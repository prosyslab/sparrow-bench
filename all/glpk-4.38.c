/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 730 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
union __anonunion_shared1_28 {
   int thickness ;
   int parent ;
};
#line 730 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
union __anonunion_shared2_29 {
   int score ;
   int order ;
};
#line 730 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
union __anonunion_shared3_30 {
   int headhash ;
   int hash ;
   int prev ;
};
#line 730 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
union __anonunion_shared4_31 {
   int degree_next ;
   int hash_next ;
};
#line 730 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
struct Colamd_Col_struct {
   int start ;
   int length ;
   union __anonunion_shared1_28 shared1 ;
   union __anonunion_shared2_29 shared2 ;
   union __anonunion_shared3_30 shared3 ;
   union __anonunion_shared4_31 shared4 ;
};
#line 730 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
typedef struct Colamd_Col_struct Colamd_Col;
#line 763 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
union __anonunion_shared1_32 {
   int degree ;
   int p ;
};
#line 763 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
union __anonunion_shared2_33 {
   int mark ;
   int first_column ;
};
#line 763 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
struct Colamd_Row_struct {
   int start ;
   int length ;
   union __anonunion_shared1_32 shared1 ;
   union __anonunion_shared2_33 shared2 ;
};
#line 763 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
typedef struct Colamd_Row_struct Colamd_Row;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 221 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
typedef void (*xerror_t)(char const   *fmt  , ...);
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.h"
struct TSP;
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.h"
typedef struct TSP TSP;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.h"
struct TSP {
   char *name ;
   int type ;
   char *comment ;
   int dimension ;
   int edge_weight_type ;
   int edge_weight_format ;
   int display_data_type ;
   double *node_x_coord ;
   double *node_y_coord ;
   double *dply_x_coord ;
   double *dply_y_coord ;
   int *tour ;
   int *edge_weight ;
};
#line 52 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
struct dsa {
   char *fname ;
   FILE *fp ;
   int seqn ;
   int c ;
   char token[256] ;
};
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
struct __anonstruct_xlong_t_26 {
   int lo ;
   int hi ;
};
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
typedef struct __anonstruct_xlong_t_26 xlong_t;
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
struct mpz_seg;
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
struct mpz {
   int val ;
   struct mpz_seg *ptr ;
};
#line 81 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
struct mpz_seg {
   unsigned short d[6] ;
   struct mpz_seg *next ;
};
#line 90 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
struct mpq {
   struct mpz p ;
   struct mpz q ;
};
#line 99 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
typedef struct mpq *mpq_t;
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.h"
struct __anonstruct_BFX_28 {
   double _opaque_bfx ;
};
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.h"
typedef struct __anonstruct_BFX_28 BFX;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpssx.h"
struct SSX;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpssx.h"
typedef struct SSX SSX;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glpssx.h"
struct SSX {
   int m ;
   int n ;
   int *type ;
   mpq_t *lb ;
   mpq_t *ub ;
   int dir ;
   mpq_t *coef ;
   int *A_ptr ;
   int *A_ind ;
   mpq_t *A_val ;
   int *stat ;
   int *Q_row ;
   int *Q_col ;
   BFX *binv ;
   mpq_t *bbar ;
   mpq_t *pi ;
   mpq_t *cbar ;
   int p ;
   mpq_t *rho ;
   mpq_t *ap ;
   int q ;
   mpq_t *aq ;
   int q_dir ;
   int p_stat ;
   mpq_t delta ;
   int it_lim ;
   int it_cnt ;
   double tm_lim ;
   double out_frq ;
   xlong_t tm_beg ;
   xlong_t tm_lag ;
};
#line 61 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TABDCA;
#line 61 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TABDCA TABDCA;
#line 1898 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TABDCA {
   int id ;
   void *link ;
   int na ;
   char **arg ;
   int nf ;
   char **name ;
   int *type ;
   double *num ;
   char **str ;
};
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.h"
struct DMP;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.h"
typedef struct DMP DMP;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.h"
struct DMP {
   void *avail[32] ;
   void *block ;
   int used ;
   xlong_t count ;
};
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
struct AVL;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
typedef struct AVL AVL;
#line 30
struct AVLNODE;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
typedef struct AVLNODE AVLNODE;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
struct AVL {
   DMP *pool ;
   AVLNODE *root ;
   int (*fcmp)(void *info , void const   *key1 , void const   *key2 ) ;
   void *info ;
   int size ;
   int height ;
};
#line 48 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
struct AVLNODE {
   void const   *key ;
   int rank ;
   int type ;
   void *link ;
   AVLNODE *up ;
   short flag ;
   short bal ;
   AVLNODE *left ;
   AVLNODE *right ;
};
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.h"
struct BFD;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.h"
typedef struct BFD BFD;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.h"
struct BFD {
   double _bfd ;
};
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
struct glp_prob;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
typedef struct glp_prob glp_prob;
#line 34
struct GLPROW;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
typedef struct GLPROW GLPROW;
#line 35
struct GLPCOL;
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
typedef struct GLPCOL GLPCOL;
#line 36
struct GLPAIJ;
#line 36 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
typedef struct GLPAIJ GLPAIJ;
#line 37
struct glp_bfcp;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
typedef struct glp_bfcp glp_bfcp;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
struct glp_prob {
   DMP *pool ;
   void *cps ;
   void *tree ;
   int lwa ;
   char *cwa ;
   char *name ;
   char *obj ;
   int dir ;
   double c0 ;
   int m_max ;
   int n_max ;
   int m ;
   int n ;
   int nnz ;
   GLPROW **row ;
   GLPCOL **col ;
   AVL *r_tree ;
   AVL *c_tree ;
   int valid ;
   int *head ;
   glp_bfcp *bfcp ;
   BFD *bfd ;
   int pbs_stat ;
   int dbs_stat ;
   double obj_val ;
   int it_cnt ;
   int some ;
   int ipt_stat ;
   double ipt_obj ;
   int mip_stat ;
   double mip_obj ;
};
#line 145 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
struct GLPROW {
   int i ;
   char *name ;
   AVLNODE *node ;
   int level ;
   unsigned char origin ;
   unsigned char klass ;
   int type ;
   double lb ;
   double ub ;
   GLPAIJ *ptr ;
   double rii ;
   int stat ;
   int bind ;
   double prim ;
   double dual ;
   double pval ;
   double dval ;
   double mipx ;
};
#line 202 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
struct GLPCOL {
   int j ;
   char *name ;
   AVLNODE *node ;
   int kind ;
   int type ;
   double lb ;
   double ub ;
   double coef ;
   GLPAIJ *ptr ;
   double sjj ;
   int stat ;
   int bind ;
   double prim ;
   double dual ;
   double pval ;
   double dval ;
   double mipx ;
};
#line 260 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
struct GLPAIJ {
   GLPROW *row ;
   GLPCOL *col ;
   double val ;
   GLPAIJ *r_prev ;
   GLPAIJ *r_next ;
   GLPAIJ *c_prev ;
   GLPAIJ *c_next ;
};
#line 89 "./../include/glpk.h"
struct glp_bfcp {
   int msg_lev ;
   int type ;
   int lu_size ;
   double piv_tol ;
   int piv_lim ;
   int suhl ;
   double eps_tol ;
   double max_gro ;
   int nfs_max ;
   double upd_tol ;
   int nrs_max ;
   int rs_size ;
   double foo_bar[38] ;
};
#line 109 "./../include/glpk.h"
struct __anonstruct_glp_smcp_28 {
   int msg_lev ;
   int meth ;
   int pricing ;
   int r_test ;
   double tol_bnd ;
   double tol_dj ;
   double tol_piv ;
   double obj_ll ;
   double obj_ul ;
   int it_lim ;
   int tm_lim ;
   int out_frq ;
   int out_dly ;
   int presolve ;
   double foo_bar[36] ;
};
#line 109 "./../include/glpk.h"
typedef struct __anonstruct_glp_smcp_28 glp_smcp;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
struct csa {
   int m ;
   int n ;
   char *type ;
   double *lb ;
   double *ub ;
   double *coef ;
   char *orig_type ;
   double *orig_lb ;
   double *orig_ub ;
   double *obj ;
   double zeta ;
   int *A_ptr ;
   int *A_ind ;
   double *A_val ;
   int *AT_ptr ;
   int *AT_ind ;
   double *AT_val ;
   int *head ;
   int *bind ;
   char *stat ;
   int valid ;
   BFD *bfd ;
   int phase ;
   xlong_t tm_beg ;
   int it_beg ;
   int it_cnt ;
   int it_dpy ;
   double *bbar ;
   double *cbar ;
   int refct ;
   char *refsp ;
   double *gamma ;
   int p ;
   double delta ;
   int trow_nnz ;
   int *trow_ind ;
   double *trow_vec ;
   double trow_max ;
   int trow_num ;
   int q ;
   double new_dq ;
   int tcol_nnz ;
   int *tcol_ind ;
   double *tcol_vec ;
   double *work1 ;
   double *work2 ;
   double *work3 ;
   double *work4 ;
};
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
struct csa___0 {
   int m ;
   int n ;
   char *type ;
   double *lb ;
   double *ub ;
   double *coef ;
   double *obj ;
   double zeta ;
   int *A_ptr ;
   int *A_ind ;
   double *A_val ;
   int *head ;
   char *stat ;
   int valid ;
   BFD *bfd ;
   int *N_ptr ;
   int *N_len ;
   int *N_ind ;
   double *N_val ;
   int phase ;
   xlong_t tm_beg ;
   int it_beg ;
   int it_cnt ;
   int it_dpy ;
   double *bbar ;
   double *cbar ;
   int refct ;
   char *refsp ;
   double *gamma ;
   int q ;
   int tcol_nnz ;
   int *tcol_ind ;
   double *tcol_vec ;
   double tcol_max ;
   int tcol_num ;
   int p ;
   int p_stat ;
   double teta ;
   int trow_nnz ;
   int *trow_ind ;
   double *trow_vec ;
   double *work1 ;
   double *work2 ;
   double *work3 ;
   double *work4 ;
};
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.h"
struct HBM;
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.h"
typedef struct HBM HBM;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.h"
struct HBM {
   char title[73] ;
   char key[9] ;
   char mxtype[4] ;
   char rhstyp[4] ;
   char ptrfmt[17] ;
   char indfmt[17] ;
   char valfmt[21] ;
   char rhsfmt[21] ;
   int totcrd ;
   int ptrcrd ;
   int indcrd ;
   int valcrd ;
   int rhscrd ;
   int nrow ;
   int ncol ;
   int nnzero ;
   int neltvl ;
   int nrhs ;
   int nrhsix ;
   int nrhsvl ;
   int nguess ;
   int nexact ;
   int *colptr ;
   int *rowind ;
   int *rhsptr ;
   int *rhsind ;
   double *values ;
   double *rhsval ;
   double *sguess ;
   double *xexact ;
};
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
struct SPM;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
typedef struct SPM SPM;
#line 30
struct SPME;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
typedef struct SPME SPME;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
struct SPM {
   int m ;
   int n ;
   DMP *pool ;
   SPME **row ;
   SPME **col ;
};
#line 46 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
struct SPME {
   int i ;
   int j ;
   double val ;
   SPME *r_prev ;
   SPME *r_next ;
   SPME *c_prev ;
   SPME *c_next ;
};
#line 64
struct PER;
#line 64 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
typedef struct PER PER;
#line 66 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
struct PER {
   int n ;
   int *row ;
   int *col ;
};
#line 34 "/usr/include/bits/setjmp.h"
typedef int __jmp_buf[6];
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_5 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_5 __sigset_t;
#line 35 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 49 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 41 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
struct XFILE;
#line 41 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
typedef struct XFILE XFILE;
#line 106 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
struct XFILE {
   int type ;
   void *fh ;
   XFILE *prev ;
   XFILE *next ;
};
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
struct _glp_data;
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
typedef struct _glp_data _glp_data;
#line 28 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
struct _glp_data {
   char *fname ;
   XFILE *fp ;
   void *jump ;
   int count ;
   int c ;
   char item[256] ;
};
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
struct SCG;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
typedef struct SCG SCG;
#line 30
struct SCGRIB;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
typedef struct SCGRIB SCGRIB;
#line 31
struct SCGCQE;
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
typedef struct SCGCQE SCGCQE;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
struct SCG {
   DMP *pool ;
   int n_max ;
   int nc_max ;
   int n ;
   int nc ;
   SCGRIB **i_ptr ;
   SCGRIB **j_ptr ;
   SCGCQE **c_ptr ;
   SCGCQE **v_ptr ;
   char *flag ;
};
#line 61 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
struct SCGRIB {
   int i ;
   int j ;
   SCGRIB *i_prev ;
   SCGRIB *i_next ;
   SCGRIB *j_prev ;
   SCGRIB *j_next ;
};
#line 77 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
struct SCGCQE {
   int c ;
   int i ;
   SCGCQE *c_next ;
   SCGCQE *v_next ;
};
#line 212 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
struct dsa___0 {
   SCG *g ;
   int i ;
   int nadj ;
   int *adj ;
   char *flag ;
   int const   *wt ;
   int record ;
   int rec_level ;
   int *rec ;
   int *clique ;
   int *set ;
};
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.h"
struct SCF;
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.h"
typedef struct SCF SCF;
#line 72 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.h"
struct SCF {
   int n_max ;
   int n ;
   double *f ;
   double *u ;
   int *p ;
   int t_opt ;
   int rank ;
   double *c ;
   double *w ;
};
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glprng.h"
struct RNG;
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glprng.h"
typedef struct RNG RNG;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glprng.h"
struct RNG {
   int A[56] ;
   int *fptr ;
};
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
struct NPP;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
typedef struct NPP NPP;
#line 30
struct NPPROW;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
typedef struct NPPROW NPPROW;
#line 31
struct NPPCOL;
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
typedef struct NPPCOL NPPCOL;
#line 32
struct NPPAIJ;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
typedef struct NPPAIJ NPPAIJ;
#line 33
struct NPPTSE;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
typedef struct NPPTSE NPPTSE;
#line 34
struct NPPLFE;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
typedef struct NPPLFE NPPLFE;
#line 36 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
struct NPP {
   int orig_dir ;
   int orig_m ;
   int orig_n ;
   int orig_nnz ;
   DMP *pool ;
   char *name ;
   char *obj ;
   double c0 ;
   int nrows ;
   int ncols ;
   NPPROW *r_head ;
   NPPROW *r_tail ;
   NPPCOL *c_head ;
   NPPCOL *c_tail ;
   DMP *stack ;
   NPPTSE *top ;
   int m ;
   int n ;
   int nnz ;
   int *row_ref ;
   int *col_ref ;
   int sol ;
   int scaling ;
   int p_stat ;
   int d_stat ;
   int t_stat ;
   int i_stat ;
   char *r_stat ;
   double *r_prim ;
   double *r_dual ;
   char *c_stat ;
   double *c_prim ;
   double *c_dual ;
};
#line 157 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
struct NPPROW {
   int i ;
   char *name ;
   double lb ;
   double ub ;
   NPPAIJ *ptr ;
   int temp ;
   NPPROW *prev ;
   NPPROW *next ;
};
#line 178 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
struct NPPCOL {
   int j ;
   char *name ;
   int kind ;
   double lb ;
   double ub ;
   double coef ;
   NPPAIJ *ptr ;
   NPPCOL *prev ;
   NPPCOL *next ;
};
#line 203 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
struct NPPAIJ {
   NPPROW *row ;
   NPPCOL *col ;
   double val ;
   NPPAIJ *r_prev ;
   NPPAIJ *r_next ;
   NPPAIJ *c_prev ;
   NPPAIJ *c_next ;
};
#line 221 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
struct NPPTSE {
   void (*func)(NPP *npp , void *info ) ;
   void *info ;
   NPPTSE *link ;
};
#line 231 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
struct NPPLFE {
   int ref ;
   double val ;
   NPPLFE *next ;
};
#line 36 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct free_row {
   int p ;
   NPPLFE *ptr ;
};
#line 106 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct ineq_row {
   int p ;
   int s ;
};
#line 238 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct free_col {
   int q ;
   int j ;
};
#line 341 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct bnd_col {
   int q ;
   double b ;
   NPPLFE *ptr ;
};
#line 540 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct dbnd_col {
   int q ;
   int j ;
};
#line 642 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct fixed_col {
   int q ;
   double s ;
   double c ;
   NPPLFE *ptr ;
};
#line 729 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct empty_row {
   int p ;
};
#line 780 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct empty_col {
   int q ;
   int stat ;
};
#line 872 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
struct sngl_row {
   int p ;
   int q ;
   double apq ;
};
#line 711 "./../include/glpk.h"
struct _glp_graph;
#line 711 "./../include/glpk.h"
typedef struct _glp_graph glp_graph;
#line 712
struct _glp_vertex;
#line 712 "./../include/glpk.h"
typedef struct _glp_vertex glp_vertex;
#line 713
struct _glp_arc;
#line 713 "./../include/glpk.h"
typedef struct _glp_arc glp_arc;
#line 715 "./../include/glpk.h"
struct _glp_graph {
   void *pool ;
   char *name ;
   int nv_max ;
   int nv ;
   int na ;
   glp_vertex **v ;
   void *index ;
   int v_size ;
   int a_size ;
};
#line 739 "./../include/glpk.h"
struct _glp_vertex {
   int i ;
   char *name ;
   void *entry ;
   void *data ;
   void *temp ;
   glp_arc *in ;
   glp_arc *out ;
};
#line 760 "./../include/glpk.h"
struct _glp_arc {
   glp_vertex *tail ;
   glp_vertex *head ;
   void *data ;
   void *temp ;
   glp_arc *t_prev ;
   glp_arc *t_next ;
   glp_arc *h_prev ;
   glp_arc *h_next ;
};
#line 117 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
struct EDGE;
#line 117 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
struct VERTEX {
   struct EDGE **edgelist ;
   struct EDGE **current ;
   int degree ;
   int index ;
};
#line 117 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
typedef struct VERTEX vertex;
#line 128 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
struct EDGE {
   int from ;
   int to ;
   int cap ;
};
#line 128 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
typedef struct EDGE edge;
#line 135 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
struct NETWORK {
   struct NETWORK *next ;
   struct NETWORK *prev ;
   int vertnum ;
   int edgenum ;
   vertex *verts ;
   edge *edges ;
   int source ;
   int sink ;
};
#line 135 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
typedef struct NETWORK network;
#line 149 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
struct csa___1 {
   glp_graph *G ;
   int *s ;
   int *t ;
   int a_cap ;
   RNG *rand ;
   network *N ;
   int *Parr ;
   int A ;
   int AA ;
   int C2AA ;
   int Ec ;
};
#line 137 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
struct stat_para {
   int distribution ;
   double parameter[5] ;
};
#line 147 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
struct arcs {
   int from ;
   int to ;
   int cost ;
   int u ;
};
#line 158 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
struct imbalance {
   int node ;
   int supply ;
};
#line 165 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
struct csa___2 {
   glp_graph *G ;
   int v_rhs ;
   int a_cap ;
   int a_cost ;
   int seed ;
   int seed_original ;
   int two_way ;
   int n_node ;
   int n_arc ;
   int n_grid_arc ;
   int n_source ;
   int n_sink ;
   int avg_degree ;
   int t_supply ;
   int n1 ;
   int n2 ;
   struct imbalance *source_list ;
   struct imbalance *sink_list ;
   struct stat_para arc_costs ;
   struct stat_para capacities ;
   struct arcs *arc_list ;
};
#line 104 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
struct csa___3 {
   glp_graph *G ;
   int v_rhs ;
   int a_cap ;
   int a_cost ;
   int nodes ;
   int iarcs ;
   int mincst ;
   int maxcst ;
   int itsup ;
   int nsorc ;
   int nsink ;
   int nonsor ;
   int nfsink ;
   int narcs ;
   int nsort ;
   int nftsor ;
   int ipcap ;
   int mincap ;
   int maxcap ;
   int ktl ;
   int nodlft ;
   int *ipred ;
   int *ihead ;
   int *itail ;
   int *iflag ;
   int *isup ;
   int *lsinks ;
   int mult ;
   int modul ;
   int i15 ;
   int i16 ;
   int jran ;
};
#line 264 "./../include/glpk.h"
struct __anonstruct_glp_mpscp_33 {
   int blank ;
   char *obj_name ;
   double tol_mps ;
   double foo_bar[17] ;
};
#line 264 "./../include/glpk.h"
typedef struct __anonstruct_glp_mpscp_33 glp_mpscp;
#line 101 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
struct csa___4 {
   glp_prob *P ;
   int deck ;
   glp_mpscp const   *parm ;
   char const   *fname ;
   XFILE *fp ;
   jmp_buf jump ;
   int recno ;
   int recpos ;
   int c ;
   int fldno ;
   char field[256] ;
   int w80 ;
   int wef ;
   int obj_row ;
   void *work1 ;
   void *work2 ;
   void *work3 ;
};
#line 1048 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
struct csa1 {
   glp_prob *P ;
   int deck ;
   glp_mpscp const   *parm ;
   char field[256] ;
};
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct MPL;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct MPL MPL;
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef char STRING;
#line 32
struct SYMBOL;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct SYMBOL SYMBOL;
#line 33
struct TUPLE;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TUPLE TUPLE;
#line 34
struct ARRAY;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct ARRAY ELEMSET;
#line 35
struct ELEMVAR;
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct ELEMVAR ELEMVAR;
#line 36
struct FORMULA;
#line 36 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct FORMULA FORMULA;
#line 37
struct ELEMCON;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct ELEMCON ELEMCON;
#line 38
union VALUE;
#line 38 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef union VALUE VALUE;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct ARRAY ARRAY;
#line 40
struct MEMBER;
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct MEMBER MEMBER;
#line 46
struct DOMAIN1;
#line 46 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct DOMAIN1 DOMAIN1;
#line 47
struct DOMAIN_BLOCK;
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct DOMAIN_BLOCK DOMAIN_BLOCK;
#line 48
struct DOMAIN_SLOT;
#line 48 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct DOMAIN_SLOT DOMAIN_SLOT;
#line 49
struct SET;
#line 49 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct SET SET;
#line 50
struct WITHIN;
#line 50 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct WITHIN WITHIN;
#line 51
struct GADGET;
#line 51 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct GADGET GADGET;
#line 52
struct PARAMETER;
#line 52 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct PARAMETER PARAMETER;
#line 53
struct CONDITION;
#line 53 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct CONDITION CONDITION;
#line 54
struct VARIABLE;
#line 54 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct VARIABLE VARIABLE;
#line 55
struct CONSTRAINT;
#line 55 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct CONSTRAINT CONSTRAINT;
#line 56
struct TABLE;
#line 56 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TABLE TABLE;
#line 57
struct TABARG;
#line 57 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TABARG TABARG;
#line 58
struct TABFLD;
#line 58 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TABFLD TABFLD;
#line 59
struct TABIN;
#line 59 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TABIN TABIN;
#line 60
struct TABOUT;
#line 60 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TABOUT TABOUT;
#line 62
union OPERANDS;
#line 62 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef union OPERANDS OPERANDS;
#line 63
struct ARG_LIST;
#line 63 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct ARG_LIST ARG_LIST;
#line 64
struct CODE;
#line 64 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct CODE CODE;
#line 65
struct CHECK;
#line 65 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct CHECK CHECK;
#line 66
struct DISPLAY;
#line 66 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct DISPLAY DISPLAY;
#line 67
struct DISPLAY1;
#line 67 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct DISPLAY1 DISPLAY1;
#line 68
struct PRINTF;
#line 68 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct PRINTF PRINTF;
#line 69
struct PRINTF1;
#line 69 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct PRINTF1 PRINTF1;
#line 70
struct FOR;
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct FOR FOR;
#line 71
struct STATEMENT;
#line 71 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct STATEMENT STATEMENT;
#line 117 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct MPL {
   int line ;
   int c ;
   int token ;
   int imlen ;
   char *image ;
   double value ;
   int b_token ;
   int b_imlen ;
   char *b_image ;
   double b_value ;
   int f_dots ;
   int f_scan ;
   int f_token ;
   int f_imlen ;
   char *f_image ;
   double f_value ;
   char *context ;
   int c_ptr ;
   int flag_d ;
   DMP *pool ;
   AVL *tree ;
   STATEMENT *model ;
   int flag_x ;
   int as_within ;
   int as_in ;
   int as_binary ;
   int flag_s ;
   DMP *strings ;
   DMP *symbols ;
   DMP *tuples ;
   DMP *arrays ;
   DMP *members ;
   DMP *elemvars ;
   DMP *formulae ;
   DMP *elemcons ;
   ARRAY *a_list ;
   char *sym_buf ;
   char *tup_buf ;
   RNG *rand ;
   int flag_p ;
   STATEMENT *stmt ;
   TABDCA *dca ;
   int m ;
   int n ;
   ELEMCON **row ;
   ELEMVAR **col ;
   FILE *in_fp ;
   char *in_file ;
   FILE *out_fp ;
   char *out_file ;
   char *out_buf ;
   int out_cnt ;
   FILE *prt_fp ;
   char *prt_file ;
   jmp_buf jump ;
   int phase ;
   char *mod_file ;
   char *mpl_buf ;
};
#line 927 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct SYMBOL {
   double num ;
   STRING *str ;
};
#line 987 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TUPLE {
   SYMBOL *sym ;
   TUPLE *next ;
};
#line 1165 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct ELEMVAR {
   int j ;
   VARIABLE *var ;
   MEMBER *memb ;
   double lbnd ;
   double ubnd ;
   double temp ;
   double value ;
};
#line 1190 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct FORMULA {
   double coef ;
   ELEMVAR *var ;
   FORMULA *next ;
};
#line 1255 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct ELEMCON {
   int i ;
   CONSTRAINT *con ;
   MEMBER *memb ;
   FORMULA *form ;
   double lbnd ;
   double ubnd ;
};
#line 1277 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
union VALUE {
   void *none ;
   double num ;
   SYMBOL *sym ;
   int bit ;
   TUPLE *tuple ;
   ELEMSET *set ;
   ELEMVAR *var ;
   FORMULA *form ;
   ELEMCON *con ;
};
#line 1315 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct ARRAY {
   int type ;
   int dim ;
   int size ;
   MEMBER *head ;
   MEMBER *tail ;
   AVL *tree ;
   ARRAY *prev ;
   ARRAY *next ;
};
#line 1349 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct MEMBER {
   TUPLE *tuple ;
   MEMBER *next ;
   VALUE value ;
};
#line 1392 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct DOMAIN1 {
   DOMAIN_BLOCK *list ;
   CODE *code ;
};
#line 1406 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct DOMAIN_BLOCK {
   DOMAIN_SLOT *list ;
   CODE *code ;
   TUPLE *backup ;
   DOMAIN_BLOCK *next ;
};
#line 1428 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct DOMAIN_SLOT {
   char *name ;
   CODE *code ;
   SYMBOL *value ;
   CODE *list ;
   DOMAIN_SLOT *next ;
};
#line 1513 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct SET {
   char *name ;
   char *alias ;
   int dim ;
   DOMAIN1 *domain ;
   int dimen ;
   WITHIN *within ;
   CODE *assign ;
   CODE *option ;
   GADGET *gadget ;
   int data ;
   ARRAY *array ;
};
#line 1547 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct WITHIN {
   CODE *code ;
   WITHIN *next ;
};
#line 1555 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct GADGET {
   SET *set ;
   int ind[20] ;
};
#line 1600 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct PARAMETER {
   char *name ;
   char *alias ;
   int dim ;
   DOMAIN1 *domain ;
   int type ;
   CONDITION *cond ;
   WITHIN *in ;
   CODE *assign ;
   CODE *option ;
   int data ;
   SYMBOL *defval ;
   ARRAY *array ;
};
#line 1640 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct CONDITION {
   int rho ;
   CODE *code ;
   CONDITION *next ;
};
#line 1718 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct VARIABLE {
   char *name ;
   char *alias ;
   int dim ;
   DOMAIN1 *domain ;
   int type ;
   CODE *lbnd ;
   CODE *ubnd ;
   ARRAY *array ;
};
#line 1774 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct CONSTRAINT {
   char *name ;
   char *alias ;
   int dim ;
   DOMAIN1 *domain ;
   int type ;
   CODE *code ;
   CODE *lbnd ;
   CODE *ubnd ;
   ARRAY *array ;
};
#line 1832 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_in_29 {
   SET *set ;
   TABFLD *fld ;
   TABIN *list ;
};
#line 1832 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_out_30 {
   DOMAIN1 *domain ;
   TABOUT *list ;
};
#line 1832 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
union __anonunion_u_28 {
   struct __anonstruct_in_29 in ;
   struct __anonstruct_out_30 out ;
};
#line 1832 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TABLE {
   char *name ;
   char *alias ;
   int type ;
   TABARG *arg ;
   union __anonunion_u_28 u ;
};
#line 1862 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TABARG {
   CODE *code ;
   TABARG *next ;
};
#line 1870 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TABFLD {
   char *name ;
   TABFLD *next ;
};
#line 1878 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TABIN {
   PARAMETER *par ;
   char *name ;
   TABIN *next ;
};
#line 1888 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct TABOUT {
   CODE *code ;
   char *name ;
   TABOUT *next ;
};
#line 1966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_index_31 {
   DOMAIN_SLOT *slot ;
   CODE *next ;
};
#line 1966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_par_32 {
   PARAMETER *par ;
   ARG_LIST *list ;
};
#line 1966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_set_33 {
   SET *set ;
   ARG_LIST *list ;
};
#line 1966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_var_34 {
   VARIABLE *var ;
   ARG_LIST *list ;
};
#line 1966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_arg_35 {
   CODE *x ;
   CODE *y ;
   CODE *z ;
};
#line 1966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct __anonstruct_loop_36 {
   DOMAIN1 *domain ;
   CODE *x ;
};
#line 1966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
union OPERANDS {
   double num ;
   char *str ;
   struct __anonstruct_index_31 index ;
   struct __anonstruct_par_32 par ;
   struct __anonstruct_set_33 set ;
   struct __anonstruct_var_34 var ;
   ARG_LIST *list ;
   DOMAIN_BLOCK *slice ;
   struct __anonstruct_arg_35 arg ;
   struct __anonstruct_loop_36 loop ;
};
#line 2031 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct ARG_LIST {
   CODE *x ;
   ARG_LIST *next ;
};
#line 2039 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct CODE {
   int op ;
   OPERANDS arg ;
   int type ;
   int dim ;
   CODE *up ;
   int vflag ;
   int valid ;
   VALUE value ;
};
#line 2213 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct CHECK {
   DOMAIN1 *domain ;
   CODE *code ;
};
#line 2221 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct DISPLAY {
   DOMAIN1 *domain ;
   DISPLAY1 *list ;
};
#line 2229 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
union __anonunion_u_37 {
   DOMAIN_SLOT *slot ;
   SET *set ;
   PARAMETER *par ;
   VARIABLE *var ;
   CONSTRAINT *con ;
   CODE *code ;
};
#line 2229 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct DISPLAY1 {
   int type ;
   union __anonunion_u_37 u ;
   ARG_LIST *list ;
   DISPLAY1 *next ;
};
#line 2254 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct PRINTF {
   DOMAIN1 *domain ;
   CODE *fmt ;
   PRINTF1 *list ;
   CODE *fname ;
   int app ;
};
#line 2269 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct PRINTF1 {
   CODE *code ;
   PRINTF1 *next ;
};
#line 2277 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct FOR {
   DOMAIN1 *domain ;
   STATEMENT *list ;
};
#line 2286 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
union __anonunion_u_38 {
   SET *set ;
   PARAMETER *par ;
   VARIABLE *var ;
   CONSTRAINT *con ;
   TABLE *tab ;
   void *slv ;
   CHECK *chk ;
   DISPLAY *dpy ;
   PRINTF *prt ;
   FOR *fur ;
};
#line 2286 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
struct STATEMENT {
   int line ;
   int type ;
   union __anonunion_u_38 u ;
   STATEMENT *next ;
};
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
struct csv {
   int mode ;
   char *fname ;
   FILE *fp ;
   jmp_buf jump ;
   int count ;
   int c ;
   int what ;
   char field[101] ;
   int nf ;
   int ref[51] ;
};
#line 407 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
struct dbf {
   int mode ;
   char *fname ;
   FILE *fp ;
   jmp_buf jump ;
   int offset ;
   int count ;
   int nf ;
   int ref[51] ;
   int type[51] ;
   int len[51] ;
   int prec[51] ;
};
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 1933 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct eval_domain_info {
   DOMAIN1 *domain ;
   DOMAIN_BLOCK *block ;
   TUPLE *tuple ;
   void *info ;
   void (*func)(MPL *mpl , void *info ) ;
   int failure ;
};
#line 2073 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct loop_domain_info {
   DOMAIN1 *domain ;
   DOMAIN_BLOCK *block ;
   int looping ;
   void *info ;
   int (*func)(MPL *mpl , void *info ) ;
};
#line 2396 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct eval_set_info {
   SET *set ;
   TUPLE *tuple ;
   MEMBER *memb ;
   ELEMSET *refer ;
};
#line 2730 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct eval_num_info {
   PARAMETER *par ;
   TUPLE *tuple ;
   MEMBER *memb ;
   double value ;
};
#line 2965 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct eval_sym_info {
   PARAMETER *par ;
   TUPLE *tuple ;
   MEMBER *memb ;
   SYMBOL *value ;
};
#line 3167 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct eval_var_info {
   VARIABLE *var ;
   TUPLE *tuple ;
   ELEMVAR *refer ;
};
#line 3349 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct eval_con_info {
   CONSTRAINT *con ;
   TUPLE *tuple ;
   ELEMCON *refer ;
};
#line 3439 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct iter_num_info {
   CODE *code ;
   double value ;
};
#line 3950 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct iter_log_info {
   CODE *code ;
   int value ;
};
#line 4249 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct iter_set_info {
   CODE *code ;
   ELEMSET *value ;
};
#line 4559 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
struct iter_form_info {
   CODE *code ;
   FORMULA *value ;
   FORMULA *tail ;
};
#line 72 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
typedef struct TUPLE SLICE;
#line 1464 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
struct __anonstruct_list_39 {
   char *name ;
   CODE *code ;
};
#line 76 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
struct LUX;
#line 76 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
typedef struct LUX LUX;
#line 77
struct LUXELM;
#line 77 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
typedef struct LUXELM LUXELM;
#line 78
struct LUXWKA;
#line 78 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
typedef struct LUXWKA LUXWKA;
#line 80 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
struct LUX {
   int n ;
   DMP *pool ;
   LUXELM **F_row ;
   LUXELM **F_col ;
   mpq_t *V_piv ;
   LUXELM **V_row ;
   LUXELM **V_col ;
   int *P_row ;
   int *P_col ;
   int *Q_row ;
   int *Q_col ;
   int rank ;
};
#line 132 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
struct LUXELM {
   int i ;
   int j ;
   mpq_t val ;
   LUXELM *r_prev ;
   LUXELM *r_next ;
   LUXELM *c_prev ;
   LUXELM *c_next ;
};
#line 150 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
struct LUXWKA {
   int *R_len ;
   int *R_head ;
   int *R_prev ;
   int *R_next ;
   int *C_len ;
   int *C_head ;
   int *C_prev ;
   int *C_next ;
};
#line 72 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.h"
struct LUF;
#line 72 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.h"
typedef struct LUF LUF;
#line 74 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.h"
struct LUF {
   int n_max ;
   int n ;
   int valid ;
   int *fr_ptr ;
   int *fr_len ;
   int *fc_ptr ;
   int *fc_len ;
   int *vr_ptr ;
   int *vr_len ;
   int *vr_cap ;
   double *vr_piv ;
   int *vc_ptr ;
   int *vc_len ;
   int *vc_cap ;
   int *pp_row ;
   int *pp_col ;
   int *qq_row ;
   int *qq_col ;
   int sv_size ;
   int sv_beg ;
   int sv_end ;
   int *sv_ind ;
   double *sv_val ;
   int sv_head ;
   int sv_tail ;
   int *sv_prev ;
   int *sv_next ;
   double *vr_max ;
   int *rs_head ;
   int *rs_prev ;
   int *rs_next ;
   int *cs_head ;
   int *cs_prev ;
   int *cs_next ;
   int *flag ;
   double *work ;
   int new_sva ;
   double piv_tol ;
   int piv_lim ;
   int suhl ;
   double eps_tol ;
   double max_gro ;
   int nnz_a ;
   int nnz_f ;
   int nnz_v ;
   double max_a ;
   double big_v ;
   int rank ;
};
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPP;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
typedef struct IPP IPP;
#line 31
struct IPPROW;
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
typedef struct IPPROW IPPROW;
#line 32
struct IPPCOL;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
typedef struct IPPCOL IPPCOL;
#line 33
struct IPPAIJ;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
typedef struct IPPAIJ IPPAIJ;
#line 34
struct IPPTQE;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
typedef struct IPPTQE IPPTQE;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPP {
   int orig_m ;
   int orig_n ;
   int orig_nnz ;
   int orig_dir ;
   int ncols ;
   DMP *row_pool ;
   DMP *col_pool ;
   DMP *aij_pool ;
   IPPROW *row_ptr ;
   IPPCOL *col_ptr ;
   IPPROW *row_que ;
   IPPCOL *col_que ;
   double c0 ;
   DMP *tqe_pool ;
   IPPTQE *tqe_list ;
   int *col_stat ;
   double *col_mipx ;
};
#line 96 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPPROW {
   double lb ;
   double ub ;
   IPPAIJ *ptr ;
   int temp ;
   IPPROW *prev ;
   IPPROW *next ;
   int q_flag ;
   IPPROW *q_prev ;
   IPPROW *q_next ;
};
#line 119 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPPCOL {
   int j ;
   int i_flag ;
   double lb ;
   double ub ;
   double c ;
   IPPAIJ *ptr ;
   int temp ;
   IPPCOL *prev ;
   IPPCOL *next ;
   int q_flag ;
   IPPCOL *q_prev ;
   IPPCOL *q_next ;
};
#line 150 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPPAIJ {
   IPPROW *row ;
   IPPCOL *col ;
   double val ;
   IPPAIJ *r_prev ;
   IPPAIJ *r_next ;
   IPPAIJ *c_prev ;
   IPPAIJ *c_next ;
};
#line 168 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPPTQE {
   int type ;
   void *info ;
   IPPTQE *next ;
};
#line 140 "./../include/glpk.h"
struct __anonstruct_glp_iptcp_29 {
   int msg_lev ;
   int ord_alg ;
   double foo_bar[48] ;
};
#line 140 "./../include/glpk.h"
typedef struct __anonstruct_glp_iptcp_29 glp_iptcp;
#line 153 "./../include/glpk.h"
struct __anonstruct_glp_tree_30 {
   double _opaque_tree ;
};
#line 153 "./../include/glpk.h"
typedef struct __anonstruct_glp_tree_30 glp_tree;
#line 157 "./../include/glpk.h"
struct __anonstruct_glp_iocp_31 {
   int msg_lev ;
   int br_tech ;
   int bt_tech ;
   double tol_int ;
   double tol_obj ;
   int tm_lim ;
   int out_frq ;
   int out_dly ;
   void (*cb_func)(glp_tree *T , void *info ) ;
   void *cb_info ;
   int cb_size ;
   int pp_tech ;
   double mip_gap ;
   int mir_cuts ;
   int gmi_cuts ;
   int cov_cuts ;
   int clq_cuts ;
   int presolve ;
   int binarize ;
   int fp_heur ;
   double foo_bar[30] ;
};
#line 157 "./../include/glpk.h"
typedef struct __anonstruct_glp_iocp_31 glp_iocp;
#line 278 "./../include/glpk.h"
struct __anonstruct_glp_tran_34 {
   double _opaque_tran ;
};
#line 278 "./../include/glpk.h"
typedef struct __anonstruct_glp_tran_34 glp_tran;
#line 1027 "./../include/glpk.h"
struct __anonstruct_LPXKKT_37 {
   double pe_ae_max ;
   int pe_ae_row ;
   double pe_re_max ;
   int pe_re_row ;
   int pe_quality ;
   double pb_ae_max ;
   int pb_ae_ind ;
   double pb_re_max ;
   int pb_re_ind ;
   int pb_quality ;
   double de_ae_max ;
   int de_ae_col ;
   double de_re_max ;
   int de_re_col ;
   int de_quality ;
   double db_ae_max ;
   int db_ae_ind ;
   double db_re_max ;
   int db_re_ind ;
   int db_quality ;
   double cs_ae_max ;
   int cs_ae_ind ;
   double cs_re_max ;
   int cs_re_ind ;
   int cs_quality ;
};
#line 1027 "./../include/glpk.h"
typedef struct __anonstruct_LPXKKT_37 LPXKKT;
#line 282 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
struct LPXCPS {
   int msg_lev ;
   int scale ;
   int dual ;
   int price ;
   double relax ;
   double tol_bnd ;
   double tol_dj ;
   double tol_piv ;
   int round ;
   double obj_ll ;
   double obj_ul ;
   int it_lim ;
   double tm_lim ;
   int out_frq ;
   double out_dly ;
   int branch ;
   int btrack ;
   double tol_int ;
   double tol_obj ;
   int mps_info ;
   int mps_obj ;
   int mps_orig ;
   int mps_wide ;
   int mps_free ;
   int mps_skip ;
   int lpt_orig ;
   int presol ;
   int binarize ;
   int use_cuts ;
   double mip_gap ;
};
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPP;
#line 29 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
typedef struct LPP LPP;
#line 30
struct LPPROW;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
typedef struct LPPROW LPPROW;
#line 31
struct LPPCOL;
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
typedef struct LPPCOL LPPCOL;
#line 32
struct LPPAIJ;
#line 32 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
typedef struct LPPAIJ LPPAIJ;
#line 33
struct LPPTQE;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
typedef struct LPPTQE LPPTQE;
#line 34
struct LPPLFE;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
typedef struct LPPLFE LPPLFE;
#line 35
struct LPPLFX;
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
typedef struct LPPLFX LPPLFX;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPP {
   int orig_m ;
   int orig_n ;
   int orig_nnz ;
   int orig_dir ;
   int nrows ;
   int ncols ;
   DMP *row_pool ;
   DMP *col_pool ;
   DMP *aij_pool ;
   LPPROW *row_ptr ;
   LPPCOL *col_ptr ;
   LPPROW *row_que ;
   LPPCOL *col_que ;
   double c0 ;
   DMP *tqe_pool ;
   LPPTQE *tqe_list ;
   int m ;
   int n ;
   int nnz ;
   int *row_ref ;
   int *col_ref ;
   int *row_stat ;
   double *row_prim ;
   double *row_dual ;
   int *col_stat ;
   double *col_prim ;
   double *col_dual ;
};
#line 140 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPPROW {
   int i ;
   double lb ;
   double ub ;
   LPPAIJ *ptr ;
   int temp ;
   LPPROW *prev ;
   LPPROW *next ;
   int q_flag ;
   LPPROW *q_prev ;
   LPPROW *q_next ;
};
#line 167 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPPCOL {
   int j ;
   double lb ;
   double ub ;
   double c ;
   LPPAIJ *ptr ;
   LPPCOL *prev ;
   LPPCOL *next ;
   int q_flag ;
   LPPCOL *q_prev ;
   LPPCOL *q_next ;
};
#line 194 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPPAIJ {
   LPPROW *row ;
   LPPCOL *col ;
   double val ;
   LPPAIJ *r_prev ;
   LPPAIJ *r_next ;
   LPPAIJ *c_prev ;
   LPPAIJ *c_next ;
};
#line 212 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPPTQE {
   int type ;
   void *info ;
   LPPTQE *next ;
};
#line 232 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPPLFE {
   int ref ;
   double val ;
   LPPLFE *next ;
};
#line 242 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
struct LPPLFX {
   int ref ;
   int flag ;
   double val ;
   LPPLFX *next ;
};
#line 49 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_EMPTY_ROW_38 {
   int p ;
};
#line 49 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_EMPTY_ROW_38 EMPTY_ROW;
#line 108 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_EMPTY_COL_39 {
   int q ;
   int stat ;
   double prim ;
   double dual ;
};
#line 108 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_EMPTY_COL_39 EMPTY_COL;
#line 199 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_FREE_ROW_40 {
   int p ;
   LPPLFE *ptr ;
};
#line 199 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_FREE_ROW_40 FREE_ROW;
#line 309 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_FIXED_COL_41 {
   int q ;
   double val ;
   double c ;
   LPPLFE *ptr ;
};
#line 309 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_FIXED_COL_41 FIXED_COL;
#line 416 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_ROW_SNGTON1_42 {
   int p ;
   int q ;
   double apq ;
};
#line 416 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_ROW_SNGTON1_42 ROW_SNGTON1;
#line 540 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_ROW_SNGTON2_43 {
   int p ;
   int q ;
   double apq ;
   int lb_changed ;
   int ub_changed ;
};
#line 540 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_ROW_SNGTON2_43 ROW_SNGTON2;
#line 828 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_COL_SNGTON1_44 {
   int p ;
   int q ;
   double rhs ;
   double c ;
   double apq ;
};
#line 828 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_COL_SNGTON1_44 COL_SNGTON1;
#line 1018 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_COL_SNGTON2_45 {
   int p ;
   int q ;
   int stat ;
};
#line 1018 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_COL_SNGTON2_45 COL_SNGTON2;
#line 1238 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
struct __anonstruct_FORCING_ROW_46 {
   int p ;
   int stat ;
   double bnd ;
   LPPLFX *ptr ;
};
#line 1238 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
typedef struct __anonstruct_FORCING_ROW_46 FORCING_ROW;
#line 81 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.h"
struct LPF;
#line 81 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.h"
typedef struct LPF LPF;
#line 83 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.h"
struct LPF {
   int valid ;
   int m0_max ;
   int m0 ;
   LUF *luf ;
   int m ;
   double *B ;
   int n_max ;
   int n ;
   int *R_ptr ;
   int *R_len ;
   int *S_ptr ;
   int *S_len ;
   SCF *scf ;
   int *P_row ;
   int *P_col ;
   int *Q_row ;
   int *Q_col ;
   int v_size ;
   int v_ptr ;
   int *v_ind ;
   double *v_val ;
   double *work1 ;
   double *work2 ;
};
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
struct LIBENV;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
typedef struct LIBENV LIBENV;
#line 40
struct LIBMEM;
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
typedef struct LIBMEM LIBMEM;
#line 43 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
struct LIBENV {
   char version[8] ;
   xlong_t mem_limit ;
   LIBMEM *mem_ptr ;
   int mem_count ;
   int mem_cpeak ;
   xlong_t mem_total ;
   xlong_t mem_tpeak ;
   int term_out ;
   int (*term_hook)(void *info , char const   *s ) ;
   void *term_info ;
   char err_msg[1001] ;
   XFILE *file_ptr ;
   void *log_file ;
   char const   *err_file ;
   int err_line ;
   xlong_t t_init ;
   xlong_t t_last ;
   char c_init[sizeof(double )] ;
   void *h_odbc ;
   void *h_mysql ;
};
#line 94 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
struct LIBMEM {
   int flag ;
   int size ;
   LIBMEM *prev ;
   LIBMEM *next ;
};
#line 36 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
struct __anonstruct_xldiv_t_27 {
   xlong_t quot ;
   xlong_t rem ;
};
#line 36 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
typedef struct __anonstruct_xldiv_t_27 xldiv_t;
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPPLFE;
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
typedef struct IPPLFE IPPLFE;
#line 182 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
struct IPPLFE {
   int ref ;
   double val ;
   IPPLFE *next ;
};
#line 89 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
struct fixed_col___0 {
   int q ;
   double s ;
};
#line 915 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
struct shift_col {
   int q ;
   double s ;
};
#line 993 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
struct nonbin_col {
   int q ;
   IPPLFE *ptr ;
};
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
struct csa___5 {
   int m ;
   int n ;
   int *A_ptr ;
   int *A_ind ;
   double *A_val ;
   double *b ;
   double *c ;
   double *x ;
   double *y ;
   double *z ;
   glp_iptcp const   *parm ;
   double *D ;
   int *P ;
   int *S_ptr ;
   int *S_ind ;
   double *S_val ;
   double *S_diag ;
   int *U_ptr ;
   int *U_ind ;
   double *U_val ;
   double *U_diag ;
   int iter ;
   double obj ;
   double rpi ;
   double rdi ;
   double gap ;
   double phi ;
   double mu ;
   double rmu ;
   double rmu0 ;
   double *phi_min ;
   int best_iter ;
   double *best_x ;
   double *best_y ;
   double *best_z ;
   double best_obj ;
   double *dx_aff ;
   double *dy_aff ;
   double *dz_aff ;
   double alfa_aff_p ;
   double alfa_aff_d ;
   double mu_aff ;
   double sigma ;
   double *dx_cc ;
   double *dy_cc ;
   double *dz_cc ;
   double *dx ;
   double *dy ;
   double *dz ;
   double alfa_max_p ;
   double alfa_max_d ;
};
#line 28 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct glp_tree;
#line 28 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct glp_tree glp_tree___0;
#line 157 "./../include/glpk.h"
struct __anonstruct_glp_iocp_30 {
   int msg_lev ;
   int br_tech ;
   int bt_tech ;
   double tol_int ;
   double tol_obj ;
   int tm_lim ;
   int out_frq ;
   int out_dly ;
   void (*cb_func)(glp_tree___0 *T , void *info ) ;
   void *cb_info ;
   int cb_size ;
   int pp_tech ;
   double mip_gap ;
   int mir_cuts ;
   int gmi_cuts ;
   int cov_cuts ;
   int clq_cuts ;
   int presolve ;
   int binarize ;
   int fp_heur ;
   double foo_bar[30] ;
};
#line 157 "./../include/glpk.h"
typedef struct __anonstruct_glp_iocp_30 glp_iocp___0;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSLOT;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSLOT IOSLOT;
#line 34
struct IOSNPD;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSNPD IOSNPD;
#line 35
struct IOSBND;
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSBND IOSBND;
#line 36
struct IOSTAT;
#line 36 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSTAT IOSTAT;
#line 37
struct IOSROW;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSROW IOSROW;
#line 38
struct IOSAIJ;
#line 38 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSAIJ IOSAIJ;
#line 39
struct IOSPOOL;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSPOOL IOSPOOL;
#line 40
struct IOSCUT;
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSCUT IOSCUT;
#line 41
struct IOSRIB;
#line 41 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSRIB IOSRIB;
#line 43 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct glp_tree {
   DMP *pool ;
   int n ;
   int orig_m ;
   int *orig_type ;
   double *orig_lb ;
   double *orig_ub ;
   int *orig_stat ;
   double *orig_prim ;
   double *orig_dual ;
   double orig_obj ;
   int nslots ;
   int avail ;
   IOSLOT *slot ;
   IOSNPD *head ;
   IOSNPD *tail ;
   int a_cnt ;
   int n_cnt ;
   int t_cnt ;
   int root_m ;
   int *root_type ;
   double *root_lb ;
   double *root_ub ;
   int *root_stat ;
   IOSNPD *curr ;
   glp_prob *mip ;
   int solved ;
   int *non_int ;
   int pred_m ;
   int pred_max ;
   int *pred_type ;
   double *pred_lb ;
   double *pred_ub ;
   int *pred_stat ;
   IOSPOOL *local ;
   int first_attempt ;
   int max_added_cuts ;
   double min_eff ;
   int miss ;
   int just_selected ;
   void *mir_gen ;
   void *clq_gen ;
   int round ;
   int *n_ref ;
   int *c_ref ;
   SCG *g ;
   int *j_ref ;
   void *pcost ;
   int *iwrk ;
   double *dwrk ;
   glp_iocp___0 const   *parm ;
   xlong_t tm_beg ;
   xlong_t tm_lag ;
   int sol_cnt ;
   int reason ;
   int reopt ;
   int br_var ;
   int br_sel ;
   IOSNPD *btrack ;
   int terminate ;
};
#line 229 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSLOT {
   IOSNPD *node ;
   int next ;
};
#line 237 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSNPD {
   int p ;
   IOSNPD *up ;
   int level ;
   int count ;
   IOSBND *b_ptr ;
   IOSTAT *s_ptr ;
   IOSROW *r_ptr ;
   int own_nn ;
   int own_nc ;
   IOSRIB *e_ptr ;
   double lp_obj ;
   double bound ;
   int br_var ;
   double br_val ;
   int ii_cnt ;
   double ii_sum ;
   void *data ;
   IOSNPD *temp ;
   IOSNPD *prev ;
   IOSNPD *next ;
};
#line 321 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSBND {
   int k ;
   int type ;
   double lb ;
   double ub ;
   IOSBND *next ;
};
#line 337 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSTAT {
   int k ;
   int stat ;
   IOSTAT *next ;
};
#line 349 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSROW {
   char *name ;
   unsigned char origin ;
   unsigned char klass ;
   int type ;
   double lb ;
   double ub ;
   IOSAIJ *ptr ;
   double rii ;
   int stat ;
   IOSROW *next ;
};
#line 373 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSAIJ {
   int j ;
   double val ;
   IOSAIJ *next ;
};
#line 383 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSPOOL {
   int size ;
   IOSCUT *head ;
   IOSCUT *tail ;
   int ord ;
   IOSCUT *curr ;
};
#line 397 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSCUT {
   char *name ;
   unsigned char klass ;
   IOSAIJ *ptr ;
   int type ;
   double rhs ;
   IOSCUT *prev ;
   IOSCUT *next ;
};
#line 418 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSRIB {
   int j1 ;
   int j2 ;
   SCGRIB *e ;
   IOSRIB *next ;
};
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glpios10.c"
struct VAR {
   int j ;
   int x ;
   double d ;
};
#line 315 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
struct COG {
   int n ;
   int nb ;
   int ne ;
   int *vert ;
   int *orig ;
   unsigned char *a ;
};
#line 551 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
struct dsa___1 {
   int n ;
   int *wt ;
   unsigned char *a ;
   int record ;
   int rec_level ;
   int *rec ;
   int *clique ;
   int *set ;
};
#line 519 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSVEC;
#line 519 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
typedef struct IOSVEC IOSVEC;
#line 521 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
struct IOSVEC {
   int n ;
   int nnz ;
   int *pos ;
   int *ind ;
   double *val ;
};
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
struct MIR {
   int m ;
   int n ;
   char *skip ;
   char *isint ;
   double *lb ;
   int *vlb ;
   double *ub ;
   int *vub ;
   double *x ;
   int agg_cnt ;
   int *agg_row ;
   IOSVEC *agg_vec ;
   double agg_rhs ;
   char *subst ;
   IOSVEC *mod_vec ;
   double mod_rhs ;
   IOSVEC *cut_vec ;
   double cut_rhs ;
};
#line 775 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
struct vset {
   int j ;
   double v ;
};
#line 44 "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c"
struct worka {
   int *ind ;
   double *val ;
   double *phi ;
};
#line 226 "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c"
struct var {
   int j ;
   double f ;
};
#line 1812 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
struct cut {
   IOSCUT *cut ;
   double eff ;
};
#line 96 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
struct f_info {
   int j_min ;
   int j_max ;
   double f_min ;
   double f_max ;
};
#line 56 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
struct dsa___2 {
   char const   *fname ;
   FILE *fp ;
   int seqn ;
   char card[81] ;
   int fmt_p ;
   int fmt_k ;
   int fmt_f ;
   int fmt_w ;
   int fmt_d ;
};
#line 98 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
typedef struct mpz *mpz_t;
#line 74 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.h"
struct FHV;
#line 74 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.h"
typedef struct FHV FHV;
#line 76 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.h"
struct FHV {
   int m_max ;
   int m ;
   int valid ;
   LUF *luf ;
   int hh_max ;
   int hh_nfs ;
   int *hh_ind ;
   int *hh_ptr ;
   int *hh_len ;
   int *p0_row ;
   int *p0_col ;
   int *cc_ind ;
   double *cc_val ;
   double upd_tol ;
   int nnz_h ;
};
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
struct csa___6 {
   jmp_buf jump ;
   char const   *fname ;
   XFILE *fp ;
   int count ;
   int c ;
   char field[32] ;
   int empty ;
   int nonint ;
};
#line 46 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
struct dsa___3 {
   jmp_buf jump ;
   glp_prob *lp ;
   char const   *fname ;
   FILE *fp ;
   int count ;
   int c ;
   int token ;
   char image[256] ;
   int imlen ;
   double value ;
   int n_max ;
   int *map ;
   int *ind ;
   double *val ;
   double *lb ;
   double *ub ;
};
#line 24 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
struct BFX;
#line 24 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
typedef struct BFX BFX___0;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
struct BFX {
   int valid ;
   LUX *lux ;
};
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.h"
typedef struct BFD___0 BFD___0;
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.h"
struct BFD___0 {
   int valid ;
   int type ;
   FHV *fhv ;
   LPF *lpf ;
   int lu_size ;
   double piv_tol ;
   int piv_lim ;
   int suhl ;
   double eps_tol ;
   double max_gro ;
   int nfs_max ;
   double upd_tol ;
   int nrs_max ;
   int rs_size ;
   int upd_lim ;
   int upd_cnt ;
};
#line 28 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
struct csa___7 {
   glp_prob *prob ;
   glp_bfcp bfcp ;
   glp_smcp smcp ;
   glp_iptcp iptcp ;
   glp_iocp iocp ;
   glp_tran *tran ;
   glp_graph *graph ;
   int format ;
   char const   *in_file ;
   int ndf ;
   char const   *in_data[11] ;
   char const   *out_dpy ;
   int solution ;
   char const   *in_res ;
   int dir ;
   int scale ;
   char const   *out_sol ;
   char const   *out_res ;
   char const   *out_bnds ;
   int check ;
   char const   *new_name ;
   char const   *out_mps ;
   char const   *out_freemps ;
   char const   *out_cpxlp ;
   char const   *out_pb ;
   char const   *out_npb ;
   char const   *log_file ;
   int crash ;
   int exact ;
   int xcheck ;
   int nomip ;
};
#line 640 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
struct __anonstruct_v_data_38 {
   double rhs ;
   double pi ;
};
#line 640 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
typedef struct __anonstruct_v_data_38 v_data;
#line 641 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
struct __anonstruct_a_data_39 {
   double low ;
   double cap ;
   double cost ;
   double x ;
};
#line 641 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
typedef struct __anonstruct_a_data_39 a_data;
#line 894 "./../include/glpk.h"
struct __anonstruct__glp_data_36 {
   double _opaque_data ;
};
#line 894 "./../include/glpk.h"
typedef struct __anonstruct__glp_data_36 _glp_data___0;
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
typedef MPL glp_tran___0;
#line 856 "./../include/glpk.h"
struct __anonstruct_glp_long_35 {
   int lo ;
   int hi ;
};
#line 856 "./../include/glpk.h"
typedef struct __anonstruct_glp_long_35 glp_long;
#line 195 "./../include/glpk.h"
struct __anonstruct_glp_attr_31 {
   int level ;
   int origin ;
   int klass ;
   double foo_bar[7] ;
};
#line 195 "./../include/glpk.h"
typedef struct __anonstruct_glp_attr_31 glp_attr;
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
typedef struct glp_prob___0 glp_prob___0;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
struct glp_prob___0 {
   DMP *pool ;
   void *cps ;
   void *tree ;
   int lwa ;
   char *cwa ;
   char *name ;
   char *obj ;
   int dir ;
   double c0 ;
   int m_max ;
   int n_max ;
   int m ;
   int n ;
   int nnz ;
   GLPROW **row ;
   GLPCOL **col ;
   AVL *r_tree ;
   AVL *c_tree ;
   int valid ;
   int *head ;
   glp_bfcp *bfcp ;
   BFD___0 *bfd ;
   int pbs_stat ;
   int dbs_stat ;
   double obj_val ;
   int it_cnt ;
   int some ;
   int ipt_stat ;
   double ipt_obj ;
   int mip_stat ;
   double mip_obj ;
};
#line 157 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 199 "./glplib.h"
void _glp_lib_xprintf(char const   *fmt___0  , ...) ;
#line 45 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.h"
size_t _glp_colamd_recommended(int nnz , int n_row , int n_col ) ;
#line 48
void _glp_colamd_set_defaults(double *knobs ) ;
#line 51
int _glp_colamd(int n_row , int n_col , int Alen , int *A , int *p , double *knobs ,
                int *stats ) ;
#line 55
int _glp_symamd(int n , int *A , int *p , int *perm , double *knobs , int *stats ,
                void *(*allocate___0)(size_t  , size_t  ) , void (*release___0)(void * ) ) ;
#line 60
void _glp_colamd_report(int *stats ) ;
#line 63
void _glp_symamd_report(int *stats ) ;
#line 850 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static int init_rows_cols(int n_row , int n_col , Colamd_Row *Row , Colamd_Col *Col ,
                          int *A , int *p , int *stats ) ;
#line 861
static void init_scoring(int n_row , int n_col , Colamd_Row *Row , Colamd_Col *Col ,
                         int *A , int *head , double *knobs , int *p_n_row2 , int *p_n_col2 ,
                         int *p_max_deg ) ;
#line 875
static int find_ordering(int n_row , int n_col , int Alen , Colamd_Row *Row , Colamd_Col *Col ,
                         int *A , int *head , int n_col2 , int max_deg , int pfree ,
                         int aggressive ) ;
#line 890
static void order_children(int n_col , Colamd_Col *Col , int *p ) ;
#line 897
static void detect_super_cols(Colamd_Col *Col , int *A , int *head , int row_start ,
                              int row_length ) ;
#line 912
static int garbage_collection(int n_row , int n_col , Colamd_Row *Row , Colamd_Col *Col ,
                              int *A , int *pfree ) ;
#line 922
static int clear_mark(int tag_mark , int max_mark , int n_row , Colamd_Row *Row ) ;
#line 930
static void print_report(char *method , int *stats ) ;
#line 1051 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static size_t t_add(size_t a , size_t b , int *ok ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1053
  if (*ok) {
#line 1053
    if (a > b) {
#line 1053
      tmp = a;
    } else {
#line 1053
      tmp = b;
    }
#line 1053
    if (a + b >= tmp) {
#line 1053
      tmp___0 = 1;
    } else {
#line 1053
      tmp___0 = 0;
    }
  } else {
#line 1053
    tmp___0 = 0;
  }
#line 1053
  *ok = tmp___0;
#line 1054
  if (*ok) {
#line 1054
    tmp___1 = a + b;
  } else {
#line 1054
    tmp___1 = (size_t )0;
  }
#line 1054
  return (tmp___1);
}
}
#line 1058 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static size_t t_mult(size_t a , size_t k , int *ok ) 
{ 
  size_t i ;
  size_t s ;

  {
#line 1060
  s = (size_t )0;
#line 1061
  i = (size_t )0;
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1061
    if (! (i < k)) {
#line 1061
      goto while_break;
    }
    {
#line 1063
    s = t_add(s, a, ok);
#line 1061
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  return (s);
}
}
#line 1076 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
size_t _glp_colamd_recommended(int nnz , int n_row , int n_col ) 
{ 
  size_t s ;
  size_t c ;
  size_t r ;
  int ok ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 1086
  ok = 1;
#line 1087
  if (nnz < 0) {
#line 1089
    return ((size_t )0);
  } else
#line 1087
  if (n_row < 0) {
#line 1089
    return ((size_t )0);
  } else
#line 1087
  if (n_col < 0) {
#line 1089
    return ((size_t )0);
  }
  {
#line 1091
  s = t_mult((size_t )nnz, (size_t )2, & ok);
#line 1092
  tmp = t_add((size_t )n_col, (size_t )1, & ok);
#line 1092
  tmp___0 = t_mult(tmp, (size_t )sizeof(Colamd_Col ), & ok);
#line 1092
  c = (size_t )((unsigned long )tmp___0 / sizeof(int ));
#line 1093
  tmp___1 = t_add((size_t )n_row, (size_t )1, & ok);
#line 1093
  tmp___2 = t_mult(tmp___1, (size_t )sizeof(Colamd_Row ), & ok);
#line 1093
  r = (size_t )((unsigned long )tmp___2 / sizeof(int ));
#line 1094
  s = t_add(s, c, & ok);
#line 1095
  s = t_add(s, r, & ok);
#line 1096
  s = t_add(s, (size_t )n_col, & ok);
#line 1097
  s = t_add(s, (size_t )(nnz / 5), & ok);
  }
#line 1098
  if (ok) {
#line 1098
    if (s < 2147483647U) {
#line 1098
      tmp___3 = 1;
    } else {
#line 1098
      tmp___3 = 0;
    }
  } else {
#line 1098
    tmp___3 = 0;
  }
#line 1098
  ok = tmp___3;
#line 1099
  if (ok) {
#line 1099
    tmp___4 = s;
  } else {
#line 1099
    tmp___4 = (size_t )0;
  }
#line 1099
  return (tmp___4);
}
}
#line 1130 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
void _glp_colamd_set_defaults(double *knobs ) 
{ 
  int i ;

  {
#line 1141
  if (! knobs) {
#line 1143
    return;
  }
#line 1145
  i = 0;
  {
#line 1145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1145
    if (! (i < 20)) {
#line 1145
      goto while_break;
    }
#line 1147
    *(knobs + i) = (double )0;
#line 1145
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1149
  *(knobs + 0) = (double )10;
#line 1150
  *(knobs + 1) = (double )10;
#line 1151
  *(knobs + 2) = (double )1;
#line 1152
  return;
}
}
#line 1159 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
int _glp_symamd(int n , int *A , int *p , int *perm , double *knobs , int *stats ,
                void *(*allocate___0)(size_t  , size_t  ) , void (*release___0)(void * ) ) 
{ 
  int *count ;
  int *mark ;
  int *M ;
  size_t Mlen ;
  int n_row ;
  int nnz ;
  int i ;
  int j ;
  int k ;
  int mnz ;
  int pp ;
  int last_row ;
  int length ;
  double cknobs[20] ;
  double default_knobs[20] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;

  {
#line 1202
  if (! stats) {
#line 1205
    return (0);
  }
#line 1207
  i = 0;
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (! (i < 20)) {
#line 1207
      goto while_break;
    }
#line 1209
    *(stats + i) = 0;
#line 1207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1211
  *(stats + 3) = 0;
#line 1212
  *(stats + 4) = -1;
#line 1213
  *(stats + 5) = -1;
#line 1215
  if (! A) {
#line 1217
    *(stats + 3) = -1;
#line 1219
    return (0);
  }
#line 1222
  if (! p) {
#line 1224
    *(stats + 3) = -2;
#line 1226
    return (0);
  }
#line 1229
  if (n < 0) {
#line 1231
    *(stats + 3) = -4;
#line 1232
    *(stats + 4) = n;
#line 1234
    return (0);
  }
#line 1237
  nnz = *(p + n);
#line 1238
  if (nnz < 0) {
#line 1240
    *(stats + 3) = -5;
#line 1241
    *(stats + 4) = nnz;
#line 1243
    return (0);
  }
#line 1246
  if (*(p + 0) != 0) {
#line 1248
    *(stats + 3) = -6;
#line 1249
    *(stats + 4) = *(p + 0);
#line 1251
    return (0);
  }
#line 1256
  if (! knobs) {
    {
#line 1258
    _glp_colamd_set_defaults((double *)(default_knobs));
#line 1259
    knobs = (double *)(default_knobs);
    }
  }
  {
#line 1264
  tmp = (*allocate___0)((size_t )(n + 1), (size_t )sizeof(int ));
#line 1264
  count = (int *)tmp;
  }
#line 1265
  if (! count) {
#line 1267
    *(stats + 3) = -10;
#line 1269
    return (0);
  }
  {
#line 1272
  tmp___0 = (*allocate___0)((size_t )(n + 1), (size_t )sizeof(int ));
#line 1272
  mark = (int *)tmp___0;
  }
#line 1273
  if (! mark) {
    {
#line 1275
    *(stats + 3) = -10;
#line 1276
    (*release___0)((void *)count);
    }
#line 1278
    return (0);
  }
#line 1283
  *(stats + 6) = 0;
#line 1285
  i = 0;
  {
#line 1285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1285
    if (! (i < n)) {
#line 1285
      goto while_break___0;
    }
#line 1287
    *(mark + i) = -1;
#line 1285
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1290
  j = 0;
  {
#line 1290
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1290
    if (! (j < n)) {
#line 1290
      goto while_break___1;
    }
#line 1292
    last_row = -1;
#line 1294
    length = *(p + (j + 1)) - *(p + j);
#line 1295
    if (length < 0) {
      {
#line 1298
      *(stats + 3) = -8;
#line 1299
      *(stats + 4) = j;
#line 1300
      *(stats + 5) = length;
#line 1301
      (*release___0)((void *)count);
#line 1302
      (*release___0)((void *)mark);
      }
#line 1304
      return (0);
    }
#line 1307
    pp = *(p + j);
    {
#line 1307
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1307
      if (! (pp < *(p + (j + 1)))) {
#line 1307
        goto while_break___2;
      }
#line 1309
      i = *(A + pp);
#line 1310
      if (i < 0) {
#line 1310
        goto _L;
      } else
#line 1310
      if (i >= n) {
        _L: /* CIL Label */ 
        {
#line 1313
        *(stats + 3) = -9;
#line 1314
        *(stats + 4) = j;
#line 1315
        *(stats + 5) = i;
#line 1316
        *(stats + 6) = n;
#line 1317
        (*release___0)((void *)count);
#line 1318
        (*release___0)((void *)mark);
        }
#line 1320
        return (0);
      }
#line 1323
      if (i <= last_row) {
#line 1327
        *(stats + 3) = 1;
#line 1328
        *(stats + 4) = j;
#line 1329
        *(stats + 5) = i;
#line 1330
        (*(stats + 6)) ++;
      } else
#line 1323
      if (*(mark + i) == j) {
#line 1327
        *(stats + 3) = 1;
#line 1328
        *(stats + 4) = j;
#line 1329
        *(stats + 5) = i;
#line 1330
        (*(stats + 6)) ++;
      }
#line 1334
      if (i > j) {
#line 1334
        if (*(mark + i) != j) {
#line 1337
          (*(count + i)) ++;
#line 1338
          (*(count + j)) ++;
        }
      }
#line 1342
      *(mark + i) = j;
#line 1344
      last_row = i;
#line 1307
      pp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1290
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1353
  *(perm + 0) = 0;
#line 1354
  j = 1;
  {
#line 1354
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1354
    if (! (j <= n)) {
#line 1354
      goto while_break___3;
    }
#line 1356
    *(perm + j) = *(perm + (j - 1)) + *(count + (j - 1));
#line 1354
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1358
  j = 0;
  {
#line 1358
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1358
    if (! (j < n)) {
#line 1358
      goto while_break___4;
    }
#line 1360
    *(count + j) = *(perm + j);
#line 1358
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1365
  mnz = *(perm + n);
#line 1366
  n_row = mnz / 2;
#line 1367
  Mlen = _glp_colamd_recommended(mnz, n_row, n);
#line 1368
  tmp___1 = (*allocate___0)(Mlen, (size_t )sizeof(int ));
#line 1368
  M = (int *)tmp___1;
  }
#line 1372
  if (! M) {
    {
#line 1374
    *(stats + 3) = -10;
#line 1375
    (*release___0)((void *)count);
#line 1376
    (*release___0)((void *)mark);
    }
#line 1378
    return (0);
  }
#line 1381
  k = 0;
#line 1383
  if (*(stats + 3) == 0) {
#line 1386
    j = 0;
    {
#line 1386
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1386
      if (! (j < n)) {
#line 1386
        goto while_break___5;
      }
#line 1389
      pp = *(p + j);
      {
#line 1389
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1389
        if (! (pp < *(p + (j + 1)))) {
#line 1389
          goto while_break___6;
        }
#line 1391
        i = *(A + pp);
#line 1393
        if (i > j) {
#line 1396
          tmp___2 = *(count + i);
#line 1396
          (*(count + i)) ++;
#line 1396
          *(M + tmp___2) = k;
#line 1397
          tmp___3 = *(count + j);
#line 1397
          (*(count + j)) ++;
#line 1397
          *(M + tmp___3) = k;
#line 1398
          k ++;
        }
#line 1389
        pp ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1386
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1407
    i = 0;
    {
#line 1407
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1407
      if (! (i < n)) {
#line 1407
        goto while_break___7;
      }
#line 1409
      *(mark + i) = -1;
#line 1407
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1411
    j = 0;
    {
#line 1411
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1411
      if (! (j < n)) {
#line 1411
        goto while_break___8;
      }
#line 1414
      pp = *(p + j);
      {
#line 1414
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1414
        if (! (pp < *(p + (j + 1)))) {
#line 1414
          goto while_break___9;
        }
#line 1416
        i = *(A + pp);
#line 1418
        if (i > j) {
#line 1418
          if (*(mark + i) != j) {
#line 1421
            tmp___4 = *(count + i);
#line 1421
            (*(count + i)) ++;
#line 1421
            *(M + tmp___4) = k;
#line 1422
            tmp___5 = *(count + j);
#line 1422
            (*(count + j)) ++;
#line 1422
            *(M + tmp___5) = k;
#line 1423
            k ++;
#line 1424
            *(mark + i) = j;
          }
        }
#line 1414
        pp ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1411
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 1432
  (*release___0)((void *)count);
#line 1433
  (*release___0)((void *)mark);
#line 1438
  i = 0;
  }
  {
#line 1438
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1438
    if (! (i < 20)) {
#line 1438
      goto while_break___10;
    }
#line 1440
    cknobs[i] = *(knobs + i);
#line 1438
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1444
  cknobs[0] = (double )-1;
#line 1445
  cknobs[1] = *(knobs + 0);
#line 1450
  _glp_colamd(n_row, n, (int )Mlen, M, perm, (double *)(cknobs), stats);
#line 1457
  *(stats + 0) = *(stats + 1);
#line 1461
  (*release___0)((void *)M);
  }
#line 1463
  return (1);
}
}
#line 1479 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
int _glp_colamd(int n_row , int n_col , int Alen , int *A , int *p , double *knobs ,
                int *stats ) 
{ 
  int i ;
  int nnz ;
  size_t Row_size ;
  size_t Col_size ;
  size_t need ;
  Colamd_Row *Row ;
  Colamd_Col *Col ;
  int n_col2 ;
  int n_row2 ;
  int ngarbage ;
  int max_deg ;
  double default_knobs[20] ;
  int aggressive ;
  int ok ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp27 ;

  {
#line 1515
  if (! stats) {
#line 1518
    return (0);
  }
#line 1520
  i = 0;
  {
#line 1520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1520
    if (! (i < 20)) {
#line 1520
      goto while_break;
    }
#line 1522
    *(stats + i) = 0;
#line 1520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1524
  *(stats + 3) = 0;
#line 1525
  *(stats + 4) = -1;
#line 1526
  *(stats + 5) = -1;
#line 1528
  if (! A) {
#line 1530
    *(stats + 3) = -1;
#line 1532
    return (0);
  }
#line 1535
  if (! p) {
#line 1537
    *(stats + 3) = -2;
#line 1539
    return (0);
  }
#line 1542
  if (n_row < 0) {
#line 1544
    *(stats + 3) = -3;
#line 1545
    *(stats + 4) = n_row;
#line 1547
    return (0);
  }
#line 1550
  if (n_col < 0) {
#line 1552
    *(stats + 3) = -4;
#line 1553
    *(stats + 4) = n_col;
#line 1555
    return (0);
  }
#line 1558
  nnz = *(p + n_col);
#line 1559
  if (nnz < 0) {
#line 1561
    *(stats + 3) = -5;
#line 1562
    *(stats + 4) = nnz;
#line 1564
    return (0);
  }
#line 1567
  if (*(p + 0) != 0) {
#line 1569
    *(stats + 3) = -6;
#line 1570
    *(stats + 4) = *(p + 0);
#line 1572
    return (0);
  }
#line 1577
  if (! knobs) {
    {
#line 1579
    _glp_colamd_set_defaults((double *)(default_knobs));
#line 1580
    knobs = (double *)(default_knobs);
    }
  }
  {
#line 1583
  aggressive = *(knobs + 2) != (double )0;
#line 1587
  ok = 1;
#line 1588
  tmp = t_add((size_t )n_col, (size_t )1, & ok);
#line 1588
  tmp___0 = t_mult(tmp, (size_t )sizeof(Colamd_Col ), & ok);
#line 1588
  Col_size = (size_t )((unsigned long )tmp___0 / sizeof(int ));
#line 1589
  tmp___1 = t_add((size_t )n_row, (size_t )1, & ok);
#line 1589
  tmp___2 = t_mult(tmp___1, (size_t )sizeof(Colamd_Row ), & ok);
#line 1589
  Row_size = (size_t )((unsigned long )tmp___2 / sizeof(int ));
#line 1592
  need = t_mult((size_t )nnz, (size_t )2, & ok);
#line 1593
  need = t_add(need, (size_t )n_col, & ok);
#line 1594
  need = t_add(need, Col_size, & ok);
#line 1595
  need = t_add(need, Row_size, & ok);
  }
#line 1597
  if (! ok) {
#line 1600
    *(stats + 3) = -7;
#line 1601
    *(stats + 4) = (int )need;
#line 1602
    *(stats + 5) = Alen;
#line 1604
    return (0);
  } else
#line 1597
  if (need > (size_t )Alen) {
#line 1600
    *(stats + 3) = -7;
#line 1601
    *(stats + 4) = (int )need;
#line 1602
    *(stats + 5) = Alen;
#line 1604
    return (0);
  } else
#line 1597
  if (need > 2147483647U) {
#line 1600
    *(stats + 3) = -7;
#line 1601
    *(stats + 4) = (int )need;
#line 1602
    *(stats + 5) = Alen;
#line 1604
    return (0);
  }
  {
#line 1607
  Alen = (int )((size_t )Alen - (Col_size + Row_size));
#line 1608
  Col = (Colamd_Col *)(A + Alen);
#line 1609
  Row = (Colamd_Row *)(A + ((size_t )Alen + Col_size));
#line 1613
  tmp___3 = init_rows_cols(n_row, n_col, Row, Col, A, p, stats);
  }
#line 1613
  if (! tmp___3) {
#line 1617
    return (0);
  }
  {
#line 1622
  init_scoring(n_row, n_col, Row, Col, A, p, knobs, & n_row2, & n_col2, & max_deg);
#line 1627
  ngarbage = find_ordering(n_row, n_col, Alen, Row, Col, A, p, n_col2, max_deg, 2 * nnz,
                           aggressive);
#line 1632
  order_children(n_col, Col, p);
#line 1636
  *(stats + 0) = n_row - n_row2;
#line 1637
  *(stats + 1) = n_col - n_col2;
#line 1638
  *(stats + 2) = ngarbage;
  }
#line 1640
  return (1);
}
}
#line 1648 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
void _glp_colamd_report(int *stats ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1653
  print_report((char *)"colamd", stats);
  }
#line 1654
  return;
}
}
#line 1661 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
void _glp_symamd_report(int *stats ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1666
  print_report((char *)"symamd", stats);
  }
#line 1667
  return;
}
}
#line 1691 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static int init_rows_cols(int n_row , int n_col , Colamd_Row *Row , Colamd_Col *Col ,
                          int *A , int *p , int *stats ) 
{ 
  int col ;
  int row ;
  int *cp ;
  int *cp_end ;
  int *rp ;
  int *rp_end ;
  int last_row ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1716
  col = 0;
  {
#line 1716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1716
    if (! (col < n_col)) {
#line 1716
      goto while_break;
    }
#line 1718
    (Col + col)->start = *(p + col);
#line 1719
    (Col + col)->length = *(p + (col + 1)) - *(p + col);
#line 1721
    if ((Col + col)->length < 0) {
#line 1724
      *(stats + 3) = -8;
#line 1725
      *(stats + 4) = col;
#line 1726
      *(stats + 5) = (Col + col)->length;
#line 1728
      return (0);
    }
#line 1731
    (Col + col)->shared1.thickness = 1;
#line 1732
    (Col + col)->shared2.score = 0;
#line 1733
    (Col + col)->shared3.prev = -1;
#line 1734
    (Col + col)->shared4.degree_next = -1;
#line 1716
    col ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1741
  *(stats + 6) = 0;
#line 1743
  row = 0;
  {
#line 1743
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1743
    if (! (row < n_row)) {
#line 1743
      goto while_break___0;
    }
#line 1745
    (Row + row)->length = 0;
#line 1746
    (Row + row)->shared2.mark = -1;
#line 1743
    row ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1749
  col = 0;
  {
#line 1749
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1749
    if (! (col < n_col)) {
#line 1749
      goto while_break___1;
    }
#line 1751
    last_row = -1;
#line 1753
    cp = A + *(p + col);
#line 1754
    cp_end = A + *(p + (col + 1));
    {
#line 1756
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1756
      if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 1756
        goto while_break___2;
      }
#line 1758
      tmp = cp;
#line 1758
      cp ++;
#line 1758
      row = *tmp;
#line 1761
      if (row < 0) {
#line 1763
        *(stats + 3) = -9;
#line 1764
        *(stats + 4) = col;
#line 1765
        *(stats + 5) = row;
#line 1766
        *(stats + 6) = n_row;
#line 1768
        return (0);
      } else
#line 1761
      if (row >= n_row) {
#line 1763
        *(stats + 3) = -9;
#line 1764
        *(stats + 4) = col;
#line 1765
        *(stats + 5) = row;
#line 1766
        *(stats + 6) = n_row;
#line 1768
        return (0);
      }
#line 1771
      if (row <= last_row) {
#line 1775
        *(stats + 3) = 1;
#line 1776
        *(stats + 4) = col;
#line 1777
        *(stats + 5) = row;
#line 1778
        (*(stats + 6)) ++;
      } else
#line 1771
      if ((Row + row)->shared2.mark == col) {
#line 1775
        *(stats + 3) = 1;
#line 1776
        *(stats + 4) = col;
#line 1777
        *(stats + 5) = row;
#line 1778
        (*(stats + 6)) ++;
      }
#line 1782
      if ((Row + row)->shared2.mark != col) {
#line 1784
        ((Row + row)->length) ++;
      } else {
#line 1790
        ((Col + col)->length) --;
      }
#line 1794
      (Row + row)->shared2.mark = col;
#line 1796
      last_row = row;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1749
    col ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1804
  (Row + 0)->start = *(p + n_col);
#line 1805
  (Row + 0)->shared1.p = (Row + 0)->start;
#line 1806
  (Row + 0)->shared2.mark = -1;
#line 1807
  row = 1;
  {
#line 1807
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1807
    if (! (row < n_row)) {
#line 1807
      goto while_break___3;
    }
#line 1809
    (Row + row)->start = (Row + (row - 1))->start + (Row + (row - 1))->length;
#line 1810
    (Row + row)->shared1.p = (Row + row)->start;
#line 1811
    (Row + row)->shared2.mark = -1;
#line 1807
    row ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1816
  if (*(stats + 3) == 1) {
#line 1819
    col = 0;
    {
#line 1819
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1819
      if (! (col < n_col)) {
#line 1819
        goto while_break___4;
      }
#line 1821
      cp = A + *(p + col);
#line 1822
      cp_end = A + *(p + (col + 1));
      {
#line 1823
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1823
        if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 1823
          goto while_break___5;
        }
#line 1825
        tmp___0 = cp;
#line 1825
        cp ++;
#line 1825
        row = *tmp___0;
#line 1826
        if ((Row + row)->shared2.mark != col) {
#line 1828
          tmp___1 = (Row + row)->shared1.p;
#line 1828
          ((Row + row)->shared1.p) ++;
#line 1828
          *(A + tmp___1) = col;
#line 1829
          (Row + row)->shared2.mark = col;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1819
      col ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 1837
    col = 0;
    {
#line 1837
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1837
      if (! (col < n_col)) {
#line 1837
        goto while_break___6;
      }
#line 1839
      cp = A + *(p + col);
#line 1840
      cp_end = A + *(p + (col + 1));
      {
#line 1841
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1841
        if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 1841
          goto while_break___7;
        }
#line 1843
        tmp___2 = cp;
#line 1843
        cp ++;
#line 1843
        tmp___3 = (Row + *tmp___2)->shared1.p;
#line 1843
        ((Row + *tmp___2)->shared1.p) ++;
#line 1843
        *(A + tmp___3) = col;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1837
      col ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1850
  row = 0;
  {
#line 1850
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1850
    if (! (row < n_row)) {
#line 1850
      goto while_break___8;
    }
#line 1852
    (Row + row)->shared2.mark = 0;
#line 1853
    (Row + row)->shared1.degree = (Row + row)->length;
#line 1850
    row ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1858
  if (*(stats + 3) == 1) {
#line 1890
    (Col + 0)->start = 0;
#line 1891
    *(p + 0) = (Col + 0)->start;
#line 1892
    col = 1;
    {
#line 1892
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1892
      if (! (col < n_col)) {
#line 1892
        goto while_break___9;
      }
#line 1896
      (Col + col)->start = (Col + (col - 1))->start + (Col + (col - 1))->length;
#line 1897
      *(p + col) = (Col + col)->start;
#line 1892
      col ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1902
    row = 0;
    {
#line 1902
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1902
      if (! (row < n_row)) {
#line 1902
        goto while_break___10;
      }
#line 1904
      rp = A + (Row + row)->start;
#line 1905
      rp_end = rp + (Row + row)->length;
      {
#line 1906
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1906
        if (! ((unsigned long )rp < (unsigned long )rp_end)) {
#line 1906
          goto while_break___11;
        }
#line 1908
        tmp___4 = rp;
#line 1908
        rp ++;
#line 1908
        tmp___5 = *(p + *tmp___4);
#line 1908
        (*(p + *tmp___4)) ++;
#line 1908
        *(A + tmp___5) = row;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1902
      row ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 1915
  return (1);
}
}
#line 1928 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static void init_scoring(int n_row , int n_col , Colamd_Row *Row , Colamd_Col *Col ,
                         int *A , int *head , double *knobs , int *p_n_row2 , int *p_n_col2 ,
                         int *p_max_deg ) 
{ 
  int c ;
  int r ;
  int row ;
  int *cp ;
  int deg ;
  int *cp_end ;
  int *new_cp ;
  int col_length ;
  int score ;
  int n_col2 ;
  int n_row2 ;
  int dense_row_count ;
  int dense_col_count ;
  int min_score ;
  int max_deg ;
  int next_col ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
#line 1969
  if (*(knobs + 0) < (double )0) {
#line 1972
    dense_row_count = n_col - 1;
  } else {
    {
#line 1976
    tmp___2 = sqrt((double )n_col);
    }
#line 1976
    if (16.0 > *(knobs + 0) * tmp___2) {
#line 1976
      tmp___1 = 16.0;
    } else {
      {
#line 1976
      tmp___0 = sqrt((double )n_col);
#line 1976
      tmp___1 = *(knobs + 0) * tmp___0;
      }
    }
#line 1976
    dense_row_count = (int )tmp___1;
  }
#line 1978
  if (*(knobs + 1) < (double )0) {
#line 1981
    dense_col_count = n_row - 1;
  } else {
#line 1985
    if (n_row < n_col) {
#line 1985
      tmp___8 = n_row;
    } else {
#line 1985
      tmp___8 = n_col;
    }
    {
#line 1985
    tmp___9 = sqrt((double )tmp___8);
    }
#line 1985
    if (16.0 > *(knobs + 1) * tmp___9) {
#line 1985
      tmp___7 = 16.0;
    } else {
#line 1985
      if (n_row < n_col) {
#line 1985
        tmp___5 = n_row;
      } else {
#line 1985
        tmp___5 = n_col;
      }
      {
#line 1985
      tmp___6 = sqrt((double )tmp___5);
#line 1985
      tmp___7 = *(knobs + 1) * tmp___6;
      }
    }
#line 1985
    dense_col_count = (int )tmp___7;
  }
#line 1990
  max_deg = 0;
#line 1991
  n_col2 = n_col;
#line 1992
  n_row2 = n_row;
#line 1998
  c = n_col - 1;
  {
#line 1998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1998
    if (! (c >= 0)) {
#line 1998
      goto while_break;
    }
#line 2000
    deg = (Col + c)->length;
#line 2001
    if (deg == 0) {
#line 2004
      n_col2 --;
#line 2004
      (Col + c)->shared2.order = n_col2;
#line 2005
      (Col + c)->start = -1;
    }
#line 1998
    c --;
  }
  while_break: /* CIL Label */ ;
  }
#line 2013
  c = n_col - 1;
  {
#line 2013
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2013
    if (! (c >= 0)) {
#line 2013
      goto while_break___0;
    }
#line 2016
    if ((Col + c)->start < 0) {
#line 2018
      goto __Cont;
    }
#line 2020
    deg = (Col + c)->length;
#line 2021
    if (deg > dense_col_count) {
#line 2024
      n_col2 --;
#line 2024
      (Col + c)->shared2.order = n_col2;
#line 2026
      cp = A + (Col + c)->start;
#line 2027
      cp_end = cp + (Col + c)->length;
      {
#line 2028
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2028
        if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 2028
          goto while_break___1;
        }
#line 2030
        tmp___10 = cp;
#line 2030
        cp ++;
#line 2030
        ((Row + *tmp___10)->shared1.degree) --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2032
      (Col + c)->start = -1;
    }
    __Cont: /* CIL Label */ 
#line 2013
    c --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2039
  r = 0;
  {
#line 2039
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2039
    if (! (r < n_row)) {
#line 2039
      goto while_break___2;
    }
#line 2041
    deg = (Row + r)->shared1.degree;
#line 2043
    if (deg > dense_row_count) {
#line 2046
      (Row + r)->shared2.mark = -1;
#line 2047
      n_row2 --;
    } else
#line 2043
    if (deg == 0) {
#line 2046
      (Row + r)->shared2.mark = -1;
#line 2047
      n_row2 --;
    } else
#line 2052
    if (max_deg > deg) {
#line 2052
      max_deg = max_deg;
    } else {
#line 2052
      max_deg = deg;
    }
#line 2039
    r ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2065
  c = n_col - 1;
  {
#line 2065
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2065
    if (! (c >= 0)) {
#line 2065
      goto while_break___3;
    }
#line 2068
    if ((Col + c)->start < 0) {
#line 2070
      goto __Cont___0;
    }
#line 2072
    score = 0;
#line 2073
    cp = A + (Col + c)->start;
#line 2074
    new_cp = cp;
#line 2075
    cp_end = cp + (Col + c)->length;
    {
#line 2076
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2076
      if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 2076
        goto while_break___4;
      }
#line 2079
      tmp___11 = cp;
#line 2079
      cp ++;
#line 2079
      row = *tmp___11;
#line 2081
      if ((Row + row)->shared2.mark < 0) {
#line 2083
        goto while_continue___4;
      }
#line 2086
      tmp___12 = new_cp;
#line 2086
      new_cp ++;
#line 2086
      *tmp___12 = row;
#line 2088
      score += (Row + row)->shared1.degree - 1;
#line 2090
      if (score < n_col) {
#line 2090
        score = score;
      } else {
#line 2090
        score = n_col;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2093
    col_length = (int )(new_cp - (A + (Col + c)->start));
#line 2094
    if (col_length == 0) {
#line 2099
      n_col2 --;
#line 2099
      (Col + c)->shared2.order = n_col2;
#line 2100
      (Col + c)->start = -1;
    } else {
#line 2107
      (Col + c)->length = col_length;
#line 2108
      (Col + c)->shared2.score = score;
    }
    __Cont___0: /* CIL Label */ 
#line 2065
    c --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2130
  c = 0;
  {
#line 2130
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2130
    if (! (c <= n_col)) {
#line 2130
      goto while_break___5;
    }
#line 2132
    *(head + c) = -1;
#line 2130
    c ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2134
  min_score = n_col;
#line 2137
  c = n_col - 1;
  {
#line 2137
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2137
    if (! (c >= 0)) {
#line 2137
      goto while_break___6;
    }
#line 2140
    if ((Col + c)->start >= 0) {
#line 2147
      score = (Col + c)->shared2.score;
#line 2156
      next_col = *(head + score);
#line 2157
      (Col + c)->shared3.prev = -1;
#line 2158
      (Col + c)->shared4.degree_next = next_col;
#line 2162
      if (next_col != -1) {
#line 2164
        (Col + next_col)->shared3.prev = c;
      }
#line 2166
      *(head + score) = c;
#line 2169
      if (min_score < score) {
#line 2169
        min_score = min_score;
      } else {
#line 2169
        min_score = score;
      }
    }
#line 2137
    c --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2187
  *p_n_col2 = n_col2;
#line 2188
  *p_n_row2 = n_row2;
#line 2189
  *p_max_deg = max_deg;
#line 2190
  return;
}
}
#line 2203 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static int find_ordering(int n_row , int n_col , int Alen , Colamd_Row *Row , Colamd_Col *Col ,
                         int *A , int *head , int n_col2 , int max_deg , int pfree ,
                         int aggressive ) 
{ 
  int k ;
  int pivot_col ;
  int *cp ;
  int *rp ;
  int pivot_row ;
  int *new_cp ;
  int *new_rp ;
  int pivot_row_start ;
  int pivot_row_degree ;
  int pivot_row_length ;
  int pivot_col_score ;
  int needed_memory ;
  int *cp_end ;
  int *rp_end ;
  int row ;
  int col ;
  int max_score ;
  int cur_score ;
  unsigned int hash ;
  int head_column ;
  int first_col ;
  int tag_mark ;
  int row_mark ;
  int set_difference ;
  int min_score ;
  int col_thickness ;
  int max_mark ;
  int pivot_col_thickness ;
  int prev_col ;
  int next_col ;
  int ngarbage ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 2261
  max_mark = 2147483647 - n_col;
#line 2262
  tag_mark = clear_mark(0, max_mark, n_row, Row);
#line 2263
  min_score = 0;
#line 2264
  ngarbage = 0;
#line 2269
  k = 0;
  }
  {
#line 2269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2269
    if (! (k < n_col2)) {
#line 2269
      goto while_break;
    }
    {
#line 2302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2302
      if (*(head + min_score) == -1) {
#line 2302
        if (! (min_score < n_col)) {
#line 2302
          goto while_break___0;
        }
      } else {
#line 2302
        goto while_break___0;
      }
#line 2304
      min_score ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2306
    pivot_col = *(head + min_score);
#line 2308
    next_col = (Col + pivot_col)->shared4.degree_next;
#line 2309
    *(head + min_score) = next_col;
#line 2310
    if (next_col != -1) {
#line 2312
      (Col + next_col)->shared3.prev = -1;
    }
#line 2318
    pivot_col_score = (Col + pivot_col)->shared2.score;
#line 2321
    (Col + pivot_col)->shared2.order = k;
#line 2324
    pivot_col_thickness = (Col + pivot_col)->shared1.thickness;
#line 2325
    k += pivot_col_thickness;
#line 2331
    if (pivot_col_score < n_col - k) {
#line 2331
      needed_memory = pivot_col_score;
    } else {
#line 2331
      needed_memory = n_col - k;
    }
#line 2332
    if (pfree + needed_memory >= Alen) {
      {
#line 2334
      pfree = garbage_collection(n_row, n_col, Row, Col, A, A + pfree);
#line 2335
      ngarbage ++;
#line 2339
      tag_mark = clear_mark(0, max_mark, n_row, Row);
      }
    }
#line 2349
    pivot_row_start = pfree;
#line 2352
    pivot_row_degree = 0;
#line 2356
    (Col + pivot_col)->shared1.thickness = - pivot_col_thickness;
#line 2359
    cp = A + (Col + pivot_col)->start;
#line 2360
    cp_end = cp + (Col + pivot_col)->length;
    {
#line 2361
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2361
      if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 2361
        goto while_break___1;
      }
#line 2364
      tmp = cp;
#line 2364
      cp ++;
#line 2364
      row = *tmp;
#line 2367
      if ((Row + row)->shared2.mark >= 0) {
#line 2369
        rp = A + (Row + row)->start;
#line 2370
        rp_end = rp + (Row + row)->length;
        {
#line 2371
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2371
          if (! ((unsigned long )rp < (unsigned long )rp_end)) {
#line 2371
            goto while_break___2;
          }
#line 2374
          tmp___0 = rp;
#line 2374
          rp ++;
#line 2374
          col = *tmp___0;
#line 2376
          col_thickness = (Col + col)->shared1.thickness;
#line 2377
          if (col_thickness > 0) {
#line 2377
            if ((Col + col)->start >= 0) {
#line 2380
              (Col + col)->shared1.thickness = - col_thickness;
#line 2383
              tmp___1 = pfree;
#line 2383
              pfree ++;
#line 2383
              *(A + tmp___1) = col;
#line 2384
              pivot_row_degree += col_thickness;
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2391
    (Col + pivot_col)->shared1.thickness = pivot_col_thickness;
#line 2392
    if (max_deg > pivot_row_degree) {
#line 2392
      max_deg = max_deg;
    } else {
#line 2392
      max_deg = pivot_row_degree;
    }
#line 2402
    cp = A + (Col + pivot_col)->start;
#line 2403
    cp_end = cp + (Col + pivot_col)->length;
    {
#line 2404
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2404
      if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 2404
        goto while_break___3;
      }
#line 2407
      tmp___2 = cp;
#line 2407
      cp ++;
#line 2407
      row = *tmp___2;
#line 2409
      (Row + row)->shared2.mark = -1;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2414
    pivot_row_length = pfree - pivot_row_start;
#line 2415
    if (pivot_row_length > 0) {
#line 2418
      pivot_row = *(A + (Col + pivot_col)->start);
    } else {
#line 2424
      pivot_row = -1;
    }
#line 2456
    rp = A + pivot_row_start;
#line 2457
    rp_end = rp + pivot_row_length;
    {
#line 2458
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2458
      if (! ((unsigned long )rp < (unsigned long )rp_end)) {
#line 2458
        goto while_break___4;
      }
#line 2460
      tmp___3 = rp;
#line 2460
      rp ++;
#line 2460
      col = *tmp___3;
#line 2465
      col_thickness = - (Col + col)->shared1.thickness;
#line 2467
      (Col + col)->shared1.thickness = col_thickness;
#line 2471
      cur_score = (Col + col)->shared2.score;
#line 2472
      prev_col = (Col + col)->shared3.prev;
#line 2473
      next_col = (Col + col)->shared4.degree_next;
#line 2477
      if (prev_col == -1) {
#line 2479
        *(head + cur_score) = next_col;
      } else {
#line 2483
        (Col + prev_col)->shared4.degree_next = next_col;
      }
#line 2485
      if (next_col != -1) {
#line 2487
        (Col + next_col)->shared3.prev = prev_col;
      }
#line 2492
      cp = A + (Col + col)->start;
#line 2493
      cp_end = cp + (Col + col)->length;
      {
#line 2494
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2494
        if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 2494
          goto while_break___5;
        }
#line 2497
        tmp___4 = cp;
#line 2497
        cp ++;
#line 2497
        row = *tmp___4;
#line 2498
        row_mark = (Row + row)->shared2.mark;
#line 2500
        if (row_mark < 0) {
#line 2502
          goto while_continue___5;
        }
#line 2505
        set_difference = row_mark - tag_mark;
#line 2507
        if (set_difference < 0) {
#line 2510
          set_difference = (Row + row)->shared1.degree;
        }
#line 2513
        set_difference -= col_thickness;
#line 2516
        if (set_difference == 0) {
#line 2516
          if (aggressive) {
#line 2519
            (Row + row)->shared2.mark = -1;
          } else {
#line 2524
            (Row + row)->shared2.mark = set_difference + tag_mark;
          }
        } else {
#line 2524
          (Row + row)->shared2.mark = set_difference + tag_mark;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2539
    rp = A + pivot_row_start;
#line 2540
    rp_end = rp + pivot_row_length;
    {
#line 2541
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2541
      if (! ((unsigned long )rp < (unsigned long )rp_end)) {
#line 2541
        goto while_break___6;
      }
#line 2544
      tmp___5 = rp;
#line 2544
      rp ++;
#line 2544
      col = *tmp___5;
#line 2546
      hash = 0U;
#line 2547
      cur_score = 0;
#line 2548
      cp = A + (Col + col)->start;
#line 2550
      new_cp = cp;
#line 2551
      cp_end = cp + (Col + col)->length;
      {
#line 2555
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2555
        if (! ((unsigned long )cp < (unsigned long )cp_end)) {
#line 2555
          goto while_break___7;
        }
#line 2558
        tmp___6 = cp;
#line 2558
        cp ++;
#line 2558
        row = *tmp___6;
#line 2560
        row_mark = (Row + row)->shared2.mark;
#line 2562
        if (row_mark < 0) {
#line 2565
          goto while_continue___7;
        }
#line 2570
        tmp___7 = new_cp;
#line 2570
        new_cp ++;
#line 2570
        *tmp___7 = row;
#line 2572
        hash += (unsigned int )row;
#line 2574
        cur_score += row_mark - tag_mark;
#line 2576
        if (cur_score < n_col) {
#line 2576
          cur_score = cur_score;
        } else {
#line 2576
          cur_score = n_col;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2580
      (Col + col)->length = (int )(new_cp - (A + (Col + col)->start));
#line 2584
      if ((Col + col)->length == 0) {
#line 2588
        (Col + col)->start = -1;
#line 2589
        pivot_row_degree -= (Col + col)->shared1.thickness;
#line 2592
        (Col + col)->shared2.order = k;
#line 2594
        k += (Col + col)->shared1.thickness;
      } else {
#line 2603
        (Col + col)->shared2.score = cur_score;
#line 2606
        hash %= (unsigned int )(n_col + 1);
#line 2611
        head_column = *(head + hash);
#line 2612
        if (head_column > -1) {
#line 2616
          first_col = (Col + head_column)->shared3.headhash;
#line 2617
          (Col + head_column)->shared3.headhash = col;
        } else {
#line 2622
          first_col = - (head_column + 2);
#line 2623
          *(head + hash) = - (col + 2);
        }
#line 2625
        (Col + col)->shared4.hash_next = first_col;
#line 2628
        (Col + col)->shared3.hash = (int )hash;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 2639
    detect_super_cols(Col, A, head, pivot_row_start, pivot_row_length);
#line 2649
    (Col + pivot_col)->start = -1;
#line 2653
    tag_mark = clear_mark((tag_mark + max_deg) + 1, max_mark, n_row, Row);
#line 2665
    rp = A + pivot_row_start;
#line 2667
    new_rp = rp;
#line 2668
    rp_end = rp + pivot_row_length;
    }
    {
#line 2669
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2669
      if (! ((unsigned long )rp < (unsigned long )rp_end)) {
#line 2669
        goto while_break___8;
      }
#line 2671
      tmp___8 = rp;
#line 2671
      rp ++;
#line 2671
      col = *tmp___8;
#line 2673
      if ((Col + col)->start < 0) {
#line 2675
        goto while_continue___8;
      }
#line 2677
      tmp___9 = new_rp;
#line 2677
      new_rp ++;
#line 2677
      *tmp___9 = col;
#line 2679
      tmp___10 = (Col + col)->length;
#line 2679
      ((Col + col)->length) ++;
#line 2679
      *(A + ((Col + col)->start + tmp___10)) = pivot_row;
#line 2684
      cur_score = (Col + col)->shared2.score + pivot_row_degree;
#line 2689
      max_score = (n_col - k) - (Col + col)->shared1.thickness;
#line 2692
      cur_score -= (Col + col)->shared1.thickness;
#line 2695
      if (cur_score < max_score) {
#line 2695
        cur_score = cur_score;
      } else {
#line 2695
        cur_score = max_score;
      }
#line 2699
      (Col + col)->shared2.score = cur_score;
#line 2708
      next_col = *(head + cur_score);
#line 2709
      (Col + col)->shared4.degree_next = next_col;
#line 2710
      (Col + col)->shared3.prev = -1;
#line 2711
      if (next_col != -1) {
#line 2713
        (Col + next_col)->shared3.prev = col;
      }
#line 2715
      *(head + cur_score) = col;
#line 2718
      if (min_score < cur_score) {
#line 2718
        min_score = min_score;
      } else {
#line 2718
        min_score = cur_score;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 2729
    if (pivot_row_degree > 0) {
#line 2733
      (Row + pivot_row)->start = pivot_row_start;
#line 2734
      (Row + pivot_row)->length = (int )(new_rp - (A + pivot_row_start));
#line 2736
      (Row + pivot_row)->shared1.degree = pivot_row_degree;
#line 2737
      (Row + pivot_row)->shared2.mark = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2747
  return (ngarbage);
}
}
#line 2768 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static void order_children(int n_col , Colamd_Col *Col , int *p ) 
{ 
  int i ;
  int c ;
  int parent ;
  int order ;
  int tmp ;

  {
#line 2786
  i = 0;
  {
#line 2786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2786
    if (! (i < n_col)) {
#line 2786
      goto while_break;
    }
#line 2790
    if (! ((Col + i)->start == -1)) {
#line 2790
      if ((Col + i)->shared2.order == -1) {
#line 2792
        parent = i;
        {
#line 2794
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2796
          parent = (Col + parent)->shared1.parent;
#line 2794
          if (! (! ((Col + parent)->start == -1))) {
#line 2794
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2801
        c = i;
#line 2803
        order = (Col + parent)->shared2.order;
        {
#line 2805
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2810
          tmp = order;
#line 2810
          order ++;
#line 2810
          (Col + c)->shared2.order = tmp;
#line 2812
          (Col + c)->shared1.parent = parent;
#line 2815
          c = (Col + c)->shared1.parent;
#line 2805
          if (! ((Col + c)->shared2.order == -1)) {
#line 2805
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2823
        (Col + parent)->shared2.order = order;
      }
    }
#line 2786
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2829
  c = 0;
  {
#line 2829
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2829
    if (! (c < n_col)) {
#line 2829
      goto while_break___2;
    }
#line 2831
    *(p + (Col + c)->shared2.order) = c;
#line 2829
    c ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2833
  return;
}
}
#line 2869 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static void detect_super_cols(Colamd_Col *Col , int *A , int *head , int row_start ,
                              int row_length ) 
{ 
  int hash ;
  int *rp ;
  int c ;
  int super_c ;
  int *cp1 ;
  int *cp2 ;
  int length ;
  int prev_c ;
  int i ;
  int *rp_end ;
  int col ;
  int head_column ;
  int first_col ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 2904
  rp = A + row_start;
#line 2905
  rp_end = rp + row_length;
  {
#line 2906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2906
    if (! ((unsigned long )rp < (unsigned long )rp_end)) {
#line 2906
      goto while_break;
    }
#line 2908
    tmp = rp;
#line 2908
    rp ++;
#line 2908
    col = *tmp;
#line 2909
    if ((Col + col)->start < 0) {
#line 2911
      goto while_continue;
    }
#line 2915
    hash = (Col + col)->shared3.hash;
#line 2920
    head_column = *(head + hash);
#line 2921
    if (head_column > -1) {
#line 2923
      first_col = (Col + head_column)->shared3.headhash;
    } else {
#line 2927
      first_col = - (head_column + 2);
    }
#line 2932
    super_c = first_col;
    {
#line 2932
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2932
      if (! (super_c != -1)) {
#line 2932
        goto while_break___0;
      }
#line 2937
      length = (Col + super_c)->length;
#line 2940
      prev_c = super_c;
#line 2944
      c = (Col + super_c)->shared4.hash_next;
      {
#line 2944
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2944
        if (! (c != -1)) {
#line 2944
          goto while_break___1;
        }
#line 2952
        if ((Col + c)->length != length) {
#line 2955
          prev_c = c;
#line 2956
          goto __Cont;
        } else
#line 2952
        if ((Col + c)->shared2.score != (Col + super_c)->shared2.score) {
#line 2955
          prev_c = c;
#line 2956
          goto __Cont;
        }
#line 2960
        cp1 = A + (Col + super_c)->start;
#line 2961
        cp2 = A + (Col + c)->start;
#line 2963
        i = 0;
        {
#line 2963
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2963
          if (! (i < length)) {
#line 2963
            goto while_break___2;
          }
#line 2970
          tmp___0 = cp1;
#line 2970
          cp1 ++;
#line 2970
          tmp___1 = cp2;
#line 2970
          cp2 ++;
#line 2970
          if (*tmp___0 != *tmp___1) {
#line 2972
            goto while_break___2;
          }
#line 2963
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2977
        if (i != length) {
#line 2979
          prev_c = c;
#line 2980
          goto __Cont;
        }
#line 2987
        (Col + super_c)->shared1.thickness += (Col + c)->shared1.thickness;
#line 2988
        (Col + c)->shared1.parent = super_c;
#line 2989
        (Col + c)->start = -2;
#line 2991
        (Col + c)->shared2.order = -1;
#line 2993
        (Col + prev_c)->shared4.hash_next = (Col + c)->shared4.hash_next;
        __Cont: /* CIL Label */ 
#line 2944
        c = (Col + c)->shared4.hash_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2932
      super_c = (Col + super_c)->shared4.hash_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2999
    if (head_column > -1) {
#line 3002
      (Col + head_column)->shared3.headhash = -1;
    } else {
#line 3007
      *(head + hash) = -1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3010
  return;
}
}
#line 3026 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static int garbage_collection(int n_row , int n_col , Colamd_Row *Row , Colamd_Col *Col ,
                              int *A , int *pfree ) 
{ 
  int *psrc ;
  int *pdest ;
  int j ;
  int r ;
  int c ;
  int length ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 3056
  pdest = A + 0;
#line 3057
  c = 0;
  {
#line 3057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3057
    if (! (c < n_col)) {
#line 3057
      goto while_break;
    }
#line 3059
    if ((Col + c)->start >= 0) {
#line 3061
      psrc = A + (Col + c)->start;
#line 3065
      (Col + c)->start = (int )(pdest - (A + 0));
#line 3066
      length = (Col + c)->length;
#line 3067
      j = 0;
      {
#line 3067
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3067
        if (! (j < length)) {
#line 3067
          goto while_break___0;
        }
#line 3069
        tmp = psrc;
#line 3069
        psrc ++;
#line 3069
        r = *tmp;
#line 3070
        if ((Row + r)->shared2.mark >= 0) {
#line 3072
          tmp___0 = pdest;
#line 3072
          pdest ++;
#line 3072
          *tmp___0 = r;
        }
#line 3067
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3075
      (Col + c)->length = (int )(pdest - (A + (Col + c)->start));
    }
#line 3057
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3081
  r = 0;
  {
#line 3081
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3081
    if (! (r < n_row)) {
#line 3081
      goto while_break___1;
    }
#line 3083
    if ((Row + r)->shared2.mark < 0) {
#line 3089
      (Row + r)->shared2.mark = -1;
    } else
#line 3083
    if ((Row + r)->length == 0) {
#line 3089
      (Row + r)->shared2.mark = -1;
    } else {
#line 3094
      psrc = A + (Row + r)->start;
#line 3095
      (Row + r)->shared2.first_column = *psrc;
#line 3098
      *psrc = - r - 1;
    }
#line 3081
    r ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3107
  psrc = pdest;
  {
#line 3108
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3108
    if (! ((unsigned long )psrc < (unsigned long )pfree)) {
#line 3108
      goto while_break___2;
    }
#line 3111
    tmp___3 = psrc;
#line 3111
    psrc ++;
#line 3111
    if (*tmp___3 < 0) {
#line 3113
      psrc --;
#line 3115
      r = - *psrc - 1;
#line 3118
      *psrc = (Row + r)->shared2.first_column;
#line 3123
      (Row + r)->start = (int )(pdest - (A + 0));
#line 3124
      length = (Row + r)->length;
#line 3125
      j = 0;
      {
#line 3125
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3125
        if (! (j < length)) {
#line 3125
          goto while_break___3;
        }
#line 3127
        tmp___1 = psrc;
#line 3127
        psrc ++;
#line 3127
        c = *tmp___1;
#line 3128
        if ((Col + c)->start >= 0) {
#line 3130
          tmp___2 = pdest;
#line 3130
          pdest ++;
#line 3130
          *tmp___2 = c;
        }
#line 3125
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3133
      (Row + r)->length = (int )(pdest - (A + (Row + r)->start));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3145
  return ((int )(pdest - (A + 0)));
}
}
#line 3158 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static int clear_mark(int tag_mark , int max_mark , int n_row , Colamd_Row *Row ) 
{ 
  int r ;

  {
#line 3173
  if (tag_mark <= 0) {
#line 3173
    goto _L;
  } else
#line 3173
  if (tag_mark >= max_mark) {
    _L: /* CIL Label */ 
#line 3175
    r = 0;
    {
#line 3175
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3175
      if (! (r < n_row)) {
#line 3175
        goto while_break;
      }
#line 3177
      if ((Row + r)->shared2.mark >= 0) {
#line 3179
        (Row + r)->shared2.mark = 0;
      }
#line 3175
      r ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3182
    tag_mark = 1;
  }
#line 3185
  return (tag_mark);
}
}
#line 3193 "/home/wslee/benchmarks/glpk-4.38/src/colamd/colamd.c"
static void print_report(char *method , int *stats ) 
{ 
  int i1 ;
  int i2 ;
  int i3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 3202
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3202
    _glp_lib_xprintf("\n%s version %d.%d, %s: ", method, 2, 7, "Nov 1, 2007");
    }
  }
#line 3205
  if (! stats) {
#line 3207
    if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
      {
#line 3207
      _glp_lib_xprintf("No statistics available.\n");
      }
    }
#line 3208
    return;
  }
#line 3211
  i1 = *(stats + 4);
#line 3212
  i2 = *(stats + 5);
#line 3213
  i3 = *(stats + 6);
#line 3215
  if (*(stats + 3) >= 0) {
#line 3217
    if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
      {
#line 3217
      _glp_lib_xprintf("OK.  ");
      }
    }
  } else
#line 3221
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3221
    _glp_lib_xprintf("ERROR.  ");
    }
  }
  {
#line 3227
  if (*(stats + 3) == 1) {
#line 3227
    goto case_1;
  }
#line 3242
  if (*(stats + 3) == 0) {
#line 3242
    goto case_0;
  }
#line 3256
  if (*(stats + 3) == -1) {
#line 3256
    goto case_neg_1;
  }
#line 3261
  if (*(stats + 3) == -2) {
#line 3261
    goto case_neg_2;
  }
#line 3266
  if (*(stats + 3) == -3) {
#line 3266
    goto case_neg_3;
  }
#line 3271
  if (*(stats + 3) == -4) {
#line 3271
    goto case_neg_4;
  }
#line 3276
  if (*(stats + 3) == -5) {
#line 3276
    goto case_neg_5;
  }
#line 3281
  if (*(stats + 3) == -6) {
#line 3281
    goto case_neg_6;
  }
#line 3286
  if (*(stats + 3) == -7) {
#line 3286
    goto case_neg_7;
  }
#line 3293
  if (*(stats + 3) == -8) {
#line 3293
    goto case_neg_8;
  }
#line 3300
  if (*(stats + 3) == -9) {
#line 3300
    goto case_neg_9;
  }
#line 3307
  if (*(stats + 3) == -10) {
#line 3307
    goto case_neg_10;
  }
#line 3224
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3229
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3229
    _glp_lib_xprintf("Matrix has unsorted or duplicate row indices.\n");
    }
  }
#line 3231
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3231
    _glp_lib_xprintf("%s: number of duplicate or out-of-order row indices: %d\n",
                     method, i3);
    }
  }
#line 3234
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3234
    _glp_lib_xprintf("%s: last seen duplicate or out-of-order row index:   %d\n",
                     method, i2);
    }
  }
#line 3237
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3237
    _glp_lib_xprintf("%s: last seen in column:                             %d", method,
                     i1);
    }
  }
  case_0: /* CIL Label */ 
#line 3244
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3244
    _glp_lib_xprintf("\n");
    }
  }
#line 3246
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3246
    _glp_lib_xprintf("%s: number of dense or empty rows ignored:           %d\n",
                     method, *(stats + 0));
    }
  }
#line 3249
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3249
    _glp_lib_xprintf("%s: number of dense or empty columns ignored:        %d\n",
                     method, *(stats + 1));
    }
  }
#line 3252
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3252
    _glp_lib_xprintf("%s: number of garbage collections performed:         %d\n",
                     method, *(stats + 2));
    }
  }
#line 3254
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 3258
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3258
    _glp_lib_xprintf("Array A (row indices of matrix) not present.\n");
    }
  }
#line 3259
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 3263
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3263
    _glp_lib_xprintf("Array p (column pointers for matrix) not present.\n");
    }
  }
#line 3264
  goto switch_break;
  case_neg_3: /* CIL Label */ 
#line 3268
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3268
    _glp_lib_xprintf("Invalid number of rows (%d).\n", i1);
    }
  }
#line 3269
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 3273
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3273
    _glp_lib_xprintf("Invalid number of columns (%d).\n", i1);
    }
  }
#line 3274
  goto switch_break;
  case_neg_5: /* CIL Label */ 
#line 3278
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3278
    _glp_lib_xprintf("Invalid number of nonzero entries (%d).\n", i1);
    }
  }
#line 3279
  goto switch_break;
  case_neg_6: /* CIL Label */ 
#line 3283
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3283
    _glp_lib_xprintf("Invalid column pointer, p [0] = %d, must be zero.\n", i1);
    }
  }
#line 3284
  goto switch_break;
  case_neg_7: /* CIL Label */ 
#line 3288
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3288
    _glp_lib_xprintf("Array A too small.\n");
    }
  }
#line 3289
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3289
    _glp_lib_xprintf("        Need Alen >= %d, but given only Alen = %d.\n", i1, i2);
    }
  }
#line 3291
  goto switch_break;
  case_neg_8: /* CIL Label */ 
#line 3295
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3295
    _glp_lib_xprintf("Column %d has a negative number of nonzero entries (%d).\n",
                     i1, i2);
    }
  }
#line 3298
  goto switch_break;
  case_neg_9: /* CIL Label */ 
#line 3302
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3302
    _glp_lib_xprintf("Row index (row %d) out of bounds (%d to %d) in column %d.\n",
                     i2, 0, i3 - 1, i1);
    }
  }
#line 3305
  goto switch_break;
  case_neg_10: /* CIL Label */ 
#line 3309
  if ((unsigned long )(& _glp_lib_xprintf) != (unsigned long )((void *)0)) {
    {
#line 3309
    _glp_lib_xprintf("Out of memory.\n");
    }
  }
#line 3310
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3314
  return;
}
}
#line 54 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd.h"
int _glp_amd_valid(int n_row , int n_col , int const   *Ap , int const   *Ai ) ;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_valid.c"
int _glp_amd_valid(int n_row , int n_col , int const   *Ap , int const   *Ai ) 
{ 
  int nz ;
  int j ;
  int p1 ;
  int p2 ;
  int ilast ;
  int i ;
  int p ;
  int result ;

  {
#line 48
  result = 0;
#line 50
  if (n_row < 0) {
#line 52
    return (-2);
  } else
#line 50
  if (n_col < 0) {
#line 52
    return (-2);
  } else
#line 50
  if ((unsigned long )Ap == (unsigned long )((void *)0)) {
#line 52
    return (-2);
  } else
#line 50
  if ((unsigned long )Ai == (unsigned long )((void *)0)) {
#line 52
    return (-2);
  }
#line 54
  nz = (int )*(Ap + n_col);
#line 55
  if (*(Ap + 0) != 0) {
#line 59
    return (-2);
  } else
#line 55
  if (nz < 0) {
#line 59
    return (-2);
  }
#line 61
  j = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (j < n_col)) {
#line 61
      goto while_break;
    }
#line 63
    p1 = (int )*(Ap + j);
#line 64
    p2 = (int )*(Ap + (j + 1));
#line 66
    if (p1 > p2) {
#line 70
      return (-2);
    }
#line 72
    ilast = -1;
#line 73
    p = p1;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! (p < p2)) {
#line 73
        goto while_break___0;
      }
#line 75
      i = (int )*(Ai + p);
#line 77
      if (i < 0) {
#line 81
        return (-2);
      } else
#line 77
      if (i >= n_row) {
#line 81
        return (-2);
      }
#line 83
      if (i <= ilast) {
#line 87
        result = 1;
      }
#line 89
      ilast = i;
#line 73
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return (result);
}
}
#line 93 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_internal.h"
void _glp_amd_preprocess(int n , int const   *Ap , int const   *Ai , int *Rp , int *Ri ,
                         int *W , int *Flag ) ;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_preprocess.c"
void _glp_amd_preprocess(int n , int const   *Ap , int const   *Ai , int *Rp , int *Ri ,
                         int *W , int *Flag ) 
{ 
  int i ;
  int j ;
  int p ;
  int p2 ;
  int tmp ;

  {
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < n)) {
#line 57
      goto while_break;
    }
#line 59
    *(W + i) = 0;
#line 60
    *(Flag + i) = -1;
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  j = 0;
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! (j < n)) {
#line 62
      goto while_break___0;
    }
#line 64
    p2 = (int )*(Ap + (j + 1));
#line 65
    p = (int )*(Ap + j);
    {
#line 65
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 65
      if (! (p < p2)) {
#line 65
        goto while_break___1;
      }
#line 67
      i = (int )*(Ai + p);
#line 68
      if (*(Flag + i) != j) {
#line 71
        (*(W + i)) ++;
#line 72
        *(Flag + i) = j;
      }
#line 65
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 62
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  *(Rp + 0) = 0;
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 82
    if (! (i < n)) {
#line 82
      goto while_break___2;
    }
#line 84
    *(Rp + (i + 1)) = *(Rp + i) + *(W + i);
#line 82
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break___3;
    }
#line 88
    *(W + i) = *(Rp + i);
#line 89
    *(Flag + i) = -1;
#line 86
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 97
  j = 0;
  {
#line 97
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 97
    if (! (j < n)) {
#line 97
      goto while_break___4;
    }
#line 99
    p2 = (int )*(Ap + (j + 1));
#line 100
    p = (int )*(Ap + j);
    {
#line 100
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 100
      if (! (p < p2)) {
#line 100
        goto while_break___5;
      }
#line 102
      i = (int )*(Ai + p);
#line 103
      if (*(Flag + i) != j) {
#line 106
        tmp = *(W + i);
#line 106
        (*(W + i)) ++;
#line 106
        *(Ri + tmp) = j;
#line 107
        *(Flag + i) = j;
      }
#line 100
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 97
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 119
  return;
}
}
#line 80 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_internal.h"
void _glp_amd_postorder(int nn , int *Parent , int *Nv , int *Fsize , int *Order ,
                        int *Child , int *Sibling , int *Stack ) ;
#line 88
int _glp_amd_post_tree(int root , int k , int *Child , int const   *Sibling , int *Order ,
                       int *Stack ) ;
#line 16 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_postorder.c"
void _glp_amd_postorder(int nn , int *Parent , int *Nv , int *Fsize , int *Order ,
                        int *Child , int *Sibling , int *Stack ) 
{ 
  int i ;
  int j ;
  int k ;
  int parent ;
  int frsize ;
  int f ;
  int fprev ;
  int maxfrsize ;
  int bigfprev ;
  int bigf ;
  int fnext ;

  {
#line 36
  j = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (j < nn)) {
#line 36
      goto while_break;
    }
#line 38
    *(Child + j) = -1;
#line 39
    *(Sibling + j) = -1;
#line 36
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  j = nn - 1;
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! (j >= 0)) {
#line 46
      goto while_break___0;
    }
#line 48
    if (*(Nv + j) > 0) {
#line 51
      parent = *(Parent + j);
#line 52
      if (parent != -1) {
#line 56
        *(Sibling + j) = *(Child + parent);
#line 57
        *(Child + parent) = j;
      }
    }
#line 46
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 103
    if (! (i < nn)) {
#line 103
      goto while_break___1;
    }
#line 105
    if (*(Nv + i) > 0) {
#line 105
      if (*(Child + i) != -1) {
#line 122
        fprev = -1;
#line 123
        maxfrsize = -1;
#line 124
        bigfprev = -1;
#line 125
        bigf = -1;
#line 126
        f = *(Child + i);
        {
#line 126
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 126
          if (! (f != -1)) {
#line 126
            goto while_break___2;
          }
#line 129
          frsize = *(Fsize + f);
#line 130
          if (frsize >= maxfrsize) {
#line 133
            maxfrsize = frsize;
#line 134
            bigfprev = fprev;
#line 135
            bigf = f;
          }
#line 137
          fprev = f;
#line 126
          f = *(Sibling + f);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 141
        fnext = *(Sibling + bigf);
#line 146
        if (fnext != -1) {
#line 150
          if (bigfprev == -1) {
#line 153
            *(Child + i) = fnext;
          } else {
#line 158
            *(Sibling + bigfprev) = fnext;
          }
#line 162
          *(Sibling + bigf) = -1;
#line 166
          *(Sibling + fprev) = bigf;
        }
      }
    }
#line 103
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 188
  i = 0;
  {
#line 188
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 188
    if (! (i < nn)) {
#line 188
      goto while_break___3;
    }
#line 190
    *(Order + i) = -1;
#line 188
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 193
  k = 0;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 195
    if (! (i < nn)) {
#line 195
      goto while_break___4;
    }
#line 197
    if (*(Parent + i) == -1) {
#line 197
      if (*(Nv + i) > 0) {
        {
#line 200
        k = _glp_amd_post_tree(i, k, Child, (int const   *)Sibling, Order, Stack);
        }
      }
    }
#line 195
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 16 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_post_tree.c"
int _glp_amd_post_tree(int root , int k , int *Child , int const   *Sibling , int *Order ,
                       int *Stack ) 
{ 
  int f ;
  int head ;
  int h ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 60
  head = 0;
#line 61
  *(Stack + 0) = root;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (head >= 0)) {
#line 63
      goto while_break;
    }
#line 67
    i = *(Stack + head);
#line 71
    if (*(Child + i) != -1) {
#line 77
      f = *(Child + i);
      {
#line 77
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 77
        if (! (f != -1)) {
#line 77
          goto while_break___0;
        }
#line 79
        head ++;
#line 77
        f = (int )*(Sibling + f);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 83
      h = head;
#line 85
      f = *(Child + i);
      {
#line 85
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 85
        if (! (f != -1)) {
#line 85
          goto while_break___1;
        }
#line 88
        tmp = h;
#line 88
        h --;
#line 88
        *(Stack + tmp) = f;
#line 85
        f = (int )*(Sibling + f);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 95
      *(Child + i) = -1;
    } else {
#line 101
      head --;
#line 103
      tmp___0 = k;
#line 103
      k ++;
#line 103
      *(Order + i) = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (k);
}
}
#line 45 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd.h"
int _glp_amd_order(int n , int const   *Ap , int const   *Ai , int *P , double *Control ,
                   double *Info ) ;
#line 242 "./glplib.h"
void *_glp_lib_xmalloc(int size ) ;
#line 256
void _glp_lib_xfree(void *ptr ) ;
#line 72 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_internal.h"
size_t _glp_amd_aat(int n , int const   *Ap , int const   *Ai , int *Len , int *Tp ,
                    double *Info ) ;
#line 76
void _glp_amd_1(int n , int const   *Ap , int const   *Ai , int *P , int *Pinv , int *Len ,
                int slen , int *S , double *Control , double *Info ) ;
#line 22 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_order.c"
int _glp_amd_order(int n , int const   *Ap , int const   *Ai , int *P , double *Control ,
                   double *Info ) 
{ 
  int *Len ;
  int *S ;
  int nz ;
  int i ;
  int *Pinv ;
  int info ;
  int status ;
  int *Rp ;
  int *Ri ;
  int *Cp ;
  int *Ci ;
  int ok ;
  size_t nzaat ;
  size_t slen ;
  double mem ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 34
  mem = (double )0;
#line 41
  info = (unsigned long )Info != (unsigned long )((double *)((void *)0));
#line 42
  if (info) {
#line 44
    i = 0;
    {
#line 44
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      if (! (i < 20)) {
#line 44
        goto while_break;
      }
#line 46
      *(Info + i) = (double )-1;
#line 44
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 48
    *(Info + 1) = (double )n;
#line 49
    *(Info + 0) = (double )0;
  }
#line 53
  if ((unsigned long )Ai == (unsigned long )((int *)((void *)0))) {
#line 53
    goto _L;
  } else
#line 53
  if ((unsigned long )Ap == (unsigned long )((int *)((void *)0))) {
#line 53
    goto _L;
  } else
#line 53
  if ((unsigned long )P == (unsigned long )((int *)((void *)0))) {
#line 53
    goto _L;
  } else
#line 53
  if (n < 0) {
    _L: /* CIL Label */ 
#line 55
    if (info) {
#line 55
      *(Info + 0) = (double )-2;
    }
#line 56
    return (-2);
  }
#line 59
  if (n == 0) {
#line 61
    return (0);
  }
#line 64
  nz = (int )*(Ap + n);
#line 65
  if (info) {
#line 67
    *(Info + 2) = (double )nz;
  }
#line 69
  if (nz < 0) {
#line 71
    if (info) {
#line 71
      *(Info + 0) = (double )-2;
    }
#line 72
    return (-2);
  }
#line 76
  if ((unsigned long )((size_t )n) >= 4294967295UL / sizeof(int )) {
#line 76
    goto _L___0;
  } else
#line 76
  if ((unsigned long )((size_t )nz) >= 4294967295UL / sizeof(int )) {
    _L___0: /* CIL Label */ 
#line 79
    if (info) {
#line 79
      *(Info + 0) = (double )-1;
    }
#line 80
    return (-1);
  }
  {
#line 84
  status = _glp_amd_valid(n, n, Ap, Ai);
  }
#line 86
  if (status == -2) {
#line 88
    if (info) {
#line 88
      *(Info + 0) = (double )-2;
    }
#line 89
    return (-2);
  }
  {
#line 93
  tmp = _glp_lib_xmalloc((int )((unsigned long )n * sizeof(int )));
#line 93
  Len = (int *)tmp;
#line 94
  tmp___0 = _glp_lib_xmalloc((int )((unsigned long )n * sizeof(int )));
#line 94
  Pinv = (int *)tmp___0;
#line 95
  mem += (double )n;
#line 96
  mem += (double )n;
  }
#line 97
  if (! Len) {
#line 97
    goto _L___1;
  } else
#line 97
  if (! Pinv) {
    _L___1: /* CIL Label */ 
    {
#line 100
    _glp_lib_xfree((void *)Len);
#line 101
    _glp_lib_xfree((void *)Pinv);
    }
#line 102
    if (info) {
#line 102
      *(Info + 0) = (double )-1;
    }
#line 103
    return (-1);
  }
#line 106
  if (status == 1) {
    {
#line 110
    tmp___1 = _glp_lib_xmalloc((int )((unsigned long )(n + 1) * sizeof(int )));
#line 110
    Rp = (int *)tmp___1;
    }
#line 111
    if (nz > 1) {
#line 111
      tmp___2 = nz;
    } else {
#line 111
      tmp___2 = 1;
    }
    {
#line 111
    tmp___3 = _glp_lib_xmalloc((int )((unsigned long )tmp___2 * sizeof(int )));
#line 111
    Ri = (int *)tmp___3;
#line 112
    mem += (double )(n + 1);
    }
#line 113
    if (nz > 1) {
#line 113
      tmp___4 = nz;
    } else {
#line 113
      tmp___4 = 1;
    }
#line 113
    mem += (double )tmp___4;
#line 114
    if (! Rp) {
#line 114
      goto _L___2;
    } else
#line 114
    if (! Ri) {
      _L___2: /* CIL Label */ 
      {
#line 117
      _glp_lib_xfree((void *)Rp);
#line 118
      _glp_lib_xfree((void *)Ri);
#line 119
      _glp_lib_xfree((void *)Len);
#line 120
      _glp_lib_xfree((void *)Pinv);
      }
#line 121
      if (info) {
#line 121
        *(Info + 0) = (double )-1;
      }
#line 122
      return (-1);
    }
    {
#line 125
    _glp_amd_preprocess(n, Ap, Ai, Rp, Ri, Len, Pinv);
#line 126
    Cp = Rp;
#line 127
    Ci = Ri;
    }
  } else {
#line 132
    Rp = (int *)((void *)0);
#line 133
    Ri = (int *)((void *)0);
#line 134
    Cp = (int *)Ap;
#line 135
    Ci = (int *)Ai;
  }
  {
#line 142
  nzaat = _glp_amd_aat(n, (int const   *)Cp, (int const   *)Ci, Len, P, Info);
#line 150
  S = (int *)((void *)0);
#line 151
  slen = nzaat;
#line 152
  ok = slen + nzaat / 5U >= slen;
#line 153
  slen += nzaat / 5U;
#line 154
  i = 0;
  }
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 154
    if (ok) {
#line 154
      if (! (i < 7)) {
#line 154
        goto while_break___0;
      }
    } else {
#line 154
      goto while_break___0;
    }
#line 156
    ok = slen + (size_t )n > slen;
#line 157
    slen += (size_t )n;
#line 154
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 159
  mem += (double )slen;
#line 160
  if (ok) {
#line 160
    if ((unsigned long )slen < 4294967295UL / sizeof(int )) {
#line 160
      tmp___5 = 1;
    } else {
#line 160
      tmp___5 = 0;
    }
  } else {
#line 160
    tmp___5 = 0;
  }
#line 160
  ok = tmp___5;
#line 161
  if (ok) {
#line 161
    if (slen < 2147483647U) {
#line 161
      tmp___6 = 1;
    } else {
#line 161
      tmp___6 = 0;
    }
  } else {
#line 161
    tmp___6 = 0;
  }
#line 161
  ok = tmp___6;
#line 162
  if (ok) {
    {
#line 164
    tmp___7 = _glp_lib_xmalloc((int )((unsigned long )slen * sizeof(int )));
#line 164
    S = (int *)tmp___7;
    }
  }
#line 167
  if (! S) {
    {
#line 170
    _glp_lib_xfree((void *)Rp);
#line 171
    _glp_lib_xfree((void *)Ri);
#line 172
    _glp_lib_xfree((void *)Len);
#line 173
    _glp_lib_xfree((void *)Pinv);
    }
#line 174
    if (info) {
#line 174
      *(Info + 0) = (double )-1;
    }
#line 175
    return (-1);
  }
#line 177
  if (info) {
#line 180
    *(Info + 7) = mem * (double )sizeof(int );
  }
  {
#line 187
  _glp_amd_1(n, (int const   *)Cp, (int const   *)Ci, P, Pinv, Len, (int )slen, S,
             Control, Info);
#line 193
  _glp_lib_xfree((void *)Rp);
#line 194
  _glp_lib_xfree((void *)Ri);
#line 195
  _glp_lib_xfree((void *)Len);
#line 196
  _glp_lib_xfree((void *)Pinv);
#line 197
  _glp_lib_xfree((void *)S);
  }
#line 198
  if (info) {
#line 198
    *(Info + 0) = (double )status;
  }
#line 199
  return (status);
}
}
#line 63 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd.h"
void _glp_amd_info(double *Info ) ;
#line 20 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_info.c"
void _glp_amd_info(double *Info ) 
{ 
  double n ;
  double ndiv ;
  double nmultsubs_ldl ;
  double nmultsubs_lu ;
  double lnz ;
  double lnzd ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 27
  _glp_lib_xprintf("\nAMD version %d.%d.%d, %s, results:\n", 2, 2, 0, "May 31, 2007");
  }
#line 30
  if (! Info) {
#line 32
    return;
  }
#line 35
  n = *(Info + 1);
#line 36
  ndiv = *(Info + 10);
#line 37
  nmultsubs_ldl = *(Info + 11);
#line 38
  nmultsubs_lu = *(Info + 12);
#line 39
  lnz = *(Info + 9);
#line 40
  if (n >= (double )0) {
#line 40
    if (lnz >= (double )0) {
#line 40
      lnzd = n + lnz;
    } else {
#line 40
      lnzd = (double )-1;
    }
  } else {
#line 40
    lnzd = (double )-1;
  }
  {
#line 43
  _glp_lib_xprintf("    status: ");
  }
#line 44
  if (*(Info + 0) == (double )0) {
    {
#line 46
    _glp_lib_xprintf("OK\n");
    }
  } else
#line 48
  if (*(Info + 0) == (double )-1) {
    {
#line 50
    _glp_lib_xprintf("out of memory\n");
    }
  } else
#line 52
  if (*(Info + 0) == (double )-2) {
    {
#line 54
    _glp_lib_xprintf("invalid matrix\n");
    }
  } else
#line 56
  if (*(Info + 0) == (double )1) {
    {
#line 58
    _glp_lib_xprintf("OK, but jumbled\n");
    }
  } else {
    {
#line 62
    _glp_lib_xprintf("unknown\n");
    }
  }
#line 66
  if (n >= (double )0) {
    {
#line 66
    _glp_lib_xprintf("    n, dimension of A:                                  %.20g\n",
                     n);
    }
  }
#line 67
  if (*(Info + 2) >= (double )0) {
    {
#line 67
    _glp_lib_xprintf("    nz, number of nonzeros in A:                        %.20g\n",
                     *(Info + 2));
    }
  }
#line 69
  if (*(Info + 3) >= (double )0) {
    {
#line 69
    _glp_lib_xprintf("    symmetry of A:                                      %.4f\n",
                     *(Info + 3));
    }
  }
#line 71
  if (*(Info + 4) >= (double )0) {
    {
#line 71
    _glp_lib_xprintf("    number of nonzeros on diagonal:                     %.20g\n",
                     *(Info + 4));
    }
  }
#line 73
  if (*(Info + 5) >= (double )0) {
    {
#line 73
    _glp_lib_xprintf("    nonzeros in pattern of A+A\' (excl. diagonal):       %.20g\n",
                     *(Info + 5));
    }
  }
#line 75
  if (*(Info + 6) >= (double )0) {
    {
#line 75
    _glp_lib_xprintf("    # dense rows/columns of A+A\':                       %.20g\n",
                     *(Info + 6));
    }
  }
#line 79
  if (*(Info + 7) >= (double )0) {
    {
#line 79
    _glp_lib_xprintf("    memory used, in bytes:                              %.20g\n",
                     *(Info + 7));
    }
  }
#line 81
  if (*(Info + 8) >= (double )0) {
    {
#line 81
    _glp_lib_xprintf("    # of memory compactions:                            %.20g\n",
                     *(Info + 8));
    }
  }
  {
#line 85
  _glp_lib_xprintf("\n    The following approximate statistics are for a subsequent\n    factorization of A(P,P) + A(P,P)\'.  They are slight upper\n    bounds if there are no dense rows/columns in A+A\', and become\n    looser if dense rows/columns exist.\n\n");
  }
#line 91
  if (lnz >= (double )0) {
    {
#line 91
    _glp_lib_xprintf("    nonzeros in L (excluding diagonal):                 %.20g\n",
                     lnz);
    }
  }
#line 93
  if (lnzd >= (double )0) {
    {
#line 93
    _glp_lib_xprintf("    nonzeros in L (including diagonal):                 %.20g\n",
                     lnzd);
    }
  }
#line 95
  if (ndiv >= (double )0) {
    {
#line 95
    _glp_lib_xprintf("    # divide operations for LDL\' or LU:                 %.20g\n",
                     ndiv);
    }
  }
#line 97
  if (nmultsubs_ldl >= (double )0) {
    {
#line 97
    _glp_lib_xprintf("    # multiply-subtract operations for LDL\':            %.20g\n",
                     nmultsubs_ldl);
    }
  }
#line 99
  if (nmultsubs_lu >= (double )0) {
    {
#line 99
    _glp_lib_xprintf("    # multiply-subtract operations for LU:              %.20g\n",
                     nmultsubs_lu);
    }
  }
#line 101
  if (*(Info + 13) >= (double )0) {
    {
#line 101
    _glp_lib_xprintf("    max nz. in any column of L (incl. diagonal):        %.20g\n",
                     *(Info + 13));
    }
  }
#line 106
  if (n >= (double )0) {
#line 106
    if (ndiv >= (double )0) {
#line 106
      if (nmultsubs_ldl >= (double )0) {
#line 106
        if (nmultsubs_lu >= (double )0) {
          {
#line 108
          _glp_lib_xprintf("\n    chol flop count for real A, sqrt counted as 1 flop: %.20g\n    LDL\' flop count for real A:                         %.20g\n    LDL\' flop count for complex A:                      %.20g\n    LU flop count for real A (with no pivoting):        %.20g\n    LU flop count for complex A (with no pivoting):     %.20g\n\n",
                           (n + ndiv) + (double )2 * nmultsubs_ldl, ndiv + (double )2 * nmultsubs_ldl,
                           (double )9 * ndiv + (double )8 * nmultsubs_ldl, ndiv + (double )2 * nmultsubs_lu,
                           (double )9 * ndiv + (double )8 * nmultsubs_lu);
          }
        }
      }
    }
  }
#line 120
  return;
}
}
#line 57 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd.h"
void _glp_amd_defaults(double *Control ) ;
#line 22 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_defaults.c"
void _glp_amd_defaults(double *Control ) 
{ 
  int i ;

  {
#line 29
  if ((unsigned long )Control != (unsigned long )((double *)((void *)0))) {
#line 31
    i = 0;
    {
#line 31
    while (1) {
      while_continue: /* CIL Label */ ;
#line 31
      if (! (i < 5)) {
#line 31
        goto while_break;
      }
#line 33
      *(Control + i) = (double )0;
#line 31
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 35
    *(Control + 0) = 10.0;
#line 36
    *(Control + 1) = (double )1;
  }
#line 38
  return;
}
}
#line 60 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd.h"
void _glp_amd_control(double *Control ) ;
#line 19 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_control.c"
void _glp_amd_control(double *Control ) 
{ 
  double alpha ;
  int aggressive ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 27
  if ((unsigned long )Control != (unsigned long )((double *)((void *)0))) {
#line 29
    alpha = *(Control + 0);
#line 30
    aggressive = *(Control + 1) != (double )0;
  } else {
#line 34
    alpha = 10.0;
#line 35
    aggressive = 1;
  }
  {
#line 38
  _glp_lib_xprintf("\nAMD version %d.%d.%d, %s: approximate minimum degree ordering\n    dense row parameter: %g\n",
                   2, 2, 0, "May 31, 2007", alpha);
  }
#line 42
  if (alpha < (double )0) {
    {
#line 44
    _glp_lib_xprintf("    no rows treated as dense\n");
    }
  } else {
    {
#line 48
    _glp_lib_xprintf("    (rows with more than max (%g * sqrt (n), 16) entries are\n    considered \"dense\", and placed last in output permutation)\n",
                     alpha);
    }
  }
#line 54
  if (aggressive) {
    {
#line 56
    _glp_lib_xprintf("    aggressive absorption:  yes\n");
    }
  } else {
    {
#line 60
    _glp_lib_xprintf("    aggressive absorption:  no\n");
    }
  }
  {
#line 63
  _glp_lib_xprintf("    size of AMD integer: %d\n\n", sizeof(int ));
  }
#line 64
  return;
}
}
#line 21 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_aat.c"
size_t _glp_amd_aat(int n , int const   *Ap , int const   *Ai , int *Len , int *Tp ,
                    double *Info ) 
{ 
  int p1 ;
  int p2 ;
  int p ;
  int i ;
  int j ;
  int pj ;
  int pj2 ;
  int k ;
  int nzdiag ;
  int nzboth ;
  int nz ;
  double sym ;
  size_t nzaat ;

  {
#line 41
  if ((unsigned long )Info != (unsigned long )((double *)((void *)0))) {
#line 44
    i = 0;
    {
#line 44
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      if (! (i < 20)) {
#line 44
        goto while_break;
      }
#line 46
      *(Info + i) = (double )-1;
#line 44
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 48
    *(Info + 0) = (double )0;
  }
#line 51
  k = 0;
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 51
    if (! (k < n)) {
#line 51
      goto while_break___0;
    }
#line 53
    *(Len + k) = 0;
#line 51
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  nzdiag = 0;
#line 57
  nzboth = 0;
#line 58
  nz = (int )*(Ap + n);
#line 60
  k = 0;
  {
#line 60
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! (k < n)) {
#line 60
      goto while_break___1;
    }
#line 62
    p1 = (int )*(Ap + k);
#line 63
    p2 = (int )*(Ap + (k + 1));
#line 67
    p = p1;
    {
#line 67
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 67
      if (! (p < p2)) {
#line 67
        goto while_break___2;
      }
#line 70
      j = (int )*(Ai + p);
#line 71
      if (j < k) {
#line 75
        (*(Len + j)) ++;
#line 76
        (*(Len + k)) ++;
#line 78
        p ++;
      } else
#line 80
      if (j == k) {
#line 83
        p ++;
#line 84
        nzdiag ++;
#line 85
        goto while_break___2;
      } else {
#line 90
        goto while_break___2;
      }
#line 96
      pj2 = (int )*(Ap + (j + 1));
#line 97
      pj = *(Tp + j);
      {
#line 97
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 97
        if (! (pj < pj2)) {
#line 97
          goto while_break___3;
        }
#line 99
        i = (int )*(Ai + pj);
#line 100
        if (i < k) {
#line 104
          (*(Len + i)) ++;
#line 105
          (*(Len + j)) ++;
#line 108
          pj ++;
        } else
#line 110
        if (i == k) {
#line 113
          pj ++;
#line 114
          nzboth ++;
#line 115
          goto while_break___3;
        } else {
#line 120
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 123
      *(Tp + j) = pj;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 126
    *(Tp + k) = p;
#line 60
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 130
  j = 0;
  {
#line 130
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 130
    if (! (j < n)) {
#line 130
      goto while_break___4;
    }
#line 132
    pj = *(Tp + j);
    {
#line 132
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 132
      if (! (pj < (int )*(Ap + (j + 1)))) {
#line 132
        goto while_break___5;
      }
#line 134
      i = (int )*(Ai + pj);
#line 137
      (*(Len + i)) ++;
#line 138
      (*(Len + j)) ++;
#line 132
      pj ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 130
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 154
  if (nz == nzdiag) {
#line 156
    sym = (double )1;
  } else {
#line 160
    sym = ((double )2 * (double )nzboth) / (double )(nz - nzdiag);
  }
#line 163
  nzaat = (size_t )0;
#line 164
  k = 0;
  {
#line 164
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 164
    if (! (k < n)) {
#line 164
      goto while_break___6;
    }
#line 166
    nzaat += (size_t )*(Len + k);
#line 164
    k ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 174
  if ((unsigned long )Info != (unsigned long )((double *)((void *)0))) {
#line 176
    *(Info + 0) = (double )0;
#line 177
    *(Info + 1) = (double )n;
#line 178
    *(Info + 2) = (double )nz;
#line 179
    *(Info + 3) = sym;
#line 180
    *(Info + 4) = (double )nzdiag;
#line 181
    *(Info + 5) = (double )nzaat;
  }
#line 184
  return (nzaat);
}
}
#line 49 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd.h"
void _glp_amd_2(int n , int *Pe , int *Iw , int *Len , int iwlen , int pfree , int *Nv ,
                int *Next , int *Last , int *Head , int *Elen , int *Degree , int *W ,
                double *Control , double *Info ) ;
#line 23 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_2.c"
static int clear_flag(int wflg , int wbig , int *W , int n ) 
{ 
  int x ;

  {
#line 26
  if (wflg < 2) {
#line 26
    goto _L;
  } else
#line 26
  if (wflg >= wbig) {
    _L: /* CIL Label */ 
#line 28
    x = 0;
    {
#line 28
    while (1) {
      while_continue: /* CIL Label */ ;
#line 28
      if (! (x < n)) {
#line 28
        goto while_break;
      }
#line 30
      if (*(W + x) != 0) {
#line 30
        *(W + x) = 1;
      }
#line 28
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 32
    wflg = 2;
  }
#line 35
  return (wflg);
}
}
#line 43 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_2.c"
void _glp_amd_2(int n , int *Pe , int *Iw , int *Len , int iwlen , int pfree , int *Nv ,
                int *Next , int *Last , int *Head , int *Elen , int *Degree , int *W ,
                double *Control , double *Info ) 
{ 
  int deg ;
  int degme ;
  int dext ;
  int lemax ;
  int e ;
  int elenme ;
  int eln ;
  int i ;
  int ilast ;
  int inext ;
  int j ;
  int jlast ;
  int jnext ;
  int k ;
  int knt1 ;
  int knt2 ;
  int knt3 ;
  int lenj ;
  int ln ;
  int me ;
  int mindeg ;
  int nel ;
  int nleft ;
  int nvi ;
  int nvj ;
  int nvpiv ;
  int slenme ;
  int wbig ;
  int we ;
  int wflg ;
  int wnvi ;
  int ok ;
  int ndense ;
  int ncmpa ;
  int dense ;
  int aggressive ;
  unsigned int hash ;
  double f ;
  double r ;
  double ndiv ;
  double s ;
  double nms_lu ;
  double nms_ldl ;
  double dmax ;
  double alpha ;
  double lnz ;
  double lnzme ;
  int p ;
  int p1 ;
  int p2 ;
  int p3 ;
  int p4 ;
  int pdst ;
  int pend ;
  int pj ;
  int pme ;
  int pme1 ;
  int pme2 ;
  int pn ;
  int psrc ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 572
  lnz = (double )0;
#line 573
  ndiv = (double )0;
#line 574
  nms_lu = (double )0;
#line 575
  nms_ldl = (double )0;
#line 576
  dmax = (double )1;
#line 577
  me = -1;
#line 579
  mindeg = 0;
#line 580
  ncmpa = 0;
#line 581
  nel = 0;
#line 582
  lemax = 0;
#line 585
  if ((unsigned long )Control != (unsigned long )((double *)((void *)0))) {
#line 587
    alpha = *(Control + 0);
#line 588
    aggressive = *(Control + 1) != (double )0;
  } else {
#line 592
    alpha = 10.0;
#line 593
    aggressive = 1;
  }
#line 596
  if (alpha < (double )0) {
#line 599
    dense = n - 2;
  } else {
    {
#line 603
    tmp = sqrt((double )n);
#line 603
    dense = (int )(alpha * tmp);
    }
  }
#line 605
  if (16 > dense) {
#line 605
    dense = 16;
  } else {
#line 605
    dense = dense;
  }
#line 606
  if (n < dense) {
#line 606
    dense = n;
  } else {
#line 606
    dense = dense;
  }
#line 610
  i = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (i < n)) {
#line 610
      goto while_break;
    }
#line 612
    *(Last + i) = -1;
#line 613
    *(Head + i) = -1;
#line 614
    *(Next + i) = -1;
#line 618
    *(Nv + i) = 1;
#line 619
    *(W + i) = 1;
#line 620
    *(Elen + i) = 0;
#line 621
    *(Degree + i) = *(Len + i);
#line 610
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 631
  wbig = 2147483647 - n;
#line 632
  wflg = clear_flag(0, wbig, W, n);
#line 638
  ndense = 0;
#line 640
  i = 0;
  }
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 640
    if (! (i < n)) {
#line 640
      goto while_break___0;
    }
#line 642
    deg = *(Degree + i);
#line 644
    if (deg == 0) {
#line 654
      *(Elen + i) = -3;
#line 655
      nel ++;
#line 656
      *(Pe + i) = -1;
#line 657
      *(W + i) = 0;
    } else
#line 660
    if (deg > dense) {
#line 671
      ndense ++;
#line 672
      *(Nv + i) = 0;
#line 673
      *(Elen + i) = -1;
#line 674
      nel ++;
#line 675
      *(Pe + i) = -1;
    } else {
#line 685
      inext = *(Head + deg);
#line 687
      if (inext != -1) {
#line 687
        *(Last + inext) = i;
      }
#line 688
      *(Next + i) = inext;
#line 689
      *(Head + deg) = i;
    }
#line 640
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 698
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 698
    if (! (nel < n)) {
#line 698
      goto while_break___1;
    }
#line 719
    deg = mindeg;
    {
#line 719
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 719
      if (! (deg < n)) {
#line 719
        goto while_break___2;
      }
#line 721
      me = *(Head + deg);
#line 722
      if (me != -1) {
#line 722
        goto while_break___2;
      }
#line 719
      deg ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 724
    mindeg = deg;
#line 732
    inext = *(Next + me);
#line 734
    if (inext != -1) {
#line 734
      *(Last + inext) = -1;
    }
#line 735
    *(Head + deg) = inext;
#line 742
    elenme = *(Elen + me);
#line 743
    nvpiv = *(Nv + me);
#line 745
    nel += nvpiv;
#line 760
    *(Nv + me) = - nvpiv;
#line 761
    degme = 0;
#line 764
    if (elenme == 0) {
#line 771
      pme1 = *(Pe + me);
#line 772
      pme2 = pme1 - 1;
#line 774
      p = pme1;
      {
#line 774
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 774
        if (! (p <= (pme1 + *(Len + me)) - 1)) {
#line 774
          goto while_break___3;
        }
#line 776
        i = *(Iw + p);
#line 778
        nvi = *(Nv + i);
#line 779
        if (nvi > 0) {
#line 788
          degme += nvi;
#line 789
          *(Nv + i) = - nvi;
#line 790
          pme2 ++;
#line 790
          *(Iw + pme2) = i;
#line 796
          ilast = *(Last + i);
#line 797
          inext = *(Next + i);
#line 800
          if (inext != -1) {
#line 800
            *(Last + inext) = ilast;
          }
#line 801
          if (ilast != -1) {
#line 803
            *(Next + ilast) = inext;
          } else {
#line 809
            *(Head + *(Degree + i)) = inext;
          }
        }
#line 774
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 821
      p = *(Pe + me);
#line 822
      pme1 = pfree;
#line 823
      slenme = *(Len + me) - elenme;
#line 825
      knt1 = 1;
      {
#line 825
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 825
        if (! (knt1 <= elenme + 1)) {
#line 825
          goto while_break___4;
        }
#line 828
        if (knt1 > elenme) {
#line 831
          e = me;
#line 832
          pj = p;
#line 833
          ln = slenme;
        } else {
#line 839
          tmp___0 = p;
#line 839
          p ++;
#line 839
          e = *(Iw + tmp___0);
#line 841
          pj = *(Pe + e);
#line 842
          ln = *(Len + e);
        }
#line 855
        knt2 = 1;
        {
#line 855
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 855
          if (! (knt2 <= ln)) {
#line 855
            goto while_break___5;
          }
#line 857
          tmp___1 = pj;
#line 857
          pj ++;
#line 857
          i = *(Iw + tmp___1);
#line 859
          nvi = *(Nv + i);
#line 863
          if (nvi > 0) {
#line 870
            if (pfree >= iwlen) {
#line 880
              *(Pe + me) = p;
#line 881
              *(Len + me) -= knt1;
#line 883
              if (*(Len + me) == 0) {
#line 883
                *(Pe + me) = -1;
              }
#line 884
              *(Pe + e) = pj;
#line 885
              *(Len + e) = ln - knt2;
#line 887
              if (*(Len + e) == 0) {
#line 887
                *(Pe + e) = -1;
              }
#line 889
              ncmpa ++;
#line 893
              j = 0;
              {
#line 893
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 893
                if (! (j < n)) {
#line 893
                  goto while_break___6;
                }
#line 895
                pn = *(Pe + j);
#line 896
                if (pn >= 0) {
#line 899
                  *(Pe + j) = *(Iw + pn);
#line 900
                  *(Iw + pn) = - j - 2;
                }
#line 893
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 905
              psrc = 0;
#line 906
              pdst = 0;
#line 907
              pend = pme1 - 1;
              {
#line 909
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 909
                if (! (psrc <= pend)) {
#line 909
                  goto while_break___7;
                }
#line 912
                tmp___2 = psrc;
#line 912
                psrc ++;
#line 912
                j = - *(Iw + tmp___2) - 2;
#line 913
                if (j >= 0) {
#line 916
                  *(Iw + pdst) = *(Pe + j);
#line 917
                  tmp___3 = pdst;
#line 917
                  pdst ++;
#line 917
                  *(Pe + j) = tmp___3;
#line 918
                  lenj = *(Len + j);
#line 920
                  knt3 = 0;
                  {
#line 920
                  while (1) {
                    while_continue___8: /* CIL Label */ ;
#line 920
                    if (! (knt3 <= lenj - 2)) {
#line 920
                      goto while_break___8;
                    }
#line 922
                    tmp___4 = pdst;
#line 922
                    pdst ++;
#line 922
                    tmp___5 = psrc;
#line 922
                    psrc ++;
#line 922
                    *(Iw + tmp___4) = *(Iw + tmp___5);
#line 920
                    knt3 ++;
                  }
                  while_break___8: /* CIL Label */ ;
                  }
                }
              }
              while_break___7: /* CIL Label */ ;
              }
#line 928
              p1 = pdst;
#line 929
              psrc = pme1;
              {
#line 929
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 929
                if (! (psrc <= pfree - 1)) {
#line 929
                  goto while_break___9;
                }
#line 931
                tmp___6 = pdst;
#line 931
                pdst ++;
#line 931
                *(Iw + tmp___6) = *(Iw + psrc);
#line 929
                psrc ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 933
              pme1 = p1;
#line 934
              pfree = pdst;
#line 935
              pj = *(Pe + e);
#line 936
              p = *(Pe + me);
            }
#line 946
            degme += nvi;
#line 947
            *(Nv + i) = - nvi;
#line 948
            tmp___7 = pfree;
#line 948
            pfree ++;
#line 948
            *(Iw + tmp___7) = i;
#line 955
            ilast = *(Last + i);
#line 956
            inext = *(Next + i);
#line 959
            if (inext != -1) {
#line 959
              *(Last + inext) = ilast;
            }
#line 960
            if (ilast != -1) {
#line 962
              *(Next + ilast) = inext;
            } else {
#line 968
              *(Head + *(Degree + i)) = inext;
            }
          }
#line 855
          knt2 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 973
        if (e != me) {
#line 978
          *(Pe + e) = - me - 2;
#line 979
          *(W + e) = 0;
        }
#line 825
        knt1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 983
      pme2 = pfree - 1;
    }
    {
#line 991
    *(Degree + me) = degme;
#line 992
    *(Pe + me) = pme1;
#line 993
    *(Len + me) = (pme2 - pme1) + 1;
#line 996
    *(Elen + me) = - (nvpiv + degme) - 2;
#line 1013
    wflg = clear_flag(wflg, wbig, W, n);
#line 1034
    pme = pme1;
    }
    {
#line 1034
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1034
      if (! (pme <= pme2)) {
#line 1034
        goto while_break___10;
      }
#line 1036
      i = *(Iw + pme);
#line 1038
      eln = *(Elen + i);
#line 1040
      if (eln > 0) {
#line 1043
        nvi = - *(Nv + i);
#line 1045
        wnvi = wflg - nvi;
#line 1046
        p = *(Pe + i);
        {
#line 1046
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1046
          if (! (p <= (*(Pe + i) + eln) - 1)) {
#line 1046
            goto while_break___11;
          }
#line 1048
          e = *(Iw + p);
#line 1050
          we = *(W + e);
#line 1052
          if (we >= wflg) {
#line 1056
            we -= nvi;
          } else
#line 1058
          if (we != 0) {
#line 1063
            we = *(Degree + e) + wnvi;
          }
#line 1066
          *(W + e) = we;
#line 1046
          p ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 1034
      pme ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1083
    pme = pme1;
    {
#line 1083
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1083
      if (! (pme <= pme2)) {
#line 1083
        goto while_break___12;
      }
#line 1085
      i = *(Iw + pme);
#line 1088
      p1 = *(Pe + i);
#line 1089
      p2 = (p1 + *(Elen + i)) - 1;
#line 1090
      pn = p1;
#line 1091
      hash = 0U;
#line 1092
      deg = 0;
#line 1100
      if (aggressive) {
#line 1102
        p = p1;
        {
#line 1102
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1102
          if (! (p <= p2)) {
#line 1102
            goto while_break___13;
          }
#line 1104
          e = *(Iw + p);
#line 1106
          we = *(W + e);
#line 1107
          if (we != 0) {
#line 1111
            dext = we - wflg;
#line 1112
            if (dext > 0) {
#line 1114
              deg += dext;
#line 1115
              tmp___8 = pn;
#line 1115
              pn ++;
#line 1115
              *(Iw + tmp___8) = e;
#line 1116
              hash += (unsigned int )e;
            } else {
#line 1125
              *(Pe + e) = - me - 2;
#line 1126
              *(W + e) = 0;
            }
          }
#line 1102
          p ++;
        }
        while_break___13: /* CIL Label */ ;
        }
      } else {
#line 1133
        p = p1;
        {
#line 1133
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1133
          if (! (p <= p2)) {
#line 1133
            goto while_break___14;
          }
#line 1135
          e = *(Iw + p);
#line 1137
          we = *(W + e);
#line 1138
          if (we != 0) {
#line 1141
            dext = we - wflg;
#line 1143
            deg += dext;
#line 1144
            tmp___9 = pn;
#line 1144
            pn ++;
#line 1144
            *(Iw + tmp___9) = e;
#line 1145
            hash += (unsigned int )e;
          }
#line 1133
          p ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 1152
      *(Elen + i) = (pn - p1) + 1;
#line 1161
      p3 = pn;
#line 1162
      p4 = p1 + *(Len + i);
#line 1163
      p = p2 + 1;
      {
#line 1163
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1163
        if (! (p < p4)) {
#line 1163
          goto while_break___15;
        }
#line 1165
        j = *(Iw + p);
#line 1167
        nvj = *(Nv + j);
#line 1168
        if (nvj > 0) {
#line 1172
          deg += nvj;
#line 1173
          tmp___10 = pn;
#line 1173
          pn ++;
#line 1173
          *(Iw + tmp___10) = j;
#line 1174
          hash += (unsigned int )j;
        }
#line 1163
        p ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 1188
      if (*(Elen + i) == 1) {
#line 1188
        if (p3 == pn) {
#line 1216
          *(Pe + i) = - me - 2;
#line 1217
          nvi = - *(Nv + i);
#line 1218
          degme -= nvi;
#line 1219
          nvpiv += nvi;
#line 1220
          nel += nvi;
#line 1221
          *(Nv + i) = 0;
#line 1222
          *(Elen + i) = -1;
        } else {
#line 1188
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1235
        if (*(Degree + i) < deg) {
#line 1235
          *(Degree + i) = *(Degree + i);
        } else {
#line 1235
          *(Degree + i) = deg;
        }
#line 1242
        *(Iw + pn) = *(Iw + p3);
#line 1244
        *(Iw + p3) = *(Iw + p1);
#line 1246
        *(Iw + p1) = me;
#line 1248
        *(Len + i) = (pn - p1) + 1;
#line 1258
        hash %= (unsigned int )n;
#line 1262
        j = *(Head + hash);
#line 1263
        if (j <= -1) {
#line 1266
          *(Next + i) = - j - 2;
#line 1267
          *(Head + hash) = - i - 2;
        } else {
#line 1273
          *(Next + i) = *(Last + j);
#line 1274
          *(Last + j) = i;
        }
#line 1282
        *(Last + i) = (int )hash;
      }
#line 1083
      pme ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1286
    *(Degree + me) = degme;
#line 1293
    if (lemax > degme) {
#line 1293
      lemax = lemax;
    } else {
#line 1293
      lemax = degme;
    }
    {
#line 1294
    wflg += lemax;
#line 1295
    wflg = clear_flag(wflg, wbig, W, n);
#line 1303
    pme = pme1;
    }
    {
#line 1303
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1303
      if (! (pme <= pme2)) {
#line 1303
        goto while_break___16;
      }
#line 1305
      i = *(Iw + pme);
#line 1308
      if (*(Nv + i) < 0) {
#line 1320
        hash = (unsigned int )*(Last + i);
#line 1323
        j = *(Head + hash);
#line 1324
        if (j == -1) {
#line 1327
          i = -1;
        } else
#line 1329
        if (j < -1) {
#line 1332
          i = - j - 2;
#line 1333
          *(Head + hash) = -1;
        } else {
#line 1338
          i = *(Last + j);
#line 1339
          *(Last + j) = -1;
        }
        {
#line 1350
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 1350
          if (i != -1) {
#line 1350
            if (! (*(Next + i) != -1)) {
#line 1350
              goto while_break___17;
            }
          } else {
#line 1350
            goto while_break___17;
          }
#line 1359
          ln = *(Len + i);
#line 1360
          eln = *(Elen + i);
#line 1364
          p = *(Pe + i) + 1;
          {
#line 1364
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 1364
            if (! (p <= (*(Pe + i) + ln) - 1)) {
#line 1364
              goto while_break___18;
            }
#line 1367
            *(W + *(Iw + p)) = wflg;
#line 1364
            p ++;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 1374
          jlast = i;
#line 1375
          j = *(Next + i);
          {
#line 1378
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 1378
            if (! (j != -1)) {
#line 1378
              goto while_break___19;
            }
#line 1389
            if (*(Len + j) == ln) {
#line 1389
              if (*(Elen + j) == eln) {
#line 1389
                tmp___11 = 1;
              } else {
#line 1389
                tmp___11 = 0;
              }
            } else {
#line 1389
              tmp___11 = 0;
            }
#line 1389
            ok = tmp___11;
#line 1391
            p = *(Pe + j) + 1;
            {
#line 1391
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 1391
              if (ok) {
#line 1391
                if (! (p <= (*(Pe + j) + ln) - 1)) {
#line 1391
                  goto while_break___20;
                }
              } else {
#line 1391
                goto while_break___20;
              }
#line 1394
              if (*(W + *(Iw + p)) != wflg) {
#line 1394
                ok = 0;
              }
#line 1391
              p ++;
            }
            while_break___20: /* CIL Label */ ;
            }
#line 1396
            if (ok) {
#line 1403
              *(Pe + j) = - i - 2;
#line 1407
              *(Nv + i) += *(Nv + j);
#line 1408
              *(Nv + j) = 0;
#line 1409
              *(Elen + j) = -1;
#line 1412
              j = *(Next + j);
#line 1413
              *(Next + jlast) = j;
            } else {
#line 1419
              jlast = j;
#line 1421
              j = *(Next + j);
            }
          }
          while_break___19: /* CIL Label */ ;
          }
#line 1431
          wflg ++;
#line 1432
          i = *(Next + i);
        }
        while_break___17: /* CIL Label */ ;
        }
      }
#line 1303
      pme ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1444
    p = pme1;
#line 1445
    nleft = n - nel;
#line 1446
    pme = pme1;
    {
#line 1446
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1446
      if (! (pme <= pme2)) {
#line 1446
        goto while_break___21;
      }
#line 1448
      i = *(Iw + pme);
#line 1450
      nvi = - *(Nv + i);
#line 1452
      if (nvi > 0) {
#line 1456
        *(Nv + i) = nvi;
#line 1462
        deg = (*(Degree + i) + degme) - nvi;
#line 1463
        if (deg < nleft - nvi) {
#line 1463
          deg = deg;
        } else {
#line 1463
          deg = nleft - nvi;
        }
#line 1470
        inext = *(Head + deg);
#line 1472
        if (inext != -1) {
#line 1472
          *(Last + inext) = i;
        }
#line 1473
        *(Next + i) = inext;
#line 1474
        *(Last + i) = -1;
#line 1475
        *(Head + deg) = i;
#line 1481
        if (mindeg < deg) {
#line 1481
          mindeg = mindeg;
        } else {
#line 1481
          mindeg = deg;
        }
#line 1482
        *(Degree + i) = deg;
#line 1488
        tmp___12 = p;
#line 1488
        p ++;
#line 1488
        *(Iw + tmp___12) = i;
      }
#line 1446
      pme ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 1499
    *(Nv + me) = nvpiv;
#line 1501
    *(Len + me) = p - pme1;
#line 1502
    if (*(Len + me) == 0) {
#line 1506
      *(Pe + me) = -1;
#line 1507
      *(W + me) = 0;
    }
#line 1509
    if (elenme != 0) {
#line 1513
      pfree = p;
    }
#line 1523
    if ((unsigned long )Info != (unsigned long )((double *)((void *)0))) {
#line 1525
      f = (double )nvpiv;
#line 1526
      r = (double )(degme + ndense);
#line 1527
      if (dmax > f + r) {
#line 1527
        dmax = dmax;
      } else {
#line 1527
        dmax = f + r;
      }
#line 1530
      lnzme = f * r + ((f - (double )1) * f) / (double )2;
#line 1531
      lnz += lnzme;
#line 1534
      ndiv += lnzme;
#line 1537
      s = ((f * r) * r + (r * (f - (double )1)) * f) + (((f - (double )1) * f) * ((double )2 * f - (double )1)) / (double )6;
#line 1538
      nms_lu += s;
#line 1541
      nms_ldl += (s + lnzme) / (double )2;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1559
  if ((unsigned long )Info != (unsigned long )((double *)((void *)0))) {
#line 1563
    f = (double )ndense;
#line 1564
    if (dmax > (double )ndense) {
#line 1564
      dmax = dmax;
    } else {
#line 1564
      dmax = (double )ndense;
    }
#line 1567
    lnzme = ((f - (double )1) * f) / (double )2;
#line 1568
    lnz += lnzme;
#line 1571
    ndiv += lnzme;
#line 1574
    s = (((f - (double )1) * f) * ((double )2 * f - (double )1)) / (double )6;
#line 1575
    nms_lu += s;
#line 1578
    nms_ldl += (s + lnzme) / (double )2;
#line 1581
    *(Info + 9) = lnz;
#line 1584
    *(Info + 10) = ndiv;
#line 1587
    *(Info + 11) = nms_ldl;
#line 1590
    *(Info + 12) = nms_lu;
#line 1593
    *(Info + 6) = (double )ndense;
#line 1596
    *(Info + 13) = dmax;
#line 1599
    *(Info + 8) = (double )ncmpa;
#line 1602
    *(Info + 0) = (double )0;
  }
#line 1634
  i = 0;
  {
#line 1634
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 1634
    if (! (i < n)) {
#line 1634
      goto while_break___22;
    }
#line 1636
    *(Pe + i) = - *(Pe + i) - 2;
#line 1634
    i ++;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 1640
  i = 0;
  {
#line 1640
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 1640
    if (! (i < n)) {
#line 1640
      goto while_break___23;
    }
#line 1642
    *(Elen + i) = - *(Elen + i) - 2;
#line 1640
    i ++;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 1708
  i = 0;
  {
#line 1708
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 1708
    if (! (i < n)) {
#line 1708
      goto while_break___24;
    }
#line 1710
    if (*(Nv + i) == 0) {
#line 1721
      j = *(Pe + i);
#line 1724
      if (j == -1) {
#line 1728
        goto __Cont;
      }
      {
#line 1732
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 1732
        if (! (*(Nv + j) == 0)) {
#line 1732
          goto while_break___25;
        }
#line 1735
        j = *(Pe + j);
      }
      while_break___25: /* CIL Label */ ;
      }
#line 1740
      e = j;
#line 1749
      j = i;
      {
#line 1751
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 1751
        if (! (*(Nv + j) == 0)) {
#line 1751
          goto while_break___26;
        }
#line 1753
        jnext = *(Pe + j);
#line 1755
        *(Pe + j) = e;
#line 1756
        j = jnext;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1708
    i ++;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 1766
  _glp_amd_postorder(n, Pe, Nv, Elen, W, Head, Next, Last);
#line 1778
  k = 0;
  }
  {
#line 1778
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1778
    if (! (k < n)) {
#line 1778
      goto while_break___27;
    }
#line 1780
    *(Head + k) = -1;
#line 1781
    *(Next + k) = -1;
#line 1778
    k ++;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 1783
  e = 0;
  {
#line 1783
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 1783
    if (! (e < n)) {
#line 1783
      goto while_break___28;
    }
#line 1785
    k = *(W + e);
#line 1787
    if (k != -1) {
#line 1790
      *(Head + k) = e;
    }
#line 1783
    e ++;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 1796
  nel = 0;
#line 1797
  k = 0;
  {
#line 1797
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 1797
    if (! (k < n)) {
#line 1797
      goto while_break___29;
    }
#line 1799
    e = *(Head + k);
#line 1800
    if (e == -1) {
#line 1800
      goto while_break___29;
    }
#line 1802
    *(Next + e) = nel;
#line 1803
    nel += *(Nv + e);
#line 1797
    k ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 1808
  i = 0;
  {
#line 1808
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 1808
    if (! (i < n)) {
#line 1808
      goto while_break___30;
    }
#line 1810
    if (*(Nv + i) == 0) {
#line 1812
      e = *(Pe + i);
#line 1814
      if (e != -1) {
#line 1821
        *(Next + i) = *(Next + e);
#line 1822
        (*(Next + e)) ++;
      } else {
#line 1828
        tmp___13 = nel;
#line 1828
        nel ++;
#line 1828
        *(Next + i) = tmp___13;
      }
    }
#line 1808
    i ++;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 1835
  i = 0;
  {
#line 1835
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 1835
    if (! (i < n)) {
#line 1835
      goto while_break___31;
    }
#line 1837
    k = *(Next + i);
#line 1839
    *(Last + k) = i;
#line 1835
    i ++;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 1842
  return;
}
}
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/amd/amd_1.c"
void _glp_amd_1(int n , int const   *Ap , int const   *Ai , int *P , int *Pinv , int *Len ,
                int slen , int *S , double *Control , double *Info ) 
{ 
  int i ;
  int j ;
  int k ;
  int p ;
  int pfree ;
  int iwlen ;
  int pj ;
  int p1 ;
  int p2 ;
  int pj2 ;
  int *Iw ;
  int *Pe ;
  int *Nv ;
  int *Head ;
  int *Elen ;
  int *Degree ;
  int *s ;
  int *W ;
  int *Sp ;
  int *Tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 54
  iwlen = slen - 6 * n;
#line 55
  s = S;
#line 56
  Pe = s;
#line 56
  s += n;
#line 57
  Nv = s;
#line 57
  s += n;
#line 58
  Head = s;
#line 58
  s += n;
#line 59
  Elen = s;
#line 59
  s += n;
#line 60
  Degree = s;
#line 60
  s += n;
#line 61
  W = s;
#line 61
  s += n;
#line 62
  Iw = s;
#line 62
  s += iwlen;
#line 67
  Sp = Nv;
#line 68
  Tp = W;
#line 69
  pfree = 0;
#line 70
  j = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (j < n)) {
#line 70
      goto while_break;
    }
#line 72
    *(Pe + j) = pfree;
#line 73
    *(Sp + j) = pfree;
#line 74
    pfree += *(Len + j);
#line 70
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  k = 0;
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (k < n)) {
#line 87
      goto while_break___0;
    }
#line 90
    p1 = (int )*(Ap + k);
#line 91
    p2 = (int )*(Ap + (k + 1));
#line 94
    p = p1;
    {
#line 94
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 94
      if (! (p < p2)) {
#line 94
        goto while_break___1;
      }
#line 97
      j = (int )*(Ai + p);
#line 99
      if (j < k) {
#line 104
        tmp = *(Sp + j);
#line 104
        (*(Sp + j)) ++;
#line 104
        *(Iw + tmp) = k;
#line 105
        tmp___0 = *(Sp + k);
#line 105
        (*(Sp + k)) ++;
#line 105
        *(Iw + tmp___0) = j;
#line 106
        p ++;
      } else
#line 108
      if (j == k) {
#line 111
        p ++;
#line 112
        goto while_break___1;
      } else {
#line 117
        goto while_break___1;
      }
#line 122
      pj2 = (int )*(Ap + (j + 1));
#line 123
      pj = *(Tp + j);
      {
#line 123
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 123
        if (! (pj < pj2)) {
#line 123
          goto while_break___2;
        }
#line 125
        i = (int )*(Ai + pj);
#line 127
        if (i < k) {
#line 132
          tmp___1 = *(Sp + i);
#line 132
          (*(Sp + i)) ++;
#line 132
          *(Iw + tmp___1) = j;
#line 133
          tmp___2 = *(Sp + j);
#line 133
          (*(Sp + j)) ++;
#line 133
          *(Iw + tmp___2) = i;
#line 134
          pj ++;
        } else
#line 136
        if (i == k) {
#line 139
          pj ++;
#line 140
          goto while_break___2;
        } else {
#line 145
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 148
      *(Tp + j) = pj;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 150
    *(Tp + k) = p;
#line 87
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 154
  j = 0;
  {
#line 154
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 154
    if (! (j < n)) {
#line 154
      goto while_break___3;
    }
#line 156
    pj = *(Tp + j);
    {
#line 156
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 156
      if (! (pj < (int )*(Ap + (j + 1)))) {
#line 156
        goto while_break___4;
      }
#line 158
      i = (int )*(Ai + pj);
#line 163
      tmp___3 = *(Sp + i);
#line 163
      (*(Sp + i)) ++;
#line 163
      *(Iw + tmp___3) = j;
#line 164
      tmp___4 = *(Sp + j);
#line 164
      (*(Sp + j)) ++;
#line 164
      *(Iw + tmp___4) = i;
#line 156
      pj ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 154
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 179
  _glp_amd_2(n, Pe, Iw, Len, iwlen, pfree, Nv, Pinv, P, Head, Elen, Degree, W, Control,
             Info);
  }
#line 181
  return;
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 55 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 179
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 224 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
xerror_t _glp_lib_xerror1(char const   *file , int line ) ;
#line 238
void _glp_lib_xassert(char const   *expr , char const   *file , int line ) ;
#line 246
void *_glp_lib_xcalloc(int n , int size ) ;
#line 331
int _glp_lib_str2int(char const   *str , int *_val ) ;
#line 335
int _glp_lib_str2num(char const   *str , double *_val ) ;
#line 92 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.h"
TSP *_glp_tsp_read_data(char *fname ) ;
#line 95
void _glp_tsp_free_data(TSP *tsp ) ;
#line 98
int _glp_tsp_distance(TSP *tsp , int i , int j ) ;
#line 66 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int get_char(struct dsa *dsa ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 67
  dsa->c = fgetc(dsa->fp);
#line 68
  tmp___1 = ferror(dsa->fp);
  }
#line 68
  if (tmp___1) {
    {
#line 69
    tmp = __errno_location();
#line 69
    tmp___0 = strerror(*tmp);
#line 69
    _glp_lib_xprintf("%s:%d: read error - %s\n", dsa->fname, dsa->seqn, tmp___0);
    }
#line 71
    return (1);
  }
  {
#line 73
  tmp___4 = feof(dsa->fp);
  }
#line 73
  if (tmp___4) {
#line 74
    dsa->c = -1;
  } else
#line 75
  if (dsa->c == 10) {
#line 76
    (dsa->seqn) ++;
  } else {
    {
#line 77
    tmp___3 = __ctype_b_loc();
    }
#line 77
    if ((int const   )*(*tmp___3 + dsa->c) & 8192) {
#line 78
      dsa->c = ' ';
    } else {
      {
#line 79
      tmp___2 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___2 + dsa->c) & 2) {
        {
#line 80
        _glp_lib_xprintf("%s:%d: invalid control character 0x%02X\n", dsa->fname,
                         dsa->seqn, dsa->c);
        }
#line 82
        return (1);
      }
    }
  }
#line 84
  return (0);
}
}
#line 87 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int skip_spaces(struct dsa *dsa , int across ) 
{ 
  int tmp ;

  {
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (dsa->c == 32)) {
#line 88
      if (across) {
#line 88
        if (! (dsa->c == 10)) {
#line 88
          goto while_break;
        }
      } else {
#line 88
        goto while_break;
      }
    }
    {
#line 89
    tmp = get_char(dsa);
    }
#line 89
    if (tmp) {
#line 89
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (0);
}
}
#line 93 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int scan_keyword(struct dsa *dsa ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 94
  len = 0;
#line 95
  tmp = skip_spaces(dsa, 0);
  }
#line 95
  if (tmp) {
#line 95
    return (1);
  }
#line 96
  dsa->token[0] = (char )'\000';
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp___2 = __ctype_b_loc();
    }
#line 97
    if (! ((int const   )*(*tmp___2 + dsa->c) & 8)) {
#line 97
      if (! (dsa->c == 95)) {
#line 97
        goto while_break;
      }
    }
#line 98
    if (len == 31) {
      {
#line 99
      _glp_lib_xprintf("%s:%d: keyword `%s...\' too long\n", dsa->fname, dsa->seqn,
                       dsa->token);
      }
#line 101
      return (1);
    }
    {
#line 103
    tmp___0 = len;
#line 103
    len ++;
#line 103
    dsa->token[tmp___0] = (char )dsa->c;
#line 103
    dsa->token[len] = (char )'\000';
#line 104
    tmp___1 = get_char(dsa);
    }
#line 104
    if (tmp___1) {
#line 104
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (len == 0) {
    {
#line 107
    _glp_lib_xprintf("%s:%d: missing keyword\n", dsa->fname, dsa->seqn);
    }
#line 108
    return (1);
  }
#line 110
  return (0);
}
}
#line 113 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int check_colon(struct dsa *dsa ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 114
  tmp = skip_spaces(dsa, 0);
  }
#line 114
  if (tmp) {
#line 114
    return (1);
  }
#line 115
  if (dsa->c != 58) {
    {
#line 116
    _glp_lib_xprintf("%s:%d: missing colon after `%s\'\n", dsa->fname, dsa->seqn,
                     dsa->token);
    }
#line 118
    return (1);
  }
  {
#line 120
  tmp___0 = get_char(dsa);
  }
#line 120
  if (tmp___0) {
#line 120
    return (1);
  }
#line 121
  return (0);
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int scan_token(struct dsa *dsa , int across ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 125
  len = 0;
#line 126
  tmp = skip_spaces(dsa, across);
  }
#line 126
  if (tmp) {
#line 126
    return (1);
  }
#line 127
  dsa->token[0] = (char )'\000';
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (dsa->c == -1) {
#line 128
      goto while_break;
    } else
#line 128
    if (dsa->c == 10) {
#line 128
      goto while_break;
    } else
#line 128
    if (dsa->c == 32) {
#line 128
      goto while_break;
    }
#line 129
    if (len == 255) {
      {
#line 130
      dsa->token[31] = (char )'\000';
#line 131
      _glp_lib_xprintf("%s:%d: token `%s...\' too long\n", dsa->fname, dsa->seqn,
                       dsa->token);
      }
#line 133
      return (1);
    }
    {
#line 135
    tmp___0 = len;
#line 135
    len ++;
#line 135
    dsa->token[tmp___0] = (char )dsa->c;
#line 135
    dsa->token[len] = (char )'\000';
#line 136
    tmp___1 = get_char(dsa);
    }
#line 136
    if (tmp___1) {
#line 136
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return (0);
}
}
#line 141 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int check_newline(struct dsa *dsa ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 142
  tmp = skip_spaces(dsa, 0);
  }
#line 142
  if (tmp) {
#line 142
    return (1);
  }
#line 143
  if (! (dsa->c == -1)) {
#line 143
    if (! (dsa->c == 10)) {
      {
#line 144
      _glp_lib_xprintf("%s:%d: extra symbols detected\n", dsa->fname, dsa->seqn);
      }
#line 146
      return (1);
    }
  }
  {
#line 148
  tmp___0 = get_char(dsa);
  }
#line 148
  if (tmp___0) {
#line 148
    return (1);
  }
#line 149
  return (0);
}
}
#line 152 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int scan_comment(struct dsa *dsa ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 153
  len = 0;
#line 154
  tmp = skip_spaces(dsa, 0);
  }
#line 154
  if (tmp) {
#line 154
    return (1);
  }
#line 155
  dsa->token[0] = (char )'\000';
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (dsa->c == -1) {
#line 156
      goto while_break;
    } else
#line 156
    if (dsa->c == 10) {
#line 156
      goto while_break;
    }
#line 157
    if (len == 255) {
      {
#line 158
      _glp_lib_xprintf("%s:%d: comment too long\n", dsa->fname, dsa->seqn);
      }
#line 160
      return (1);
    }
    {
#line 162
    tmp___0 = len;
#line 162
    len ++;
#line 162
    dsa->token[tmp___0] = (char )dsa->c;
#line 162
    dsa->token[len] = (char )'\000';
#line 163
    tmp___1 = get_char(dsa);
    }
#line 163
    if (tmp___1) {
#line 163
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (0);
}
}
#line 168 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int scan_integer(struct dsa *dsa , int across , int *val ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 169
  tmp = scan_token(dsa, across);
  }
#line 169
  if (tmp) {
#line 169
    return (1);
  }
  {
#line 170
  tmp___0 = strlen((char const   *)(dsa->token));
  }
#line 170
  if (tmp___0 == 0U) {
    {
#line 171
    _glp_lib_xprintf("%s:%d: missing integer\n", dsa->fname, dsa->seqn);
    }
#line 172
    return (1);
  }
  {
#line 174
  tmp___1 = _glp_lib_str2int((char const   *)(dsa->token), val);
  }
#line 174
  if (tmp___1) {
    {
#line 175
    _glp_lib_xprintf("%s:%d: integer `%s\' invalid\n", dsa->fname, dsa->seqn, dsa->token);
    }
#line 177
    return (1);
  }
#line 179
  return (0);
}
}
#line 182 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static int scan_number(struct dsa *dsa , int across , double *val ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 183
  tmp = scan_token(dsa, across);
  }
#line 183
  if (tmp) {
#line 183
    return (1);
  }
  {
#line 184
  tmp___0 = strlen((char const   *)(dsa->token));
  }
#line 184
  if (tmp___0 == 0U) {
    {
#line 185
    _glp_lib_xprintf("%s:%d: missing number\n", dsa->fname, dsa->seqn);
    }
#line 186
    return (1);
  }
  {
#line 188
  tmp___1 = _glp_lib_str2num((char const   *)(dsa->token), val);
  }
#line 188
  if (tmp___1) {
    {
#line 189
    _glp_lib_xprintf("%s:%d: number `%s\' invalid\n", dsa->fname, dsa->seqn, dsa->token);
    }
#line 191
    return (1);
  }
#line 193
  return (0);
}
}
#line 196 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
TSP *_glp_tsp_read_data(char *fname ) 
{ 
  struct dsa _dsa ;
  struct dsa *dsa ;
  TSP *tsp ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int n ;
  int k ;
  int node ;
  int tmp___44 ;
  void *tmp___45 ;
  void *tmp___46 ;
  double tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int n___0 ;
  int k___0 ;
  int node___0 ;
  int tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  double tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int n___1 ;
  int k___1 ;
  int node___1 ;
  int tmp___60 ;
  void *tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int n___2 ;
  int i ;
  int j ;
  int temp ;
  int tmp___65 ;
  void *tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;

  {
  {
#line 197
  dsa = & _dsa;
#line 198
  tsp = (TSP *)((void *)0);
#line 199
  dsa->fname = fname;
#line 200
  _glp_lib_xprintf("tsp_read_data: reading TSP data from `%s\'...\n", dsa->fname);
#line 202
  dsa->fp = fopen((char const   */* __restrict  */)dsa->fname, (char const   */* __restrict  */)"r");
  }
#line 203
  if ((unsigned long )dsa->fp == (unsigned long )((void *)0)) {
    {
#line 204
    tmp = __errno_location();
#line 204
    tmp___0 = strerror(*tmp);
#line 204
    _glp_lib_xprintf("tsp_read_data: unable to open `%s\' - %s\n", dsa->fname, tmp___0);
    }
#line 206
    goto fail;
  }
  {
#line 208
  tmp___1 = _glp_lib_xmalloc((int )sizeof(TSP ));
#line 208
  tsp = (TSP *)tmp___1;
#line 209
  tsp->name = (char *)((void *)0);
#line 210
  tsp->type = 0;
#line 211
  tsp->comment = (char *)((void *)0);
#line 212
  tsp->dimension = 0;
#line 213
  tsp->edge_weight_type = 0;
#line 214
  tsp->edge_weight_format = 0;
#line 215
  tsp->display_data_type = 0;
#line 216
  tsp->node_x_coord = (double *)((void *)0);
#line 217
  tsp->node_y_coord = (double *)((void *)0);
#line 218
  tsp->dply_x_coord = (double *)((void *)0);
#line 219
  tsp->dply_y_coord = (double *)((void *)0);
#line 220
  tsp->tour = (int *)((void *)0);
#line 221
  tsp->edge_weight = (int *)((void *)0);
#line 222
  dsa->seqn = 1;
#line 223
  tmp___2 = get_char(dsa);
  }
#line 223
  if (tmp___2) {
#line 223
    goto fail;
  }
  loop: 
  {
#line 224
  tmp___3 = scan_keyword(dsa);
  }
#line 224
  if (tmp___3) {
#line 224
    goto fail;
  }
  {
#line 225
  tmp___83 = strcmp((char const   *)(dsa->token), "NAME");
  }
#line 225
  if (tmp___83 == 0) {
#line 226
    if ((unsigned long )tsp->name != (unsigned long )((void *)0)) {
      {
#line 227
      _glp_lib_xprintf("%s:%d: NAME entry multiply defined\n", dsa->fname, dsa->seqn);
      }
#line 229
      goto fail;
    }
    {
#line 231
    tmp___4 = check_colon(dsa);
    }
#line 231
    if (tmp___4) {
#line 231
      goto fail;
    }
    {
#line 232
    tmp___5 = scan_token(dsa, 0);
    }
#line 232
    if (tmp___5) {
#line 232
      goto fail;
    }
    {
#line 233
    tmp___6 = strlen((char const   *)(dsa->token));
    }
#line 233
    if (tmp___6 == 0U) {
      {
#line 234
      _glp_lib_xprintf("%s:%d: NAME entry incomplete\n", dsa->fname, dsa->seqn);
      }
#line 236
      goto fail;
    }
    {
#line 238
    tmp___7 = strlen((char const   *)(dsa->token));
#line 238
    tmp___8 = _glp_lib_xmalloc((int )(tmp___7 + 1U));
#line 238
    tsp->name = (char *)tmp___8;
#line 239
    strcpy((char */* __restrict  */)tsp->name, (char const   */* __restrict  */)(dsa->token));
#line 240
    _glp_lib_xprintf("tsp_read_data: NAME: %s\n", tsp->name);
#line 241
    tmp___9 = check_newline(dsa);
    }
#line 241
    if (tmp___9) {
#line 241
      goto fail;
    }
  } else {
    {
#line 243
    tmp___82 = strcmp((char const   *)(dsa->token), "TYPE");
    }
#line 243
    if (tmp___82 == 0) {
#line 244
      if (tsp->type != 0) {
        {
#line 245
        _glp_lib_xprintf("%s:%d: TYPE entry multiply defined\n", dsa->fname, dsa->seqn);
        }
#line 247
        goto fail;
      }
      {
#line 249
      tmp___10 = check_colon(dsa);
      }
#line 249
      if (tmp___10) {
#line 249
        goto fail;
      }
      {
#line 250
      tmp___11 = scan_keyword(dsa);
      }
#line 250
      if (tmp___11) {
#line 250
        goto fail;
      }
      {
#line 251
      tmp___14 = strcmp((char const   *)(dsa->token), "TSP");
      }
#line 251
      if (tmp___14 == 0) {
#line 252
        tsp->type = 1;
      } else {
        {
#line 253
        tmp___13 = strcmp((char const   *)(dsa->token), "ATSP");
        }
#line 253
        if (tmp___13 == 0) {
#line 254
          tsp->type = 2;
        } else {
          {
#line 255
          tmp___12 = strcmp((char const   *)(dsa->token), "TOUR");
          }
#line 255
          if (tmp___12 == 0) {
#line 256
            tsp->type = 3;
          } else {
            {
#line 258
            _glp_lib_xprintf("%s:%d: data type `%s\' not recognized\n", dsa->fname,
                             dsa->seqn, dsa->token);
            }
#line 260
            goto fail;
          }
        }
      }
      {
#line 262
      _glp_lib_xprintf("tsp_read_data: TYPE: %s\n", dsa->token);
#line 263
      tmp___15 = check_newline(dsa);
      }
#line 263
      if (tmp___15) {
#line 263
        goto fail;
      }
    } else {
      {
#line 265
      tmp___81 = strcmp((char const   *)(dsa->token), "COMMENT");
      }
#line 265
      if (tmp___81 == 0) {
#line 266
        if ((unsigned long )tsp->comment != (unsigned long )((void *)0)) {
          {
#line 267
          _glp_lib_xprintf("%s:%d: COMMENT entry multiply defined\n", dsa->fname,
                           dsa->seqn);
          }
#line 269
          goto fail;
        }
        {
#line 271
        tmp___16 = check_colon(dsa);
        }
#line 271
        if (tmp___16) {
#line 271
          goto fail;
        }
        {
#line 272
        tmp___17 = scan_comment(dsa);
        }
#line 272
        if (tmp___17) {
#line 272
          goto fail;
        }
        {
#line 273
        tmp___18 = strlen((char const   *)(dsa->token));
#line 273
        tmp___19 = _glp_lib_xmalloc((int )(tmp___18 + 1U));
#line 273
        tsp->comment = (char *)tmp___19;
#line 274
        strcpy((char */* __restrict  */)tsp->comment, (char const   */* __restrict  */)(dsa->token));
#line 275
        _glp_lib_xprintf("tsp_read_data: COMMENT: %s\n", tsp->comment);
#line 276
        tmp___20 = check_newline(dsa);
        }
#line 276
        if (tmp___20) {
#line 276
          goto fail;
        }
      } else {
        {
#line 278
        tmp___80 = strcmp((char const   *)(dsa->token), "DIMENSION");
        }
#line 278
        if (tmp___80 == 0) {
#line 279
          if (tsp->dimension != 0) {
            {
#line 280
            _glp_lib_xprintf("%s:%d: DIMENSION entry multiply defined\n", dsa->fname,
                             dsa->seqn);
            }
#line 282
            goto fail;
          }
          {
#line 284
          tmp___21 = check_colon(dsa);
          }
#line 284
          if (tmp___21) {
#line 284
            goto fail;
          }
          {
#line 285
          tmp___22 = scan_integer(dsa, 0, & tsp->dimension);
          }
#line 285
          if (tmp___22) {
#line 285
            goto fail;
          }
#line 286
          if (tsp->dimension < 1) {
            {
#line 287
            _glp_lib_xprintf("%s:%d: invalid dimension\n", dsa->fname, dsa->seqn);
            }
#line 289
            goto fail;
          }
          {
#line 291
          _glp_lib_xprintf("tsp_read_data: DIMENSION: %d\n", tsp->dimension);
#line 292
          tmp___23 = check_newline(dsa);
          }
#line 292
          if (tmp___23) {
#line 292
            goto fail;
          }
        } else {
          {
#line 294
          tmp___79 = strcmp((char const   *)(dsa->token), "EDGE_WEIGHT_TYPE");
          }
#line 294
          if (tmp___79 == 0) {
#line 295
            if (tsp->edge_weight_type != 0) {
              {
#line 296
              _glp_lib_xprintf("%s:%d: EDGE_WEIGHT_TYPE entry multiply defined\n",
                               dsa->fname, dsa->seqn);
              }
#line 298
              goto fail;
            }
            {
#line 300
            tmp___24 = check_colon(dsa);
            }
#line 300
            if (tmp___24) {
#line 300
              goto fail;
            }
            {
#line 301
            tmp___25 = scan_keyword(dsa);
            }
#line 301
            if (tmp___25) {
#line 301
              goto fail;
            }
            {
#line 302
            tmp___30 = strcmp((char const   *)(dsa->token), "GEO");
            }
#line 302
            if (tmp___30 == 0) {
#line 303
              tsp->edge_weight_type = 4;
            } else {
              {
#line 304
              tmp___29 = strcmp((char const   *)(dsa->token), "EUC_2D");
              }
#line 304
              if (tmp___29 == 0) {
#line 305
                tsp->edge_weight_type = 2;
              } else {
                {
#line 306
                tmp___28 = strcmp((char const   *)(dsa->token), "ATT");
                }
#line 306
                if (tmp___28 == 0) {
#line 307
                  tsp->edge_weight_type = 5;
                } else {
                  {
#line 308
                  tmp___27 = strcmp((char const   *)(dsa->token), "EXPLICIT");
                  }
#line 308
                  if (tmp___27 == 0) {
#line 309
                    tsp->edge_weight_type = 1;
                  } else {
                    {
#line 310
                    tmp___26 = strcmp((char const   *)(dsa->token), "CEIL_2D");
                    }
#line 310
                    if (tmp___26 == 0) {
#line 311
                      tsp->edge_weight_type = 3;
                    } else {
                      {
#line 313
                      _glp_lib_xprintf("%s:%d: edge weight type `%s\' not recognized\n",
                                       dsa->fname, dsa->seqn, dsa->token);
                      }
#line 315
                      goto fail;
                    }
                  }
                }
              }
            }
            {
#line 317
            _glp_lib_xprintf("tsp_read_data: EDGE_WEIGHT_TYPE: %s\n", dsa->token);
#line 318
            tmp___31 = check_newline(dsa);
            }
#line 318
            if (tmp___31) {
#line 318
              goto fail;
            }
          } else {
            {
#line 320
            tmp___78 = strcmp((char const   *)(dsa->token), "EDGE_WEIGHT_FORMAT");
            }
#line 320
            if (tmp___78 == 0) {
#line 321
              if (tsp->edge_weight_format != 0) {
                {
#line 322
                _glp_lib_xprintf("%s:%d: EDGE_WEIGHT_FORMAT entry multiply defined\n",
                                 dsa->fname, dsa->seqn);
                }
#line 325
                goto fail;
              }
              {
#line 327
              tmp___32 = check_colon(dsa);
              }
#line 327
              if (tmp___32) {
#line 327
                goto fail;
              }
              {
#line 328
              tmp___33 = scan_keyword(dsa);
              }
#line 328
              if (tmp___33) {
#line 328
                goto fail;
              }
              {
#line 329
              tmp___37 = strcmp((char const   *)(dsa->token), "UPPER_ROW");
              }
#line 329
              if (tmp___37 == 0) {
#line 330
                tsp->edge_weight_format = 3;
              } else {
                {
#line 331
                tmp___36 = strcmp((char const   *)(dsa->token), "FULL_MATRIX");
                }
#line 331
                if (tmp___36 == 0) {
#line 332
                  tsp->edge_weight_format = 2;
                } else {
                  {
#line 333
                  tmp___35 = strcmp((char const   *)(dsa->token), "FUNCTION");
                  }
#line 333
                  if (tmp___35 == 0) {
#line 334
                    tsp->edge_weight_format = 1;
                  } else {
                    {
#line 335
                    tmp___34 = strcmp((char const   *)(dsa->token), "LOWER_DIAG_ROW");
                    }
#line 335
                    if (tmp___34 == 0) {
#line 336
                      tsp->edge_weight_format = 4;
                    } else {
                      {
#line 338
                      _glp_lib_xprintf("%s:%d: edge weight format `%s\' not recognized\n",
                                       dsa->fname, dsa->seqn, dsa->token);
                      }
#line 340
                      goto fail;
                    }
                  }
                }
              }
              {
#line 342
              _glp_lib_xprintf("tsp_read_data: EDGE_WEIGHT_FORMAT: %s\n", dsa->token);
#line 343
              tmp___38 = check_newline(dsa);
              }
#line 343
              if (tmp___38) {
#line 343
                goto fail;
              }
            } else {
              {
#line 345
              tmp___77 = strcmp((char const   *)(dsa->token), "DISPLAY_DATA_TYPE");
              }
#line 345
              if (tmp___77 == 0) {
#line 346
                if (tsp->display_data_type != 0) {
                  {
#line 347
                  _glp_lib_xprintf("%s:%d: DISPLAY_DATA_TYPE entry multiply defined\n",
                                   dsa->fname, dsa->seqn);
                  }
#line 349
                  goto fail;
                }
                {
#line 351
                tmp___39 = check_colon(dsa);
                }
#line 351
                if (tmp___39) {
#line 351
                  goto fail;
                }
                {
#line 352
                tmp___40 = scan_keyword(dsa);
                }
#line 352
                if (tmp___40) {
#line 352
                  goto fail;
                }
                {
#line 353
                tmp___42 = strcmp((char const   *)(dsa->token), "COORD_DISPLAY");
                }
#line 353
                if (tmp___42 == 0) {
#line 354
                  tsp->display_data_type = 1;
                } else {
                  {
#line 355
                  tmp___41 = strcmp((char const   *)(dsa->token), "TWOD_DISPLAY");
                  }
#line 355
                  if (tmp___41 == 0) {
#line 356
                    tsp->display_data_type = 2;
                  } else {
                    {
#line 358
                    _glp_lib_xprintf("%s:%d: display data type `%s\' not recognized\n",
                                     dsa->fname, dsa->seqn, dsa->token);
                    }
#line 360
                    goto fail;
                  }
                }
                {
#line 362
                _glp_lib_xprintf("tsp_read_data: DISPLAY_DATA_TYPE: %s\n", dsa->token);
#line 363
                tmp___43 = check_newline(dsa);
                }
#line 363
                if (tmp___43) {
#line 363
                  goto fail;
                }
              } else {
                {
#line 365
                tmp___76 = strcmp((char const   *)(dsa->token), "NODE_COORD_SECTION");
                }
#line 365
                if (tmp___76 == 0) {
#line 366
                  n = tsp->dimension;
#line 367
                  if (n == 0) {
                    {
#line 368
                    _glp_lib_xprintf("%s:%d: DIMENSION entry not specified\n", dsa->fname,
                                     dsa->seqn);
                    }
#line 370
                    goto fail;
                  }
#line 372
                  if ((unsigned long )tsp->node_x_coord != (unsigned long )((void *)0)) {
                    {
#line 373
                    _glp_lib_xprintf("%s:%d: NODE_COORD_SECTION multiply specified\n",
                                     dsa->fname, dsa->seqn);
                    }
#line 375
                    goto fail;
                  }
                  {
#line 377
                  tmp___44 = check_newline(dsa);
                  }
#line 377
                  if (tmp___44) {
#line 377
                    goto fail;
                  }
                  {
#line 378
                  tmp___45 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 378
                  tsp->node_x_coord = (double *)tmp___45;
#line 379
                  tmp___46 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 379
                  tsp->node_y_coord = (double *)tmp___46;
#line 380
                  node = 1;
                  }
                  {
#line 380
                  while (1) {
                    while_continue: /* CIL Label */ ;
#line 380
                    if (! (node <= n)) {
#line 380
                      goto while_break;
                    }
#line 381
                    tmp___47 = 1.7976931348623157e+308;
#line 381
                    *(tsp->node_y_coord + node) = tmp___47;
#line 381
                    *(tsp->node_x_coord + node) = tmp___47;
#line 380
                    node ++;
                  }
                  while_break: /* CIL Label */ ;
                  }
#line 382
                  k = 1;
                  {
#line 382
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 382
                    if (! (k <= n)) {
#line 382
                      goto while_break___0;
                    }
                    {
#line 383
                    tmp___48 = scan_integer(dsa, 0, & node);
                    }
#line 383
                    if (tmp___48) {
#line 383
                      goto fail;
                    }
#line 384
                    if (1 <= node) {
#line 384
                      if (! (node <= n)) {
                        {
#line 385
                        _glp_lib_xprintf("%s:%d: invalid node number %d\n", dsa->fname,
                                         dsa->seqn, node);
                        }
#line 387
                        goto fail;
                      }
                    } else {
                      {
#line 385
                      _glp_lib_xprintf("%s:%d: invalid node number %d\n", dsa->fname,
                                       dsa->seqn, node);
                      }
#line 387
                      goto fail;
                    }
#line 389
                    if (*(tsp->node_x_coord + node) != 1.7976931348623157e+308) {
                      {
#line 390
                      _glp_lib_xprintf("%s:%d: node number %d multiply specified\n",
                                       dsa->fname, dsa->seqn, node);
                      }
#line 392
                      goto fail;
                    }
                    {
#line 394
                    tmp___49 = scan_number(dsa, 0, tsp->node_x_coord + node);
                    }
#line 394
                    if (tmp___49) {
#line 395
                      goto fail;
                    }
                    {
#line 396
                    tmp___50 = scan_number(dsa, 0, tsp->node_y_coord + node);
                    }
#line 396
                    if (tmp___50) {
#line 397
                      goto fail;
                    }
                    {
#line 398
                    tmp___51 = check_newline(dsa);
                    }
#line 398
                    if (tmp___51) {
#line 398
                      goto fail;
                    }
#line 382
                    k ++;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                } else {
                  {
#line 401
                  tmp___75 = strcmp((char const   *)(dsa->token), "DISPLAY_DATA_SECTION");
                  }
#line 401
                  if (tmp___75 == 0) {
#line 402
                    n___0 = tsp->dimension;
#line 403
                    if (n___0 == 0) {
                      {
#line 404
                      _glp_lib_xprintf("%s:%d: DIMENSION entry not specified\n", dsa->fname,
                                       dsa->seqn);
                      }
#line 406
                      goto fail;
                    }
#line 408
                    if ((unsigned long )tsp->dply_x_coord != (unsigned long )((void *)0)) {
                      {
#line 409
                      _glp_lib_xprintf("%s:%d: DISPLAY_DATA_SECTION multiply specified\n",
                                       dsa->fname, dsa->seqn);
                      }
#line 411
                      goto fail;
                    }
                    {
#line 413
                    tmp___52 = check_newline(dsa);
                    }
#line 413
                    if (tmp___52) {
#line 413
                      goto fail;
                    }
                    {
#line 414
                    tmp___53 = _glp_lib_xcalloc(1 + n___0, (int )sizeof(double ));
#line 414
                    tsp->dply_x_coord = (double *)tmp___53;
#line 415
                    tmp___54 = _glp_lib_xcalloc(1 + n___0, (int )sizeof(double ));
#line 415
                    tsp->dply_y_coord = (double *)tmp___54;
#line 416
                    node___0 = 1;
                    }
                    {
#line 416
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
#line 416
                      if (! (node___0 <= n___0)) {
#line 416
                        goto while_break___1;
                      }
#line 417
                      tmp___55 = 1.7976931348623157e+308;
#line 417
                      *(tsp->dply_y_coord + node___0) = tmp___55;
#line 417
                      *(tsp->dply_x_coord + node___0) = tmp___55;
#line 416
                      node___0 ++;
                    }
                    while_break___1: /* CIL Label */ ;
                    }
#line 418
                    k___0 = 1;
                    {
#line 418
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 418
                      if (! (k___0 <= n___0)) {
#line 418
                        goto while_break___2;
                      }
                      {
#line 419
                      tmp___56 = scan_integer(dsa, 0, & node___0);
                      }
#line 419
                      if (tmp___56) {
#line 419
                        goto fail;
                      }
#line 420
                      if (1 <= node___0) {
#line 420
                        if (! (node___0 <= n___0)) {
                          {
#line 421
                          _glp_lib_xprintf("%s:%d: invalid node number %d\n", dsa->fname,
                                           dsa->seqn, node___0);
                          }
#line 423
                          goto fail;
                        }
                      } else {
                        {
#line 421
                        _glp_lib_xprintf("%s:%d: invalid node number %d\n", dsa->fname,
                                         dsa->seqn, node___0);
                        }
#line 423
                        goto fail;
                      }
#line 425
                      if (*(tsp->dply_x_coord + node___0) != 1.7976931348623157e+308) {
                        {
#line 426
                        _glp_lib_xprintf("%s:%d: node number %d multiply specified\n",
                                         dsa->fname, dsa->seqn, node___0);
                        }
#line 428
                        goto fail;
                      }
                      {
#line 430
                      tmp___57 = scan_number(dsa, 0, tsp->dply_x_coord + node___0);
                      }
#line 430
                      if (tmp___57) {
#line 431
                        goto fail;
                      }
                      {
#line 432
                      tmp___58 = scan_number(dsa, 0, tsp->dply_y_coord + node___0);
                      }
#line 432
                      if (tmp___58) {
#line 433
                        goto fail;
                      }
                      {
#line 434
                      tmp___59 = check_newline(dsa);
                      }
#line 434
                      if (tmp___59) {
#line 434
                        goto fail;
                      }
#line 418
                      k___0 ++;
                    }
                    while_break___2: /* CIL Label */ ;
                    }
                  } else {
                    {
#line 437
                    tmp___74 = strcmp((char const   *)(dsa->token), "TOUR_SECTION");
                    }
#line 437
                    if (tmp___74 == 0) {
#line 438
                      n___1 = tsp->dimension;
#line 439
                      if (n___1 == 0) {
                        {
#line 440
                        _glp_lib_xprintf("%s:%d: DIMENSION entry not specified\n",
                                         dsa->fname, dsa->seqn);
                        }
#line 442
                        goto fail;
                      }
#line 444
                      if ((unsigned long )tsp->tour != (unsigned long )((void *)0)) {
                        {
#line 445
                        _glp_lib_xprintf("%s:%d: TOUR_SECTION multiply specified\n",
                                         dsa->fname, dsa->seqn);
                        }
#line 447
                        goto fail;
                      }
                      {
#line 449
                      tmp___60 = check_newline(dsa);
                      }
#line 449
                      if (tmp___60) {
#line 449
                        goto fail;
                      }
                      {
#line 450
                      tmp___61 = _glp_lib_xcalloc(1 + n___1, (int )sizeof(int ));
#line 450
                      tsp->tour = (int *)tmp___61;
#line 451
                      k___1 = 1;
                      }
                      {
#line 451
                      while (1) {
                        while_continue___3: /* CIL Label */ ;
#line 451
                        if (! (k___1 <= n___1)) {
#line 451
                          goto while_break___3;
                        }
                        {
#line 452
                        tmp___62 = scan_integer(dsa, 1, & node___1);
                        }
#line 452
                        if (tmp___62) {
#line 452
                          goto fail;
                        }
#line 453
                        if (1 <= node___1) {
#line 453
                          if (! (node___1 <= n___1)) {
                            {
#line 454
                            _glp_lib_xprintf("%s:%d: invalid node number %d\n", dsa->fname,
                                             dsa->seqn, node___1);
                            }
#line 456
                            goto fail;
                          }
                        } else {
                          {
#line 454
                          _glp_lib_xprintf("%s:%d: invalid node number %d\n", dsa->fname,
                                           dsa->seqn, node___1);
                          }
#line 456
                          goto fail;
                        }
#line 458
                        *(tsp->tour + k___1) = node___1;
#line 451
                        k___1 ++;
                      }
                      while_break___3: /* CIL Label */ ;
                      }
                      {
#line 460
                      tmp___63 = scan_integer(dsa, 1, & node___1);
                      }
#line 460
                      if (tmp___63) {
#line 460
                        goto fail;
                      }
#line 461
                      if (node___1 != -1) {
                        {
#line 462
                        _glp_lib_xprintf("%s:%d: extra node(s) detected\n", dsa->fname,
                                         dsa->seqn);
                        }
#line 464
                        goto fail;
                      }
                      {
#line 466
                      tmp___64 = check_newline(dsa);
                      }
#line 466
                      if (tmp___64) {
#line 466
                        goto fail;
                      }
                    } else {
                      {
#line 468
                      tmp___73 = strcmp((char const   *)(dsa->token), "EDGE_WEIGHT_SECTION");
                      }
#line 468
                      if (tmp___73 == 0) {
#line 469
                        n___2 = tsp->dimension;
#line 470
                        if (n___2 == 0) {
                          {
#line 471
                          _glp_lib_xprintf("%s:%d: DIMENSION entry not specified\n",
                                           dsa->fname, dsa->seqn);
                          }
#line 473
                          goto fail;
                        }
#line 475
                        if (tsp->edge_weight_format == 0) {
                          {
#line 476
                          _glp_lib_xprintf("%s:%d: EDGE_WEIGHT_FORMAT entry not specified\n",
                                           dsa->fname, dsa->seqn);
                          }
#line 478
                          goto fail;
                        }
#line 480
                        if ((unsigned long )tsp->edge_weight != (unsigned long )((void *)0)) {
                          {
#line 481
                          _glp_lib_xprintf("%s:%d: EDGE_WEIGHT_SECTION multiply specified\n",
                                           dsa->fname, dsa->seqn);
                          }
#line 483
                          goto fail;
                        }
                        {
#line 485
                        tmp___65 = check_newline(dsa);
                        }
#line 485
                        if (tmp___65) {
#line 485
                          goto fail;
                        }
                        {
#line 486
                        tmp___66 = _glp_lib_xcalloc(1 + n___2 * n___2, (int )sizeof(int ));
#line 486
                        tsp->edge_weight = (int *)tmp___66;
                        }
                        {
#line 488
                        if (tsp->edge_weight_format == 2) {
#line 488
                          goto case_2;
                        }
#line 496
                        if (tsp->edge_weight_format == 3) {
#line 496
                          goto case_3;
                        }
#line 506
                        if (tsp->edge_weight_format == 4) {
#line 506
                          goto case_4;
                        }
#line 515
                        goto switch_default;
                        case_2: /* CIL Label */ 
#line 489
                        i = 1;
                        {
#line 489
                        while (1) {
                          while_continue___4: /* CIL Label */ ;
#line 489
                          if (! (i <= n___2)) {
#line 489
                            goto while_break___4;
                          }
#line 490
                          j = 1;
                          {
#line 490
                          while (1) {
                            while_continue___5: /* CIL Label */ ;
#line 490
                            if (! (j <= n___2)) {
#line 490
                              goto while_break___5;
                            }
                            {
#line 491
                            tmp___67 = scan_integer(dsa, 1, & temp);
                            }
#line 491
                            if (tmp___67) {
#line 491
                              goto fail;
                            }
#line 492
                            *(tsp->edge_weight + ((i - 1) * n___2 + j)) = temp;
#line 490
                            j ++;
                          }
                          while_break___5: /* CIL Label */ ;
                          }
#line 489
                          i ++;
                        }
                        while_break___4: /* CIL Label */ ;
                        }
#line 495
                        goto switch_break;
                        case_3: /* CIL Label */ 
#line 497
                        i = 1;
                        {
#line 497
                        while (1) {
                          while_continue___6: /* CIL Label */ ;
#line 497
                          if (! (i <= n___2)) {
#line 497
                            goto while_break___6;
                          }
#line 498
                          *(tsp->edge_weight + ((i - 1) * n___2 + i)) = 0;
#line 499
                          j = i + 1;
                          {
#line 499
                          while (1) {
                            while_continue___7: /* CIL Label */ ;
#line 499
                            if (! (j <= n___2)) {
#line 499
                              goto while_break___7;
                            }
                            {
#line 500
                            tmp___68 = scan_integer(dsa, 1, & temp);
                            }
#line 500
                            if (tmp___68) {
#line 500
                              goto fail;
                            }
#line 501
                            *(tsp->edge_weight + ((i - 1) * n___2 + j)) = temp;
#line 502
                            *(tsp->edge_weight + ((j - 1) * n___2 + i)) = temp;
#line 499
                            j ++;
                          }
                          while_break___7: /* CIL Label */ ;
                          }
#line 497
                          i ++;
                        }
                        while_break___6: /* CIL Label */ ;
                        }
#line 505
                        goto switch_break;
                        case_4: /* CIL Label */ 
#line 507
                        i = 1;
                        {
#line 507
                        while (1) {
                          while_continue___8: /* CIL Label */ ;
#line 507
                          if (! (i <= n___2)) {
#line 507
                            goto while_break___8;
                          }
#line 508
                          j = 1;
                          {
#line 508
                          while (1) {
                            while_continue___9: /* CIL Label */ ;
#line 508
                            if (! (j <= i)) {
#line 508
                              goto while_break___9;
                            }
                            {
#line 509
                            tmp___69 = scan_integer(dsa, 1, & temp);
                            }
#line 509
                            if (tmp___69) {
#line 509
                              goto fail;
                            }
#line 510
                            *(tsp->edge_weight + ((i - 1) * n___2 + j)) = temp;
#line 511
                            *(tsp->edge_weight + ((j - 1) * n___2 + i)) = temp;
#line 508
                            j ++;
                          }
                          while_break___9: /* CIL Label */ ;
                          }
#line 507
                          i ++;
                        }
                        while_break___8: /* CIL Label */ ;
                        }
#line 514
                        goto switch_break;
                        switch_default: /* CIL Label */ 
#line 516
                        goto fail;
                        switch_break: /* CIL Label */ ;
                        }
                        {
#line 518
                        tmp___70 = check_newline(dsa);
                        }
#line 518
                        if (tmp___70) {
#line 518
                          goto fail;
                        }
                      } else {
                        {
#line 520
                        tmp___72 = strcmp((char const   *)(dsa->token), "EOF");
                        }
#line 520
                        if (tmp___72 == 0) {
                          {
#line 521
                          tmp___71 = check_newline(dsa);
                          }
#line 521
                          if (tmp___71) {
#line 521
                            goto fail;
                          }
#line 522
                          goto done;
                        } else {
                          {
#line 525
                          _glp_lib_xprintf("%s:%d: keyword `%s\' not recognized\n",
                                           dsa->fname, dsa->seqn, dsa->token);
                          }
#line 527
                          goto fail;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 529
  goto loop;
  done: 
  {
#line 530
  _glp_lib_xprintf("tsp_read_data: %d lines were read\n", dsa->seqn - 1);
#line 531
  fclose(dsa->fp);
  }
#line 532
  return (tsp);
  fail: 
#line 533
  if ((unsigned long )tsp != (unsigned long )((void *)0)) {
#line 534
    if ((unsigned long )tsp->name != (unsigned long )((void *)0)) {
      {
#line 534
      _glp_lib_xfree((void *)tsp->name);
      }
    }
#line 535
    if ((unsigned long )tsp->comment != (unsigned long )((void *)0)) {
      {
#line 535
      _glp_lib_xfree((void *)tsp->comment);
      }
    }
#line 536
    if ((unsigned long )tsp->node_x_coord != (unsigned long )((void *)0)) {
      {
#line 536
      _glp_lib_xfree((void *)tsp->node_x_coord);
      }
    }
#line 537
    if ((unsigned long )tsp->node_y_coord != (unsigned long )((void *)0)) {
      {
#line 537
      _glp_lib_xfree((void *)tsp->node_y_coord);
      }
    }
#line 538
    if ((unsigned long )tsp->dply_x_coord != (unsigned long )((void *)0)) {
      {
#line 538
      _glp_lib_xfree((void *)tsp->dply_x_coord);
      }
    }
#line 539
    if ((unsigned long )tsp->dply_y_coord != (unsigned long )((void *)0)) {
      {
#line 539
      _glp_lib_xfree((void *)tsp->dply_y_coord);
      }
    }
#line 540
    if ((unsigned long )tsp->tour != (unsigned long )((void *)0)) {
      {
#line 540
      _glp_lib_xfree((void *)tsp->tour);
      }
    }
#line 541
    if ((unsigned long )tsp->edge_weight != (unsigned long )((void *)0)) {
      {
#line 541
      _glp_lib_xfree((void *)tsp->edge_weight);
      }
    }
    {
#line 542
    _glp_lib_xfree((void *)tsp);
    }
  }
#line 544
  if ((unsigned long )dsa->fp != (unsigned long )((void *)0)) {
    {
#line 544
    fclose(dsa->fp);
    }
  }
#line 545
  return ((TSP *)((void *)0));
}
}
#line 561 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
void _glp_tsp_free_data(TSP *tsp ) 
{ 


  {
#line 562
  if ((unsigned long )tsp->name != (unsigned long )((void *)0)) {
    {
#line 562
    _glp_lib_xfree((void *)tsp->name);
    }
  }
#line 563
  if ((unsigned long )tsp->comment != (unsigned long )((void *)0)) {
    {
#line 563
    _glp_lib_xfree((void *)tsp->comment);
    }
  }
#line 564
  if ((unsigned long )tsp->node_x_coord != (unsigned long )((void *)0)) {
    {
#line 564
    _glp_lib_xfree((void *)tsp->node_x_coord);
    }
  }
#line 565
  if ((unsigned long )tsp->node_y_coord != (unsigned long )((void *)0)) {
    {
#line 565
    _glp_lib_xfree((void *)tsp->node_y_coord);
    }
  }
#line 566
  if ((unsigned long )tsp->dply_x_coord != (unsigned long )((void *)0)) {
    {
#line 566
    _glp_lib_xfree((void *)tsp->dply_x_coord);
    }
  }
#line 567
  if ((unsigned long )tsp->dply_y_coord != (unsigned long )((void *)0)) {
    {
#line 567
    _glp_lib_xfree((void *)tsp->dply_y_coord);
    }
  }
#line 568
  if ((unsigned long )tsp->tour != (unsigned long )((void *)0)) {
    {
#line 568
    _glp_lib_xfree((void *)tsp->tour);
    }
  }
#line 569
  if ((unsigned long )tsp->edge_weight != (unsigned long )((void *)0)) {
    {
#line 569
    _glp_lib_xfree((void *)tsp->edge_weight);
    }
  }
  {
#line 570
  _glp_lib_xfree((void *)tsp);
  }
#line 571
  return;
}
}
#line 593 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
static double rad(double x ) 
{ 
  double pi ;
  double deg ;
  double min ;

  {
#line 595
  pi = 3.141592;
#line 596
  deg = (double )((int )x);
#line 597
  min = x - deg;
#line 598
  return ((pi * (deg + (5.0 * min) / 3.0)) / 180.0);
}
}
#line 601 "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c"
int _glp_tsp_distance(TSP *tsp , int i , int j ) 
{ 
  int n ;
  int dij ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  double xd ;
  double yd ;
  double tmp___4 ;
  xerror_t tmp___5 ;
  double xd___0 ;
  double yd___0 ;
  double tmp___6 ;
  double tmp___7 ;
  xerror_t tmp___8 ;
  double rrr ;
  double latitude_i ;
  double tmp___9 ;
  double latitude_j ;
  double tmp___10 ;
  double longitude_i ;
  double tmp___11 ;
  double longitude_j ;
  double tmp___12 ;
  double q1 ;
  double tmp___13 ;
  double q2 ;
  double tmp___14 ;
  double q3 ;
  double tmp___15 ;
  double tmp___16 ;
  xerror_t tmp___17 ;
  int tij ;
  double xd___1 ;
  double yd___1 ;
  double rij ;
  int tmp___18 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
#line 602
  n = tsp->dimension;
#line 603
  if (! (tsp->type == 1)) {
#line 603
    if (! (tsp->type == 2)) {
      {
#line 604
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 604);
#line 604
      (*tmp)("tsp_distance: invalid TSP instance\n");
      }
    }
  }
#line 605
  if (1 <= i) {
#line 605
    if (i <= n) {
#line 605
      if (1 <= j) {
#line 605
        if (! (j <= n)) {
          {
#line 606
          tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c",
                                     606);
#line 606
          (*tmp___0)("tsp_distance: node number out of range\n");
          }
        }
      } else {
        {
#line 606
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c",
                                   606);
#line 606
        (*tmp___0)("tsp_distance: node number out of range\n");
        }
      }
    } else {
      {
#line 606
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c",
                                 606);
#line 606
      (*tmp___0)("tsp_distance: node number out of range\n");
      }
    }
  } else {
    {
#line 606
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 606);
#line 606
    (*tmp___0)("tsp_distance: node number out of range\n");
    }
  }
  {
#line 608
  if (tsp->edge_weight_type == 0) {
#line 608
    goto case_0;
  }
#line 610
  if (tsp->edge_weight_type == 1) {
#line 610
    goto case_1;
  }
#line 615
  if (tsp->edge_weight_type == 2) {
#line 615
    goto case_2;
  }
#line 624
  if (tsp->edge_weight_type == 3) {
#line 624
    goto case_3;
  }
#line 633
  if (tsp->edge_weight_type == 4) {
#line 633
    goto case_4;
  }
#line 648
  if (tsp->edge_weight_type == 5) {
#line 648
    goto case_5;
  }
#line 660
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 609
  tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 609);
#line 609
  (*tmp___1)("tsp_distance: edge weight type not specified\n");
  }
  case_1: /* CIL Label */ 
#line 611
  if ((unsigned long )tsp->edge_weight == (unsigned long )((void *)0)) {
    {
#line 612
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 612);
#line 612
    (*tmp___2)("tsp_distance: edge weights not specified\n");
    }
  }
#line 613
  dij = *(tsp->edge_weight + ((i - 1) * n + j));
#line 614
  goto switch_break;
  case_2: /* CIL Label */ 
#line 616
  if ((unsigned long )tsp->node_x_coord == (unsigned long )((void *)0)) {
    {
#line 617
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 617);
#line 617
    (*tmp___3)("tsp_distance: node coordinates not specified\n");
    }
  } else
#line 616
  if ((unsigned long )tsp->node_y_coord == (unsigned long )((void *)0)) {
    {
#line 617
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 617);
#line 617
    (*tmp___3)("tsp_distance: node coordinates not specified\n");
    }
  }
  {
#line 619
  xd = *(tsp->node_x_coord + i) - *(tsp->node_x_coord + j);
#line 620
  yd = *(tsp->node_y_coord + i) - *(tsp->node_y_coord + j);
#line 621
  tmp___4 = sqrt(xd * xd + yd * yd);
#line 621
  dij = (int )(tmp___4 + 0.5);
  }
#line 623
  goto switch_break;
  case_3: /* CIL Label */ 
#line 625
  if ((unsigned long )tsp->node_x_coord == (unsigned long )((void *)0)) {
    {
#line 626
    tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 626);
#line 626
    (*tmp___5)("tsp_distance: node coordinates not specified\n");
    }
  } else
#line 625
  if ((unsigned long )tsp->node_y_coord == (unsigned long )((void *)0)) {
    {
#line 626
    tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 626);
#line 626
    (*tmp___5)("tsp_distance: node coordinates not specified\n");
    }
  }
  {
#line 628
  xd___0 = *(tsp->node_x_coord + i) - *(tsp->node_x_coord + j);
#line 629
  yd___0 = *(tsp->node_y_coord + i) - *(tsp->node_y_coord + j);
#line 630
  tmp___6 = sqrt(xd___0 * xd___0 + yd___0 * yd___0);
#line 630
  tmp___7 = ceil(tmp___6);
#line 630
  dij = (int )tmp___7;
  }
#line 632
  goto switch_break;
  case_4: /* CIL Label */ 
#line 634
  if ((unsigned long )tsp->node_x_coord == (unsigned long )((void *)0)) {
    {
#line 635
    tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 635);
#line 635
    (*tmp___8)("tsp_distance: node coordinates not specified\n");
    }
  } else
#line 634
  if ((unsigned long )tsp->node_y_coord == (unsigned long )((void *)0)) {
    {
#line 635
    tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 635);
#line 635
    (*tmp___8)("tsp_distance: node coordinates not specified\n");
    }
  }
  {
#line 636
  rrr = 6378.388;
#line 637
  tmp___9 = rad(*(tsp->node_x_coord + i));
#line 637
  latitude_i = tmp___9;
#line 638
  tmp___10 = rad(*(tsp->node_x_coord + j));
#line 638
  latitude_j = tmp___10;
#line 639
  tmp___11 = rad(*(tsp->node_y_coord + i));
#line 639
  longitude_i = tmp___11;
#line 640
  tmp___12 = rad(*(tsp->node_y_coord + j));
#line 640
  longitude_j = tmp___12;
#line 641
  tmp___13 = cos(longitude_i - longitude_j);
#line 641
  q1 = tmp___13;
#line 642
  tmp___14 = cos(latitude_i - latitude_j);
#line 642
  q2 = tmp___14;
#line 643
  tmp___15 = cos(latitude_i + latitude_j);
#line 643
  q3 = tmp___15;
#line 644
  tmp___16 = acos(0.5 * ((1.0 + q1) * q2 - (1.0 - q1) * q3));
#line 644
  dij = (int )(rrr * tmp___16 + 1.0);
  }
#line 647
  goto switch_break;
  case_5: /* CIL Label */ 
#line 649
  if ((unsigned long )tsp->node_x_coord == (unsigned long )((void *)0)) {
    {
#line 650
    tmp___17 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 650);
#line 650
    (*tmp___17)("tsp_distance: node coordinates not specified\n");
    }
  } else
#line 649
  if ((unsigned long )tsp->node_y_coord == (unsigned long )((void *)0)) {
    {
#line 650
    tmp___17 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glptsp.c", 650);
#line 650
    (*tmp___17)("tsp_distance: node coordinates not specified\n");
    }
  }
  {
#line 653
  xd___1 = *(tsp->node_x_coord + i) - *(tsp->node_x_coord + j);
#line 654
  yd___1 = *(tsp->node_y_coord + i) - *(tsp->node_y_coord + j);
#line 655
  rij = sqrt((xd___1 * xd___1 + yd___1 * yd___1) / 10.0);
#line 656
  tij = (int )(rij + 0.5);
  }
#line 657
  if ((double )tij < rij) {
#line 657
    dij = tij + 1;
  } else {
#line 657
    dij = tij;
  }
#line 659
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 661
  if (tsp->edge_weight_type != tsp->edge_weight_type) {
#line 661
    tmp___18 = 1;
  } else {
    {
#line 661
    _glp_lib_xassert("tsp->edge_weight_type != tsp->edge_weight_type", "/home/wslee/benchmarks/glpk-4.38/src/glptsp.c",
                     661);
#line 661
    tmp___18 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (dij);
}
}
#line 324 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
xlong_t _glp_lib_xtime(void) ;
#line 328
double _glp_lib_xdifftime(xlong_t t1 , xlong_t t0 ) ;
#line 167 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
mpq_t _glp_mpq_init(void) ;
#line 169
void _glp_mpq_clear(mpq_t x ) ;
#line 171
void _glp_mpq_set(mpq_t z , mpq_t x ) ;
#line 172
void _glp_mpq_set_si(mpq_t x , int p , unsigned int q ) ;
#line 173
double _glp_mpq_get_d(mpq_t x ) ;
#line 175
void _glp_mpq_add(mpq_t z , mpq_t x , mpq_t y ) ;
#line 176
void _glp_mpq_sub(mpq_t z , mpq_t x , mpq_t y ) ;
#line 177
void _glp_mpq_mul(mpq_t z , mpq_t x , mpq_t y ) ;
#line 179
void _glp_mpq_neg(mpq_t z , mpq_t x ) ;
#line 181
int _glp_mpq_cmp(mpq_t x , mpq_t y ) ;
#line 182
int _glp_mpq_sgn(mpq_t x ) ;
#line 358 "/home/wslee/benchmarks/glpk-4.38/src/glpssx.h"
int _glp_ssx_factorize(SSX *ssx ) ;
#line 364
void _glp_ssx_eval_bbar(SSX *ssx ) ;
#line 367
void _glp_ssx_eval_pi(SSX *ssx ) ;
#line 373
void _glp_ssx_eval_cbar(SSX *ssx ) ;
#line 376
void _glp_ssx_eval_rho(SSX *ssx ) ;
#line 379
void _glp_ssx_eval_row(SSX *ssx ) ;
#line 382
void _glp_ssx_eval_col(SSX *ssx ) ;
#line 385
void _glp_ssx_chuzc(SSX *ssx ) ;
#line 388
void _glp_ssx_chuzr(SSX *ssx ) ;
#line 391
void _glp_ssx_update_bbar(SSX *ssx ) ;
#line 394
void _glp_ssx_update_pi(SSX *ssx ) ;
#line 397
void _glp_ssx_update_cbar(SSX *ssx ) ;
#line 400
void _glp_ssx_change_basis(SSX *ssx ) ;
#line 406
int _glp_ssx_phase_I(SSX *ssx ) ;
#line 409
int _glp_ssx_phase_II(SSX *ssx ) ;
#line 412
int _glp_ssx_driver(SSX *ssx ) ;
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c"
static void show_progress(SSX *ssx , int phase ) 
{ 
  int i ;
  int def ;
  double tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 30
  def = 0;
#line 31
  i = 1;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i <= ssx->m)) {
#line 31
      goto while_break;
    }
#line 32
    if (*(ssx->type + *(ssx->Q_col + i)) == 4) {
#line 32
      def ++;
    }
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 33
  tmp = _glp_mpq_get_d(*(ssx->bbar + 0));
  }
#line 33
  if (phase == 1) {
#line 33
    tmp___0 = "infsum";
  } else {
#line 33
    tmp___0 = "objval";
  }
#line 33
  if (phase == 1) {
#line 33
    tmp___1 = " ";
  } else {
#line 33
    tmp___1 = "*";
  }
  {
#line 33
  _glp_lib_xprintf("%s%6d:   %s = %22.15g   (%d)\n", tmp___1, ssx->it_cnt, tmp___0,
                   tmp, def);
#line 39
  ssx->tm_lag = _glp_lib_xtime();
  }
#line 41
  return;
}
}
#line 57 "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c"
int _glp_ssx_phase_I(SSX *ssx ) 
{ 
  int m ;
  int n ;
  int *type ;
  mpq_t *lb ;
  mpq_t *ub ;
  mpq_t *coef ;
  int *A_ptr ;
  int *A_ind ;
  mpq_t *A_val ;
  int *Q_col ;
  mpq_t *bbar ;
  mpq_t *pi ;
  mpq_t *cbar ;
  int *orig_type ;
  int orig_dir ;
  mpq_t *orig_lb ;
  mpq_t *orig_ub ;
  mpq_t *orig_coef ;
  int i ;
  int k ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int t ;
  int tmp___3 ;
  int tmp___4 ;
  xlong_t tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  xlong_t tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int ptr ;
  mpq_t temp ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 58
  m = ssx->m;
#line 59
  n = ssx->n;
#line 60
  type = ssx->type;
#line 61
  lb = ssx->lb;
#line 62
  ub = ssx->ub;
#line 63
  coef = ssx->coef;
#line 64
  A_ptr = ssx->A_ptr;
#line 65
  A_ind = ssx->A_ind;
#line 66
  A_val = ssx->A_val;
#line 67
  Q_col = ssx->Q_col;
#line 68
  bbar = ssx->bbar;
#line 69
  pi = ssx->pi;
#line 70
  cbar = ssx->cbar;
#line 76
  tmp = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 76
  orig_type = (int *)tmp;
#line 77
  tmp___0 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(mpq_t ));
#line 77
  orig_lb = (mpq_t *)tmp___0;
#line 78
  tmp___1 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(mpq_t ));
#line 78
  orig_ub = (mpq_t *)tmp___1;
#line 79
  tmp___2 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(mpq_t ));
#line 79
  orig_coef = (mpq_t *)tmp___2;
#line 80
  k = 1;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (k <= m + n)) {
#line 80
      goto while_break;
    }
    {
#line 81
    *(orig_type + k) = *(type + k);
#line 82
    *(orig_lb + k) = _glp_mpq_init();
#line 83
    _glp_mpq_set(*(orig_lb + k), *(lb + k));
#line 84
    *(orig_ub + k) = _glp_mpq_init();
#line 85
    _glp_mpq_set(*(orig_ub + k), *(ub + k));
#line 80
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  orig_dir = ssx->dir;
#line 88
  k = 0;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (k <= m + n)) {
#line 88
      goto while_break___0;
    }
    {
#line 89
    *(orig_coef + k) = _glp_mpq_init();
#line 90
    _glp_mpq_set(*(orig_coef + k), *(coef + k));
#line 88
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  ssx->dir = 0;
#line 96
  k = 0;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! (k <= m + n)) {
#line 96
      goto while_break___1;
    }
    {
#line 96
    _glp_mpq_set_si(*(coef + k), 0, 1U);
#line 96
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  _glp_mpq_set_si(*(bbar + 0), 0, 1U);
#line 98
  i = 1;
  }
  {
#line 98
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 98
    if (! (i <= m)) {
#line 98
      goto while_break___2;
    }
#line 100
    k = *(Q_col + i);
#line 101
    t = *(type + k);
#line 102
    if (t == 1) {
#line 102
      goto _L;
    } else
#line 102
    if (t == 3) {
#line 102
      goto _L;
    } else
#line 102
    if (t == 4) {
      _L: /* CIL Label */ 
      {
#line 104
      tmp___3 = _glp_mpq_cmp(*(bbar + i), *(lb + k));
      }
#line 104
      if (tmp___3 < 0) {
        {
#line 106
        *(type + k) = 2;
#line 107
        _glp_mpq_set(*(ub + k), *(lb + k));
#line 108
        _glp_mpq_set_si(*(lb + k), 0, 1U);
#line 109
        _glp_mpq_set_si(*(coef + k), -1, 1U);
#line 110
        _glp_mpq_add(*(bbar + 0), *(bbar + 0), *(ub + k));
#line 111
        _glp_mpq_sub(*(bbar + 0), *(bbar + 0), *(bbar + i));
        }
      }
    }
#line 114
    if (t == 2) {
#line 114
      goto _L___0;
    } else
#line 114
    if (t == 3) {
#line 114
      goto _L___0;
    } else
#line 114
    if (t == 4) {
      _L___0: /* CIL Label */ 
      {
#line 116
      tmp___4 = _glp_mpq_cmp(*(bbar + i), *(ub + k));
      }
#line 116
      if (tmp___4 > 0) {
        {
#line 118
        *(type + k) = 1;
#line 119
        _glp_mpq_set(*(lb + k), *(ub + k));
#line 120
        _glp_mpq_set_si(*(ub + k), 0, 1U);
#line 121
        _glp_mpq_set_si(*(coef + k), 1, 1U);
#line 122
        _glp_mpq_add(*(bbar + 0), *(bbar + 0), *(bbar + i));
#line 123
        _glp_mpq_sub(*(bbar + 0), *(bbar + 0), *(lb + k));
        }
      }
    }
#line 98
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 131
  _glp_ssx_eval_pi(ssx);
#line 132
  _glp_ssx_eval_cbar(ssx);
#line 134
  show_progress(ssx, 1);
  }
  {
#line 136
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 141
    tmp___5 = _glp_lib_xtime();
#line 141
    tmp___6 = _glp_lib_xdifftime(tmp___5, ssx->tm_lag);
    }
#line 141
    if (tmp___6 >= ssx->out_frq - 0.001) {
      {
#line 143
      show_progress(ssx, 1);
      }
    }
    {
#line 146
    tmp___7 = _glp_mpq_sgn(*(bbar + 0));
    }
#line 146
    if (tmp___7 == 0) {
#line 149
      ret = 0;
#line 150
      goto while_break___3;
    }
#line 153
    if (ssx->it_lim == 0) {
#line 154
      ret = 2;
#line 155
      goto while_break___3;
    }
#line 161
    if (ssx->tm_lim >= 0.0) {
      {
#line 161
      tmp___8 = _glp_lib_xtime();
#line 161
      tmp___9 = _glp_lib_xdifftime(tmp___8, ssx->tm_beg);
      }
#line 161
      if (ssx->tm_lim <= tmp___9) {
#line 164
        ret = 3;
#line 165
        goto while_break___3;
      }
    }
    {
#line 168
    _glp_ssx_chuzc(ssx);
    }
#line 172
    if (ssx->q == 0) {
#line 173
      ret = 1;
#line 174
      goto while_break___3;
    }
    {
#line 177
    _glp_ssx_eval_col(ssx);
#line 179
    _glp_ssx_chuzr(ssx);
    }
#line 182
    if (ssx->p != 0) {
#line 182
      tmp___10 = 1;
    } else {
      {
#line 182
      _glp_lib_xassert("ssx->p != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c",
                       182);
#line 182
      tmp___10 = 1;
      }
    }
    {
#line 184
    _glp_ssx_update_bbar(ssx);
    }
#line 185
    if (ssx->p > 0) {
      {
#line 187
      _glp_ssx_eval_rho(ssx);
#line 189
      _glp_ssx_eval_row(ssx);
#line 190
      tmp___11 = _glp_mpq_cmp(*(ssx->aq + ssx->p), *(ssx->ap + ssx->q));
      }
#line 190
      if (tmp___11 == 0) {
#line 190
        tmp___12 = 1;
      } else {
        {
#line 190
        _glp_lib_xassert("mpq_cmp(ssx->aq[ssx->p], ssx->ap[ssx->q]) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c",
                         190);
#line 190
        tmp___12 = 1;
        }
      }
      {
#line 192
      _glp_ssx_update_pi(ssx);
#line 194
      _glp_ssx_update_cbar(ssx);
      }
    }
#line 200
    if (ssx->p > 0) {
#line 201
      k = *(Q_col + ssx->p);
#line 202
      if (*(type + k) != *(orig_type + k)) {
        {
#line 204
        *(type + k) = *(orig_type + k);
#line 205
        _glp_mpq_set(*(lb + k), *(orig_lb + k));
#line 206
        _glp_mpq_set(*(ub + k), *(orig_ub + k));
        }
#line 207
        if (ssx->p_stat == 1) {
#line 207
          tmp___13 = 1;
        } else
#line 207
        if (ssx->p_stat == 2) {
#line 207
          tmp___13 = 1;
        } else {
          {
#line 207
          _glp_lib_xassert("ssx->p_stat == SSX_NL || ssx->p_stat == SSX_NU", "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c",
                           207);
#line 207
          tmp___13 = 1;
          }
        }
#line 208
        if (ssx->p_stat == 1) {
#line 208
          ssx->p_stat = 2;
        } else {
#line 208
          ssx->p_stat = 1;
        }
#line 209
        if (*(type + k) == 4) {
#line 209
          ssx->p_stat = 4;
        }
        {
#line 211
        _glp_mpq_set_si(*(coef + k), 0, 1U);
        }
#line 220
        if (k <= m) {
          {
#line 222
          _glp_mpq_neg(*(cbar + ssx->q), *(pi + k));
          }
        } else {
          {
#line 228
          temp = _glp_mpq_init();
#line 229
          _glp_mpq_set_si(*(cbar + ssx->q), 0, 1U);
#line 230
          ptr = *(A_ptr + (k - m));
          }
          {
#line 230
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 230
            if (! (ptr < *(A_ptr + ((k - m) + 1)))) {
#line 230
              goto while_break___4;
            }
            {
#line 231
            _glp_mpq_mul(temp, *(pi + *(A_ind + ptr)), *(A_val + ptr));
#line 232
            _glp_mpq_add(*(cbar + ssx->q), *(cbar + ssx->q), temp);
#line 230
            ptr ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 234
          _glp_mpq_clear(temp);
          }
        }
      }
    }
    {
#line 239
    _glp_ssx_change_basis(ssx);
    }
#line 241
    if (ssx->it_lim > 0) {
#line 241
      (ssx->it_lim) --;
    }
#line 242
    (ssx->it_cnt) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 245
  show_progress(ssx, 1);
#line 248
  k = 1;
  }
  {
#line 248
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 248
    if (! (k <= m + n)) {
#line 248
      goto while_break___5;
    }
    {
#line 249
    *(type + k) = *(orig_type + k);
#line 250
    _glp_mpq_set(*(lb + k), *(orig_lb + k));
#line 251
    _glp_mpq_clear(*(orig_lb + k));
#line 252
    _glp_mpq_set(*(ub + k), *(orig_ub + k));
#line 253
    _glp_mpq_clear(*(orig_ub + k));
#line 248
    k ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 255
  ssx->dir = orig_dir;
#line 256
  k = 0;
  {
#line 256
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 256
    if (! (k <= m + n)) {
#line 256
      goto while_break___6;
    }
    {
#line 257
    _glp_mpq_set(*(coef + k), *(orig_coef + k));
#line 258
    _glp_mpq_clear(*(orig_coef + k));
#line 256
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 260
  _glp_lib_xfree((void *)orig_type);
#line 261
  _glp_lib_xfree((void *)orig_lb);
#line 262
  _glp_lib_xfree((void *)orig_ub);
#line 263
  _glp_lib_xfree((void *)orig_coef);
  }
#line 265
  return (ret);
}
}
#line 281 "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c"
int _glp_ssx_phase_II(SSX *ssx ) 
{ 
  int ret ;
  xlong_t tmp ;
  double tmp___0 ;
  xlong_t tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 284
  show_progress(ssx, 2);
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    tmp = _glp_lib_xtime();
#line 291
    tmp___0 = _glp_lib_xdifftime(tmp, ssx->tm_lag);
    }
#line 291
    if (tmp___0 >= ssx->out_frq - 0.001) {
      {
#line 293
      show_progress(ssx, 2);
      }
    }
#line 295
    if (ssx->it_lim == 0) {
#line 296
      ret = 2;
#line 297
      goto while_break;
    }
#line 303
    if (ssx->tm_lim >= 0.0) {
      {
#line 303
      tmp___1 = _glp_lib_xtime();
#line 303
      tmp___2 = _glp_lib_xdifftime(tmp___1, ssx->tm_beg);
      }
#line 303
      if (ssx->tm_lim <= tmp___2) {
#line 306
        ret = 3;
#line 307
        goto while_break;
      }
    }
    {
#line 310
    _glp_ssx_chuzc(ssx);
    }
#line 313
    if (ssx->q == 0) {
#line 314
      ret = 0;
#line 315
      goto while_break;
    }
    {
#line 318
    _glp_ssx_eval_col(ssx);
#line 320
    _glp_ssx_chuzr(ssx);
    }
#line 323
    if (ssx->p == 0) {
#line 324
      ret = 1;
#line 325
      goto while_break;
    }
    {
#line 328
    _glp_ssx_update_bbar(ssx);
    }
#line 329
    if (ssx->p > 0) {
      {
#line 331
      _glp_ssx_eval_rho(ssx);
#line 333
      _glp_ssx_eval_row(ssx);
#line 334
      tmp___3 = _glp_mpq_cmp(*(ssx->aq + ssx->p), *(ssx->ap + ssx->q));
      }
#line 334
      if (tmp___3 == 0) {
#line 334
        tmp___4 = 1;
      } else {
        {
#line 334
        _glp_lib_xassert("mpq_cmp(ssx->aq[ssx->p], ssx->ap[ssx->q]) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c",
                         334);
#line 334
        tmp___4 = 1;
        }
      }
      {
#line 340
      _glp_ssx_update_cbar(ssx);
      }
    }
    {
#line 343
    _glp_ssx_change_basis(ssx);
    }
#line 345
    if (ssx->it_lim > 0) {
#line 345
      (ssx->it_lim) --;
    }
#line 346
    (ssx->it_cnt) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  show_progress(ssx, 2);
  }
#line 351
  return (ret);
}
}
#line 372 "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c"
int _glp_ssx_driver(SSX *ssx ) 
{ 
  int m ;
  int *type ;
  mpq_t *lb ;
  mpq_t *ub ;
  int *Q_col ;
  mpq_t *bbar ;
  int i ;
  int k ;
  int ret ;
  int tmp ;
  int t ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  xlong_t tmp___4 ;
  double tmp___5 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 373
  m = ssx->m;
#line 374
  type = ssx->type;
#line 375
  lb = ssx->lb;
#line 376
  ub = ssx->ub;
#line 377
  Q_col = ssx->Q_col;
#line 378
  bbar = ssx->bbar;
#line 380
  ssx->tm_beg = _glp_lib_xtime();
#line 382
  tmp = _glp_ssx_factorize(ssx);
  }
#line 382
  if (tmp) {
    {
#line 383
    _glp_lib_xprintf("Initial basis matrix is singular\n");
#line 384
    ret = 7;
    }
#line 385
    goto done;
  }
  {
#line 388
  _glp_ssx_eval_bbar(ssx);
#line 390
  i = 1;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i <= m)) {
#line 390
      goto while_break;
    }
#line 392
    k = *(Q_col + i);
#line 393
    t = *(type + k);
#line 394
    if (t == 1) {
#line 394
      goto _L;
    } else
#line 394
    if (t == 3) {
#line 394
      goto _L;
    } else
#line 394
    if (t == 4) {
      _L: /* CIL Label */ 
      {
#line 396
      tmp___0 = _glp_mpq_cmp(*(bbar + i), *(lb + k));
      }
#line 396
      if (tmp___0 < 0) {
#line 398
        goto while_break;
      }
    }
#line 401
    if (t == 2) {
#line 401
      goto _L___0;
    } else
#line 401
    if (t == 3) {
#line 401
      goto _L___0;
    } else
#line 401
    if (t == 4) {
      _L___0: /* CIL Label */ 
      {
#line 403
      tmp___1 = _glp_mpq_cmp(*(bbar + i), *(ub + k));
      }
#line 403
      if (tmp___1 > 0) {
#line 405
        goto while_break;
      }
    }
#line 390
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if (i > m) {
#line 411
    ret = 0;
#line 412
    goto skip;
  }
  {
#line 415
  ret = _glp_ssx_phase_I(ssx);
  }
  {
#line 417
  if (ret == 0) {
#line 417
    goto case_0;
  }
#line 420
  if (ret == 1) {
#line 420
    goto case_1;
  }
#line 424
  if (ret == 2) {
#line 424
    goto case_2;
  }
#line 428
  if (ret == 3) {
#line 428
    goto case_3;
  }
#line 432
  goto switch_default;
  case_0: /* CIL Label */ 
#line 418
  ret = 0;
#line 419
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 421
  _glp_lib_xprintf("PROBLEM HAS NO FEASIBLE SOLUTION\n");
#line 422
  ret = 1;
  }
#line 423
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 425
  _glp_lib_xprintf("ITERATIONS LIMIT EXCEEDED; SEARCH TERMINATED\n");
#line 426
  ret = 3;
  }
#line 427
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 429
  _glp_lib_xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
#line 430
  ret = 5;
  }
#line 431
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 433
  if (ret != ret) {
#line 433
    tmp___2 = 1;
  } else {
    {
#line 433
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c",
                     433);
#line 433
    tmp___2 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 437
  _glp_ssx_eval_bbar(ssx);
  }
  skip: 
  {
#line 439
  _glp_ssx_eval_pi(ssx);
#line 441
  _glp_ssx_eval_cbar(ssx);
  }
#line 443
  if (ret != 0) {
#line 443
    goto done;
  }
  {
#line 445
  ret = _glp_ssx_phase_II(ssx);
  }
  {
#line 447
  if (ret == 0) {
#line 447
    goto case_0___0;
  }
#line 451
  if (ret == 1) {
#line 451
    goto case_1___0;
  }
#line 455
  if (ret == 2) {
#line 455
    goto case_2___0;
  }
#line 459
  if (ret == 3) {
#line 459
    goto case_3___0;
  }
#line 463
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 448
  _glp_lib_xprintf("OPTIMAL SOLUTION FOUND\n");
#line 449
  ret = 0;
  }
#line 450
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 452
  _glp_lib_xprintf("PROBLEM HAS UNBOUNDED SOLUTION\n");
#line 453
  ret = 2;
  }
#line 454
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 456
  _glp_lib_xprintf("ITERATIONS LIMIT EXCEEDED; SEARCH TERMINATED\n");
#line 457
  ret = 4;
  }
#line 458
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 460
  _glp_lib_xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
#line 461
  ret = 6;
  }
#line 462
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 464
  if (ret != ret) {
#line 464
    tmp___3 = 1;
  } else {
    {
#line 464
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpssx02.c",
                     464);
#line 464
    tmp___3 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  done: 
#line 467
  if (ssx->tm_lim >= 0.0) {
    {
#line 471
    tmp___4 = _glp_lib_xtime();
#line 471
    tmp___5 = _glp_lib_xdifftime(tmp___4, ssx->tm_beg);
#line 471
    ssx->tm_lim -= tmp___5;
    }
#line 473
    if (ssx->tm_lim < 0.0) {
#line 473
      ssx->tm_lim = 0.0;
    }
  }
#line 475
  return (ret);
}
}
#line 182 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 178 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
void _glp_mpq_div(mpq_t z , mpq_t x , mpq_t y ) ;
#line 180
void _glp_mpq_abs(mpq_t z , mpq_t x ) ;
#line 43 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.h"
extern BFX *_glp_bfx_create_binv(void) ;
#line 52
extern int _glp_bfx_factorize(BFX *binv , int m , int (*col)(void *info , int j ,
                                                             int *ind , mpq_t *val ) ,
                              void *info ) ;
#line 56
extern void _glp_bfx_ftran(BFX *binv , mpq_t *x , int save ) ;
#line 59
extern void _glp_bfx_btran(BFX *binv , mpq_t *x ) ;
#line 62
extern int _glp_bfx_update(BFX *binv , int j ) ;
#line 65
extern void _glp_bfx_delete_binv(BFX *binv ) ;
#line 355 "/home/wslee/benchmarks/glpk-4.38/src/glpssx.h"
SSX *_glp_ssx_create(int m , int n , int nnz ) ;
#line 361
void _glp_ssx_get_xNj(SSX *ssx , int j , mpq_t x ) ;
#line 370
void _glp_ssx_eval_dj(SSX *ssx , int j , mpq_t dj ) ;
#line 403
void _glp_ssx_delete(SSX *ssx ) ;
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
SSX *_glp_ssx_create(int m , int n , int nnz ) 
{ 
  SSX *ssx ;
  int i ;
  int j ;
  int k ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 43
  if (m < 1) {
    {
#line 44
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c", 44);
#line 44
    (*tmp)("ssx_create: m = %d; invalid number of rows\n", m);
    }
  }
#line 45
  if (n < 1) {
    {
#line 46
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                               46);
#line 46
    (*tmp___0)("ssx_create: n = %d; invalid number of columns\n", n);
    }
  }
#line 47
  if (nnz < 0) {
    {
#line 48
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                               48);
#line 48
    (*tmp___1)("ssx_create: nnz = %d; invalid number of non-zero constraint coefficients\n",
               nnz);
    }
  }
  {
#line 50
  tmp___2 = _glp_lib_xmalloc((int )sizeof(SSX ));
#line 50
  ssx = (SSX *)tmp___2;
#line 51
  ssx->m = m;
#line 52
  ssx->n = n;
#line 53
  tmp___3 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 53
  ssx->type = (int *)tmp___3;
#line 54
  tmp___4 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(mpq_t ));
#line 54
  ssx->lb = (mpq_t *)tmp___4;
#line 55
  k = 1;
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (k <= m + n)) {
#line 55
      goto while_break;
    }
    {
#line 55
    *(ssx->lb + k) = _glp_mpq_init();
#line 55
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  tmp___5 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(mpq_t ));
#line 56
  ssx->ub = (mpq_t *)tmp___5;
#line 57
  k = 1;
  }
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (k <= m + n)) {
#line 57
      goto while_break___0;
    }
    {
#line 57
    *(ssx->ub + k) = _glp_mpq_init();
#line 57
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  tmp___6 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(mpq_t ));
#line 58
  ssx->coef = (mpq_t *)tmp___6;
#line 59
  k = 0;
  }
  {
#line 59
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 59
    if (! (k <= m + n)) {
#line 59
      goto while_break___1;
    }
    {
#line 59
    *(ssx->coef + k) = _glp_mpq_init();
#line 59
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 60
  tmp___7 = _glp_lib_xcalloc((1 + n) + 1, (int )sizeof(int ));
#line 60
  ssx->A_ptr = (int *)tmp___7;
#line 61
  *(ssx->A_ptr + (n + 1)) = nnz + 1;
#line 62
  tmp___8 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(int ));
#line 62
  ssx->A_ind = (int *)tmp___8;
#line 63
  tmp___9 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(mpq_t ));
#line 63
  ssx->A_val = (mpq_t *)tmp___9;
#line 64
  k = 1;
  }
  {
#line 64
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 64
    if (! (k <= nnz)) {
#line 64
      goto while_break___2;
    }
    {
#line 64
    *(ssx->A_val + k) = _glp_mpq_init();
#line 64
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 65
  tmp___10 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 65
  ssx->stat = (int *)tmp___10;
#line 66
  tmp___11 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 66
  ssx->Q_row = (int *)tmp___11;
#line 67
  tmp___12 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 67
  ssx->Q_col = (int *)tmp___12;
#line 68
  ssx->binv = _glp_bfx_create_binv();
#line 69
  tmp___13 = _glp_lib_xcalloc(1 + m, (int )sizeof(mpq_t ));
#line 69
  ssx->bbar = (mpq_t *)tmp___13;
#line 70
  i = 0;
  }
  {
#line 70
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 70
    if (! (i <= m)) {
#line 70
      goto while_break___3;
    }
    {
#line 70
    *(ssx->bbar + i) = _glp_mpq_init();
#line 70
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 71
  tmp___14 = _glp_lib_xcalloc(1 + m, (int )sizeof(mpq_t ));
#line 71
  ssx->pi = (mpq_t *)tmp___14;
#line 72
  i = 1;
  }
  {
#line 72
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 72
    if (! (i <= m)) {
#line 72
      goto while_break___4;
    }
    {
#line 72
    *(ssx->pi + i) = _glp_mpq_init();
#line 72
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 73
  tmp___15 = _glp_lib_xcalloc(1 + n, (int )sizeof(mpq_t ));
#line 73
  ssx->cbar = (mpq_t *)tmp___15;
#line 74
  j = 1;
  }
  {
#line 74
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 74
    if (! (j <= n)) {
#line 74
      goto while_break___5;
    }
    {
#line 74
    *(ssx->cbar + j) = _glp_mpq_init();
#line 74
    j ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 75
  tmp___16 = _glp_lib_xcalloc(1 + m, (int )sizeof(mpq_t ));
#line 75
  ssx->rho = (mpq_t *)tmp___16;
#line 76
  i = 1;
  }
  {
#line 76
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 76
    if (! (i <= m)) {
#line 76
      goto while_break___6;
    }
    {
#line 76
    *(ssx->rho + i) = _glp_mpq_init();
#line 76
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 77
  tmp___17 = _glp_lib_xcalloc(1 + n, (int )sizeof(mpq_t ));
#line 77
  ssx->ap = (mpq_t *)tmp___17;
#line 78
  j = 1;
  }
  {
#line 78
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 78
    if (! (j <= n)) {
#line 78
      goto while_break___7;
    }
    {
#line 78
    *(ssx->ap + j) = _glp_mpq_init();
#line 78
    j ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 79
  tmp___18 = _glp_lib_xcalloc(1 + m, (int )sizeof(mpq_t ));
#line 79
  ssx->aq = (mpq_t *)tmp___18;
#line 80
  i = 1;
  }
  {
#line 80
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 80
    if (! (i <= m)) {
#line 80
      goto while_break___8;
    }
    {
#line 80
    *(ssx->aq + i) = _glp_mpq_init();
#line 80
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 81
  ssx->delta = _glp_mpq_init();
  }
#line 82
  return (ssx);
}
}
#line 92 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
static int basis_col(void *info , int j , int *ind , mpq_t *val ) 
{ 
  SSX *ssx ;
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  mpq_t *A_val ;
  int *Q_col ;
  int k ;
  int len ;
  int ptr ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 95
  ssx = (SSX *)info;
#line 96
  m = ssx->m;
#line 97
  n = ssx->n;
#line 98
  A_ptr = ssx->A_ptr;
#line 99
  A_ind = ssx->A_ind;
#line 100
  A_val = ssx->A_val;
#line 101
  Q_col = ssx->Q_col;
#line 103
  if (1 <= j) {
#line 103
    if (j <= m) {
#line 103
      tmp = 1;
    } else {
      {
#line 103
      _glp_lib_xassert("1 <= j && j <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       103);
#line 103
      tmp = 1;
      }
    }
  } else {
    {
#line 103
    _glp_lib_xassert("1 <= j && j <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     103);
#line 103
    tmp = 1;
    }
  }
#line 104
  k = *(Q_col + j);
#line 105
  if (1 <= k) {
#line 105
    if (k <= m + n) {
#line 105
      tmp___0 = 1;
    } else {
      {
#line 105
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       105);
#line 105
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 105
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     105);
#line 105
    tmp___0 = 1;
    }
  }
#line 108
  if (k <= m) {
    {
#line 110
    len = 1;
#line 110
    *(ind + 1) = k;
#line 110
    _glp_mpq_set_si(*(val + 1), 1, 1U);
    }
  } else {
#line 114
    len = 0;
#line 115
    ptr = *(A_ptr + (k - m));
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! (ptr < *(A_ptr + ((k - m) + 1)))) {
#line 115
        goto while_break;
      }
      {
#line 116
      len ++;
#line 117
      *(ind + len) = *(A_ind + ptr);
#line 118
      _glp_mpq_neg(*(val + len), *(A_val + ptr));
#line 115
      ptr ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 121
  return (len);
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
int _glp_ssx_factorize(SSX *ssx ) 
{ 
  int ret ;

  {
  {
#line 126
  ret = _glp_bfx_factorize(ssx->binv, ssx->m, & basis_col, (void *)ssx);
  }
#line 127
  return (ret);
}
}
#line 143 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_get_xNj(SSX *ssx , int j , mpq_t x ) 
{ 
  int m ;
  int n ;
  mpq_t *lb ;
  mpq_t *ub ;
  int *stat ;
  int *Q_col ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 144
  m = ssx->m;
#line 145
  n = ssx->n;
#line 146
  lb = ssx->lb;
#line 147
  ub = ssx->ub;
#line 148
  stat = ssx->stat;
#line 149
  Q_col = ssx->Q_col;
#line 151
  if (1 <= j) {
#line 151
    if (j <= n) {
#line 151
      tmp = 1;
    } else {
      {
#line 151
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       151);
#line 151
      tmp = 1;
      }
    }
  } else {
    {
#line 151
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     151);
#line 151
    tmp = 1;
    }
  }
#line 152
  k = *(Q_col + (m + j));
#line 153
  if (1 <= k) {
#line 153
    if (k <= m + n) {
#line 153
      tmp___0 = 1;
    } else {
      {
#line 153
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       153);
#line 153
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 153
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     153);
#line 153
    tmp___0 = 1;
    }
  }
  {
#line 155
  if (*(stat + k) == 1) {
#line 155
    goto case_1;
  }
#line 158
  if (*(stat + k) == 2) {
#line 158
    goto case_2;
  }
#line 161
  if (*(stat + k) == 3) {
#line 161
    goto case_3;
  }
#line 164
  if (*(stat + k) == 4) {
#line 164
    goto case_4;
  }
#line 167
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 157
  _glp_mpq_set(x, *(lb + k));
  }
#line 157
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 160
  _glp_mpq_set(x, *(ub + k));
  }
#line 160
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 163
  _glp_mpq_set_si(x, 0, 1U);
  }
#line 163
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 166
  _glp_mpq_set(x, *(lb + k));
  }
#line 166
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 168
  if ((unsigned long )stat != (unsigned long )stat) {
#line 168
    tmp___1 = 1;
  } else {
    {
#line 168
    _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     168);
#line 168
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 184 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_eval_bbar(SSX *ssx ) 
{ 
  int m ;
  int n ;
  mpq_t *coef ;
  int *A_ptr ;
  int *A_ind ;
  mpq_t *A_val ;
  int *Q_col ;
  mpq_t *bbar ;
  int i ;
  int j ;
  int k ;
  int ptr ;
  mpq_t x ;
  mpq_t temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 185
  m = ssx->m;
#line 186
  n = ssx->n;
#line 187
  coef = ssx->coef;
#line 188
  A_ptr = ssx->A_ptr;
#line 189
  A_ind = ssx->A_ind;
#line 190
  A_val = ssx->A_val;
#line 191
  Q_col = ssx->Q_col;
#line 192
  bbar = ssx->bbar;
#line 195
  x = _glp_mpq_init();
#line 196
  temp = _glp_mpq_init();
#line 198
  i = 1;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i <= m)) {
#line 198
      goto while_break;
    }
    {
#line 199
    _glp_mpq_set_si(*(bbar + i), 0, 1U);
#line 198
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  j = 1;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (j <= n)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    _glp_ssx_get_xNj(ssx, j, x);
#line 203
    tmp = _glp_mpq_sgn(x);
    }
#line 203
    if (tmp == 0) {
#line 203
      goto __Cont;
    }
#line 204
    k = *(Q_col + (m + j));
#line 205
    if (k <= m) {
      {
#line 207
      _glp_mpq_sub(*(bbar + k), *(bbar + k), x);
      }
    } else {
#line 211
      ptr = *(A_ptr + (k - m));
      {
#line 211
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 211
        if (! (ptr < *(A_ptr + ((k - m) + 1)))) {
#line 211
          goto while_break___1;
        }
        {
#line 212
        _glp_mpq_mul(temp, *(A_val + ptr), x);
#line 213
        _glp_mpq_add(*(bbar + *(A_ind + ptr)), *(bbar + *(A_ind + ptr)), temp);
#line 211
        ptr ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 201
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 218
  _glp_bfx_ftran(ssx->binv, bbar, 0);
#line 222
  _glp_mpq_set(*(bbar + 0), *(coef + 0));
#line 224
  i = 1;
  }
  {
#line 224
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 224
    if (! (i <= m)) {
#line 224
      goto while_break___2;
    }
    {
#line 225
    k = *(Q_col + i);
#line 226
    tmp___0 = _glp_mpq_sgn(*(coef + k));
    }
#line 226
    if (tmp___0 == 0) {
#line 226
      goto __Cont___0;
    }
    {
#line 227
    _glp_mpq_mul(temp, *(coef + k), *(bbar + i));
#line 228
    _glp_mpq_add(*(bbar + 0), *(bbar + 0), temp);
    }
    __Cont___0: /* CIL Label */ 
#line 224
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 231
  j = 1;
  {
#line 231
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 231
    if (! (j <= n)) {
#line 231
      goto while_break___3;
    }
    {
#line 232
    k = *(Q_col + (m + j));
#line 233
    tmp___1 = _glp_mpq_sgn(*(coef + k));
    }
#line 233
    if (tmp___1 == 0) {
#line 233
      goto __Cont___1;
    }
    {
#line 234
    _glp_ssx_get_xNj(ssx, j, x);
#line 235
    _glp_mpq_mul(temp, *(coef + k), x);
#line 236
    _glp_mpq_add(*(bbar + 0), *(bbar + 0), temp);
    }
    __Cont___1: /* CIL Label */ 
#line 231
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 239
  _glp_mpq_clear(x);
#line 240
  _glp_mpq_clear(temp);
  }
#line 241
  return;
}
}
#line 255 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_eval_pi(SSX *ssx ) 
{ 
  int m ;
  mpq_t *coef ;
  int *Q_col ;
  mpq_t *pi ;
  int i ;

  {
#line 256
  m = ssx->m;
#line 257
  coef = ssx->coef;
#line 258
  Q_col = ssx->Q_col;
#line 259
  pi = ssx->pi;
#line 262
  i = 1;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i <= m)) {
#line 262
      goto while_break;
    }
    {
#line 262
    _glp_mpq_set(*(pi + i), *(coef + *(Q_col + i)));
#line 262
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  _glp_bfx_btran(ssx->binv, pi);
  }
#line 265
  return;
}
}
#line 280 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_eval_dj(SSX *ssx , int j , mpq_t dj ) 
{ 
  int m ;
  int n ;
  mpq_t *coef ;
  int *A_ptr ;
  int *A_ind ;
  mpq_t *A_val ;
  int *Q_col ;
  mpq_t *pi ;
  int k ;
  int ptr ;
  int end ;
  mpq_t temp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 281
  m = ssx->m;
#line 282
  n = ssx->n;
#line 283
  coef = ssx->coef;
#line 284
  A_ptr = ssx->A_ptr;
#line 285
  A_ind = ssx->A_ind;
#line 286
  A_val = ssx->A_val;
#line 287
  Q_col = ssx->Q_col;
#line 288
  pi = ssx->pi;
#line 291
  temp = _glp_mpq_init();
  }
#line 292
  if (1 <= j) {
#line 292
    if (j <= n) {
#line 292
      tmp = 1;
    } else {
      {
#line 292
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       292);
#line 292
      tmp = 1;
      }
    }
  } else {
    {
#line 292
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     292);
#line 292
    tmp = 1;
    }
  }
#line 293
  k = *(Q_col + (m + j));
#line 294
  if (1 <= k) {
#line 294
    if (k <= m + n) {
#line 294
      tmp___0 = 1;
    } else {
      {
#line 294
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       294);
#line 294
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 294
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     294);
#line 294
    tmp___0 = 1;
    }
  }
#line 297
  if (k <= m) {
    {
#line 299
    _glp_mpq_sub(dj, *(coef + k), *(pi + k));
    }
  } else {
    {
#line 303
    _glp_mpq_set(dj, *(coef + k));
#line 304
    ptr = *(A_ptr + (k - m));
#line 304
    end = *(A_ptr + ((k - m) + 1));
    }
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 304
      if (! (ptr < end)) {
#line 304
        goto while_break;
      }
      {
#line 305
      _glp_mpq_mul(temp, *(A_val + ptr), *(pi + *(A_ind + ptr)));
#line 306
      _glp_mpq_add(dj, dj, temp);
#line 304
      ptr ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 309
  _glp_mpq_clear(temp);
  }
#line 310
  return;
}
}
#line 319 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_eval_cbar(SSX *ssx ) 
{ 
  int n ;
  mpq_t *cbar ;
  int j ;

  {
#line 320
  n = ssx->n;
#line 321
  cbar = ssx->cbar;
#line 323
  j = 1;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (j <= n)) {
#line 323
      goto while_break;
    }
    {
#line 324
    _glp_ssx_eval_dj(ssx, j, *(cbar + j));
#line 323
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return;
}
}
#line 341 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_eval_rho(SSX *ssx ) 
{ 
  int m ;
  int p ;
  mpq_t *rho ;
  int i ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 342
  m = ssx->m;
#line 343
  p = ssx->p;
#line 344
  rho = ssx->rho;
#line 346
  if (1 <= p) {
#line 346
    if (p <= m) {
#line 346
      tmp = 1;
    } else {
      {
#line 346
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       346);
#line 346
      tmp = 1;
      }
    }
  } else {
    {
#line 346
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     346);
#line 346
    tmp = 1;
    }
  }
#line 348
  i = 1;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (i <= m)) {
#line 348
      goto while_break;
    }
    {
#line 348
    _glp_mpq_set_si(*(rho + i), 0, 1U);
#line 348
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  _glp_mpq_set_si(*(rho + p), 1, 1U);
#line 352
  _glp_bfx_btran(ssx->binv, rho);
  }
#line 353
  return;
}
}
#line 367 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_eval_row(SSX *ssx ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  mpq_t *A_val ;
  int *Q_col ;
  mpq_t *rho ;
  mpq_t *ap ;
  int j ;
  int k ;
  int ptr ;
  mpq_t temp ;

  {
  {
#line 368
  m = ssx->m;
#line 369
  n = ssx->n;
#line 370
  A_ptr = ssx->A_ptr;
#line 371
  A_ind = ssx->A_ind;
#line 372
  A_val = ssx->A_val;
#line 373
  Q_col = ssx->Q_col;
#line 374
  rho = ssx->rho;
#line 375
  ap = ssx->ap;
#line 378
  temp = _glp_mpq_init();
#line 379
  j = 1;
  }
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (j <= n)) {
#line 379
      goto while_break;
    }
#line 381
    k = *(Q_col + (m + j));
#line 382
    if (k <= m) {
      {
#line 383
      _glp_mpq_neg(*(ap + j), *(rho + k));
      }
    } else {
      {
#line 385
      _glp_mpq_set_si(*(ap + j), 0, 1U);
#line 386
      ptr = *(A_ptr + (k - m));
      }
      {
#line 386
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 386
        if (! (ptr < *(A_ptr + ((k - m) + 1)))) {
#line 386
          goto while_break___0;
        }
        {
#line 387
        _glp_mpq_mul(temp, *(A_val + ptr), *(rho + *(A_ind + ptr)));
#line 388
        _glp_mpq_add(*(ap + j), *(ap + j), temp);
#line 386
        ptr ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 379
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 392
  _glp_mpq_clear(temp);
  }
#line 393
  return;
}
}
#line 407 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_eval_col(SSX *ssx ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  mpq_t *A_val ;
  int *Q_col ;
  int q ;
  mpq_t *aq ;
  int i ;
  int k ;
  int ptr ;
  int tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 408
  m = ssx->m;
#line 409
  n = ssx->n;
#line 410
  A_ptr = ssx->A_ptr;
#line 411
  A_ind = ssx->A_ind;
#line 412
  A_val = ssx->A_val;
#line 413
  Q_col = ssx->Q_col;
#line 414
  q = ssx->q;
#line 415
  aq = ssx->aq;
#line 417
  if (1 <= q) {
#line 417
    if (q <= n) {
#line 417
      tmp = 1;
    } else {
      {
#line 417
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       417);
#line 417
      tmp = 1;
      }
    }
  } else {
    {
#line 417
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     417);
#line 417
    tmp = 1;
    }
  }
#line 419
  i = 1;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (i <= m)) {
#line 419
      goto while_break;
    }
    {
#line 419
    _glp_mpq_set_si(*(aq + i), 0, 1U);
#line 419
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  k = *(Q_col + (m + q));
#line 422
  if (k <= m) {
    {
#line 424
    _glp_mpq_set_si(*(aq + k), 1, 1U);
    }
  } else {
#line 428
    ptr = *(A_ptr + (k - m));
    {
#line 428
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 428
      if (! (ptr < *(A_ptr + ((k - m) + 1)))) {
#line 428
        goto while_break___0;
      }
      {
#line 429
      _glp_mpq_neg(*(aq + *(A_ind + ptr)), *(A_val + ptr));
#line 428
      ptr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 432
  _glp_bfx_ftran(ssx->binv, aq, 1);
#line 434
  i = 1;
  }
  {
#line 434
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 434
    if (! (i <= m)) {
#line 434
      goto while_break___1;
    }
    {
#line 434
    _glp_mpq_neg(*(aq + i), *(aq + i));
#line 434
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 456 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_chuzc(SSX *ssx ) 
{ 
  int m ;
  int n ;
  int dir ;
  int tmp ;
  int *Q_col ;
  int *stat ;
  mpq_t *cbar ;
  int j ;
  int k ;
  int s ;
  int q ;
  int q_dir ;
  double best ;
  double temp ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 457
  m = ssx->m;
#line 458
  n = ssx->n;
#line 459
  if (ssx->dir == 0) {
#line 459
    tmp = 1;
  } else {
#line 459
    tmp = -1;
  }
#line 459
  dir = tmp;
#line 460
  Q_col = ssx->Q_col;
#line 461
  stat = ssx->stat;
#line 462
  cbar = ssx->cbar;
#line 466
  q = 0;
#line 466
  q_dir = 0;
#line 466
  best = 0.0;
#line 468
  j = 1;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! (j <= n)) {
#line 468
      goto while_break;
    }
    {
#line 469
    k = *(Q_col + (m + j));
#line 470
    tmp___0 = _glp_mpq_sgn(*(cbar + j));
#line 470
    s = dir * tmp___0;
    }
#line 471
    if (*(stat + k) == 3) {
#line 471
      goto _L___2;
    } else
#line 471
    if (*(stat + k) == 1) {
      _L___2: /* CIL Label */ 
#line 471
      if (s < 0) {
#line 471
        goto _L;
      } else {
#line 471
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 471
    if (*(stat + k) == 3) {
#line 471
      goto _L___0;
    } else
#line 471
    if (*(stat + k) == 2) {
      _L___0: /* CIL Label */ 
#line 471
      if (s > 0) {
        _L: /* CIL Label */ 
        {
#line 475
        tmp___1 = _glp_mpq_get_d(*(cbar + j));
#line 475
        temp = fabs(tmp___1);
        }
#line 476
        if (temp != 0.0) {
#line 476
          tmp___2 = 1;
        } else {
          {
#line 476
          _glp_lib_xassert("temp != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                           476);
#line 476
          tmp___2 = 1;
          }
        }
#line 477
        if (q == 0) {
#line 478
          q = j;
#line 478
          q_dir = - s;
#line 478
          best = temp;
        } else
#line 477
        if (best < temp) {
#line 478
          q = j;
#line 478
          q_dir = - s;
#line 478
          best = temp;
        }
      }
    }
#line 468
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  ssx->q = q;
#line 481
  ssx->q_dir = q_dir;
#line 482
  return;
}
}
#line 504 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_chuzr(SSX *ssx ) 
{ 
  int m ;
  int n ;
  int *type ;
  mpq_t *lb ;
  mpq_t *ub ;
  int *Q_col ;
  mpq_t *bbar ;
  int q ;
  mpq_t *aq ;
  int q_dir ;
  int i ;
  int k ;
  int s ;
  int t ;
  int p ;
  int p_stat ;
  mpq_t teta ;
  mpq_t temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 505
  m = ssx->m;
#line 506
  n = ssx->n;
#line 507
  type = ssx->type;
#line 508
  lb = ssx->lb;
#line 509
  ub = ssx->ub;
#line 510
  Q_col = ssx->Q_col;
#line 511
  bbar = ssx->bbar;
#line 512
  q = ssx->q;
#line 513
  aq = ssx->aq;
#line 514
  q_dir = ssx->q_dir;
#line 517
  teta = _glp_mpq_init();
#line 518
  temp = _glp_mpq_init();
  }
#line 519
  if (1 <= q) {
#line 519
    if (q <= n) {
#line 519
      tmp = 1;
    } else {
      {
#line 519
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       519);
#line 519
      tmp = 1;
      }
    }
  } else {
    {
#line 519
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     519);
#line 519
    tmp = 1;
    }
  }
#line 520
  if (q_dir == 1) {
#line 520
    tmp___0 = 1;
  } else
#line 520
  if (q_dir == -1) {
#line 520
    tmp___0 = 1;
  } else {
    {
#line 520
    _glp_lib_xassert("q_dir == +1 || q_dir == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     520);
#line 520
    tmp___0 = 1;
    }
  }
#line 522
  p = 0;
#line 522
  p_stat = 0;
#line 524
  i = 1;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (i <= m)) {
#line 524
      goto while_break;
    }
    {
#line 525
    tmp___1 = _glp_mpq_sgn(*(aq + i));
#line 525
    s = q_dir * tmp___1;
    }
#line 526
    if (s < 0) {
#line 528
      k = *(Q_col + i);
#line 529
      t = *(type + k);
#line 530
      if (t == 1) {
#line 530
        goto _L___0;
      } else
#line 530
      if (t == 3) {
#line 530
        goto _L___0;
      } else
#line 530
      if (t == 4) {
        _L___0: /* CIL Label */ 
        {
#line 532
        _glp_mpq_sub(temp, *(bbar + i), *(lb + k));
#line 533
        _glp_mpq_div(temp, temp, *(aq + i));
#line 534
        _glp_mpq_abs(temp, temp);
        }
#line 535
        if (p == 0) {
#line 535
          goto _L;
        } else {
          {
#line 535
          tmp___2 = _glp_mpq_cmp(teta, temp);
          }
#line 535
          if (tmp___2 > 0) {
            _L: /* CIL Label */ 
#line 536
            p = i;
#line 537
            if (t == 4) {
#line 537
              p_stat = 4;
            } else {
#line 537
              p_stat = 1;
            }
            {
#line 538
            _glp_mpq_set(teta, temp);
            }
          }
        }
      }
    } else
#line 542
    if (s > 0) {
#line 544
      k = *(Q_col + i);
#line 545
      t = *(type + k);
#line 546
      if (t == 2) {
#line 546
        goto _L___2;
      } else
#line 546
      if (t == 3) {
#line 546
        goto _L___2;
      } else
#line 546
      if (t == 4) {
        _L___2: /* CIL Label */ 
        {
#line 548
        _glp_mpq_sub(temp, *(bbar + i), *(ub + k));
#line 549
        _glp_mpq_div(temp, temp, *(aq + i));
#line 550
        _glp_mpq_abs(temp, temp);
        }
#line 551
        if (p == 0) {
#line 551
          goto _L___1;
        } else {
          {
#line 551
          tmp___3 = _glp_mpq_cmp(teta, temp);
          }
#line 551
          if (tmp___3 > 0) {
            _L___1: /* CIL Label */ 
#line 552
            p = i;
#line 553
            if (t == 4) {
#line 553
              p_stat = 4;
            } else {
#line 553
              p_stat = 2;
            }
            {
#line 554
            _glp_mpq_set(teta, temp);
            }
          }
        }
      }
    }
#line 560
    if (p != 0) {
      {
#line 560
      tmp___4 = _glp_mpq_sgn(teta);
      }
#line 560
      if (tmp___4 == 0) {
#line 560
        goto while_break;
      }
    }
#line 524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  k = *(Q_col + (m + q));
#line 565
  if (*(type + k) == 3) {
    {
#line 566
    _glp_mpq_sub(temp, *(ub + k), *(lb + k));
    }
#line 567
    if (p == 0) {
      {
#line 568
      p = -1;
#line 569
      p_stat = -1;
#line 570
      _glp_mpq_set(teta, temp);
      }
    } else {
      {
#line 567
      tmp___5 = _glp_mpq_cmp(teta, temp);
      }
#line 567
      if (tmp___5 > 0) {
        {
#line 568
        p = -1;
#line 569
        p_stat = -1;
#line 570
        _glp_mpq_set(teta, temp);
        }
      }
    }
  }
#line 573
  ssx->p = p;
#line 574
  ssx->p_stat = p_stat;
#line 577
  if (p != 0) {
    {
#line 578
    tmp___6 = _glp_mpq_sgn(teta);
    }
#line 578
    if (tmp___6 >= 0) {
#line 578
      tmp___7 = 1;
    } else {
      {
#line 578
      _glp_lib_xassert("mpq_sgn(teta) >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       578);
#line 578
      tmp___7 = 1;
      }
    }
#line 579
    if (q_dir > 0) {
      {
#line 580
      _glp_mpq_set(ssx->delta, teta);
      }
    } else {
      {
#line 582
      _glp_mpq_neg(ssx->delta, teta);
      }
    }
  }
  {
#line 584
  _glp_mpq_clear(teta);
#line 585
  _glp_mpq_clear(temp);
  }
#line 586
  return;
}
}
#line 615 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_update_bbar(SSX *ssx ) 
{ 
  int m ;
  int n ;
  mpq_t *bbar ;
  mpq_t *cbar ;
  int p ;
  int q ;
  mpq_t *aq ;
  int i ;
  mpq_t temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 616
  m = ssx->m;
#line 617
  n = ssx->n;
#line 618
  bbar = ssx->bbar;
#line 619
  cbar = ssx->cbar;
#line 620
  p = ssx->p;
#line 621
  q = ssx->q;
#line 622
  aq = ssx->aq;
#line 625
  temp = _glp_mpq_init();
  }
#line 626
  if (1 <= q) {
#line 626
    if (q <= n) {
#line 626
      tmp = 1;
    } else {
      {
#line 626
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       626);
#line 626
      tmp = 1;
      }
    }
  } else {
    {
#line 626
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     626);
#line 626
    tmp = 1;
    }
  }
#line 627
  if (! (p < 0)) {
#line 634
    if (1 <= p) {
#line 634
      if (p <= m) {
#line 634
        tmp___0 = 1;
      } else {
        {
#line 634
        _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                         634);
#line 634
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 634
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       634);
#line 634
      tmp___0 = 1;
      }
    }
    {
#line 635
    _glp_ssx_get_xNj(ssx, q, temp);
#line 636
    _glp_mpq_add(*(bbar + p), temp, ssx->delta);
    }
  }
#line 639
  i = 1;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (i <= m)) {
#line 639
      goto while_break;
    }
#line 640
    if (i == p) {
#line 640
      goto __Cont;
    }
    {
#line 642
    tmp___1 = _glp_mpq_sgn(*(aq + i));
    }
#line 642
    if (tmp___1 == 0) {
#line 642
      goto __Cont;
    }
    {
#line 643
    _glp_mpq_mul(temp, *(aq + i), ssx->delta);
#line 644
    _glp_mpq_add(*(bbar + i), *(bbar + i), temp);
    }
    __Cont: /* CIL Label */ 
#line 639
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 649
  _glp_mpq_mul(temp, *(cbar + q), ssx->delta);
#line 650
  _glp_mpq_add(*(bbar + 0), *(bbar + 0), temp);
#line 652
  _glp_mpq_clear(temp);
  }
#line 653
  return;
}
}
#line 662 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_update_pi(SSX *ssx ) 
{ 
  int m ;
  int n ;
  mpq_t *pi ;
  mpq_t *cbar ;
  int p ;
  int q ;
  mpq_t *aq ;
  mpq_t *rho ;
  int i ;
  mpq_t new_dq ;
  mpq_t temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 663
  m = ssx->m;
#line 664
  n = ssx->n;
#line 665
  pi = ssx->pi;
#line 666
  cbar = ssx->cbar;
#line 667
  p = ssx->p;
#line 668
  q = ssx->q;
#line 669
  aq = ssx->aq;
#line 670
  rho = ssx->rho;
#line 673
  new_dq = _glp_mpq_init();
#line 674
  temp = _glp_mpq_init();
  }
#line 675
  if (1 <= p) {
#line 675
    if (p <= m) {
#line 675
      tmp = 1;
    } else {
      {
#line 675
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       675);
#line 675
      tmp = 1;
      }
    }
  } else {
    {
#line 675
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     675);
#line 675
    tmp = 1;
    }
  }
#line 676
  if (1 <= q) {
#line 676
    if (q <= n) {
#line 676
      tmp___0 = 1;
    } else {
      {
#line 676
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       676);
#line 676
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 676
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     676);
#line 676
    tmp___0 = 1;
    }
  }
  {
#line 678
  _glp_mpq_div(new_dq, *(cbar + q), *(aq + p));
#line 680
  i = 1;
  }
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! (i <= m)) {
#line 680
      goto while_break;
    }
    {
#line 681
    tmp___1 = _glp_mpq_sgn(*(rho + i));
    }
#line 681
    if (tmp___1 == 0) {
#line 681
      goto __Cont;
    }
    {
#line 682
    _glp_mpq_mul(temp, new_dq, *(rho + i));
#line 683
    _glp_mpq_sub(*(pi + i), *(pi + i), temp);
    }
    __Cont: /* CIL Label */ 
#line 680
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  _glp_mpq_clear(new_dq);
#line 686
  _glp_mpq_clear(temp);
  }
#line 687
  return;
}
}
#line 696 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_update_cbar(SSX *ssx ) 
{ 
  int m ;
  int n ;
  mpq_t *cbar ;
  int p ;
  int q ;
  mpq_t *ap ;
  int j ;
  mpq_t temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 697
  m = ssx->m;
#line 698
  n = ssx->n;
#line 699
  cbar = ssx->cbar;
#line 700
  p = ssx->p;
#line 701
  q = ssx->q;
#line 702
  ap = ssx->ap;
#line 705
  temp = _glp_mpq_init();
  }
#line 706
  if (1 <= p) {
#line 706
    if (p <= m) {
#line 706
      tmp = 1;
    } else {
      {
#line 706
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       706);
#line 706
      tmp = 1;
      }
    }
  } else {
    {
#line 706
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     706);
#line 706
    tmp = 1;
    }
  }
#line 707
  if (1 <= q) {
#line 707
    if (q <= n) {
#line 707
      tmp___0 = 1;
    } else {
      {
#line 707
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       707);
#line 707
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 707
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                     707);
#line 707
    tmp___0 = 1;
    }
  }
  {
#line 710
  _glp_mpq_div(*(cbar + q), *(cbar + q), *(ap + q));
#line 712
  j = 1;
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! (j <= n)) {
#line 712
      goto while_break;
    }
#line 713
    if (j == q) {
#line 713
      goto __Cont;
    }
    {
#line 715
    tmp___1 = _glp_mpq_sgn(*(ap + j));
    }
#line 715
    if (tmp___1 == 0) {
#line 715
      goto __Cont;
    }
    {
#line 716
    _glp_mpq_mul(temp, *(ap + j), *(cbar + q));
#line 717
    _glp_mpq_sub(*(cbar + j), *(cbar + j), temp);
    }
    __Cont: /* CIL Label */ 
#line 712
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 719
  _glp_mpq_clear(temp);
  }
#line 720
  return;
}
}
#line 729 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_change_basis(SSX *ssx ) 
{ 
  int m ;
  int n ;
  int *type ;
  int *stat ;
  int *Q_row ;
  int *Q_col ;
  int p ;
  int q ;
  int p_stat ;
  int k ;
  int kp ;
  int kq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 730
  m = ssx->m;
#line 731
  n = ssx->n;
#line 732
  type = ssx->type;
#line 733
  stat = ssx->stat;
#line 734
  Q_row = ssx->Q_row;
#line 735
  Q_col = ssx->Q_col;
#line 736
  p = ssx->p;
#line 737
  q = ssx->q;
#line 738
  p_stat = ssx->p_stat;
#line 740
  if (p < 0) {
#line 742
    if (1 <= q) {
#line 742
      if (q <= n) {
#line 742
        tmp = 1;
      } else {
        {
#line 742
        _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                         742);
#line 742
        tmp = 1;
        }
      }
    } else {
      {
#line 742
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       742);
#line 742
      tmp = 1;
      }
    }
#line 743
    k = *(Q_col + (m + q));
#line 744
    if (*(type + k) == 3) {
#line 744
      tmp___0 = 1;
    } else {
      {
#line 744
      _glp_lib_xassert("type[k] == SSX_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       744);
#line 744
      tmp___0 = 1;
      }
    }
    {
#line 746
    if (*(stat + k) == 1) {
#line 746
      goto case_1;
    }
#line 749
    if (*(stat + k) == 2) {
#line 749
      goto case_2;
    }
#line 752
    goto switch_default;
    case_1: /* CIL Label */ 
#line 747
    *(stat + k) = 2;
#line 748
    goto switch_break;
    case_2: /* CIL Label */ 
#line 750
    *(stat + k) = 1;
#line 751
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 753
    if ((unsigned long )stat != (unsigned long )stat) {
#line 753
      tmp___1 = 1;
    } else {
      {
#line 753
      _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       753);
#line 753
      tmp___1 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 758
    if (1 <= p) {
#line 758
      if (p <= m) {
#line 758
        tmp___2 = 1;
      } else {
        {
#line 758
        _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                         758);
#line 758
        tmp___2 = 1;
        }
      }
    } else {
      {
#line 758
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       758);
#line 758
      tmp___2 = 1;
      }
    }
#line 759
    if (1 <= q) {
#line 759
      if (q <= n) {
#line 759
        tmp___3 = 1;
      } else {
        {
#line 759
        _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                         759);
#line 759
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 759
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       759);
#line 759
      tmp___3 = 1;
      }
    }
#line 760
    kp = *(Q_col + p);
#line 761
    kq = *(Q_col + (m + q));
    {
#line 764
    if (*(type + kp) == 0) {
#line 764
      goto case_0;
    }
#line 767
    if (*(type + kp) == 1) {
#line 767
      goto case_1___0;
    }
#line 770
    if (*(type + kp) == 2) {
#line 770
      goto case_2___0;
    }
#line 773
    if (*(type + kp) == 3) {
#line 773
      goto case_3;
    }
#line 776
    if (*(type + kp) == 4) {
#line 776
      goto case_4;
    }
#line 779
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 765
    if (p_stat == 3) {
#line 765
      tmp___4 = 1;
    } else {
      {
#line 765
      _glp_lib_xassert("p_stat == SSX_NF", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       765);
#line 765
      tmp___4 = 1;
      }
    }
#line 766
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 768
    if (p_stat == 1) {
#line 768
      tmp___5 = 1;
    } else {
      {
#line 768
      _glp_lib_xassert("p_stat == SSX_NL", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       768);
#line 768
      tmp___5 = 1;
      }
    }
#line 769
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 771
    if (p_stat == 2) {
#line 771
      tmp___6 = 1;
    } else {
      {
#line 771
      _glp_lib_xassert("p_stat == SSX_NU", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       771);
#line 771
      tmp___6 = 1;
      }
    }
#line 772
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 774
    if (p_stat == 1) {
#line 774
      tmp___7 = 1;
    } else
#line 774
    if (p_stat == 2) {
#line 774
      tmp___7 = 1;
    } else {
      {
#line 774
      _glp_lib_xassert("p_stat == SSX_NL || p_stat == SSX_NU", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       774);
#line 774
      tmp___7 = 1;
      }
    }
#line 775
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 777
    if (p_stat == 4) {
#line 777
      tmp___8 = 1;
    } else {
      {
#line 777
      _glp_lib_xassert("p_stat == SSX_NS", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       777);
#line 777
      tmp___8 = 1;
      }
    }
#line 778
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 780
    if ((unsigned long )type != (unsigned long )type) {
#line 780
      tmp___9 = 1;
    } else {
      {
#line 780
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                       780);
#line 780
      tmp___9 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 783
    *(stat + kp) = (int )((char )p_stat);
#line 783
    *(stat + kq) = 0;
#line 784
    *(Q_row + kp) = m + q;
#line 784
    *(Q_row + kq) = p;
#line 785
    *(Q_col + p) = kq;
#line 785
    *(Q_col + (m + q)) = kp;
#line 787
    tmp___11 = _glp_bfx_update(ssx->binv, p);
    }
#line 787
    if (tmp___11) {
      {
#line 788
      tmp___10 = _glp_ssx_factorize(ssx);
      }
#line 788
      if (tmp___10) {
        {
#line 789
        _glp_lib_xassert("(\"Internal error: basis matrix is singular\", 0)", "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c",
                         789);
        }
      }
    }
  }
#line 792
  return;
}
}
#line 801 "/home/wslee/benchmarks/glpk-4.38/src/glpssx01.c"
void _glp_ssx_delete(SSX *ssx ) 
{ 
  int m ;
  int n ;
  int nnz ;
  int i ;
  int j ;
  int k ;

  {
  {
#line 802
  m = ssx->m;
#line 803
  n = ssx->n;
#line 804
  nnz = *(ssx->A_ptr + (n + 1)) - 1;
#line 806
  _glp_lib_xfree((void *)ssx->type);
#line 807
  k = 1;
  }
  {
#line 807
  while (1) {
    while_continue: /* CIL Label */ ;
#line 807
    if (! (k <= m + n)) {
#line 807
      goto while_break;
    }
    {
#line 807
    _glp_mpq_clear(*(ssx->lb + k));
#line 807
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 808
  _glp_lib_xfree((void *)ssx->lb);
#line 809
  k = 1;
  }
  {
#line 809
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 809
    if (! (k <= m + n)) {
#line 809
      goto while_break___0;
    }
    {
#line 809
    _glp_mpq_clear(*(ssx->ub + k));
#line 809
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 810
  _glp_lib_xfree((void *)ssx->ub);
#line 811
  k = 0;
  }
  {
#line 811
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 811
    if (! (k <= m + n)) {
#line 811
      goto while_break___1;
    }
    {
#line 811
    _glp_mpq_clear(*(ssx->coef + k));
#line 811
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 812
  _glp_lib_xfree((void *)ssx->coef);
#line 813
  _glp_lib_xfree((void *)ssx->A_ptr);
#line 814
  _glp_lib_xfree((void *)ssx->A_ind);
#line 815
  k = 1;
  }
  {
#line 815
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 815
    if (! (k <= nnz)) {
#line 815
      goto while_break___2;
    }
    {
#line 815
    _glp_mpq_clear(*(ssx->A_val + k));
#line 815
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 816
  _glp_lib_xfree((void *)ssx->A_val);
#line 817
  _glp_lib_xfree((void *)ssx->stat);
#line 818
  _glp_lib_xfree((void *)ssx->Q_row);
#line 819
  _glp_lib_xfree((void *)ssx->Q_col);
#line 820
  _glp_bfx_delete_binv(ssx->binv);
#line 821
  i = 0;
  }
  {
#line 821
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 821
    if (! (i <= m)) {
#line 821
      goto while_break___3;
    }
    {
#line 821
    _glp_mpq_clear(*(ssx->bbar + i));
#line 821
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 822
  _glp_lib_xfree((void *)ssx->bbar);
#line 823
  i = 1;
  }
  {
#line 823
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 823
    if (! (i <= m)) {
#line 823
      goto while_break___4;
    }
    {
#line 823
    _glp_mpq_clear(*(ssx->pi + i));
#line 823
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 824
  _glp_lib_xfree((void *)ssx->pi);
#line 825
  j = 1;
  }
  {
#line 825
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 825
    if (! (j <= n)) {
#line 825
      goto while_break___5;
    }
    {
#line 825
    _glp_mpq_clear(*(ssx->cbar + j));
#line 825
    j ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 826
  _glp_lib_xfree((void *)ssx->cbar);
#line 827
  i = 1;
  }
  {
#line 827
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 827
    if (! (i <= m)) {
#line 827
      goto while_break___6;
    }
    {
#line 827
    _glp_mpq_clear(*(ssx->rho + i));
#line 827
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 828
  _glp_lib_xfree((void *)ssx->rho);
#line 829
  j = 1;
  }
  {
#line 829
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 829
    if (! (j <= n)) {
#line 829
      goto while_break___7;
    }
    {
#line 829
    _glp_mpq_clear(*(ssx->ap + j));
#line 829
    j ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 830
  _glp_lib_xfree((void *)ssx->ap);
#line 831
  i = 1;
  }
  {
#line 831
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 831
    if (! (i <= m)) {
#line 831
      goto while_break___8;
    }
    {
#line 831
    _glp_mpq_clear(*(ssx->aq + i));
#line 831
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 832
  _glp_lib_xfree((void *)ssx->aq);
#line 833
  _glp_mpq_clear(ssx->delta);
#line 834
  _glp_lib_xfree((void *)ssx);
  }
#line 835
  return;
}
}
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.h"
void *_glp_db_iodbc_open(TABDCA *dca , int mode ) ;
#line 34
int _glp_db_iodbc_read(TABDCA *dca , void *link ) ;
#line 38
int _glp_db_iodbc_write(TABDCA *dca , void *link ) ;
#line 42
int _glp_db_iodbc_close(TABDCA *dca , void *link ) ;
#line 46
void *_glp_db_mysql_open(TABDCA *dca , int mode ) ;
#line 50
int _glp_db_mysql_read(TABDCA *dca , void *link ) ;
#line 54
int _glp_db_mysql_write(TABDCA *dca , void *link ) ;
#line 58
int _glp_db_mysql_close(TABDCA *dca , void *link ) ;
#line 194 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
void *_glp_db_iodbc_open(TABDCA *dca , int mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 195
  if ((unsigned long )dca == (unsigned long )dca) {
#line 195
    tmp = 1;
  } else {
    {
#line 195
    _glp_lib_xassert("dca == dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     195);
#line 195
    tmp = 1;
    }
  }
#line 196
  if (mode == mode) {
#line 196
    tmp___0 = 1;
  } else {
    {
#line 196
    _glp_lib_xassert("mode == mode", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     196);
#line 196
    tmp___0 = 1;
    }
  }
  {
#line 197
  _glp_lib_xprintf("iODBC table driver not supported\n");
  }
#line 198
  return ((void *)0);
}
}
#line 201 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
int _glp_db_iodbc_read(TABDCA *dca , void *link ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 202
  if ((unsigned long )dca != (unsigned long )dca) {
#line 202
    tmp = 1;
  } else {
    {
#line 202
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     202);
#line 202
    tmp = 1;
    }
  }
#line 203
  if ((unsigned long )link != (unsigned long )link) {
#line 203
    tmp___0 = 1;
  } else {
    {
#line 203
    _glp_lib_xassert("link != link", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     203);
#line 203
    tmp___0 = 1;
    }
  }
#line 204
  return (0);
}
}
#line 207 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
int _glp_db_iodbc_write(TABDCA *dca , void *link ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 208
  if ((unsigned long )dca != (unsigned long )dca) {
#line 208
    tmp = 1;
  } else {
    {
#line 208
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     208);
#line 208
    tmp = 1;
    }
  }
#line 209
  if ((unsigned long )link != (unsigned long )link) {
#line 209
    tmp___0 = 1;
  } else {
    {
#line 209
    _glp_lib_xassert("link != link", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     209);
#line 209
    tmp___0 = 1;
    }
  }
#line 210
  return (0);
}
}
#line 213 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
int _glp_db_iodbc_close(TABDCA *dca , void *link ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 214
  if ((unsigned long )dca != (unsigned long )dca) {
#line 214
    tmp = 1;
  } else {
    {
#line 214
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     214);
#line 214
    tmp = 1;
    }
  }
#line 215
  if ((unsigned long )link != (unsigned long )link) {
#line 215
    tmp___0 = 1;
  } else {
    {
#line 215
    _glp_lib_xassert("link != link", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     215);
#line 215
    tmp___0 = 1;
    }
  }
#line 216
  return (0);
}
}
#line 917 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
void *_glp_db_mysql_open(TABDCA *dca , int mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 918
  if ((unsigned long )dca == (unsigned long )dca) {
#line 918
    tmp = 1;
  } else {
    {
#line 918
    _glp_lib_xassert("dca == dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     918);
#line 918
    tmp = 1;
    }
  }
#line 919
  if (mode == mode) {
#line 919
    tmp___0 = 1;
  } else {
    {
#line 919
    _glp_lib_xassert("mode == mode", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     919);
#line 919
    tmp___0 = 1;
    }
  }
  {
#line 920
  _glp_lib_xprintf("MySQL table driver not supported\n");
  }
#line 921
  return ((void *)0);
}
}
#line 924 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
int _glp_db_mysql_read(TABDCA *dca , void *link ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 925
  if ((unsigned long )dca != (unsigned long )dca) {
#line 925
    tmp = 1;
  } else {
    {
#line 925
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     925);
#line 925
    tmp = 1;
    }
  }
#line 926
  if ((unsigned long )link != (unsigned long )link) {
#line 926
    tmp___0 = 1;
  } else {
    {
#line 926
    _glp_lib_xassert("link != link", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     926);
#line 926
    tmp___0 = 1;
    }
  }
#line 927
  return (0);
}
}
#line 930 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
int _glp_db_mysql_write(TABDCA *dca , void *link ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 931
  if ((unsigned long )dca != (unsigned long )dca) {
#line 931
    tmp = 1;
  } else {
    {
#line 931
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     931);
#line 931
    tmp = 1;
    }
  }
#line 932
  if ((unsigned long )link != (unsigned long )link) {
#line 932
    tmp___0 = 1;
  } else {
    {
#line 932
    _glp_lib_xassert("link != link", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     932);
#line 932
    tmp___0 = 1;
    }
  }
#line 933
  return (0);
}
}
#line 936 "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c"
int _glp_db_mysql_close(TABDCA *dca , void *link ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 937
  if ((unsigned long )dca != (unsigned long )dca) {
#line 937
    tmp = 1;
  } else {
    {
#line 937
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     937);
#line 937
    tmp = 1;
    }
  }
#line 938
  if ((unsigned long )link != (unsigned long )link) {
#line 938
    tmp___0 = 1;
  } else {
    {
#line 938
    _glp_lib_xassert("link != link", "/home/wslee/benchmarks/glpk-4.38/src/glpsql.c",
                     938);
#line 938
    tmp___0 = 1;
    }
  }
#line 939
  return (0);
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 78 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.h"
extern int _glp_bfd_factorize(BFD *bfd , int m , int const   *bh , int (*col)(void *info ,
                                                                              int j ,
                                                                              int *ind ,
                                                                              double *val ) ,
                              void *info ) ;
#line 83
extern void _glp_bfd_ftran(BFD *bfd , double *x ) ;
#line 87
extern void _glp_bfd_btran(BFD *bfd , double *x ) ;
#line 91
extern int _glp_bfd_update_it(BFD *bfd , int j , int bh , int len , int const   *ind ,
                              double const   *val ) ;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpspx.h"
int _glp_spx_dual(glp_prob *lp , glp_smcp const   *parm ) ;
#line 288 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static double const   kappa  =    (double const   )0.10;
#line 296 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static struct csa *alloc_csa(glp_prob *lp ) 
{ 
  struct csa *csa ;
  int m ;
  int n ;
  int nnz ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 298
  m = lp->m;
#line 299
  n = lp->n;
#line 300
  nnz = lp->nnz;
#line 301
  tmp = _glp_lib_xmalloc((int )sizeof(struct csa ));
#line 301
  csa = (struct csa *)tmp;
  }
#line 302
  if (m > 0) {
#line 302
    if (n > 0) {
#line 302
      tmp___0 = 1;
    } else {
      {
#line 302
      _glp_lib_xassert("m > 0 && n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       302);
#line 302
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 302
    _glp_lib_xassert("m > 0 && n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     302);
#line 302
    tmp___0 = 1;
    }
  }
  {
#line 303
  csa->m = m;
#line 304
  csa->n = n;
#line 305
  tmp___1 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(char ));
#line 305
  csa->type = (char *)tmp___1;
#line 306
  tmp___2 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 306
  csa->lb = (double *)tmp___2;
#line 307
  tmp___3 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 307
  csa->ub = (double *)tmp___3;
#line 308
  tmp___4 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 308
  csa->coef = (double *)tmp___4;
#line 309
  tmp___5 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(char ));
#line 309
  csa->orig_type = (char *)tmp___5;
#line 310
  tmp___6 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 310
  csa->orig_lb = (double *)tmp___6;
#line 311
  tmp___7 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 311
  csa->orig_ub = (double *)tmp___7;
#line 312
  tmp___8 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 312
  csa->obj = (double *)tmp___8;
#line 313
  tmp___9 = _glp_lib_xcalloc((1 + n) + 1, (int )sizeof(int ));
#line 313
  csa->A_ptr = (int *)tmp___9;
#line 314
  tmp___10 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(int ));
#line 314
  csa->A_ind = (int *)tmp___10;
#line 315
  tmp___11 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(double ));
#line 315
  csa->A_val = (double *)tmp___11;
#line 317
  tmp___12 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 317
  csa->AT_ptr = (int *)tmp___12;
#line 318
  tmp___13 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(int ));
#line 318
  csa->AT_ind = (int *)tmp___13;
#line 319
  tmp___14 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(double ));
#line 319
  csa->AT_val = (double *)tmp___14;
#line 321
  tmp___15 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 321
  csa->head = (int *)tmp___15;
#line 323
  tmp___16 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 323
  csa->bind = (int *)tmp___16;
#line 325
  tmp___17 = _glp_lib_xcalloc(1 + n, (int )sizeof(char ));
#line 325
  csa->stat = (char *)tmp___17;
#line 332
  tmp___18 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 332
  csa->bbar = (double *)tmp___18;
#line 333
  tmp___19 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 333
  csa->cbar = (double *)tmp___19;
#line 334
  tmp___20 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(char ));
#line 334
  csa->refsp = (char *)tmp___20;
#line 335
  tmp___21 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 335
  csa->gamma = (double *)tmp___21;
#line 336
  tmp___22 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 336
  csa->trow_ind = (int *)tmp___22;
#line 337
  tmp___23 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 337
  csa->trow_vec = (double *)tmp___23;
#line 341
  tmp___24 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 341
  csa->tcol_ind = (int *)tmp___24;
#line 342
  tmp___25 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 342
  csa->tcol_vec = (double *)tmp___25;
#line 343
  tmp___26 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 343
  csa->work1 = (double *)tmp___26;
#line 344
  tmp___27 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 344
  csa->work2 = (double *)tmp___27;
#line 345
  tmp___28 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 345
  csa->work3 = (double *)tmp___28;
#line 346
  tmp___29 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 346
  csa->work4 = (double *)tmp___29;
  }
#line 347
  return (csa);
}
}
#line 356 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void init_csa(struct csa *csa , glp_prob *lp ) 
{ 
  int m ;
  int n ;
  char *type ;
  double *lb ;
  double *ub ;
  double *coef ;
  char *orig_type ;
  double *orig_lb ;
  double *orig_ub ;
  double *obj ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *AT_ptr ;
  int *AT_ind ;
  double *AT_val ;
  int *head ;
  int *bind ;
  char *stat ;
  char *refsp ;
  double *gamma___0 ;
  int i ;
  int j ;
  int k ;
  int loc ;
  double cmax ;
  GLPROW *row ;
  GLPCOL *col ;
  double tmp ;
  int tmp___0 ;
  double tmp___1 ;
  GLPAIJ *aij ;
  int tmp___2 ;
  GLPAIJ *aij___0 ;
  int tmp___3 ;
  int tmp___4 ;
  GLPROW *row___0 ;
  int tmp___5 ;
  GLPCOL *col___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 357
  m = csa->m;
#line 358
  n = csa->n;
#line 359
  type = csa->type;
#line 360
  lb = csa->lb;
#line 361
  ub = csa->ub;
#line 362
  coef = csa->coef;
#line 363
  orig_type = csa->orig_type;
#line 364
  orig_lb = csa->orig_lb;
#line 365
  orig_ub = csa->orig_ub;
#line 366
  obj = csa->obj;
#line 367
  A_ptr = csa->A_ptr;
#line 368
  A_ind = csa->A_ind;
#line 369
  A_val = csa->A_val;
#line 371
  AT_ptr = csa->AT_ptr;
#line 372
  AT_ind = csa->AT_ind;
#line 373
  AT_val = csa->AT_val;
#line 375
  head = csa->head;
#line 377
  bind = csa->bind;
#line 379
  stat = csa->stat;
#line 380
  refsp = csa->refsp;
#line 381
  gamma___0 = csa->gamma;
#line 385
  i = 1;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (i <= m)) {
#line 385
      goto while_break;
    }
#line 386
    row = *(lp->row + i);
#line 387
    *(type + i) = (char )row->type;
#line 388
    *(lb + i) = row->lb * row->rii;
#line 389
    *(ub + i) = row->ub * row->rii;
#line 390
    *(coef + i) = 0.0;
#line 385
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  j = 1;
  {
#line 393
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 393
    if (! (j <= n)) {
#line 393
      goto while_break___0;
    }
#line 394
    col = *(lp->col + j);
#line 395
    *(type + (m + j)) = (char )col->type;
#line 396
    *(lb + (m + j)) = col->lb / col->sjj;
#line 397
    *(ub + (m + j)) = col->ub / col->sjj;
#line 398
    *(coef + (m + j)) = col->coef * col->sjj;
#line 393
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  memcpy((void */* __restrict  */)(orig_type + 1), (void const   */* __restrict  */)(type + 1),
         (size_t )((unsigned long )(m + n) * sizeof(char )));
#line 402
  memcpy((void */* __restrict  */)(orig_lb + 1), (void const   */* __restrict  */)(lb + 1),
         (size_t )((unsigned long )(m + n) * sizeof(double )));
#line 403
  memcpy((void */* __restrict  */)(orig_ub + 1), (void const   */* __restrict  */)(ub + 1),
         (size_t )((unsigned long )(m + n) * sizeof(double )));
#line 405
  *(obj + 0) = lp->c0;
#line 406
  memcpy((void */* __restrict  */)(obj + 1), (void const   */* __restrict  */)(coef + (m + 1)),
         (size_t )((unsigned long )n * sizeof(double )));
#line 408
  cmax = 0.0;
#line 409
  j = 1;
  }
  {
#line 409
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 409
    if (! (j <= n)) {
#line 409
      goto while_break___1;
    }
    {
#line 410
    tmp = fabs(*(obj + j));
    }
#line 410
    if (cmax < tmp) {
      {
#line 410
      cmax = fabs(*(obj + j));
      }
    }
#line 409
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 411
  if (cmax == 0.0) {
#line 411
    cmax = 1.0;
  }
  {
#line 413
  if (lp->dir == 1) {
#line 413
    goto case_1;
  }
#line 416
  if (lp->dir == 2) {
#line 416
    goto case_2;
  }
#line 419
  goto switch_default;
  case_1: /* CIL Label */ 
#line 414
  csa->zeta = 1.0 / cmax;
#line 415
  goto switch_break;
  case_2: /* CIL Label */ 
#line 417
  csa->zeta = - 1.0 / cmax;
#line 418
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 420
  if ((unsigned long )lp != (unsigned long )lp) {
#line 420
    tmp___0 = 1;
  } else {
    {
#line 420
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     420);
#line 420
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 423
  tmp___1 = fabs(csa->zeta);
  }
#line 423
  if (tmp___1 < 1.0) {
#line 423
    csa->zeta *= 1000.0;
  }
#line 426
  j = 1;
  {
#line 426
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 426
    if (! (j <= n)) {
#line 426
      goto while_break___2;
    }
#line 426
    *(coef + (m + j)) *= csa->zeta;
#line 426
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 428
  loc = 1;
#line 429
  j = 1;
  {
#line 429
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 429
    if (! (j <= n)) {
#line 429
      goto while_break___3;
    }
#line 431
    *(A_ptr + j) = loc;
#line 432
    aij = (*(lp->col + j))->ptr;
    {
#line 432
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 432
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 432
        goto while_break___4;
      }
#line 433
      *(A_ind + loc) = (aij->row)->i;
#line 434
      *(A_val + loc) = ((aij->row)->rii * aij->val) * (aij->col)->sjj;
#line 435
      loc ++;
#line 432
      aij = aij->c_next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 429
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 438
  *(A_ptr + (n + 1)) = loc;
#line 439
  if (loc - 1 == lp->nnz) {
#line 439
    tmp___2 = 1;
  } else {
    {
#line 439
    _glp_lib_xassert("loc-1 == lp->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     439);
#line 439
    tmp___2 = 1;
    }
  }
#line 442
  loc = 1;
#line 443
  i = 1;
  {
#line 443
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 443
    if (! (i <= m)) {
#line 443
      goto while_break___5;
    }
#line 445
    *(AT_ptr + i) = loc;
#line 446
    aij___0 = (*(lp->row + i))->ptr;
    {
#line 446
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 446
      if (! ((unsigned long )aij___0 != (unsigned long )((void *)0))) {
#line 446
        goto while_break___6;
      }
#line 447
      *(AT_ind + loc) = (aij___0->col)->j;
#line 448
      *(AT_val + loc) = ((aij___0->row)->rii * aij___0->val) * (aij___0->col)->sjj;
#line 449
      loc ++;
#line 446
      aij___0 = aij___0->r_next;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 443
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 452
  *(AT_ptr + (m + 1)) = loc;
#line 453
  if (loc - 1 == lp->nnz) {
#line 453
    tmp___3 = 1;
  } else {
    {
#line 453
    _glp_lib_xassert("loc-1 == lp->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     453);
#line 453
    tmp___3 = 1;
    }
  }
#line 456
  if (lp->valid) {
#line 456
    tmp___4 = 1;
  } else {
    {
#line 456
    _glp_lib_xassert("lp->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     456);
#line 456
    tmp___4 = 1;
    }
  }
  {
#line 457
  memcpy((void */* __restrict  */)(head + 1), (void const   */* __restrict  */)(lp->head + 1),
         (size_t )((unsigned long )m * sizeof(int )));
#line 458
  k = 0;
#line 459
  i = 1;
  }
  {
#line 459
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 459
    if (! (i <= m)) {
#line 459
      goto while_break___7;
    }
#line 460
    row___0 = *(lp->row + i);
#line 461
    if (row___0->stat != 1) {
#line 462
      k ++;
#line 463
      if (k <= n) {
#line 463
        tmp___5 = 1;
      } else {
        {
#line 463
        _glp_lib_xassert("k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         463);
#line 463
        tmp___5 = 1;
        }
      }
#line 464
      *(head + (m + k)) = i;
#line 465
      *(stat + k) = (char )row___0->stat;
    }
#line 459
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 468
  j = 1;
  {
#line 468
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 468
    if (! (j <= n)) {
#line 468
      goto while_break___8;
    }
#line 469
    col___0 = *(lp->col + j);
#line 470
    if (col___0->stat != 1) {
#line 471
      k ++;
#line 472
      if (k <= n) {
#line 472
        tmp___6 = 1;
      } else {
        {
#line 472
        _glp_lib_xassert("k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         472);
#line 472
        tmp___6 = 1;
        }
      }
#line 473
      *(head + (m + k)) = m + j;
#line 474
      *(stat + k) = (char )col___0->stat;
    }
#line 468
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 477
  if (k == n) {
#line 477
    tmp___7 = 1;
  } else {
    {
#line 477
    _glp_lib_xassert("k == n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     477);
#line 477
    tmp___7 = 1;
    }
  }
#line 479
  k = 1;
  {
#line 479
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 479
    if (! (k <= m + n)) {
#line 479
      goto while_break___9;
    }
#line 480
    *(bind + *(head + k)) = k;
#line 479
    k ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 483
  csa->valid = 1;
#line 483
  lp->valid = 0;
#line 484
  csa->bfd = lp->bfd;
#line 484
  lp->bfd = (BFD *)((void *)0);
#line 491
  csa->phase = 0;
#line 492
  csa->tm_beg = _glp_lib_xtime();
#line 493
  tmp___8 = lp->it_cnt;
#line 493
  csa->it_cnt = tmp___8;
#line 493
  csa->it_beg = tmp___8;
#line 494
  csa->it_dpy = -1;
#line 496
  csa->refct = 0;
#line 497
  memset((void *)(refsp + 1), 0, (size_t )((unsigned long )(m + n) * sizeof(char )));
#line 498
  i = 1;
  }
  {
#line 498
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 498
    if (! (i <= m)) {
#line 498
      goto while_break___10;
    }
#line 498
    *(gamma___0 + i) = 1.0;
#line 498
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 499
  return;
}
}
#line 511 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static int inv_col(void *info , int i , int *ind , double *val ) 
{ 
  struct csa *csa ;
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  int k ;
  int len ;
  int ptr ;
  int t ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 514
  csa = (struct csa *)info;
#line 515
  m = csa->m;
#line 517
  n = csa->n;
#line 519
  A_ptr = csa->A_ptr;
#line 520
  A_ind = csa->A_ind;
#line 521
  A_val = csa->A_val;
#line 522
  head = csa->head;
#line 525
  if (1 <= i) {
#line 525
    if (i <= m) {
#line 525
      tmp = 1;
    } else {
      {
#line 525
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       525);
#line 525
      tmp = 1;
      }
    }
  } else {
    {
#line 525
    _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     525);
#line 525
    tmp = 1;
    }
  }
#line 527
  k = *(head + i);
#line 529
  if (1 <= k) {
#line 529
    if (k <= m + n) {
#line 529
      tmp___0 = 1;
    } else {
      {
#line 529
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       529);
#line 529
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 529
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     529);
#line 529
    tmp___0 = 1;
    }
  }
#line 531
  if (k <= m) {
#line 533
    len = 1;
#line 534
    *(ind + 1) = k;
#line 535
    *(val + 1) = 1.0;
  } else {
    {
#line 539
    ptr = *(A_ptr + (k - m));
#line 540
    len = *(A_ptr + ((k - m) + 1)) - ptr;
#line 541
    memcpy((void */* __restrict  */)(ind + 1), (void const   */* __restrict  */)(A_ind + ptr),
           (size_t )((unsigned long )len * sizeof(int )));
#line 542
    memcpy((void */* __restrict  */)(val + 1), (void const   */* __restrict  */)(A_val + ptr),
           (size_t )((unsigned long )len * sizeof(double )));
#line 543
    t = 1;
    }
    {
#line 543
    while (1) {
      while_continue: /* CIL Label */ ;
#line 543
      if (! (t <= len)) {
#line 543
        goto while_break;
      }
#line 543
      *(val + t) = - *(val + t);
#line 543
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 545
  return (len);
}
}
#line 548 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static int invert_B(struct csa *csa ) 
{ 
  int ret ;

  {
  {
#line 550
  ret = _glp_bfd_factorize(csa->bfd, csa->m, (int const   *)((void *)0), & inv_col,
                           (void *)csa);
#line 551
  csa->valid = ret == 0;
  }
#line 552
  return (ret);
}
}
#line 567 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static int update_B(struct csa *csa , int i , int k ) 
{ 
  int m ;
  int n ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int ind[2] ;
  double val[2] ;
  int tmp___1 ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  double *val___0 ;
  int beg ;
  int end ;
  int ptr ;
  int len ;
  int tmp___2 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 568
  m = csa->m;
#line 570
  n = csa->n;
#line 574
  if (1 <= i) {
#line 574
    if (i <= m) {
#line 574
      tmp = 1;
    } else {
      {
#line 574
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       574);
#line 574
      tmp = 1;
      }
    }
  } else {
    {
#line 574
    _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     574);
#line 574
    tmp = 1;
    }
  }
#line 575
  if (1 <= k) {
#line 575
    if (k <= m + n) {
#line 575
      tmp___0 = 1;
    } else {
      {
#line 575
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       575);
#line 575
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 575
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     575);
#line 575
    tmp___0 = 1;
    }
  }
#line 577
  if (k <= m) {
#line 581
    ind[1] = k;
#line 582
    val[1] = 1.0;
#line 583
    if (csa->valid) {
#line 583
      tmp___1 = 1;
    } else {
      {
#line 583
      _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       583);
#line 583
      tmp___1 = 1;
      }
    }
    {
#line 584
    ret = _glp_bfd_update_it(csa->bfd, i, 0, 1, (int const   *)(ind), (double const   *)(val));
    }
  } else {
#line 588
    A_ptr = csa->A_ptr;
#line 589
    A_ind = csa->A_ind;
#line 590
    A_val = csa->A_val;
#line 591
    val___0 = csa->work1;
#line 593
    beg = *(A_ptr + (k - m));
#line 594
    end = *(A_ptr + ((k - m) + 1));
#line 595
    len = 0;
#line 596
    ptr = beg;
    {
#line 596
    while (1) {
      while_continue: /* CIL Label */ ;
#line 596
      if (! (ptr < end)) {
#line 596
        goto while_break;
      }
#line 597
      len ++;
#line 597
      *(val___0 + len) = - *(A_val + ptr);
#line 596
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 598
    if (csa->valid) {
#line 598
      tmp___2 = 1;
    } else {
      {
#line 598
      _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       598);
#line 598
      tmp___2 = 1;
      }
    }
    {
#line 599
    ret = _glp_bfd_update_it(csa->bfd, i, 0, len, (int const   *)(A_ind + (beg - 1)),
                             (double const   *)val___0);
    }
  }
#line 601
  csa->valid = ret == 0;
#line 602
  return (ret);
}
}
#line 614 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void error_ftran(struct csa *csa , double *h , double *x , double *r ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  int i ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;
  int tmp ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 616
  m = csa->m;
#line 618
  n = csa->n;
#line 620
  A_ptr = csa->A_ptr;
#line 621
  A_ind = csa->A_ind;
#line 622
  A_val = csa->A_val;
#line 623
  head = csa->head;
#line 629
  memcpy((void */* __restrict  */)(r + 1), (void const   */* __restrict  */)(h + 1),
         (size_t )((unsigned long )m * sizeof(double )));
#line 630
  i = 1;
  }
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i <= m)) {
#line 630
      goto while_break;
    }
#line 631
    temp = *(x + i);
#line 632
    if (temp == 0.0) {
#line 632
      goto __Cont;
    }
#line 633
    k = *(head + i);
#line 635
    if (1 <= k) {
#line 635
      if (k <= m + n) {
#line 635
        tmp = 1;
      } else {
        {
#line 635
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         635);
#line 635
        tmp = 1;
        }
      }
    } else {
      {
#line 635
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       635);
#line 635
      tmp = 1;
      }
    }
#line 637
    if (k <= m) {
#line 639
      *(r + k) -= temp;
    } else {
#line 643
      beg = *(A_ptr + (k - m));
#line 644
      end = *(A_ptr + ((k - m) + 1));
#line 645
      ptr = beg;
      {
#line 645
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 645
        if (! (ptr < end)) {
#line 645
          goto while_break___0;
        }
#line 646
        *(r + *(A_ind + ptr)) += *(A_val + ptr) * temp;
#line 645
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 630
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return;
}
}
#line 661 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void refine_ftran(struct csa *csa , double *h , double *x ) 
{ 
  int m ;
  double *r ;
  double *d___0 ;
  int i ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 662
  m = csa->m;
#line 663
  r = csa->work1;
#line 664
  d___0 = csa->work1;
#line 667
  error_ftran(csa, h, x, r);
  }
#line 669
  if (csa->valid) {
#line 669
    tmp = 1;
  } else {
    {
#line 669
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     669);
#line 669
    tmp = 1;
    }
  }
  {
#line 670
  _glp_bfd_ftran(csa->bfd, d___0);
#line 672
  i = 1;
  }
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (i <= m)) {
#line 672
      goto while_break;
    }
#line 672
    *(x + i) += *(d___0 + i);
#line 672
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  return;
}
}
#line 685 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void error_btran(struct csa *csa , double *h , double *x , double *r ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  int i ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;
  int tmp ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 687
  m = csa->m;
#line 689
  n = csa->n;
#line 691
  A_ptr = csa->A_ptr;
#line 692
  A_ind = csa->A_ind;
#line 693
  A_val = csa->A_val;
#line 694
  head = csa->head;
#line 698
  i = 1;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (i <= m)) {
#line 698
      goto while_break;
    }
#line 700
    k = *(head + i);
#line 702
    if (1 <= k) {
#line 702
      if (k <= m + n) {
#line 702
        tmp = 1;
      } else {
        {
#line 702
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         702);
#line 702
        tmp = 1;
        }
      }
    } else {
      {
#line 702
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       702);
#line 702
      tmp = 1;
      }
    }
#line 704
    temp = *(h + i);
#line 705
    if (k <= m) {
#line 707
      temp -= *(x + k);
    } else {
#line 711
      beg = *(A_ptr + (k - m));
#line 712
      end = *(A_ptr + ((k - m) + 1));
#line 713
      ptr = beg;
      {
#line 713
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 713
        if (! (ptr < end)) {
#line 713
          goto while_break___0;
        }
#line 714
        temp += *(A_val + ptr) * *(x + *(A_ind + ptr));
#line 713
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 716
    *(r + i) = temp;
#line 698
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 718
  return;
}
}
#line 731 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void refine_btran(struct csa *csa , double *h , double *x ) 
{ 
  int m ;
  double *r ;
  double *d___0 ;
  int i ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 732
  m = csa->m;
#line 733
  r = csa->work1;
#line 734
  d___0 = csa->work1;
#line 737
  error_btran(csa, h, x, r);
  }
#line 739
  if (csa->valid) {
#line 739
    tmp = 1;
  } else {
    {
#line 739
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     739);
#line 739
    tmp = 1;
    }
  }
  {
#line 740
  _glp_bfd_btran(csa->bfd, d___0);
#line 742
  i = 1;
  }
  {
#line 742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 742
    if (! (i <= m)) {
#line 742
      goto while_break;
    }
#line 742
    *(x + i) += *(d___0 + i);
#line 742
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  return;
}
}
#line 754 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static double get_xN(struct csa *csa , int j ) 
{ 
  int m ;
  int n ;
  double *lb ;
  double *ub ;
  int *head ;
  char *stat ;
  int k ;
  double xN ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 755
  m = csa->m;
#line 757
  n = csa->n;
#line 759
  lb = csa->lb;
#line 760
  ub = csa->ub;
#line 761
  head = csa->head;
#line 762
  stat = csa->stat;
#line 766
  if (1 <= j) {
#line 766
    if (j <= n) {
#line 766
      tmp = 1;
    } else {
      {
#line 766
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       766);
#line 766
      tmp = 1;
      }
    }
  } else {
    {
#line 766
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     766);
#line 766
    tmp = 1;
    }
  }
#line 768
  k = *(head + (m + j));
#line 770
  if (1 <= k) {
#line 770
    if (k <= m + n) {
#line 770
      tmp___0 = 1;
    } else {
      {
#line 770
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       770);
#line 770
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 770
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     770);
#line 770
    tmp___0 = 1;
    }
  }
  {
#line 773
  if ((int )*(stat + j) == 2) {
#line 773
    goto case_2;
  }
#line 776
  if ((int )*(stat + j) == 3) {
#line 776
    goto case_3;
  }
#line 779
  if ((int )*(stat + j) == 4) {
#line 779
    goto case_4;
  }
#line 782
  if ((int )*(stat + j) == 5) {
#line 782
    goto case_5;
  }
#line 785
  goto switch_default;
  case_2: /* CIL Label */ 
#line 775
  xN = *(lb + k);
#line 775
  goto switch_break;
  case_3: /* CIL Label */ 
#line 778
  xN = *(ub + k);
#line 778
  goto switch_break;
  case_4: /* CIL Label */ 
#line 781
  xN = 0.0;
#line 781
  goto switch_break;
  case_5: /* CIL Label */ 
#line 784
  xN = *(lb + k);
#line 784
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 786
  if ((unsigned long )stat != (unsigned long )stat) {
#line 786
    tmp___1 = 1;
  } else {
    {
#line 786
    _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     786);
#line 786
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 788
  return (xN);
}
}
#line 804 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_beta(struct csa *csa , double *beta ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  double *h ;
  int i ;
  int j ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double xN ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 805
  m = csa->m;
#line 806
  n = csa->n;
#line 807
  A_ptr = csa->A_ptr;
#line 808
  A_ind = csa->A_ind;
#line 809
  A_val = csa->A_val;
#line 810
  head = csa->head;
#line 811
  h = csa->work2;
#line 817
  i = 1;
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 817
    if (! (i <= m)) {
#line 817
      goto while_break;
    }
#line 818
    *(h + i) = 0.0;
#line 817
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  j = 1;
  {
#line 819
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 819
    if (! (j <= n)) {
#line 819
      goto while_break___0;
    }
#line 820
    k = *(head + (m + j));
#line 822
    if (1 <= k) {
#line 822
      if (k <= m + n) {
#line 822
        tmp = 1;
      } else {
        {
#line 822
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         822);
#line 822
        tmp = 1;
        }
      }
    } else {
      {
#line 822
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       822);
#line 822
      tmp = 1;
      }
    }
    {
#line 825
    xN = get_xN(csa, j);
    }
#line 826
    if (xN == 0.0) {
#line 826
      goto __Cont;
    }
#line 827
    if (k <= m) {
#line 829
      *(h + k) -= xN;
    } else {
#line 833
      beg = *(A_ptr + (k - m));
#line 834
      end = *(A_ptr + ((k - m) + 1));
#line 835
      ptr = beg;
      {
#line 835
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 835
        if (! (ptr < end)) {
#line 835
          goto while_break___1;
        }
#line 836
        *(h + *(A_ind + ptr)) += xN * *(A_val + ptr);
#line 835
        ptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 819
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 840
  memcpy((void */* __restrict  */)(beta + 1), (void const   */* __restrict  */)(h + 1),
         (size_t )((unsigned long )m * sizeof(double )));
  }
#line 841
  if (csa->valid) {
#line 841
    tmp___0 = 1;
  } else {
    {
#line 841
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     841);
#line 841
    tmp___0 = 1;
    }
  }
  {
#line 842
  _glp_bfd_ftran(csa->bfd, beta);
#line 844
  refine_ftran(csa, h, beta);
  }
#line 845
  return;
}
}
#line 860 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_pi(struct csa *csa , double *pi ) 
{ 
  int m ;
  double *c ;
  int *head ;
  double *cB ;
  int i ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 861
  m = csa->m;
#line 862
  c = csa->coef;
#line 863
  head = csa->head;
#line 864
  cB = csa->work2;
#line 867
  i = 1;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! (i <= m)) {
#line 867
      goto while_break;
    }
#line 868
    *(cB + i) = *(c + *(head + i));
#line 867
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 870
  memcpy((void */* __restrict  */)(pi + 1), (void const   */* __restrict  */)(cB + 1),
         (size_t )((unsigned long )m * sizeof(double )));
  }
#line 871
  if (csa->valid) {
#line 871
    tmp = 1;
  } else {
    {
#line 871
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     871);
#line 871
    tmp = 1;
    }
  }
  {
#line 872
  _glp_bfd_btran(csa->bfd, pi);
#line 874
  refine_btran(csa, cB, pi);
  }
#line 875
  return;
}
}
#line 892 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static double eval_cost(struct csa *csa , double *pi , int j ) 
{ 
  int m ;
  int n ;
  double *coef ;
  int *head ;
  int k ;
  double dj ;
  int tmp ;
  int tmp___0 ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 893
  m = csa->m;
#line 895
  n = csa->n;
#line 897
  coef = csa->coef;
#line 898
  head = csa->head;
#line 902
  if (1 <= j) {
#line 902
    if (j <= n) {
#line 902
      tmp = 1;
    } else {
      {
#line 902
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       902);
#line 902
      tmp = 1;
      }
    }
  } else {
    {
#line 902
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     902);
#line 902
    tmp = 1;
    }
  }
#line 904
  k = *(head + (m + j));
#line 906
  if (1 <= k) {
#line 906
    if (k <= m + n) {
#line 906
      tmp___0 = 1;
    } else {
      {
#line 906
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       906);
#line 906
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 906
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     906);
#line 906
    tmp___0 = 1;
    }
  }
#line 908
  dj = *(coef + k);
#line 909
  if (k <= m) {
#line 911
    dj -= *(pi + k);
  } else {
#line 915
    A_ptr = csa->A_ptr;
#line 916
    A_ind = csa->A_ind;
#line 917
    A_val = csa->A_val;
#line 919
    beg = *(A_ptr + (k - m));
#line 920
    end = *(A_ptr + ((k - m) + 1));
#line 921
    ptr = beg;
    {
#line 921
    while (1) {
      while_continue: /* CIL Label */ ;
#line 921
      if (! (ptr < end)) {
#line 921
        goto while_break;
      }
#line 922
      dj += *(A_val + ptr) * *(pi + *(A_ind + ptr));
#line 921
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 924
  return (dj);
}
}
#line 935 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_bbar(struct csa *csa ) 
{ 


  {
  {
#line 936
  eval_beta(csa, csa->bbar);
  }
#line 937
  return;
}
}
#line 948 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_cbar(struct csa *csa ) 
{ 
  int m ;
  int n ;
  int *head ;
  double *cbar ;
  double *pi ;
  int j ;
  int k ;
  int tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 951
  m = csa->m;
#line 953
  n = csa->n;
#line 955
  head = csa->head;
#line 957
  cbar = csa->cbar;
#line 958
  pi = csa->work3;
#line 964
  eval_pi(csa, pi);
#line 966
  j = 1;
  }
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 966
    if (! (j <= n)) {
#line 966
      goto while_break;
    }
#line 969
    k = *(head + (m + j));
#line 970
    if (1 <= k) {
#line 970
      if (k <= m + n) {
#line 970
        tmp = 1;
      } else {
        {
#line 970
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         970);
#line 970
        tmp = 1;
        }
      }
    } else {
      {
#line 970
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       970);
#line 970
      tmp = 1;
      }
    }
    {
#line 972
    *(cbar + j) = eval_cost(csa, pi, j);
#line 966
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 974
  return;
}
}
#line 984 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void reset_refsp(struct csa *csa ) 
{ 
  int m ;
  int n ;
  int *head ;
  char *refsp ;
  double *gamma___0 ;
  int i ;
  int k ;
  int tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 985
  m = csa->m;
#line 986
  n = csa->n;
#line 987
  head = csa->head;
#line 988
  refsp = csa->refsp;
#line 989
  gamma___0 = csa->gamma;
#line 991
  if (csa->refct == 0) {
#line 991
    tmp = 1;
  } else {
    {
#line 991
    _glp_lib_xassert("csa->refct == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     991);
#line 991
    tmp = 1;
    }
  }
  {
#line 992
  csa->refct = 1000;
#line 993
  memset((void *)(refsp + 1), 0, (size_t )((unsigned long )(m + n) * sizeof(char )));
#line 994
  i = 1;
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! (i <= m)) {
#line 994
      goto while_break;
    }
#line 995
    k = *(head + i);
#line 996
    *(refsp + k) = (char)1;
#line 997
    *(gamma___0 + i) = 1.0;
#line 994
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  return;
}
}
#line 1018 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_gamma(struct csa *csa , double *gamma___0 ) 
{ 
  int m ;
  int n ;
  char *type ;
  int *head ;
  char *refsp ;
  double *alfa ;
  double *h ;
  int i ;
  int j ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;
  int tmp___2 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1019
  m = csa->m;
#line 1020
  n = csa->n;
#line 1021
  type = csa->type;
#line 1022
  head = csa->head;
#line 1023
  refsp = csa->refsp;
#line 1024
  alfa = csa->work3;
#line 1025
  h = csa->work3;
#line 1028
  i = 1;
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! (i <= m)) {
#line 1028
      goto while_break;
    }
#line 1029
    k = *(head + i);
#line 1031
    if (1 <= k) {
#line 1031
      if (k <= m + n) {
#line 1031
        tmp = 1;
      } else {
        {
#line 1031
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1031);
#line 1031
        tmp = 1;
        }
      }
    } else {
      {
#line 1031
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1031);
#line 1031
      tmp = 1;
      }
    }
#line 1033
    if ((int )*(type + k) == 1) {
#line 1034
      *(gamma___0 + i) = 1.0;
    } else
#line 1036
    if (*(refsp + k)) {
#line 1036
      *(gamma___0 + i) = 1.0;
    } else {
#line 1036
      *(gamma___0 + i) = 0.0;
    }
#line 1028
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  j = 1;
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1039
    if (! (j <= n)) {
#line 1039
      goto while_break___0;
    }
#line 1040
    k = *(head + (m + j));
#line 1042
    if (1 <= k) {
#line 1042
      if (k <= m + n) {
#line 1042
        tmp___0 = 1;
      } else {
        {
#line 1042
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1042);
#line 1042
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 1042
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1042);
#line 1042
      tmp___0 = 1;
      }
    }
#line 1045
    if (! *(refsp + k)) {
#line 1045
      goto __Cont;
    }
#line 1048
    if ((int )*(type + k) != 5) {
#line 1048
      tmp___1 = 1;
    } else {
      {
#line 1048
      _glp_lib_xassert("type[k] != GLP_FX", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1048);
#line 1048
      tmp___1 = 1;
      }
    }
#line 1051
    i = 1;
    {
#line 1051
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1051
      if (! (i <= m)) {
#line 1051
        goto while_break___1;
      }
#line 1052
      *(h + i) = 0.0;
#line 1051
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1053
    if (k <= m) {
#line 1055
      *(h + k) = - 1.0;
    } else {
#line 1059
      A_ptr = csa->A_ptr;
#line 1060
      A_ind = csa->A_ind;
#line 1061
      A_val = csa->A_val;
#line 1063
      beg = *(A_ptr + (k - m));
#line 1064
      end = *(A_ptr + ((k - m) + 1));
#line 1065
      ptr = beg;
      {
#line 1065
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1065
        if (! (ptr < end)) {
#line 1065
          goto while_break___2;
        }
#line 1066
        *(h + *(A_ind + ptr)) = *(A_val + ptr);
#line 1065
        ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1069
    if (csa->valid) {
#line 1069
      tmp___2 = 1;
    } else {
      {
#line 1069
      _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1069);
#line 1069
      tmp___2 = 1;
      }
    }
    {
#line 1070
    _glp_bfd_ftran(csa->bfd, alfa);
#line 1072
    i = 1;
    }
    {
#line 1072
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1072
      if (! (i <= m)) {
#line 1072
        goto while_break___3;
      }
#line 1073
      k = *(head + i);
#line 1074
      if ((int )*(type + k) != 1) {
#line 1075
        *(gamma___0 + i) += *(alfa + i) * *(alfa + i);
      }
#line 1072
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1039
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1078
  return;
}
}
#line 1106 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void chuzr(struct csa *csa , double tol_bnd ) 
{ 
  int m ;
  int n ;
  char *type ;
  double *lb ;
  double *ub ;
  int *head ;
  double *bbar ;
  double *gamma___0 ;
  int i ;
  int k ;
  int p ;
  double delta ;
  double best ;
  double eps ;
  double ri ;
  double temp ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 1107
  m = csa->m;
#line 1109
  n = csa->n;
#line 1111
  type = csa->type;
#line 1112
  lb = csa->lb;
#line 1113
  ub = csa->ub;
#line 1114
  head = csa->head;
#line 1115
  bbar = csa->bbar;
#line 1116
  gamma___0 = csa->gamma;
#line 1120
  p = 0;
#line 1120
  delta = 0.0;
#line 1120
  best = 0.0;
#line 1122
  i = 1;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    if (! (i <= m)) {
#line 1122
      goto while_break;
    }
#line 1123
    k = *(head + i);
#line 1125
    if (1 <= k) {
#line 1125
      if (k <= m + n) {
#line 1125
        tmp = 1;
      } else {
        {
#line 1125
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1125);
#line 1125
        tmp = 1;
        }
      }
    } else {
      {
#line 1125
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1125);
#line 1125
      tmp = 1;
      }
    }
#line 1128
    ri = 0.0;
#line 1129
    if ((int )*(type + k) == 2) {
#line 1129
      goto _L;
    } else
#line 1129
    if ((int )*(type + k) == 4) {
#line 1129
      goto _L;
    } else
#line 1129
    if ((int )*(type + k) == 5) {
      _L: /* CIL Label */ 
      {
#line 1132
      tmp___0 = fabs(*(lb + k));
#line 1132
      eps = tol_bnd * (1.0 + (double )(kappa * (double const   )tmp___0));
      }
#line 1133
      if (*(bbar + i) < *(lb + k) - eps) {
#line 1135
        ri = *(lb + k) - *(bbar + i);
      }
    }
#line 1138
    if ((int )*(type + k) == 3) {
#line 1138
      goto _L___0;
    } else
#line 1138
    if ((int )*(type + k) == 4) {
#line 1138
      goto _L___0;
    } else
#line 1138
    if ((int )*(type + k) == 5) {
      _L___0: /* CIL Label */ 
      {
#line 1141
      tmp___1 = fabs(*(ub + k));
#line 1141
      eps = tol_bnd * (1.0 + (double )(kappa * (double const   )tmp___1));
      }
#line 1142
      if (*(bbar + i) > *(ub + k) + eps) {
#line 1144
        ri = *(ub + k) - *(bbar + i);
      }
    }
#line 1148
    if (ri == 0.0) {
#line 1148
      goto __Cont;
    }
#line 1152
    if (*(gamma___0 + i) >= 0.0) {
#line 1152
      tmp___2 = 1;
    } else {
      {
#line 1152
      _glp_lib_xassert("gamma[i] >= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1152);
#line 1152
      tmp___2 = 1;
      }
    }
#line 1154
    temp = *(gamma___0 + i);
#line 1155
    if (temp < 2.2204460492503131e-16) {
#line 1155
      temp = 2.2204460492503131e-16;
    }
#line 1156
    temp = (ri * ri) / temp;
#line 1157
    if (best < temp) {
#line 1158
      p = i;
#line 1158
      delta = ri;
#line 1158
      best = temp;
    }
    __Cont: /* CIL Label */ 
#line 1122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1162
  csa->p = p;
#line 1163
  csa->delta = delta;
#line 1164
  return;
}
}
#line 1179 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_rho(struct csa *csa , double *rho ) 
{ 
  int m ;
  int p ;
  double *e ;
  int i ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1180
  m = csa->m;
#line 1181
  p = csa->p;
#line 1182
  e = rho;
#line 1185
  if (1 <= p) {
#line 1185
    if (p <= m) {
#line 1185
      tmp = 1;
    } else {
      {
#line 1185
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1185);
#line 1185
      tmp = 1;
      }
    }
  } else {
    {
#line 1185
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1185);
#line 1185
    tmp = 1;
    }
  }
#line 1188
  i = 1;
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1188
    if (! (i <= m)) {
#line 1188
      goto while_break;
    }
#line 1189
    *(e + i) = 0.0;
#line 1188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1190
  *(e + p) = 1.0;
#line 1192
  if (csa->valid) {
#line 1192
    tmp___0 = 1;
  } else {
    {
#line 1192
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1192);
#line 1192
    tmp___0 = 1;
    }
  }
  {
#line 1193
  _glp_bfd_btran(csa->bfd, rho);
  }
#line 1194
  return;
}
}
#line 1205 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void refine_rho(struct csa *csa , double *rho ) 
{ 
  int m ;
  int p ;
  double *e ;
  int i ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1206
  m = csa->m;
#line 1207
  p = csa->p;
#line 1208
  e = csa->work3;
#line 1211
  if (1 <= p) {
#line 1211
    if (p <= m) {
#line 1211
      tmp = 1;
    } else {
      {
#line 1211
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1211);
#line 1211
      tmp = 1;
      }
    }
  } else {
    {
#line 1211
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1211);
#line 1211
    tmp = 1;
    }
  }
#line 1214
  i = 1;
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1214
    if (! (i <= m)) {
#line 1214
      goto while_break;
    }
#line 1215
    *(e + i) = 0.0;
#line 1214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1216
  *(e + p) = 1.0;
#line 1218
  refine_btran(csa, e, rho);
  }
#line 1219
  return;
}
}
#line 1253 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_trow1(struct csa *csa , double *rho ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  char *stat ;
  int *trow_ind ;
  double *trow_vec ;
  int j ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  int nnz ;
  double temp ;

  {
#line 1254
  m = csa->m;
#line 1255
  n = csa->n;
#line 1256
  A_ptr = csa->A_ptr;
#line 1257
  A_ind = csa->A_ind;
#line 1258
  A_val = csa->A_val;
#line 1259
  head = csa->head;
#line 1260
  stat = csa->stat;
#line 1261
  trow_ind = csa->trow_ind;
#line 1262
  trow_vec = csa->trow_vec;
#line 1267
  nnz = 0;
#line 1268
  j = 1;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! (j <= n)) {
#line 1268
      goto while_break;
    }
#line 1269
    if ((int )*(stat + j) == 5) {
#line 1271
      *(trow_vec + j) = 0.0;
#line 1272
      goto __Cont;
    }
#line 1274
    k = *(head + (m + j));
#line 1275
    if (k <= m) {
#line 1277
      temp = - *(rho + k);
    } else {
#line 1281
      beg = *(A_ptr + (k - m));
#line 1281
      end = *(A_ptr + ((k - m) + 1));
#line 1282
      temp = 0.0;
#line 1283
      ptr = beg;
      {
#line 1283
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1283
        if (! (ptr < end)) {
#line 1283
          goto while_break___0;
        }
#line 1284
        temp += *(rho + *(A_ind + ptr)) * *(A_val + ptr);
#line 1283
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1286
    if (temp != 0.0) {
#line 1287
      nnz ++;
#line 1287
      *(trow_ind + nnz) = j;
    }
#line 1288
    *(trow_vec + j) = temp;
    __Cont: /* CIL Label */ 
#line 1268
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  csa->trow_nnz = nnz;
#line 1291
  return;
}
}
#line 1294 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_trow2(struct csa *csa , double *rho ) 
{ 
  int m ;
  int n ;
  int *AT_ptr ;
  int *AT_ind ;
  double *AT_val ;
  int *bind ;
  char *stat ;
  int *trow_ind ;
  double *trow_vec ;
  int i ;
  int j ;
  int beg ;
  int end ;
  int ptr ;
  int nnz ;
  double temp ;

  {
#line 1295
  m = csa->m;
#line 1296
  n = csa->n;
#line 1297
  AT_ptr = csa->AT_ptr;
#line 1298
  AT_ind = csa->AT_ind;
#line 1299
  AT_val = csa->AT_val;
#line 1300
  bind = csa->bind;
#line 1301
  stat = csa->stat;
#line 1302
  trow_ind = csa->trow_ind;
#line 1303
  trow_vec = csa->trow_vec;
#line 1307
  j = 1;
  {
#line 1307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1307
    if (! (j <= n)) {
#line 1307
      goto while_break;
    }
#line 1308
    *(trow_vec + j) = 0.0;
#line 1307
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  i = 1;
  {
#line 1311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1311
    if (! (i <= m)) {
#line 1311
      goto while_break___0;
    }
#line 1312
    temp = *(rho + i);
#line 1313
    if (temp == 0.0) {
#line 1313
      goto __Cont;
    }
#line 1315
    j = *(bind + i) - m;
#line 1316
    if (j >= 1) {
#line 1316
      if ((int )*(stat + j) != 5) {
#line 1317
        *(trow_vec + j) -= temp;
      }
    }
#line 1318
    beg = *(AT_ptr + i);
#line 1318
    end = *(AT_ptr + (i + 1));
#line 1319
    ptr = beg;
    {
#line 1319
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1319
      if (! (ptr < end)) {
#line 1319
        goto while_break___1;
      }
#line 1320
      j = *(bind + (m + *(AT_ind + ptr))) - m;
#line 1321
      if (j >= 1) {
#line 1321
        if ((int )*(stat + j) != 5) {
#line 1322
          *(trow_vec + j) += temp * *(AT_val + ptr);
        }
      }
#line 1319
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1311
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1326
  nnz = 0;
#line 1327
  j = 1;
  {
#line 1327
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1327
    if (! (j <= n)) {
#line 1327
      goto while_break___2;
    }
#line 1328
    if (*(trow_vec + j) != 0.0) {
#line 1329
      nnz ++;
#line 1329
      *(trow_ind + nnz) = j;
    }
#line 1327
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1331
  csa->trow_nnz = nnz;
#line 1332
  return;
}
}
#line 1335 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_trow(struct csa *csa , double *rho ) 
{ 
  int m ;
  int i ;
  int nnz ;
  double dens ;

  {
#line 1336
  m = csa->m;
#line 1340
  nnz = 0;
#line 1341
  i = 1;
  {
#line 1341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1341
    if (! (i <= m)) {
#line 1341
      goto while_break;
    }
#line 1342
    if (*(rho + i) != 0.0) {
#line 1342
      nnz ++;
    }
#line 1341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1343
  dens = (double )nnz / (double )m;
#line 1344
  if (dens >= 0.20) {
    {
#line 1346
    eval_trow1(csa, rho);
    }
  } else {
    {
#line 1350
    eval_trow2(csa, rho);
    }
  }
#line 1352
  return;
}
}
#line 1364 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void sort_trow(struct csa *csa , double tol_piv ) 
{ 
  int n ;
  char *stat ;
  int nnz ;
  int *trow_ind ;
  double *trow_vec ;
  int j ;
  int num ;
  int pos ;
  double big ;
  double eps ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1367
  n = csa->n;
#line 1368
  stat = csa->stat;
#line 1370
  nnz = csa->trow_nnz;
#line 1371
  trow_ind = csa->trow_ind;
#line 1372
  trow_vec = csa->trow_vec;
#line 1376
  big = 0.0;
#line 1377
  pos = 1;
  {
#line 1377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1377
    if (! (pos <= nnz)) {
#line 1377
      goto while_break;
    }
#line 1380
    j = *(trow_ind + pos);
#line 1381
    if (1 <= j) {
#line 1381
      if (j <= n) {
#line 1381
        tmp = 1;
      } else {
        {
#line 1381
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1381);
#line 1381
        tmp = 1;
        }
      }
    } else {
      {
#line 1381
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1381);
#line 1381
      tmp = 1;
      }
    }
#line 1382
    if ((int )*(stat + j) != 5) {
#line 1382
      tmp___0 = 1;
    } else {
      {
#line 1382
      _glp_lib_xassert("stat[j] != GLP_NS", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1382);
#line 1382
      tmp___0 = 1;
      }
    }
    {
#line 1384
    temp = fabs(*(trow_vec + *(trow_ind + pos)));
    }
#line 1385
    if (big < temp) {
#line 1385
      big = temp;
    }
#line 1377
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1387
  csa->trow_max = big;
#line 1389
  eps = tol_piv * (1.0 + 0.01 * big);
#line 1391
  num = 0;
  {
#line 1391
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1391
    if (! (num < nnz)) {
#line 1391
      goto while_break___0;
    }
    {
#line 1392
    j = *(trow_ind + nnz);
#line 1393
    tmp___1 = fabs(*(trow_vec + j));
    }
#line 1393
    if (tmp___1 < eps) {
#line 1394
      nnz --;
    } else {
#line 1396
      num ++;
#line 1397
      *(trow_ind + nnz) = *(trow_ind + num);
#line 1398
      *(trow_ind + num) = j;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1401
  csa->trow_num = num;
#line 1402
  return;
}
}
#line 1550 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void chuzc(struct csa *csa , double rtol ) 
{ 
  int m ;
  int n ;
  char *stat ;
  double *cbar ;
  int p ;
  double delta ;
  int *trow_ind ;
  double *trow_vec ;
  int trow_num ;
  int j ;
  int pos ;
  int q ;
  double alfa ;
  double big ;
  double s ;
  double t ;
  double teta ;
  double tmax ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 1553
  m = csa->m;
#line 1554
  n = csa->n;
#line 1556
  stat = csa->stat;
#line 1557
  cbar = csa->cbar;
#line 1559
  p = csa->p;
#line 1561
  delta = csa->delta;
#line 1562
  trow_ind = csa->trow_ind;
#line 1563
  trow_vec = csa->trow_vec;
#line 1564
  trow_num = csa->trow_num;
#line 1568
  if (1 <= p) {
#line 1568
    if (p <= m) {
#line 1568
      tmp = 1;
    } else {
      {
#line 1568
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1568);
#line 1568
      tmp = 1;
      }
    }
  } else {
    {
#line 1568
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1568);
#line 1568
    tmp = 1;
    }
  }
#line 1577
  if (delta != 0.0) {
#line 1577
    tmp___0 = 1;
  } else {
    {
#line 1577
    _glp_lib_xassert("delta != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1577);
#line 1577
    tmp___0 = 1;
    }
  }
#line 1580
  if (delta > 0.0) {
#line 1580
    s = 1.0;
  } else {
#line 1580
    s = - 1.0;
  }
#line 1583
  q = 0;
#line 1583
  teta = 1.7976931348623157e+308;
#line 1583
  big = 0.0;
#line 1585
  pos = 1;
  {
#line 1585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1585
    if (! (pos <= trow_num)) {
#line 1585
      goto while_break;
    }
#line 1586
    j = *(trow_ind + pos);
#line 1588
    if (1 <= j) {
#line 1588
      if (j <= n) {
#line 1588
        tmp___1 = 1;
      } else {
        {
#line 1588
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1588);
#line 1588
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 1588
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1588);
#line 1588
      tmp___1 = 1;
      }
    }
#line 1590
    alfa = s * *(trow_vec + j);
#line 1592
    if (alfa != 0.0) {
#line 1592
      tmp___2 = 1;
    } else {
      {
#line 1592
      _glp_lib_xassert("alfa != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1592);
#line 1592
      tmp___2 = 1;
      }
    }
#line 1596
    if (alfa > 0.0) {
#line 1598
      if ((int )*(stat + j) == 2) {
#line 1600
        t = (*(cbar + j) + rtol) / alfa;
      } else
#line 1598
      if ((int )*(stat + j) == 4) {
#line 1600
        t = (*(cbar + j) + rtol) / alfa;
      } else {
#line 1604
        goto __Cont;
      }
    } else
#line 1609
    if ((int )*(stat + j) == 3) {
#line 1611
      t = (*(cbar + j) - rtol) / alfa;
    } else
#line 1609
    if ((int )*(stat + j) == 4) {
#line 1611
      t = (*(cbar + j) - rtol) / alfa;
    } else {
#line 1615
      goto __Cont;
    }
#line 1629
    if (t < 0.0) {
#line 1629
      t = 0.0;
    }
#line 1631
    if (teta > t) {
      {
#line 1632
      q = j;
#line 1632
      teta = t;
#line 1632
      big = fabs(alfa);
      }
    } else
#line 1631
    if (teta == t) {
      {
#line 1631
      tmp___3 = fabs(alfa);
      }
#line 1631
      if (big < tmp___3) {
        {
#line 1632
        q = j;
#line 1632
        teta = t;
#line 1632
        big = fabs(alfa);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1585
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1636
  if (rtol == 0.0) {
#line 1636
    goto done;
  }
#line 1638
  if (q == 0) {
#line 1638
    goto done;
  }
#line 1640
  if (teta == 0.0) {
#line 1640
    goto done;
  }
#line 1647
  tmax = teta;
#line 1650
  q = 0;
#line 1650
  teta = 1.7976931348623157e+308;
#line 1650
  big = 0.0;
#line 1652
  pos = 1;
  {
#line 1652
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1652
    if (! (pos <= trow_num)) {
#line 1652
      goto while_break___0;
    }
#line 1653
    j = *(trow_ind + pos);
#line 1655
    if (1 <= j) {
#line 1655
      if (j <= n) {
#line 1655
        tmp___4 = 1;
      } else {
        {
#line 1655
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1655);
#line 1655
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 1655
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1655);
#line 1655
      tmp___4 = 1;
      }
    }
#line 1657
    alfa = s * *(trow_vec + j);
#line 1659
    if (alfa != 0.0) {
#line 1659
      tmp___5 = 1;
    } else {
      {
#line 1659
      _glp_lib_xassert("alfa != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1659);
#line 1659
      tmp___5 = 1;
      }
    }
#line 1663
    if (alfa > 0.0) {
#line 1665
      if ((int )*(stat + j) == 2) {
#line 1667
        t = *(cbar + j) / alfa;
      } else
#line 1665
      if ((int )*(stat + j) == 4) {
#line 1667
        t = *(cbar + j) / alfa;
      } else {
#line 1671
        goto __Cont___0;
      }
    } else
#line 1676
    if ((int )*(stat + j) == 3) {
#line 1678
      t = *(cbar + j) / alfa;
    } else
#line 1676
    if ((int )*(stat + j) == 4) {
#line 1678
      t = *(cbar + j) / alfa;
    } else {
#line 1682
      goto __Cont___0;
    }
#line 1686
    if (t < 0.0) {
#line 1686
      t = 0.0;
    }
#line 1693
    if (t <= tmax) {
      {
#line 1693
      tmp___6 = fabs(alfa);
      }
#line 1693
      if (big < tmp___6) {
        {
#line 1694
        q = j;
#line 1694
        teta = t;
#line 1694
        big = fabs(alfa);
        }
      }
    }
    __Cont___0: /* CIL Label */ 
#line 1652
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1697
  if (q != 0) {
#line 1697
    tmp___7 = 1;
  } else {
    {
#line 1697
    _glp_lib_xassert("q != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1697);
#line 1697
    tmp___7 = 1;
    }
  }
  done: 
#line 1699
  csa->q = q;
#line 1701
  csa->new_dq = s * teta;
#line 1702
  return;
}
}
#line 1719 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void eval_tcol(struct csa *csa ) 
{ 
  int m ;
  int n ;
  int *head ;
  int q ;
  int *tcol_ind ;
  double *tcol_vec ;
  double *h ;
  int i ;
  int k ;
  int nnz ;
  int tmp ;
  int tmp___0 ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;
  int tmp___1 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 1720
  m = csa->m;
#line 1722
  n = csa->n;
#line 1724
  head = csa->head;
#line 1725
  q = csa->q;
#line 1726
  tcol_ind = csa->tcol_ind;
#line 1727
  tcol_vec = csa->tcol_vec;
#line 1728
  h = csa->tcol_vec;
#line 1731
  if (1 <= q) {
#line 1731
    if (q <= n) {
#line 1731
      tmp = 1;
    } else {
      {
#line 1731
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1731);
#line 1731
      tmp = 1;
      }
    }
  } else {
    {
#line 1731
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1731);
#line 1731
    tmp = 1;
    }
  }
#line 1733
  k = *(head + (m + q));
#line 1735
  if (1 <= k) {
#line 1735
    if (k <= m + n) {
#line 1735
      tmp___0 = 1;
    } else {
      {
#line 1735
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1735);
#line 1735
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1735
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1735);
#line 1735
    tmp___0 = 1;
    }
  }
#line 1738
  i = 1;
  {
#line 1738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1738
    if (! (i <= m)) {
#line 1738
      goto while_break;
    }
#line 1739
    *(h + i) = 0.0;
#line 1738
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1740
  if (k <= m) {
#line 1742
    *(h + k) = - 1.0;
  } else {
#line 1746
    A_ptr = csa->A_ptr;
#line 1747
    A_ind = csa->A_ind;
#line 1748
    A_val = csa->A_val;
#line 1750
    beg = *(A_ptr + (k - m));
#line 1751
    end = *(A_ptr + ((k - m) + 1));
#line 1752
    ptr = beg;
    {
#line 1752
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1752
      if (! (ptr < end)) {
#line 1752
        goto while_break___0;
      }
#line 1753
      *(h + *(A_ind + ptr)) = *(A_val + ptr);
#line 1752
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1756
  if (csa->valid) {
#line 1756
    tmp___1 = 1;
  } else {
    {
#line 1756
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1756);
#line 1756
    tmp___1 = 1;
    }
  }
  {
#line 1757
  _glp_bfd_ftran(csa->bfd, tcol_vec);
#line 1759
  nnz = 0;
#line 1760
  i = 1;
  }
  {
#line 1760
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1760
    if (! (i <= m)) {
#line 1760
      goto while_break___1;
    }
#line 1761
    if (*(tcol_vec + i) != 0.0) {
#line 1762
      nnz ++;
#line 1762
      *(tcol_ind + nnz) = i;
    }
#line 1760
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1764
  csa->tcol_nnz = nnz;
#line 1765
  return;
}
}
#line 1776 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void refine_tcol(struct csa *csa ) 
{ 
  int m ;
  int n ;
  int *head ;
  int q ;
  int *tcol_ind ;
  double *tcol_vec ;
  double *h ;
  int i ;
  int k ;
  int nnz ;
  int tmp ;
  int tmp___0 ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 1777
  m = csa->m;
#line 1779
  n = csa->n;
#line 1781
  head = csa->head;
#line 1782
  q = csa->q;
#line 1783
  tcol_ind = csa->tcol_ind;
#line 1784
  tcol_vec = csa->tcol_vec;
#line 1785
  h = csa->work3;
#line 1788
  if (1 <= q) {
#line 1788
    if (q <= n) {
#line 1788
      tmp = 1;
    } else {
      {
#line 1788
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1788);
#line 1788
      tmp = 1;
      }
    }
  } else {
    {
#line 1788
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1788);
#line 1788
    tmp = 1;
    }
  }
#line 1790
  k = *(head + (m + q));
#line 1792
  if (1 <= k) {
#line 1792
    if (k <= m + n) {
#line 1792
      tmp___0 = 1;
    } else {
      {
#line 1792
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1792);
#line 1792
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1792
    _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1792);
#line 1792
    tmp___0 = 1;
    }
  }
#line 1795
  i = 1;
  {
#line 1795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1795
    if (! (i <= m)) {
#line 1795
      goto while_break;
    }
#line 1796
    *(h + i) = 0.0;
#line 1795
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1797
  if (k <= m) {
#line 1799
    *(h + k) = - 1.0;
  } else {
#line 1803
    A_ptr = csa->A_ptr;
#line 1804
    A_ind = csa->A_ind;
#line 1805
    A_val = csa->A_val;
#line 1807
    beg = *(A_ptr + (k - m));
#line 1808
    end = *(A_ptr + ((k - m) + 1));
#line 1809
    ptr = beg;
    {
#line 1809
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1809
      if (! (ptr < end)) {
#line 1809
        goto while_break___0;
      }
#line 1810
      *(h + *(A_ind + ptr)) = *(A_val + ptr);
#line 1809
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1813
  refine_ftran(csa, h, tcol_vec);
#line 1815
  nnz = 0;
#line 1816
  i = 1;
  }
  {
#line 1816
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1816
    if (! (i <= m)) {
#line 1816
      goto while_break___1;
    }
#line 1817
    if (*(tcol_vec + i) != 0.0) {
#line 1818
      nnz ++;
#line 1818
      *(tcol_ind + nnz) = i;
    }
#line 1816
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1820
  csa->tcol_nnz = nnz;
#line 1821
  return;
}
}
#line 1831 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void update_cbar(struct csa *csa ) 
{ 
  int n ;
  double *cbar ;
  int trow_nnz ;
  int *trow_ind ;
  double *trow_vec ;
  int q ;
  double new_dq ;
  int j ;
  int pos ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1834
  n = csa->n;
#line 1836
  cbar = csa->cbar;
#line 1837
  trow_nnz = csa->trow_nnz;
#line 1838
  trow_ind = csa->trow_ind;
#line 1839
  trow_vec = csa->trow_vec;
#line 1840
  q = csa->q;
#line 1841
  new_dq = csa->new_dq;
#line 1844
  if (1 <= q) {
#line 1844
    if (q <= n) {
#line 1844
      tmp = 1;
    } else {
      {
#line 1844
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1844);
#line 1844
      tmp = 1;
      }
    }
  } else {
    {
#line 1844
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1844);
#line 1844
    tmp = 1;
    }
  }
#line 1847
  *(cbar + q) = new_dq;
#line 1849
  if (new_dq == 0.0) {
#line 1849
    goto done;
  }
#line 1850
  pos = 1;
  {
#line 1850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1850
    if (! (pos <= trow_nnz)) {
#line 1850
      goto while_break;
    }
#line 1851
    j = *(trow_ind + pos);
#line 1853
    if (1 <= j) {
#line 1853
      if (j <= n) {
#line 1853
        tmp___0 = 1;
      } else {
        {
#line 1853
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1853);
#line 1853
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 1853
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1853);
#line 1853
      tmp___0 = 1;
      }
    }
#line 1855
    if (j != q) {
#line 1856
      *(cbar + j) -= *(trow_vec + j) * new_dq;
    }
#line 1850
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1858
  return;
}
}
#line 1867 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void update_bbar(struct csa *csa ) 
{ 
  int m ;
  int n ;
  double *bbar ;
  int p ;
  double delta ;
  int q ;
  int tcol_nnz ;
  int *tcol_ind ;
  double *tcol_vec ;
  int i ;
  int pos ;
  double teta ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 1870
  m = csa->m;
#line 1871
  n = csa->n;
#line 1873
  bbar = csa->bbar;
#line 1874
  p = csa->p;
#line 1875
  delta = csa->delta;
#line 1876
  q = csa->q;
#line 1877
  tcol_nnz = csa->tcol_nnz;
#line 1878
  tcol_ind = csa->tcol_ind;
#line 1879
  tcol_vec = csa->tcol_vec;
#line 1883
  if (1 <= p) {
#line 1883
    if (p <= m) {
#line 1883
      tmp = 1;
    } else {
      {
#line 1883
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1883);
#line 1883
      tmp = 1;
      }
    }
  } else {
    {
#line 1883
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1883);
#line 1883
    tmp = 1;
    }
  }
#line 1884
  if (1 <= q) {
#line 1884
    if (q <= n) {
#line 1884
      tmp___0 = 1;
    } else {
      {
#line 1884
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1884);
#line 1884
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1884
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1884);
#line 1884
    tmp___0 = 1;
    }
  }
#line 1888
  if (*(tcol_vec + p) != 0.0) {
#line 1888
    tmp___1 = 1;
  } else {
    {
#line 1888
    _glp_lib_xassert("tcol_vec[p] != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1888);
#line 1888
    tmp___1 = 1;
    }
  }
  {
#line 1890
  teta = delta / *(tcol_vec + p);
#line 1892
  tmp___2 = get_xN(csa, q);
#line 1892
  *(bbar + p) = tmp___2 + teta;
  }
#line 1894
  if (teta == 0.0) {
#line 1894
    goto done;
  }
#line 1895
  pos = 1;
  {
#line 1895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1895
    if (! (pos <= tcol_nnz)) {
#line 1895
      goto while_break;
    }
#line 1896
    i = *(tcol_ind + pos);
#line 1898
    if (1 <= i) {
#line 1898
      if (i <= m) {
#line 1898
        tmp___3 = 1;
      } else {
        {
#line 1898
        _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1898);
#line 1898
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 1898
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1898);
#line 1898
      tmp___3 = 1;
      }
    }
#line 1900
    if (i != p) {
#line 1901
      *(bbar + i) += *(tcol_vec + i) * teta;
    }
#line 1895
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1903
  return;
}
}
#line 1912 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void update_gamma(struct csa *csa ) 
{ 
  int m ;
  int n ;
  char *type ;
  int *head ;
  char *refsp ;
  double *gamma___0 ;
  int p ;
  int trow_nnz ;
  int *trow_ind ;
  double *trow_vec ;
  int q ;
  int tcol_nnz ;
  int *tcol_ind ;
  double *tcol_vec ;
  double *u ;
  int i ;
  int j ;
  int k ;
  int pos ;
  double gamma_p ;
  double eta_p ;
  double pivot ;
  double t ;
  double t1 ;
  double t2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
#line 1913
  m = csa->m;
#line 1915
  n = csa->n;
#line 1917
  type = csa->type;
#line 1918
  head = csa->head;
#line 1919
  refsp = csa->refsp;
#line 1920
  gamma___0 = csa->gamma;
#line 1921
  p = csa->p;
#line 1922
  trow_nnz = csa->trow_nnz;
#line 1923
  trow_ind = csa->trow_ind;
#line 1924
  trow_vec = csa->trow_vec;
#line 1925
  q = csa->q;
#line 1926
  tcol_nnz = csa->tcol_nnz;
#line 1927
  tcol_ind = csa->tcol_ind;
#line 1928
  tcol_vec = csa->tcol_vec;
#line 1929
  u = csa->work3;
#line 1933
  if (1 <= p) {
#line 1933
    if (p <= m) {
#line 1933
      tmp = 1;
    } else {
      {
#line 1933
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1933);
#line 1933
      tmp = 1;
      }
    }
  } else {
    {
#line 1933
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1933);
#line 1933
    tmp = 1;
    }
  }
#line 1934
  if (1 <= q) {
#line 1934
    if (q <= n) {
#line 1934
      tmp___0 = 1;
    } else {
      {
#line 1934
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1934);
#line 1934
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1934
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1934);
#line 1934
    tmp___0 = 1;
    }
  }
#line 1937
  if (csa->refct > 0) {
#line 1937
    tmp___1 = 1;
  } else {
    {
#line 1937
    _glp_lib_xassert("csa->refct > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1937);
#line 1937
    tmp___1 = 1;
    }
  }
#line 1938
  (csa->refct) --;
#line 1942
  if ((int )*(type + *(head + p)) != 1) {
#line 1942
    tmp___2 = 1;
  } else {
    {
#line 1942
    _glp_lib_xassert("type[head[p]] != GLP_FR", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1942);
#line 1942
    tmp___2 = 1;
    }
  }
#line 1944
  if (*(refsp + *(head + p))) {
#line 1944
    eta_p = 1.0;
  } else {
#line 1944
    eta_p = 0.0;
  }
#line 1944
  gamma_p = eta_p;
#line 1945
  i = 1;
  {
#line 1945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1945
    if (! (i <= m)) {
#line 1945
      goto while_break;
    }
#line 1945
    *(u + i) = 0.0;
#line 1945
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1946
  pos = 1;
  {
#line 1946
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1946
    if (! (pos <= trow_nnz)) {
#line 1946
      goto while_break___0;
    }
#line 1947
    j = *(trow_ind + pos);
#line 1949
    if (1 <= j) {
#line 1949
      if (j <= n) {
#line 1949
        tmp___3 = 1;
      } else {
        {
#line 1949
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1949);
#line 1949
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 1949
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1949);
#line 1949
      tmp___3 = 1;
      }
    }
#line 1951
    k = *(head + (m + j));
#line 1953
    if (1 <= k) {
#line 1953
      if (k <= m + n) {
#line 1953
        tmp___4 = 1;
      } else {
        {
#line 1953
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1953);
#line 1953
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 1953
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1953);
#line 1953
      tmp___4 = 1;
      }
    }
#line 1954
    if ((int )*(type + k) != 5) {
#line 1954
      tmp___5 = 1;
    } else {
      {
#line 1954
      _glp_lib_xassert("type[k] != GLP_FX", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1954);
#line 1954
      tmp___5 = 1;
      }
    }
#line 1956
    if (! *(refsp + k)) {
#line 1956
      goto __Cont;
    }
#line 1957
    t = *(trow_vec + j);
#line 1958
    gamma_p += t * t;
#line 1960
    if (k <= m) {
#line 1962
      *(u + k) += t;
    } else {
#line 1966
      A_ptr = csa->A_ptr;
#line 1967
      A_ind = csa->A_ind;
#line 1968
      A_val = csa->A_val;
#line 1970
      beg = *(A_ptr + (k - m));
#line 1971
      end = *(A_ptr + ((k - m) + 1));
#line 1972
      ptr = beg;
      {
#line 1972
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1972
        if (! (ptr < end)) {
#line 1972
          goto while_break___1;
        }
#line 1973
        *(u + *(A_ind + ptr)) -= t * *(A_val + ptr);
#line 1972
        ptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1946
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1976
  if (csa->valid) {
#line 1976
    tmp___6 = 1;
  } else {
    {
#line 1976
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1976);
#line 1976
    tmp___6 = 1;
    }
  }
  {
#line 1977
  _glp_bfd_ftran(csa->bfd, u);
#line 1980
  pivot = *(tcol_vec + p);
  }
#line 1982
  if (pivot != 0.0) {
#line 1982
    tmp___7 = 1;
  } else {
    {
#line 1982
    _glp_lib_xassert("pivot != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     1982);
#line 1982
    tmp___7 = 1;
    }
  }
#line 1984
  pos = 1;
  {
#line 1984
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1984
    if (! (pos <= tcol_nnz)) {
#line 1984
      goto while_break___2;
    }
#line 1985
    i = *(tcol_ind + pos);
#line 1987
    if (1 <= i) {
#line 1987
      if (i <= m) {
#line 1987
        tmp___8 = 1;
      } else {
        {
#line 1987
        _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1987);
#line 1987
        tmp___8 = 1;
        }
      }
    } else {
      {
#line 1987
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1987);
#line 1987
      tmp___8 = 1;
      }
    }
#line 1989
    k = *(head + i);
#line 1991
    if (1 <= k) {
#line 1991
      if (k <= m + n) {
#line 1991
        tmp___9 = 1;
      } else {
        {
#line 1991
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1991);
#line 1991
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 1991
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       1991);
#line 1991
      tmp___9 = 1;
      }
    }
#line 1994
    if (i == p) {
#line 1994
      goto __Cont___0;
    }
#line 1996
    if ((int )*(type + *(head + i)) == 1) {
#line 1999
      if (*(gamma___0 + i) == 1.0) {
#line 1999
        tmp___10 = 1;
      } else {
        {
#line 1999
        _glp_lib_xassert("gamma[i] == 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         1999);
#line 1999
        tmp___10 = 1;
        }
      }
#line 2001
      goto __Cont___0;
    }
#line 2004
    t = *(tcol_vec + i) / pivot;
#line 2005
    t1 = (*(gamma___0 + i) + (t * t) * gamma_p) + (2.0 * t) * *(u + i);
#line 2006
    if (*(refsp + k)) {
#line 2006
      tmp___11 = 1.0;
    } else {
#line 2006
      tmp___11 = 0.0;
    }
#line 2006
    t2 = tmp___11 + (eta_p * t) * t;
#line 2007
    if (t1 >= t2) {
#line 2007
      *(gamma___0 + i) = t1;
    } else {
#line 2007
      *(gamma___0 + i) = t2;
    }
#line 2010
    if (*(gamma___0 + i) < 2.2204460492503131e-16) {
#line 2010
      *(gamma___0 + i) = 2.2204460492503131e-16;
    }
    __Cont___0: /* CIL Label */ 
#line 1984
    pos ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2013
  if ((int )*(type + *(head + (m + q))) == 1) {
#line 2014
    *(gamma___0 + p) = 1.0;
  } else {
#line 2016
    *(gamma___0 + p) = gamma_p / (pivot * pivot);
#line 2017
    if (*(gamma___0 + p) < 2.2204460492503131e-16) {
#line 2017
      *(gamma___0 + p) = 2.2204460492503131e-16;
    }
  }
#line 2022
  k = *(head + p);
#line 2023
  if ((int )*(type + k) == 5) {
#line 2023
    if (*(refsp + k)) {
#line 2024
      *(refsp + k) = (char)0;
#line 2025
      pos = 1;
      {
#line 2025
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2025
        if (! (pos <= tcol_nnz)) {
#line 2025
          goto while_break___3;
        }
#line 2026
        i = *(tcol_ind + pos);
#line 2027
        if (i == p) {
#line 2028
          if ((int )*(type + *(head + (m + q))) == 1) {
#line 2028
            goto __Cont___1;
          }
#line 2029
          t = 1.0 / *(tcol_vec + p);
        } else {
#line 2032
          if ((int )*(type + *(head + i)) == 1) {
#line 2032
            goto __Cont___1;
          }
#line 2033
          t = *(tcol_vec + i) / *(tcol_vec + p);
        }
#line 2035
        *(gamma___0 + i) -= t * t;
#line 2036
        if (*(gamma___0 + i) < 2.2204460492503131e-16) {
#line 2036
          *(gamma___0 + i) = 2.2204460492503131e-16;
        }
        __Cont___1: /* CIL Label */ 
#line 2025
        pos ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 2039
  return;
}
}
#line 2055 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static double err_in_bbar(struct csa *csa ) 
{ 
  int m ;
  double *bbar ;
  int i ;
  double e ;
  double emax ;
  double *beta ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 2056
  m = csa->m;
#line 2057
  bbar = csa->bbar;
#line 2060
  tmp = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 2060
  beta = (double *)tmp;
#line 2061
  eval_beta(csa, beta);
#line 2062
  emax = 0.0;
#line 2063
  i = 1;
  }
  {
#line 2063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2063
    if (! (i <= m)) {
#line 2063
      goto while_break;
    }
    {
#line 2064
    tmp___0 = fabs(*(beta + i) - *(bbar + i));
#line 2064
    tmp___1 = fabs(*(beta + i));
#line 2064
    e = tmp___0 / (1.0 + tmp___1);
    }
#line 2065
    if (emax < e) {
#line 2065
      emax = e;
    }
#line 2063
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2067
  _glp_lib_xfree((void *)beta);
  }
#line 2068
  return (emax);
}
}
#line 2085 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static double err_in_cbar(struct csa *csa ) 
{ 
  int m ;
  int n ;
  char *stat ;
  double *cbar ;
  int j ;
  double e ;
  double emax ;
  double cost ;
  double *pi ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 2086
  m = csa->m;
#line 2087
  n = csa->n;
#line 2088
  stat = csa->stat;
#line 2089
  cbar = csa->cbar;
#line 2092
  tmp = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 2092
  pi = (double *)tmp;
#line 2093
  eval_pi(csa, pi);
#line 2094
  emax = 0.0;
#line 2095
  j = 1;
  }
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2095
    if (! (j <= n)) {
#line 2095
      goto while_break;
    }
#line 2096
    if ((int )*(stat + j) == 5) {
#line 2096
      goto __Cont;
    }
    {
#line 2097
    cost = eval_cost(csa, pi, j);
#line 2098
    tmp___0 = fabs(cost - *(cbar + j));
#line 2098
    tmp___1 = fabs(cost);
#line 2098
    e = tmp___0 / (1.0 + tmp___1);
    }
#line 2099
    if (emax < e) {
#line 2099
      emax = e;
    }
    __Cont: /* CIL Label */ 
#line 2095
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2101
  _glp_lib_xfree((void *)pi);
  }
#line 2102
  return (emax);
}
}
#line 2119 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static double err_in_gamma(struct csa *csa ) 
{ 
  int m ;
  char *type ;
  int *head ;
  double *gamma___0 ;
  double *exact ;
  int i ;
  double e ;
  double emax ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 2120
  m = csa->m;
#line 2121
  type = csa->type;
#line 2122
  head = csa->head;
#line 2123
  gamma___0 = csa->gamma;
#line 2124
  exact = csa->work4;
#line 2127
  eval_gamma(csa, exact);
#line 2128
  emax = 0.0;
#line 2129
  i = 1;
  }
  {
#line 2129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2129
    if (! (i <= m)) {
#line 2129
      goto while_break;
    }
#line 2130
    if ((int )*(type + *(head + i)) == 1) {
#line 2131
      if (*(gamma___0 + i) == 1.0) {
#line 2131
        tmp = 1;
      } else {
        {
#line 2131
        _glp_lib_xassert("gamma[i] == 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2131);
#line 2131
        tmp = 1;
        }
      }
#line 2132
      if (*(exact + i) == 1.0) {
#line 2132
        tmp___0 = 1;
      } else {
        {
#line 2132
        _glp_lib_xassert("exact[i] == 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2132);
#line 2132
        tmp___0 = 1;
        }
      }
#line 2133
      goto __Cont;
    }
    {
#line 2135
    temp = *(exact + i);
#line 2136
    tmp___1 = fabs(temp - *(gamma___0 + i));
#line 2136
    tmp___2 = fabs(temp);
#line 2136
    e = tmp___1 / (1.0 + tmp___2);
    }
#line 2137
    if (emax < e) {
#line 2137
      emax = e;
    }
    __Cont: /* CIL Label */ 
#line 2129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2139
  return (emax);
}
}
#line 2148 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void change_basis(struct csa *csa ) 
{ 
  int m ;
  int n ;
  char *type ;
  int *head ;
  int *bind ;
  char *stat ;
  int p ;
  double delta ;
  int q ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 2149
  m = csa->m;
#line 2151
  n = csa->n;
#line 2153
  type = csa->type;
#line 2154
  head = csa->head;
#line 2156
  bind = csa->bind;
#line 2158
  stat = csa->stat;
#line 2159
  p = csa->p;
#line 2160
  delta = csa->delta;
#line 2161
  q = csa->q;
#line 2165
  if (1 <= p) {
#line 2165
    if (p <= m) {
#line 2165
      tmp = 1;
    } else {
      {
#line 2165
      _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2165);
#line 2165
      tmp = 1;
      }
    }
  } else {
    {
#line 2165
    _glp_lib_xassert("1 <= p && p <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2165);
#line 2165
    tmp = 1;
    }
  }
#line 2166
  if (1 <= q) {
#line 2166
    if (q <= n) {
#line 2166
      tmp___0 = 1;
    } else {
      {
#line 2166
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2166);
#line 2166
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 2166
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2166);
#line 2166
    tmp___0 = 1;
    }
  }
#line 2169
  k = *(head + p);
#line 2169
  *(head + p) = *(head + (m + q));
#line 2169
  *(head + (m + q)) = k;
#line 2171
  *(bind + *(head + p)) = p;
#line 2171
  *(bind + *(head + (m + q))) = m + q;
#line 2173
  if ((int )*(type + k) == 5) {
#line 2174
    *(stat + q) = (char)5;
  } else
#line 2175
  if (delta > 0.0) {
#line 2178
    if ((int )*(type + k) == 2) {
#line 2178
      tmp___1 = 1;
    } else
#line 2178
    if ((int )*(type + k) == 4) {
#line 2178
      tmp___1 = 1;
    } else {
      {
#line 2178
      _glp_lib_xassert("type[k] == GLP_LO || type[k] == GLP_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2178);
#line 2178
      tmp___1 = 1;
      }
    }
#line 2180
    *(stat + q) = (char)2;
  } else {
#line 2185
    if ((int )*(type + k) == 3) {
#line 2185
      tmp___2 = 1;
    } else
#line 2185
    if ((int )*(type + k) == 4) {
#line 2185
      tmp___2 = 1;
    } else {
      {
#line 2185
      _glp_lib_xassert("type[k] == GLP_UP || type[k] == GLP_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2185);
#line 2185
      tmp___2 = 1;
      }
    }
#line 2187
    *(stat + q) = (char)3;
  }
#line 2189
  return;
}
}
#line 2198 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static int check_feas(struct csa *csa , double tol_dj ) 
{ 
  int m ;
  int n ;
  char *orig_type ;
  int *head ;
  double *cbar ;
  int j ;
  int k ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 2199
  m = csa->m;
#line 2200
  n = csa->n;
#line 2201
  orig_type = csa->orig_type;
#line 2202
  head = csa->head;
#line 2203
  cbar = csa->cbar;
#line 2205
  j = 1;
  {
#line 2205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2205
    if (! (j <= n)) {
#line 2205
      goto while_break;
    }
#line 2206
    k = *(head + (m + j));
#line 2208
    if (1 <= k) {
#line 2208
      if (k <= m + n) {
#line 2208
        tmp = 1;
      } else {
        {
#line 2208
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2208);
#line 2208
        tmp = 1;
        }
      }
    } else {
      {
#line 2208
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2208);
#line 2208
      tmp = 1;
      }
    }
#line 2210
    if (*(cbar + j) < - tol_dj) {
#line 2211
      if ((int )*(orig_type + k) == 2) {
#line 2212
        return (1);
      } else
#line 2211
      if ((int )*(orig_type + k) == 1) {
#line 2212
        return (1);
      }
    }
#line 2213
    if (*(cbar + j) > tol_dj) {
#line 2214
      if ((int )*(orig_type + k) == 3) {
#line 2215
        return (1);
      } else
#line 2214
      if ((int )*(orig_type + k) == 1) {
#line 2215
        return (1);
      }
    }
#line 2205
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2217
  return (0);
}
}
#line 2226 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void set_aux_bnds(struct csa *csa ) 
{ 
  int m ;
  int n ;
  char *type ;
  double *lb ;
  double *ub ;
  char *orig_type ;
  int *head ;
  char *stat ;
  double *cbar ;
  int j ;
  int k ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2227
  m = csa->m;
#line 2228
  n = csa->n;
#line 2229
  type = csa->type;
#line 2230
  lb = csa->lb;
#line 2231
  ub = csa->ub;
#line 2232
  orig_type = csa->orig_type;
#line 2233
  head = csa->head;
#line 2234
  stat = csa->stat;
#line 2235
  cbar = csa->cbar;
#line 2237
  k = 1;
  {
#line 2237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2237
    if (! (k <= m + n)) {
#line 2237
      goto while_break;
    }
    {
#line 2239
    if ((int )*(orig_type + k) == 1) {
#line 2239
      goto case_1;
    }
#line 2247
    if ((int )*(orig_type + k) == 2) {
#line 2247
      goto case_2;
    }
#line 2250
    if ((int )*(orig_type + k) == 3) {
#line 2250
      goto case_3;
    }
#line 2254
    if ((int )*(orig_type + k) == 5) {
#line 2254
      goto case_5;
    }
#line 2254
    if ((int )*(orig_type + k) == 4) {
#line 2254
      goto case_5;
    }
#line 2257
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2244
    *(type + k) = (char)4;
#line 2244
    *(lb + k) = - 1e3;
#line 2244
    *(ub + k) = 1e3;
#line 2246
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2248
    *(type + k) = (char)4;
#line 2248
    *(lb + k) = 0.0;
#line 2248
    *(ub + k) = 1.0;
#line 2249
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2251
    *(type + k) = (char)4;
#line 2251
    *(lb + k) = - 1.0;
#line 2251
    *(ub + k) = 0.0;
#line 2252
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 2255
    *(type + k) = (char)5;
#line 2255
    tmp = 0.0;
#line 2255
    *(ub + k) = tmp;
#line 2255
    *(lb + k) = tmp;
#line 2256
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2258
    if ((unsigned long )orig_type != (unsigned long )orig_type) {
#line 2258
      tmp___0 = 1;
    } else {
      {
#line 2258
      _glp_lib_xassert("orig_type != orig_type", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2258);
#line 2258
      tmp___0 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 2237
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2261
  j = 1;
  {
#line 2261
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2261
    if (! (j <= n)) {
#line 2261
      goto while_break___0;
    }
#line 2262
    k = *(head + (m + j));
#line 2264
    if (1 <= k) {
#line 2264
      if (k <= m + n) {
#line 2264
        tmp___1 = 1;
      } else {
        {
#line 2264
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2264);
#line 2264
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 2264
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2264);
#line 2264
      tmp___1 = 1;
      }
    }
#line 2266
    if ((int )*(type + k) == 5) {
#line 2267
      *(stat + j) = (char)5;
    } else
#line 2268
    if (*(cbar + j) >= 0.0) {
#line 2269
      *(stat + j) = (char)2;
    } else {
#line 2271
      *(stat + j) = (char)3;
    }
#line 2261
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2273
  return;
}
}
#line 2283 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void set_orig_bnds(struct csa *csa ) 
{ 
  int m ;
  int n ;
  char *type ;
  double *lb ;
  double *ub ;
  char *orig_type ;
  double *orig_lb ;
  double *orig_ub ;
  int *head ;
  char *stat ;
  double *cbar ;
  int j ;
  int k ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 2284
  m = csa->m;
#line 2285
  n = csa->n;
#line 2286
  type = csa->type;
#line 2287
  lb = csa->lb;
#line 2288
  ub = csa->ub;
#line 2289
  orig_type = csa->orig_type;
#line 2290
  orig_lb = csa->orig_lb;
#line 2291
  orig_ub = csa->orig_ub;
#line 2292
  head = csa->head;
#line 2293
  stat = csa->stat;
#line 2294
  cbar = csa->cbar;
#line 2296
  memcpy((void */* __restrict  */)(type + 1), (void const   */* __restrict  */)(orig_type + 1),
         (size_t )((unsigned long )(m + n) * sizeof(char )));
#line 2297
  memcpy((void */* __restrict  */)(lb + 1), (void const   */* __restrict  */)(orig_lb + 1),
         (size_t )((unsigned long )(m + n) * sizeof(double )));
#line 2298
  memcpy((void */* __restrict  */)(ub + 1), (void const   */* __restrict  */)(orig_ub + 1),
         (size_t )((unsigned long )(m + n) * sizeof(double )));
#line 2299
  j = 1;
  }
  {
#line 2299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2299
    if (! (j <= n)) {
#line 2299
      goto while_break;
    }
#line 2300
    k = *(head + (m + j));
#line 2302
    if (1 <= k) {
#line 2302
      if (k <= m + n) {
#line 2302
        tmp = 1;
      } else {
        {
#line 2302
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2302);
#line 2302
        tmp = 1;
        }
      }
    } else {
      {
#line 2302
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2302);
#line 2302
      tmp = 1;
      }
    }
    {
#line 2305
    if ((int )*(type + k) == 1) {
#line 2305
      goto case_1;
    }
#line 2308
    if ((int )*(type + k) == 2) {
#line 2308
      goto case_2;
    }
#line 2311
    if ((int )*(type + k) == 3) {
#line 2311
      goto case_3;
    }
#line 2314
    if ((int )*(type + k) == 4) {
#line 2314
      goto case_4;
    }
#line 2324
    if ((int )*(type + k) == 5) {
#line 2324
      goto case_5;
    }
#line 2327
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2306
    *(stat + j) = (char)4;
#line 2307
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2309
    *(stat + j) = (char)2;
#line 2310
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2312
    *(stat + j) = (char)3;
#line 2313
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2315
    if (*(cbar + j) >= 2.2204460492503131e-16) {
#line 2316
      *(stat + j) = (char)2;
    } else
#line 2317
    if (*(cbar + j) <= - 2.2204460492503131e-16) {
#line 2318
      *(stat + j) = (char)3;
    } else {
      {
#line 2319
      tmp___0 = fabs(*(lb + k));
#line 2319
      tmp___1 = fabs(*(ub + k));
      }
#line 2319
      if (tmp___0 <= tmp___1) {
#line 2320
        *(stat + j) = (char)2;
      } else {
#line 2322
        *(stat + j) = (char)3;
      }
    }
#line 2323
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2325
    *(stat + j) = (char)5;
#line 2326
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2328
    if ((unsigned long )type != (unsigned long )type) {
#line 2328
      tmp___2 = 1;
    } else {
      {
#line 2328
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2328);
#line 2328
      tmp___2 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 2299
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2331
  return;
}
}
#line 2340 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static int check_stab(struct csa *csa , double tol_dj ) 
{ 
  int n ;
  char *stat ;
  double *cbar ;
  int j ;

  {
#line 2341
  n = csa->n;
#line 2342
  stat = csa->stat;
#line 2343
  cbar = csa->cbar;
#line 2345
  j = 1;
  {
#line 2345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2345
    if (! (j <= n)) {
#line 2345
      goto while_break;
    }
#line 2346
    if (*(cbar + j) < - tol_dj) {
#line 2347
      if ((int )*(stat + j) == 2) {
#line 2347
        return (1);
      } else
#line 2347
      if ((int )*(stat + j) == 4) {
#line 2347
        return (1);
      }
    }
#line 2348
    if (*(cbar + j) > tol_dj) {
#line 2349
      if ((int )*(stat + j) == 3) {
#line 2349
        return (1);
      } else
#line 2349
      if ((int )*(stat + j) == 4) {
#line 2349
        return (1);
      }
    }
#line 2345
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2351
  return (0);
}
}
#line 2361 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static double eval_obj(struct csa *csa ) 
{ 
  int m ;
  int n ;
  double *obj ;
  int *head ;
  double *bbar ;
  int i ;
  int j ;
  int k ;
  double sum ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2362
  m = csa->m;
#line 2363
  n = csa->n;
#line 2364
  obj = csa->obj;
#line 2365
  head = csa->head;
#line 2366
  bbar = csa->bbar;
#line 2369
  sum = *(obj + 0);
#line 2371
  i = 1;
  {
#line 2371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2371
    if (! (i <= m)) {
#line 2371
      goto while_break;
    }
#line 2372
    k = *(head + i);
#line 2374
    if (1 <= k) {
#line 2374
      if (k <= m + n) {
#line 2374
        tmp = 1;
      } else {
        {
#line 2374
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2374);
#line 2374
        tmp = 1;
        }
      }
    } else {
      {
#line 2374
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2374);
#line 2374
      tmp = 1;
      }
    }
#line 2376
    if (k > m) {
#line 2377
      sum += *(obj + (k - m)) * *(bbar + i);
    }
#line 2371
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2380
  j = 1;
  {
#line 2380
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2380
    if (! (j <= n)) {
#line 2380
      goto while_break___0;
    }
#line 2381
    k = *(head + (m + j));
#line 2383
    if (1 <= k) {
#line 2383
      if (k <= m + n) {
#line 2383
        tmp___0 = 1;
      } else {
        {
#line 2383
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2383);
#line 2383
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 2383
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2383);
#line 2383
      tmp___0 = 1;
      }
    }
#line 2385
    if (k > m) {
      {
#line 2386
      tmp___1 = get_xN(csa, j);
#line 2386
      sum += *(obj + (k - m)) * tmp___1;
      }
    }
#line 2380
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2388
  return (sum);
}
}
#line 2397 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void display(struct csa *csa , glp_smcp const   *parm , int spec ) 
{ 
  int m ;
  int n ;
  double *coef ;
  char *orig_type ;
  int *head ;
  char *stat ;
  int phase ;
  double *bbar ;
  double *cbar ;
  int i ;
  int j ;
  int cnt ;
  double sum ;
  xlong_t tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 2398
  m = csa->m;
#line 2399
  n = csa->n;
#line 2400
  coef = csa->coef;
#line 2401
  orig_type = csa->orig_type;
#line 2402
  head = csa->head;
#line 2403
  stat = csa->stat;
#line 2404
  phase = csa->phase;
#line 2405
  bbar = csa->bbar;
#line 2406
  cbar = csa->cbar;
#line 2409
  if (parm->msg_lev < 2) {
#line 2409
    goto skip;
  }
#line 2410
  if (parm->out_dly > 0) {
    {
#line 2410
    tmp = _glp_lib_xtime();
#line 2410
    tmp___0 = _glp_lib_xdifftime(tmp, csa->tm_beg);
    }
#line 2410
    if (1000.0 * tmp___0 < (double )parm->out_dly) {
#line 2412
      goto skip;
    }
  }
#line 2413
  if (csa->it_cnt == csa->it_dpy) {
#line 2413
    goto skip;
  }
#line 2414
  if (! spec) {
#line 2414
    if (csa->it_cnt % (int )parm->out_frq != 0) {
#line 2414
      goto skip;
    }
  }
#line 2416
  sum = 0.0;
#line 2417
  if (phase == 1) {
#line 2418
    i = 1;
    {
#line 2418
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2418
      if (! (i <= m)) {
#line 2418
        goto while_break;
      }
#line 2419
      sum -= *(coef + *(head + i)) * *(bbar + i);
#line 2418
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2420
    j = 1;
    {
#line 2420
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2420
      if (! (j <= n)) {
#line 2420
        goto while_break___0;
      }
      {
#line 2421
      tmp___1 = get_xN(csa, j);
#line 2421
      sum -= *(coef + *(head + (m + j))) * tmp___1;
#line 2420
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 2424
    j = 1;
    {
#line 2424
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2424
      if (! (j <= n)) {
#line 2424
        goto while_break___1;
      }
#line 2425
      if (*(cbar + j) < 0.0) {
#line 2426
        if ((int )*(stat + j) == 2) {
#line 2427
          sum -= *(cbar + j);
        } else
#line 2426
        if ((int )*(stat + j) == 4) {
#line 2427
          sum -= *(cbar + j);
        }
      }
#line 2428
      if (*(cbar + j) > 0.0) {
#line 2429
        if ((int )*(stat + j) == 3) {
#line 2430
          sum += *(cbar + j);
        } else
#line 2429
        if ((int )*(stat + j) == 4) {
#line 2430
          sum += *(cbar + j);
        }
      }
#line 2424
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2434
  cnt = 0;
#line 2435
  i = 1;
  {
#line 2435
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2435
    if (! (i <= m)) {
#line 2435
      goto while_break___2;
    }
#line 2436
    if ((int )*(orig_type + *(head + i)) == 5) {
#line 2436
      cnt ++;
    }
#line 2435
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2437
  if (csa->phase == 1) {
    {
#line 2438
    _glp_lib_xprintf(" %6d: %24s infeas = %10.3e (%d)\n", csa->it_cnt, "", sum, cnt);
    }
  } else {
    {
#line 2441
    tmp___2 = eval_obj(csa);
#line 2441
    _glp_lib_xprintf("|%6d: obj = %17.9e  infeas = %10.3e (%d)\n", csa->it_cnt, tmp___2,
                     sum, cnt);
    }
  }
#line 2443
  csa->it_dpy = csa->it_cnt;
  skip: 
#line 2444
  return;
}
}
#line 2454 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void store_sol(struct csa *csa , glp_prob *lp , int p_stat , int d_stat , int ray ) 
{ 
  int m ;
  int n ;
  double zeta ;
  int *head ;
  char *stat ;
  double *bbar ;
  double *cbar ;
  int i ;
  int j ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  GLPROW *row ;
  GLPCOL *col ;
  int tmp___4 ;
  GLPROW *row___0 ;
  int tmp___5 ;
  GLPCOL *col___0 ;
  int tmp___6 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 2456
  m = csa->m;
#line 2457
  n = csa->n;
#line 2458
  zeta = csa->zeta;
#line 2459
  head = csa->head;
#line 2460
  stat = csa->stat;
#line 2461
  bbar = csa->bbar;
#line 2462
  cbar = csa->cbar;
#line 2465
  if (lp->m == m) {
#line 2465
    tmp = 1;
  } else {
    {
#line 2465
    _glp_lib_xassert("lp->m == m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2465);
#line 2465
    tmp = 1;
    }
  }
#line 2466
  if (lp->n == n) {
#line 2466
    tmp___0 = 1;
  } else {
    {
#line 2466
    _glp_lib_xassert("lp->n == n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2466);
#line 2466
    tmp___0 = 1;
    }
  }
#line 2470
  if (! lp->valid) {
#line 2470
    if ((unsigned long )lp->bfd == (unsigned long )((void *)0)) {
#line 2470
      tmp___1 = 1;
    } else {
      {
#line 2470
      _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2470);
#line 2470
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 2470
    _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2470);
#line 2470
    tmp___1 = 1;
    }
  }
#line 2471
  if (csa->valid) {
#line 2471
    if ((unsigned long )csa->bfd != (unsigned long )((void *)0)) {
#line 2471
      tmp___2 = 1;
    } else {
      {
#line 2471
      _glp_lib_xassert("csa->valid && csa->bfd != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2471);
#line 2471
      tmp___2 = 1;
      }
    }
  } else {
    {
#line 2471
    _glp_lib_xassert("csa->valid && csa->bfd != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2471);
#line 2471
    tmp___2 = 1;
    }
  }
  {
#line 2473
  lp->valid = 1;
#line 2473
  csa->valid = 0;
#line 2474
  lp->bfd = csa->bfd;
#line 2474
  csa->bfd = (BFD *)((void *)0);
#line 2475
  memcpy((void */* __restrict  */)(lp->head + 1), (void const   */* __restrict  */)(head + 1),
         (size_t )((unsigned long )m * sizeof(int )));
#line 2477
  lp->pbs_stat = p_stat;
#line 2478
  lp->dbs_stat = d_stat;
#line 2480
  lp->obj_val = eval_obj(csa);
#line 2482
  lp->it_cnt = csa->it_cnt;
#line 2484
  lp->some = ray;
#line 2486
  i = 1;
  }
  {
#line 2486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2486
    if (! (i <= m)) {
#line 2486
      goto while_break;
    }
#line 2487
    k = *(head + i);
#line 2489
    if (1 <= k) {
#line 2489
      if (k <= m + n) {
#line 2489
        tmp___3 = 1;
      } else {
        {
#line 2489
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2489);
#line 2489
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 2489
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2489);
#line 2489
      tmp___3 = 1;
      }
    }
#line 2491
    if (k <= m) {
#line 2492
      row = *(lp->row + k);
#line 2493
      row->stat = 1;
#line 2494
      row->bind = i;
#line 2495
      row->prim = *(bbar + i) / row->rii;
#line 2496
      row->dual = 0.0;
    } else {
#line 2499
      col = *(lp->col + (k - m));
#line 2500
      col->stat = 1;
#line 2501
      col->bind = i;
#line 2502
      col->prim = *(bbar + i) * col->sjj;
#line 2503
      col->dual = 0.0;
    }
#line 2486
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2507
  j = 1;
  {
#line 2507
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2507
    if (! (j <= n)) {
#line 2507
      goto while_break___0;
    }
#line 2508
    k = *(head + (m + j));
#line 2510
    if (1 <= k) {
#line 2510
      if (k <= m + n) {
#line 2510
        tmp___4 = 1;
      } else {
        {
#line 2510
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2510);
#line 2510
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 2510
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2510);
#line 2510
      tmp___4 = 1;
      }
    }
#line 2512
    if (k <= m) {
#line 2513
      row___0 = *(lp->row + k);
#line 2514
      row___0->stat = (int )*(stat + j);
#line 2515
      row___0->bind = 0;
      {
#line 2520
      if ((int )*(stat + j) == 2) {
#line 2520
        goto case_2;
      }
#line 2522
      if ((int )*(stat + j) == 3) {
#line 2522
        goto case_3;
      }
#line 2524
      if ((int )*(stat + j) == 4) {
#line 2524
        goto case_4;
      }
#line 2526
      if ((int )*(stat + j) == 5) {
#line 2526
        goto case_5;
      }
#line 2528
      goto switch_default;
      case_2: /* CIL Label */ 
#line 2521
      row___0->prim = row___0->lb;
#line 2521
      goto switch_break;
      case_3: /* CIL Label */ 
#line 2523
      row___0->prim = row___0->ub;
#line 2523
      goto switch_break;
      case_4: /* CIL Label */ 
#line 2525
      row___0->prim = 0.0;
#line 2525
      goto switch_break;
      case_5: /* CIL Label */ 
#line 2527
      row___0->prim = row___0->lb;
#line 2527
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2529
      if ((unsigned long )stat != (unsigned long )stat) {
#line 2529
        tmp___5 = 1;
      } else {
        {
#line 2529
        _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2529);
#line 2529
        tmp___5 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 2532
      row___0->dual = (*(cbar + j) * row___0->rii) / zeta;
    } else {
#line 2535
      col___0 = *(lp->col + (k - m));
#line 2536
      col___0->stat = (int )*(stat + j);
#line 2537
      col___0->bind = 0;
      {
#line 2542
      if ((int )*(stat + j) == 2) {
#line 2542
        goto case_2___0;
      }
#line 2544
      if ((int )*(stat + j) == 3) {
#line 2544
        goto case_3___0;
      }
#line 2546
      if ((int )*(stat + j) == 4) {
#line 2546
        goto case_4___0;
      }
#line 2548
      if ((int )*(stat + j) == 5) {
#line 2548
        goto case_5___0;
      }
#line 2550
      goto switch_default___0;
      case_2___0: /* CIL Label */ 
#line 2543
      col___0->prim = col___0->lb;
#line 2543
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 2545
      col___0->prim = col___0->ub;
#line 2545
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 2547
      col___0->prim = 0.0;
#line 2547
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
#line 2549
      col___0->prim = col___0->lb;
#line 2549
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2551
      if ((unsigned long )stat != (unsigned long )stat) {
#line 2551
        tmp___6 = 1;
      } else {
        {
#line 2551
        _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2551);
#line 2551
        tmp___6 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 2554
      col___0->dual = (*(cbar + j) / col___0->sjj) / zeta;
    }
#line 2507
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2557
  return;
}
}
#line 2567 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
static void free_csa(struct csa *csa ) 
{ 


  {
  {
#line 2568
  _glp_lib_xfree((void *)csa->type);
#line 2569
  _glp_lib_xfree((void *)csa->lb);
#line 2570
  _glp_lib_xfree((void *)csa->ub);
#line 2571
  _glp_lib_xfree((void *)csa->coef);
#line 2572
  _glp_lib_xfree((void *)csa->orig_type);
#line 2573
  _glp_lib_xfree((void *)csa->orig_lb);
#line 2574
  _glp_lib_xfree((void *)csa->orig_ub);
#line 2575
  _glp_lib_xfree((void *)csa->obj);
#line 2576
  _glp_lib_xfree((void *)csa->A_ptr);
#line 2577
  _glp_lib_xfree((void *)csa->A_ind);
#line 2578
  _glp_lib_xfree((void *)csa->A_val);
#line 2580
  _glp_lib_xfree((void *)csa->AT_ptr);
#line 2581
  _glp_lib_xfree((void *)csa->AT_ind);
#line 2582
  _glp_lib_xfree((void *)csa->AT_val);
#line 2584
  _glp_lib_xfree((void *)csa->head);
#line 2586
  _glp_lib_xfree((void *)csa->bind);
#line 2588
  _glp_lib_xfree((void *)csa->stat);
#line 2595
  _glp_lib_xfree((void *)csa->bbar);
#line 2596
  _glp_lib_xfree((void *)csa->cbar);
#line 2597
  _glp_lib_xfree((void *)csa->refsp);
#line 2598
  _glp_lib_xfree((void *)csa->gamma);
#line 2599
  _glp_lib_xfree((void *)csa->trow_ind);
#line 2600
  _glp_lib_xfree((void *)csa->trow_vec);
#line 2604
  _glp_lib_xfree((void *)csa->tcol_ind);
#line 2605
  _glp_lib_xfree((void *)csa->tcol_vec);
#line 2606
  _glp_lib_xfree((void *)csa->work1);
#line 2607
  _glp_lib_xfree((void *)csa->work2);
#line 2608
  _glp_lib_xfree((void *)csa->work3);
#line 2609
  _glp_lib_xfree((void *)csa->work4);
#line 2610
  _glp_lib_xfree((void *)csa);
  }
#line 2611
  return;
}
}
#line 2646 "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c"
int _glp_spx_dual(glp_prob *lp , glp_smcp const   *parm ) 
{ 
  struct csa *csa ;
  int binv_st ;
  int bbar_st ;
  int cbar_st ;
  int rigorous ;
  int check ;
  int p_stat ;
  int d_stat ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  double e_bbar ;
  double tmp___10 ;
  double e_cbar ;
  double tmp___11 ;
  double e_gamma ;
  double tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  xlong_t tmp___17 ;
  double tmp___18 ;
  int tmp___19 ;
  double *rho ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  double piv ;
  double eps ;
  double tmp___24 ;
  double piv1 ;
  double piv2 ;
  int tmp___25 ;
  int tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  int tmp___29 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;

  {
  {
#line 2648
  binv_st = 2;
#line 2651
  bbar_st = 0;
#line 2654
  cbar_st = 0;
#line 2657
  rigorous = 0;
#line 2661
  check = 0;
#line 2664
  csa = alloc_csa(lp);
#line 2665
  init_csa(csa, lp);
  }
#line 2666
  if (parm->msg_lev >= 4) {
    {
#line 2667
    _glp_lib_xprintf("Objective scale factor = %g\n", csa->zeta);
    }
  }
  loop: 
#line 2670
  if (binv_st == 0) {
    {
#line 2671
    ret = invert_B(csa);
    }
#line 2672
    if (ret != 0) {
#line 2673
      if (parm->msg_lev >= 1) {
        {
#line 2674
        _glp_lib_xprintf("Error: unable to factorize the basis matrix (%d)\n", ret);
#line 2676
        _glp_lib_xprintf("Sorry, basis recovery procedure not implemented yet\n");
        }
      }
#line 2679
      if (! lp->valid) {
#line 2679
        if ((unsigned long )lp->bfd == (unsigned long )((void *)0)) {
#line 2679
          tmp = 1;
        } else {
          {
#line 2679
          _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                           2679);
#line 2679
          tmp = 1;
          }
        }
      } else {
        {
#line 2679
        _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2679);
#line 2679
        tmp = 1;
        }
      }
#line 2680
      lp->bfd = csa->bfd;
#line 2680
      csa->bfd = (BFD *)((void *)0);
#line 2681
      tmp___0 = 1;
#line 2681
      lp->dbs_stat = tmp___0;
#line 2681
      lp->pbs_stat = tmp___0;
#line 2682
      lp->obj_val = 0.0;
#line 2683
      lp->it_cnt = csa->it_cnt;
#line 2684
      lp->some = 0;
#line 2685
      ret = 5;
#line 2686
      goto done;
    }
#line 2688
    csa->valid = 1;
#line 2689
    binv_st = 1;
#line 2691
    cbar_st = 0;
#line 2691
    bbar_st = cbar_st;
  }
#line 2694
  if (cbar_st == 0) {
    {
#line 2695
    eval_cbar(csa);
#line 2696
    cbar_st = 1;
    }
#line 2698
    if (csa->phase == 0) {
      {
#line 2699
      tmp___1 = check_feas(csa, 0.90 * (double )parm->tol_dj);
      }
#line 2699
      if (tmp___1 != 0) {
        {
#line 2702
        csa->phase = 1;
#line 2703
        set_aux_bnds(csa);
        }
      } else {
        {
#line 2708
        csa->phase = 2;
#line 2709
        set_orig_bnds(csa);
        }
      }
      {
#line 2711
      tmp___2 = check_stab(csa, (double )parm->tol_dj);
      }
#line 2711
      if (tmp___2 == 0) {
#line 2711
        tmp___3 = 1;
      } else {
        {
#line 2711
        _glp_lib_xassert("check_stab(csa, parm->tol_dj) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2711);
#line 2711
        tmp___3 = 1;
        }
      }
#line 2717
      csa->refct = 0;
#line 2720
      bbar_st = 0;
    }
    {
#line 2724
    tmp___5 = check_stab(csa, (double )parm->tol_dj);
    }
#line 2724
    if (tmp___5 != 0) {
#line 2725
      if (parm->msg_lev >= 1) {
#line 2726
        if (csa->phase == 1) {
#line 2726
          tmp___4 = "I";
        } else {
#line 2726
          tmp___4 = "II";
        }
        {
#line 2726
        _glp_lib_xprintf("Warning: numerical instability (dual simplex, phase %s)\n",
                         tmp___4);
        }
      }
#line 2729
      if (parm->meth == 2) {
        {
#line 2730
        store_sol(csa, lp, 1, 1, 0);
#line 2731
        ret = 5;
        }
#line 2732
        goto done;
      }
#line 2736
      csa->phase = 0;
#line 2737
      binv_st = 0;
#line 2738
      rigorous = 5;
#line 2739
      goto loop;
    }
  }
#line 2742
  if (csa->phase == 1) {
#line 2742
    tmp___6 = 1;
  } else
#line 2742
  if (csa->phase == 2) {
#line 2742
    tmp___6 = 1;
  } else {
    {
#line 2742
    _glp_lib_xassert("csa->phase == 1 || csa->phase == 2", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2742);
#line 2742
    tmp___6 = 1;
    }
  }
#line 2746
  if (csa->phase == 1) {
    {
#line 2746
    tmp___7 = check_feas(csa, (double )parm->tol_dj);
    }
#line 2746
    if (tmp___7 == 0) {
      {
#line 2748
      display(csa, parm, 1);
#line 2749
      csa->phase = 2;
      }
#line 2750
      if (cbar_st != 1) {
        {
#line 2751
        eval_cbar(csa);
#line 2752
        cbar_st = 1;
        }
      }
      {
#line 2754
      set_orig_bnds(csa);
#line 2758
      csa->refct = 0;
#line 2759
      bbar_st = 0;
      }
    }
  }
#line 2762
  if (bbar_st == 0) {
    {
#line 2763
    eval_bbar(csa);
    }
#line 2764
    if (csa->phase == 2) {
      {
#line 2765
      *(csa->bbar + 0) = eval_obj(csa);
      }
    }
#line 2766
    bbar_st = 1;
  }
  {
#line 2770
  if (parm->pricing == 17) {
#line 2770
    goto case_17;
  }
#line 2772
  if (parm->pricing == 34) {
#line 2772
    goto case_34;
  }
#line 2775
  goto switch_default;
  case_17: /* CIL Label */ 
#line 2771
  goto switch_break;
  case_34: /* CIL Label */ 
#line 2773
  if (csa->refct == 0) {
    {
#line 2773
    reset_refsp(csa);
    }
  }
#line 2774
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2776
  if ((unsigned long )parm != (unsigned long )parm) {
#line 2776
    tmp___8 = 1;
  } else {
    {
#line 2776
    _glp_lib_xassert("parm != parm", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2776);
#line 2776
    tmp___8 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 2780
  if (binv_st) {
#line 2780
    if (bbar_st) {
#line 2780
      if (cbar_st) {
#line 2780
        tmp___9 = 1;
      } else {
        {
#line 2780
        _glp_lib_xassert("binv_st && bbar_st && cbar_st", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2780);
#line 2780
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 2780
      _glp_lib_xassert("binv_st && bbar_st && cbar_st", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2780);
#line 2780
      tmp___9 = 1;
      }
    }
  } else {
    {
#line 2780
    _glp_lib_xassert("binv_st && bbar_st && cbar_st", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2780);
#line 2780
    tmp___9 = 1;
    }
  }
#line 2783
  if (check) {
    {
#line 2784
    tmp___10 = err_in_bbar(csa);
#line 2784
    e_bbar = tmp___10;
#line 2785
    tmp___11 = err_in_cbar(csa);
#line 2785
    e_cbar = tmp___11;
    }
#line 2786
    if (parm->pricing == 34) {
      {
#line 2786
      tmp___12 = err_in_gamma(csa);
#line 2786
      tmp___13 = tmp___12;
      }
    } else {
#line 2786
      tmp___13 = 0.0;
    }
    {
#line 2786
    e_gamma = tmp___13;
#line 2788
    _glp_lib_xprintf("e_bbar = %10.3e; e_cbar = %10.3e; e_gamma = %10.3e\n", e_bbar,
                     e_cbar, e_gamma);
    }
#line 2790
    if (e_bbar <= 1e-5) {
#line 2790
      if (e_cbar <= 1e-5) {
#line 2790
        if (e_gamma <= 1e-3) {
#line 2790
          tmp___14 = 1;
        } else {
          {
#line 2790
          _glp_lib_xassert("e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3",
                           "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c", 2790);
#line 2790
          tmp___14 = 1;
          }
        }
      } else {
        {
#line 2790
        _glp_lib_xassert("e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2790);
#line 2790
        tmp___14 = 1;
        }
      }
    } else {
      {
#line 2790
      _glp_lib_xassert("e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2790);
#line 2790
      tmp___14 = 1;
      }
    }
  }
#line 2794
  if (csa->phase == 2) {
#line 2794
    if (csa->zeta < 0.0) {
#line 2794
      if (parm->obj_ll > (double const   )(- 1.7976931348623157e+308)) {
#line 2794
        if (*(csa->bbar + 0) <= (double )parm->obj_ll) {
#line 2796
          if (bbar_st != 1) {
#line 2796
            goto _L;
          } else
#line 2796
          if (cbar_st != 1) {
            _L: /* CIL Label */ 
#line 2797
            if (bbar_st != 1) {
#line 2797
              bbar_st = 0;
            }
#line 2798
            if (cbar_st != 1) {
#line 2798
              cbar_st = 0;
            }
#line 2799
            goto loop;
          }
          {
#line 2801
          display(csa, parm, 1);
          }
#line 2802
          if (parm->msg_lev >= 3) {
            {
#line 2803
            _glp_lib_xprintf("OBJECTIVE LOWER LIMIT REACHED; SEARCH TERMINATED\n");
            }
          }
          {
#line 2805
          store_sol(csa, lp, 3, 2, 0);
#line 2806
          ret = 6;
          }
#line 2807
          goto done;
        }
      }
    }
  }
#line 2811
  if (csa->phase == 2) {
#line 2811
    if (csa->zeta > 0.0) {
#line 2811
      if (parm->obj_ul < (double const   )1.7976931348623157e+308) {
#line 2811
        if (*(csa->bbar + 0) >= (double )parm->obj_ul) {
#line 2813
          if (bbar_st != 1) {
#line 2813
            goto _L___0;
          } else
#line 2813
          if (cbar_st != 1) {
            _L___0: /* CIL Label */ 
#line 2814
            if (bbar_st != 1) {
#line 2814
              bbar_st = 0;
            }
#line 2815
            if (cbar_st != 1) {
#line 2815
              cbar_st = 0;
            }
#line 2816
            goto loop;
          }
          {
#line 2818
          display(csa, parm, 1);
          }
#line 2819
          if (parm->msg_lev >= 3) {
            {
#line 2820
            _glp_lib_xprintf("OBJECTIVE UPPER LIMIT REACHED; SEARCH TERMINATED\n");
            }
          }
          {
#line 2822
          store_sol(csa, lp, 3, 2, 0);
#line 2823
          ret = 7;
          }
#line 2824
          goto done;
        }
      }
    }
  }
#line 2827
  if (parm->it_lim < 2147483647) {
#line 2827
    if (csa->it_cnt - csa->it_beg >= (int )parm->it_lim) {
#line 2829
      if (csa->phase == 2) {
#line 2829
        if (bbar_st != 1) {
#line 2829
          goto _L___1;
        } else {
#line 2829
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 2829
      if (cbar_st != 1) {
        _L___1: /* CIL Label */ 
#line 2830
        if (csa->phase == 2) {
#line 2830
          if (bbar_st != 1) {
#line 2830
            bbar_st = 0;
          }
        }
#line 2831
        if (cbar_st != 1) {
#line 2831
          cbar_st = 0;
        }
#line 2832
        goto loop;
      }
      {
#line 2834
      display(csa, parm, 1);
      }
#line 2835
      if (parm->msg_lev >= 3) {
        {
#line 2836
        _glp_lib_xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
        }
      }
      {
#line 2838
      if (csa->phase == 1) {
#line 2838
        goto case_1;
      }
#line 2843
      if (csa->phase == 2) {
#line 2843
        goto case_2;
      }
#line 2846
      goto switch_default___0;
      case_1: /* CIL Label */ 
      {
#line 2839
      d_stat = 3;
#line 2840
      set_orig_bnds(csa);
#line 2841
      eval_bbar(csa);
      }
#line 2842
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 2844
      d_stat = 2;
#line 2845
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2847
      if ((unsigned long )csa != (unsigned long )csa) {
#line 2847
        tmp___15 = 1;
      } else {
        {
#line 2847
        _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2847);
#line 2847
        tmp___15 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 2849
      store_sol(csa, lp, 3, d_stat, 0);
#line 2850
      ret = 8;
      }
#line 2851
      goto done;
    }
  }
#line 2854
  if (parm->tm_lim < 2147483647) {
    {
#line 2854
    tmp___17 = _glp_lib_xtime();
#line 2854
    tmp___18 = _glp_lib_xdifftime(tmp___17, csa->tm_beg);
    }
#line 2854
    if (1000.0 * tmp___18 >= (double )parm->tm_lim) {
#line 2856
      if (csa->phase == 2) {
#line 2856
        if (bbar_st != 1) {
#line 2856
          goto _L___3;
        } else {
#line 2856
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 2856
      if (cbar_st != 1) {
        _L___3: /* CIL Label */ 
#line 2857
        if (csa->phase == 2) {
#line 2857
          if (bbar_st != 1) {
#line 2857
            bbar_st = 0;
          }
        }
#line 2858
        if (cbar_st != 1) {
#line 2858
          cbar_st = 0;
        }
#line 2859
        goto loop;
      }
      {
#line 2861
      display(csa, parm, 1);
      }
#line 2862
      if (parm->msg_lev >= 3) {
        {
#line 2863
        _glp_lib_xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
        }
      }
      {
#line 2865
      if (csa->phase == 1) {
#line 2865
        goto case_1___0;
      }
#line 2870
      if (csa->phase == 2) {
#line 2870
        goto case_2___0;
      }
#line 2873
      goto switch_default___1;
      case_1___0: /* CIL Label */ 
      {
#line 2866
      d_stat = 3;
#line 2867
      set_orig_bnds(csa);
#line 2868
      eval_bbar(csa);
      }
#line 2869
      goto switch_break___1;
      case_2___0: /* CIL Label */ 
#line 2871
      d_stat = 2;
#line 2872
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 2874
      if ((unsigned long )csa != (unsigned long )csa) {
#line 2874
        tmp___16 = 1;
      } else {
        {
#line 2874
        _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2874);
#line 2874
        tmp___16 = 1;
        }
      }
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 2876
      store_sol(csa, lp, 3, d_stat, 0);
#line 2877
      ret = 9;
      }
#line 2878
      goto done;
    }
  }
  {
#line 2881
  display(csa, parm, 0);
#line 2883
  chuzr(csa, (double )parm->tol_bnd);
  }
#line 2884
  if (csa->p == 0) {
#line 2885
    if (bbar_st != 1) {
#line 2885
      goto _L___5;
    } else
#line 2885
    if (cbar_st != 1) {
      _L___5: /* CIL Label */ 
#line 2886
      if (bbar_st != 1) {
#line 2886
        bbar_st = 0;
      }
#line 2887
      if (cbar_st != 1) {
#line 2887
        cbar_st = 0;
      }
#line 2888
      goto loop;
    }
    {
#line 2890
    display(csa, parm, 1);
    }
    {
#line 2892
    if (csa->phase == 1) {
#line 2892
      goto case_1___1;
    }
#line 2899
    if (csa->phase == 2) {
#line 2899
      goto case_2___1;
    }
#line 2904
    goto switch_default___2;
    case_1___1: /* CIL Label */ 
#line 2893
    if (parm->msg_lev >= 3) {
      {
#line 2894
      _glp_lib_xprintf("PROBLEM HAS NO DUAL FEASIBLE SOLUTION\n");
      }
    }
    {
#line 2895
    set_orig_bnds(csa);
#line 2896
    eval_bbar(csa);
#line 2897
    p_stat = 3;
#line 2897
    d_stat = 4;
    }
#line 2898
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
#line 2900
    if (parm->msg_lev >= 3) {
      {
#line 2901
      _glp_lib_xprintf("OPTIMAL SOLUTION FOUND\n");
      }
    }
#line 2902
    d_stat = 2;
#line 2902
    p_stat = d_stat;
#line 2903
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2905
    if ((unsigned long )csa != (unsigned long )csa) {
#line 2905
      tmp___19 = 1;
    } else {
      {
#line 2905
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2905);
#line 2905
      tmp___19 = 1;
      }
    }
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 2907
    store_sol(csa, lp, p_stat, d_stat, 0);
#line 2908
    ret = 0;
    }
#line 2909
    goto done;
  }
  {
#line 2912
  rho = csa->work4;
#line 2913
  eval_rho(csa, rho);
  }
#line 2914
  if (rigorous) {
    {
#line 2914
    refine_rho(csa, rho);
    }
  }
  {
#line 2915
  eval_trow(csa, rho);
#line 2916
  sort_trow(csa, (double )parm->tol_bnd);
  }
  {
#line 2934
  if (parm->r_test == 17) {
#line 2934
    goto case_17___0;
  }
#line 2937
  if (parm->r_test == 34) {
#line 2937
    goto case_34___0;
  }
#line 2940
  goto switch_default___3;
  case_17___0: /* CIL Label */ 
  {
#line 2935
  chuzc(csa, 0.0);
  }
#line 2936
  goto switch_break___3;
  case_34___0: /* CIL Label */ 
  {
#line 2938
  chuzc(csa, 0.30 * (double )parm->tol_dj);
  }
#line 2939
  goto switch_break___3;
  switch_default___3: /* CIL Label */ 
#line 2941
  if ((unsigned long )parm != (unsigned long )parm) {
#line 2941
    tmp___20 = 1;
  } else {
    {
#line 2941
    _glp_lib_xassert("parm != parm", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2941);
#line 2941
    tmp___20 = 1;
    }
  }
  switch_break___3: /* CIL Label */ ;
  }
#line 2943
  if (csa->q == 0) {
#line 2944
    if (bbar_st != 1) {
#line 2944
      goto _L___6;
    } else
#line 2944
    if (cbar_st != 1) {
#line 2944
      goto _L___6;
    } else
#line 2944
    if (! rigorous) {
      _L___6: /* CIL Label */ 
#line 2945
      if (bbar_st != 1) {
#line 2945
        bbar_st = 0;
      }
#line 2946
      if (cbar_st != 1) {
#line 2946
        cbar_st = 0;
      }
#line 2947
      rigorous = 1;
#line 2948
      goto loop;
    }
    {
#line 2950
    display(csa, parm, 1);
    }
    {
#line 2952
    if (csa->phase == 1) {
#line 2952
      goto case_1___2;
    }
#line 2964
    if (csa->phase == 2) {
#line 2964
      goto case_2___2;
    }
#line 2971
    goto switch_default___4;
    case_1___2: /* CIL Label */ 
#line 2953
    if (parm->msg_lev >= 1) {
      {
#line 2954
      _glp_lib_xprintf("Error: unable to choose basic variable on phase I\n");
      }
    }
#line 2956
    if (! lp->valid) {
#line 2956
      if ((unsigned long )lp->bfd == (unsigned long )((void *)0)) {
#line 2956
        tmp___21 = 1;
      } else {
        {
#line 2956
        _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         2956);
#line 2956
        tmp___21 = 1;
        }
      }
    } else {
      {
#line 2956
      _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2956);
#line 2956
      tmp___21 = 1;
      }
    }
#line 2957
    lp->bfd = csa->bfd;
#line 2957
    csa->bfd = (BFD *)((void *)0);
#line 2958
    tmp___22 = 1;
#line 2958
    lp->dbs_stat = tmp___22;
#line 2958
    lp->pbs_stat = tmp___22;
#line 2959
    lp->obj_val = 0.0;
#line 2960
    lp->it_cnt = csa->it_cnt;
#line 2961
    lp->some = 0;
#line 2962
    ret = 5;
#line 2963
    goto switch_break___4;
    case_2___2: /* CIL Label */ 
#line 2965
    if (parm->msg_lev >= 3) {
      {
#line 2966
      _glp_lib_xprintf("PROBLEM HAS NO FEASIBLE SOLUTION\n");
      }
    }
    {
#line 2967
    store_sol(csa, lp, 4, 2, *(csa->head + csa->p));
#line 2969
    ret = 0;
    }
#line 2970
    goto switch_break___4;
    switch_default___4: /* CIL Label */ 
#line 2972
    if ((unsigned long )csa != (unsigned long )csa) {
#line 2972
      tmp___23 = 1;
    } else {
      {
#line 2972
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                       2972);
#line 2972
      tmp___23 = 1;
      }
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 2974
    goto done;
  }
  {
#line 2977
  piv = *(csa->trow_vec + csa->q);
#line 2978
  eps = 1e-5 * (1.0 + 0.01 * csa->trow_max);
#line 2979
  tmp___24 = fabs(piv);
  }
#line 2979
  if (tmp___24 < eps) {
#line 2980
    if (parm->msg_lev >= 4) {
      {
#line 2981
      _glp_lib_xprintf("piv = %.12g; eps = %g\n", piv, eps);
      }
    }
#line 2982
    if (! rigorous) {
#line 2983
      rigorous = 5;
#line 2984
      goto loop;
    }
  }
  {
#line 2990
  eval_tcol(csa);
  }
#line 2991
  if (rigorous) {
    {
#line 2991
    refine_tcol(csa);
    }
  }
#line 2993
  piv1 = *(csa->tcol_vec + csa->p);
#line 2994
  piv2 = *(csa->trow_vec + csa->q);
#line 2995
  if (piv1 != 0.0) {
#line 2995
    tmp___25 = 1;
  } else {
    {
#line 2995
    _glp_lib_xassert("piv1 != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     2995);
#line 2995
    tmp___25 = 1;
    }
  }
  {
#line 2996
  tmp___27 = fabs(piv1 - piv2);
#line 2996
  tmp___28 = fabs(piv1);
  }
#line 2996
  if (tmp___27 > 1e-8 * (1.0 + tmp___28)) {
#line 2996
    goto _L___9;
  } else
#line 2996
  if (piv1 > 0.0) {
#line 2996
    if (! (piv2 > 0.0)) {
#line 2996
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 2996
  if (piv1 < 0.0) {
#line 2996
    if (! (piv2 < 0.0)) {
#line 2996
      goto _L___9;
    }
  } else {
    _L___9: /* CIL Label */ 
#line 2998
    if (parm->msg_lev >= 4) {
      {
#line 2999
      _glp_lib_xprintf("piv1 = %.12g; piv2 = %.12g\n", piv1, piv2);
      }
    }
#line 3000
    if (binv_st != 1) {
#line 3000
      goto _L___7;
    } else
#line 3000
    if (! rigorous) {
      _L___7: /* CIL Label */ 
#line 3001
      if (binv_st != 1) {
#line 3001
        binv_st = 0;
      }
#line 3002
      rigorous = 5;
#line 3003
      goto loop;
    }
#line 3006
    if (*(csa->tcol_vec + csa->p) == 0.0) {
#line 3007
      (csa->tcol_nnz) ++;
#line 3008
      if (csa->tcol_nnz <= csa->m) {
#line 3008
        tmp___26 = 1;
      } else {
        {
#line 3008
        _glp_lib_xassert("csa->tcol_nnz <= csa->m", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                         3008);
#line 3008
        tmp___26 = 1;
        }
      }
#line 3009
      *(csa->tcol_ind + csa->tcol_nnz) = csa->p;
    }
#line 3011
    *(csa->tcol_vec + csa->p) = piv2;
  }
  {
#line 3031
  update_bbar(csa);
  }
#line 3032
  if (csa->phase == 2) {
#line 3033
    *(csa->bbar + 0) += (*(csa->cbar + csa->q) / csa->zeta) * (csa->delta / *(csa->tcol_vec + csa->p));
  }
  {
#line 3035
  bbar_st = 2;
#line 3038
  update_cbar(csa);
#line 3039
  cbar_st = 2;
  }
  {
#line 3042
  if (parm->pricing == 17) {
#line 3042
    goto case_17___1;
  }
#line 3044
  if (parm->pricing == 34) {
#line 3044
    goto case_34___1;
  }
#line 3047
  goto switch_default___5;
  case_17___1: /* CIL Label */ 
#line 3043
  goto switch_break___5;
  case_34___1: /* CIL Label */ 
#line 3045
  if (csa->refct > 0) {
    {
#line 3045
    update_gamma(csa);
    }
  }
#line 3046
  goto switch_break___5;
  switch_default___5: /* CIL Label */ 
#line 3048
  if ((unsigned long )parm != (unsigned long )parm) {
#line 3048
    tmp___29 = 1;
  } else {
    {
#line 3048
    _glp_lib_xassert("parm != parm", "/home/wslee/benchmarks/glpk-4.38/src/glpspx02.c",
                     3048);
#line 3048
    tmp___29 = 1;
    }
  }
  switch_break___5: /* CIL Label */ ;
  }
  {
#line 3051
  ret = update_B(csa, csa->p, *(csa->head + (csa->m + csa->q)));
  }
#line 3052
  if (ret == 0) {
#line 3053
    binv_st = 2;
  } else {
#line 3055
    csa->valid = 0;
#line 3056
    binv_st = 0;
  }
  {
#line 3065
  change_basis(csa);
#line 3067
  (csa->it_cnt) ++;
  }
#line 3068
  if (rigorous > 0) {
#line 3068
    rigorous --;
  }
#line 3069
  goto loop;
  done: 
  {
#line 3071
  free_csa(csa);
  }
#line 3073
  return (ret);
}
}
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpspx.h"
int _glp_spx_primal(glp_prob *lp , glp_smcp const   *parm ) ;
#line 238 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double const   kappa___0  =    (double const   )0.10;
#line 246 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static struct csa___0 *alloc_csa___0(glp_prob *lp ) 
{ 
  struct csa___0 *csa ;
  int m ;
  int n ;
  int nnz ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 248
  m = lp->m;
#line 249
  n = lp->n;
#line 250
  nnz = lp->nnz;
#line 251
  tmp = _glp_lib_xmalloc((int )sizeof(struct csa___0 ));
#line 251
  csa = (struct csa___0 *)tmp;
  }
#line 252
  if (m > 0) {
#line 252
    if (n > 0) {
#line 252
      tmp___0 = 1;
    } else {
      {
#line 252
      _glp_lib_xassert("m > 0 && n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       252);
#line 252
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 252
    _glp_lib_xassert("m > 0 && n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     252);
#line 252
    tmp___0 = 1;
    }
  }
  {
#line 253
  csa->m = m;
#line 254
  csa->n = n;
#line 255
  tmp___1 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(char ));
#line 255
  csa->type = (char *)tmp___1;
#line 256
  tmp___2 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 256
  csa->lb = (double *)tmp___2;
#line 257
  tmp___3 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 257
  csa->ub = (double *)tmp___3;
#line 258
  tmp___4 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 258
  csa->coef = (double *)tmp___4;
#line 259
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 259
  csa->obj = (double *)tmp___5;
#line 260
  tmp___6 = _glp_lib_xcalloc((1 + n) + 1, (int )sizeof(int ));
#line 260
  csa->A_ptr = (int *)tmp___6;
#line 261
  tmp___7 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(int ));
#line 261
  csa->A_ind = (int *)tmp___7;
#line 262
  tmp___8 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(double ));
#line 262
  csa->A_val = (double *)tmp___8;
#line 263
  tmp___9 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 263
  csa->head = (int *)tmp___9;
#line 264
  tmp___10 = _glp_lib_xcalloc(1 + n, (int )sizeof(char ));
#line 264
  csa->stat = (char *)tmp___10;
#line 265
  tmp___11 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 265
  csa->N_ptr = (int *)tmp___11;
#line 266
  tmp___12 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 266
  csa->N_len = (int *)tmp___12;
#line 267
  csa->N_ind = (int *)((void *)0);
#line 268
  csa->N_val = (double *)((void *)0);
#line 269
  tmp___13 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 269
  csa->bbar = (double *)tmp___13;
#line 270
  tmp___14 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 270
  csa->cbar = (double *)tmp___14;
#line 271
  tmp___15 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(char ));
#line 271
  csa->refsp = (char *)tmp___15;
#line 272
  tmp___16 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 272
  csa->gamma = (double *)tmp___16;
#line 273
  tmp___17 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 273
  csa->tcol_ind = (int *)tmp___17;
#line 274
  tmp___18 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 274
  csa->tcol_vec = (double *)tmp___18;
#line 275
  tmp___19 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 275
  csa->trow_ind = (int *)tmp___19;
#line 276
  tmp___20 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 276
  csa->trow_vec = (double *)tmp___20;
#line 277
  tmp___21 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 277
  csa->work1 = (double *)tmp___21;
#line 278
  tmp___22 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 278
  csa->work2 = (double *)tmp___22;
#line 279
  tmp___23 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 279
  csa->work3 = (double *)tmp___23;
#line 280
  tmp___24 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 280
  csa->work4 = (double *)tmp___24;
  }
#line 281
  return (csa);
}
}
#line 290
static void alloc_N(struct csa___0 *csa ) ;
#line 291
static void build_N(struct csa___0 *csa ) ;
#line 293 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void init_csa___0(struct csa___0 *csa , glp_prob *lp ) 
{ 
  int m ;
  int n ;
  char *type ;
  double *lb ;
  double *ub ;
  double *coef ;
  double *obj ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  char *stat ;
  char *refsp ;
  double *gamma___0 ;
  int i ;
  int j ;
  int k ;
  int loc ;
  double cmax ;
  GLPROW *row ;
  GLPCOL *col ;
  double tmp ;
  int tmp___0 ;
  double tmp___1 ;
  GLPAIJ *aij ;
  int tmp___2 ;
  int tmp___3 ;
  GLPROW *row___0 ;
  int tmp___4 ;
  GLPCOL *col___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 294
  m = csa->m;
#line 295
  n = csa->n;
#line 296
  type = csa->type;
#line 297
  lb = csa->lb;
#line 298
  ub = csa->ub;
#line 299
  coef = csa->coef;
#line 300
  obj = csa->obj;
#line 301
  A_ptr = csa->A_ptr;
#line 302
  A_ind = csa->A_ind;
#line 303
  A_val = csa->A_val;
#line 304
  head = csa->head;
#line 305
  stat = csa->stat;
#line 306
  refsp = csa->refsp;
#line 307
  gamma___0 = csa->gamma;
#line 311
  i = 1;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i <= m)) {
#line 311
      goto while_break;
    }
#line 312
    row = *(lp->row + i);
#line 313
    *(type + i) = (char )row->type;
#line 314
    *(lb + i) = row->lb * row->rii;
#line 315
    *(ub + i) = row->ub * row->rii;
#line 316
    *(coef + i) = 0.0;
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  j = 1;
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 319
    if (! (j <= n)) {
#line 319
      goto while_break___0;
    }
#line 320
    col = *(lp->col + j);
#line 321
    *(type + (m + j)) = (char )col->type;
#line 322
    *(lb + (m + j)) = col->lb / col->sjj;
#line 323
    *(ub + (m + j)) = col->ub / col->sjj;
#line 324
    *(coef + (m + j)) = col->coef * col->sjj;
#line 319
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 327
  *(obj + 0) = lp->c0;
#line 328
  memcpy((void */* __restrict  */)(obj + 1), (void const   */* __restrict  */)(coef + (m + 1)),
         (size_t )((unsigned long )n * sizeof(double )));
#line 330
  cmax = 0.0;
#line 331
  j = 1;
  }
  {
#line 331
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 331
    if (! (j <= n)) {
#line 331
      goto while_break___1;
    }
    {
#line 332
    tmp = fabs(*(obj + j));
    }
#line 332
    if (cmax < tmp) {
      {
#line 332
      cmax = fabs(*(obj + j));
      }
    }
#line 331
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 333
  if (cmax == 0.0) {
#line 333
    cmax = 1.0;
  }
  {
#line 335
  if (lp->dir == 1) {
#line 335
    goto case_1;
  }
#line 338
  if (lp->dir == 2) {
#line 338
    goto case_2;
  }
#line 341
  goto switch_default;
  case_1: /* CIL Label */ 
#line 336
  csa->zeta = 1.0 / cmax;
#line 337
  goto switch_break;
  case_2: /* CIL Label */ 
#line 339
  csa->zeta = - 1.0 / cmax;
#line 340
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 342
  if ((unsigned long )lp != (unsigned long )lp) {
#line 342
    tmp___0 = 1;
  } else {
    {
#line 342
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     342);
#line 342
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 345
  tmp___1 = fabs(csa->zeta);
  }
#line 345
  if (tmp___1 < 1.0) {
#line 345
    csa->zeta *= 1000.0;
  }
#line 348
  loc = 1;
#line 349
  j = 1;
  {
#line 349
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 349
    if (! (j <= n)) {
#line 349
      goto while_break___2;
    }
#line 351
    *(A_ptr + j) = loc;
#line 352
    aij = (*(lp->col + j))->ptr;
    {
#line 352
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 352
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 352
        goto while_break___3;
      }
#line 353
      *(A_ind + loc) = (aij->row)->i;
#line 354
      *(A_val + loc) = ((aij->row)->rii * aij->val) * (aij->col)->sjj;
#line 355
      loc ++;
#line 352
      aij = aij->c_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 349
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 358
  *(A_ptr + (n + 1)) = loc;
#line 359
  if (loc == lp->nnz + 1) {
#line 359
    tmp___2 = 1;
  } else {
    {
#line 359
    _glp_lib_xassert("loc == lp->nnz+1", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     359);
#line 359
    tmp___2 = 1;
    }
  }
#line 361
  if (lp->valid) {
#line 361
    tmp___3 = 1;
  } else {
    {
#line 361
    _glp_lib_xassert("lp->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     361);
#line 361
    tmp___3 = 1;
    }
  }
  {
#line 362
  memcpy((void */* __restrict  */)(head + 1), (void const   */* __restrict  */)(lp->head + 1),
         (size_t )((unsigned long )m * sizeof(int )));
#line 363
  k = 0;
#line 364
  i = 1;
  }
  {
#line 364
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 364
    if (! (i <= m)) {
#line 364
      goto while_break___4;
    }
#line 365
    row___0 = *(lp->row + i);
#line 366
    if (row___0->stat != 1) {
#line 367
      k ++;
#line 368
      if (k <= n) {
#line 368
        tmp___4 = 1;
      } else {
        {
#line 368
        _glp_lib_xassert("k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         368);
#line 368
        tmp___4 = 1;
        }
      }
#line 369
      *(head + (m + k)) = i;
#line 370
      *(stat + k) = (char )row___0->stat;
    }
#line 364
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 373
  j = 1;
  {
#line 373
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 373
    if (! (j <= n)) {
#line 373
      goto while_break___5;
    }
#line 374
    col___0 = *(lp->col + j);
#line 375
    if (col___0->stat != 1) {
#line 376
      k ++;
#line 377
      if (k <= n) {
#line 377
        tmp___5 = 1;
      } else {
        {
#line 377
        _glp_lib_xassert("k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         377);
#line 377
        tmp___5 = 1;
        }
      }
#line 378
      *(head + (m + k)) = m + j;
#line 379
      *(stat + k) = (char )col___0->stat;
    }
#line 373
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 382
  if (k == n) {
#line 382
    tmp___6 = 1;
  } else {
    {
#line 382
    _glp_lib_xassert("k == n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     382);
#line 382
    tmp___6 = 1;
    }
  }
  {
#line 384
  csa->valid = 1;
#line 384
  lp->valid = 0;
#line 385
  csa->bfd = lp->bfd;
#line 385
  lp->bfd = (BFD *)((void *)0);
#line 387
  alloc_N(csa);
#line 388
  build_N(csa);
#line 390
  csa->phase = 0;
#line 391
  csa->tm_beg = _glp_lib_xtime();
#line 392
  tmp___7 = lp->it_cnt;
#line 392
  csa->it_cnt = tmp___7;
#line 392
  csa->it_beg = tmp___7;
#line 393
  csa->it_dpy = -1;
#line 395
  csa->refct = 0;
#line 396
  memset((void *)(refsp + 1), 0, (size_t )((unsigned long )(m + n) * sizeof(char )));
#line 397
  j = 1;
  }
  {
#line 397
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 397
    if (! (j <= n)) {
#line 397
      goto while_break___6;
    }
#line 397
    *(gamma___0 + j) = 1.0;
#line 397
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 398
  return;
}
}
#line 409 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static int inv_col___0(void *info , int i , int *ind , double *val ) 
{ 
  struct csa___0 *csa ;
  int m ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  int k ;
  int len ;
  int ptr ;
  int t ;

  {
#line 412
  csa = (struct csa___0 *)info;
#line 413
  m = csa->m;
#line 417
  A_ptr = csa->A_ptr;
#line 418
  A_ind = csa->A_ind;
#line 419
  A_val = csa->A_val;
#line 420
  head = csa->head;
#line 425
  k = *(head + i);
#line 429
  if (k <= m) {
#line 431
    len = 1;
#line 432
    *(ind + 1) = k;
#line 433
    *(val + 1) = 1.0;
  } else {
    {
#line 437
    ptr = *(A_ptr + (k - m));
#line 438
    len = *(A_ptr + ((k - m) + 1)) - ptr;
#line 439
    memcpy((void */* __restrict  */)(ind + 1), (void const   */* __restrict  */)(A_ind + ptr),
           (size_t )((unsigned long )len * sizeof(int )));
#line 440
    memcpy((void */* __restrict  */)(val + 1), (void const   */* __restrict  */)(A_val + ptr),
           (size_t )((unsigned long )len * sizeof(double )));
#line 441
    t = 1;
    }
    {
#line 441
    while (1) {
      while_continue: /* CIL Label */ ;
#line 441
      if (! (t <= len)) {
#line 441
        goto while_break;
      }
#line 441
      *(val + t) = - *(val + t);
#line 441
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 443
  return (len);
}
}
#line 446 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static int invert_B___0(struct csa___0 *csa ) 
{ 
  int ret ;

  {
  {
#line 448
  ret = _glp_bfd_factorize(csa->bfd, csa->m, (int const   *)((void *)0), & inv_col___0,
                           (void *)csa);
#line 449
  csa->valid = ret == 0;
  }
#line 450
  return (ret);
}
}
#line 463 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static int update_B___0(struct csa___0 *csa , int i , int k ) 
{ 
  int m ;
  int ret ;
  int ind[2] ;
  double val[2] ;
  int tmp ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  double *val___0 ;
  int beg ;
  int end ;
  int ptr ;
  int len ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 464
  m = csa->m;
#line 473
  if (k <= m) {
#line 477
    ind[1] = k;
#line 478
    val[1] = 1.0;
#line 479
    if (csa->valid) {
#line 479
      tmp = 1;
    } else {
      {
#line 479
      _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       479);
#line 479
      tmp = 1;
      }
    }
    {
#line 480
    ret = _glp_bfd_update_it(csa->bfd, i, 0, 1, (int const   *)(ind), (double const   *)(val));
    }
  } else {
#line 484
    A_ptr = csa->A_ptr;
#line 485
    A_ind = csa->A_ind;
#line 486
    A_val = csa->A_val;
#line 487
    val___0 = csa->work1;
#line 489
    beg = *(A_ptr + (k - m));
#line 490
    end = *(A_ptr + ((k - m) + 1));
#line 491
    len = 0;
#line 492
    ptr = beg;
    {
#line 492
    while (1) {
      while_continue: /* CIL Label */ ;
#line 492
      if (! (ptr < end)) {
#line 492
        goto while_break;
      }
#line 493
      len ++;
#line 493
      *(val___0 + len) = - *(A_val + ptr);
#line 492
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 494
    if (csa->valid) {
#line 494
      tmp___0 = 1;
    } else {
      {
#line 494
      _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       494);
#line 494
      tmp___0 = 1;
      }
    }
    {
#line 495
    ret = _glp_bfd_update_it(csa->bfd, i, 0, len, (int const   *)(A_ind + (beg - 1)),
                             (double const   *)val___0);
    }
  }
#line 497
  csa->valid = ret == 0;
#line 498
  return (ret);
}
}
#line 508 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void error_ftran___0(struct csa___0 *csa , double *h , double *x , double *r ) 
{ 
  int m ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  int i ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;

  {
  {
#line 510
  m = csa->m;
#line 514
  A_ptr = csa->A_ptr;
#line 515
  A_ind = csa->A_ind;
#line 516
  A_val = csa->A_val;
#line 517
  head = csa->head;
#line 523
  memcpy((void */* __restrict  */)(r + 1), (void const   */* __restrict  */)(h + 1),
         (size_t )((unsigned long )m * sizeof(double )));
#line 524
  i = 1;
  }
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (i <= m)) {
#line 524
      goto while_break;
    }
#line 525
    temp = *(x + i);
#line 526
    if (temp == 0.0) {
#line 526
      goto __Cont;
    }
#line 527
    k = *(head + i);
#line 531
    if (k <= m) {
#line 533
      *(r + k) -= temp;
    } else {
#line 537
      beg = *(A_ptr + (k - m));
#line 538
      end = *(A_ptr + ((k - m) + 1));
#line 539
      ptr = beg;
      {
#line 539
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 539
        if (! (ptr < end)) {
#line 539
          goto while_break___0;
        }
#line 540
        *(r + *(A_ind + ptr)) += *(A_val + ptr) * temp;
#line 539
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  return;
}
}
#line 553 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void refine_ftran___0(struct csa___0 *csa , double *h , double *x ) 
{ 
  int m ;
  double *r ;
  double *d___0 ;
  int i ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 554
  m = csa->m;
#line 555
  r = csa->work1;
#line 556
  d___0 = csa->work1;
#line 559
  error_ftran___0(csa, h, x, r);
  }
#line 561
  if (csa->valid) {
#line 561
    tmp = 1;
  } else {
    {
#line 561
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     561);
#line 561
    tmp = 1;
    }
  }
  {
#line 562
  _glp_bfd_ftran(csa->bfd, d___0);
#line 564
  i = 1;
  }
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (i <= m)) {
#line 564
      goto while_break;
    }
#line 564
    *(x + i) += *(d___0 + i);
#line 564
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  return;
}
}
#line 575 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void error_btran___0(struct csa___0 *csa , double *h , double *x , double *r ) 
{ 
  int m ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  int i ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;

  {
#line 577
  m = csa->m;
#line 581
  A_ptr = csa->A_ptr;
#line 582
  A_ind = csa->A_ind;
#line 583
  A_val = csa->A_val;
#line 584
  head = csa->head;
#line 588
  i = 1;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! (i <= m)) {
#line 588
      goto while_break;
    }
#line 590
    k = *(head + i);
#line 594
    temp = *(h + i);
#line 595
    if (k <= m) {
#line 597
      temp -= *(x + k);
    } else {
#line 601
      beg = *(A_ptr + (k - m));
#line 602
      end = *(A_ptr + ((k - m) + 1));
#line 603
      ptr = beg;
      {
#line 603
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 603
        if (! (ptr < end)) {
#line 603
          goto while_break___0;
        }
#line 604
        temp += *(A_val + ptr) * *(x + *(A_ind + ptr));
#line 603
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 606
    *(r + i) = temp;
#line 588
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  return;
}
}
#line 619 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void refine_btran___0(struct csa___0 *csa , double *h , double *x ) 
{ 
  int m ;
  double *r ;
  double *d___0 ;
  int i ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 620
  m = csa->m;
#line 621
  r = csa->work1;
#line 622
  d___0 = csa->work1;
#line 625
  error_btran___0(csa, h, x, r);
  }
#line 627
  if (csa->valid) {
#line 627
    tmp = 1;
  } else {
    {
#line 627
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     627);
#line 627
    tmp = 1;
    }
  }
  {
#line 628
  _glp_bfd_btran(csa->bfd, d___0);
#line 630
  i = 1;
  }
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i <= m)) {
#line 630
      goto while_break;
    }
#line 630
    *(x + i) += *(d___0 + i);
#line 630
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  return;
}
}
#line 644 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void alloc_N(struct csa___0 *csa ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  int *N_ptr ;
  int *N_len ;
  int i ;
  int j ;
  int beg ;
  int end ;
  int ptr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 645
  m = csa->m;
#line 646
  n = csa->n;
#line 647
  A_ptr = csa->A_ptr;
#line 648
  A_ind = csa->A_ind;
#line 649
  N_ptr = csa->N_ptr;
#line 650
  N_len = csa->N_len;
#line 654
  i = 1;
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if (! (i <= m)) {
#line 654
      goto while_break;
    }
#line 655
    *(N_len + i) = 1;
#line 654
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  j = 1;
  {
#line 656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 656
    if (! (j <= n)) {
#line 656
      goto while_break___0;
    }
#line 657
    beg = *(A_ptr + j);
#line 658
    end = *(A_ptr + (j + 1));
#line 659
    ptr = beg;
    {
#line 659
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 659
      if (! (ptr < end)) {
#line 659
        goto while_break___1;
      }
#line 660
      (*(N_len + *(A_ind + ptr))) ++;
#line 659
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 656
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 664
  *(N_ptr + 1) = 1;
#line 665
  i = 1;
  {
#line 665
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 665
    if (! (i <= m)) {
#line 665
      goto while_break___2;
    }
#line 667
    if (*(N_len + i) > n) {
#line 667
      *(N_len + i) = n;
    }
#line 668
    *(N_ptr + (i + 1)) = *(N_ptr + i) + *(N_len + i);
#line 665
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 671
  tmp = _glp_lib_xcalloc(*(N_ptr + (m + 1)), (int )sizeof(int ));
#line 671
  csa->N_ind = (int *)tmp;
#line 672
  tmp___0 = _glp_lib_xcalloc(*(N_ptr + (m + 1)), (int )sizeof(double ));
#line 672
  csa->N_val = (double *)tmp___0;
  }
#line 673
  return;
}
}
#line 683 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void add_N_col(struct csa___0 *csa , int j , int k ) 
{ 
  int m ;
  int *N_ptr ;
  int *N_len ;
  int *N_ind ;
  double *N_val ;
  int pos ;
  int tmp ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int i ;
  int beg ;
  int end ;
  int ptr ;
  int tmp___0 ;

  {
#line 684
  m = csa->m;
#line 688
  N_ptr = csa->N_ptr;
#line 689
  N_len = csa->N_len;
#line 690
  N_ind = csa->N_ind;
#line 691
  N_val = csa->N_val;
#line 697
  if (k <= m) {
#line 699
    tmp = *(N_len + k);
#line 699
    (*(N_len + k)) ++;
#line 699
    pos = *(N_ptr + k) + tmp;
#line 703
    *(N_ind + pos) = j;
#line 704
    *(N_val + pos) = 1.0;
  } else {
#line 708
    A_ptr = csa->A_ptr;
#line 709
    A_ind = csa->A_ind;
#line 710
    A_val = csa->A_val;
#line 712
    beg = *(A_ptr + (k - m));
#line 713
    end = *(A_ptr + ((k - m) + 1));
#line 714
    ptr = beg;
    {
#line 714
    while (1) {
      while_continue: /* CIL Label */ ;
#line 714
      if (! (ptr < end)) {
#line 714
        goto while_break;
      }
#line 715
      i = *(A_ind + ptr);
#line 716
      tmp___0 = *(N_len + i);
#line 716
      (*(N_len + i)) ++;
#line 716
      pos = *(N_ptr + i) + tmp___0;
#line 720
      *(N_ind + pos) = j;
#line 721
      *(N_val + pos) = - *(A_val + ptr);
#line 714
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 724
  return;
}
}
#line 733 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void del_N_col(struct csa___0 *csa , int j , int k ) 
{ 
  int m ;
  int *N_ptr ;
  int *N_len ;
  int *N_ind ;
  double *N_val ;
  int pos ;
  int head ;
  int tail ;
  int *A_ptr ;
  int *A_ind ;
  int i ;
  int beg ;
  int end ;
  int ptr ;

  {
#line 734
  m = csa->m;
#line 738
  N_ptr = csa->N_ptr;
#line 739
  N_len = csa->N_len;
#line 740
  N_ind = csa->N_ind;
#line 741
  N_val = csa->N_val;
#line 747
  if (k <= m) {
#line 750
    head = *(N_ptr + k);
#line 751
    pos = head;
    {
#line 751
    while (1) {
      while_continue: /* CIL Label */ ;
#line 751
      if (! (*(N_ind + pos) != j)) {
#line 751
        goto while_break;
      }
#line 751
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 753
    (*(N_len + k)) --;
#line 753
    tail = head + *(N_len + k);
#line 757
    *(N_ind + pos) = *(N_ind + tail);
#line 758
    *(N_val + pos) = *(N_val + tail);
  } else {
#line 762
    A_ptr = csa->A_ptr;
#line 763
    A_ind = csa->A_ind;
#line 765
    beg = *(A_ptr + (k - m));
#line 766
    end = *(A_ptr + ((k - m) + 1));
#line 767
    ptr = beg;
    {
#line 767
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 767
      if (! (ptr < end)) {
#line 767
        goto while_break___0;
      }
#line 768
      i = *(A_ind + ptr);
#line 770
      head = *(N_ptr + i);
#line 771
      pos = head;
      {
#line 771
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 771
        if (! (*(N_ind + pos) != j)) {
#line 771
          goto while_break___1;
        }
#line 771
        pos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 773
      (*(N_len + i)) --;
#line 773
      tail = head + *(N_len + i);
#line 777
      *(N_ind + pos) = *(N_ind + tail);
#line 778
      *(N_val + pos) = *(N_val + tail);
#line 767
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 781
  return;
}
}
#line 791 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void build_N(struct csa___0 *csa ) 
{ 
  int m ;
  int n ;
  int *head ;
  char *stat ;
  int *N_len ;
  int j ;
  int k ;

  {
  {
#line 792
  m = csa->m;
#line 793
  n = csa->n;
#line 794
  head = csa->head;
#line 795
  stat = csa->stat;
#line 796
  N_len = csa->N_len;
#line 799
  memset((void *)(N_len + 1), 0, (size_t )((unsigned long )m * sizeof(int )));
#line 801
  j = 1;
  }
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    if (! (j <= n)) {
#line 801
      goto while_break;
    }
#line 802
    if ((int )*(stat + j) != 5) {
      {
#line 805
      k = *(head + (m + j));
#line 809
      add_N_col(csa, j, k);
      }
    }
#line 801
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 812
  return;
}
}
#line 821 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double get_xN___0(struct csa___0 *csa , int j ) 
{ 
  int m ;
  double *lb ;
  double *ub ;
  int *head ;
  char *stat ;
  int k ;
  double xN ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 822
  m = csa->m;
#line 826
  lb = csa->lb;
#line 827
  ub = csa->ub;
#line 828
  head = csa->head;
#line 829
  stat = csa->stat;
#line 835
  k = *(head + (m + j));
  {
#line 840
  if ((int )*(stat + j) == 2) {
#line 840
    goto case_2;
  }
#line 843
  if ((int )*(stat + j) == 3) {
#line 843
    goto case_3;
  }
#line 846
  if ((int )*(stat + j) == 4) {
#line 846
    goto case_4;
  }
#line 849
  if ((int )*(stat + j) == 5) {
#line 849
    goto case_5;
  }
#line 852
  goto switch_default;
  case_2: /* CIL Label */ 
#line 842
  xN = *(lb + k);
#line 842
  goto switch_break;
  case_3: /* CIL Label */ 
#line 845
  xN = *(ub + k);
#line 845
  goto switch_break;
  case_4: /* CIL Label */ 
#line 848
  xN = 0.0;
#line 848
  goto switch_break;
  case_5: /* CIL Label */ 
#line 851
  xN = *(lb + k);
#line 851
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 853
  if ((unsigned long )stat != (unsigned long )stat) {
#line 853
    tmp = 1;
  } else {
    {
#line 853
    _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     853);
#line 853
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 855
  return (xN);
}
}
#line 869 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void eval_beta___0(struct csa___0 *csa , double *beta ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  double *h ;
  int i ;
  int j ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double xN ;
  int tmp ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 870
  m = csa->m;
#line 871
  n = csa->n;
#line 872
  A_ptr = csa->A_ptr;
#line 873
  A_ind = csa->A_ind;
#line 874
  A_val = csa->A_val;
#line 875
  head = csa->head;
#line 876
  h = csa->work2;
#line 882
  i = 1;
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! (i <= m)) {
#line 882
      goto while_break;
    }
#line 883
    *(h + i) = 0.0;
#line 882
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  j = 1;
  {
#line 884
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 884
    if (! (j <= n)) {
#line 884
      goto while_break___0;
    }
    {
#line 885
    k = *(head + (m + j));
#line 890
    xN = get_xN___0(csa, j);
    }
#line 891
    if (xN == 0.0) {
#line 891
      goto __Cont;
    }
#line 892
    if (k <= m) {
#line 894
      *(h + k) -= xN;
    } else {
#line 898
      beg = *(A_ptr + (k - m));
#line 899
      end = *(A_ptr + ((k - m) + 1));
#line 900
      ptr = beg;
      {
#line 900
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 900
        if (! (ptr < end)) {
#line 900
          goto while_break___1;
        }
#line 901
        *(h + *(A_ind + ptr)) += xN * *(A_val + ptr);
#line 900
        ptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 884
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 905
  memcpy((void */* __restrict  */)(beta + 1), (void const   */* __restrict  */)(h + 1),
         (size_t )((unsigned long )m * sizeof(double )));
  }
#line 906
  if (csa->valid) {
#line 906
    tmp = 1;
  } else {
    {
#line 906
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     906);
#line 906
    tmp = 1;
    }
  }
  {
#line 907
  _glp_bfd_ftran(csa->bfd, beta);
#line 909
  refine_ftran___0(csa, h, beta);
  }
#line 910
  return;
}
}
#line 923 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void eval_pi___0(struct csa___0 *csa , double *pi ) 
{ 
  int m ;
  double *c ;
  int *head ;
  double *cB ;
  int i ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 924
  m = csa->m;
#line 925
  c = csa->coef;
#line 926
  head = csa->head;
#line 927
  cB = csa->work2;
#line 930
  i = 1;
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (i <= m)) {
#line 930
      goto while_break;
    }
#line 931
    *(cB + i) = *(c + *(head + i));
#line 930
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 933
  memcpy((void */* __restrict  */)(pi + 1), (void const   */* __restrict  */)(cB + 1),
         (size_t )((unsigned long )m * sizeof(double )));
  }
#line 934
  if (csa->valid) {
#line 934
    tmp = 1;
  } else {
    {
#line 934
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     934);
#line 934
    tmp = 1;
    }
  }
  {
#line 935
  _glp_bfd_btran(csa->bfd, pi);
#line 937
  refine_btran___0(csa, cB, pi);
  }
#line 938
  return;
}
}
#line 953 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double eval_cost___0(struct csa___0 *csa , double *pi , int j ) 
{ 
  int m ;
  double *coef ;
  int *head ;
  int k ;
  double dj ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;

  {
#line 954
  m = csa->m;
#line 958
  coef = csa->coef;
#line 959
  head = csa->head;
#line 965
  k = *(head + (m + j));
#line 969
  dj = *(coef + k);
#line 970
  if (k <= m) {
#line 972
    dj -= *(pi + k);
  } else {
#line 976
    A_ptr = csa->A_ptr;
#line 977
    A_ind = csa->A_ind;
#line 978
    A_val = csa->A_val;
#line 980
    beg = *(A_ptr + (k - m));
#line 981
    end = *(A_ptr + ((k - m) + 1));
#line 982
    ptr = beg;
    {
#line 982
    while (1) {
      while_continue: /* CIL Label */ ;
#line 982
      if (! (ptr < end)) {
#line 982
        goto while_break;
      }
#line 983
      dj += *(A_val + ptr) * *(pi + *(A_ind + ptr));
#line 982
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 985
  return (dj);
}
}
#line 994 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void eval_bbar___0(struct csa___0 *csa ) 
{ 


  {
  {
#line 995
  eval_beta___0(csa, csa->bbar);
  }
#line 996
  return;
}
}
#line 1005 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void eval_cbar___0(struct csa___0 *csa ) 
{ 
  int n ;
  double *cbar ;
  double *pi ;
  int j ;

  {
  {
#line 1010
  n = csa->n;
#line 1014
  cbar = csa->cbar;
#line 1015
  pi = csa->work3;
#line 1021
  eval_pi___0(csa, pi);
#line 1023
  j = 1;
  }
  {
#line 1023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    if (! (j <= n)) {
#line 1023
      goto while_break;
    }
    {
#line 1029
    *(cbar + j) = eval_cost___0(csa, pi, j);
#line 1023
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  return;
}
}
#line 1040 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void reset_refsp___0(struct csa___0 *csa ) 
{ 
  int m ;
  int n ;
  int *head ;
  char *refsp ;
  double *gamma___0 ;
  int j ;
  int k ;
  int tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1041
  m = csa->m;
#line 1042
  n = csa->n;
#line 1043
  head = csa->head;
#line 1044
  refsp = csa->refsp;
#line 1045
  gamma___0 = csa->gamma;
#line 1047
  if (csa->refct == 0) {
#line 1047
    tmp = 1;
  } else {
    {
#line 1047
    _glp_lib_xassert("csa->refct == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     1047);
#line 1047
    tmp = 1;
    }
  }
  {
#line 1048
  csa->refct = 1000;
#line 1049
  memset((void *)(refsp + 1), 0, (size_t )((unsigned long )(m + n) * sizeof(char )));
#line 1050
  j = 1;
  }
  {
#line 1050
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1050
    if (! (j <= n)) {
#line 1050
      goto while_break;
    }
#line 1051
    k = *(head + (m + j));
#line 1052
    *(refsp + k) = (char)1;
#line 1053
    *(gamma___0 + j) = 1.0;
#line 1050
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1055
  return;
}
}
#line 1074 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double eval_gamma___0(struct csa___0 *csa , int j ) 
{ 
  int m ;
  int *head ;
  char *refsp ;
  double *alfa ;
  double *h ;
  int i ;
  int k ;
  double gamma___0 ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;
  int tmp ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1075
  m = csa->m;
#line 1079
  head = csa->head;
#line 1080
  refsp = csa->refsp;
#line 1081
  alfa = csa->work3;
#line 1082
  h = csa->work3;
#line 1088
  k = *(head + (m + j));
#line 1093
  i = 1;
  {
#line 1093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    if (! (i <= m)) {
#line 1093
      goto while_break;
    }
#line 1094
    *(h + i) = 0.0;
#line 1093
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  if (k <= m) {
#line 1097
    *(h + k) = - 1.0;
  } else {
#line 1101
    A_ptr = csa->A_ptr;
#line 1102
    A_ind = csa->A_ind;
#line 1103
    A_val = csa->A_val;
#line 1105
    beg = *(A_ptr + (k - m));
#line 1106
    end = *(A_ptr + ((k - m) + 1));
#line 1107
    ptr = beg;
    {
#line 1107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1107
      if (! (ptr < end)) {
#line 1107
        goto while_break___0;
      }
#line 1108
      *(h + *(A_ind + ptr)) = *(A_val + ptr);
#line 1107
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1111
  if (csa->valid) {
#line 1111
    tmp = 1;
  } else {
    {
#line 1111
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     1111);
#line 1111
    tmp = 1;
    }
  }
  {
#line 1112
  _glp_bfd_ftran(csa->bfd, alfa);
  }
#line 1114
  if (*(refsp + k)) {
#line 1114
    gamma___0 = 1.0;
  } else {
#line 1114
    gamma___0 = 0.0;
  }
#line 1115
  i = 1;
  {
#line 1115
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1115
    if (! (i <= m)) {
#line 1115
      goto while_break___1;
    }
#line 1116
    k = *(head + i);
#line 1120
    if (*(refsp + k)) {
#line 1120
      gamma___0 += *(alfa + i) * *(alfa + i);
    }
#line 1115
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1122
  return (gamma___0);
}
}
#line 1150 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void chuzc___0(struct csa___0 *csa , double tol_dj ) 
{ 
  int n ;
  char *stat ;
  double *cbar ;
  double *gamma___0 ;
  int j ;
  int q ;
  double dj ;
  double best ;
  double temp ;
  int tmp ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1151
  n = csa->n;
#line 1152
  stat = csa->stat;
#line 1153
  cbar = csa->cbar;
#line 1154
  gamma___0 = csa->gamma;
#line 1158
  q = 0;
#line 1158
  best = 0.0;
#line 1160
  j = 1;
  {
#line 1160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    if (! (j <= n)) {
#line 1160
      goto while_break;
    }
#line 1161
    dj = *(cbar + j);
    {
#line 1163
    if ((int )*(stat + j) == 2) {
#line 1163
      goto case_2;
    }
#line 1167
    if ((int )*(stat + j) == 3) {
#line 1167
      goto case_3;
    }
#line 1171
    if ((int )*(stat + j) == 4) {
#line 1171
      goto case_4;
    }
#line 1175
    if ((int )*(stat + j) == 5) {
#line 1175
      goto case_5;
    }
#line 1178
    goto switch_default;
    case_2: /* CIL Label */ 
#line 1165
    if (dj >= - tol_dj) {
#line 1165
      goto __Cont;
    }
#line 1166
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1169
    if (dj <= tol_dj) {
#line 1169
      goto __Cont;
    }
#line 1170
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1173
    if (- tol_dj <= dj) {
#line 1173
      if (dj <= tol_dj) {
#line 1173
        goto __Cont;
      }
    }
#line 1174
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1177
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 1179
    if ((unsigned long )stat != (unsigned long )stat) {
#line 1179
      tmp = 1;
    } else {
      {
#line 1179
      _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       1179);
#line 1179
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 1186
    temp = (dj * dj) / *(gamma___0 + j);
#line 1187
    if (best < temp) {
#line 1188
      q = j;
#line 1188
      best = temp;
    }
    __Cont: /* CIL Label */ 
#line 1160
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1191
  csa->q = q;
#line 1192
  return;
}
}
#line 1208 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void eval_tcol___0(struct csa___0 *csa ) 
{ 
  int m ;
  int *head ;
  int q ;
  int *tcol_ind ;
  double *tcol_vec ;
  double *h ;
  int i ;
  int k ;
  int nnz ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;
  int tmp ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1209
  m = csa->m;
#line 1213
  head = csa->head;
#line 1214
  q = csa->q;
#line 1215
  tcol_ind = csa->tcol_ind;
#line 1216
  tcol_vec = csa->tcol_vec;
#line 1217
  h = csa->tcol_vec;
#line 1222
  k = *(head + (m + q));
#line 1227
  i = 1;
  {
#line 1227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1227
    if (! (i <= m)) {
#line 1227
      goto while_break;
    }
#line 1228
    *(h + i) = 0.0;
#line 1227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  if (k <= m) {
#line 1231
    *(h + k) = - 1.0;
  } else {
#line 1235
    A_ptr = csa->A_ptr;
#line 1236
    A_ind = csa->A_ind;
#line 1237
    A_val = csa->A_val;
#line 1239
    beg = *(A_ptr + (k - m));
#line 1240
    end = *(A_ptr + ((k - m) + 1));
#line 1241
    ptr = beg;
    {
#line 1241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1241
      if (! (ptr < end)) {
#line 1241
        goto while_break___0;
      }
#line 1242
      *(h + *(A_ind + ptr)) = *(A_val + ptr);
#line 1241
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1245
  if (csa->valid) {
#line 1245
    tmp = 1;
  } else {
    {
#line 1245
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     1245);
#line 1245
    tmp = 1;
    }
  }
  {
#line 1246
  _glp_bfd_ftran(csa->bfd, tcol_vec);
#line 1248
  nnz = 0;
#line 1249
  i = 1;
  }
  {
#line 1249
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1249
    if (! (i <= m)) {
#line 1249
      goto while_break___1;
    }
#line 1250
    if (*(tcol_vec + i) != 0.0) {
#line 1251
      nnz ++;
#line 1251
      *(tcol_ind + nnz) = i;
    }
#line 1249
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1253
  csa->tcol_nnz = nnz;
#line 1254
  return;
}
}
#line 1263 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void refine_tcol___0(struct csa___0 *csa ) 
{ 
  int m ;
  int *head ;
  int q ;
  int *tcol_ind ;
  double *tcol_vec ;
  double *h ;
  int i ;
  int k ;
  int nnz ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int beg ;
  int end ;
  int ptr ;

  {
#line 1264
  m = csa->m;
#line 1268
  head = csa->head;
#line 1269
  q = csa->q;
#line 1270
  tcol_ind = csa->tcol_ind;
#line 1271
  tcol_vec = csa->tcol_vec;
#line 1272
  h = csa->work3;
#line 1277
  k = *(head + (m + q));
#line 1282
  i = 1;
  {
#line 1282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1282
    if (! (i <= m)) {
#line 1282
      goto while_break;
    }
#line 1283
    *(h + i) = 0.0;
#line 1282
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1284
  if (k <= m) {
#line 1286
    *(h + k) = - 1.0;
  } else {
#line 1290
    A_ptr = csa->A_ptr;
#line 1291
    A_ind = csa->A_ind;
#line 1292
    A_val = csa->A_val;
#line 1294
    beg = *(A_ptr + (k - m));
#line 1295
    end = *(A_ptr + ((k - m) + 1));
#line 1296
    ptr = beg;
    {
#line 1296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1296
      if (! (ptr < end)) {
#line 1296
        goto while_break___0;
      }
#line 1297
      *(h + *(A_ind + ptr)) = *(A_val + ptr);
#line 1296
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1300
  refine_ftran___0(csa, h, tcol_vec);
#line 1302
  nnz = 0;
#line 1303
  i = 1;
  }
  {
#line 1303
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1303
    if (! (i <= m)) {
#line 1303
      goto while_break___1;
    }
#line 1304
    if (*(tcol_vec + i) != 0.0) {
#line 1305
      nnz ++;
#line 1305
      *(tcol_ind + nnz) = i;
    }
#line 1303
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1307
  csa->tcol_nnz = nnz;
#line 1308
  return;
}
}
#line 1319 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void sort_tcol(struct csa___0 *csa , double tol_piv ) 
{ 
  int nnz ;
  int *tcol_ind ;
  double *tcol_vec ;
  int i ;
  int num ;
  int pos ;
  double big ;
  double eps ;
  double temp ;
  double tmp ;

  {
#line 1324
  nnz = csa->tcol_nnz;
#line 1325
  tcol_ind = csa->tcol_ind;
#line 1326
  tcol_vec = csa->tcol_vec;
#line 1330
  big = 0.0;
#line 1331
  pos = 1;
  {
#line 1331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1331
    if (! (pos <= nnz)) {
#line 1331
      goto while_break;
    }
    {
#line 1337
    temp = fabs(*(tcol_vec + *(tcol_ind + pos)));
    }
#line 1338
    if (big < temp) {
#line 1338
      big = temp;
    }
#line 1331
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1340
  csa->tcol_max = big;
#line 1342
  eps = tol_piv * (1.0 + 0.01 * big);
#line 1344
  num = 0;
  {
#line 1344
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1344
    if (! (num < nnz)) {
#line 1344
      goto while_break___0;
    }
    {
#line 1345
    i = *(tcol_ind + nnz);
#line 1346
    tmp = fabs(*(tcol_vec + i));
    }
#line 1346
    if (tmp < eps) {
#line 1347
      nnz --;
    } else {
#line 1349
      num ++;
#line 1350
      *(tcol_ind + nnz) = *(tcol_ind + num);
#line 1351
      *(tcol_ind + num) = i;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1354
  csa->tcol_num = num;
#line 1355
  return;
}
}
#line 1370 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void chuzr___0(struct csa___0 *csa , double rtol ) 
{ 
  int m ;
  char *type ;
  double *lb ;
  double *ub ;
  double *coef ;
  int *head ;
  int phase ;
  double *bbar ;
  double *cbar ;
  int q ;
  int *tcol_ind ;
  double *tcol_vec ;
  int tcol_num ;
  int i ;
  int i_stat ;
  int k ;
  int p ;
  int p_stat ;
  int pos ;
  double alfa ;
  double big ;
  double delta ;
  double s ;
  double t ;
  double teta ;
  double tmax ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 1371
  m = csa->m;
#line 1375
  type = csa->type;
#line 1376
  lb = csa->lb;
#line 1377
  ub = csa->ub;
#line 1378
  coef = csa->coef;
#line 1379
  head = csa->head;
#line 1380
  phase = csa->phase;
#line 1381
  bbar = csa->bbar;
#line 1382
  cbar = csa->cbar;
#line 1383
  q = csa->q;
#line 1384
  tcol_ind = csa->tcol_ind;
#line 1385
  tcol_vec = csa->tcol_vec;
#line 1386
  tcol_num = csa->tcol_num;
#line 1396
  if (*(cbar + q) > 0.0) {
#line 1396
    s = - 1.0;
  } else {
#line 1396
    s = 1.0;
  }
#line 1398
  k = *(head + (m + q));
#line 1402
  if ((int )*(type + k) == 4) {
#line 1404
    p = -1;
#line 1404
    p_stat = 0;
#line 1404
    teta = *(ub + k) - *(lb + k);
#line 1404
    big = 1.0;
  } else {
#line 1408
    p = 0;
#line 1408
    p_stat = 0;
#line 1408
    teta = 1.7976931348623157e+308;
#line 1408
    big = 0.0;
  }
#line 1411
  pos = 1;
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1411
    if (! (pos <= tcol_num)) {
#line 1411
      goto while_break;
    }
#line 1412
    i = *(tcol_ind + pos);
#line 1416
    k = *(head + i);
#line 1420
    alfa = s * *(tcol_vec + i);
#line 1426
    if (alfa > 0.0) {
#line 1428
      if (phase == 1) {
#line 1428
        if (*(coef + k) < 0.0) {
          {
#line 1431
          tmp = fabs(*(lb + k));
#line 1431
          delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp));
#line 1432
          t = ((*(lb + k) + delta) - *(bbar + i)) / alfa;
#line 1433
          i_stat = 2;
          }
        } else {
#line 1428
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1435
      if (phase == 1) {
#line 1435
        if (*(coef + k) > 0.0) {
#line 1438
          goto __Cont;
        } else {
#line 1435
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1440
      if ((int )*(type + k) == 3) {
        {
#line 1443
        tmp___0 = fabs(*(ub + k));
#line 1443
        delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp___0));
#line 1444
        t = ((*(ub + k) + delta) - *(bbar + i)) / alfa;
#line 1445
        i_stat = 3;
        }
      } else
#line 1440
      if ((int )*(type + k) == 4) {
        {
#line 1443
        tmp___0 = fabs(*(ub + k));
#line 1443
        delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp___0));
#line 1444
        t = ((*(ub + k) + delta) - *(bbar + i)) / alfa;
#line 1445
        i_stat = 3;
        }
      } else
#line 1440
      if ((int )*(type + k) == 5) {
        {
#line 1443
        tmp___0 = fabs(*(ub + k));
#line 1443
        delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp___0));
#line 1444
        t = ((*(ub + k) + delta) - *(bbar + i)) / alfa;
#line 1445
        i_stat = 3;
        }
      } else {
#line 1449
        goto __Cont;
      }
    } else
#line 1454
    if (phase == 1) {
#line 1454
      if (*(coef + k) > 0.0) {
        {
#line 1457
        tmp___1 = fabs(*(ub + k));
#line 1457
        delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp___1));
#line 1458
        t = ((*(ub + k) - delta) - *(bbar + i)) / alfa;
#line 1459
        i_stat = 3;
        }
      } else {
#line 1454
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1461
    if (phase == 1) {
#line 1461
      if (*(coef + k) < 0.0) {
#line 1464
        goto __Cont;
      } else {
#line 1461
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1466
    if ((int )*(type + k) == 2) {
      {
#line 1469
      tmp___2 = fabs(*(lb + k));
#line 1469
      delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp___2));
#line 1470
      t = ((*(lb + k) - delta) - *(bbar + i)) / alfa;
#line 1471
      i_stat = 2;
      }
    } else
#line 1466
    if ((int )*(type + k) == 4) {
      {
#line 1469
      tmp___2 = fabs(*(lb + k));
#line 1469
      delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp___2));
#line 1470
      t = ((*(lb + k) - delta) - *(bbar + i)) / alfa;
#line 1471
      i_stat = 2;
      }
    } else
#line 1466
    if ((int )*(type + k) == 5) {
      {
#line 1469
      tmp___2 = fabs(*(lb + k));
#line 1469
      delta = rtol * (1.0 + (double )(kappa___0 * (double const   )tmp___2));
#line 1470
      t = ((*(lb + k) - delta) - *(bbar + i)) / alfa;
#line 1471
      i_stat = 2;
      }
    } else {
#line 1475
      goto __Cont;
    }
#line 1497
    if (t < 0.0) {
#line 1497
      t = 0.0;
    }
#line 1499
    if (teta > t) {
      {
#line 1500
      p = i;
#line 1500
      p_stat = i_stat;
#line 1500
      teta = t;
#line 1500
      big = fabs(alfa);
      }
    } else
#line 1499
    if (teta == t) {
      {
#line 1499
      tmp___3 = fabs(alfa);
      }
#line 1499
      if (big < tmp___3) {
        {
#line 1500
        p = i;
#line 1500
        p_stat = i_stat;
#line 1500
        teta = t;
#line 1500
        big = fabs(alfa);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1411
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1504
  if (rtol == 0.0) {
#line 1504
    goto done;
  }
#line 1507
  if (p <= 0) {
#line 1507
    goto done;
  }
#line 1510
  if (teta == 0.0) {
#line 1510
    goto done;
  }
#line 1518
  tmax = teta;
#line 1521
  p = 0;
#line 1521
  p_stat = 0;
#line 1521
  teta = 1.7976931348623157e+308;
#line 1521
  big = 0.0;
#line 1523
  pos = 1;
  {
#line 1523
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1523
    if (! (pos <= tcol_num)) {
#line 1523
      goto while_break___0;
    }
#line 1524
    i = *(tcol_ind + pos);
#line 1528
    k = *(head + i);
#line 1532
    alfa = s * *(tcol_vec + i);
#line 1538
    if (alfa > 0.0) {
#line 1540
      if (phase == 1) {
#line 1540
        if (*(coef + k) < 0.0) {
#line 1543
          t = (*(lb + k) - *(bbar + i)) / alfa;
#line 1544
          i_stat = 2;
        } else {
#line 1540
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 1546
      if (phase == 1) {
#line 1546
        if (*(coef + k) > 0.0) {
#line 1549
          goto __Cont___0;
        } else {
#line 1546
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1551
      if ((int )*(type + k) == 3) {
#line 1554
        t = (*(ub + k) - *(bbar + i)) / alfa;
#line 1555
        i_stat = 3;
      } else
#line 1551
      if ((int )*(type + k) == 4) {
#line 1554
        t = (*(ub + k) - *(bbar + i)) / alfa;
#line 1555
        i_stat = 3;
      } else
#line 1551
      if ((int )*(type + k) == 5) {
#line 1554
        t = (*(ub + k) - *(bbar + i)) / alfa;
#line 1555
        i_stat = 3;
      } else {
#line 1559
        goto __Cont___0;
      }
    } else
#line 1564
    if (phase == 1) {
#line 1564
      if (*(coef + k) > 0.0) {
#line 1567
        t = (*(ub + k) - *(bbar + i)) / alfa;
#line 1568
        i_stat = 3;
      } else {
#line 1564
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 1570
    if (phase == 1) {
#line 1570
      if (*(coef + k) < 0.0) {
#line 1573
        goto __Cont___0;
      } else {
#line 1570
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1575
    if ((int )*(type + k) == 2) {
#line 1578
      t = (*(lb + k) - *(bbar + i)) / alfa;
#line 1579
      i_stat = 2;
    } else
#line 1575
    if ((int )*(type + k) == 4) {
#line 1578
      t = (*(lb + k) - *(bbar + i)) / alfa;
#line 1579
      i_stat = 2;
    } else
#line 1575
    if ((int )*(type + k) == 5) {
#line 1578
      t = (*(lb + k) - *(bbar + i)) / alfa;
#line 1579
      i_stat = 2;
    } else {
#line 1583
      goto __Cont___0;
    }
#line 1587
    if (t < 0.0) {
#line 1587
      t = 0.0;
    }
#line 1593
    if (t <= tmax) {
      {
#line 1593
      tmp___4 = fabs(alfa);
      }
#line 1593
      if (big < tmp___4) {
        {
#line 1594
        p = i;
#line 1594
        p_stat = i_stat;
#line 1594
        teta = t;
#line 1594
        big = fabs(alfa);
        }
      }
    }
    __Cont___0: /* CIL Label */ 
#line 1523
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1597
  if (p != 0) {
#line 1597
    tmp___5 = 1;
  } else {
    {
#line 1597
    _glp_lib_xassert("p != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     1597);
#line 1597
    tmp___5 = 1;
    }
  }
  done: 
#line 1599
  csa->p = p;
#line 1600
  if (p > 0) {
#line 1600
    if ((int )*(type + *(head + p)) == 5) {
#line 1601
      csa->p_stat = 5;
    } else {
#line 1603
      csa->p_stat = p_stat;
    }
  } else {
#line 1603
    csa->p_stat = p_stat;
  }
#line 1608
  csa->teta = s * teta;
#line 1609
  return;
}
}
#line 1623 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void eval_rho___0(struct csa___0 *csa , double *rho ) 
{ 
  int m ;
  int p ;
  double *e ;
  int i ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1624
  m = csa->m;
#line 1625
  p = csa->p;
#line 1626
  e = rho;
#line 1632
  i = 1;
  {
#line 1632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1632
    if (! (i <= m)) {
#line 1632
      goto while_break;
    }
#line 1633
    *(e + i) = 0.0;
#line 1632
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1634
  *(e + p) = 1.0;
#line 1636
  if (csa->valid) {
#line 1636
    tmp = 1;
  } else {
    {
#line 1636
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     1636);
#line 1636
    tmp = 1;
    }
  }
  {
#line 1637
  _glp_bfd_btran(csa->bfd, rho);
  }
#line 1638
  return;
}
}
#line 1647 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void refine_rho___0(struct csa___0 *csa , double *rho ) 
{ 
  int m ;
  int p ;
  double *e ;
  int i ;

  {
#line 1648
  m = csa->m;
#line 1649
  p = csa->p;
#line 1650
  e = csa->work3;
#line 1656
  i = 1;
  {
#line 1656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1656
    if (! (i <= m)) {
#line 1656
      goto while_break;
    }
#line 1657
    *(e + i) = 0.0;
#line 1656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1658
  *(e + p) = 1.0;
#line 1660
  refine_btran___0(csa, e, rho);
  }
#line 1661
  return;
}
}
#line 1680 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void eval_trow___0(struct csa___0 *csa , double *rho ) 
{ 
  int m ;
  int n ;
  int *N_ptr ;
  int *N_len ;
  int *N_ind ;
  double *N_val ;
  int *trow_ind ;
  double *trow_vec ;
  int i ;
  int j ;
  int beg ;
  int end ;
  int ptr ;
  int nnz ;
  double temp ;

  {
#line 1681
  m = csa->m;
#line 1682
  n = csa->n;
#line 1686
  N_ptr = csa->N_ptr;
#line 1687
  N_len = csa->N_len;
#line 1688
  N_ind = csa->N_ind;
#line 1689
  N_val = csa->N_val;
#line 1690
  trow_ind = csa->trow_ind;
#line 1691
  trow_vec = csa->trow_vec;
#line 1695
  j = 1;
  {
#line 1695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1695
    if (! (j <= n)) {
#line 1695
      goto while_break;
    }
#line 1696
    *(trow_vec + j) = 0.0;
#line 1695
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1699
  i = 1;
  {
#line 1699
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1699
    if (! (i <= m)) {
#line 1699
      goto while_break___0;
    }
#line 1700
    temp = *(rho + i);
#line 1701
    if (temp == 0.0) {
#line 1701
      goto __Cont;
    }
#line 1703
    beg = *(N_ptr + i);
#line 1704
    end = beg + *(N_len + i);
#line 1705
    ptr = beg;
    {
#line 1705
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1705
      if (! (ptr < end)) {
#line 1705
        goto while_break___1;
      }
#line 1712
      *(trow_vec + *(N_ind + ptr)) -= temp * *(N_val + ptr);
#line 1705
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1699
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1716
  nnz = 0;
#line 1717
  j = 1;
  {
#line 1717
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1717
    if (! (j <= n)) {
#line 1717
      goto while_break___2;
    }
#line 1718
    if (*(trow_vec + j) != 0.0) {
#line 1719
      nnz ++;
#line 1719
      *(trow_ind + nnz) = j;
    }
#line 1717
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1721
  csa->trow_nnz = nnz;
#line 1722
  return;
}
}
#line 1731 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void update_bbar___0(struct csa___0 *csa ) 
{ 
  double *bbar ;
  int q ;
  int tcol_nnz ;
  int *tcol_ind ;
  double *tcol_vec ;
  int p ;
  double teta ;
  int i ;
  int pos ;
  double tmp ;

  {
#line 1737
  bbar = csa->bbar;
#line 1738
  q = csa->q;
#line 1739
  tcol_nnz = csa->tcol_nnz;
#line 1740
  tcol_ind = csa->tcol_ind;
#line 1741
  tcol_vec = csa->tcol_vec;
#line 1742
  p = csa->p;
#line 1743
  teta = csa->teta;
#line 1751
  if (p > 0) {
    {
#line 1752
    tmp = get_xN___0(csa, q);
#line 1752
    *(bbar + p) = tmp + teta;
    }
  }
#line 1755
  if (teta == 0.0) {
#line 1755
    goto done;
  }
#line 1756
  pos = 1;
  {
#line 1756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1756
    if (! (pos <= tcol_nnz)) {
#line 1756
      goto while_break;
    }
#line 1757
    i = *(tcol_ind + pos);
#line 1759
    if (i == p) {
#line 1759
      goto __Cont;
    }
#line 1761
    *(bbar + i) += *(tcol_vec + i) * teta;
    __Cont: /* CIL Label */ 
#line 1756
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1763
  return;
}
}
#line 1783 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double reeval_cost(struct csa___0 *csa ) 
{ 
  int m ;
  double *coef ;
  int *head ;
  int q ;
  int tcol_nnz ;
  int *tcol_ind ;
  double *tcol_vec ;
  int i ;
  int pos ;
  double dq ;

  {
#line 1784
  m = csa->m;
#line 1788
  coef = csa->coef;
#line 1789
  head = csa->head;
#line 1790
  q = csa->q;
#line 1791
  tcol_nnz = csa->tcol_nnz;
#line 1792
  tcol_ind = csa->tcol_ind;
#line 1793
  tcol_vec = csa->tcol_vec;
#line 1799
  dq = *(coef + *(head + (m + q)));
#line 1800
  pos = 1;
  {
#line 1800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1800
    if (! (pos <= tcol_nnz)) {
#line 1800
      goto while_break;
    }
#line 1801
    i = *(tcol_ind + pos);
#line 1805
    dq += *(coef + *(head + i)) * *(tcol_vec + i);
#line 1800
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1807
  return (dq);
}
}
#line 1816 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void update_cbar___0(struct csa___0 *csa ) 
{ 
  double *cbar ;
  int q ;
  int trow_nnz ;
  int *trow_ind ;
  double *trow_vec ;
  int j ;
  int pos ;
  double new_dq ;
  double tmp ;

  {
#line 1821
  cbar = csa->cbar;
#line 1822
  q = csa->q;
#line 1823
  trow_nnz = csa->trow_nnz;
#line 1824
  trow_ind = csa->trow_ind;
#line 1825
  trow_vec = csa->trow_vec;
#line 1836
  tmp = *(cbar + q) / *(trow_vec + q);
#line 1836
  *(cbar + q) = tmp;
#line 1836
  new_dq = tmp;
#line 1839
  pos = 1;
  {
#line 1839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1839
    if (! (pos <= trow_nnz)) {
#line 1839
      goto while_break;
    }
#line 1840
    j = *(trow_ind + pos);
#line 1842
    if (j == q) {
#line 1842
      goto __Cont;
    }
#line 1843
    *(cbar + j) -= *(trow_vec + j) * new_dq;
    __Cont: /* CIL Label */ 
#line 1839
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1845
  return;
}
}
#line 1854 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void update_gamma___0(struct csa___0 *csa ) 
{ 
  int m ;
  char *type ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int *head ;
  char *refsp ;
  double *gamma___0 ;
  int q ;
  int tcol_nnz ;
  int *tcol_ind ;
  double *tcol_vec ;
  int p ;
  int trow_nnz ;
  int *trow_ind ;
  double *trow_vec ;
  double *u ;
  int i ;
  int j ;
  int k ;
  int pos ;
  int beg ;
  int end ;
  int ptr ;
  double gamma_q ;
  double delta_q ;
  double pivot ;
  double s ;
  double t ;
  double t1 ;
  double t2 ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 1855
  m = csa->m;
#line 1859
  type = csa->type;
#line 1860
  A_ptr = csa->A_ptr;
#line 1861
  A_ind = csa->A_ind;
#line 1862
  A_val = csa->A_val;
#line 1863
  head = csa->head;
#line 1864
  refsp = csa->refsp;
#line 1865
  gamma___0 = csa->gamma;
#line 1866
  q = csa->q;
#line 1867
  tcol_nnz = csa->tcol_nnz;
#line 1868
  tcol_ind = csa->tcol_ind;
#line 1869
  tcol_vec = csa->tcol_vec;
#line 1870
  p = csa->p;
#line 1871
  trow_nnz = csa->trow_nnz;
#line 1872
  trow_ind = csa->trow_ind;
#line 1873
  trow_vec = csa->trow_vec;
#line 1874
  u = csa->work3;
#line 1882
  if (csa->refct > 0) {
#line 1882
    tmp = 1;
  } else {
    {
#line 1882
    _glp_lib_xassert("csa->refct > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     1882);
#line 1882
    tmp = 1;
    }
  }
#line 1883
  (csa->refct) --;
#line 1886
  if (*(refsp + *(head + (m + q)))) {
#line 1886
    delta_q = 1.0;
  } else {
#line 1886
    delta_q = 0.0;
  }
#line 1886
  gamma_q = delta_q;
#line 1887
  i = 1;
  {
#line 1887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1887
    if (! (i <= m)) {
#line 1887
      goto while_break;
    }
#line 1887
    *(u + i) = 0.0;
#line 1887
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1888
  pos = 1;
  {
#line 1888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1888
    if (! (pos <= tcol_nnz)) {
#line 1888
      goto while_break___0;
    }
#line 1889
    i = *(tcol_ind + pos);
#line 1890
    if (*(refsp + *(head + i))) {
#line 1891
      t = *(tcol_vec + i);
#line 1891
      *(u + i) = t;
#line 1892
      gamma_q += t * t;
    } else {
#line 1895
      *(u + i) = 0.0;
    }
#line 1888
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1897
  if (csa->valid) {
#line 1897
    tmp___0 = 1;
  } else {
    {
#line 1897
    _glp_lib_xassert("csa->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     1897);
#line 1897
    tmp___0 = 1;
    }
  }
  {
#line 1898
  _glp_bfd_btran(csa->bfd, u);
#line 1901
  pivot = *(trow_vec + q);
#line 1905
  pos = 1;
  }
  {
#line 1905
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1905
    if (! (pos <= trow_nnz)) {
#line 1905
      goto while_break___1;
    }
#line 1906
    j = *(trow_ind + pos);
#line 1908
    if (j == q) {
#line 1908
      goto __Cont;
    }
#line 1910
    t = *(trow_vec + j) / pivot;
#line 1912
    k = *(head + (m + j));
#line 1913
    if (k <= m) {
#line 1914
      s = *(u + k);
    } else {
#line 1916
      s = 0.0;
#line 1917
      beg = *(A_ptr + (k - m));
#line 1918
      end = *(A_ptr + ((k - m) + 1));
#line 1919
      ptr = beg;
      {
#line 1919
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1919
        if (! (ptr < end)) {
#line 1919
          goto while_break___2;
        }
#line 1920
        s -= *(A_val + ptr) * *(u + *(A_ind + ptr));
#line 1919
        ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1923
    t1 = (*(gamma___0 + j) + (t * t) * gamma_q) + (2.0 * t) * s;
#line 1924
    if (*(refsp + k)) {
#line 1924
      tmp___1 = 1.0;
    } else {
#line 1924
      tmp___1 = 0.0;
    }
#line 1924
    t2 = tmp___1 + (delta_q * t) * t;
#line 1925
    if (t1 >= t2) {
#line 1925
      *(gamma___0 + j) = t1;
    } else {
#line 1925
      *(gamma___0 + j) = t2;
    }
#line 1926
    if (*(gamma___0 + j) < 2.2204460492503131e-16) {
#line 1926
      *(gamma___0 + j) = 2.2204460492503131e-16;
    }
    __Cont: /* CIL Label */ 
#line 1905
    pos ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1929
  if ((int )*(type + *(head + p)) == 5) {
#line 1930
    *(gamma___0 + q) = 1.0;
  } else {
#line 1932
    *(gamma___0 + q) = gamma_q / (pivot * pivot);
#line 1933
    if (*(gamma___0 + q) < 2.2204460492503131e-16) {
#line 1933
      *(gamma___0 + q) = 2.2204460492503131e-16;
    }
  }
#line 1935
  return;
}
}
#line 1950 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double err_in_bbar___0(struct csa___0 *csa ) 
{ 
  int m ;
  double *bbar ;
  int i ;
  double e ;
  double emax ;
  double *beta ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 1951
  m = csa->m;
#line 1952
  bbar = csa->bbar;
#line 1955
  tmp = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 1955
  beta = (double *)tmp;
#line 1956
  eval_beta___0(csa, beta);
#line 1957
  emax = 0.0;
#line 1958
  i = 1;
  }
  {
#line 1958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1958
    if (! (i <= m)) {
#line 1958
      goto while_break;
    }
    {
#line 1959
    tmp___0 = fabs(*(beta + i) - *(bbar + i));
#line 1959
    tmp___1 = fabs(*(beta + i));
#line 1959
    e = tmp___0 / (1.0 + tmp___1);
    }
#line 1960
    if (emax < e) {
#line 1960
      emax = e;
    }
#line 1958
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1962
  _glp_lib_xfree((void *)beta);
  }
#line 1963
  return (emax);
}
}
#line 1978 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double err_in_cbar___0(struct csa___0 *csa ) 
{ 
  int m ;
  int n ;
  char *stat ;
  double *cbar ;
  int j ;
  double e ;
  double emax ;
  double cost ;
  double *pi ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 1979
  m = csa->m;
#line 1980
  n = csa->n;
#line 1981
  stat = csa->stat;
#line 1982
  cbar = csa->cbar;
#line 1985
  tmp = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 1985
  pi = (double *)tmp;
#line 1986
  eval_pi___0(csa, pi);
#line 1987
  emax = 0.0;
#line 1988
  j = 1;
  }
  {
#line 1988
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1988
    if (! (j <= n)) {
#line 1988
      goto while_break;
    }
#line 1989
    if ((int )*(stat + j) == 5) {
#line 1989
      goto __Cont;
    }
    {
#line 1990
    cost = eval_cost___0(csa, pi, j);
#line 1991
    tmp___0 = fabs(cost - *(cbar + j));
#line 1991
    tmp___1 = fabs(cost);
#line 1991
    e = tmp___0 / (1.0 + tmp___1);
    }
#line 1992
    if (emax < e) {
#line 1992
      emax = e;
    }
    __Cont: /* CIL Label */ 
#line 1988
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1994
  _glp_lib_xfree((void *)pi);
  }
#line 1995
  return (emax);
}
}
#line 2011 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double err_in_gamma___0(struct csa___0 *csa ) 
{ 
  int n ;
  char *stat ;
  double *gamma___0 ;
  int j ;
  double e ;
  double emax ;
  double temp ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 2012
  n = csa->n;
#line 2013
  stat = csa->stat;
#line 2014
  gamma___0 = csa->gamma;
#line 2017
  emax = 0.0;
#line 2018
  j = 1;
  {
#line 2018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2018
    if (! (j <= n)) {
#line 2018
      goto while_break;
    }
#line 2019
    if ((int )*(stat + j) == 5) {
#line 2020
      if (*(gamma___0 + j) == 1.0) {
#line 2020
        tmp = 1;
      } else {
        {
#line 2020
        _glp_lib_xassert("gamma[j] == 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2020);
#line 2020
        tmp = 1;
        }
      }
#line 2021
      goto __Cont;
    }
    {
#line 2023
    temp = eval_gamma___0(csa, j);
#line 2024
    tmp___0 = fabs(temp - *(gamma___0 + j));
#line 2024
    tmp___1 = fabs(temp);
#line 2024
    e = tmp___0 / (1.0 + tmp___1);
    }
#line 2025
    if (emax < e) {
#line 2025
      emax = e;
    }
    __Cont: /* CIL Label */ 
#line 2018
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2027
  return (emax);
}
}
#line 2036 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void change_basis___0(struct csa___0 *csa ) 
{ 
  int m ;
  int *head ;
  char *stat ;
  int q ;
  int p ;
  int p_stat ;
  int k ;
  int tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2037
  m = csa->m;
#line 2042
  head = csa->head;
#line 2043
  stat = csa->stat;
#line 2044
  q = csa->q;
#line 2045
  p = csa->p;
#line 2046
  p_stat = csa->p_stat;
#line 2051
  if (p < 0) {
    {
#line 2059
    if ((int )*(stat + q) == 2) {
#line 2059
      goto case_2;
    }
#line 2063
    if ((int )*(stat + q) == 3) {
#line 2063
      goto case_3;
    }
#line 2067
    goto switch_default;
    case_2: /* CIL Label */ 
#line 2061
    *(stat + q) = (char)3;
#line 2062
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2065
    *(stat + q) = (char)2;
#line 2066
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2068
    if ((unsigned long )stat != (unsigned long )stat) {
#line 2068
      tmp = 1;
    } else {
      {
#line 2068
      _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2068);
#line 2068
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 2094
    k = *(head + p);
#line 2094
    *(head + p) = *(head + (m + q));
#line 2094
    *(head + (m + q)) = k;
#line 2095
    *(stat + q) = (char )p_stat;
  }
#line 2097
  return;
}
}
#line 2119 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static int set_aux_obj(struct csa___0 *csa , double tol_bnd ) 
{ 
  int m ;
  int n ;
  char *type ;
  double *lb ;
  double *ub ;
  double *coef ;
  int *head ;
  double *bbar ;
  int i ;
  int k ;
  int cnt ;
  double eps ;
  double tmp ;
  double tmp___0 ;

  {
#line 2120
  m = csa->m;
#line 2121
  n = csa->n;
#line 2122
  type = csa->type;
#line 2123
  lb = csa->lb;
#line 2124
  ub = csa->ub;
#line 2125
  coef = csa->coef;
#line 2126
  head = csa->head;
#line 2127
  bbar = csa->bbar;
#line 2128
  cnt = 0;
#line 2131
  tol_bnd *= 0.90;
#line 2133
  k = 1;
  {
#line 2133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2133
    if (! (k <= m + n)) {
#line 2133
      goto while_break;
    }
#line 2134
    *(coef + k) = 0.0;
#line 2133
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2136
  i = 1;
  {
#line 2136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2136
    if (! (i <= m)) {
#line 2136
      goto while_break___0;
    }
#line 2137
    k = *(head + i);
#line 2138
    if ((int )*(type + k) == 2) {
#line 2138
      goto _L;
    } else
#line 2138
    if ((int )*(type + k) == 4) {
#line 2138
      goto _L;
    } else
#line 2138
    if ((int )*(type + k) == 5) {
      _L: /* CIL Label */ 
      {
#line 2141
      tmp = fabs(*(lb + k));
#line 2141
      eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp));
      }
#line 2142
      if (*(bbar + i) < *(lb + k) - eps) {
#line 2144
        *(coef + k) = - 1.0;
#line 2145
        cnt ++;
      }
    }
#line 2148
    if ((int )*(type + k) == 3) {
#line 2148
      goto _L___0;
    } else
#line 2148
    if ((int )*(type + k) == 4) {
#line 2148
      goto _L___0;
    } else
#line 2148
    if ((int )*(type + k) == 5) {
      _L___0: /* CIL Label */ 
      {
#line 2151
      tmp___0 = fabs(*(ub + k));
#line 2151
      eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp___0));
      }
#line 2152
      if (*(bbar + i) > *(ub + k) + eps) {
#line 2154
        *(coef + k) = 1.0;
#line 2155
        cnt ++;
      }
    }
#line 2136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2159
  return (cnt);
}
}
#line 2168 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void set_orig_obj(struct csa___0 *csa ) 
{ 
  int m ;
  int n ;
  double *coef ;
  double *obj ;
  double zeta ;
  int i ;
  int j ;

  {
#line 2169
  m = csa->m;
#line 2170
  n = csa->n;
#line 2171
  coef = csa->coef;
#line 2172
  obj = csa->obj;
#line 2173
  zeta = csa->zeta;
#line 2175
  i = 1;
  {
#line 2175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2175
    if (! (i <= m)) {
#line 2175
      goto while_break;
    }
#line 2176
    *(coef + i) = 0.0;
#line 2175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2177
  j = 1;
  {
#line 2177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2177
    if (! (j <= n)) {
#line 2177
      goto while_break___0;
    }
#line 2178
    *(coef + (m + j)) = zeta * *(obj + j);
#line 2177
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2179
  return;
}
}
#line 2189 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static int check_stab___0(struct csa___0 *csa , double tol_bnd ) 
{ 
  int m ;
  char *type ;
  double *lb ;
  double *ub ;
  double *coef ;
  int *head ;
  int phase ;
  double *bbar ;
  int i ;
  int k ;
  double eps ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 2190
  m = csa->m;
#line 2194
  type = csa->type;
#line 2195
  lb = csa->lb;
#line 2196
  ub = csa->ub;
#line 2197
  coef = csa->coef;
#line 2198
  head = csa->head;
#line 2199
  phase = csa->phase;
#line 2200
  bbar = csa->bbar;
#line 2204
  i = 1;
  {
#line 2204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2204
    if (! (i <= m)) {
#line 2204
      goto while_break;
    }
#line 2205
    k = *(head + i);
#line 2209
    if (phase == 1) {
#line 2209
      if (*(coef + k) < 0.0) {
        {
#line 2215
        tmp = fabs(*(lb + k));
#line 2215
        eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp));
        }
#line 2216
        if (*(bbar + i) > *(lb + k) + eps) {
#line 2216
          return (1);
        }
      } else {
#line 2209
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2218
    if (phase == 1) {
#line 2218
      if (*(coef + k) > 0.0) {
        {
#line 2224
        tmp___0 = fabs(*(ub + k));
#line 2224
        eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp___0));
        }
#line 2225
        if (*(bbar + i) < *(ub + k) - eps) {
#line 2225
          return (1);
        }
      } else {
#line 2218
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 2229
      if ((int )*(type + k) == 2) {
#line 2229
        goto _L;
      } else
#line 2229
      if ((int )*(type + k) == 4) {
#line 2229
        goto _L;
      } else
#line 2229
      if ((int )*(type + k) == 5) {
        _L: /* CIL Label */ 
        {
#line 2232
        tmp___1 = fabs(*(lb + k));
#line 2232
        eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp___1));
        }
#line 2233
        if (*(bbar + i) < *(lb + k) - eps) {
#line 2233
          return (1);
        }
      }
#line 2235
      if ((int )*(type + k) == 3) {
#line 2235
        goto _L___0;
      } else
#line 2235
      if ((int )*(type + k) == 4) {
#line 2235
        goto _L___0;
      } else
#line 2235
      if ((int )*(type + k) == 5) {
        _L___0: /* CIL Label */ 
        {
#line 2238
        tmp___2 = fabs(*(ub + k));
#line 2238
        eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp___2));
        }
#line 2239
        if (*(bbar + i) > *(ub + k) + eps) {
#line 2239
          return (1);
        }
      }
    }
#line 2204
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2244
  return (0);
}
}
#line 2253 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static int check_feas___0(struct csa___0 *csa , double tol_bnd ) 
{ 
  int m ;
  double *lb ;
  double *ub ;
  double *coef ;
  int *head ;
  double *bbar ;
  int i ;
  int k ;
  double eps ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 2254
  m = csa->m;
#line 2259
  lb = csa->lb;
#line 2260
  ub = csa->ub;
#line 2261
  coef = csa->coef;
#line 2262
  head = csa->head;
#line 2263
  bbar = csa->bbar;
#line 2266
  if (csa->phase == 1) {
#line 2266
    tmp = 1;
  } else {
    {
#line 2266
    _glp_lib_xassert("csa->phase == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     2266);
#line 2266
    tmp = 1;
    }
  }
#line 2268
  i = 1;
  {
#line 2268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2268
    if (! (i <= m)) {
#line 2268
      goto while_break;
    }
#line 2269
    k = *(head + i);
#line 2273
    if (*(coef + k) < 0.0) {
      {
#line 2279
      tmp___0 = fabs(*(lb + k));
#line 2279
      eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp___0));
      }
#line 2280
      if (*(bbar + i) < *(lb + k) - eps) {
#line 2280
        return (1);
      }
    } else
#line 2282
    if (*(coef + k) > 0.0) {
      {
#line 2288
      tmp___1 = fabs(*(ub + k));
#line 2288
      eps = tol_bnd * (1.0 + (double )(kappa___0 * (double const   )tmp___1));
      }
#line 2289
      if (*(bbar + i) > *(ub + k) + eps) {
#line 2289
        return (1);
      }
    }
#line 2268
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2293
  return (0);
}
}
#line 2302 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static double eval_obj___0(struct csa___0 *csa ) 
{ 
  int m ;
  int n ;
  double *obj ;
  int *head ;
  double *bbar ;
  int i ;
  int j ;
  int k ;
  double sum ;
  double tmp ;

  {
#line 2303
  m = csa->m;
#line 2304
  n = csa->n;
#line 2305
  obj = csa->obj;
#line 2306
  head = csa->head;
#line 2307
  bbar = csa->bbar;
#line 2310
  sum = *(obj + 0);
#line 2312
  i = 1;
  {
#line 2312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2312
    if (! (i <= m)) {
#line 2312
      goto while_break;
    }
#line 2313
    k = *(head + i);
#line 2317
    if (k > m) {
#line 2318
      sum += *(obj + (k - m)) * *(bbar + i);
    }
#line 2312
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2321
  j = 1;
  {
#line 2321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2321
    if (! (j <= n)) {
#line 2321
      goto while_break___0;
    }
#line 2322
    k = *(head + (m + j));
#line 2326
    if (k > m) {
      {
#line 2327
      tmp = get_xN___0(csa, j);
#line 2327
      sum += *(obj + (k - m)) * tmp;
      }
    }
#line 2321
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2329
  return (sum);
}
}
#line 2348 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void display___0(struct csa___0 *csa , glp_smcp const   *parm , int spec ) 
{ 
  int m ;
  char *type ;
  double *lb ;
  double *ub ;
  int phase ;
  int *head ;
  double *bbar ;
  int i ;
  int k ;
  int cnt ;
  double sum ;
  xlong_t tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp19 ;

  {
#line 2349
  m = csa->m;
#line 2353
  type = csa->type;
#line 2354
  lb = csa->lb;
#line 2355
  ub = csa->ub;
#line 2356
  phase = csa->phase;
#line 2357
  head = csa->head;
#line 2358
  bbar = csa->bbar;
#line 2361
  if (parm->msg_lev < 2) {
#line 2361
    goto skip;
  }
#line 2362
  if (parm->out_dly > 0) {
    {
#line 2362
    tmp = _glp_lib_xtime();
#line 2362
    tmp___0 = _glp_lib_xdifftime(tmp, csa->tm_beg);
    }
#line 2362
    if (1000.0 * tmp___0 < (double )parm->out_dly) {
#line 2364
      goto skip;
    }
  }
#line 2365
  if (csa->it_cnt == csa->it_dpy) {
#line 2365
    goto skip;
  }
#line 2366
  if (! spec) {
#line 2366
    if (csa->it_cnt % (int )parm->out_frq != 0) {
#line 2366
      goto skip;
    }
  }
#line 2369
  sum = 0.0;
#line 2369
  cnt = 0;
#line 2370
  i = 1;
  {
#line 2370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2370
    if (! (i <= m)) {
#line 2370
      goto while_break;
    }
#line 2371
    k = *(head + i);
#line 2375
    if ((int )*(type + k) == 2) {
#line 2375
      goto _L;
    } else
#line 2375
    if ((int )*(type + k) == 4) {
#line 2375
      goto _L;
    } else
#line 2375
    if ((int )*(type + k) == 5) {
      _L: /* CIL Label */ 
#line 2378
      if (*(bbar + i) < *(lb + k)) {
#line 2379
        sum += *(lb + k) - *(bbar + i);
      }
    }
#line 2381
    if ((int )*(type + k) == 3) {
#line 2381
      goto _L___0;
    } else
#line 2381
    if ((int )*(type + k) == 4) {
#line 2381
      goto _L___0;
    } else
#line 2381
    if ((int )*(type + k) == 5) {
      _L___0: /* CIL Label */ 
#line 2384
      if (*(bbar + i) > *(ub + k)) {
#line 2385
        sum += *(bbar + i) - *(ub + k);
      }
    }
#line 2387
    if ((int )*(type + k) == 5) {
#line 2387
      cnt ++;
    }
#line 2370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2389
  tmp___1 = eval_obj___0(csa);
  }
#line 2389
  if (phase == 1) {
#line 2389
    tmp___2 = ' ';
  } else {
#line 2389
    tmp___2 = '*';
  }
  {
#line 2389
  _glp_lib_xprintf("%c%6d: obj = %17.9e  infeas = %10.3e (%d)\n", tmp___2, csa->it_cnt,
                   tmp___1, sum, cnt);
#line 2391
  csa->it_dpy = csa->it_cnt;
  }
  skip: 
#line 2392
  return;
}
}
#line 2401 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void store_sol___0(struct csa___0 *csa , glp_prob *lp , int p_stat , int d_stat ,
                          int ray ) 
{ 
  int m ;
  int n ;
  double zeta ;
  int *head ;
  char *stat ;
  double *bbar ;
  double *cbar ;
  int i ;
  int j ;
  int k ;
  GLPROW *row ;
  GLPCOL *col ;
  GLPROW *row___0 ;
  int tmp ;
  GLPCOL *col___0 ;
  int tmp___0 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 2403
  m = csa->m;
#line 2404
  n = csa->n;
#line 2405
  zeta = csa->zeta;
#line 2406
  head = csa->head;
#line 2407
  stat = csa->stat;
#line 2408
  bbar = csa->bbar;
#line 2409
  cbar = csa->cbar;
#line 2420
  lp->valid = 1;
#line 2420
  csa->valid = 0;
#line 2421
  lp->bfd = csa->bfd;
#line 2421
  csa->bfd = (BFD *)((void *)0);
#line 2422
  memcpy((void */* __restrict  */)(lp->head + 1), (void const   */* __restrict  */)(head + 1),
         (size_t )((unsigned long )m * sizeof(int )));
#line 2424
  lp->pbs_stat = p_stat;
#line 2425
  lp->dbs_stat = d_stat;
#line 2427
  lp->obj_val = eval_obj___0(csa);
#line 2429
  lp->it_cnt = csa->it_cnt;
#line 2431
  lp->some = ray;
#line 2433
  i = 1;
  }
  {
#line 2433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2433
    if (! (i <= m)) {
#line 2433
      goto while_break;
    }
#line 2434
    k = *(head + i);
#line 2438
    if (k <= m) {
#line 2439
      row = *(lp->row + k);
#line 2440
      row->stat = 1;
#line 2441
      row->bind = i;
#line 2442
      row->prim = *(bbar + i) / row->rii;
#line 2443
      row->dual = 0.0;
    } else {
#line 2446
      col = *(lp->col + (k - m));
#line 2447
      col->stat = 1;
#line 2448
      col->bind = i;
#line 2449
      col->prim = *(bbar + i) * col->sjj;
#line 2450
      col->dual = 0.0;
    }
#line 2433
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2454
  j = 1;
  {
#line 2454
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2454
    if (! (j <= n)) {
#line 2454
      goto while_break___0;
    }
#line 2455
    k = *(head + (m + j));
#line 2459
    if (k <= m) {
#line 2460
      row___0 = *(lp->row + k);
#line 2461
      row___0->stat = (int )*(stat + j);
#line 2462
      row___0->bind = 0;
      {
#line 2467
      if ((int )*(stat + j) == 2) {
#line 2467
        goto case_2;
      }
#line 2469
      if ((int )*(stat + j) == 3) {
#line 2469
        goto case_3;
      }
#line 2471
      if ((int )*(stat + j) == 4) {
#line 2471
        goto case_4;
      }
#line 2473
      if ((int )*(stat + j) == 5) {
#line 2473
        goto case_5;
      }
#line 2475
      goto switch_default;
      case_2: /* CIL Label */ 
#line 2468
      row___0->prim = row___0->lb;
#line 2468
      goto switch_break;
      case_3: /* CIL Label */ 
#line 2470
      row___0->prim = row___0->ub;
#line 2470
      goto switch_break;
      case_4: /* CIL Label */ 
#line 2472
      row___0->prim = 0.0;
#line 2472
      goto switch_break;
      case_5: /* CIL Label */ 
#line 2474
      row___0->prim = row___0->lb;
#line 2474
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2476
      if ((unsigned long )stat != (unsigned long )stat) {
#line 2476
        tmp = 1;
      } else {
        {
#line 2476
        _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2476);
#line 2476
        tmp = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 2479
      row___0->dual = (*(cbar + j) * row___0->rii) / zeta;
    } else {
#line 2482
      col___0 = *(lp->col + (k - m));
#line 2483
      col___0->stat = (int )*(stat + j);
#line 2484
      col___0->bind = 0;
      {
#line 2489
      if ((int )*(stat + j) == 2) {
#line 2489
        goto case_2___0;
      }
#line 2491
      if ((int )*(stat + j) == 3) {
#line 2491
        goto case_3___0;
      }
#line 2493
      if ((int )*(stat + j) == 4) {
#line 2493
        goto case_4___0;
      }
#line 2495
      if ((int )*(stat + j) == 5) {
#line 2495
        goto case_5___0;
      }
#line 2497
      goto switch_default___0;
      case_2___0: /* CIL Label */ 
#line 2490
      col___0->prim = col___0->lb;
#line 2490
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 2492
      col___0->prim = col___0->ub;
#line 2492
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 2494
      col___0->prim = 0.0;
#line 2494
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
#line 2496
      col___0->prim = col___0->lb;
#line 2496
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2498
      if ((unsigned long )stat != (unsigned long )stat) {
#line 2498
        tmp___0 = 1;
      } else {
        {
#line 2498
        _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2498);
#line 2498
        tmp___0 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 2501
      col___0->dual = (*(cbar + j) / col___0->sjj) / zeta;
    }
#line 2454
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2504
  return;
}
}
#line 2513 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
static void free_csa___0(struct csa___0 *csa ) 
{ 


  {
  {
#line 2514
  _glp_lib_xfree((void *)csa->type);
#line 2515
  _glp_lib_xfree((void *)csa->lb);
#line 2516
  _glp_lib_xfree((void *)csa->ub);
#line 2517
  _glp_lib_xfree((void *)csa->coef);
#line 2518
  _glp_lib_xfree((void *)csa->obj);
#line 2519
  _glp_lib_xfree((void *)csa->A_ptr);
#line 2520
  _glp_lib_xfree((void *)csa->A_ind);
#line 2521
  _glp_lib_xfree((void *)csa->A_val);
#line 2522
  _glp_lib_xfree((void *)csa->head);
#line 2523
  _glp_lib_xfree((void *)csa->stat);
#line 2524
  _glp_lib_xfree((void *)csa->N_ptr);
#line 2525
  _glp_lib_xfree((void *)csa->N_len);
#line 2526
  _glp_lib_xfree((void *)csa->N_ind);
#line 2527
  _glp_lib_xfree((void *)csa->N_val);
#line 2528
  _glp_lib_xfree((void *)csa->bbar);
#line 2529
  _glp_lib_xfree((void *)csa->cbar);
#line 2530
  _glp_lib_xfree((void *)csa->refsp);
#line 2531
  _glp_lib_xfree((void *)csa->gamma);
#line 2532
  _glp_lib_xfree((void *)csa->tcol_ind);
#line 2533
  _glp_lib_xfree((void *)csa->tcol_vec);
#line 2534
  _glp_lib_xfree((void *)csa->trow_ind);
#line 2535
  _glp_lib_xfree((void *)csa->trow_vec);
#line 2536
  _glp_lib_xfree((void *)csa->work1);
#line 2537
  _glp_lib_xfree((void *)csa->work2);
#line 2538
  _glp_lib_xfree((void *)csa->work3);
#line 2539
  _glp_lib_xfree((void *)csa->work4);
#line 2540
  _glp_lib_xfree((void *)csa);
  }
#line 2541
  return;
}
}
#line 2570 "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c"
int _glp_spx_primal(glp_prob *lp , glp_smcp const   *parm ) 
{ 
  struct csa___0 *csa ;
  int binv_st ;
  int bbar_st ;
  int cbar_st ;
  int rigorous ;
  int check ;
  int p_stat ;
  int d_stat ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  double e_bbar ;
  double tmp___10 ;
  double e_cbar ;
  double tmp___11 ;
  double e_gamma ;
  double tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  xlong_t tmp___17 ;
  double tmp___18 ;
  int tmp___19 ;
  double d1 ;
  double d2 ;
  double tmp___20 ;
  int tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  double piv ;
  double eps ;
  double tmp___28 ;
  double *rho ;
  double piv1 ;
  double piv2 ;
  int tmp___29 ;
  int tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  int k ;
  int tmp___33 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;

  {
  {
#line 2572
  binv_st = 2;
#line 2575
  bbar_st = 0;
#line 2578
  cbar_st = 0;
#line 2581
  rigorous = 0;
#line 2585
  check = 0;
#line 2588
  csa = alloc_csa___0(lp);
#line 2589
  init_csa___0(csa, lp);
  }
#line 2590
  if (parm->msg_lev >= 4) {
    {
#line 2591
    _glp_lib_xprintf("Objective scale factor = %g\n", csa->zeta);
    }
  }
  loop: 
#line 2594
  if (binv_st == 0) {
    {
#line 2595
    ret = invert_B___0(csa);
    }
#line 2596
    if (ret != 0) {
#line 2597
      if (parm->msg_lev >= 1) {
        {
#line 2598
        _glp_lib_xprintf("Error: unable to factorize the basis matrix (%d)\n", ret);
#line 2600
        _glp_lib_xprintf("Sorry, basis recovery procedure not implemented yet\n");
        }
      }
#line 2603
      if (! lp->valid) {
#line 2603
        if ((unsigned long )lp->bfd == (unsigned long )((void *)0)) {
#line 2603
          tmp = 1;
        } else {
          {
#line 2603
          _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                           2603);
#line 2603
          tmp = 1;
          }
        }
      } else {
        {
#line 2603
        _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2603);
#line 2603
        tmp = 1;
        }
      }
#line 2604
      lp->bfd = csa->bfd;
#line 2604
      csa->bfd = (BFD *)((void *)0);
#line 2605
      tmp___0 = 1;
#line 2605
      lp->dbs_stat = tmp___0;
#line 2605
      lp->pbs_stat = tmp___0;
#line 2606
      lp->obj_val = 0.0;
#line 2607
      lp->it_cnt = csa->it_cnt;
#line 2608
      lp->some = 0;
#line 2609
      ret = 5;
#line 2610
      goto done;
    }
#line 2612
    csa->valid = 1;
#line 2613
    binv_st = 1;
#line 2615
    cbar_st = 0;
#line 2615
    bbar_st = cbar_st;
  }
#line 2618
  if (bbar_st == 0) {
    {
#line 2619
    eval_bbar___0(csa);
#line 2620
    bbar_st = 1;
    }
#line 2622
    if (csa->phase == 0) {
      {
#line 2623
      tmp___1 = set_aux_obj(csa, (double )parm->tol_bnd);
      }
#line 2623
      if (tmp___1 > 0) {
#line 2626
        csa->phase = 1;
      } else {
        {
#line 2631
        set_orig_obj(csa);
#line 2632
        csa->phase = 2;
        }
      }
      {
#line 2634
      tmp___2 = check_stab___0(csa, (double )parm->tol_bnd);
      }
#line 2634
      if (tmp___2 == 0) {
#line 2634
        tmp___3 = 1;
      } else {
        {
#line 2634
        _glp_lib_xassert("check_stab(csa, parm->tol_bnd) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2634);
#line 2634
        tmp___3 = 1;
        }
      }
      {
#line 2637
      cbar_st = 0;
#line 2638
      display___0(csa, parm, 1);
      }
    }
    {
#line 2642
    tmp___5 = check_stab___0(csa, (double )parm->tol_bnd);
    }
#line 2642
    if (tmp___5) {
#line 2645
      if (parm->msg_lev >= 1) {
#line 2646
        if (csa->phase == 1) {
#line 2646
          tmp___4 = "I";
        } else {
#line 2646
          tmp___4 = "II";
        }
        {
#line 2646
        _glp_lib_xprintf("Warning: numerical instability (primal simplex, phase %s)\n",
                         tmp___4);
        }
      }
#line 2649
      csa->phase = 0;
#line 2650
      binv_st = 0;
#line 2651
      rigorous = 5;
#line 2652
      goto loop;
    }
  }
#line 2655
  if (csa->phase == 1) {
#line 2655
    tmp___6 = 1;
  } else
#line 2655
  if (csa->phase == 2) {
#line 2655
    tmp___6 = 1;
  } else {
    {
#line 2655
    _glp_lib_xassert("csa->phase == 1 || csa->phase == 2", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     2655);
#line 2655
    tmp___6 = 1;
    }
  }
#line 2659
  if (csa->phase == 1) {
    {
#line 2659
    tmp___7 = check_feas___0(csa, (double )parm->tol_bnd);
    }
#line 2659
    if (! tmp___7) {
      {
#line 2661
      csa->phase = 2;
#line 2662
      set_orig_obj(csa);
#line 2663
      cbar_st = 0;
#line 2664
      display___0(csa, parm, 1);
      }
    }
  }
#line 2667
  if (cbar_st == 0) {
    {
#line 2668
    eval_cbar___0(csa);
#line 2669
    cbar_st = 1;
    }
  }
  {
#line 2673
  if (parm->pricing == 17) {
#line 2673
    goto case_17;
  }
#line 2675
  if (parm->pricing == 34) {
#line 2675
    goto case_34;
  }
#line 2678
  goto switch_default;
  case_17: /* CIL Label */ 
#line 2674
  goto switch_break;
  case_34: /* CIL Label */ 
#line 2676
  if (csa->refct == 0) {
    {
#line 2676
    reset_refsp___0(csa);
    }
  }
#line 2677
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2679
  if ((unsigned long )parm != (unsigned long )parm) {
#line 2679
    tmp___8 = 1;
  } else {
    {
#line 2679
    _glp_lib_xassert("parm != parm", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     2679);
#line 2679
    tmp___8 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 2683
  if (binv_st) {
#line 2683
    if (bbar_st) {
#line 2683
      if (cbar_st) {
#line 2683
        tmp___9 = 1;
      } else {
        {
#line 2683
        _glp_lib_xassert("binv_st && bbar_st && cbar_st", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2683);
#line 2683
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 2683
      _glp_lib_xassert("binv_st && bbar_st && cbar_st", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2683);
#line 2683
      tmp___9 = 1;
      }
    }
  } else {
    {
#line 2683
    _glp_lib_xassert("binv_st && bbar_st && cbar_st", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     2683);
#line 2683
    tmp___9 = 1;
    }
  }
#line 2686
  if (check) {
    {
#line 2687
    tmp___10 = err_in_bbar___0(csa);
#line 2687
    e_bbar = tmp___10;
#line 2688
    tmp___11 = err_in_cbar___0(csa);
#line 2688
    e_cbar = tmp___11;
    }
#line 2689
    if (parm->pricing == 34) {
      {
#line 2689
      tmp___12 = err_in_gamma___0(csa);
#line 2689
      tmp___13 = tmp___12;
      }
    } else {
#line 2689
      tmp___13 = 0.0;
    }
    {
#line 2689
    e_gamma = tmp___13;
#line 2691
    _glp_lib_xprintf("e_bbar = %10.3e; e_cbar = %10.3e; e_gamma = %10.3e\n", e_bbar,
                     e_cbar, e_gamma);
    }
#line 2693
    if (e_bbar <= 1e-5) {
#line 2693
      if (e_cbar <= 1e-5) {
#line 2693
        if (e_gamma <= 1e-3) {
#line 2693
          tmp___14 = 1;
        } else {
          {
#line 2693
          _glp_lib_xassert("e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3",
                           "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c", 2693);
#line 2693
          tmp___14 = 1;
          }
        }
      } else {
        {
#line 2693
        _glp_lib_xassert("e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2693);
#line 2693
        tmp___14 = 1;
        }
      }
    } else {
      {
#line 2693
      _glp_lib_xassert("e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2693);
#line 2693
      tmp___14 = 1;
      }
    }
  }
#line 2696
  if (parm->it_lim < 2147483647) {
#line 2696
    if (csa->it_cnt - csa->it_beg >= (int )parm->it_lim) {
#line 2698
      if (bbar_st != 1) {
#line 2698
        goto _L;
      } else
#line 2698
      if (csa->phase == 2) {
#line 2698
        if (cbar_st != 1) {
          _L: /* CIL Label */ 
#line 2699
          if (bbar_st != 1) {
#line 2699
            bbar_st = 0;
          }
#line 2700
          if (csa->phase == 2) {
#line 2700
            if (cbar_st != 1) {
#line 2700
              cbar_st = 0;
            }
          }
#line 2701
          goto loop;
        }
      }
      {
#line 2703
      display___0(csa, parm, 1);
      }
#line 2704
      if (parm->msg_lev >= 3) {
        {
#line 2705
        _glp_lib_xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
        }
      }
      {
#line 2707
      if (csa->phase == 1) {
#line 2707
        goto case_1;
      }
#line 2712
      if (csa->phase == 2) {
#line 2712
        goto case_2;
      }
#line 2715
      goto switch_default___0;
      case_1: /* CIL Label */ 
      {
#line 2708
      p_stat = 3;
#line 2709
      set_orig_obj(csa);
#line 2710
      eval_cbar___0(csa);
      }
#line 2711
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 2713
      p_stat = 2;
#line 2714
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2716
      if ((unsigned long )csa != (unsigned long )csa) {
#line 2716
        tmp___15 = 1;
      } else {
        {
#line 2716
        _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2716);
#line 2716
        tmp___15 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 2718
      chuzc___0(csa, (double )parm->tol_dj);
      }
#line 2719
      if (csa->q == 0) {
#line 2719
        d_stat = 2;
      } else {
#line 2719
        d_stat = 3;
      }
      {
#line 2720
      store_sol___0(csa, lp, p_stat, d_stat, 0);
#line 2721
      ret = 8;
      }
#line 2722
      goto done;
    }
  }
#line 2725
  if (parm->tm_lim < 2147483647) {
    {
#line 2725
    tmp___17 = _glp_lib_xtime();
#line 2725
    tmp___18 = _glp_lib_xdifftime(tmp___17, csa->tm_beg);
    }
#line 2725
    if (1000.0 * tmp___18 >= (double )parm->tm_lim) {
#line 2727
      if (bbar_st != 1) {
#line 2727
        goto _L___0;
      } else
#line 2727
      if (csa->phase == 2) {
#line 2727
        if (cbar_st != 1) {
          _L___0: /* CIL Label */ 
#line 2728
          if (bbar_st != 1) {
#line 2728
            bbar_st = 0;
          }
#line 2729
          if (csa->phase == 2) {
#line 2729
            if (cbar_st != 1) {
#line 2729
              cbar_st = 0;
            }
          }
#line 2730
          goto loop;
        }
      }
      {
#line 2732
      display___0(csa, parm, 1);
      }
#line 2733
      if (parm->msg_lev >= 3) {
        {
#line 2734
        _glp_lib_xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
        }
      }
      {
#line 2736
      if (csa->phase == 1) {
#line 2736
        goto case_1___0;
      }
#line 2741
      if (csa->phase == 2) {
#line 2741
        goto case_2___0;
      }
#line 2744
      goto switch_default___1;
      case_1___0: /* CIL Label */ 
      {
#line 2737
      p_stat = 3;
#line 2738
      set_orig_obj(csa);
#line 2739
      eval_cbar___0(csa);
      }
#line 2740
      goto switch_break___1;
      case_2___0: /* CIL Label */ 
#line 2742
      p_stat = 2;
#line 2743
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 2745
      if ((unsigned long )csa != (unsigned long )csa) {
#line 2745
        tmp___16 = 1;
      } else {
        {
#line 2745
        _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2745);
#line 2745
        tmp___16 = 1;
        }
      }
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 2747
      chuzc___0(csa, (double )parm->tol_dj);
      }
#line 2748
      if (csa->q == 0) {
#line 2748
        d_stat = 2;
      } else {
#line 2748
        d_stat = 3;
      }
      {
#line 2749
      store_sol___0(csa, lp, p_stat, d_stat, 0);
#line 2750
      ret = 9;
      }
#line 2751
      goto done;
    }
  }
  {
#line 2754
  display___0(csa, parm, 0);
#line 2756
  chuzc___0(csa, (double )parm->tol_dj);
  }
#line 2757
  if (csa->q == 0) {
#line 2758
    if (bbar_st != 1) {
#line 2758
      goto _L___1;
    } else
#line 2758
    if (cbar_st != 1) {
      _L___1: /* CIL Label */ 
#line 2759
      if (bbar_st != 1) {
#line 2759
        bbar_st = 0;
      }
#line 2760
      if (cbar_st != 1) {
#line 2760
        cbar_st = 0;
      }
#line 2761
      goto loop;
    }
    {
#line 2763
    display___0(csa, parm, 1);
    }
    {
#line 2765
    if (csa->phase == 1) {
#line 2765
      goto case_1___1;
    }
#line 2774
    if (csa->phase == 2) {
#line 2774
      goto case_2___1;
    }
#line 2779
    goto switch_default___2;
    case_1___1: /* CIL Label */ 
#line 2766
    if (parm->msg_lev >= 3) {
      {
#line 2767
      _glp_lib_xprintf("PROBLEM HAS NO FEASIBLE SOLUTION\n");
      }
    }
    {
#line 2768
    p_stat = 4;
#line 2769
    set_orig_obj(csa);
#line 2770
    eval_cbar___0(csa);
#line 2771
    chuzc___0(csa, (double )parm->tol_dj);
    }
#line 2772
    if (csa->q == 0) {
#line 2772
      d_stat = 2;
    } else {
#line 2772
      d_stat = 3;
    }
#line 2773
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
#line 2775
    if (parm->msg_lev >= 3) {
      {
#line 2776
      _glp_lib_xprintf("OPTIMAL SOLUTION FOUND\n");
      }
    }
#line 2777
    d_stat = 2;
#line 2777
    p_stat = d_stat;
#line 2778
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2780
    if ((unsigned long )csa != (unsigned long )csa) {
#line 2780
      tmp___19 = 1;
    } else {
      {
#line 2780
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2780);
#line 2780
      tmp___19 = 1;
      }
    }
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 2782
    store_sol___0(csa, lp, p_stat, d_stat, 0);
#line 2783
    ret = 0;
    }
#line 2784
    goto done;
  }
  {
#line 2787
  eval_tcol___0(csa);
  }
#line 2788
  if (rigorous) {
    {
#line 2788
    refine_tcol___0(csa);
    }
  }
  {
#line 2789
  sort_tcol(csa, (double )parm->tol_piv);
#line 2791
  d1 = *(csa->cbar + csa->q);
#line 2792
  tmp___20 = reeval_cost(csa);
#line 2792
  d2 = tmp___20;
  }
#line 2793
  if (d1 != 0.0) {
#line 2793
    tmp___21 = 1;
  } else {
    {
#line 2793
    _glp_lib_xassert("d1 != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     2793);
#line 2793
    tmp___21 = 1;
    }
  }
  {
#line 2794
  tmp___22 = fabs(d1 - d2);
#line 2794
  tmp___23 = fabs(d2);
  }
#line 2794
  if (tmp___22 > 1e-5 * (1.0 + tmp___23)) {
#line 2794
    goto _L___4;
  } else
#line 2794
  if (d1 < 0.0) {
#line 2794
    if (! (d2 < 0.0)) {
#line 2794
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 2794
  if (d1 > 0.0) {
#line 2794
    if (! (d2 > 0.0)) {
#line 2794
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
#line 2796
    if (parm->msg_lev >= 4) {
      {
#line 2797
      _glp_lib_xprintf("d1 = %.12g; d2 = %.12g\n", d1, d2);
      }
    }
#line 2798
    if (cbar_st != 1) {
#line 2798
      goto _L___2;
    } else
#line 2798
    if (! rigorous) {
      _L___2: /* CIL Label */ 
#line 2799
      if (cbar_st != 1) {
#line 2799
        cbar_st = 0;
      }
#line 2800
      rigorous = 5;
#line 2801
      goto loop;
    }
  }
#line 2805
  if (d1 > 0.0) {
#line 2806
    if (d2 > 0.0) {
#line 2806
      *(csa->cbar + csa->q) = d2;
    } else {
#line 2806
      *(csa->cbar + csa->q) = 2.2204460492503131e-16;
    }
  } else
#line 2808
  if (d2 < 0.0) {
#line 2808
    *(csa->cbar + csa->q) = d2;
  } else {
#line 2808
    *(csa->cbar + csa->q) = - 2.2204460492503131e-16;
  }
  {
#line 2812
  if (parm->r_test == 17) {
#line 2812
    goto case_17___0;
  }
#line 2815
  if (parm->r_test == 34) {
#line 2815
    goto case_34___0;
  }
#line 2818
  goto switch_default___3;
  case_17___0: /* CIL Label */ 
  {
#line 2813
  chuzr___0(csa, 0.0);
  }
#line 2814
  goto switch_break___3;
  case_34___0: /* CIL Label */ 
  {
#line 2816
  chuzr___0(csa, 0.30 * (double )parm->tol_bnd);
  }
#line 2817
  goto switch_break___3;
  switch_default___3: /* CIL Label */ 
#line 2819
  if ((unsigned long )parm != (unsigned long )parm) {
#line 2819
    tmp___24 = 1;
  } else {
    {
#line 2819
    _glp_lib_xassert("parm != parm", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                     2819);
#line 2819
    tmp___24 = 1;
    }
  }
  switch_break___3: /* CIL Label */ ;
  }
#line 2821
  if (csa->p == 0) {
#line 2822
    if (bbar_st != 1) {
#line 2822
      goto _L___6;
    } else
#line 2822
    if (cbar_st != 1) {
#line 2822
      goto _L___6;
    } else
#line 2822
    if (! rigorous) {
      _L___6: /* CIL Label */ 
#line 2823
      if (bbar_st != 1) {
#line 2823
        bbar_st = 0;
      }
#line 2824
      if (cbar_st != 1) {
#line 2824
        cbar_st = 0;
      }
#line 2825
      rigorous = 1;
#line 2826
      goto loop;
    }
    {
#line 2828
    display___0(csa, parm, 1);
    }
    {
#line 2830
    if (csa->phase == 1) {
#line 2830
      goto case_1___2;
    }
#line 2842
    if (csa->phase == 2) {
#line 2842
      goto case_2___2;
    }
#line 2849
    goto switch_default___4;
    case_1___2: /* CIL Label */ 
#line 2831
    if (parm->msg_lev >= 1) {
      {
#line 2832
      _glp_lib_xprintf("Error: unable to choose basic variable on phase I\n");
      }
    }
#line 2834
    if (! lp->valid) {
#line 2834
      if ((unsigned long )lp->bfd == (unsigned long )((void *)0)) {
#line 2834
        tmp___25 = 1;
      } else {
        {
#line 2834
        _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                         2834);
#line 2834
        tmp___25 = 1;
        }
      }
    } else {
      {
#line 2834
      _glp_lib_xassert("!lp->valid && lp->bfd == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2834);
#line 2834
      tmp___25 = 1;
      }
    }
#line 2835
    lp->bfd = csa->bfd;
#line 2835
    csa->bfd = (BFD *)((void *)0);
#line 2836
    tmp___26 = 1;
#line 2836
    lp->dbs_stat = tmp___26;
#line 2836
    lp->pbs_stat = tmp___26;
#line 2837
    lp->obj_val = 0.0;
#line 2838
    lp->it_cnt = csa->it_cnt;
#line 2839
    lp->some = 0;
#line 2840
    ret = 5;
#line 2841
    goto switch_break___4;
    case_2___2: /* CIL Label */ 
#line 2843
    if (parm->msg_lev >= 3) {
      {
#line 2844
      _glp_lib_xprintf("PROBLEM HAS UNBOUNDED SOLUTION\n");
      }
    }
    {
#line 2845
    store_sol___0(csa, lp, 2, 4, *(csa->head + (csa->m + csa->q)));
#line 2847
    ret = 0;
    }
#line 2848
    goto switch_break___4;
    switch_default___4: /* CIL Label */ 
#line 2850
    if ((unsigned long )csa != (unsigned long )csa) {
#line 2850
      tmp___27 = 1;
    } else {
      {
#line 2850
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2850);
#line 2850
      tmp___27 = 1;
      }
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 2852
    goto done;
  }
#line 2855
  if (csa->p > 0) {
    {
#line 2856
    piv = *(csa->tcol_vec + csa->p);
#line 2857
    eps = 1e-5 * (1.0 + 0.01 * csa->tcol_max);
#line 2858
    tmp___28 = fabs(piv);
    }
#line 2858
    if (tmp___28 < eps) {
#line 2859
      if (parm->msg_lev >= 4) {
        {
#line 2860
        _glp_lib_xprintf("piv = %.12g; eps = %g\n", piv, eps);
        }
      }
#line 2861
      if (! rigorous) {
#line 2862
        rigorous = 5;
#line 2863
        goto loop;
      }
    }
  }
#line 2869
  if (csa->p > 0) {
    {
#line 2870
    rho = csa->work4;
#line 2871
    eval_rho___0(csa, rho);
    }
#line 2872
    if (rigorous) {
      {
#line 2872
      refine_rho___0(csa, rho);
      }
    }
    {
#line 2873
    eval_trow___0(csa, rho);
    }
  }
#line 2876
  if (csa->p > 0) {
#line 2877
    piv1 = *(csa->tcol_vec + csa->p);
#line 2878
    piv2 = *(csa->trow_vec + csa->q);
#line 2879
    if (piv1 != 0.0) {
#line 2879
      tmp___29 = 1;
    } else {
      {
#line 2879
      _glp_lib_xassert("piv1 != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2879);
#line 2879
      tmp___29 = 1;
      }
    }
    {
#line 2880
    tmp___31 = fabs(piv1 - piv2);
#line 2880
    tmp___32 = fabs(piv1);
    }
#line 2880
    if (tmp___31 > 1e-8 * (1.0 + tmp___32)) {
#line 2880
      goto _L___9;
    } else
#line 2880
    if (piv1 > 0.0) {
#line 2880
      if (! (piv2 > 0.0)) {
#line 2880
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 2880
    if (piv1 < 0.0) {
#line 2880
      if (! (piv2 < 0.0)) {
#line 2880
        goto _L___9;
      }
    } else {
      _L___9: /* CIL Label */ 
#line 2882
      if (parm->msg_lev >= 4) {
        {
#line 2883
        _glp_lib_xprintf("piv1 = %.12g; piv2 = %.12g\n", piv1, piv2);
        }
      }
#line 2884
      if (binv_st != 1) {
#line 2884
        goto _L___7;
      } else
#line 2884
      if (! rigorous) {
        _L___7: /* CIL Label */ 
#line 2885
        if (binv_st != 1) {
#line 2885
          binv_st = 0;
        }
#line 2886
        rigorous = 5;
#line 2887
        goto loop;
      }
#line 2890
      if (*(csa->trow_vec + csa->q) == 0.0) {
#line 2891
        (csa->trow_nnz) ++;
#line 2892
        if (csa->trow_nnz <= csa->n) {
#line 2892
          tmp___30 = 1;
        } else {
          {
#line 2892
          _glp_lib_xassert("csa->trow_nnz <= csa->n", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                           2892);
#line 2892
          tmp___30 = 1;
          }
        }
#line 2893
        *(csa->trow_ind + csa->trow_nnz) = csa->q;
      }
#line 2895
      *(csa->trow_vec + csa->q) = piv1;
    }
  }
  {
#line 2899
  update_bbar___0(csa);
#line 2900
  bbar_st = 2;
  }
#line 2902
  if (csa->p > 0) {
    {
#line 2903
    update_cbar___0(csa);
#line 2904
    cbar_st = 2;
    }
#line 2907
    if (csa->phase == 1) {
#line 2908
      k = *(csa->head + csa->p);
#line 2909
      *(csa->cbar + csa->q) -= *(csa->coef + k);
#line 2910
      *(csa->coef + k) = 0.0;
    }
  }
#line 2914
  if (csa->p > 0) {
    {
#line 2916
    if (parm->pricing == 17) {
#line 2916
      goto case_17___1;
    }
#line 2918
    if (parm->pricing == 34) {
#line 2918
      goto case_34___1;
    }
#line 2921
    goto switch_default___5;
    case_17___1: /* CIL Label */ 
#line 2917
    goto switch_break___5;
    case_34___1: /* CIL Label */ 
#line 2919
    if (csa->refct > 0) {
      {
#line 2919
      update_gamma___0(csa);
      }
    }
#line 2920
    goto switch_break___5;
    switch_default___5: /* CIL Label */ 
#line 2922
    if ((unsigned long )parm != (unsigned long )parm) {
#line 2922
      tmp___33 = 1;
    } else {
      {
#line 2922
      _glp_lib_xassert("parm != parm", "/home/wslee/benchmarks/glpk-4.38/src/glpspx01.c",
                       2922);
#line 2922
      tmp___33 = 1;
      }
    }
    switch_break___5: /* CIL Label */ ;
    }
  }
#line 2926
  if (csa->p > 0) {
    {
#line 2927
    ret = update_B___0(csa, csa->p, *(csa->head + (csa->m + csa->q)));
    }
#line 2928
    if (ret == 0) {
#line 2929
      binv_st = 2;
    } else {
#line 2931
      csa->valid = 0;
#line 2932
      binv_st = 0;
    }
  }
#line 2936
  if (csa->p > 0) {
    {
#line 2937
    del_N_col(csa, csa->q, *(csa->head + (csa->m + csa->q)));
    }
#line 2938
    if ((int )*(csa->type + *(csa->head + csa->p)) != 5) {
      {
#line 2939
      add_N_col(csa, csa->q, *(csa->head + csa->p));
      }
    }
  }
  {
#line 2942
  change_basis___0(csa);
#line 2944
  (csa->it_cnt) ++;
  }
#line 2945
  if (rigorous > 0) {
#line 2945
    rigorous --;
  }
#line 2946
  goto loop;
  done: 
  {
#line 2948
  free_csa___0(csa);
  }
#line 2950
  return (ret);
}
}
#line 117 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.h"
HBM *_glp_hbm_read_mat(char const   *fname ) ;
#line 121
void _glp_hbm_free_mat(HBM *hbm ) ;
#line 28 "/home/wslee/benchmarks/glpk-4.38/src/glprgr.h"
int _glp_rgr_write_bmp16(char const   *fname , int m , int n , char const   *map ) ;
#line 58 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.h"
DMP *_glp_dmp_create_pool(void) ;
#line 62
void *_glp_dmp_get_atom(DMP *pool , int size ) ;
#line 66
void _glp_dmp_free_atom(DMP *pool , void *atom , int size ) ;
#line 74
void _glp_dmp_delete_pool(DMP *pool ) ;
#line 77 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.h"
SPM *_glp_spm_create_mat(int m , int n ) ;
#line 81
SPME *_glp_spm_new_elem(SPM *A , int i , int j , double val ) ;
#line 85
void _glp_spm_delete_mat(SPM *A ) ;
#line 89
SPM *_glp_spm_test_mat_e(int n , int c ) ;
#line 93
SPM *_glp_spm_test_mat_d(int n , int c ) ;
#line 97
int _glp_spm_show_mat(SPM const   *A , char const   *fname ) ;
#line 101
SPM *_glp_spm_read_hbm(char const   *fname ) ;
#line 105
int _glp_spm_count_nnz(SPM const   *A ) ;
#line 109
int _glp_spm_drop_zeros(SPM *A , double eps ) ;
#line 113
SPM *_glp_spm_read_mat(char const   *fname ) ;
#line 117
int _glp_spm_write_mat(SPM const   *A , char const   *fname ) ;
#line 121
SPM *_glp_spm_transpose(SPM const   *A ) ;
#line 125
SPM *_glp_spm_add_sym(SPM const   *A , SPM const   *B ) ;
#line 129
void _glp_spm_add_num(SPM *C , double alfa , SPM const   *A , double beta , SPM const   *B ) ;
#line 134
SPM *_glp_spm_add_mat(double alfa , SPM const   *A , double beta , SPM const   *B ) ;
#line 139
SPM *_glp_spm_mul_sym(SPM const   *A , SPM const   *B ) ;
#line 143
void _glp_spm_mul_num(SPM *C , SPM const   *A , SPM const   *B ) ;
#line 147
SPM *_glp_spm_mul_mat(SPM const   *A , SPM const   *B ) ;
#line 151
PER *_glp_spm_create_per(int n ) ;
#line 155
void _glp_spm_check_per(PER *P ) ;
#line 159
void _glp_spm_delete_per(PER *P ) ;
#line 48 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_create_mat(int m , int n ) 
{ 
  SPM *A ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int i ;
  int j ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 50
  if (0 <= m) {
#line 50
    if (m < 2147483647) {
#line 50
      tmp = 1;
    } else {
      {
#line 50
      _glp_lib_xassert("0 <= m && m < INT_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       50);
#line 50
      tmp = 1;
      }
    }
  } else {
    {
#line 50
    _glp_lib_xassert("0 <= m && m < INT_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     50);
#line 50
    tmp = 1;
    }
  }
#line 51
  if (0 <= n) {
#line 51
    if (n < 2147483647) {
#line 51
      tmp___0 = 1;
    } else {
      {
#line 51
      _glp_lib_xassert("0 <= n && n < INT_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       51);
#line 51
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 51
    _glp_lib_xassert("0 <= n && n < INT_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     51);
#line 51
    tmp___0 = 1;
    }
  }
  {
#line 52
  tmp___1 = _glp_lib_xmalloc((int )sizeof(SPM ));
#line 52
  A = (SPM *)tmp___1;
#line 53
  A->m = m;
#line 54
  A->n = n;
  }
#line 55
  if (m == 0) {
#line 56
    A->pool = (DMP *)((void *)0);
#line 57
    A->row = (SPME **)((void *)0);
#line 58
    A->col = (SPME **)((void *)0);
  } else
#line 55
  if (n == 0) {
#line 56
    A->pool = (DMP *)((void *)0);
#line 57
    A->row = (SPME **)((void *)0);
#line 58
    A->col = (SPME **)((void *)0);
  } else {
    {
#line 62
    A->pool = _glp_dmp_create_pool();
#line 63
    tmp___2 = _glp_lib_xcalloc(1 + m, (int )sizeof(SPME *));
#line 63
    A->row = (SPME **)tmp___2;
#line 64
    i = 1;
    }
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
#line 64
      if (! (i <= m)) {
#line 64
        goto while_break;
      }
#line 64
      *(A->row + i) = (SPME *)((void *)0);
#line 64
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 65
    tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(SPME *));
#line 65
    A->col = (SPME **)tmp___3;
#line 66
    j = 1;
    }
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! (j <= n)) {
#line 66
        goto while_break___0;
      }
#line 66
      *(A->col + j) = (SPME *)((void *)0);
#line 66
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 68
  return (A);
}
}
#line 91 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPME *_glp_spm_new_elem(SPM *A , int i , int j , double val ) 
{ 
  SPME *e ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  SPME *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 93
  if (1 <= i) {
#line 93
    if (i <= A->m) {
#line 93
      tmp = 1;
    } else {
      {
#line 93
      _glp_lib_xassert("1 <= i && i <= A->m", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       93);
#line 93
      tmp = 1;
      }
    }
  } else {
    {
#line 93
    _glp_lib_xassert("1 <= i && i <= A->m", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     93);
#line 93
    tmp = 1;
    }
  }
#line 94
  if (1 <= j) {
#line 94
    if (j <= A->n) {
#line 94
      tmp___0 = 1;
    } else {
      {
#line 94
      _glp_lib_xassert("1 <= j && j <= A->n", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       94);
#line 94
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 94
    _glp_lib_xassert("1 <= j && j <= A->n", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     94);
#line 94
    tmp___0 = 1;
    }
  }
  {
#line 95
  tmp___1 = _glp_dmp_get_atom(A->pool, (int )sizeof(SPME ));
#line 95
  e = (SPME *)tmp___1;
#line 96
  e->i = i;
#line 97
  e->j = j;
#line 98
  e->val = val;
#line 99
  e->r_prev = (SPME *)((void *)0);
#line 100
  e->r_next = *(A->row + i);
  }
#line 101
  if ((unsigned long )e->r_next != (unsigned long )((void *)0)) {
#line 101
    (e->r_next)->r_prev = e;
  }
#line 102
  e->c_prev = (SPME *)((void *)0);
#line 103
  e->c_next = *(A->col + j);
#line 104
  if ((unsigned long )e->c_next != (unsigned long )((void *)0)) {
#line 104
    (e->c_next)->c_prev = e;
  }
#line 105
  tmp___2 = e;
#line 105
  *(A->col + j) = tmp___2;
#line 105
  *(A->row + i) = tmp___2;
#line 106
  return (e);
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
void _glp_spm_delete_mat(SPM *A ) 
{ 


  {
#line 126
  if ((unsigned long )A->pool != (unsigned long )((void *)0)) {
    {
#line 126
    _glp_dmp_delete_pool(A->pool);
    }
  }
#line 127
  if ((unsigned long )A->row != (unsigned long )((void *)0)) {
    {
#line 127
    _glp_lib_xfree((void *)A->row);
    }
  }
#line 128
  if ((unsigned long )A->col != (unsigned long )((void *)0)) {
    {
#line 128
    _glp_lib_xfree((void *)A->col);
    }
  }
  {
#line 129
  _glp_lib_xfree((void *)A);
  }
#line 130
  return;
}
}
#line 161 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_test_mat_e(int n , int c ) 
{ 
  SPM *A ;
  int i ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 164
  if (n >= 3) {
#line 164
    if (2 <= c) {
#line 164
      if (c <= n - 1) {
#line 164
        tmp = 1;
      } else {
        {
#line 164
        _glp_lib_xassert("n >= 3 && 2 <= c && c <= n-1", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                         164);
#line 164
        tmp = 1;
        }
      }
    } else {
      {
#line 164
      _glp_lib_xassert("n >= 3 && 2 <= c && c <= n-1", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       164);
#line 164
      tmp = 1;
      }
    }
  } else {
    {
#line 164
    _glp_lib_xassert("n >= 3 && 2 <= c && c <= n-1", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     164);
#line 164
    tmp = 1;
    }
  }
  {
#line 165
  A = _glp_spm_create_mat(n, n);
#line 166
  i = 1;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i <= n)) {
#line 166
      goto while_break;
    }
    {
#line 167
    _glp_spm_new_elem(A, i, i, 4.0);
#line 166
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  i = 1;
  {
#line 168
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 168
    if (! (i <= n - 1)) {
#line 168
      goto while_break___0;
    }
    {
#line 169
    _glp_spm_new_elem(A, i, i + 1, - 1.0);
#line 170
    _glp_spm_new_elem(A, i + 1, i, - 1.0);
#line 168
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 172
  i = 1;
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 172
    if (! (i <= n - c)) {
#line 172
      goto while_break___1;
    }
    {
#line 173
    _glp_spm_new_elem(A, i, i + c, - 1.0);
#line 174
    _glp_spm_new_elem(A, i + c, i, - 1.0);
#line 172
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 176
  return (A);
}
}
#line 207 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_test_mat_d(int n , int c ) 
{ 
  SPM *A ;
  int i ;
  int j ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 210
  if (n >= 14) {
#line 210
    if (1 <= c) {
#line 210
      if (c <= n - 13) {
#line 210
        tmp = 1;
      } else {
        {
#line 210
        _glp_lib_xassert("n >= 14 && 1 <= c && c <= n-13", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                         210);
#line 210
        tmp = 1;
        }
      }
    } else {
      {
#line 210
      _glp_lib_xassert("n >= 14 && 1 <= c && c <= n-13", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       210);
#line 210
      tmp = 1;
      }
    }
  } else {
    {
#line 210
    _glp_lib_xassert("n >= 14 && 1 <= c && c <= n-13", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     210);
#line 210
    tmp = 1;
    }
  }
  {
#line 211
  A = _glp_spm_create_mat(n, n);
#line 212
  i = 1;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i <= n)) {
#line 212
      goto while_break;
    }
    {
#line 213
    _glp_spm_new_elem(A, i, i, 1.0);
#line 212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  i = 1;
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    if (! (i <= n - c)) {
#line 214
      goto while_break___0;
    }
    {
#line 215
    _glp_spm_new_elem(A, i, i + c, (double )(i + 1));
#line 214
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  i = (n - c) + 1;
  {
#line 216
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 216
    if (! (i <= n)) {
#line 216
      goto while_break___1;
    }
    {
#line 217
    _glp_spm_new_elem(A, i, (i - n) + c, (double )(i + 1));
#line 216
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 218
  i = 1;
  {
#line 218
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 218
    if (! (i <= (n - c) - 1)) {
#line 218
      goto while_break___2;
    }
    {
#line 219
    _glp_spm_new_elem(A, i, (i + c) + 1, (double )(- i));
#line 218
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 220
  i = n - c;
  {
#line 220
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 220
    if (! (i <= n)) {
#line 220
      goto while_break___3;
    }
    {
#line 221
    _glp_spm_new_elem(A, i, ((i - n) + c) + 1, (double )(- i));
#line 220
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 222
  i = 1;
  {
#line 222
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 222
    if (! (i <= (n - c) - 2)) {
#line 222
      goto while_break___4;
    }
    {
#line 223
    _glp_spm_new_elem(A, i, (i + c) + 2, 16.0);
#line 222
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 224
  i = (n - c) - 1;
  {
#line 224
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 224
    if (! (i <= n)) {
#line 224
      goto while_break___5;
    }
    {
#line 225
    _glp_spm_new_elem(A, i, ((i - n) + c) + 2, 16.0);
#line 224
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 226
  j = 1;
  {
#line 226
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 226
    if (! (j <= 10)) {
#line 226
      goto while_break___6;
    }
#line 227
    i = 1;
    {
#line 227
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 227
      if (! (i <= 11 - j)) {
#line 227
        goto while_break___7;
      }
      {
#line 228
      _glp_spm_new_elem(A, i, ((n - 11) + i) + j, 100.0 * (double )j);
#line 227
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 226
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 229
  return (A);
}
}
#line 262 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
int _glp_spm_show_mat(SPM const   *A , char const   *fname ) 
{ 
  int m ;
  int n ;
  int i ;
  int j ;
  int k ;
  int ret ;
  char *map ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  SPME *e ;
  int tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 263
  m = (int )A->m;
#line 264
  n = (int )A->n;
#line 267
  _glp_lib_xprintf("spm_show_mat: writing matrix pattern to `%s\'...\n", fname);
  }
#line 269
  if (1 <= m) {
#line 269
    if (m <= 32767) {
#line 269
      tmp = 1;
    } else {
      {
#line 269
      _glp_lib_xassert("1 <= m && m <= 32767", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       269);
#line 269
      tmp = 1;
      }
    }
  } else {
    {
#line 269
    _glp_lib_xassert("1 <= m && m <= 32767", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     269);
#line 269
    tmp = 1;
    }
  }
#line 270
  if (1 <= n) {
#line 270
    if (n <= 32767) {
#line 270
      tmp___0 = 1;
    } else {
      {
#line 270
      _glp_lib_xassert("1 <= n && n <= 32767", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       270);
#line 270
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 270
    _glp_lib_xassert("1 <= n && n <= 32767", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     270);
#line 270
    tmp___0 = 1;
    }
  }
  {
#line 271
  tmp___1 = _glp_lib_xmalloc(m * n);
#line 271
  map = (char *)tmp___1;
#line 272
  memset((void *)map, 8, (size_t )(m * n));
#line 273
  i = 1;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i <= m)) {
#line 273
      goto while_break;
    }
#line 275
    e = *(A->row + i);
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 275
        goto while_break___0;
      }
#line 276
      j = e->j;
#line 277
      if (1 <= j) {
#line 277
        if (j <= n) {
#line 277
          tmp___2 = 1;
        } else {
          {
#line 277
          _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                           277);
#line 277
          tmp___2 = 1;
          }
        }
      } else {
        {
#line 277
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                         277);
#line 277
        tmp___2 = 1;
        }
      }
#line 278
      k = n * (i - 1) + (j - 1);
#line 279
      if ((int )*(map + k) != 8) {
#line 280
        *(map + k) = (char)12;
      } else
#line 281
      if (e->val > 0.0) {
#line 282
        *(map + k) = (char)15;
      } else
#line 283
      if (e->val < 0.0) {
#line 284
        *(map + k) = (char)11;
      } else {
#line 286
        *(map + k) = (char)10;
      }
#line 275
      e = e->r_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 289
  ret = _glp_rgr_write_bmp16(fname, m, n, (char const   *)map);
#line 290
  _glp_lib_xfree((void *)map);
  }
#line 291
  return (ret);
}
}
#line 326 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_read_hbm(char const   *fname ) 
{ 
  SPM *A ;
  HBM *hbm ;
  int nrow ;
  int ncol ;
  int nnzero ;
  int i ;
  int j ;
  int beg ;
  int end ;
  int ptr ;
  int *colptr ;
  int *rowind ;
  double val ;
  double *values ;
  char *mxtype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
  {
#line 327
  A = (SPM *)((void *)0);
#line 332
  hbm = _glp_hbm_read_mat(fname);
  }
#line 333
  if ((unsigned long )hbm == (unsigned long )((void *)0)) {
    {
#line 334
    _glp_lib_xprintf("spm_read_hbm: unable to read matrix\n");
    }
#line 335
    goto fini;
  }
  {
#line 337
  mxtype = hbm->mxtype;
#line 338
  nrow = hbm->nrow;
#line 339
  ncol = hbm->ncol;
#line 340
  nnzero = hbm->nnzero;
#line 341
  colptr = hbm->colptr;
#line 342
  rowind = hbm->rowind;
#line 343
  values = hbm->values;
#line 344
  tmp = strcmp((char const   *)mxtype, "RSA");
  }
#line 344
  if (! (tmp == 0)) {
    {
#line 344
    tmp___0 = strcmp((char const   *)mxtype, "PSA");
    }
#line 344
    if (! (tmp___0 == 0)) {
      {
#line 344
      tmp___1 = strcmp((char const   *)mxtype, "RUA");
      }
#line 344
      if (! (tmp___1 == 0)) {
        {
#line 344
        tmp___2 = strcmp((char const   *)mxtype, "PUA");
        }
#line 344
        if (! (tmp___2 == 0)) {
          {
#line 344
          tmp___3 = strcmp((char const   *)mxtype, "RRA");
          }
#line 344
          if (! (tmp___3 == 0)) {
            {
#line 344
            tmp___4 = strcmp((char const   *)mxtype, "PRA");
            }
#line 344
            if (! (tmp___4 == 0)) {
              {
#line 347
              _glp_lib_xprintf("spm_read_hbm: matrix type `%s\' not supported\n",
                               mxtype);
              }
#line 349
              goto fini;
            }
          }
        }
      }
    }
  }
  {
#line 351
  A = _glp_spm_create_mat(nrow, ncol);
  }
#line 352
  if ((int )*(mxtype + 1) == 83) {
#line 352
    goto _L;
  } else
#line 352
  if ((int )*(mxtype + 1) == 85) {
    _L: /* CIL Label */ 
#line 353
    if (nrow == ncol) {
#line 353
      tmp___5 = 1;
    } else {
      {
#line 353
      _glp_lib_xassert("nrow == ncol", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       353);
#line 353
      tmp___5 = 1;
      }
    }
  }
#line 354
  j = 1;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (j <= ncol)) {
#line 354
      goto while_break;
    }
#line 355
    beg = *(colptr + j);
#line 356
    end = *(colptr + (j + 1));
#line 357
    if (1 <= beg) {
#line 357
      if (beg <= end) {
#line 357
        if (end <= nnzero + 1) {
#line 357
          tmp___6 = 1;
        } else {
          {
#line 357
          _glp_lib_xassert("1 <= beg && beg <= end && end <= nnzero + 1", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                           357);
#line 357
          tmp___6 = 1;
          }
        }
      } else {
        {
#line 357
        _glp_lib_xassert("1 <= beg && beg <= end && end <= nnzero + 1", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                         357);
#line 357
        tmp___6 = 1;
        }
      }
    } else {
      {
#line 357
      _glp_lib_xassert("1 <= beg && beg <= end && end <= nnzero + 1", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       357);
#line 357
      tmp___6 = 1;
      }
    }
#line 358
    ptr = beg;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 358
      if (! (ptr < end)) {
#line 358
        goto while_break___0;
      }
#line 359
      i = *(rowind + ptr);
#line 360
      if (1 <= i) {
#line 360
        if (i <= nrow) {
#line 360
          tmp___7 = 1;
        } else {
          {
#line 360
          _glp_lib_xassert("1 <= i && i <= nrow", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                           360);
#line 360
          tmp___7 = 1;
          }
        }
      } else {
        {
#line 360
        _glp_lib_xassert("1 <= i && i <= nrow", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                         360);
#line 360
        tmp___7 = 1;
        }
      }
#line 361
      if ((int )*(mxtype + 0) == 82) {
#line 362
        val = *(values + ptr);
      } else {
#line 364
        val = 1.0;
      }
      {
#line 365
      _glp_spm_new_elem(A, i, j, val);
      }
#line 366
      if ((int )*(mxtype + 1) == 83) {
#line 366
        if (i != j) {
          {
#line 367
          _glp_spm_new_elem(A, j, i, val);
          }
        }
      }
#line 358
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 354
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  fini: 
#line 370
  if ((unsigned long )hbm != (unsigned long )((void *)0)) {
    {
#line 370
    _glp_hbm_free_mat(hbm);
    }
  }
#line 371
  return (A);
}
}
#line 389 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
int _glp_spm_count_nnz(SPM const   *A ) 
{ 
  SPME *e ;
  int i ;
  int nnz ;

  {
#line 391
  nnz = 0;
#line 392
  i = 1;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (i <= (int )A->m)) {
#line 392
      goto while_break;
    }
#line 393
    e = *(A->row + i);
    {
#line 393
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 393
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 393
        goto while_break___0;
      }
#line 393
      nnz ++;
#line 393
      e = e->r_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 392
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return (nnz);
}
}
#line 419 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
int _glp_spm_drop_zeros(SPM *A , double eps ) 
{ 
  SPME *e ;
  SPME *next ;
  int i ;
  int count ;
  double tmp ;

  {
#line 421
  count = 0;
#line 422
  i = 1;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i <= A->m)) {
#line 422
      goto while_break;
    }
#line 423
    e = *(A->row + i);
    {
#line 423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 423
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 423
        goto while_break___0;
      }
#line 424
      next = e->r_next;
#line 425
      if (e->val == 0.0) {
#line 425
        goto _L;
      } else {
        {
#line 425
        tmp = fabs(e->val);
        }
#line 425
        if (tmp < eps) {
          _L: /* CIL Label */ 
#line 427
          if ((unsigned long )e->r_prev == (unsigned long )((void *)0)) {
#line 428
            *(A->row + e->i) = e->r_next;
          } else {
#line 430
            (e->r_prev)->r_next = e->r_next;
          }
#line 431
          if (! ((unsigned long )e->r_next == (unsigned long )((void *)0))) {
#line 434
            (e->r_next)->r_prev = e->r_prev;
          }
#line 436
          if ((unsigned long )e->c_prev == (unsigned long )((void *)0)) {
#line 437
            *(A->col + e->j) = e->c_next;
          } else {
#line 439
            (e->c_prev)->c_next = e->c_next;
          }
#line 440
          if (! ((unsigned long )e->c_next == (unsigned long )((void *)0))) {
#line 443
            (e->c_next)->c_prev = e->c_prev;
          }
          {
#line 445
          _glp_dmp_free_atom(A->pool, (void *)e, (int )sizeof(SPME ));
#line 446
          count ++;
          }
        }
      }
#line 423
      e = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 422
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  return (count);
}
}
#line 476 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_read_mat(char const   *fname ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 477
  if ((unsigned long )fname != (unsigned long )fname) {
#line 477
    tmp = 1;
  } else {
    {
#line 477
    _glp_lib_xassert("fname != fname", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     477);
#line 477
    tmp = 1;
    }
  }
#line 478
  return ((SPM *)((void *)0));
}
}
#line 574 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
int _glp_spm_write_mat(SPM const   *A , char const   *fname ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 575
  if ((unsigned long )A != (unsigned long )A) {
#line 575
    tmp = 1;
  } else {
    {
#line 575
    _glp_lib_xassert("A != A", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c", 575);
#line 575
    tmp = 1;
    }
  }
#line 576
  if ((unsigned long )fname != (unsigned long )fname) {
#line 576
    tmp___0 = 1;
  } else {
    {
#line 576
    _glp_lib_xassert("fname != fname", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     576);
#line 576
    tmp___0 = 1;
    }
  }
#line 577
  return (0);
}
}
#line 631 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_transpose(SPM const   *A ) 
{ 
  SPM *B ;
  int i ;
  SPME *e ;

  {
  {
#line 634
  B = _glp_spm_create_mat((int )A->n, (int )A->m);
#line 635
  i = 1;
  }
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i <= (int )A->m)) {
#line 635
      goto while_break;
    }
#line 637
    e = *(A->row + i);
    {
#line 637
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 637
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 637
        goto while_break___0;
      }
      {
#line 638
      _glp_spm_new_elem(B, e->j, i, e->val);
#line 637
      e = e->r_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 635
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  return (B);
}
}
#line 643 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_add_sym(SPM const   *A , SPM const   *B ) 
{ 
  SPM *C ;
  int i ;
  int j ;
  int *flag ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  SPME *e ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 647
  if (A->m == B->m) {
#line 647
    tmp = 1;
  } else {
    {
#line 647
    _glp_lib_xassert("A->m == B->m", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     647);
#line 647
    tmp = 1;
    }
  }
#line 648
  if (A->n == B->n) {
#line 648
    tmp___0 = 1;
  } else {
    {
#line 648
    _glp_lib_xassert("A->n == B->n", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     648);
#line 648
    tmp___0 = 1;
    }
  }
  {
#line 650
  C = _glp_spm_create_mat((int )A->m, (int )A->n);
#line 652
  tmp___1 = _glp_lib_xcalloc(1 + C->n, (int )sizeof(int ));
#line 652
  flag = (int *)tmp___1;
#line 653
  j = 1;
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! (j <= C->n)) {
#line 653
      goto while_break;
    }
#line 654
    *(flag + j) = 0;
#line 653
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  i = 1;
  {
#line 656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 656
    if (! (i <= C->m)) {
#line 656
      goto while_break___0;
    }
#line 660
    e = *(A->row + i);
    {
#line 660
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 660
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 660
        goto while_break___1;
      }
#line 662
      j = e->j;
#line 663
      if (! *(flag + j)) {
        {
#line 664
        _glp_spm_new_elem(C, i, j, 0.0);
#line 665
        *(flag + j) = 1;
        }
      }
#line 660
      e = e->r_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 669
    e = *(B->row + i);
    {
#line 669
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 669
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 669
        goto while_break___2;
      }
#line 671
      j = e->j;
#line 672
      if (! *(flag + j)) {
        {
#line 673
        _glp_spm_new_elem(C, i, j, 0.0);
#line 674
        *(flag + j) = 1;
        }
      }
#line 669
      e = e->r_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 678
    e = *(C->row + i);
    {
#line 678
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 678
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 678
        goto while_break___3;
      }
#line 679
      *(flag + e->j) = 0;
#line 678
      e = e->r_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 656
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 682
  j = 1;
  {
#line 682
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 682
    if (! (j <= C->n)) {
#line 682
      goto while_break___4;
    }
#line 683
    if (! *(flag + j)) {
#line 683
      tmp___2 = 1;
    } else {
      {
#line 683
      _glp_lib_xassert("!flag[j]", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       683);
#line 683
      tmp___2 = 1;
      }
    }
#line 682
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 684
  _glp_lib_xfree((void *)flag);
  }
#line 685
  return (C);
}
}
#line 688 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
void _glp_spm_add_num(SPM *C , double alfa , SPM const   *A , double beta , SPM const   *B ) 
{ 
  int i ;
  int j ;
  double *work ;
  void *tmp ;
  SPME *e ;
  int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 694
  tmp = _glp_lib_xcalloc(1 + C->n, (int )sizeof(double ));
#line 694
  work = (double *)tmp;
#line 695
  j = 1;
  }
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (j <= C->n)) {
#line 695
      goto while_break;
    }
#line 696
    *(work + j) = 0.0;
#line 695
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  i = 1;
  {
#line 698
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 698
    if (! (i <= C->n)) {
#line 698
      goto while_break___0;
    }
#line 702
    e = *(A->row + i);
    {
#line 702
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 702
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 702
        goto while_break___1;
      }
#line 703
      *(work + e->j) += alfa * e->val;
#line 702
      e = e->r_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 704
    e = *(B->row + i);
    {
#line 704
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 704
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 704
        goto while_break___2;
      }
#line 705
      *(work + e->j) += beta * e->val;
#line 704
      e = e->r_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 707
    e = *(C->row + i);
    {
#line 707
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 707
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 707
        goto while_break___3;
      }
#line 708
      j = e->j;
#line 709
      e->val = *(work + j);
#line 710
      *(work + j) = 0.0;
#line 707
      e = e->r_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 698
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 714
  j = 1;
  {
#line 714
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 714
    if (! (j <= C->n)) {
#line 714
      goto while_break___4;
    }
#line 715
    if (*(work + j) == 0.0) {
#line 715
      tmp___0 = 1;
    } else {
      {
#line 715
      _glp_lib_xassert("work[j] == 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       715);
#line 715
      tmp___0 = 1;
      }
    }
#line 714
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 716
  _glp_lib_xfree((void *)work);
  }
#line 717
  return;
}
}
#line 720 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_add_mat(double alfa , SPM const   *A , double beta , SPM const   *B ) 
{ 
  SPM *C ;

  {
  {
#line 723
  C = _glp_spm_add_sym(A, B);
#line 724
  _glp_spm_add_num(C, alfa, A, beta, B);
  }
#line 725
  return (C);
}
}
#line 728 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_mul_sym(SPM const   *A , SPM const   *B ) 
{ 
  int i ;
  int j ;
  int k ;
  int *flag ;
  SPM *C ;
  int tmp ;
  void *tmp___0 ;
  SPME *e ;
  SPME *ee ;
  int tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 732
  if (A->n == B->m) {
#line 732
    tmp = 1;
  } else {
    {
#line 732
    _glp_lib_xassert("A->n == B->m", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     732);
#line 732
    tmp = 1;
    }
  }
  {
#line 734
  C = _glp_spm_create_mat((int )A->m, (int )B->n);
#line 736
  tmp___0 = _glp_lib_xcalloc(1 + C->n, (int )sizeof(int ));
#line 736
  flag = (int *)tmp___0;
#line 737
  j = 1;
  }
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (! (j <= C->n)) {
#line 737
      goto while_break;
    }
#line 738
    *(flag + j) = 0;
#line 737
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 740
  i = 1;
  {
#line 740
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 740
    if (! (i <= C->m)) {
#line 740
      goto while_break___0;
    }
#line 743
    e = *(A->row + i);
    {
#line 743
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 743
        goto while_break___1;
      }
#line 744
      k = e->j;
#line 745
      ee = *(B->row + k);
      {
#line 745
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 745
        if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 745
          goto while_break___2;
        }
#line 746
        j = ee->j;
#line 748
        if (! *(flag + j)) {
          {
#line 750
          _glp_spm_new_elem(C, i, j, 0.0);
#line 751
          *(flag + j) = 1;
          }
        }
#line 745
        ee = ee->r_next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 743
      e = e->r_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 756
    e = *(C->row + i);
    {
#line 756
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 756
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 756
        goto while_break___3;
      }
#line 757
      *(flag + e->j) = 0;
#line 756
      e = e->r_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 740
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 760
  j = 1;
  {
#line 760
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 760
    if (! (j <= C->n)) {
#line 760
      goto while_break___4;
    }
#line 761
    if (! *(flag + j)) {
#line 761
      tmp___1 = 1;
    } else {
      {
#line 761
      _glp_lib_xassert("!flag[j]", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       761);
#line 761
      tmp___1 = 1;
      }
    }
#line 760
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 762
  _glp_lib_xfree((void *)flag);
  }
#line 763
  return (C);
}
}
#line 766 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
void _glp_spm_mul_num(SPM *C , SPM const   *A , SPM const   *B ) 
{ 
  int i ;
  int j ;
  double *work ;
  void *tmp ;
  SPME *e ;
  SPME *ee ;
  double temp ;
  int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 771
  tmp = _glp_lib_xcalloc(1 + (int )A->n, (int )sizeof(double ));
#line 771
  work = (double *)tmp;
#line 772
  j = 1;
  }
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 772
    if (! (j <= (int )A->n)) {
#line 772
      goto while_break;
    }
#line 773
    *(work + j) = 0.0;
#line 772
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 775
  i = 1;
  {
#line 775
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 775
    if (! (i <= C->m)) {
#line 775
      goto while_break___0;
    }
#line 780
    e = *(A->row + i);
    {
#line 780
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 780
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 780
        goto while_break___1;
      }
#line 781
      *(work + e->j) += e->val;
#line 780
      e = e->r_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 783
    e = *(C->row + i);
    {
#line 783
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 783
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 783
        goto while_break___2;
      }
#line 784
      j = e->j;
#line 786
      temp = 0.0;
#line 787
      ee = *(B->col + j);
      {
#line 787
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 787
        if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 787
          goto while_break___3;
        }
#line 788
        temp += *(work + ee->i) * ee->val;
#line 787
        ee = ee->c_next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 789
      e->val = temp;
#line 783
      e = e->r_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 792
    e = *(A->row + i);
    {
#line 792
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 792
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 792
        goto while_break___4;
      }
#line 793
      *(work + e->j) = 0.0;
#line 792
      e = e->r_next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 775
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 796
  j = 1;
  {
#line 796
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 796
    if (! (j <= (int )A->n)) {
#line 796
      goto while_break___5;
    }
#line 797
    if (*(work + j) == 0.0) {
#line 797
      tmp___0 = 1;
    } else {
      {
#line 797
      _glp_lib_xassert("work[j] == 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       797);
#line 797
      tmp___0 = 1;
      }
    }
#line 796
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 798
  _glp_lib_xfree((void *)work);
  }
#line 799
  return;
}
}
#line 802 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
SPM *_glp_spm_mul_mat(SPM const   *A , SPM const   *B ) 
{ 
  SPM *C ;

  {
  {
#line 805
  C = _glp_spm_mul_sym(A, B);
#line 806
  _glp_spm_mul_num(C, A, B);
  }
#line 807
  return (C);
}
}
#line 810 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
PER *_glp_spm_create_per(int n ) 
{ 
  PER *P ;
  int k ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 814
  if (n >= 0) {
#line 814
    tmp = 1;
  } else {
    {
#line 814
    _glp_lib_xassert("n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c", 814);
#line 814
    tmp = 1;
    }
  }
  {
#line 815
  tmp___0 = _glp_lib_xmalloc((int )sizeof(PER ));
#line 815
  P = (PER *)tmp___0;
#line 816
  P->n = n;
#line 817
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 817
  P->row = (int *)tmp___1;
#line 818
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 818
  P->col = (int *)tmp___2;
#line 820
  k = 1;
  }
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (k <= n)) {
#line 820
      goto while_break;
    }
#line 821
    tmp___3 = k;
#line 821
    *(P->col + k) = tmp___3;
#line 821
    *(P->row + k) = tmp___3;
#line 820
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 822
  return (P);
}
}
#line 825 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
void _glp_spm_check_per(PER *P ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 828
  if (P->n >= 0) {
#line 828
    tmp = 1;
  } else {
    {
#line 828
    _glp_lib_xassert("P->n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                     828);
#line 828
    tmp = 1;
    }
  }
#line 829
  i = 1;
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    if (! (i <= P->n)) {
#line 829
      goto while_break;
    }
#line 830
    j = *(P->row + i);
#line 831
    if (1 <= j) {
#line 831
      if (j <= P->n) {
#line 831
        tmp___0 = 1;
      } else {
        {
#line 831
        _glp_lib_xassert("1 <= j && j <= P->n", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                         831);
#line 831
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 831
      _glp_lib_xassert("1 <= j && j <= P->n", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       831);
#line 831
      tmp___0 = 1;
      }
    }
#line 832
    if (*(P->col + j) == i) {
#line 832
      tmp___1 = 1;
    } else {
      {
#line 832
      _glp_lib_xassert("P->col[j] == i", "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c",
                       832);
#line 832
      tmp___1 = 1;
      }
    }
#line 829
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 834
  return;
}
}
#line 837 "/home/wslee/benchmarks/glpk-4.38/src/glpspm.c"
void _glp_spm_delete_per(PER *P ) 
{ 


  {
  {
#line 839
  _glp_lib_xfree((void *)P->row);
#line 840
  _glp_lib_xfree((void *)P->col);
#line 841
  _glp_lib_xfree((void *)P);
  }
#line 842
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 65 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 82
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 203 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
void _glp_lib_xvprintf(char const   *fmt___0 , va_list arg ) ;
#line 272
char const   *_glp_lib_xerrmsg(void) ;
#line 275
XFILE *_glp_lib_xfopen(char const   *fname , char const   *mode ) ;
#line 278
int _glp_lib_xferror(XFILE *fp ) ;
#line 284
int _glp_lib_xfgetc(XFILE *fp ) ;
#line 293
int _glp_lib_xfclose(XFILE *fp ) ;
#line 898 "./../include/glpk.h"
_glp_data *_glp_sds_open(char const   *fname ) ;
#line 899
void _glp_sds_jump(_glp_data *data , void *jump ) ;
#line 900
void _glp_sds_error(_glp_data *data , char const   *fmt___0  , ...) ;
#line 901
void _glp_sds_warning(_glp_data *data , char const   *fmt___0  , ...) ;
#line 902
int _glp_sds_int(_glp_data *data ) ;
#line 903
double _glp_sds_num(_glp_data *data ) ;
#line 904
char const   *_glp_sds_item(_glp_data *data ) ;
#line 905
char const   *_glp_sds_text(_glp_data *data ) ;
#line 906
int _glp_sds_line(_glp_data *data ) ;
#line 907
void _glp_sds_close(_glp_data *data ) ;
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
static void next_char(_glp_data *data ) ;
#line 49 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
_glp_data *_glp_sds_open(char const   *fname ) 
{ 
  _glp_data *data ;
  XFILE *fp ;
  jmp_buf jump ;
  char const   *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 51
  data = (_glp_data *)((void *)0);
#line 54
  fp = _glp_lib_xfopen(fname, "r");
  }
#line 55
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 56
    tmp = _glp_lib_xerrmsg();
#line 56
    _glp_lib_xprintf("Unable to open `%s\' - %s\n", fname, tmp);
    }
#line 57
    goto done;
  }
  {
#line 59
  tmp___0 = _glp_lib_xmalloc((int )sizeof(_glp_data ));
#line 59
  data = (_glp_data *)tmp___0;
#line 60
  tmp___1 = strlen(fname);
#line 60
  tmp___2 = _glp_lib_xmalloc((int )(tmp___1 + 1U));
#line 60
  data->fname = (char *)tmp___2;
#line 61
  strcpy((char */* __restrict  */)data->fname, (char const   */* __restrict  */)fname);
#line 62
  data->fp = fp;
#line 63
  data->jump = (void *)0;
#line 64
  data->count = 0;
#line 65
  data->c = '\n';
#line 66
  data->item[0] = (char )'\000';
#line 68
  tmp___3 = _setjmp((struct __jmp_buf_tag *)(jump));
  }
#line 68
  if (tmp___3) {
    {
#line 69
    _glp_sds_close(data);
#line 70
    data = (_glp_data *)((void *)0);
    }
#line 71
    goto done;
  }
  {
#line 73
  data->jump = (void *)(jump);
#line 74
  next_char(data);
#line 75
  data->jump = (void *)0;
  }
  done: 
#line 76
  return (data);
}
}
#line 79 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
void _glp_sds_jump(_glp_data *data , void *jump ) 
{ 


  {
#line 81
  data->jump = jump;
#line 82
  return;
}
}
#line 85 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
void _glp_sds_error(_glp_data *data , char const   *fmt___0  , ...) 
{ 
  va_list arg ;
  char *__cil_tmp4 ;

  {
  {
#line 88
  _glp_lib_xprintf("%s:%d: ", data->fname, data->count);
#line 89
  __builtin_va_start(arg, fmt___0);
#line 90
  _glp_lib_xvprintf(fmt___0, arg);
#line 91
  __builtin_va_end(arg);
  }
#line 92
  if ((unsigned long )data->jump == (unsigned long )((void *)0)) {
    {
#line 93
    exit(1);
    }
  } else {
    {
#line 95
    longjmp((struct __jmp_buf_tag *)data->jump, 1);
    }
  }
}
}
#line 99 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
void _glp_sds_warning(_glp_data *data , char const   *fmt___0  , ...) 
{ 
  va_list arg ;
  char *__cil_tmp4 ;

  {
  {
#line 102
  _glp_lib_xprintf("%s:%d: warning: ", data->fname, data->count);
#line 103
  __builtin_va_start(arg, fmt___0);
#line 104
  _glp_lib_xvprintf(fmt___0, arg);
#line 105
  __builtin_va_end(arg);
  }
#line 106
  return;
}
}
#line 109 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
static void next_char(_glp_data *data ) 
{ 
  int c ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 112
  if (data->c == -1) {
    {
#line 113
    _glp_sds_error(data, "unexpected end of file\n");
    }
  } else
#line 114
  if (data->c == 10) {
#line 115
    (data->count) ++;
  }
  {
#line 116
  c = _glp_lib_xfgetc(data->fp);
  }
#line 117
  if (c < 0) {
    {
#line 118
    tmp___0 = _glp_lib_xferror(data->fp);
    }
#line 118
    if (tmp___0) {
      {
#line 119
      tmp = _glp_lib_xerrmsg();
#line 119
      _glp_sds_error(data, "read error - %s\n", tmp);
      }
    } else
#line 120
    if (data->c == 10) {
#line 121
      c = -1;
    } else {
      {
#line 123
      _glp_sds_warning(data, "missing final end of line\n");
#line 124
      c = '\n';
      }
    }
  } else
#line 127
  if (! (c == 10)) {
    {
#line 129
    tmp___2 = __ctype_b_loc();
    }
#line 129
    if ((int const   )*(*tmp___2 + c) & 8192) {
#line 130
      c = ' ';
    } else {
      {
#line 131
      tmp___1 = __ctype_b_loc();
      }
#line 131
      if ((int const   )*(*tmp___1 + c) & 2) {
        {
#line 132
        _glp_sds_error(data, "invalid control character 0x%02X\n", c);
        }
      }
    }
  }
#line 133
  data->c = c;
#line 134
  return;
}
}
#line 137 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
static void skip_pad(_glp_data *data ) 
{ 
  char *__cil_tmp2 ;

  {
  loop: 
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (data->c == 32)) {
#line 139
      if (! (data->c == 10)) {
#line 139
        goto while_break;
      }
    }
    {
#line 140
    next_char(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (data->c == 47) {
    {
#line 142
    next_char(data);
    }
#line 143
    if (data->c != 42) {
      {
#line 144
      _glp_sds_error(data, "invalid use of slash\n");
      }
    }
    {
#line 145
    next_char(data);
    }
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 147
      if (data->c == 42) {
        {
#line 148
        next_char(data);
        }
#line 149
        if (data->c == 47) {
          {
#line 150
          next_char(data);
          }
#line 151
          goto while_break___0;
        }
      }
      {
#line 154
      next_char(data);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    goto loop;
  }
#line 158
  return;
}
}
#line 161 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
static void next_item(_glp_data *data ) 
{ 
  int len ;
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 164
  skip_pad(data);
#line 165
  len = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (data->c == 32) {
#line 166
      goto while_break;
    } else
#line 166
    if (data->c == 10) {
#line 166
      goto while_break;
    }
#line 167
    tmp = len;
#line 167
    len ++;
#line 167
    data->item[tmp] = (char )data->c;
#line 168
    if ((unsigned long )len == sizeof(data->item)) {
      {
#line 169
      _glp_sds_error(data, "data item `%.31s...\' too long\n", data->item);
      }
    }
    {
#line 171
    next_char(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  data->item[len] = (char )'\000';
#line 174
  return;
}
}
#line 177 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
int _glp_sds_int(_glp_data *data ) 
{ 
  int x ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 180
  next_item(data);
#line 181
  tmp = _glp_lib_str2int((char const   *)(data->item), & x);
  }
  {
#line 182
  if (tmp == 0) {
#line 182
    goto case_0;
  }
#line 184
  if (tmp == 1) {
#line 184
    goto case_1;
  }
#line 187
  if (tmp == 2) {
#line 187
    goto case_2;
  }
#line 190
  goto switch_default;
  case_0: /* CIL Label */ 
#line 183
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 185
  _glp_sds_error(data, "integer `%s\' out of range\n", data->item);
  }
  case_2: /* CIL Label */ 
  {
#line 188
  _glp_sds_error(data, "cannot convert `%s\' to integer\n", data->item);
  }
  switch_default: /* CIL Label */ 
#line 191
  if ((unsigned long )data != (unsigned long )data) {
#line 191
    tmp___0 = 1;
  } else {
    {
#line 191
    _glp_lib_xassert("data != data", "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c",
                     191);
#line 191
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 193
  return (x);
}
}
#line 196 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
double _glp_sds_num(_glp_data *data ) 
{ 
  double x ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 199
  next_item(data);
#line 200
  tmp = _glp_lib_str2num((char const   *)(data->item), & x);
  }
  {
#line 201
  if (tmp == 0) {
#line 201
    goto case_0;
  }
#line 203
  if (tmp == 1) {
#line 203
    goto case_1;
  }
#line 206
  if (tmp == 2) {
#line 206
    goto case_2;
  }
#line 209
  goto switch_default;
  case_0: /* CIL Label */ 
#line 202
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 204
  _glp_sds_error(data, "number `%s\' out of range\n", data->item);
  }
  case_2: /* CIL Label */ 
  {
#line 207
  _glp_sds_error(data, "cannot convert `%s\' to number\n", data->item);
  }
  switch_default: /* CIL Label */ 
#line 210
  if ((unsigned long )data != (unsigned long )data) {
#line 210
    tmp___0 = 1;
  } else {
    {
#line 210
    _glp_lib_xassert("data != data", "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c",
                     210);
#line 210
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 212
  return (x);
}
}
#line 215 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
char const   *_glp_sds_item(_glp_data *data ) 
{ 


  {
  {
#line 217
  next_item(data);
  }
#line 218
  return ((char const   *)(data->item));
}
}
#line 221 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
char const   *_glp_sds_text(_glp_data *data ) 
{ 
  int c ;
  int len ;
  int tmp ;
  char *__cil_tmp5 ;

  {
#line 223
  len = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    c = data->c;
#line 226
    next_char(data);
    }
#line 227
    if (c == 32) {
#line 229
      if (len == 0) {
#line 229
        goto __Cont;
      }
#line 231
      if ((int )data->item[len - 1] == 32) {
#line 231
        goto __Cont;
      }
    } else
#line 233
    if (c == 10) {
#line 235
      if (len > 0) {
#line 235
        if ((int )data->item[len - 1] == 32) {
#line 235
          len --;
        }
      }
#line 237
      goto while_break;
    }
#line 240
    tmp = len;
#line 240
    len ++;
#line 240
    data->item[tmp] = (char )c;
#line 241
    if ((unsigned long )len == sizeof(data->item)) {
      {
#line 242
      _glp_sds_error(data, "line too long\n", data->item);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  data->item[len] = (char )'\000';
#line 245
  return ((char const   *)(data->item));
}
}
#line 248 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
int _glp_sds_line(_glp_data *data ) 
{ 


  {
#line 250
  return (data->count);
}
}
#line 253 "/home/wslee/benchmarks/glpk-4.38/src/glpsds.c"
void _glp_sds_close(_glp_data *data ) 
{ 


  {
  {
#line 255
  _glp_lib_xfclose(data->fp);
#line 256
  _glp_lib_xfree((void *)data->fname);
#line 257
  _glp_lib_xfree((void *)data);
  }
#line 258
  return;
}
}
#line 367 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
double _glp_lib_round2n(double x ) ;
#line 407 "./../include/glpk.h"
void glp_set_rii(glp_prob *lp , int i , double rii ) ;
#line 410
void glp_set_sjj(glp_prob *lp , int j , double sjj ) ;
#line 413
double glp_get_rii(glp_prob *lp , int i ) ;
#line 416
double glp_get_sjj(glp_prob *lp , int j ) ;
#line 422
void glp_unscale_prob(glp_prob *lp ) ;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.h"
void _glp_scale_prob(glp_prob *lp , int flags ) ;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double min_row_aij(glp_prob *lp , int i , int scaled ) 
{ 
  GLPAIJ *aij ;
  double min_aij ;
  double temp ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 40
  if (1 <= i) {
#line 40
    if (i <= lp->m) {
#line 40
      tmp = 1;
    } else {
      {
#line 40
      _glp_lib_xassert("1 <= i && i <= lp->m", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                       40);
#line 40
      tmp = 1;
      }
    }
  } else {
    {
#line 40
    _glp_lib_xassert("1 <= i && i <= lp->m", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                     40);
#line 40
    tmp = 1;
    }
  }
#line 41
  min_aij = 1.0;
#line 42
  aij = (*(lp->row + i))->ptr;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 42
      goto while_break;
    }
    {
#line 43
    temp = fabs(aij->val);
    }
#line 44
    if (scaled) {
#line 44
      temp *= (aij->row)->rii * (aij->col)->sjj;
    }
#line 45
    if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 46
      min_aij = temp;
    } else
#line 45
    if (min_aij > temp) {
#line 46
      min_aij = temp;
    }
#line 42
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return (min_aij);
}
}
#line 62 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double max_row_aij(glp_prob *lp , int i , int scaled ) 
{ 
  GLPAIJ *aij ;
  double max_aij ;
  double temp ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 65
  if (1 <= i) {
#line 65
    if (i <= lp->m) {
#line 65
      tmp = 1;
    } else {
      {
#line 65
      _glp_lib_xassert("1 <= i && i <= lp->m", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                       65);
#line 65
      tmp = 1;
      }
    }
  } else {
    {
#line 65
    _glp_lib_xassert("1 <= i && i <= lp->m", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                     65);
#line 65
    tmp = 1;
    }
  }
#line 66
  max_aij = 1.0;
#line 67
  aij = (*(lp->row + i))->ptr;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 67
      goto while_break;
    }
    {
#line 68
    temp = fabs(aij->val);
    }
#line 69
    if (scaled) {
#line 69
      temp *= (aij->row)->rii * (aij->col)->sjj;
    }
#line 70
    if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 71
      max_aij = temp;
    } else
#line 70
    if (max_aij < temp) {
#line 71
      max_aij = temp;
    }
#line 67
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (max_aij);
}
}
#line 87 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double min_col_aij(glp_prob *lp , int j , int scaled ) 
{ 
  GLPAIJ *aij ;
  double min_aij ;
  double temp ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 90
  if (1 <= j) {
#line 90
    if (j <= lp->n) {
#line 90
      tmp = 1;
    } else {
      {
#line 90
      _glp_lib_xassert("1 <= j && j <= lp->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                       90);
#line 90
      tmp = 1;
      }
    }
  } else {
    {
#line 90
    _glp_lib_xassert("1 <= j && j <= lp->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                     90);
#line 90
    tmp = 1;
    }
  }
#line 91
  min_aij = 1.0;
#line 92
  aij = (*(lp->col + j))->ptr;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 92
      goto while_break;
    }
    {
#line 93
    temp = fabs(aij->val);
    }
#line 94
    if (scaled) {
#line 94
      temp *= (aij->row)->rii * (aij->col)->sjj;
    }
#line 95
    if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 96
      min_aij = temp;
    } else
#line 95
    if (min_aij > temp) {
#line 96
      min_aij = temp;
    }
#line 92
    aij = aij->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (min_aij);
}
}
#line 112 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double max_col_aij(glp_prob *lp , int j , int scaled ) 
{ 
  GLPAIJ *aij ;
  double max_aij ;
  double temp ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 115
  if (1 <= j) {
#line 115
    if (j <= lp->n) {
#line 115
      tmp = 1;
    } else {
      {
#line 115
      _glp_lib_xassert("1 <= j && j <= lp->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                       115);
#line 115
      tmp = 1;
      }
    }
  } else {
    {
#line 115
    _glp_lib_xassert("1 <= j && j <= lp->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                     115);
#line 115
    tmp = 1;
    }
  }
#line 116
  max_aij = 1.0;
#line 117
  aij = (*(lp->col + j))->ptr;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 117
      goto while_break;
    }
    {
#line 118
    temp = fabs(aij->val);
    }
#line 119
    if (scaled) {
#line 119
      temp *= (aij->row)->rii * (aij->col)->sjj;
    }
#line 120
    if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 121
      max_aij = temp;
    } else
#line 120
    if (max_aij < temp) {
#line 121
      max_aij = temp;
    }
#line 117
    aij = aij->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (max_aij);
}
}
#line 137 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double min_mat_aij(glp_prob *lp , int scaled ) 
{ 
  int i ;
  double min_aij ;
  double temp ;

  {
#line 140
  min_aij = 1.0;
#line 141
  i = 1;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i <= lp->m)) {
#line 141
      goto while_break;
    }
    {
#line 142
    temp = min_row_aij(lp, i, scaled);
    }
#line 143
    if (i == 1) {
#line 144
      min_aij = temp;
    } else
#line 143
    if (min_aij > temp) {
#line 144
      min_aij = temp;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (min_aij);
}
}
#line 160 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double max_mat_aij(glp_prob *lp , int scaled ) 
{ 
  int i ;
  double max_aij ;
  double temp ;

  {
#line 163
  max_aij = 1.0;
#line 164
  i = 1;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i <= lp->m)) {
#line 164
      goto while_break;
    }
    {
#line 165
    temp = max_row_aij(lp, i, scaled);
    }
#line 166
    if (i == 1) {
#line 167
      max_aij = temp;
    } else
#line 166
    if (max_aij < temp) {
#line 167
      max_aij = temp;
    }
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return (max_aij);
}
}
#line 199 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static void eq_scaling(glp_prob *lp , int flag ) 
{ 
  int i ;
  int j ;
  int pass ;
  double temp ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 202
  if (flag == 0) {
#line 202
    tmp = 1;
  } else
#line 202
  if (flag == 1) {
#line 202
    tmp = 1;
  } else {
    {
#line 202
    _glp_lib_xassert("flag == 0 || flag == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                     202);
#line 202
    tmp = 1;
    }
  }
#line 203
  pass = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (pass <= 1)) {
#line 203
      goto while_break;
    }
#line 204
    if (pass == flag) {
#line 206
      i = 1;
      {
#line 206
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 206
        if (! (i <= lp->m)) {
#line 206
          goto while_break___0;
        }
        {
#line 207
        temp = max_row_aij(lp, i, 1);
#line 208
        tmp___0 = glp_get_rii(lp, i);
#line 208
        glp_set_rii(lp, i, tmp___0 / temp);
#line 206
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 213
      j = 1;
      {
#line 213
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 213
        if (! (j <= lp->n)) {
#line 213
          goto while_break___1;
        }
        {
#line 214
        temp = max_col_aij(lp, j, 1);
#line 215
        tmp___1 = glp_get_sjj(lp, j);
#line 215
        glp_set_sjj(lp, j, tmp___1 / temp);
#line 213
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 203
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return;
}
}
#line 255 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static void gm_scaling(glp_prob *lp , int flag ) 
{ 
  int i ;
  int j ;
  int pass ;
  double temp ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 258
  if (flag == 0) {
#line 258
    tmp = 1;
  } else
#line 258
  if (flag == 1) {
#line 258
    tmp = 1;
  } else {
    {
#line 258
    _glp_lib_xassert("flag == 0 || flag == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c",
                     258);
#line 258
    tmp = 1;
    }
  }
#line 259
  pass = 0;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (pass <= 1)) {
#line 259
      goto while_break;
    }
#line 260
    if (pass == flag) {
#line 262
      i = 1;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (i <= lp->m)) {
#line 262
          goto while_break___0;
        }
        {
#line 263
        tmp___0 = min_row_aij(lp, i, 1);
#line 263
        tmp___1 = max_row_aij(lp, i, 1);
#line 263
        temp = tmp___0 * tmp___1;
#line 264
        tmp___2 = glp_get_rii(lp, i);
#line 264
        tmp___3 = sqrt(temp);
#line 264
        glp_set_rii(lp, i, tmp___2 / tmp___3);
#line 262
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 269
      j = 1;
      {
#line 269
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 269
        if (! (j <= lp->n)) {
#line 269
          goto while_break___1;
        }
        {
#line 270
        tmp___4 = min_col_aij(lp, j, 1);
#line 270
        tmp___5 = max_col_aij(lp, j, 1);
#line 270
        temp = tmp___4 * tmp___5;
#line 271
        tmp___6 = glp_get_sjj(lp, j);
#line 271
        tmp___7 = sqrt(temp);
#line 271
        glp_set_sjj(lp, j, tmp___6 / tmp___7);
#line 269
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 259
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 294 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double max_row_ratio(glp_prob *lp ) 
{ 
  int i ;
  double ratio ;
  double temp ;
  double tmp ;
  double tmp___0 ;

  {
#line 297
  ratio = 1.0;
#line 298
  i = 1;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i <= lp->m)) {
#line 298
      goto while_break;
    }
    {
#line 299
    tmp = max_row_aij(lp, i, 1);
#line 299
    tmp___0 = min_row_aij(lp, i, 1);
#line 299
    temp = tmp / tmp___0;
    }
#line 300
    if (i == 1) {
#line 300
      ratio = temp;
    } else
#line 300
    if (ratio < temp) {
#line 300
      ratio = temp;
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return (ratio);
}
}
#line 321 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static double max_col_ratio(glp_prob *lp ) 
{ 
  int j ;
  double ratio ;
  double temp ;
  double tmp ;
  double tmp___0 ;

  {
#line 324
  ratio = 1.0;
#line 325
  j = 1;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (j <= lp->n)) {
#line 325
      goto while_break;
    }
    {
#line 326
    tmp = max_col_aij(lp, j, 1);
#line 326
    tmp___0 = min_col_aij(lp, j, 1);
#line 326
    temp = tmp / tmp___0;
    }
#line 327
    if (j == 1) {
#line 327
      ratio = temp;
    } else
#line 327
    if (ratio < temp) {
#line 327
      ratio = temp;
    }
#line 325
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return (ratio);
}
}
#line 351 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static void gm_iterate(glp_prob *lp , int it_max , double tau ) 
{ 
  int k ;
  int flag ;
  double ratio ;
  double r_old ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 353
  ratio = 0.0;
#line 357
  tmp = max_row_ratio(lp);
#line 357
  tmp___0 = max_col_ratio(lp);
#line 357
  flag = tmp > tmp___0;
#line 358
  k = 1;
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (k <= it_max)) {
#line 358
      goto while_break;
    }
    {
#line 360
    r_old = ratio;
#line 362
    tmp___1 = max_mat_aij(lp, 1);
#line 362
    tmp___2 = min_mat_aij(lp, 1);
#line 362
    ratio = tmp___1 / tmp___2;
    }
#line 367
    if (k > 1) {
#line 367
      if (ratio > tau * r_old) {
#line 367
        goto while_break;
      }
    }
    {
#line 369
    gm_scaling(lp, flag);
#line 358
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 390 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
static char const   *fmt  =    "%s: min|aij| = %10.3e  max|aij| = %10.3e  ratio = %10.3e\n";
#line 389 "/home/wslee/benchmarks/glpk-4.38/src/glpscl.c"
void _glp_scale_prob(glp_prob *lp , int flags ) 
{ 
  double min_aij ;
  double max_aij ;
  double ratio ;
  double tmp ;
  double tmp___0 ;
  int i ;
  int j ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 393
  _glp_lib_xprintf("Scaling...\n");
#line 395
  glp_unscale_prob(lp);
#line 397
  min_aij = min_mat_aij(lp, 1);
#line 398
  max_aij = max_mat_aij(lp, 1);
#line 399
  ratio = max_aij / min_aij;
#line 400
  _glp_lib_xprintf(fmt, " A", min_aij, max_aij, ratio);
  }
#line 402
  if (min_aij >= 0.10) {
#line 402
    if (max_aij <= 10.0) {
      {
#line 403
      _glp_lib_xprintf("Problem data seem to be well scaled\n");
      }
#line 405
      if (flags & 64) {
#line 405
        goto done;
      }
    }
  }
#line 408
  if (flags & 1) {
    {
#line 409
    gm_iterate(lp, 15, 0.90);
#line 410
    min_aij = min_mat_aij(lp, 1);
#line 411
    max_aij = max_mat_aij(lp, 1);
#line 412
    ratio = max_aij / min_aij;
#line 413
    _glp_lib_xprintf(fmt, "GM", min_aij, max_aij, ratio);
    }
  }
#line 416
  if (flags & 16) {
    {
#line 417
    tmp = max_row_ratio(lp);
#line 417
    tmp___0 = max_col_ratio(lp);
#line 417
    eq_scaling(lp, tmp > tmp___0);
#line 418
    min_aij = min_mat_aij(lp, 1);
#line 419
    max_aij = max_mat_aij(lp, 1);
#line 420
    ratio = max_aij / min_aij;
#line 421
    _glp_lib_xprintf(fmt, "EQ", min_aij, max_aij, ratio);
    }
  }
#line 424
  if (flags & 32) {
#line 426
    i = 1;
    {
#line 426
    while (1) {
      while_continue: /* CIL Label */ ;
#line 426
      if (! (i <= lp->m)) {
#line 426
        goto while_break;
      }
      {
#line 427
      tmp___1 = glp_get_rii(lp, i);
#line 427
      tmp___2 = _glp_lib_round2n(tmp___1);
#line 427
      glp_set_rii(lp, i, tmp___2);
#line 426
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 428
    j = 1;
    {
#line 428
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 428
      if (! (j <= lp->n)) {
#line 428
        goto while_break___0;
      }
      {
#line 429
      tmp___3 = glp_get_sjj(lp, j);
#line 429
      tmp___4 = _glp_lib_round2n(tmp___3);
#line 429
      glp_set_sjj(lp, j, tmp___4);
#line 428
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 430
    min_aij = min_mat_aij(lp, 1);
#line 431
    max_aij = max_mat_aij(lp, 1);
#line 432
    ratio = max_aij / min_aij;
#line 433
    _glp_lib_xprintf(fmt, "2N", min_aij, max_aij, ratio);
    }
  }
  done: 
#line 435
  return;
}
}
#line 90 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.h"
SCG *_glp_scg_create_graph(int n ) ;
#line 94
int _glp_scg_add_nodes(SCG *g , int num ) ;
#line 98
SCGRIB *_glp_scg_add_edge(SCG *g , int i , int j ) ;
#line 102
int _glp_scg_adj_list(SCG *g , int i , int *adj ) ;
#line 106
int _glp_scg_max_clique(SCG *g , int const   *w , int *list ) ;
#line 110
void _glp_scg_delete_graph(SCG *g ) ;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
SCG *_glp_scg_create_graph(int n ) 
{ 
  SCG *g ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 33
  if (n >= 0) {
#line 33
    tmp = 1;
  } else {
    {
#line 33
    _glp_lib_xassert("n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c", 33);
#line 33
    tmp = 1;
    }
  }
  {
#line 34
  tmp___0 = _glp_lib_xmalloc((int )sizeof(SCG ));
#line 34
  g = (SCG *)tmp___0;
#line 35
  g->pool = _glp_dmp_create_pool();
#line 36
  g->n_max = 50;
#line 37
  g->nc_max = 10;
#line 38
  tmp___1 = 0;
#line 38
  g->nc = tmp___1;
#line 38
  g->n = tmp___1;
#line 39
  tmp___2 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(SCGRIB *));
#line 39
  g->i_ptr = (SCGRIB **)tmp___2;
#line 40
  tmp___3 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(SCGRIB *));
#line 40
  g->j_ptr = (SCGRIB **)tmp___3;
#line 41
  tmp___4 = _glp_lib_xcalloc(1 + g->nc_max, (int )sizeof(SCGCQE *));
#line 41
  g->c_ptr = (SCGCQE **)tmp___4;
#line 42
  tmp___5 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(SCGCQE *));
#line 42
  g->v_ptr = (SCGCQE **)tmp___5;
#line 43
  tmp___6 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(char ));
#line 43
  g->flag = (char *)tmp___6;
  }
#line 44
  if (n > 0) {
    {
#line 44
    _glp_scg_add_nodes(g, n);
    }
  }
#line 45
  return (g);
}
}
#line 50 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
int _glp_scg_add_nodes(SCG *g , int num ) 
{ 
  int n_new ;
  int i ;
  int tmp ;
  int tmp___0 ;
  void **save ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 53
  if (num > 0) {
#line 53
    tmp = 1;
  } else {
    {
#line 53
    _glp_lib_xassert("num > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c", 53);
#line 53
    tmp = 1;
    }
  }
#line 55
  n_new = g->n + num;
#line 56
  if (n_new > 0) {
#line 56
    tmp___0 = 1;
  } else {
    {
#line 56
    _glp_lib_xassert("n_new > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                     56);
#line 56
    tmp___0 = 1;
    }
  }
#line 58
  if (g->n_max < n_new) {
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if (! (g->n_max < n_new)) {
#line 60
        goto while_break;
      }
#line 61
      g->n_max += g->n_max;
#line 62
      if (g->n_max > 0) {
#line 62
        tmp___1 = 1;
      } else {
        {
#line 62
        _glp_lib_xassert("g->n_max > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                         62);
#line 62
        tmp___1 = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 64
    save = (void **)g->i_ptr;
#line 65
    tmp___2 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(SCGRIB *));
#line 65
    g->i_ptr = (SCGRIB **)tmp___2;
#line 66
    memcpy((void */* __restrict  */)(g->i_ptr + 1), (void const   */* __restrict  */)(save + 1),
           (size_t )((unsigned long )g->n * sizeof(SCGRIB *)));
#line 67
    _glp_lib_xfree((void *)save);
#line 68
    save = (void **)g->j_ptr;
#line 69
    tmp___3 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(SCGRIB *));
#line 69
    g->j_ptr = (SCGRIB **)tmp___3;
#line 70
    memcpy((void */* __restrict  */)(g->j_ptr + 1), (void const   */* __restrict  */)(save + 1),
           (size_t )((unsigned long )g->n * sizeof(SCGRIB *)));
#line 71
    _glp_lib_xfree((void *)save);
#line 72
    save = (void **)g->v_ptr;
#line 73
    tmp___4 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(SCGCQE *));
#line 73
    g->v_ptr = (SCGCQE **)tmp___4;
#line 74
    memcpy((void */* __restrict  */)(g->v_ptr + 1), (void const   */* __restrict  */)(save + 1),
           (size_t )((unsigned long )g->n * sizeof(SCGCQE *)));
#line 75
    _glp_lib_xfree((void *)save);
#line 76
    _glp_lib_xfree((void *)g->flag);
#line 77
    tmp___5 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(char ));
#line 77
    g->flag = (char *)tmp___5;
#line 78
    memset((void *)(g->flag + 1), 0, (size_t )g->n);
    }
  }
#line 81
  i = g->n + 1;
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (i <= n_new)) {
#line 81
      goto while_break___0;
    }
#line 82
    *(g->i_ptr + i) = (SCGRIB *)((void *)0);
#line 83
    *(g->j_ptr + i) = (SCGRIB *)((void *)0);
#line 84
    *(g->v_ptr + i) = (SCGCQE *)((void *)0);
#line 85
    *(g->flag + i) = (char)0;
#line 81
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 88
  g->n = n_new;
#line 90
  return ((n_new - num) + 1);
}
}
#line 95 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
SCGRIB *_glp_scg_add_edge(SCG *g , int i , int j ) 
{ 
  SCGRIB *e ;
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  SCGRIB *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 99
  if (1 <= i) {
#line 99
    if (i <= g->n) {
#line 99
      tmp = 1;
    } else {
      {
#line 99
      _glp_lib_xassert("1 <= i && i <= g->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                       99);
#line 99
      tmp = 1;
      }
    }
  } else {
    {
#line 99
    _glp_lib_xassert("1 <= i && i <= g->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                     99);
#line 99
    tmp = 1;
    }
  }
#line 100
  if (1 <= j) {
#line 100
    if (j <= g->n) {
#line 100
      tmp___0 = 1;
    } else {
      {
#line 100
      _glp_lib_xassert("1 <= j && j <= g->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                       100);
#line 100
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 100
    _glp_lib_xassert("1 <= j && j <= g->n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                     100);
#line 100
    tmp___0 = 1;
    }
  }
#line 101
  if (i > j) {
#line 101
    t = i;
#line 101
    i = j;
#line 101
    j = t;
  }
#line 102
  if (i < j) {
#line 102
    tmp___1 = 1;
  } else {
    {
#line 102
    _glp_lib_xassert("i < j", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c", 102);
#line 102
    tmp___1 = 1;
    }
  }
  {
#line 103
  tmp___2 = _glp_dmp_get_atom(g->pool, (int )sizeof(SCGRIB ));
#line 103
  e = (SCGRIB *)tmp___2;
#line 104
  e->i = i;
#line 105
  e->j = j;
#line 106
  e->i_prev = (SCGRIB *)((void *)0);
#line 107
  e->i_next = *(g->i_ptr + i);
#line 108
  e->j_prev = (SCGRIB *)((void *)0);
#line 109
  e->j_next = *(g->j_ptr + j);
  }
#line 110
  if ((unsigned long )e->i_next != (unsigned long )((void *)0)) {
#line 110
    (e->i_next)->i_prev = e;
  }
#line 111
  if ((unsigned long )e->j_next != (unsigned long )((void *)0)) {
#line 111
    (e->j_next)->j_prev = e;
  }
#line 112
  tmp___3 = e;
#line 112
  *(g->j_ptr + j) = tmp___3;
#line 112
  *(g->i_ptr + i) = tmp___3;
#line 113
  return (e);
}
}
#line 139 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
int _glp_scg_adj_list(SCG *g , int i , int *adj ) 
{ 
  int n ;
  char *flag ;
  SCGRIB *e ;
  SCGCQE *p ;
  SCGCQE *q ;
  int j ;
  int c ;
  int nadj ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 140
  n = g->n;
#line 141
  flag = g->flag;
#line 144
  nadj = 0;
#line 145
  if (1 <= i) {
#line 145
    if (i <= n) {
#line 145
      tmp = 1;
    } else {
      {
#line 145
      _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                       145);
#line 145
      tmp = 1;
      }
    }
  } else {
    {
#line 145
    _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                     145);
#line 145
    tmp = 1;
    }
  }
#line 151
  e = *(g->i_ptr + i);
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 151
      goto while_break;
    }
#line 152
    j = e->j;
#line 156
    if (! *(flag + j)) {
#line 156
      nadj ++;
#line 156
      *(adj + nadj) = j;
#line 156
      *(flag + j) = (char)1;
    }
#line 151
    e = e->i_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  e = *(g->j_ptr + i);
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 160
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 160
      goto while_break___0;
    }
#line 161
    j = e->i;
#line 165
    if (! *(flag + j)) {
#line 165
      nadj ++;
#line 165
      *(adj + nadj) = j;
#line 165
      *(flag + j) = (char)1;
    }
#line 160
    e = e->j_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 169
  if ((unsigned long )*(g->v_ptr + i) == (unsigned long )((void *)0)) {
#line 169
    tmp___0 = 1;
  } else {
    {
#line 169
    _glp_lib_xassert("g->v_ptr[i] == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                     169);
#line 169
    tmp___0 = 1;
    }
  }
#line 172
  p = *(g->v_ptr + i);
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 172
      goto while_break___1;
    }
#line 173
    c = p->c;
#line 180
    q = *(g->c_ptr + c);
    {
#line 180
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 180
      if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 180
        goto while_break___2;
      }
#line 181
      j = q->i;
#line 186
      if (j != i) {
#line 186
        if (! *(flag + j)) {
#line 186
          nadj ++;
#line 186
          *(adj + nadj) = j;
#line 186
          *(flag + j) = (char)1;
        }
      }
#line 180
      q = q->c_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 172
    p = p->v_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 190
  j = 1;
  {
#line 190
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 190
    if (! (j <= nadj)) {
#line 190
      goto while_break___3;
    }
#line 190
    *(flag + *(adj + j)) = (char)0;
#line 190
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 194
  return (nadj);
}
}
#line 240 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
static int is_edge(struct dsa___0 *dsa , int i , int j ) 
{ 
  SCG *g ;
  int n ;
  int *adj ;
  char *flag ;
  int k ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 242
  g = dsa->g;
#line 243
  n = g->n;
#line 244
  adj = dsa->adj;
#line 245
  flag = dsa->flag;
#line 247
  i ++;
#line 247
  j ++;
#line 248
  if (1 <= i) {
#line 248
    if (i <= n) {
#line 248
      tmp = 1;
    } else {
      {
#line 248
      _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                       248);
#line 248
      tmp = 1;
      }
    }
  } else {
    {
#line 248
    _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                     248);
#line 248
    tmp = 1;
    }
  }
#line 249
  if (1 <= j) {
#line 249
    if (j <= n) {
#line 249
      tmp___0 = 1;
    } else {
      {
#line 249
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                       249);
#line 249
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 249
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c",
                     249);
#line 249
    tmp___0 = 1;
    }
  }
#line 251
  if (dsa->i != i) {
#line 252
    k = dsa->nadj;
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 252
      if (! (k >= 1)) {
#line 252
        goto while_break;
      }
#line 252
      *(flag + *(adj + k)) = (char)0;
#line 252
      k --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 253
    dsa->i = i;
#line 254
    dsa->nadj = _glp_scg_adj_list(g, i, adj);
#line 255
    k = dsa->nadj;
    }
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      if (! (k >= 1)) {
#line 255
        goto while_break___0;
      }
#line 255
      *(flag + *(adj + k)) = (char)1;
#line 255
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 257
  return ((int )*(flag + j));
}
}
#line 260 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
static void sub(struct dsa___0 *dsa , int ct , int *table , int level , int weight ,
                int l_weight ) 
{ 
  int n ;
  int const   *wt ;
  int *rec ;
  int *clique ;
  int *set___0 ;
  int i ;
  int j ;
  int k ;
  int curr_weight ;
  int left_weight ;
  int *p1 ;
  int *p2 ;
  int *newtable ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 262
  n = (dsa->g)->n;
#line 263
  wt = dsa->wt;
#line 264
  rec = dsa->rec;
#line 265
  clique = dsa->clique;
#line 266
  set___0 = dsa->set;
#line 268
  tmp = _glp_lib_xcalloc(n, (int )sizeof(int ));
#line 268
  newtable = (int *)tmp;
  }
#line 269
  if (ct <= 0) {
#line 271
    if (ct == 0) {
#line 272
      tmp___0 = level;
#line 272
      level ++;
#line 272
      *(set___0 + tmp___0) = *(table + 0);
#line 273
      weight += l_weight;
    }
#line 275
    if (weight > dsa->record) {
#line 276
      dsa->record = weight;
#line 277
      dsa->rec_level = level;
#line 278
      i = 0;
      {
#line 278
      while (1) {
        while_continue: /* CIL Label */ ;
#line 278
        if (! (i < level)) {
#line 278
          goto while_break;
        }
#line 278
        *(rec + i) = *(set___0 + i);
#line 278
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 280
    goto done;
  }
#line 282
  i = ct;
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i >= 0)) {
#line 282
      goto while_break___0;
    }
#line 283
    if (level == 0) {
#line 283
      if (i < ct) {
#line 283
        goto done;
      }
    }
#line 284
    k = *(table + i);
#line 285
    if (level > 0) {
#line 285
      if (*(clique + k) <= dsa->record - weight) {
#line 286
        goto done;
      }
    }
#line 287
    *(set___0 + level) = k;
#line 288
    curr_weight = weight + (int )*(wt + k);
#line 289
    l_weight -= (int )*(wt + k);
#line 290
    if (l_weight <= dsa->record - curr_weight) {
#line 291
      goto done;
    }
#line 292
    p1 = newtable;
#line 293
    p2 = table;
#line 294
    left_weight = 0;
    {
#line 295
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 295
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 295
        goto while_break___1;
      }
      {
#line 296
      tmp___1 = p2;
#line 296
      p2 ++;
#line 296
      j = *tmp___1;
#line 301
      tmp___3 = is_edge(dsa, k, j);
      }
#line 301
      if (tmp___3) {
#line 303
        tmp___2 = p1;
#line 303
        p1 ++;
#line 303
        *tmp___2 = j;
#line 304
        left_weight += (int )*(wt + j);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 307
    if (left_weight <= dsa->record - curr_weight) {
#line 307
      goto __Cont;
    }
    {
#line 308
    sub(dsa, (int )((p1 - newtable) - 1L), newtable, level + 1, curr_weight, left_weight);
    }
    __Cont: /* CIL Label */ 
#line 282
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
  {
#line 311
  _glp_lib_xfree((void *)newtable);
  }
#line 312
  return;
}
}
#line 315 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
static int wclique(SCG *g , int const   *w , int *sol ) 
{ 
  int n ;
  int const   *wt ;
  struct dsa___0 _dsa ;
  struct dsa___0 *dsa ;
  int i ;
  int j ;
  int p ;
  int max_wt ;
  int max_nwt ;
  int wth ;
  int *used ;
  int *nwt ;
  int *pos ;
  xlong_t timer ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  xlong_t tmp___9 ;
  double tmp___10 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 316
  n = g->n;
#line 317
  wt = w + 1;
#line 318
  dsa = & _dsa;
#line 321
  if (n > 0) {
#line 321
    tmp = 1;
  } else {
    {
#line 321
    _glp_lib_xassert("n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c", 321);
#line 321
    tmp = 1;
    }
  }
  {
#line 322
  dsa->g = g;
#line 323
  dsa->i = 0;
#line 324
  dsa->nadj = 0;
#line 325
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 325
  dsa->adj = (int *)tmp___0;
#line 326
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(char ));
#line 326
  dsa->flag = (char *)tmp___1;
#line 327
  memset((void *)(dsa->flag + 1), 0, (size_t )n);
#line 328
  dsa->wt = wt;
#line 329
  dsa->record = 0;
#line 330
  dsa->rec_level = 0;
#line 331
  dsa->rec = sol + 1;
#line 332
  tmp___2 = _glp_lib_xcalloc(n, (int )sizeof(int ));
#line 332
  dsa->clique = (int *)tmp___2;
#line 333
  tmp___3 = _glp_lib_xcalloc(n, (int )sizeof(int ));
#line 333
  dsa->set = (int *)tmp___3;
#line 334
  tmp___4 = _glp_lib_xcalloc(n, (int )sizeof(int ));
#line 334
  used = (int *)tmp___4;
#line 335
  tmp___5 = _glp_lib_xcalloc(n, (int )sizeof(int ));
#line 335
  nwt = (int *)tmp___5;
#line 336
  tmp___6 = _glp_lib_xcalloc(n, (int )sizeof(int ));
#line 336
  pos = (int *)tmp___6;
#line 338
  timer = _glp_lib_xtime();
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (i < n)) {
#line 340
      goto while_break;
    }
#line 341
    *(nwt + i) = 0;
#line 342
    j = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (j < n)) {
#line 342
        goto while_break___0;
      }
      {
#line 343
      tmp___7 = is_edge(dsa, i, j);
      }
#line 343
      if (tmp___7) {
#line 343
        *(nwt + i) += (int )*(wt + j);
      }
#line 342
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 340
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 345
    if (! (i < n)) {
#line 345
      goto while_break___1;
    }
#line 346
    *(used + i) = 0;
#line 345
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 347
  i = n - 1;
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (! (i >= 0)) {
#line 347
      goto while_break___2;
    }
#line 348
    max_wt = -1;
#line 349
    max_nwt = -1;
#line 350
    j = 0;
    {
#line 350
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 350
      if (! (j < n)) {
#line 350
        goto while_break___3;
      }
#line 351
      if (! *(used + j)) {
#line 351
        if (*(wt + j) > (int const   )max_wt) {
#line 353
          max_wt = (int )*(wt + j);
#line 354
          max_nwt = *(nwt + j);
#line 355
          p = j;
        } else
#line 351
        if (*(wt + j) == (int const   )max_wt) {
#line 351
          if (*(nwt + j) > max_nwt) {
#line 353
            max_wt = (int )*(wt + j);
#line 354
            max_nwt = *(nwt + j);
#line 355
            p = j;
          }
        }
      }
#line 350
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 358
    *(pos + i) = p;
#line 359
    *(used + p) = 1;
#line 360
    j = 0;
    {
#line 360
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 360
      if (! (j < n)) {
#line 360
        goto while_break___4;
      }
#line 361
      if (! *(used + j)) {
#line 361
        if (j != p) {
          {
#line 361
          tmp___8 = is_edge(dsa, p, j);
          }
#line 361
          if (tmp___8) {
#line 362
            *(nwt + j) -= (int )*(wt + p);
          }
        }
      }
#line 360
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 347
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 365
  wth = 0;
#line 366
  i = 0;
  {
#line 366
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 366
    if (! (i < n)) {
#line 366
      goto while_break___5;
    }
    {
#line 367
    wth += (int )*(wt + *(pos + i));
#line 368
    sub(dsa, i, pos, 0, 0, wth);
#line 369
    *(dsa->clique + *(pos + i)) = dsa->record;
#line 373
    tmp___9 = _glp_lib_xtime();
#line 373
    tmp___10 = _glp_lib_xdifftime(tmp___9, timer);
    }
#line 373
    if (tmp___10 >= 5.0 - 0.001) {
      {
#line 376
      _glp_lib_xprintf("level = %d (%d); best = %d\n", i + 1, n, dsa->record);
#line 378
      timer = _glp_lib_xtime();
      }
    }
#line 366
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 381
  _glp_lib_xfree((void *)dsa->adj);
#line 382
  _glp_lib_xfree((void *)dsa->flag);
#line 383
  _glp_lib_xfree((void *)dsa->clique);
#line 384
  _glp_lib_xfree((void *)dsa->set);
#line 385
  _glp_lib_xfree((void *)used);
#line 386
  _glp_lib_xfree((void *)nwt);
#line 387
  _glp_lib_xfree((void *)pos);
#line 389
  i = 1;
  }
  {
#line 389
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 389
    if (! (i <= dsa->rec_level)) {
#line 389
      goto while_break___6;
    }
#line 389
    (*(sol + i)) ++;
#line 389
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 390
  return (dsa->rec_level);
}
}
#line 419 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
int _glp_scg_max_clique(SCG *g , int const   *w , int *list ) 
{ 
  int size ;

  {
#line 421
  if (g->n == 0) {
#line 422
    size = 0;
  } else {
    {
#line 424
    size = wclique(g, w, list);
    }
  }
#line 425
  return (size);
}
}
#line 430 "/home/wslee/benchmarks/glpk-4.38/src/glpscg.c"
void _glp_scg_delete_graph(SCG *g ) 
{ 


  {
  {
#line 432
  _glp_dmp_delete_pool(g->pool);
#line 433
  _glp_lib_xfree((void *)g->i_ptr);
#line 434
  _glp_lib_xfree((void *)g->j_ptr);
#line 435
  _glp_lib_xfree((void *)g->c_ptr);
#line 436
  _glp_lib_xfree((void *)g->v_ptr);
#line 437
  _glp_lib_xfree((void *)g->flag);
#line 438
  _glp_lib_xfree((void *)g);
  }
#line 439
  return;
}
}
#line 103 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.h"
SCF *_glp_scf_create_it(int n_max ) ;
#line 107
int _glp_scf_update_exp(SCF *scf , double const   *x , double const   *y , double z ) ;
#line 112
void _glp_scf_solve_it(SCF *scf , int tr , double *x ) ;
#line 116
void _glp_scf_reset_it(SCF *scf ) ;
#line 120
void _glp_scf_delete_it(SCF *scf ) ;
#line 55 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
SCF *_glp_scf_create_it(int n_max ) 
{ 
  SCF *scf ;
  xerror_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 60
  if (1 <= n_max) {
#line 60
    if (! (n_max <= 32767)) {
      {
#line 61
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpscf.c", 61);
#line 61
      (*tmp)("scf_create_it: n_max = %d; invalid parameter\n", n_max);
      }
    }
  } else {
    {
#line 61
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpscf.c", 61);
#line 61
    (*tmp)("scf_create_it: n_max = %d; invalid parameter\n", n_max);
    }
  }
  {
#line 63
  tmp___0 = _glp_lib_xmalloc((int )sizeof(SCF ));
#line 63
  scf = (SCF *)tmp___0;
#line 64
  scf->n_max = n_max;
#line 65
  scf->n = 0;
#line 66
  tmp___1 = _glp_lib_xcalloc(1 + n_max * n_max, (int )sizeof(double ));
#line 66
  scf->f = (double *)tmp___1;
#line 67
  tmp___2 = _glp_lib_xcalloc(1 + (n_max * (n_max + 1)) / 2, (int )sizeof(double ));
#line 67
  scf->u = (double *)tmp___2;
#line 68
  tmp___3 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 68
  scf->p = (int *)tmp___3;
#line 69
  scf->t_opt = 1;
#line 70
  scf->rank = 0;
#line 74
  scf->c = (double *)((void *)0);
#line 76
  tmp___4 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(double ));
#line 76
  scf->w = (double *)tmp___4;
  }
#line 77
  return (scf);
}
}
#line 84 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static int f_loc(SCF *scf , int i , int j ) 
{ 
  int n_max ;
  int n ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 85
  n_max = scf->n_max;
#line 86
  n = scf->n;
#line 87
  if (1 <= i) {
#line 87
    if (i <= n) {
#line 87
      tmp = 1;
    } else {
      {
#line 87
      _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                       87);
#line 87
      tmp = 1;
      }
    }
  } else {
    {
#line 87
    _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                     87);
#line 87
    tmp = 1;
    }
  }
#line 88
  if (1 <= j) {
#line 88
    if (j <= n) {
#line 88
      tmp___0 = 1;
    } else {
      {
#line 88
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                       88);
#line 88
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 88
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                     88);
#line 88
    tmp___0 = 1;
    }
  }
#line 89
  return ((i - 1) * n_max + j);
}
}
#line 96 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static int u_loc(SCF *scf , int i , int j ) 
{ 
  int n_max ;
  int n ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 97
  n_max = scf->n_max;
#line 98
  n = scf->n;
#line 99
  if (1 <= i) {
#line 99
    if (i <= n) {
#line 99
      tmp = 1;
    } else {
      {
#line 99
      _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                       99);
#line 99
      tmp = 1;
      }
    }
  } else {
    {
#line 99
    _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                     99);
#line 99
    tmp = 1;
    }
  }
#line 100
  if (i <= j) {
#line 100
    if (j <= n) {
#line 100
      tmp___0 = 1;
    } else {
      {
#line 100
      _glp_lib_xassert("i <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                       100);
#line 100
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 100
    _glp_lib_xassert("i <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                     100);
#line 100
    tmp___0 = 1;
    }
  }
#line 101
  return (((i - 1) * n_max + j) - (i * (i - 1)) / 2);
}
}
#line 132 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static void bg_transform(SCF *scf , int k , double *un ) 
{ 
  int n ;
  double *f ;
  double *u ;
  int j ;
  int k1 ;
  int kj ;
  int kk ;
  int n1 ;
  int nj ;
  double t ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 133
  n = scf->n;
#line 134
  f = scf->f;
#line 135
  u = scf->u;
#line 138
  if (1 <= k) {
#line 138
    if (k <= n) {
#line 138
      tmp = 1;
    } else {
      {
#line 138
      _glp_lib_xassert("1 <= k && k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                       138);
#line 138
      tmp = 1;
      }
    }
  } else {
    {
#line 138
    _glp_lib_xassert("1 <= k && k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                     138);
#line 138
    tmp = 1;
    }
  }
#line 140
  k = k;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (k < n)) {
#line 140
      goto while_break;
    }
    {
#line 142
    kk = u_loc(scf, k, k);
#line 144
    k1 = f_loc(scf, k, 1);
#line 146
    n1 = f_loc(scf, n, 1);
#line 149
    tmp___0 = fabs(*(u + kk));
#line 149
    tmp___1 = fabs(*(un + k));
    }
#line 149
    if (tmp___0 < tmp___1) {
#line 151
      j = k;
#line 151
      kj = kk;
      {
#line 151
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 151
        if (! (j <= n)) {
#line 151
          goto while_break___0;
        }
#line 152
        t = *(u + kj);
#line 152
        *(u + kj) = *(un + j);
#line 152
        *(un + j) = t;
#line 151
        j ++;
#line 151
        kj ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 155
      j = 1;
#line 155
      kj = k1;
#line 155
      nj = n1;
      {
#line 155
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 155
        if (! (j <= n)) {
#line 155
          goto while_break___1;
        }
#line 156
        t = *(f + kj);
#line 156
        *(f + kj) = *(f + nj);
#line 156
        *(f + nj) = t;
#line 155
        j ++;
#line 155
        kj ++;
#line 155
        nj ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 161
    tmp___3 = fabs(*(u + kk));
    }
#line 161
    if (tmp___3 < 1e-10) {
#line 161
      tmp___2 = 0.0;
#line 161
      *(un + k) = tmp___2;
#line 161
      *(u + kk) = tmp___2;
    }
#line 163
    if (*(un + k) == 0.0) {
#line 163
      goto __Cont;
    }
#line 165
    t = *(un + k) / *(u + kk);
#line 168
    j = k + 1;
#line 168
    kj = kk + 1;
    {
#line 168
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 168
      if (! (j <= n)) {
#line 168
        goto while_break___2;
      }
#line 169
      *(un + j) -= t * *(u + kj);
#line 168
      j ++;
#line 168
      kj ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 172
    j = 1;
#line 172
    kj = k1;
#line 172
    nj = n1;
    {
#line 172
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 172
      if (! (j <= n)) {
#line 172
        goto while_break___3;
      }
#line 173
      *(f + nj) -= t * *(f + kj);
#line 172
      j ++;
#line 172
      kj ++;
#line 172
      nj ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 140
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  tmp___4 = fabs(*(un + n));
  }
#line 177
  if (tmp___4 < 1e-10) {
#line 177
    *(un + n) = 0.0;
  }
  {
#line 179
  tmp___5 = u_loc(scf, n, n);
#line 179
  *(u + tmp___5) = *(un + n);
  }
#line 180
  return;
}
}
#line 197 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static void givens(double a , double b , double *c , double *s ) 
{ 
  double t ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 199
  if (b == 0.0) {
#line 200
    *c = 1.0;
#line 200
    *s = 0.0;
  } else {
    {
#line 201
    tmp___1 = fabs(a);
#line 201
    tmp___2 = fabs(b);
    }
#line 201
    if (tmp___1 <= tmp___2) {
      {
#line 202
      t = - a / b;
#line 202
      tmp = sqrt(1.0 + t * t);
#line 202
      *s = 1.0 / tmp;
#line 202
      *c = *s * t;
      }
    } else {
      {
#line 204
      t = - b / a;
#line 204
      tmp___0 = sqrt(1.0 + t * t);
#line 204
      *c = 1.0 / tmp___0;
#line 204
      *s = *c * t;
      }
    }
  }
#line 205
  return;
}
}
#line 236 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static void gr_transform(SCF *scf , int k , double *un ) 
{ 
  int n ;
  double *f ;
  double *u ;
  int j ;
  int k1 ;
  int kj ;
  int kk ;
  int n1 ;
  int nj ;
  double c ;
  double s ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double ukj ;
  double unj ;
  double fkj ;
  double fnj ;
  double tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 237
  n = scf->n;
#line 238
  f = scf->f;
#line 239
  u = scf->u;
#line 242
  if (1 <= k) {
#line 242
    if (k <= n) {
#line 242
      tmp = 1;
    } else {
      {
#line 242
      _glp_lib_xassert("1 <= k && k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                       242);
#line 242
      tmp = 1;
      }
    }
  } else {
    {
#line 242
    _glp_lib_xassert("1 <= k && k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                     242);
#line 242
    tmp = 1;
    }
  }
#line 244
  k = k;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (k < n)) {
#line 244
      goto while_break;
    }
    {
#line 246
    kk = u_loc(scf, k, k);
#line 248
    k1 = f_loc(scf, k, 1);
#line 250
    n1 = f_loc(scf, n, 1);
#line 253
    tmp___1 = fabs(*(u + kk));
    }
#line 253
    if (tmp___1 < 1e-10) {
      {
#line 253
      tmp___2 = fabs(*(un + k));
      }
#line 253
      if (tmp___2 < 1e-10) {
#line 254
        tmp___0 = 0.0;
#line 254
        *(un + k) = tmp___0;
#line 254
        *(u + kk) = tmp___0;
      }
    }
#line 256
    if (*(un + k) == 0.0) {
#line 256
      goto __Cont;
    }
    {
#line 258
    givens(*(u + kk), *(un + k), & c, & s);
#line 260
    j = k;
#line 260
    kj = kk;
    }
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      if (! (j <= n)) {
#line 260
        goto while_break___0;
      }
#line 261
      ukj = *(u + kj);
#line 261
      unj = *(un + j);
#line 262
      *(u + kj) = c * ukj - s * unj;
#line 263
      *(un + j) = s * ukj + c * unj;
#line 260
      j ++;
#line 260
      kj ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 267
    j = 1;
#line 267
    kj = k1;
#line 267
    nj = n1;
    {
#line 267
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 267
      if (! (j <= n)) {
#line 267
        goto while_break___1;
      }
#line 268
      fkj = *(f + kj);
#line 268
      fnj = *(f + nj);
#line 269
      *(f + kj) = c * fkj - s * fnj;
#line 270
      *(f + nj) = s * fkj + c * fnj;
#line 267
      j ++;
#line 267
      kj ++;
#line 267
      nj ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 244
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  tmp___3 = fabs(*(un + n));
  }
#line 275
  if (tmp___3 < 1e-10) {
#line 275
    *(un + n) = 0.0;
  }
  {
#line 277
  tmp___4 = u_loc(scf, n, n);
#line 277
  *(u + tmp___4) = *(un + n);
  }
#line 278
  return;
}
}
#line 286 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static void transform(SCF *scf , int k , double *un ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 288
  if (scf->t_opt == 1) {
#line 288
    goto case_1;
  }
#line 291
  if (scf->t_opt == 2) {
#line 291
    goto case_2;
  }
#line 294
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 289
  bg_transform(scf, k, un);
  }
#line 290
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 292
  gr_transform(scf, k, un);
  }
#line 293
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 295
  if ((unsigned long )scf != (unsigned long )scf) {
#line 295
    tmp = 1;
  } else {
    {
#line 295
    _glp_lib_xassert("scf != scf", "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c",
                     295);
#line 295
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 297
  return;
}
}
#line 308 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static int estimate_rank(SCF *scf ) 
{ 
  int n_max ;
  int n ;
  double *u ;
  int i ;
  int ii ;
  int inc ;
  int rank ;

  {
  {
#line 309
  n_max = scf->n_max;
#line 310
  n = scf->n;
#line 311
  u = scf->u;
#line 312
  rank = 0;
#line 313
  i = 1;
#line 313
  ii = u_loc(scf, i, i);
#line 313
  inc = n_max;
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (i <= n)) {
#line 313
      goto while_break;
    }
#line 315
    if (*(u + ii) != 0.0) {
#line 315
      rank ++;
    }
#line 313
    i ++;
#line 313
    ii += inc;
#line 313
    inc --;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return (rank);
}
}
#line 415 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
int _glp_scf_update_exp(SCF *scf , double const   *x , double const   *y , double z ) 
{ 
  int n_max ;
  int n ;
  double *f ;
  double *u ;
  int *p ;
  double *un ;
  int i ;
  int ij ;
  int in ;
  int j ;
  int k ;
  int nj ;
  int ret ;
  double t ;
  int tmp ;
  int tmp___0 ;

  {
#line 417
  n_max = scf->n_max;
#line 418
  n = scf->n;
#line 419
  f = scf->f;
#line 420
  u = scf->u;
#line 421
  p = scf->p;
#line 425
  un = scf->w;
#line 426
  ret = 0;
#line 429
  if (n == n_max) {
#line 431
    ret = 2;
#line 432
    goto done;
  }
  {
#line 435
  n ++;
#line 435
  scf->n = n;
#line 437
  i = 1;
#line 437
  in = f_loc(scf, i, n);
  }
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! (i < n)) {
#line 437
      goto while_break;
    }
#line 438
    *(f + in) = 0.0;
#line 437
    i ++;
#line 437
    in += n_max;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 440
  j = 1;
#line 440
  nj = f_loc(scf, n, j);
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! (j < n)) {
#line 440
      goto while_break___0;
    }
#line 441
    *(f + nj) = 0.0;
#line 440
    j ++;
#line 440
    nj ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 443
  tmp = f_loc(scf, n, n);
#line 443
  *(f + tmp) = 1.0;
#line 445
  i = 1;
  }
  {
#line 445
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 445
    if (! (i < n)) {
#line 445
      goto while_break___1;
    }
    {
#line 447
    t = 0.0;
#line 448
    j = 1;
#line 448
    ij = f_loc(scf, i, 1);
    }
    {
#line 448
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 448
      if (! (j < n)) {
#line 448
        goto while_break___2;
      }
#line 449
      t += *(f + ij) * (double )*(x + j);
#line 448
      j ++;
#line 448
      ij ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 450
    tmp___0 = u_loc(scf, i, n);
#line 450
    *(u + tmp___0) = t;
#line 445
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 453
  j = 1;
  {
#line 453
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 453
    if (! (j < n)) {
#line 453
      goto while_break___3;
    }
#line 453
    *(un + j) = (double )*(y + *(p + j));
#line 453
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 455
  *(un + n) = z;
#line 457
  *(p + n) = n;
#line 470
  k = 1;
  {
#line 470
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 470
    if (! (k < n)) {
#line 470
      goto while_break___4;
    }
#line 471
    if (*(un + k) != 0.0) {
#line 471
      goto while_break___4;
    }
#line 470
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 472
  transform(scf, k, un);
#line 474
  scf->rank = estimate_rank(scf);
  }
#line 475
  if (scf->rank != n) {
#line 475
    ret = 1;
  }
  done: 
#line 480
  return (ret);
}
}
#line 495 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static void solve(SCF *scf , double *x ) 
{ 
  int n ;
  double *f ;
  double *u ;
  int *p ;
  double *y ;
  int i ;
  int j ;
  int ij ;
  double t ;

  {
#line 496
  n = scf->n;
#line 497
  f = scf->f;
#line 498
  u = scf->u;
#line 499
  p = scf->p;
#line 500
  y = scf->w;
#line 504
  i = 1;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (i <= n)) {
#line 504
      goto while_break;
    }
    {
#line 506
    t = 0.0;
#line 507
    j = 1;
#line 507
    ij = f_loc(scf, i, 1);
    }
    {
#line 507
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 507
      if (! (j <= n)) {
#line 507
        goto while_break___0;
      }
#line 508
      t += *(f + ij) * *(x + j);
#line 507
      j ++;
#line 507
      ij ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 509
    *(y + i) = t;
#line 504
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  i = n;
  {
#line 512
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 512
    if (! (i >= 1)) {
#line 512
      goto while_break___1;
    }
    {
#line 513
    t = *(y + i);
#line 514
    j = n;
#line 514
    ij = u_loc(scf, i, n);
    }
    {
#line 514
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 514
      if (! (j > i)) {
#line 514
        goto while_break___2;
      }
#line 515
      t -= *(u + ij) * *(y + j);
#line 514
      j --;
#line 514
      ij --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 516
    *(y + i) = t / *(u + ij);
#line 512
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 519
  i = 1;
  {
#line 519
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 519
    if (! (i <= n)) {
#line 519
      goto while_break___3;
    }
#line 519
    *(x + *(p + i)) = *(y + i);
#line 519
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 520
  return;
}
}
#line 541 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
static void tsolve(SCF *scf , double *x ) 
{ 
  int n ;
  double *f ;
  double *u ;
  int *p ;
  double *y ;
  int i ;
  int j ;
  int ij ;
  double t ;
  double tmp ;

  {
#line 542
  n = scf->n;
#line 543
  f = scf->f;
#line 544
  u = scf->u;
#line 545
  p = scf->p;
#line 546
  y = scf->w;
#line 550
  i = 1;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (i <= n)) {
#line 550
      goto while_break;
    }
#line 550
    *(y + i) = *(x + *(p + i));
#line 550
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  i = 1;
  {
#line 552
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 552
    if (! (i <= n)) {
#line 552
      goto while_break___0;
    }
    {
#line 554
    ij = u_loc(scf, i, i);
#line 555
    tmp = *(y + i) / *(u + ij);
#line 555
    *(y + i) = tmp;
#line 555
    t = tmp;
#line 557
    j = i + 1;
#line 557
    ij ++;
    }
    {
#line 557
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 557
      if (! (j <= n)) {
#line 557
        goto while_break___1;
      }
#line 558
      *(y + j) -= *(u + ij) * t;
#line 557
      j ++;
#line 557
      ij ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 552
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 561
  j = 1;
  {
#line 561
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 561
    if (! (j <= n)) {
#line 561
      goto while_break___2;
    }
#line 561
    *(x + j) = 0.0;
#line 561
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 562
  i = 1;
  {
#line 562
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 562
    if (! (i <= n)) {
#line 562
      goto while_break___3;
    }
    {
#line 563
    t = *(y + i);
#line 564
    j = 1;
#line 564
    ij = f_loc(scf, i, 1);
    }
    {
#line 564
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 564
      if (! (j <= n)) {
#line 564
        goto while_break___4;
      }
#line 565
      *(x + j) += *(f + ij) * t;
#line 564
      j ++;
#line 564
      ij ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 562
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 567
  return;
}
}
#line 590 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
void _glp_scf_solve_it(SCF *scf , int tr , double *x ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 591
  if (scf->rank < scf->n) {
    {
#line 592
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpscf.c", 592);
#line 592
    (*tmp)("scf_solve_it: singular matrix\n");
    }
  }
#line 593
  if (! tr) {
    {
#line 594
    solve(scf, x);
    }
  } else {
    {
#line 596
    tsolve(scf, x);
    }
  }
#line 597
  return;
}
}
#line 600 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
void _glp_scf_reset_it(SCF *scf ) 
{ 
  int tmp ;

  {
#line 602
  tmp = 0;
#line 602
  scf->rank = tmp;
#line 602
  scf->n = tmp;
#line 603
  return;
}
}
#line 621 "/home/wslee/benchmarks/glpk-4.38/src/glpscf.c"
void _glp_scf_delete_it(SCF *scf ) 
{ 


  {
  {
#line 622
  _glp_lib_xfree((void *)scf->f);
#line 623
  _glp_lib_xfree((void *)scf->u);
#line 624
  _glp_lib_xfree((void *)scf->p);
#line 628
  _glp_lib_xfree((void *)scf->w);
#line 629
  _glp_lib_xfree((void *)scf);
  }
#line 630
  return;
}
}
#line 46 "/home/wslee/benchmarks/glpk-4.38/src/glprng.h"
int _glp_rng_next_rand(RNG *rand___0 ) ;
#line 58
double _glp_rng_unif_01(RNG *rand___0 ) ;
#line 62
double _glp_rng_uniform(RNG *rand___0 , double a , double b ) ;
#line 43 "/home/wslee/benchmarks/glpk-4.38/src/glprng02.c"
double _glp_rng_unif_01(RNG *rand___0 ) 
{ 
  double x ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 45
  tmp = _glp_rng_next_rand(rand___0);
#line 45
  x = (double )tmp / 2147483647.0;
  }
#line 46
  if (0.0 <= x) {
#line 46
    if (x <= 1.0) {
#line 46
      tmp___0 = 1;
    } else {
      {
#line 46
      _glp_lib_xassert("0.0 <= x && x <= 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glprng02.c",
                       46);
#line 46
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 46
    _glp_lib_xassert("0.0 <= x && x <= 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glprng02.c",
                     46);
#line 46
    tmp___0 = 1;
    }
  }
#line 47
  return (x);
}
}
#line 65 "/home/wslee/benchmarks/glpk-4.38/src/glprng02.c"
double _glp_rng_uniform(RNG *rand___0 , double a , double b ) 
{ 
  double x ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 67
  if (a >= b) {
    {
#line 68
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glprng02.c", 68);
#line 68
    (*tmp)("rng_uniform: a = %g, b = %g; invalid range\n", a, b);
    }
  }
  {
#line 69
  x = _glp_rng_unif_01(rand___0);
#line 70
  x = a * (1.0 - x) + b * x;
  }
#line 71
  if (a <= x) {
#line 71
    if (x <= b) {
#line 71
      tmp___0 = 1;
    } else {
      {
#line 71
      _glp_lib_xassert("a <= x && x <= b", "/home/wslee/benchmarks/glpk-4.38/src/glprng02.c",
                       71);
#line 71
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 71
    _glp_lib_xassert("a <= x && x <= b", "/home/wslee/benchmarks/glpk-4.38/src/glprng02.c",
                     71);
#line 71
    tmp___0 = 1;
    }
  }
#line 72
  return (x);
}
}
#line 38 "/home/wslee/benchmarks/glpk-4.38/src/glprng.h"
RNG *_glp_rng_create_rand(void) ;
#line 42
void _glp_rng_init_rand(RNG *rand___0 , int seed ) ;
#line 50
int _glp_rng_unif_rand(RNG *rand___0 , int m ) ;
#line 54
void _glp_rng_delete_rand(RNG *rand___0 ) ;
#line 50 "/home/wslee/benchmarks/glpk-4.38/src/glprng01.c"
static int flip_cycle(RNG *rand___0 ) 
{ 
  int *ii ;
  int *jj ;

  {
#line 54
  ii = & rand___0->A[1];
#line 54
  jj = & rand___0->A[32];
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )jj <= (unsigned long )(& rand___0->A[55]))) {
#line 54
      goto while_break;
    }
#line 55
    *ii = (*ii - *jj) & 2147483647;
#line 54
    ii ++;
#line 54
    jj ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  jj = & rand___0->A[1];
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )ii <= (unsigned long )(& rand___0->A[55]))) {
#line 56
      goto while_break___0;
    }
#line 57
    *ii = (*ii - *jj) & 2147483647;
#line 56
    ii ++;
#line 56
    jj ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 58
  rand___0->fptr = & rand___0->A[54];
#line 59
  return (rand___0->A[55]);
}
}
#line 81 "/home/wslee/benchmarks/glpk-4.38/src/glprng01.c"
RNG *_glp_rng_create_rand(void) 
{ 
  RNG *rand___0 ;
  int i ;
  void *tmp ;

  {
  {
#line 84
  tmp = _glp_lib_xmalloc((int )sizeof(RNG ));
#line 84
  rand___0 = (RNG *)tmp;
#line 85
  rand___0->A[0] = -1;
#line 86
  i = 1;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i <= 55)) {
#line 86
      goto while_break;
    }
#line 86
    rand___0->A[i] = 0;
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  rand___0->fptr = rand___0->A;
#line 88
  _glp_rng_init_rand(rand___0, 1);
  }
#line 89
  return (rand___0);
}
}
#line 109 "/home/wslee/benchmarks/glpk-4.38/src/glprng01.c"
void _glp_rng_init_rand(RNG *rand___0 , int seed ) 
{ 
  int i ;
  int prev ;
  int next ;

  {
#line 111
  prev = seed;
#line 111
  next = 1;
#line 112
  prev &= 2147483647;
#line 112
  seed = prev;
#line 113
  rand___0->A[55] = prev;
#line 114
  i = 21;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! i) {
#line 114
      goto while_break;
    }
#line 115
    rand___0->A[i] = next;
#line 116
    next = (prev - next) & 2147483647;
#line 117
    if (seed & 1) {
#line 118
      seed = 1073741824 + (seed >> 1);
    } else {
#line 120
      seed >>= 1;
    }
#line 121
    next = (next - seed) & 2147483647;
#line 122
    prev = rand___0->A[i];
#line 114
    i = (i + 21) % 55;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  flip_cycle(rand___0);
#line 125
  flip_cycle(rand___0);
#line 126
  flip_cycle(rand___0);
#line 127
  flip_cycle(rand___0);
#line 128
  flip_cycle(rand___0);
  }
#line 129
  return;
}
}
#line 149 "/home/wslee/benchmarks/glpk-4.38/src/glprng01.c"
int _glp_rng_next_rand(RNG *rand___0 ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 150
  if (*(rand___0->fptr) >= 0) {
#line 150
    tmp = rand___0->fptr;
#line 150
    (rand___0->fptr) --;
#line 150
    tmp___1 = *tmp;
  } else {
    {
#line 150
    tmp___0 = flip_cycle(rand___0);
#line 150
    tmp___1 = tmp___0;
    }
  }
#line 150
  return (tmp___1);
}
}
#line 172 "/home/wslee/benchmarks/glpk-4.38/src/glprng01.c"
int _glp_rng_unif_rand(RNG *rand___0 , int m ) 
{ 
  unsigned int t ;
  int r ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 173
  t = 2147483648U - 2147483648U % (unsigned int )m;
#line 175
  if (m > 0) {
#line 175
    tmp = 1;
  } else {
    {
#line 175
    _glp_lib_xassert("m > 0", "/home/wslee/benchmarks/glpk-4.38/src/glprng01.c", 175);
#line 175
    tmp = 1;
    }
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    r = _glp_rng_next_rand(rand___0);
    }
#line 176
    if (! (t <= (unsigned int )r)) {
#line 176
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (r % m);
}
}
#line 195 "/home/wslee/benchmarks/glpk-4.38/src/glprng01.c"
void _glp_rng_delete_rand(RNG *rand___0 ) 
{ 


  {
  {
#line 196
  _glp_lib_xfree((void *)rand___0);
  }
#line 197
  return;
}
}
#line 219 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 74 "/home/wslee/benchmarks/glpk-4.38/src/glprgr.c"
static void put_byte(FILE *fp , int c ) 
{ 


  {
  {
#line 75
  fputc(c, fp);
  }
#line 76
  return;
}
}
#line 79 "/home/wslee/benchmarks/glpk-4.38/src/glprgr.c"
static void put_word(FILE *fp , int w ) 
{ 


  {
  {
#line 81
  put_byte(fp, w);
#line 82
  put_byte(fp, w >> 8);
  }
#line 83
  return;
}
}
#line 86 "/home/wslee/benchmarks/glpk-4.38/src/glprgr.c"
static void put_dword(FILE *fp , int d___0 ) 
{ 


  {
  {
#line 88
  put_word(fp, d___0);
#line 89
  put_word(fp, d___0 >> 16);
  }
#line 90
  return;
}
}
#line 93 "/home/wslee/benchmarks/glpk-4.38/src/glprgr.c"
int _glp_rgr_write_bmp16(char const   *fname , int m , int n , char const   *map ) 
{ 
  FILE *fp ;
  int offset ;
  int bmsize ;
  int i ;
  int j ;
  int b ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 95
  ret = 0;
#line 96
  if (1 <= m) {
#line 96
    if (! (m <= 32767)) {
      {
#line 97
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glprgr.c", 97);
#line 97
      (*tmp)("rgr_write_bmp16: m = %d; invalid height\n", m);
      }
    }
  } else {
    {
#line 97
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glprgr.c", 97);
#line 97
    (*tmp)("rgr_write_bmp16: m = %d; invalid height\n", m);
    }
  }
#line 98
  if (1 <= n) {
#line 98
    if (! (n <= 32767)) {
      {
#line 99
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glprgr.c",
                                 99);
#line 99
      (*tmp___0)("rgr_write_bmp16: n = %d; invalid width\n", n);
      }
    }
  } else {
    {
#line 99
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glprgr.c", 99);
#line 99
    (*tmp___0)("rgr_write_bmp16: n = %d; invalid width\n", n);
    }
  }
  {
#line 100
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"wb");
  }
#line 101
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 102
    tmp___1 = __errno_location();
#line 102
    tmp___2 = strerror(*tmp___1);
#line 102
    _glp_lib_xprintf("rgr_write_bmp16: unable to create `%s\' - %s\n", fname, tmp___2);
#line 104
    ret = 1;
    }
#line 105
    goto fini;
  }
  {
#line 107
  offset = 118;
#line 108
  bmsize = (4 * n + 31) / 32;
#line 110
  put_byte(fp, 'B');
#line 110
  put_byte(fp, 'M');
#line 111
  put_dword(fp, offset + bmsize * 4);
#line 112
  put_word(fp, 0);
#line 113
  put_word(fp, 0);
#line 114
  put_dword(fp, offset);
#line 116
  put_dword(fp, 40);
#line 117
  put_dword(fp, n);
#line 118
  put_dword(fp, m);
#line 119
  put_word(fp, 1);
#line 120
  put_word(fp, 4);
#line 121
  put_dword(fp, 0);
#line 122
  put_dword(fp, 0);
#line 123
  put_dword(fp, 2953);
#line 124
  put_dword(fp, 2953);
#line 125
  put_dword(fp, 0);
#line 126
  put_dword(fp, 0);
#line 129
  put_dword(fp, 0);
#line 130
  put_dword(fp, 128);
#line 131
  put_dword(fp, 32768);
#line 132
  put_dword(fp, 32896);
#line 133
  put_dword(fp, 8388608);
#line 134
  put_dword(fp, 8388736);
#line 135
  put_dword(fp, 8421376);
#line 136
  put_dword(fp, 12632256);
#line 137
  put_dword(fp, 8421504);
#line 138
  put_dword(fp, 255);
#line 139
  put_dword(fp, 65280);
#line 140
  put_dword(fp, 65535);
#line 141
  put_dword(fp, 16711680);
#line 142
  put_dword(fp, 16711935);
#line 143
  put_dword(fp, 16776960);
#line 144
  put_dword(fp, 16777215);
#line 146
  b = 0;
#line 147
  i = m - 1;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (i >= 0)) {
#line 147
      goto while_break;
    }
#line 148
    j = 0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      if (! (j < ((n + 7) / 8) * 8)) {
#line 148
        goto while_break___0;
      }
#line 149
      b <<= 4;
#line 150
      if (j < n) {
#line 150
        tmp___3 = (int const   )*(map + (i * n + j)) & 15;
      } else {
#line 150
        tmp___3 = (int const   )0;
      }
#line 150
      b |= (int )tmp___3;
#line 151
      if (j & 1) {
        {
#line 151
        put_byte(fp, b);
        }
      }
#line 148
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  fflush(fp);
#line 155
  tmp___6 = ferror(fp);
  }
#line 155
  if (tmp___6) {
    {
#line 156
    tmp___4 = __errno_location();
#line 156
    tmp___5 = strerror(*tmp___4);
#line 156
    _glp_lib_xprintf("rgr_write_bmp16: write error on `%s\' - %s\n", fname, tmp___5);
#line 158
    ret = 1;
    }
  }
  fini: 
#line 160
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 160
    fclose(fp);
    }
  }
#line 161
  return (ret);
}
}
#line 28 "/home/wslee/benchmarks/glpk-4.38/src/glpqmd.h"
void _glp_qmd_genqmd(int *_neqns , int *xadj , int *adjncy , int *perm , int *invp ,
                     int *deg , int *marker , int *rchset , int *nbrhd , int *qsize ,
                     int *qlink , int *_nofsub ) ;
#line 34
void _glp_qmd_qmdrch(int *_root , int *xadj , int *adjncy , int *deg , int *marker ,
                     int *_rchsze , int *rchset , int *_nhdsze , int *nbrhd ) ;
#line 40
void _glp_qmd_qmdqt(int *_root , int *xadj , int *adjncy , int *marker , int *_rchsze ,
                    int *rchset , int *nbrhd ) ;
#line 45
void _glp_qmd_qmdupd(int *xadj , int *adjncy , int *_nlist , int *list , int *deg ,
                     int *qsize , int *qlink , int *marker , int *rchset , int *nbrhd ) ;
#line 51
void _glp_qmd_qmdmrg(int *xadj , int *adjncy , int *deg , int *qsize , int *qlink ,
                     int *marker , int *_deg0 , int *_nhdsze , int *nbrhd , int *rchset ,
                     int *ovrlp ) ;
#line 86 "/home/wslee/benchmarks/glpk-4.38/src/glpqmd.c"
void _glp_qmd_genqmd(int *_neqns , int *xadj , int *adjncy , int *perm , int *invp ,
                     int *deg , int *marker , int *rchset , int *nbrhd , int *qsize ,
                     int *qlink , int *_nofsub ) 
{ 
  int inode ;
  int ip ;
  int irch ;
  int j ;
  int mindeg ;
  int ndeg ;
  int nhdsze ;
  int node ;
  int np ;
  int num ;
  int nump1 ;
  int nxnode ;
  int rchsze ;
  int search ;
  int thresh ;

  {
#line 94
  mindeg = *_neqns;
#line 95
  *_nofsub = 0;
#line 96
  node = 1;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (node <= *_neqns)) {
#line 96
      goto while_break;
    }
#line 97
    *(perm + node) = node;
#line 98
    *(invp + node) = node;
#line 99
    *(marker + node) = 0;
#line 100
    *(qsize + node) = 1;
#line 101
    *(qlink + node) = 0;
#line 102
    ndeg = *(xadj + (node + 1)) - *(xadj + node);
#line 103
    *(deg + node) = ndeg;
#line 104
    if (ndeg < mindeg) {
#line 104
      mindeg = ndeg;
    }
#line 96
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  num = 0;
  s200: 
#line 109
  search = 1;
#line 110
  thresh = mindeg;
#line 111
  mindeg = *_neqns;
  s300: 
#line 112
  nump1 = num + 1;
#line 113
  if (nump1 > search) {
#line 113
    search = nump1;
  }
#line 114
  j = search;
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (! (j <= *_neqns)) {
#line 114
      goto while_break___0;
    }
#line 115
    node = *(perm + j);
#line 116
    if (*(marker + node) >= 0) {
#line 117
      ndeg = *(deg + node);
#line 118
      if (ndeg <= thresh) {
#line 118
        goto s500;
      }
#line 119
      if (ndeg < mindeg) {
#line 119
        mindeg = ndeg;
      }
    }
#line 114
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  goto s200;
  s500: 
  {
#line 125
  search = j;
#line 126
  *_nofsub += *(deg + node);
#line 127
  *(marker + node) = 1;
#line 128
  _glp_qmd_qmdrch(& node, xadj, adjncy, deg, marker, & rchsze, rchset, & nhdsze, nbrhd);
#line 132
  nxnode = node;
  }
  s600: 
#line 133
  num ++;
#line 134
  np = *(invp + nxnode);
#line 135
  ip = *(perm + num);
#line 136
  *(perm + np) = ip;
#line 137
  *(invp + ip) = np;
#line 138
  *(perm + num) = nxnode;
#line 139
  *(invp + nxnode) = num;
#line 140
  *(deg + nxnode) = -1;
#line 141
  nxnode = *(qlink + nxnode);
#line 142
  if (nxnode > 0) {
#line 142
    goto s600;
  }
#line 143
  if (rchsze > 0) {
    {
#line 146
    _glp_qmd_qmdupd(xadj, adjncy, & rchsze, rchset, deg, qsize, qlink, marker, rchset + (rchsze + 1),
                    nbrhd + (nhdsze + 1));
#line 151
    *(marker + node) = 0;
#line 152
    irch = 1;
    }
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (! (irch <= rchsze)) {
#line 152
        goto while_break___1;
      }
#line 153
      inode = *(rchset + irch);
#line 154
      if (*(marker + inode) >= 0) {
#line 155
        *(marker + inode) = 0;
#line 156
        ndeg = *(deg + inode);
#line 157
        if (ndeg < mindeg) {
#line 157
          mindeg = ndeg;
        }
#line 158
        if (ndeg <= thresh) {
#line 159
          mindeg = thresh;
#line 160
          thresh = ndeg;
#line 161
          search = *(invp + inode);
        }
      }
#line 152
      irch ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 165
    if (nhdsze > 0) {
      {
#line 166
      _glp_qmd_qmdqt(& node, xadj, adjncy, marker, & rchsze, rchset, nbrhd);
      }
    }
  }
#line 168
  if (num < *_neqns) {
#line 168
    goto s300;
  }
#line 169
  return;
}
}
#line 214 "/home/wslee/benchmarks/glpk-4.38/src/glpqmd.c"
void _glp_qmd_qmdrch(int *_root , int *xadj , int *adjncy , int *deg , int *marker ,
                     int *_rchsze , int *rchset , int *_nhdsze , int *nbrhd ) 
{ 
  int i ;
  int istop ;
  int istrt ;
  int j ;
  int jstop ;
  int jstrt ;
  int nabor ;
  int node ;

  {
#line 222
  *_nhdsze = 0;
#line 223
  *_rchsze = 0;
#line 224
  istrt = *(xadj + *_root);
#line 225
  istop = *(xadj + (*_root + 1)) - 1;
#line 226
  if (istop < istrt) {
#line 226
    return;
  }
#line 227
  i = istrt;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i <= istop)) {
#line 227
      goto while_break;
    }
#line 228
    nabor = *(adjncy + i);
#line 229
    if (nabor == 0) {
#line 229
      return;
    }
#line 230
    if (*(marker + nabor) == 0) {
#line 231
      if (*(deg + nabor) >= 0) {
#line 233
        (*_rchsze) ++;
#line 234
        *(rchset + *_rchsze) = nabor;
#line 235
        *(marker + nabor) = 1;
#line 236
        goto s600;
      }
#line 240
      *(marker + nabor) = -1;
#line 241
      (*_nhdsze) ++;
#line 242
      *(nbrhd + *_nhdsze) = nabor;
      s300: 
#line 243
      jstrt = *(xadj + nabor);
#line 244
      jstop = *(xadj + (nabor + 1)) - 1;
#line 245
      j = jstrt;
      {
#line 245
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 245
        if (! (j <= jstop)) {
#line 245
          goto while_break___0;
        }
#line 246
        node = *(adjncy + j);
#line 247
        nabor = - node;
#line 248
        if (node < 0) {
#line 248
          goto s300;
        }
#line 249
        if (node == 0) {
#line 249
          goto s600;
        }
#line 250
        if (*(marker + node) == 0) {
#line 251
          (*_rchsze) ++;
#line 252
          *(rchset + *_rchsze) = node;
#line 253
          *(marker + node) = 1;
        }
#line 245
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    s600: 
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return;
}
}
#line 298 "/home/wslee/benchmarks/glpk-4.38/src/glpqmd.c"
void _glp_qmd_qmdqt(int *_root , int *xadj , int *adjncy , int *marker , int *_rchsze ,
                    int *rchset , int *nbrhd ) 
{ 
  int inhd ;
  int irch ;
  int j ;
  int jstop ;
  int jstrt ;
  int link ;
  int nabor ;
  int node ;

  {
#line 303
  irch = 0;
#line 304
  inhd = 0;
#line 305
  node = *_root;
  s100: 
#line 306
  jstrt = *(xadj + node);
#line 307
  jstop = *(xadj + (node + 1)) - 2;
#line 308
  if (jstop >= jstrt) {
#line 310
    j = jstrt;
    {
#line 310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 310
      if (! (j <= jstop)) {
#line 310
        goto while_break;
      }
#line 311
      irch ++;
#line 312
      *(adjncy + j) = *(rchset + irch);
#line 313
      if (irch >= *_rchsze) {
#line 313
        goto s400;
      }
#line 310
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 317
  link = *(adjncy + (jstop + 1));
#line 318
  node = - link;
#line 319
  if (link >= 0) {
#line 320
    inhd ++;
#line 321
    node = *(nbrhd + inhd);
#line 322
    *(adjncy + (jstop + 1)) = - node;
  }
#line 324
  goto s100;
  s400: 
#line 328
  *(adjncy + (j + 1)) = 0;
#line 329
  irch = 1;
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 329
    if (! (irch <= *_rchsze)) {
#line 329
      goto while_break___0;
    }
#line 330
    node = *(rchset + irch);
#line 331
    if (*(marker + node) >= 0) {
#line 332
      jstrt = *(xadj + node);
#line 333
      jstop = *(xadj + (node + 1)) - 1;
#line 334
      j = jstrt;
      {
#line 334
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 334
        if (! (j <= jstop)) {
#line 334
          goto while_break___1;
        }
#line 335
        nabor = *(adjncy + j);
#line 336
        if (*(marker + nabor) < 0) {
#line 337
          *(adjncy + j) = *_root;
#line 338
          goto s600;
        }
#line 334
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    s600: 
#line 329
    irch ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 344
  return;
}
}
#line 390 "/home/wslee/benchmarks/glpk-4.38/src/glpqmd.c"
void _glp_qmd_qmdupd(int *xadj , int *adjncy , int *_nlist , int *list , int *deg ,
                     int *qsize , int *qlink , int *marker , int *rchset , int *nbrhd ) 
{ 
  int deg0 ;
  int deg1 ;
  int il ;
  int inhd ;
  int inode ;
  int irch ;
  int j ;
  int jstop ;
  int jstrt ;
  int mark ;
  int nabor ;
  int nhdsze ;
  int node ;
  int rchsze ;

  {
#line 399
  if (*_nlist <= 0) {
#line 399
    return;
  }
#line 400
  deg0 = 0;
#line 401
  nhdsze = 0;
#line 402
  il = 1;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (il <= *_nlist)) {
#line 402
      goto while_break;
    }
#line 403
    node = *(list + il);
#line 404
    deg0 += *(qsize + node);
#line 405
    jstrt = *(xadj + node);
#line 406
    jstop = *(xadj + (node + 1)) - 1;
#line 407
    j = jstrt;
    {
#line 407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 407
      if (! (j <= jstop)) {
#line 407
        goto while_break___0;
      }
#line 408
      nabor = *(adjncy + j);
#line 409
      if (*(marker + nabor) == 0) {
#line 409
        if (*(deg + nabor) < 0) {
#line 410
          *(marker + nabor) = -1;
#line 411
          nhdsze ++;
#line 412
          *(nbrhd + nhdsze) = nabor;
        }
      }
#line 407
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 402
    il ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  if (nhdsze > 0) {
    {
#line 419
    _glp_qmd_qmdmrg(xadj, adjncy, deg, qsize, qlink, marker, & deg0, & nhdsze, nbrhd,
                    rchset, nbrhd + (nhdsze + 1));
    }
  }
#line 422
  il = 1;
  {
#line 422
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 422
    if (! (il <= *_nlist)) {
#line 422
      goto while_break___1;
    }
#line 423
    node = *(list + il);
#line 424
    mark = *(marker + node);
#line 425
    if (mark == 0) {
#line 425
      goto _L;
    } else
#line 425
    if (mark == 1) {
      _L: /* CIL Label */ 
      {
#line 426
      *(marker + node) = 2;
#line 427
      _glp_qmd_qmdrch(& node, xadj, adjncy, deg, marker, & rchsze, rchset, & nhdsze,
                      nbrhd);
#line 429
      deg1 = deg0;
      }
#line 430
      if (rchsze > 0) {
#line 431
        irch = 1;
        {
#line 431
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 431
          if (! (irch <= rchsze)) {
#line 431
            goto while_break___2;
          }
#line 432
          inode = *(rchset + irch);
#line 433
          deg1 += *(qsize + inode);
#line 434
          *(marker + inode) = 0;
#line 431
          irch ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 437
      *(deg + node) = deg1 - 1;
#line 438
      if (nhdsze > 0) {
#line 439
        inhd = 1;
        {
#line 439
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 439
          if (! (inhd <= nhdsze)) {
#line 439
            goto while_break___3;
          }
#line 440
          inode = *(nbrhd + inhd);
#line 441
          *(marker + inode) = 0;
#line 439
          inhd ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 422
    il ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 492 "/home/wslee/benchmarks/glpk-4.38/src/glpqmd.c"
void _glp_qmd_qmdmrg(int *xadj , int *adjncy , int *deg , int *qsize , int *qlink ,
                     int *marker , int *_deg0 , int *_nhdsze , int *nbrhd , int *rchset ,
                     int *ovrlp ) 
{ 
  int deg1 ;
  int head ;
  int inhd ;
  int iov ;
  int irch ;
  int j ;
  int jstop ;
  int jstrt ;
  int link ;
  int lnode ;
  int mark ;
  int mrgsze ;
  int nabor ;
  int node ;
  int novrlp ;
  int rchsze ;
  int root ;

  {
#line 500
  if (*_nhdsze <= 0) {
#line 500
    return;
  }
#line 501
  inhd = 1;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! (inhd <= *_nhdsze)) {
#line 501
      goto while_break;
    }
#line 502
    root = *(nbrhd + inhd);
#line 503
    *(marker + root) = 0;
#line 501
    inhd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  inhd = 1;
  {
#line 507
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 507
    if (! (inhd <= *_nhdsze)) {
#line 507
      goto while_break___0;
    }
#line 508
    root = *(nbrhd + inhd);
#line 509
    *(marker + root) = -1;
#line 510
    rchsze = 0;
#line 511
    novrlp = 0;
#line 512
    deg1 = 0;
    s200: 
#line 513
    jstrt = *(xadj + root);
#line 514
    jstop = *(xadj + (root + 1)) - 1;
#line 517
    j = jstrt;
    {
#line 517
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 517
      if (! (j <= jstop)) {
#line 517
        goto while_break___1;
      }
#line 518
      nabor = *(adjncy + j);
#line 519
      root = - nabor;
#line 520
      if (nabor < 0) {
#line 520
        goto s200;
      }
#line 521
      if (nabor == 0) {
#line 521
        goto while_break___1;
      }
#line 522
      mark = *(marker + nabor);
#line 523
      if (mark == 0) {
#line 524
        rchsze ++;
#line 525
        *(rchset + rchsze) = nabor;
#line 526
        deg1 += *(qsize + nabor);
#line 527
        *(marker + nabor) = 1;
      } else
#line 529
      if (mark == 1) {
#line 530
        novrlp ++;
#line 531
        *(ovrlp + novrlp) = nabor;
#line 532
        *(marker + nabor) = 2;
      }
#line 517
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 537
    head = 0;
#line 538
    mrgsze = 0;
#line 539
    iov = 1;
    {
#line 539
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 539
      if (! (iov <= novrlp)) {
#line 539
        goto while_break___2;
      }
#line 540
      node = *(ovrlp + iov);
#line 541
      jstrt = *(xadj + node);
#line 542
      jstop = *(xadj + (node + 1)) - 1;
#line 543
      j = jstrt;
      {
#line 543
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 543
        if (! (j <= jstop)) {
#line 543
          goto while_break___3;
        }
#line 544
        nabor = *(adjncy + j);
#line 545
        if (*(marker + nabor) == 0) {
#line 546
          *(marker + node) = 1;
#line 547
          goto s1100;
        }
#line 543
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 552
      mrgsze += *(qsize + node);
#line 553
      *(marker + node) = -1;
#line 554
      lnode = node;
      s900: 
#line 555
      link = *(qlink + lnode);
#line 556
      if (link > 0) {
#line 557
        lnode = link;
#line 558
        goto s900;
      }
#line 560
      *(qlink + lnode) = head;
#line 561
      head = node;
      s1100: 
#line 539
      iov ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 564
    if (head > 0) {
#line 565
      *(qsize + head) = mrgsze;
#line 566
      *(deg + head) = (*_deg0 + deg1) - 1;
#line 567
      *(marker + head) = 2;
    }
#line 570
    root = *(nbrhd + inhd);
#line 571
    *(marker + root) = 0;
#line 572
    if (rchsze > 0) {
#line 573
      irch = 1;
      {
#line 573
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 573
        if (! (irch <= rchsze)) {
#line 573
          goto while_break___4;
        }
#line 574
        node = *(rchset + irch);
#line 575
        *(marker + node) = 0;
#line 573
        irch ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 507
    inhd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 579
  return;
}
}
#line 246 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
NPPROW *_glp_npp_add_row(NPP *npp ) ;
#line 250
NPPCOL *_glp_npp_add_col(NPP *npp ) ;
#line 254
NPPAIJ *_glp_npp_add_aij(NPP *npp , NPPROW *row , NPPCOL *col , double val ) ;
#line 258
void *_glp_npp_push_tse(NPP *npp , void (*func___0)(NPP *npp , void *info ) , int size ) ;
#line 263
void _glp_npp_del_row(NPP *npp , NPPROW *row ) ;
#line 267
void _glp_npp_del_col(NPP *npp , NPPCOL *col ) ;
#line 292
void _glp_npp_free_row(NPP *npp , NPPROW *row ) ;
#line 296
void _glp_npp_gteq_row(NPP *npp , NPPROW *row ) ;
#line 300
void _glp_npp_lteq_row(NPP *npp , NPPROW *row ) ;
#line 304
void _glp_npp_free_col(NPP *npp , NPPCOL *col ) ;
#line 308
void _glp_npp_lbnd_col(NPP *npp , NPPCOL *col ) ;
#line 312
void _glp_npp_ubnd_col(NPP *npp , NPPCOL *col ) ;
#line 316
void _glp_npp_dbnd_col(NPP *npp , NPPCOL *col ) ;
#line 320
void _glp_npp_fixed_col(NPP *npp , NPPCOL *col ) ;
#line 324
int _glp_npp_empty_row(NPP *npp , NPPROW *row ) ;
#line 328
int _glp_npp_empty_col(NPP *npp , NPPCOL *col ) ;
#line 332
int _glp_npp_sngl_row(NPP *npp , NPPROW *row ) ;
#line 44 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_free_row(NPP *npp , void *_info ) ;
#line 46 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_free_row(NPP *npp , NPPROW *row ) 
{ 
  struct free_row *info ;
  NPPAIJ *aij ;
  NPPLFE *lfe ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 52
  if (row->lb == - 1.7976931348623157e+308) {
#line 52
    if (row->ub == 1.7976931348623157e+308) {
#line 52
      tmp = 1;
    } else {
      {
#line 52
      _glp_lib_xassert("row->lb == -DBL_MAX && row->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                       52);
#line 52
      tmp = 1;
      }
    }
  } else {
    {
#line 52
    _glp_lib_xassert("row->lb == -DBL_MAX && row->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     52);
#line 52
    tmp = 1;
    }
  }
  {
#line 54
  tmp___0 = _glp_npp_push_tse(npp, & rcv_free_row, (int )sizeof(struct free_row ));
#line 54
  info = (struct free_row *)tmp___0;
#line 56
  info->p = row->i;
#line 57
  info->ptr = (NPPLFE *)((void *)0);
#line 59
  aij = row->ptr;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 59
      goto while_break;
    }
    {
#line 60
    tmp___1 = _glp_dmp_get_atom(npp->stack, (int )sizeof(NPPLFE ));
#line 60
    lfe = (NPPLFE *)tmp___1;
#line 61
    lfe->ref = (aij->col)->j;
#line 62
    lfe->val = aij->val;
#line 63
    lfe->next = info->ptr;
#line 64
    info->ptr = lfe;
#line 59
    aij = aij->r_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  _glp_npp_del_row(npp, row);
  }
#line 68
  return;
}
}
#line 71 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_free_row(NPP *npp , void *_info ) 
{ 
  struct free_row *info ;
  NPPLFE *lfe ;
  double sum ;

  {
#line 73
  info = (struct free_row *)_info;
#line 76
  if (npp->sol == 1) {
#line 78
    *(npp->r_stat + info->p) = (char)1;
  }
#line 81
  sum = 0.0;
#line 82
  lfe = info->ptr;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
#line 83
    sum += lfe->val * *(npp->c_prim + lfe->ref);
#line 82
    lfe = lfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  *(npp->r_prim + info->p) = sum;
#line 86
  if (npp->sol != 3) {
#line 87
    *(npp->r_dual + info->p) = 0.0;
  }
#line 88
  return;
}
}
#line 114
static void rcv_gteq_row(NPP *npp , void *_info ) ;
#line 116 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_gteq_row(NPP *npp , NPPROW *row ) 
{ 
  struct ineq_row *info ;
  NPPCOL *col ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 121
  if (row->lb != - 1.7976931348623157e+308) {
#line 121
    tmp = 1;
  } else {
    {
#line 121
    _glp_lib_xassert("row->lb != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     121);
#line 121
    tmp = 1;
    }
  }
  {
#line 123
  col = _glp_npp_add_col(npp);
#line 124
  col->lb = 0.0;
  }
#line 125
  if (row->ub == 1.7976931348623157e+308) {
#line 125
    col->ub = 1.7976931348623157e+308;
  } else {
#line 125
    col->ub = row->ub - row->lb;
  }
  {
#line 127
  _glp_npp_add_aij(npp, row, col, - 1.0);
#line 129
  tmp___0 = _glp_npp_push_tse(npp, & rcv_gteq_row, (int )sizeof(struct ineq_row ));
#line 129
  info = (struct ineq_row *)tmp___0;
#line 131
  info->p = row->i;
#line 132
  info->s = col->j;
#line 134
  row->ub = row->lb;
  }
#line 135
  return;
}
}
#line 138 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_gteq_row(NPP *npp , void *_info ) 
{ 
  struct ineq_row *info ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 140
  info = (struct ineq_row *)_info;
#line 141
  if (npp->sol == 1) {
#line 142
    if (! ((int )*(npp->r_stat + info->p) == 1)) {
#line 144
      if ((int )*(npp->c_stat + info->s) == 1) {
#line 145
        *(npp->r_stat + info->p) = (char)1;
      } else
#line 146
      if ((int )*(npp->c_stat + info->s) == 2) {
#line 147
        *(npp->r_stat + info->p) = (char)2;
      } else
#line 148
      if ((int )*(npp->c_stat + info->s) == 3) {
#line 149
        *(npp->r_stat + info->p) = (char)3;
      } else
#line 151
      if ((unsigned long )npp != (unsigned long )npp) {
#line 151
        tmp = 1;
      } else {
        {
#line 151
        _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                         151);
#line 151
        tmp = 1;
        }
      }
    }
  }
#line 155
  *(npp->r_prim + info->p) += *(npp->c_prim + info->s);
#line 157
  if (npp->sol != 3) {
#line 158
    *(npp->r_dual + info->p) = *(npp->c_dual + info->s);
  }
#line 159
  return;
}
}
#line 177
static void rcv_lteq_row(NPP *npp , void *_info ) ;
#line 179 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_lteq_row(NPP *npp , NPPROW *row ) 
{ 
  struct ineq_row *info ;
  NPPCOL *col ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 184
  if (row->ub != 1.7976931348623157e+308) {
#line 184
    tmp = 1;
  } else {
    {
#line 184
    _glp_lib_xassert("row->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     184);
#line 184
    tmp = 1;
    }
  }
  {
#line 186
  col = _glp_npp_add_col(npp);
#line 187
  col->lb = 0.0;
  }
#line 188
  if (row->lb == - 1.7976931348623157e+308) {
#line 188
    col->ub = 1.7976931348623157e+308;
  } else {
#line 188
    col->ub = row->ub - row->lb;
  }
  {
#line 190
  _glp_npp_add_aij(npp, row, col, 1.0);
#line 192
  tmp___0 = _glp_npp_push_tse(npp, & rcv_lteq_row, (int )sizeof(struct ineq_row ));
#line 192
  info = (struct ineq_row *)tmp___0;
#line 194
  info->p = row->i;
#line 195
  info->s = col->j;
#line 197
  row->lb = row->ub;
  }
#line 198
  return;
}
}
#line 201 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_lteq_row(NPP *npp , void *_info ) 
{ 
  struct ineq_row *info ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 203
  info = (struct ineq_row *)_info;
#line 204
  if (npp->sol == 1) {
#line 205
    if (! ((int )*(npp->r_stat + info->p) == 1)) {
#line 207
      if ((int )*(npp->c_stat + info->s) == 1) {
#line 208
        *(npp->r_stat + info->p) = (char)1;
      } else
#line 209
      if ((int )*(npp->c_stat + info->s) == 2) {
#line 210
        *(npp->r_stat + info->p) = (char)3;
      } else
#line 211
      if ((int )*(npp->c_stat + info->s) == 3) {
#line 212
        *(npp->r_stat + info->p) = (char)2;
      } else
#line 214
      if ((unsigned long )npp != (unsigned long )npp) {
#line 214
        tmp = 1;
      } else {
        {
#line 214
        _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                         214);
#line 214
        tmp = 1;
        }
      }
    }
  }
#line 218
  *(npp->r_prim + info->p) -= *(npp->c_prim + info->s);
#line 220
  if (npp->sol != 3) {
#line 221
    *(npp->r_dual + info->p) = - *(npp->c_dual + info->s);
  }
#line 222
  return;
}
}
#line 246
static void rcv_free_col(NPP *npp , void *_info ) ;
#line 248 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_free_col(NPP *npp , NPPCOL *col ) 
{ 
  struct free_col *info ;
  NPPCOL *ccc ;
  NPPAIJ *aij ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 254
  if (col->lb == - 1.7976931348623157e+308) {
#line 254
    if (col->ub == 1.7976931348623157e+308) {
#line 254
      tmp = 1;
    } else {
      {
#line 254
      _glp_lib_xassert("col->lb == -DBL_MAX && col->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                       254);
#line 254
      tmp = 1;
      }
    }
  } else {
    {
#line 254
    _glp_lib_xassert("col->lb == -DBL_MAX && col->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     254);
#line 254
    tmp = 1;
    }
  }
  {
#line 256
  col->lb = 0.0;
#line 256
  col->ub = 1.7976931348623157e+308;
#line 258
  ccc = _glp_npp_add_col(npp);
#line 259
  ccc->lb = 0.0;
#line 259
  ccc->ub = 1.7976931348623157e+308;
#line 261
  ccc->coef = - col->coef;
#line 263
  aij = col->ptr;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 263
      goto while_break;
    }
    {
#line 264
    _glp_npp_add_aij(npp, aij->row, ccc, - aij->val);
#line 263
    aij = aij->c_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  tmp___0 = _glp_npp_push_tse(npp, & rcv_free_col, (int )sizeof(struct free_col ));
#line 266
  info = (struct free_col *)tmp___0;
#line 268
  info->q = col->j;
#line 269
  info->j = ccc->j;
  }
#line 270
  return;
}
}
#line 273 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_free_col(NPP *npp , void *_info ) 
{ 
  struct free_col *info ;

  {
#line 275
  info = (struct free_col *)_info;
#line 276
  if (npp->sol == 1) {
#line 277
    if ((int )*(npp->c_stat + info->q) == 2) {
#line 277
      if ((int )*(npp->c_stat + info->j) == 2) {
#line 280
        *(npp->c_stat + info->q) = (char)4;
      } else {
#line 285
        *(npp->c_stat + info->q) = (char)1;
      }
    } else {
#line 285
      *(npp->c_stat + info->q) = (char)1;
    }
  }
#line 289
  *(npp->c_prim + info->q) -= *(npp->c_prim + info->j);
#line 292
  if (npp->sol != 3) {
#line 293
    *(npp->c_dual + info->q) = 0.0;
  }
#line 294
  return;
}
}
#line 351
static void rcv_lbnd_col(NPP *npp , void *_info ) ;
#line 353 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_lbnd_col(NPP *npp , NPPCOL *col ) 
{ 
  struct bnd_col *info ;
  NPPROW *row ;
  NPPAIJ *aij ;
  NPPLFE *lfe ;
  int tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 360
  if (col->lb != - 1.7976931348623157e+308) {
#line 360
    tmp = 1;
  } else {
    {
#line 360
    _glp_lib_xassert("col->lb != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     360);
#line 360
    tmp = 1;
    }
  }
  {
#line 362
  tmp___0 = _glp_npp_push_tse(npp, & rcv_lbnd_col, (int )sizeof(struct bnd_col ));
#line 362
  info = (struct bnd_col *)tmp___0;
#line 364
  info->q = col->j;
#line 365
  info->b = col->lb;
#line 366
  info->ptr = (NPPLFE *)((void *)0);
#line 368
  npp->c0 += col->coef * col->lb;
#line 370
  aij = col->ptr;
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 370
      goto while_break;
    }
#line 371
    row = aij->row;
#line 372
    if (row->lb == row->ub) {
#line 373
      tmp___1 = row->lb - aij->val * col->lb;
#line 373
      row->lb = tmp___1;
#line 373
      row->ub = tmp___1;
    } else {
#line 375
      if (row->lb != - 1.7976931348623157e+308) {
#line 376
        row->lb -= aij->val * col->lb;
      }
#line 377
      if (row->ub != 1.7976931348623157e+308) {
#line 378
        row->ub -= aij->val * col->lb;
      }
    }
    {
#line 380
    tmp___2 = _glp_dmp_get_atom(npp->stack, (int )sizeof(NPPLFE ));
#line 380
    lfe = (NPPLFE *)tmp___2;
#line 381
    lfe->ref = row->i;
#line 382
    lfe->val = aij->val;
#line 383
    lfe->next = info->ptr;
#line 384
    info->ptr = lfe;
#line 370
    aij = aij->c_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  if (col->ub != 1.7976931348623157e+308) {
#line 388
    col->ub -= col->lb;
  }
#line 389
  col->lb = 0.0;
#line 390
  return;
}
}
#line 393 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_lbnd_col(NPP *npp , void *_info ) 
{ 
  struct bnd_col *info ;
  NPPLFE *lfe ;

  {
#line 395
  info = (struct bnd_col *)_info;
#line 397
  if (npp->sol == 1) {
#line 399
    *(npp->c_stat + info->q) = *(npp->c_stat + info->q);
  }
#line 402
  *(npp->c_prim + info->q) = info->b + *(npp->c_prim + info->q);
#line 404
  lfe = info->ptr;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 404
      goto while_break;
    }
#line 405
    *(npp->r_prim + lfe->ref) += lfe->val * info->b;
#line 404
    lfe = lfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  if (npp->sol != 3) {
#line 408
    *(npp->c_dual + info->q) = *(npp->c_dual + info->q);
  }
#line 409
  return;
}
}
#line 456
static void rcv_ubnd_col(NPP *npp , void *_info ) ;
#line 458 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_ubnd_col(NPP *npp , NPPCOL *col ) 
{ 
  struct bnd_col *info ;
  NPPROW *row ;
  NPPAIJ *aij ;
  NPPLFE *lfe ;
  int tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 465
  if (col->ub != 1.7976931348623157e+308) {
#line 465
    tmp = 1;
  } else {
    {
#line 465
    _glp_lib_xassert("col->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     465);
#line 465
    tmp = 1;
    }
  }
  {
#line 467
  tmp___0 = _glp_npp_push_tse(npp, & rcv_ubnd_col, (int )sizeof(struct bnd_col ));
#line 467
  info = (struct bnd_col *)tmp___0;
#line 469
  info->q = col->j;
#line 470
  info->b = col->ub;
#line 471
  info->ptr = (NPPLFE *)((void *)0);
#line 473
  npp->c0 += col->coef * col->ub;
#line 474
  col->coef = - col->coef;
#line 476
  aij = col->ptr;
  }
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 476
      goto while_break;
    }
#line 477
    row = aij->row;
#line 478
    if (row->lb == row->ub) {
#line 479
      tmp___1 = row->lb - aij->val * col->ub;
#line 479
      row->lb = tmp___1;
#line 479
      row->ub = tmp___1;
    } else {
#line 481
      if (row->lb != - 1.7976931348623157e+308) {
#line 482
        row->lb -= aij->val * col->ub;
      }
#line 483
      if (row->ub != 1.7976931348623157e+308) {
#line 484
        row->ub -= aij->val * col->ub;
      }
    }
    {
#line 486
    tmp___2 = _glp_dmp_get_atom(npp->stack, (int )sizeof(NPPLFE ));
#line 486
    lfe = (NPPLFE *)tmp___2;
#line 487
    lfe->ref = row->i;
#line 488
    lfe->val = aij->val;
#line 488
    aij->val = - aij->val;
#line 489
    lfe->next = info->ptr;
#line 490
    info->ptr = lfe;
#line 476
    aij = aij->c_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  if (col->lb != - 1.7976931348623157e+308) {
#line 494
    col->ub -= col->lb;
  } else {
#line 496
    col->ub = 1.7976931348623157e+308;
  }
#line 497
  col->lb = 0.0;
#line 498
  return;
}
}
#line 501 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_ubnd_col(NPP *npp , void *_info ) 
{ 
  struct bnd_col *info ;
  NPPLFE *lfe ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 503
  info = (struct bnd_col *)_info;
#line 505
  if (npp->sol == 1) {
#line 506
    if (! ((int )*(npp->c_stat + info->q) == 1)) {
#line 508
      if ((int )*(npp->c_stat + info->q) == 2) {
#line 509
        *(npp->c_stat + info->q) = (char)3;
      } else
#line 510
      if ((int )*(npp->c_stat + info->q) == 3) {
#line 511
        *(npp->c_stat + info->q) = (char)2;
      } else
#line 513
      if ((unsigned long )npp != (unsigned long )npp) {
#line 513
        tmp = 1;
      } else {
        {
#line 513
        _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                         513);
#line 513
        tmp = 1;
        }
      }
    }
  }
#line 516
  *(npp->c_prim + info->q) = info->b - *(npp->c_prim + info->q);
#line 518
  lfe = info->ptr;
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 518
      goto while_break;
    }
#line 519
    *(npp->r_prim + lfe->ref) += lfe->val * info->b;
#line 518
    lfe = lfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  if (npp->sol != 3) {
#line 522
    *(npp->c_dual + info->q) = - *(npp->c_dual + info->q);
  }
#line 523
  return;
}
}
#line 548
static void rcv_dbnd_col(NPP *npp , void *_info ) ;
#line 550 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_dbnd_col(NPP *npp , NPPCOL *col ) 
{ 
  struct dbnd_col *info ;
  NPPROW *row ;
  NPPCOL *ccc ;
  int tmp ;
  double tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 556
  if (col->lb == 0.0) {
#line 556
    if (col->ub != 1.7976931348623157e+308) {
#line 556
      tmp = 1;
    } else {
      {
#line 556
      _glp_lib_xassert("col->lb == 0.0 && col->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                       556);
#line 556
      tmp = 1;
      }
    }
  } else {
    {
#line 556
    _glp_lib_xassert("col->lb == 0.0 && col->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     556);
#line 556
    tmp = 1;
    }
  }
  {
#line 558
  ccc = _glp_npp_add_col(npp);
#line 559
  ccc->lb = 0.0;
#line 559
  ccc->ub = 1.7976931348623157e+308;
#line 561
  row = _glp_npp_add_row(npp);
#line 562
  tmp___0 = col->ub;
#line 562
  row->ub = tmp___0;
#line 562
  row->lb = tmp___0;
#line 563
  _glp_npp_add_aij(npp, row, col, 1.0);
#line 564
  _glp_npp_add_aij(npp, row, ccc, 1.0);
#line 566
  tmp___1 = _glp_npp_push_tse(npp, & rcv_dbnd_col, (int )sizeof(struct dbnd_col ));
#line 566
  info = (struct dbnd_col *)tmp___1;
#line 568
  info->q = col->j;
#line 569
  info->j = ccc->j;
#line 571
  col->ub = 1.7976931348623157e+308;
  }
#line 572
  return;
}
}
#line 575 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_dbnd_col(NPP *npp , void *_info ) 
{ 
  struct dbnd_col *info ;

  {
#line 576
  info = (struct dbnd_col *)_info;
#line 577
  if (npp->sol == 1) {
#line 579
    if ((int )*(npp->c_stat + info->q) == 2) {
#line 580
      *(npp->c_stat + info->q) = (char)2;
    } else
#line 581
    if ((int )*(npp->c_stat + info->j) == 2) {
#line 582
      *(npp->c_stat + info->q) = (char)3;
    } else {
#line 584
      *(npp->c_stat + info->q) = (char)1;
    }
  }
#line 588
  if (npp->sol != 3) {
#line 589
    *(npp->c_dual + info->q) -= *(npp->c_dual + info->j);
  }
#line 590
  return;
}
}
#line 654
static void rcv_fixed_col(NPP *npp , void *_info ) ;
#line 656 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
void _glp_npp_fixed_col(NPP *npp , NPPCOL *col ) 
{ 
  struct fixed_col *info ;
  NPPROW *row ;
  NPPAIJ *aij ;
  NPPLFE *lfe ;
  int tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 663
  if (col->lb == col->ub) {
#line 663
    tmp = 1;
  } else {
    {
#line 663
    _glp_lib_xassert("col->lb == col->ub", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     663);
#line 663
    tmp = 1;
    }
  }
  {
#line 665
  tmp___0 = _glp_npp_push_tse(npp, & rcv_fixed_col, (int )sizeof(struct fixed_col ));
#line 665
  info = (struct fixed_col *)tmp___0;
#line 667
  info->q = col->j;
#line 668
  info->s = col->lb;
#line 669
  info->c = col->coef;
#line 670
  info->ptr = (NPPLFE *)((void *)0);
#line 672
  npp->c0 += col->coef * col->lb;
#line 674
  aij = col->ptr;
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 674
      goto while_break;
    }
#line 675
    row = aij->row;
#line 676
    if (row->lb == row->ub) {
#line 677
      tmp___1 = row->lb - aij->val * col->lb;
#line 677
      row->lb = tmp___1;
#line 677
      row->ub = tmp___1;
    } else {
#line 679
      if (row->lb != - 1.7976931348623157e+308) {
#line 680
        row->lb -= aij->val * col->lb;
      }
#line 681
      if (row->ub != 1.7976931348623157e+308) {
#line 682
        row->ub -= aij->val * col->lb;
      }
    }
    {
#line 684
    tmp___2 = _glp_dmp_get_atom(npp->stack, (int )sizeof(NPPLFE ));
#line 684
    lfe = (NPPLFE *)tmp___2;
#line 685
    lfe->ref = (aij->row)->i;
#line 686
    lfe->val = aij->val;
#line 687
    lfe->next = info->ptr;
#line 688
    info->ptr = lfe;
#line 674
    aij = aij->c_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 691
  _glp_npp_del_col(npp, col);
  }
#line 692
  return;
}
}
#line 695 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_fixed_col(NPP *npp , void *_info ) 
{ 
  struct fixed_col *info ;
  NPPLFE *lfe ;
  double sum ;

  {
#line 697
  info = (struct fixed_col *)_info;
#line 700
  if (npp->sol == 1) {
#line 702
    *(npp->c_stat + info->q) = (char)5;
  }
#line 705
  *(npp->c_prim + info->q) = info->s;
#line 707
  lfe = info->ptr;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 707
      goto while_break;
    }
#line 708
    *(npp->r_prim + lfe->ref) += lfe->val * info->s;
#line 707
    lfe = lfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  if (npp->sol != 3) {
#line 711
    sum = info->c;
#line 712
    lfe = info->ptr;
    {
#line 712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 712
      if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 712
        goto while_break___0;
      }
#line 713
      sum -= lfe->val * *(npp->r_dual + lfe->ref);
#line 712
      lfe = lfe->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 714
    *(npp->c_dual + info->q) = sum;
  }
#line 716
  return;
}
}
#line 735
static void rcv_empty_row(NPP *npp , void *_info ) ;
#line 737 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
int _glp_npp_empty_row(NPP *npp , NPPROW *row ) 
{ 
  struct empty_row *info ;
  double eps ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 740
  eps = 1e-6;
#line 742
  if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
#line 742
    tmp = 1;
  } else {
    {
#line 742
    _glp_lib_xassert("row->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     742);
#line 742
    tmp = 1;
    }
  }
#line 744
  if (row->lb > eps) {
#line 745
    return (1);
  } else
#line 744
  if (row->ub < - eps) {
#line 745
    return (1);
  }
  {
#line 747
  tmp___0 = _glp_npp_push_tse(npp, & rcv_empty_row, (int )sizeof(struct empty_row ));
#line 747
  info = (struct empty_row *)tmp___0;
#line 749
  info->p = row->i;
#line 751
  _glp_npp_del_row(npp, row);
  }
#line 752
  return (0);
}
}
#line 755 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_empty_row(NPP *npp , void *_info ) 
{ 
  struct empty_row *info ;

  {
#line 757
  info = (struct empty_row *)_info;
#line 758
  if (npp->sol == 1) {
#line 760
    *(npp->r_stat + info->p) = (char)1;
  }
#line 763
  *(npp->r_prim + info->p) = 0.0;
#line 765
  if (npp->sol != 3) {
#line 766
    *(npp->r_dual + info->p) = 0.0;
  }
#line 767
  return;
}
}
#line 788
static void rcv_empty_col(NPP *npp , void *_info ) ;
#line 790 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
int _glp_npp_empty_col(NPP *npp , NPPCOL *col ) 
{ 
  struct empty_col *info ;
  double eps ;
  int tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 793
  eps = 1e-6;
#line 795
  if ((unsigned long )col->ptr == (unsigned long )((void *)0)) {
#line 795
    tmp = 1;
  } else {
    {
#line 795
    _glp_lib_xassert("col->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     795);
#line 795
    tmp = 1;
    }
  }
#line 797
  if (col->coef > eps) {
#line 797
    if (col->lb == - 1.7976931348623157e+308) {
#line 798
      return (1);
    }
  }
#line 799
  if (col->coef < - eps) {
#line 799
    if (col->ub == 1.7976931348623157e+308) {
#line 800
      return (1);
    }
  }
  {
#line 802
  tmp___0 = _glp_npp_push_tse(npp, & rcv_empty_col, (int )sizeof(struct empty_col ));
#line 802
  info = (struct empty_col *)tmp___0;
#line 804
  info->q = col->j;
  }
#line 806
  if (col->lb == - 1.7976931348623157e+308) {
#line 806
    if (col->ub == 1.7976931348623157e+308) {
#line 808
      info->stat = 5;
#line 809
      tmp___1 = 0.0;
#line 809
      col->ub = tmp___1;
#line 809
      col->lb = tmp___1;
    } else {
#line 806
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 811
  if (col->ub == 1.7976931348623157e+308) {
    lo: 
#line 813
    info->stat = 2;
#line 814
    col->ub = col->lb;
  } else
#line 816
  if (col->lb == - 1.7976931348623157e+308) {
    up: 
#line 818
    info->stat = 3;
#line 819
    col->lb = col->ub;
  } else
#line 821
  if (col->lb != col->ub) {
#line 823
    if (col->coef > 0.0) {
#line 823
      goto lo;
    }
#line 824
    if (col->coef < 0.0) {
#line 824
      goto up;
    }
    {
#line 825
    tmp___2 = fabs(col->lb);
#line 825
    tmp___3 = fabs(col->ub);
    }
#line 825
    if (tmp___2 <= tmp___3) {
#line 825
      goto lo;
    } else {
#line 825
      goto up;
    }
  } else {
#line 829
    info->stat = 5;
  }
  {
#line 832
  _glp_npp_fixed_col(npp, col);
  }
#line 833
  return (0);
}
}
#line 836 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_empty_col(NPP *npp , void *_info ) 
{ 
  struct empty_col *info ;

  {
#line 838
  info = (struct empty_col *)_info;
#line 839
  if (npp->sol == 1) {
#line 840
    *(npp->c_stat + info->q) = (char )info->stat;
  }
#line 841
  return;
}
}
#line 882
static void rcv_sngl_row(NPP *npp , void *_info ) ;
#line 884 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
int _glp_npp_sngl_row(NPP *npp , NPPROW *row ) 
{ 
  struct sngl_row *info ;
  NPPCOL *col ;
  NPPAIJ *aij ;
  double val ;
  double eps ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  double tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 891
  if (row->lb == row->ub) {
#line 891
    tmp = 1;
  } else {
    {
#line 891
    _glp_lib_xassert("row->lb == row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     891);
#line 891
    tmp = 1;
    }
  }
#line 892
  if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 892
    if ((unsigned long )(row->ptr)->r_next == (unsigned long )((void *)0)) {
#line 892
      tmp___0 = 1;
    } else {
      {
#line 892
      _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                       892);
#line 892
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 892
    _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                     892);
#line 892
    tmp___0 = 1;
    }
  }
#line 894
  aij = row->ptr;
#line 895
  val = row->lb / aij->val;
#line 897
  col = aij->col;
#line 898
  if (col->lb != - 1.7976931348623157e+308) {
    {
#line 899
    tmp___1 = fabs(col->lb);
#line 899
    eps = 1e-6 + 1e-9 * tmp___1;
    }
#line 900
    if (val < col->lb - eps) {
#line 900
      return (1);
    }
  }
#line 902
  if (col->ub != 1.7976931348623157e+308) {
    {
#line 903
    tmp___2 = fabs(col->ub);
#line 903
    eps = 1e-6 + 1e-9 * tmp___2;
    }
#line 904
    if (val > col->ub + eps) {
#line 904
      return (1);
    }
  }
#line 907
  if (npp->sol == 3) {
#line 907
    if (col->kind == 2) {
#line 908
      if ((unsigned long )npp != (unsigned long )npp) {
#line 908
        tmp___3 = 1;
      } else {
        {
#line 908
        _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                         908);
#line 908
        tmp___3 = 1;
        }
      }
    }
  }
  {
#line 910
  tmp___4 = _glp_npp_push_tse(npp, & rcv_sngl_row, (int )sizeof(struct sngl_row ));
#line 910
  info = (struct sngl_row *)tmp___4;
#line 912
  info->p = row->i;
#line 913
  info->q = col->j;
#line 914
  info->apq = aij->val;
#line 916
  _glp_npp_del_row(npp, row);
#line 918
  tmp___5 = val;
#line 918
  col->ub = tmp___5;
#line 918
  col->lb = tmp___5;
#line 919
  _glp_npp_fixed_col(npp, col);
  }
#line 920
  return (0);
}
}
#line 923 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c"
static void rcv_sngl_row(NPP *npp , void *_info ) 
{ 
  struct sngl_row *info ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 925
  info = (struct sngl_row *)_info;
#line 927
  if (npp->sol == 1) {
#line 928
    if ((int )*(npp->c_stat + info->q) == 5) {
#line 928
      tmp = 1;
    } else {
      {
#line 928
      _glp_lib_xassert("npp->c_stat[info->q] == GLP_NS", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp02.c",
                       928);
#line 928
      tmp = 1;
      }
    }
#line 929
    *(npp->r_stat + info->p) = (char)5;
#line 930
    *(npp->c_stat + info->q) = (char)1;
  }
#line 933
  *(npp->r_prim + info->p) = info->apq * *(npp->c_prim + info->q);
#line 935
  if (npp->sol != 3) {
#line 936
    *(npp->r_dual + info->p) = *(npp->c_dual + info->q) / info->apq;
#line 937
    *(npp->c_dual + info->q) = 0.0;
  }
#line 939
  return;
}
}
#line 185 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 285 "./../include/glpk.h"
void glp_set_prob_name(glp_prob *lp , char const   *name ) ;
#line 288
void glp_set_obj_name(glp_prob *lp , char const   *name ) ;
#line 291
void glp_set_obj_dir(glp_prob *lp , int dir ) ;
#line 294
int glp_add_rows(glp_prob *lp , int nrs ) ;
#line 297
int glp_add_cols(glp_prob *lp , int ncs ) ;
#line 300
void glp_set_row_name(glp_prob *lp , int i , char const   *name ) ;
#line 303
void glp_set_col_name(glp_prob *lp , int j , char const   *name ) ;
#line 306
void glp_set_row_bnds(glp_prob *lp , int i , int type , double lb , double ub ) ;
#line 310
void glp_set_col_bnds(glp_prob *lp , int j , int type , double lb , double ub ) ;
#line 314
void glp_set_obj_coef(glp_prob *lp , int j , double coef ) ;
#line 321
void glp_set_mat_col(glp_prob *lp , int j , int len , int const   *ind , double const   *val ) ;
#line 338
void glp_erase_prob(glp_prob *lp ) ;
#line 506
void glp_set_col_kind(glp_prob *mip , int j , int kind ) ;
#line 242 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp.h"
NPP *_glp_npp_create_wksp(void) ;
#line 271
void _glp_npp_load_prob(NPP *npp , glp_prob *orig , int names , int sol , int scaling ) ;
#line 276
void _glp_npp_build_prob(NPP *npp , glp_prob *prob ) ;
#line 280
void _glp_npp_postprocess(NPP *npp , glp_prob *prob ) ;
#line 284
void _glp_npp_unload_sol(NPP *npp , glp_prob *orig ) ;
#line 288
void _glp_npp_delete_wksp(NPP *npp ) ;
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
NPP *_glp_npp_create_wksp(void) 
{ 
  NPP *npp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  NPPROW *tmp___4 ;
  NPPCOL *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double *tmp___13 ;
  double *tmp___14 ;

  {
  {
#line 29
  tmp = _glp_lib_xmalloc((int )sizeof(NPP ));
#line 29
  npp = (NPP *)tmp;
#line 30
  npp->orig_dir = 0;
#line 31
  tmp___1 = 0;
#line 31
  npp->orig_nnz = tmp___1;
#line 31
  tmp___0 = tmp___1;
#line 31
  npp->orig_n = tmp___0;
#line 31
  npp->orig_m = tmp___0;
#line 32
  npp->pool = _glp_dmp_create_pool();
#line 33
  tmp___2 = (char *)((void *)0);
#line 33
  npp->obj = tmp___2;
#line 33
  npp->name = tmp___2;
#line 34
  npp->c0 = 0.0;
#line 35
  tmp___3 = 0;
#line 35
  npp->ncols = tmp___3;
#line 35
  npp->nrows = tmp___3;
#line 36
  tmp___4 = (NPPROW *)((void *)0);
#line 36
  npp->r_tail = tmp___4;
#line 36
  npp->r_head = tmp___4;
#line 37
  tmp___5 = (NPPCOL *)((void *)0);
#line 37
  npp->c_tail = tmp___5;
#line 37
  npp->c_head = tmp___5;
#line 38
  npp->stack = _glp_dmp_create_pool();
#line 39
  npp->top = (NPPTSE *)((void *)0);
#line 40
  tmp___7 = 0;
#line 40
  npp->nnz = tmp___7;
#line 40
  tmp___6 = tmp___7;
#line 40
  npp->n = tmp___6;
#line 40
  npp->m = tmp___6;
#line 41
  tmp___8 = (int *)((void *)0);
#line 41
  npp->col_ref = tmp___8;
#line 41
  npp->row_ref = tmp___8;
#line 42
  tmp___9 = 0;
#line 42
  npp->scaling = tmp___9;
#line 42
  npp->sol = tmp___9;
#line 43
  tmp___12 = 0;
#line 43
  npp->i_stat = tmp___12;
#line 43
  tmp___11 = tmp___12;
#line 43
  npp->t_stat = tmp___11;
#line 43
  tmp___10 = tmp___11;
#line 43
  npp->d_stat = tmp___10;
#line 43
  npp->p_stat = tmp___10;
#line 44
  npp->r_stat = (char *)((void *)0);
#line 45
  tmp___13 = (double *)((void *)0);
#line 45
  npp->r_dual = tmp___13;
#line 45
  npp->r_prim = tmp___13;
#line 46
  npp->c_stat = (char *)((void *)0);
#line 47
  tmp___14 = (double *)((void *)0);
#line 47
  npp->c_dual = tmp___14;
#line 47
  npp->c_prim = tmp___14;
  }
#line 48
  return (npp);
}
}
#line 51 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
NPPROW *_glp_npp_add_row(NPP *npp ) 
{ 
  NPPROW *row ;
  void *tmp ;

  {
  {
#line 54
  tmp = _glp_dmp_get_atom(npp->pool, (int )sizeof(NPPROW ));
#line 54
  row = (NPPROW *)tmp;
#line 55
  (npp->nrows) ++;
#line 55
  row->i = npp->nrows;
#line 56
  row->name = (char *)((void *)0);
#line 57
  row->lb = - 1.7976931348623157e+308;
#line 57
  row->ub = 1.7976931348623157e+308;
#line 58
  row->ptr = (NPPAIJ *)((void *)0);
#line 59
  row->temp = 0;
#line 60
  row->prev = npp->r_tail;
#line 61
  row->next = (NPPROW *)((void *)0);
  }
#line 62
  if ((unsigned long )row->prev == (unsigned long )((void *)0)) {
#line 63
    npp->r_head = row;
  } else {
#line 65
    (row->prev)->next = row;
  }
#line 66
  npp->r_tail = row;
#line 67
  return (row);
}
}
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
NPPCOL *_glp_npp_add_col(NPP *npp ) 
{ 
  NPPCOL *col ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 73
  tmp = _glp_dmp_get_atom(npp->pool, (int )sizeof(NPPCOL ));
#line 73
  col = (NPPCOL *)tmp;
#line 74
  (npp->ncols) ++;
#line 74
  col->j = npp->ncols;
#line 75
  col->name = (char *)((void *)0);
#line 76
  col->kind = 1;
#line 77
  tmp___1 = 0.0;
#line 77
  col->coef = tmp___1;
#line 77
  tmp___0 = tmp___1;
#line 77
  col->ub = tmp___0;
#line 77
  col->lb = tmp___0;
#line 78
  col->ptr = (NPPAIJ *)((void *)0);
#line 79
  col->prev = npp->c_tail;
#line 80
  col->next = (NPPCOL *)((void *)0);
  }
#line 81
  if ((unsigned long )col->prev == (unsigned long )((void *)0)) {
#line 82
    npp->c_head = col;
  } else {
#line 84
    (col->prev)->next = col;
  }
#line 85
  npp->c_tail = col;
#line 86
  return (col);
}
}
#line 89 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
NPPAIJ *_glp_npp_add_aij(NPP *npp , NPPROW *row , NPPCOL *col , double val ) 
{ 
  NPPAIJ *aij ;
  void *tmp ;
  NPPAIJ *tmp___0 ;

  {
  {
#line 92
  tmp = _glp_dmp_get_atom(npp->pool, (int )sizeof(NPPAIJ ));
#line 92
  aij = (NPPAIJ *)tmp;
#line 93
  aij->row = row;
#line 94
  aij->col = col;
#line 95
  aij->val = val;
#line 96
  aij->r_prev = (NPPAIJ *)((void *)0);
#line 97
  aij->r_next = row->ptr;
#line 98
  aij->c_prev = (NPPAIJ *)((void *)0);
#line 99
  aij->c_next = col->ptr;
  }
#line 100
  if ((unsigned long )aij->r_next != (unsigned long )((void *)0)) {
#line 101
    (aij->r_next)->r_prev = aij;
  }
#line 102
  if ((unsigned long )aij->c_next != (unsigned long )((void *)0)) {
#line 103
    (aij->c_next)->c_prev = aij;
  }
#line 104
  tmp___0 = aij;
#line 104
  col->ptr = tmp___0;
#line 104
  row->ptr = tmp___0;
#line 105
  return (aij);
}
}
#line 108 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void *_glp_npp_push_tse(NPP *npp , void (*func___0)(NPP *npp , void *info ) , int size ) 
{ 
  NPPTSE *tse ;
  void *tmp ;

  {
  {
#line 112
  tmp = _glp_dmp_get_atom(npp->stack, (int )sizeof(NPPTSE ));
#line 112
  tse = (NPPTSE *)tmp;
#line 113
  tse->func = func___0;
#line 114
  tse->info = _glp_dmp_get_atom(npp->stack, size);
#line 115
  tse->link = npp->top;
#line 116
  npp->top = tse;
  }
#line 117
  return (tse->info);
}
}
#line 120 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void _glp_npp_del_row(NPP *npp , NPPROW *row ) 
{ 
  NPPAIJ *aij ;
  size_t tmp ;

  {
#line 123
  if ((unsigned long )row->name != (unsigned long )((void *)0)) {
    {
#line 124
    tmp = strlen((char const   *)row->name);
#line 124
    _glp_dmp_free_atom(npp->pool, (void *)row->name, (int )(tmp + 1U));
    }
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )row->ptr != (unsigned long )((void *)0))) {
#line 125
      goto while_break;
    }
#line 126
    aij = row->ptr;
#line 127
    row->ptr = aij->r_next;
#line 128
    if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 129
      (aij->col)->ptr = aij->c_next;
    } else {
#line 131
      (aij->c_prev)->c_next = aij->c_next;
    }
#line 132
    if (! ((unsigned long )aij->c_next == (unsigned long )((void *)0))) {
#line 135
      (aij->c_next)->c_prev = aij->c_prev;
    }
    {
#line 136
    _glp_dmp_free_atom(npp->pool, (void *)aij, (int )sizeof(NPPAIJ ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if ((unsigned long )row->prev == (unsigned long )((void *)0)) {
#line 139
    npp->r_head = row->next;
  } else {
#line 141
    (row->prev)->next = row->next;
  }
#line 142
  if ((unsigned long )row->next == (unsigned long )((void *)0)) {
#line 143
    npp->r_tail = row->prev;
  } else {
#line 145
    (row->next)->prev = row->prev;
  }
  {
#line 146
  _glp_dmp_free_atom(npp->pool, (void *)row, (int )sizeof(NPPROW ));
  }
#line 147
  return;
}
}
#line 150 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void _glp_npp_del_col(NPP *npp , NPPCOL *col ) 
{ 
  NPPAIJ *aij ;
  size_t tmp ;

  {
#line 153
  if ((unsigned long )col->name != (unsigned long )((void *)0)) {
    {
#line 154
    tmp = strlen((char const   *)col->name);
#line 154
    _glp_dmp_free_atom(npp->pool, (void *)col->name, (int )(tmp + 1U));
    }
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((unsigned long )col->ptr != (unsigned long )((void *)0))) {
#line 155
      goto while_break;
    }
#line 156
    aij = col->ptr;
#line 157
    col->ptr = aij->c_next;
#line 158
    if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 159
      (aij->row)->ptr = aij->r_next;
    } else {
#line 161
      (aij->r_prev)->r_next = aij->r_next;
    }
#line 162
    if (! ((unsigned long )aij->r_next == (unsigned long )((void *)0))) {
#line 165
      (aij->r_next)->r_prev = aij->r_prev;
    }
    {
#line 166
    _glp_dmp_free_atom(npp->pool, (void *)aij, (int )sizeof(NPPAIJ ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if ((unsigned long )col->prev == (unsigned long )((void *)0)) {
#line 169
    npp->c_head = col->next;
  } else {
#line 171
    (col->prev)->next = col->next;
  }
#line 172
  if ((unsigned long )col->next == (unsigned long )((void *)0)) {
#line 173
    npp->c_tail = col->prev;
  } else {
#line 175
    (col->next)->prev = col->prev;
  }
  {
#line 176
  _glp_dmp_free_atom(npp->pool, (void *)col, (int )sizeof(NPPCOL ));
  }
#line 177
  return;
}
}
#line 180 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void _glp_npp_load_prob(NPP *npp , glp_prob *orig , int names , int sol , int scaling ) 
{ 
  int m ;
  int n ;
  NPPROW **link ;
  int i ;
  int j ;
  double dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  GLPROW *rrr ;
  NPPROW *row ;
  int tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  double rii ;
  double tmp___14 ;
  int tmp___15 ;
  GLPCOL *ccc ;
  GLPAIJ *aaa ;
  NPPCOL *col ;
  int tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;
  double tmp___19 ;
  int tmp___20 ;
  double sjj ;
  double tmp___21 ;
  int tmp___22 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 183
  m = orig->m;
#line 184
  n = orig->n;
#line 188
  if (names == 0) {
#line 188
    tmp = 1;
  } else
#line 188
  if (names == 1) {
#line 188
    tmp = 1;
  } else {
    {
#line 188
    _glp_lib_xassert("names == GLP_OFF || names == GLP_ON", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     188);
#line 188
    tmp = 1;
    }
  }
#line 189
  if (sol == 1) {
#line 189
    tmp___0 = 1;
  } else
#line 189
  if (sol == 2) {
#line 189
    tmp___0 = 1;
  } else
#line 189
  if (sol == 3) {
#line 189
    tmp___0 = 1;
  } else {
    {
#line 189
    _glp_lib_xassert("sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     189);
#line 189
    tmp___0 = 1;
    }
  }
#line 190
  if (scaling == 0) {
#line 190
    tmp___1 = 1;
  } else
#line 190
  if (scaling == 1) {
#line 190
    tmp___1 = 1;
  } else {
    {
#line 190
    _glp_lib_xassert("scaling == GLP_OFF || scaling == GLP_ON", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     190);
#line 190
    tmp___1 = 1;
    }
  }
#line 191
  if (sol == 3) {
#line 191
    if (! scaling) {
#line 191
      tmp___2 = 1;
    } else {
      {
#line 191
      _glp_lib_xassert("!scaling", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                       191);
#line 191
      tmp___2 = 1;
      }
    }
  }
#line 192
  npp->orig_dir = orig->dir;
#line 193
  if (npp->orig_dir == 1) {
#line 194
    dir = 1.0;
  } else
#line 195
  if (npp->orig_dir == 2) {
#line 196
    dir = - 1.0;
  } else
#line 198
  if ((unsigned long )npp != (unsigned long )npp) {
#line 198
    tmp___3 = 1;
  } else {
    {
#line 198
    _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     198);
#line 198
    tmp___3 = 1;
    }
  }
#line 199
  npp->orig_m = m;
#line 200
  npp->orig_n = n;
#line 201
  npp->orig_nnz = orig->nnz;
#line 202
  if (names) {
#line 202
    if ((unsigned long )orig->name != (unsigned long )((void *)0)) {
      {
#line 203
      tmp___4 = strlen((char const   *)orig->name);
#line 203
      tmp___5 = _glp_dmp_get_atom(npp->pool, (int )(tmp___4 + 1U));
#line 203
      npp->name = (char *)tmp___5;
#line 204
      strcpy((char */* __restrict  */)npp->name, (char const   */* __restrict  */)orig->name);
      }
    }
  }
#line 206
  if (names) {
#line 206
    if ((unsigned long )orig->obj != (unsigned long )((void *)0)) {
      {
#line 207
      tmp___6 = strlen((char const   *)orig->obj);
#line 207
      tmp___7 = _glp_dmp_get_atom(npp->pool, (int )(tmp___6 + 1U));
#line 207
      npp->obj = (char *)tmp___7;
#line 208
      strcpy((char */* __restrict  */)npp->obj, (char const   */* __restrict  */)orig->obj);
      }
    }
  }
  {
#line 210
  npp->c0 = dir * orig->c0;
#line 212
  tmp___8 = _glp_lib_xcalloc(1 + m, (int )sizeof(NPPROW *));
#line 212
  link = (NPPROW **)tmp___8;
#line 213
  i = 1;
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i <= m)) {
#line 213
      goto while_break;
    }
    {
#line 214
    rrr = *(orig->row + i);
#line 216
    row = _glp_npp_add_row(npp);
#line 216
    *(link + i) = row;
    }
#line 217
    if (row->i == i) {
#line 217
      tmp___9 = 1;
    } else {
      {
#line 217
      _glp_lib_xassert("row->i == i", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                       217);
#line 217
      tmp___9 = 1;
      }
    }
#line 218
    if (names) {
#line 218
      if ((unsigned long )rrr->name != (unsigned long )((void *)0)) {
        {
#line 219
        tmp___10 = strlen((char const   *)rrr->name);
#line 219
        tmp___11 = _glp_dmp_get_atom(npp->pool, (int )(tmp___10 + 1U));
#line 219
        row->name = (char *)tmp___11;
#line 220
        strcpy((char */* __restrict  */)row->name, (char const   */* __restrict  */)rrr->name);
        }
      }
    }
#line 222
    if (! scaling) {
#line 223
      if (rrr->type == 1) {
#line 224
        row->lb = - 1.7976931348623157e+308;
#line 224
        row->ub = 1.7976931348623157e+308;
      } else
#line 225
      if (rrr->type == 2) {
#line 226
        row->lb = rrr->lb;
#line 226
        row->ub = 1.7976931348623157e+308;
      } else
#line 227
      if (rrr->type == 3) {
#line 228
        row->lb = - 1.7976931348623157e+308;
#line 228
        row->ub = rrr->ub;
      } else
#line 229
      if (rrr->type == 4) {
#line 230
        row->lb = rrr->lb;
#line 230
        row->ub = rrr->ub;
      } else
#line 231
      if (rrr->type == 5) {
#line 232
        tmp___12 = rrr->lb;
#line 232
        row->ub = tmp___12;
#line 232
        row->lb = tmp___12;
      } else
#line 234
      if ((unsigned long )rrr != (unsigned long )rrr) {
#line 234
        tmp___13 = 1;
      } else {
        {
#line 234
        _glp_lib_xassert("rrr != rrr", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                         234);
#line 234
        tmp___13 = 1;
        }
      }
    } else {
#line 237
      rii = rrr->rii;
#line 238
      if (rrr->type == 1) {
#line 239
        row->lb = - 1.7976931348623157e+308;
#line 239
        row->ub = 1.7976931348623157e+308;
      } else
#line 240
      if (rrr->type == 2) {
#line 241
        row->lb = rrr->lb * rii;
#line 241
        row->ub = 1.7976931348623157e+308;
      } else
#line 242
      if (rrr->type == 3) {
#line 243
        row->lb = - 1.7976931348623157e+308;
#line 243
        row->ub = rrr->ub * rii;
      } else
#line 244
      if (rrr->type == 4) {
#line 245
        row->lb = rrr->lb * rii;
#line 245
        row->ub = rrr->ub * rii;
      } else
#line 246
      if (rrr->type == 5) {
#line 247
        tmp___14 = rrr->lb * rii;
#line 247
        row->ub = tmp___14;
#line 247
        row->lb = tmp___14;
      } else
#line 249
      if ((unsigned long )rrr != (unsigned long )rrr) {
#line 249
        tmp___15 = 1;
      } else {
        {
#line 249
        _glp_lib_xassert("rrr != rrr", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                         249);
#line 249
        tmp___15 = 1;
        }
      }
    }
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  j = 1;
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (! (j <= n)) {
#line 253
      goto while_break___0;
    }
    {
#line 254
    ccc = *(orig->col + j);
#line 257
    col = _glp_npp_add_col(npp);
    }
#line 258
    if (col->j == j) {
#line 258
      tmp___16 = 1;
    } else {
      {
#line 258
      _glp_lib_xassert("col->j == j", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                       258);
#line 258
      tmp___16 = 1;
      }
    }
#line 259
    if (names) {
#line 259
      if ((unsigned long )ccc->name != (unsigned long )((void *)0)) {
        {
#line 260
        tmp___17 = strlen((char const   *)ccc->name);
#line 260
        tmp___18 = _glp_dmp_get_atom(npp->pool, (int )(tmp___17 + 1U));
#line 260
        col->name = (char *)tmp___18;
#line 261
        strcpy((char */* __restrict  */)col->name, (char const   */* __restrict  */)ccc->name);
        }
      }
    }
#line 263
    if (sol == 3) {
#line 264
      col->kind = ccc->kind;
    }
#line 265
    if (! scaling) {
#line 266
      if (ccc->type == 1) {
#line 267
        col->lb = - 1.7976931348623157e+308;
#line 267
        col->ub = 1.7976931348623157e+308;
      } else
#line 268
      if (ccc->type == 2) {
#line 269
        col->lb = ccc->lb;
#line 269
        col->ub = 1.7976931348623157e+308;
      } else
#line 270
      if (ccc->type == 3) {
#line 271
        col->lb = - 1.7976931348623157e+308;
#line 271
        col->ub = ccc->ub;
      } else
#line 272
      if (ccc->type == 4) {
#line 273
        col->lb = ccc->lb;
#line 273
        col->ub = ccc->ub;
      } else
#line 274
      if (ccc->type == 5) {
#line 275
        tmp___19 = ccc->lb;
#line 275
        col->ub = tmp___19;
#line 275
        col->lb = tmp___19;
      } else
#line 277
      if ((unsigned long )ccc != (unsigned long )ccc) {
#line 277
        tmp___20 = 1;
      } else {
        {
#line 277
        _glp_lib_xassert("ccc != ccc", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                         277);
#line 277
        tmp___20 = 1;
        }
      }
#line 278
      col->coef = dir * ccc->coef;
#line 279
      aaa = ccc->ptr;
      {
#line 279
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 279
        if (! ((unsigned long )aaa != (unsigned long )((void *)0))) {
#line 279
          goto while_break___1;
        }
        {
#line 280
        _glp_npp_add_aij(npp, *(link + (aaa->row)->i), col, aaa->val);
#line 279
        aaa = aaa->c_next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 283
      sjj = ccc->sjj;
#line 284
      if (ccc->type == 1) {
#line 285
        col->lb = - 1.7976931348623157e+308;
#line 285
        col->ub = 1.7976931348623157e+308;
      } else
#line 286
      if (ccc->type == 2) {
#line 287
        col->lb = ccc->lb / sjj;
#line 287
        col->ub = 1.7976931348623157e+308;
      } else
#line 288
      if (ccc->type == 3) {
#line 289
        col->lb = - 1.7976931348623157e+308;
#line 289
        col->ub = ccc->ub / sjj;
      } else
#line 290
      if (ccc->type == 4) {
#line 291
        col->lb = ccc->lb / sjj;
#line 291
        col->ub = ccc->ub / sjj;
      } else
#line 292
      if (ccc->type == 5) {
#line 293
        tmp___21 = ccc->lb / sjj;
#line 293
        col->ub = tmp___21;
#line 293
        col->lb = tmp___21;
      } else
#line 295
      if ((unsigned long )ccc != (unsigned long )ccc) {
#line 295
        tmp___22 = 1;
      } else {
        {
#line 295
        _glp_lib_xassert("ccc != ccc", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                         295);
#line 295
        tmp___22 = 1;
        }
      }
#line 296
      col->coef = (dir * ccc->coef) * sjj;
#line 297
      aaa = ccc->ptr;
      {
#line 297
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 297
        if (! ((unsigned long )aaa != (unsigned long )((void *)0))) {
#line 297
          goto while_break___2;
        }
        {
#line 298
        _glp_npp_add_aij(npp, *(link + (aaa->row)->i), col, ((aaa->row)->rii * aaa->val) * sjj);
#line 297
        aaa = aaa->c_next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 253
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 302
  _glp_lib_xfree((void *)link);
#line 304
  npp->sol = sol;
#line 305
  npp->scaling = scaling;
  }
#line 306
  return;
}
}
#line 309 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void _glp_npp_build_prob(NPP *npp , glp_prob *prob ) 
{ 
  NPPROW *row ;
  NPPCOL *col ;
  NPPAIJ *aij ;
  int i ;
  int j ;
  int type ;
  int len ;
  int *ind ;
  double dir ;
  double *val ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  NPPROW *tmp___5 ;
  NPPCOL *tmp___6 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 316
  glp_erase_prob(prob);
#line 317
  glp_set_prob_name(prob, (char const   *)npp->name);
#line 318
  glp_set_obj_name(prob, (char const   *)npp->obj);
#line 319
  glp_set_obj_dir(prob, npp->orig_dir);
  }
#line 320
  if (npp->orig_dir == 1) {
#line 321
    dir = 1.0;
  } else
#line 322
  if (npp->orig_dir == 2) {
#line 323
    dir = - 1.0;
  } else
#line 325
  if ((unsigned long )npp != (unsigned long )npp) {
#line 325
    tmp = 1;
  } else {
    {
#line 325
    _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     325);
#line 325
    tmp = 1;
    }
  }
  {
#line 326
  glp_set_obj_coef(prob, 0, dir * npp->c0);
#line 328
  row = npp->r_head;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 328
      goto while_break;
    }
    {
#line 329
    i = glp_add_rows(prob, 1);
#line 329
    row->temp = i;
#line 330
    glp_set_row_name(prob, i, (char const   *)row->name);
    }
#line 331
    if (row->lb == - 1.7976931348623157e+308) {
#line 331
      if (row->ub == 1.7976931348623157e+308) {
#line 332
        type = 1;
      } else {
#line 331
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 333
    if (row->ub == 1.7976931348623157e+308) {
#line 334
      type = 2;
    } else
#line 335
    if (row->lb == - 1.7976931348623157e+308) {
#line 336
      type = 3;
    } else
#line 337
    if (row->lb != row->ub) {
#line 338
      type = 4;
    } else {
#line 340
      type = 5;
    }
    {
#line 341
    glp_set_row_bnds(prob, i, type, row->lb, row->ub);
#line 328
    row = row->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  tmp___0 = _glp_lib_xcalloc(1 + prob->m, (int )sizeof(int ));
#line 344
  ind = (int *)tmp___0;
#line 345
  tmp___1 = _glp_lib_xcalloc(1 + prob->m, (int )sizeof(double ));
#line 345
  val = (double *)tmp___1;
#line 346
  col = npp->c_head;
  }
  {
#line 346
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 346
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 346
      goto while_break___0;
    }
    {
#line 347
    j = glp_add_cols(prob, 1);
#line 348
    glp_set_col_name(prob, j, (char const   *)col->name);
#line 349
    glp_set_col_kind(prob, j, col->kind);
    }
#line 350
    if (col->lb == - 1.7976931348623157e+308) {
#line 350
      if (col->ub == 1.7976931348623157e+308) {
#line 351
        type = 1;
      } else {
#line 350
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 352
    if (col->ub == 1.7976931348623157e+308) {
#line 353
      type = 2;
    } else
#line 354
    if (col->lb == - 1.7976931348623157e+308) {
#line 355
      type = 3;
    } else
#line 356
    if (col->lb != col->ub) {
#line 357
      type = 4;
    } else {
#line 359
      type = 5;
    }
    {
#line 360
    glp_set_col_bnds(prob, j, type, col->lb, col->ub);
#line 361
    glp_set_obj_coef(prob, j, dir * col->coef);
#line 362
    len = 0;
#line 363
    aij = col->ptr;
    }
    {
#line 363
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 363
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 363
        goto while_break___1;
      }
#line 364
      len ++;
#line 365
      *(ind + len) = (aij->row)->temp;
#line 366
      *(val + len) = aij->val;
#line 363
      aij = aij->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 368
    glp_set_mat_col(prob, j, len, (int const   *)ind, (double const   *)val);
#line 346
    col = col->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 370
  _glp_lib_xfree((void *)ind);
#line 371
  _glp_lib_xfree((void *)val);
#line 373
  npp->m = prob->m;
#line 374
  npp->n = prob->n;
#line 375
  npp->nnz = prob->nnz;
#line 376
  tmp___2 = _glp_lib_xcalloc(1 + npp->m, (int )sizeof(int ));
#line 376
  npp->row_ref = (int *)tmp___2;
#line 377
  tmp___3 = _glp_lib_xcalloc(1 + npp->n, (int )sizeof(int ));
#line 377
  npp->col_ref = (int *)tmp___3;
#line 378
  row = npp->r_head;
#line 378
  i = 0;
  }
  {
#line 378
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 378
      goto while_break___2;
    }
#line 379
    i ++;
#line 379
    *(npp->row_ref + i) = row->i;
#line 378
    row = row->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 380
  col = npp->c_head;
#line 380
  j = 0;
  {
#line 380
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 380
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 380
      goto while_break___3;
    }
#line 381
    j ++;
#line 381
    *(npp->col_ref + j) = col->j;
#line 380
    col = col->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 383
  _glp_dmp_delete_pool(npp->pool);
#line 383
  npp->pool = (DMP *)((void *)0);
#line 384
  tmp___4 = (char *)((void *)0);
#line 384
  npp->obj = tmp___4;
#line 384
  npp->name = tmp___4;
#line 385
  npp->c0 = 0.0;
#line 386
  tmp___5 = (NPPROW *)((void *)0);
#line 386
  npp->r_tail = tmp___5;
#line 386
  npp->r_head = tmp___5;
#line 387
  tmp___6 = (NPPCOL *)((void *)0);
#line 387
  npp->c_tail = tmp___6;
#line 387
  npp->c_head = tmp___6;
  }
#line 388
  return;
}
}
#line 391 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void _glp_npp_postprocess(NPP *npp , glp_prob *prob ) 
{ 
  GLPROW *row ;
  GLPCOL *col ;
  NPPTSE *tse ;
  int i ;
  int j ;
  int k ;
  double dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 398
  if (npp->orig_dir == prob->dir) {
#line 398
    tmp = 1;
  } else {
    {
#line 398
    _glp_lib_xassert("npp->orig_dir == prob->dir", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     398);
#line 398
    tmp = 1;
    }
  }
#line 399
  if (npp->orig_dir == 1) {
#line 400
    dir = 1.0;
  } else
#line 401
  if (npp->orig_dir == 2) {
#line 402
    dir = - 1.0;
  } else
#line 404
  if ((unsigned long )npp != (unsigned long )npp) {
#line 404
    tmp___0 = 1;
  } else {
    {
#line 404
    _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     404);
#line 404
    tmp___0 = 1;
    }
  }
#line 405
  if (npp->m == prob->m) {
#line 405
    tmp___1 = 1;
  } else {
    {
#line 405
    _glp_lib_xassert("npp->m == prob->m", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     405);
#line 405
    tmp___1 = 1;
    }
  }
#line 406
  if (npp->n == prob->n) {
#line 406
    tmp___2 = 1;
  } else {
    {
#line 406
    _glp_lib_xassert("npp->n == prob->n", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     406);
#line 406
    tmp___2 = 1;
    }
  }
#line 407
  if (npp->nnz == prob->nnz) {
#line 407
    tmp___3 = 1;
  } else {
    {
#line 407
    _glp_lib_xassert("npp->nnz == prob->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     407);
#line 407
    tmp___3 = 1;
    }
  }
#line 409
  if (npp->sol == 1) {
#line 410
    npp->p_stat = prob->pbs_stat;
#line 411
    npp->d_stat = prob->dbs_stat;
  } else
#line 413
  if (npp->sol == 2) {
#line 414
    npp->t_stat = prob->ipt_stat;
  } else
#line 415
  if (npp->sol == 3) {
#line 416
    npp->i_stat = prob->mip_stat;
  } else
#line 418
  if ((unsigned long )npp != (unsigned long )npp) {
#line 418
    tmp___4 = 1;
  } else {
    {
#line 418
    _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     418);
#line 418
    tmp___4 = 1;
    }
  }
#line 420
  if (npp->sol == 1) {
#line 421
    if ((unsigned long )npp->r_stat == (unsigned long )((void *)0)) {
      {
#line 422
      tmp___5 = _glp_lib_xcalloc(1 + npp->nrows, (int )sizeof(char ));
#line 422
      npp->r_stat = (char *)tmp___5;
      }
    }
#line 423
    i = 1;
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 423
      if (! (i <= npp->nrows)) {
#line 423
        goto while_break;
      }
#line 424
      *(npp->r_stat + i) = (char)0;
#line 423
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 425
    if ((unsigned long )npp->c_stat == (unsigned long )((void *)0)) {
      {
#line 426
      tmp___6 = _glp_lib_xcalloc(1 + npp->ncols, (int )sizeof(char ));
#line 426
      npp->c_stat = (char *)tmp___6;
      }
    }
#line 427
    j = 1;
    {
#line 427
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 427
      if (! (j <= npp->ncols)) {
#line 427
        goto while_break___0;
      }
#line 428
      *(npp->c_stat + j) = (char)0;
#line 427
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 430
  if ((unsigned long )npp->r_prim == (unsigned long )((void *)0)) {
    {
#line 431
    tmp___7 = _glp_lib_xcalloc(1 + npp->nrows, (int )sizeof(double ));
#line 431
    npp->r_prim = (double *)tmp___7;
    }
  }
#line 432
  i = 1;
  {
#line 432
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 432
    if (! (i <= npp->nrows)) {
#line 432
      goto while_break___1;
    }
#line 433
    *(npp->r_prim + i) = 1.7976931348623157e+308;
#line 432
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 434
  if ((unsigned long )npp->c_prim == (unsigned long )((void *)0)) {
    {
#line 435
    tmp___8 = _glp_lib_xcalloc(1 + npp->ncols, (int )sizeof(double ));
#line 435
    npp->c_prim = (double *)tmp___8;
    }
  }
#line 436
  j = 1;
  {
#line 436
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 436
    if (! (j <= npp->ncols)) {
#line 436
      goto while_break___2;
    }
#line 437
    *(npp->c_prim + j) = 1.7976931348623157e+308;
#line 436
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 438
  if (npp->sol != 3) {
#line 439
    if ((unsigned long )npp->r_dual == (unsigned long )((void *)0)) {
      {
#line 440
      tmp___9 = _glp_lib_xcalloc(1 + npp->nrows, (int )sizeof(double ));
#line 440
      npp->r_dual = (double *)tmp___9;
      }
    }
#line 441
    i = 1;
    {
#line 441
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 441
      if (! (i <= npp->nrows)) {
#line 441
        goto while_break___3;
      }
#line 442
      *(npp->r_dual + i) = 1.7976931348623157e+308;
#line 441
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 443
    if ((unsigned long )npp->c_dual == (unsigned long )((void *)0)) {
      {
#line 444
      tmp___10 = _glp_lib_xcalloc(1 + npp->ncols, (int )sizeof(double ));
#line 444
      npp->c_dual = (double *)tmp___10;
      }
    }
#line 445
    j = 1;
    {
#line 445
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 445
      if (! (j <= npp->ncols)) {
#line 445
        goto while_break___4;
      }
#line 446
      *(npp->c_dual + j) = 1.7976931348623157e+308;
#line 445
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 449
  if (npp->sol == 1) {
#line 450
    i = 1;
    {
#line 450
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 450
      if (! (i <= npp->m)) {
#line 450
        goto while_break___5;
      }
#line 451
      row = *(prob->row + i);
#line 452
      k = *(npp->row_ref + i);
#line 453
      *(npp->r_stat + k) = (char )row->stat;
#line 454
      *(npp->r_prim + k) = row->prim;
#line 455
      *(npp->r_dual + k) = dir * row->dual;
#line 450
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 457
    j = 1;
    {
#line 457
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 457
      if (! (j <= npp->n)) {
#line 457
        goto while_break___6;
      }
#line 458
      col = *(prob->col + j);
#line 459
      k = *(npp->col_ref + j);
#line 460
      *(npp->c_stat + k) = (char )col->stat;
#line 461
      *(npp->c_prim + k) = col->prim;
#line 462
      *(npp->c_dual + k) = dir * col->dual;
#line 457
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else
#line 465
  if (npp->sol == 2) {
#line 466
    i = 1;
    {
#line 466
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 466
      if (! (i <= npp->m)) {
#line 466
        goto while_break___7;
      }
#line 467
      row = *(prob->row + i);
#line 468
      k = *(npp->row_ref + i);
#line 469
      *(npp->r_prim + k) = row->pval;
#line 470
      *(npp->r_dual + k) = dir * row->dval;
#line 466
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 472
    j = 1;
    {
#line 472
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 472
      if (! (j <= npp->n)) {
#line 472
        goto while_break___8;
      }
#line 473
      col = *(prob->col + j);
#line 474
      k = *(npp->col_ref + j);
#line 475
      *(npp->c_prim + k) = col->pval;
#line 476
      *(npp->c_dual + k) = dir * col->dval;
#line 472
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  } else
#line 479
  if (npp->sol == 3) {
#line 480
    i = 1;
    {
#line 480
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 480
      if (! (i <= npp->m)) {
#line 480
        goto while_break___9;
      }
#line 481
      row = *(prob->row + i);
#line 482
      k = *(npp->row_ref + i);
#line 483
      *(npp->r_prim + k) = row->mipx;
#line 480
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 485
    j = 1;
    {
#line 485
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 485
      if (! (j <= npp->n)) {
#line 485
        goto while_break___10;
      }
#line 486
      col = *(prob->col + j);
#line 487
      k = *(npp->col_ref + j);
#line 488
      *(npp->c_prim + k) = col->mipx;
#line 485
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
  } else
#line 492
  if ((unsigned long )npp != (unsigned long )npp) {
#line 492
    tmp___11 = 1;
  } else {
    {
#line 492
    _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     492);
#line 492
    tmp___11 = 1;
    }
  }
#line 495
  tse = npp->top;
  {
#line 495
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 495
    if (! ((unsigned long )tse != (unsigned long )((void *)0))) {
#line 495
      goto while_break___11;
    }
#line 496
    if ((unsigned long )tse->func != (unsigned long )((void *)0)) {
#line 496
      tmp___12 = 1;
    } else {
      {
#line 496
      _glp_lib_xassert("tse->func != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                       496);
#line 496
      tmp___12 = 1;
      }
    }
    {
#line 497
    (*(tse->func))(npp, tse->info);
#line 495
    tse = tse->link;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
#line 499
  return;
}
}
#line 502 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void _glp_npp_unload_sol(NPP *npp , glp_prob *orig ) 
{ 
  GLPROW *row ;
  GLPCOL *col ;
  int i ;
  int j ;
  double dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
#line 508
  if (npp->orig_dir == orig->dir) {
#line 508
    tmp = 1;
  } else {
    {
#line 508
    _glp_lib_xassert("npp->orig_dir == orig->dir", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     508);
#line 508
    tmp = 1;
    }
  }
#line 509
  if (npp->orig_dir == 1) {
#line 510
    dir = 1.0;
  } else
#line 511
  if (npp->orig_dir == 2) {
#line 512
    dir = - 1.0;
  } else
#line 514
  if ((unsigned long )npp != (unsigned long )npp) {
#line 514
    tmp___0 = 1;
  } else {
    {
#line 514
    _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     514);
#line 514
    tmp___0 = 1;
    }
  }
#line 515
  if (npp->orig_m == orig->m) {
#line 515
    tmp___1 = 1;
  } else {
    {
#line 515
    _glp_lib_xassert("npp->orig_m == orig->m", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     515);
#line 515
    tmp___1 = 1;
    }
  }
#line 516
  if (npp->orig_n == orig->n) {
#line 516
    tmp___2 = 1;
  } else {
    {
#line 516
    _glp_lib_xassert("npp->orig_n == orig->n", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     516);
#line 516
    tmp___2 = 1;
    }
  }
#line 517
  if (npp->orig_nnz == orig->nnz) {
#line 517
    tmp___3 = 1;
  } else {
    {
#line 517
    _glp_lib_xassert("npp->orig_nnz == orig->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     517);
#line 517
    tmp___3 = 1;
    }
  }
#line 518
  if (npp->sol == 1) {
#line 520
    orig->valid = 0;
#line 521
    orig->pbs_stat = npp->p_stat;
#line 522
    orig->dbs_stat = npp->d_stat;
#line 523
    orig->obj_val = orig->c0;
#line 524
    orig->some = 0;
#line 525
    i = 1;
    {
#line 525
    while (1) {
      while_continue: /* CIL Label */ ;
#line 525
      if (! (i <= orig->m)) {
#line 525
        goto while_break;
      }
#line 526
      row = *(orig->row + i);
#line 527
      row->stat = (int )*(npp->r_stat + i);
#line 528
      if (! npp->scaling) {
#line 529
        row->prim = *(npp->r_prim + i);
#line 530
        row->dual = dir * *(npp->r_dual + i);
      } else {
#line 533
        row->prim = *(npp->r_prim + i) / row->rii;
#line 534
        row->dual = (dir * *(npp->r_dual + i)) * row->rii;
      }
#line 536
      if (row->stat == 1) {
#line 537
        row->dual = 0.0;
      } else
#line 538
      if (row->stat == 2) {
#line 539
        if (row->type == 2) {
#line 539
          tmp___4 = 1;
        } else
#line 539
        if (row->type == 4) {
#line 539
          tmp___4 = 1;
        } else {
          {
#line 539
          _glp_lib_xassert("row->type == GLP_LO || row->type == GLP_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           539);
#line 539
          tmp___4 = 1;
          }
        }
#line 540
        row->prim = row->lb;
      } else
#line 542
      if (row->stat == 3) {
#line 543
        if (row->type == 3) {
#line 543
          tmp___5 = 1;
        } else
#line 543
        if (row->type == 4) {
#line 543
          tmp___5 = 1;
        } else {
          {
#line 543
          _glp_lib_xassert("row->type == GLP_UP || row->type == GLP_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           543);
#line 543
          tmp___5 = 1;
          }
        }
#line 544
        row->prim = row->ub;
      } else
#line 546
      if (row->stat == 4) {
#line 547
        if (row->type == 1) {
#line 547
          tmp___6 = 1;
        } else {
          {
#line 547
          _glp_lib_xassert("row->type == GLP_FR", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           547);
#line 547
          tmp___6 = 1;
          }
        }
#line 548
        row->prim = 0.0;
      } else
#line 550
      if (row->stat == 5) {
#line 551
        if (row->type == 5) {
#line 551
          tmp___7 = 1;
        } else {
          {
#line 551
          _glp_lib_xassert("row->type == GLP_FX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           551);
#line 551
          tmp___7 = 1;
          }
        }
#line 552
        row->prim = row->lb;
      } else
#line 555
      if ((unsigned long )row != (unsigned long )row) {
#line 555
        tmp___8 = 1;
      } else {
        {
#line 555
        _glp_lib_xassert("row != row", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                         555);
#line 555
        tmp___8 = 1;
        }
      }
#line 525
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 557
    j = 1;
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      if (! (j <= orig->n)) {
#line 557
        goto while_break___0;
      }
#line 558
      col = *(orig->col + j);
#line 559
      col->stat = (int )*(npp->c_stat + j);
#line 560
      if (! npp->scaling) {
#line 561
        col->prim = *(npp->c_prim + j);
#line 562
        col->dual = dir * *(npp->c_dual + j);
      } else {
#line 565
        col->prim = *(npp->c_prim + j) * col->sjj;
#line 566
        col->dual = (dir * *(npp->c_dual + j)) / col->sjj;
      }
#line 568
      if (col->stat == 1) {
#line 569
        col->dual = 0.0;
      } else
#line 570
      if (col->stat == 2) {
#line 571
        if (col->type == 2) {
#line 571
          tmp___9 = 1;
        } else
#line 571
        if (col->type == 4) {
#line 571
          tmp___9 = 1;
        } else {
          {
#line 571
          _glp_lib_xassert("col->type == GLP_LO || col->type == GLP_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           571);
#line 571
          tmp___9 = 1;
          }
        }
#line 572
        col->prim = col->lb;
      } else
#line 574
      if (col->stat == 3) {
#line 575
        if (col->type == 3) {
#line 575
          tmp___10 = 1;
        } else
#line 575
        if (col->type == 4) {
#line 575
          tmp___10 = 1;
        } else {
          {
#line 575
          _glp_lib_xassert("col->type == GLP_UP || col->type == GLP_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           575);
#line 575
          tmp___10 = 1;
          }
        }
#line 576
        col->prim = col->ub;
      } else
#line 578
      if (col->stat == 4) {
#line 579
        if (col->type == 1) {
#line 579
          tmp___11 = 1;
        } else {
          {
#line 579
          _glp_lib_xassert("col->type == GLP_FR", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           579);
#line 579
          tmp___11 = 1;
          }
        }
#line 580
        col->prim = 0.0;
      } else
#line 582
      if (col->stat == 5) {
#line 583
        if (col->type == 5) {
#line 583
          tmp___12 = 1;
        } else {
          {
#line 583
          _glp_lib_xassert("col->type == GLP_FX", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           583);
#line 583
          tmp___12 = 1;
          }
        }
#line 584
        col->prim = col->lb;
      } else
#line 587
      if ((unsigned long )col != (unsigned long )col) {
#line 587
        tmp___13 = 1;
      } else {
        {
#line 587
        _glp_lib_xassert("col != col", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                         587);
#line 587
        tmp___13 = 1;
        }
      }
#line 588
      orig->obj_val += col->coef * col->prim;
#line 557
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 591
  if (npp->sol == 2) {
#line 593
    orig->ipt_stat = npp->t_stat;
#line 594
    orig->ipt_obj = orig->c0;
#line 595
    i = 1;
    {
#line 595
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 595
      if (! (i <= orig->m)) {
#line 595
        goto while_break___1;
      }
#line 596
      row = *(orig->row + i);
#line 597
      if (! npp->scaling) {
#line 598
        row->pval = *(npp->r_prim + i);
#line 599
        row->dval = dir * *(npp->r_dual + i);
      } else {
#line 602
        row->pval = *(npp->r_prim + i) / row->rii;
#line 603
        row->dval = (dir * *(npp->r_dual + i)) * row->rii;
      }
#line 595
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 606
    j = 1;
    {
#line 606
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 606
      if (! (j <= orig->n)) {
#line 606
        goto while_break___2;
      }
#line 607
      col = *(orig->col + j);
#line 608
      if (! npp->scaling) {
#line 609
        col->pval = *(npp->c_prim + j);
#line 610
        col->dval = dir * *(npp->c_dual + j);
      } else {
#line 613
        col->pval = *(npp->c_prim + j) * col->sjj;
#line 614
        col->dval = (dir * *(npp->c_dual + j)) / col->sjj;
      }
#line 616
      orig->ipt_obj += col->coef * col->pval;
#line 606
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 619
  if (npp->sol == 3) {
#line 621
    if (! npp->scaling) {
#line 621
      tmp___14 = 1;
    } else {
      {
#line 621
      _glp_lib_xassert("!npp->scaling", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                       621);
#line 621
      tmp___14 = 1;
      }
    }
#line 622
    orig->mip_stat = npp->i_stat;
#line 623
    orig->mip_obj = orig->c0;
#line 624
    i = 1;
    {
#line 624
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 624
      if (! (i <= orig->m)) {
#line 624
        goto while_break___3;
      }
#line 625
      row = *(orig->row + i);
#line 626
      row->mipx = *(npp->r_prim + i);
#line 624
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 628
    j = 1;
    {
#line 628
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 628
      if (! (j <= orig->n)) {
#line 628
        goto while_break___4;
      }
#line 629
      col = *(orig->col + j);
#line 630
      col->mipx = *(npp->c_prim + j);
#line 631
      if (col->kind == 2) {
        {
#line 632
        tmp___15 = floor(col->mipx);
        }
#line 632
        if (col->mipx == tmp___15) {
#line 632
          tmp___16 = 1;
        } else {
          {
#line 632
          _glp_lib_xassert("col->mipx == floor(col->mipx)", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                           632);
#line 632
          tmp___16 = 1;
          }
        }
      }
#line 633
      orig->mip_obj += col->coef * col->mipx;
#line 628
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 637
  if ((unsigned long )npp != (unsigned long )npp) {
#line 637
    tmp___17 = 1;
  } else {
    {
#line 637
    _glp_lib_xassert("npp != npp", "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c",
                     637);
#line 637
    tmp___17 = 1;
    }
  }
#line 638
  return;
}
}
#line 641 "/home/wslee/benchmarks/glpk-4.38/src/glpnpp01.c"
void _glp_npp_delete_wksp(NPP *npp ) 
{ 


  {
#line 643
  if ((unsigned long )npp->pool != (unsigned long )((void *)0)) {
    {
#line 644
    _glp_dmp_delete_pool(npp->pool);
    }
  }
#line 645
  if ((unsigned long )npp->stack != (unsigned long )((void *)0)) {
    {
#line 646
    _glp_dmp_delete_pool(npp->stack);
    }
  }
#line 647
  if ((unsigned long )npp->row_ref != (unsigned long )((void *)0)) {
    {
#line 648
    _glp_lib_xfree((void *)npp->row_ref);
    }
  }
#line 649
  if ((unsigned long )npp->col_ref != (unsigned long )((void *)0)) {
    {
#line 650
    _glp_lib_xfree((void *)npp->col_ref);
    }
  }
#line 651
  if ((unsigned long )npp->r_stat != (unsigned long )((void *)0)) {
    {
#line 652
    _glp_lib_xfree((void *)npp->r_stat);
    }
  }
#line 653
  if ((unsigned long )npp->r_prim != (unsigned long )((void *)0)) {
    {
#line 654
    _glp_lib_xfree((void *)npp->r_prim);
    }
  }
#line 655
  if ((unsigned long )npp->r_dual != (unsigned long )((void *)0)) {
    {
#line 656
    _glp_lib_xfree((void *)npp->r_dual);
    }
  }
#line 657
  if ((unsigned long )npp->c_stat != (unsigned long )((void *)0)) {
    {
#line 658
    _glp_lib_xfree((void *)npp->c_stat);
    }
  }
#line 659
  if ((unsigned long )npp->c_prim != (unsigned long )((void *)0)) {
    {
#line 660
    _glp_lib_xfree((void *)npp->c_prim);
    }
  }
#line 661
  if ((unsigned long )npp->c_dual != (unsigned long )((void *)0)) {
    {
#line 662
    _glp_lib_xfree((void *)npp->c_dual);
    }
  }
  {
#line 663
  _glp_lib_xfree((void *)npp);
  }
#line 664
  return;
}
}
#line 44 "/home/wslee/benchmarks/glpk-4.38/src/glpnet.h"
void _glp_ffalg(int nv , int na , int const   *tail , int const   *head , int s ,
                int t , int const   *cap , int *x , char *cut ) ;
#line 76 "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c"
void _glp_ffalg(int nv , int na , int const   *tail , int const   *head , int s ,
                int t , int const   *cap , int *x , char *cut ) 
{ 
  int a ;
  int delta ;
  int i ;
  int j ;
  int k ;
  int pos1 ;
  int pos2 ;
  int temp ;
  int *ptr ;
  int *arc ;
  int *link ;
  int *list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;

  {
#line 81
  if (nv >= 2) {
#line 81
    tmp = 1;
  } else {
    {
#line 81
    _glp_lib_xassert("nv >= 2", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     81);
#line 81
    tmp = 1;
    }
  }
#line 82
  if (na >= 0) {
#line 82
    tmp___0 = 1;
  } else {
    {
#line 82
    _glp_lib_xassert("na >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     82);
#line 82
    tmp___0 = 1;
    }
  }
#line 83
  if (1 <= s) {
#line 83
    if (s <= nv) {
#line 83
      tmp___1 = 1;
    } else {
      {
#line 83
      _glp_lib_xassert("1 <= s && s <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       83);
#line 83
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 83
    _glp_lib_xassert("1 <= s && s <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     83);
#line 83
    tmp___1 = 1;
    }
  }
#line 84
  if (1 <= t) {
#line 84
    if (t <= nv) {
#line 84
      tmp___2 = 1;
    } else {
      {
#line 84
      _glp_lib_xassert("1 <= t && t <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       84);
#line 84
      tmp___2 = 1;
      }
    }
  } else {
    {
#line 84
    _glp_lib_xassert("1 <= t && t <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     84);
#line 84
    tmp___2 = 1;
    }
  }
#line 85
  if (s != t) {
#line 85
    tmp___3 = 1;
  } else {
    {
#line 85
    _glp_lib_xassert("s != t", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     85);
#line 85
    tmp___3 = 1;
    }
  }
#line 86
  a = 1;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (a <= na)) {
#line 86
      goto while_break;
    }
#line 87
    i = (int )*(tail + a);
#line 87
    j = (int )*(head + a);
#line 88
    if (1 <= i) {
#line 88
      if (i <= nv) {
#line 88
        tmp___4 = 1;
      } else {
        {
#line 88
        _glp_lib_xassert("1 <= i && i <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                         88);
#line 88
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 88
      _glp_lib_xassert("1 <= i && i <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       88);
#line 88
      tmp___4 = 1;
      }
    }
#line 89
    if (1 <= j) {
#line 89
      if (j <= nv) {
#line 89
        tmp___5 = 1;
      } else {
        {
#line 89
        _glp_lib_xassert("1 <= j && j <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                         89);
#line 89
        tmp___5 = 1;
        }
      }
    } else {
      {
#line 89
      _glp_lib_xassert("1 <= j && j <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       89);
#line 89
      tmp___5 = 1;
      }
    }
#line 90
    if (i != j) {
#line 90
      tmp___6 = 1;
    } else {
      {
#line 90
      _glp_lib_xassert("i != j", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       90);
#line 90
      tmp___6 = 1;
      }
    }
#line 91
    if (*(cap + a) >= 0) {
#line 91
      tmp___7 = 1;
    } else {
      {
#line 91
      _glp_lib_xassert("cap[a] >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       91);
#line 91
      tmp___7 = 1;
      }
    }
#line 86
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  tmp___8 = _glp_lib_xcalloc((1 + nv) + 1, (int )sizeof(int ));
#line 94
  ptr = (int *)tmp___8;
#line 95
  tmp___9 = _glp_lib_xcalloc((1 + na) + na, (int )sizeof(int ));
#line 95
  arc = (int *)tmp___9;
#line 96
  tmp___10 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 96
  link = (int *)tmp___10;
#line 97
  tmp___11 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 97
  list = (int *)tmp___11;
#line 99
  i = 1;
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    if (! (i <= nv)) {
#line 99
      goto while_break___0;
    }
#line 100
    *(ptr + i) = 0;
#line 99
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  a = 1;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (a <= na)) {
#line 101
      goto while_break___1;
    }
#line 102
    (*(ptr + *(tail + a))) ++;
#line 103
    (*(ptr + *(head + a))) ++;
#line 101
    a ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 106
  (*(ptr + 1)) ++;
#line 107
  i = 1;
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 107
    if (! (i < nv)) {
#line 107
      goto while_break___2;
    }
#line 108
    *(ptr + (i + 1)) += *(ptr + i);
#line 107
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 109
  *(ptr + (nv + 1)) = *(ptr + nv);
#line 111
  a = 1;
  {
#line 111
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 111
    if (! (a <= na)) {
#line 111
      goto while_break___3;
    }
#line 112
    (*(ptr + *(tail + a))) --;
#line 112
    *(arc + *(ptr + *(tail + a))) = a;
#line 113
    (*(ptr + *(head + a))) --;
#line 113
    *(arc + *(ptr + *(head + a))) = a;
#line 111
    a ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 115
  if (*(ptr + 1) == 1) {
#line 115
    tmp___12 = 1;
  } else {
    {
#line 115
    _glp_lib_xassert("ptr[1] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     115);
#line 115
    tmp___12 = 1;
    }
  }
#line 116
  if (*(ptr + (nv + 1)) == (na + na) + 1) {
#line 116
    tmp___13 = 1;
  } else {
    {
#line 116
    _glp_lib_xassert("ptr[nv+1] == na+na+1", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     116);
#line 116
    tmp___13 = 1;
    }
  }
#line 120
  a = 1;
  {
#line 120
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 120
    if (! (a <= na)) {
#line 120
      goto while_break___4;
    }
#line 121
    *(x + a) = 0;
#line 120
    a ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  loop: 
#line 127
  i = 1;
  {
#line 127
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 127
    if (! (i <= nv)) {
#line 127
      goto while_break___5;
    }
#line 128
    *(link + i) = 0;
#line 127
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 129
  *(link + s) = -1;
#line 129
  *(list + 1) = s;
#line 129
  pos2 = 1;
#line 129
  pos1 = pos2;
  {
#line 131
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 131
    if (! (pos1 <= pos2)) {
#line 131
      goto while_break___6;
    }
#line 133
    tmp___14 = pos1;
#line 133
    pos1 ++;
#line 133
    i = *(list + tmp___14);
#line 135
    k = *(ptr + i);
    {
#line 135
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 135
      if (! (k < *(ptr + (i + 1)))) {
#line 135
        goto while_break___7;
      }
#line 136
      a = *(arc + k);
#line 137
      if (*(tail + a) == (int const   )i) {
#line 139
        j = (int )*(head + a);
#line 141
        if (*(link + j) != 0) {
#line 141
          goto __Cont;
        }
#line 144
        if (*(x + a) == (int )*(cap + a)) {
#line 144
          goto __Cont;
        }
      } else
#line 146
      if (*(head + a) == (int const   )i) {
#line 148
        j = (int )*(tail + a);
#line 150
        if (*(link + j) != 0) {
#line 150
          goto __Cont;
        }
#line 153
        if (*(x + a) == 0) {
#line 153
          goto __Cont;
        }
      } else
#line 156
      if (a != a) {
#line 156
        tmp___15 = 1;
      } else {
        {
#line 156
        _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                         156);
#line 156
        tmp___15 = 1;
        }
      }
#line 158
      *(link + j) = a;
#line 158
      pos2 ++;
#line 158
      *(list + pos2) = j;
#line 160
      if (j == t) {
#line 160
        goto brkt;
      }
      __Cont: /* CIL Label */ 
#line 135
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 166
  if ((unsigned long )cut != (unsigned long )((void *)0)) {
#line 167
    i = 1;
    {
#line 167
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 167
      if (! (i <= nv)) {
#line 167
        goto while_break___8;
      }
#line 168
      *(cut + i) = (char )(*(link + i) != 0);
#line 167
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 170
  goto done;
  brkt: 
#line 174
  delta = 0;
#line 175
  j = t;
  {
#line 175
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 175
    if (! (j != s)) {
#line 175
      goto while_break___9;
    }
#line 177
    a = *(link + j);
#line 178
    if (*(head + a) == (int const   )j) {
#line 180
      i = (int )*(tail + a);
#line 182
      temp = (int )(*(cap + a) - (int const   )*(x + a));
    } else
#line 184
    if (*(tail + a) == (int const   )j) {
#line 186
      i = (int )*(head + a);
#line 188
      temp = *(x + a);
    } else
#line 191
    if (a != a) {
#line 191
      tmp___16 = 1;
    } else {
      {
#line 191
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       191);
#line 191
      tmp___16 = 1;
      }
    }
#line 192
    if (delta == 0) {
#line 192
      delta = temp;
    } else
#line 192
    if (delta > temp) {
#line 192
      delta = temp;
    }
#line 175
    j = i;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 194
  if (delta > 0) {
#line 194
    tmp___17 = 1;
  } else {
    {
#line 194
    _glp_lib_xassert("delta > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                     194);
#line 194
    tmp___17 = 1;
    }
  }
#line 196
  j = t;
  {
#line 196
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 196
    if (! (j != s)) {
#line 196
      goto while_break___10;
    }
#line 198
    a = *(link + j);
#line 199
    if (*(head + a) == (int const   )j) {
#line 201
      i = (int )*(tail + a);
#line 202
      *(x + a) += delta;
    } else
#line 204
    if (*(tail + a) == (int const   )j) {
#line 206
      i = (int )*(head + a);
#line 207
      *(x + a) -= delta;
    } else
#line 210
    if (a != a) {
#line 210
      tmp___18 = 1;
    } else {
      {
#line 210
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet07.c",
                       210);
#line 210
      tmp___18 = 1;
      }
    }
#line 196
    j = i;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 212
  goto loop;
  done: 
  {
#line 214
  _glp_lib_xfree((void *)ptr);
#line 215
  _glp_lib_xfree((void *)arc);
#line 216
  _glp_lib_xfree((void *)link);
#line 217
  _glp_lib_xfree((void *)list);
  }
#line 218
  return;
}
}
#line 38 "/home/wslee/benchmarks/glpk-4.38/src/glpnet.h"
int _glp_okalg(int nv , int na , int const   *tail , int const   *head , int const   *low ,
               int const   *cap , int const   *cost , int *x , int *pi ) ;
#line 92 "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c"
static int overflow(int u , int v ) 
{ 


  {
#line 94
  if (u > 0) {
#line 94
    if (v > 0) {
#line 94
      if (u + v < 0) {
#line 94
        return (1);
      }
    }
  }
#line 95
  if (u < 0) {
#line 95
    if (v < 0) {
#line 95
      if (u + v > 0) {
#line 95
        return (1);
      }
    }
  }
#line 96
  return (0);
}
}
#line 99 "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c"
int _glp_okalg(int nv , int na , int const   *tail , int const   *head , int const   *low ,
               int const   *cap , int const   *cost , int *x , int *pi ) 
{ 
  int a ;
  int aok ;
  int delta ;
  int i ;
  int j ;
  int k ;
  int lambda ;
  int pos1 ;
  int pos2 ;
  int s ;
  int t ;
  int temp ;
  int ret ;
  int *ptr ;
  int *arc ;
  int *link ;
  int *list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
#line 105
  if (nv >= 0) {
#line 105
    tmp = 1;
  } else {
    {
#line 105
    _glp_lib_xassert("nv >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                     105);
#line 105
    tmp = 1;
    }
  }
#line 106
  if (na >= 0) {
#line 106
    tmp___0 = 1;
  } else {
    {
#line 106
    _glp_lib_xassert("na >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                     106);
#line 106
    tmp___0 = 1;
    }
  }
#line 107
  a = 1;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (a <= na)) {
#line 107
      goto while_break;
    }
#line 108
    i = (int )*(tail + a);
#line 108
    j = (int )*(head + a);
#line 109
    if (1 <= i) {
#line 109
      if (i <= nv) {
#line 109
        tmp___1 = 1;
      } else {
        {
#line 109
        _glp_lib_xassert("1 <= i && i <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                         109);
#line 109
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 109
      _glp_lib_xassert("1 <= i && i <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                       109);
#line 109
      tmp___1 = 1;
      }
    }
#line 110
    if (1 <= j) {
#line 110
      if (j <= nv) {
#line 110
        tmp___2 = 1;
      } else {
        {
#line 110
        _glp_lib_xassert("1 <= j && j <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                         110);
#line 110
        tmp___2 = 1;
        }
      }
    } else {
      {
#line 110
      _glp_lib_xassert("1 <= j && j <= nv", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                       110);
#line 110
      tmp___2 = 1;
      }
    }
#line 111
    if (i != j) {
#line 111
      tmp___3 = 1;
    } else {
      {
#line 111
      _glp_lib_xassert("i != j", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                       111);
#line 111
      tmp___3 = 1;
      }
    }
#line 112
    if (0 <= (int )*(low + a)) {
#line 112
      if (*(low + a) <= *(cap + a)) {
#line 112
        tmp___4 = 1;
      } else {
        {
#line 112
        _glp_lib_xassert("0 <= low[a] && low[a] <= cap[a]", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                         112);
#line 112
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 112
      _glp_lib_xassert("0 <= low[a] && low[a] <= cap[a]", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                       112);
#line 112
      tmp___4 = 1;
      }
    }
#line 107
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp___5 = _glp_lib_xcalloc((1 + nv) + 1, (int )sizeof(int ));
#line 115
  ptr = (int *)tmp___5;
#line 116
  tmp___6 = _glp_lib_xcalloc((1 + na) + na, (int )sizeof(int ));
#line 116
  arc = (int *)tmp___6;
#line 117
  tmp___7 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 117
  link = (int *)tmp___7;
#line 118
  tmp___8 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 118
  list = (int *)tmp___8;
#line 120
  i = 1;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (i <= nv)) {
#line 120
      goto while_break___0;
    }
#line 121
    *(ptr + i) = 0;
#line 120
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  a = 1;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (a <= na)) {
#line 122
      goto while_break___1;
    }
#line 123
    (*(ptr + *(tail + a))) ++;
#line 124
    (*(ptr + *(head + a))) ++;
#line 122
    a ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 127
  (*(ptr + 1)) ++;
#line 128
  i = 1;
  {
#line 128
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 128
    if (! (i < nv)) {
#line 128
      goto while_break___2;
    }
#line 129
    *(ptr + (i + 1)) += *(ptr + i);
#line 128
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 130
  *(ptr + (nv + 1)) = *(ptr + nv);
#line 132
  a = 1;
  {
#line 132
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 132
    if (! (a <= na)) {
#line 132
      goto while_break___3;
    }
#line 133
    (*(ptr + *(tail + a))) --;
#line 133
    *(arc + *(ptr + *(tail + a))) = a;
#line 134
    (*(ptr + *(head + a))) --;
#line 134
    *(arc + *(ptr + *(head + a))) = a;
#line 132
    a ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 136
  if (*(ptr + 1) == 1) {
#line 136
    tmp___9 = 1;
  } else {
    {
#line 136
    _glp_lib_xassert("ptr[1] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                     136);
#line 136
    tmp___9 = 1;
    }
  }
#line 137
  if (*(ptr + (nv + 1)) == (na + na) + 1) {
#line 137
    tmp___10 = 1;
  } else {
    {
#line 137
    _glp_lib_xassert("ptr[nv+1] == na+na+1", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                     137);
#line 137
    tmp___10 = 1;
    }
  }
#line 141
  a = 1;
  {
#line 141
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 141
    if (! (a <= na)) {
#line 141
      goto while_break___4;
    }
#line 142
    *(x + a) = 0;
#line 141
    a ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 143
  i = 1;
  {
#line 143
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 143
    if (! (i <= nv)) {
#line 143
      goto while_break___5;
    }
#line 144
    *(pi + i) = 0;
#line 143
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  loop: 
#line 147
  aok = 0;
#line 148
  a = 1;
  {
#line 148
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 148
    if (! (a <= na)) {
#line 148
      goto while_break___6;
    }
    {
#line 149
    i = (int )*(tail + a);
#line 149
    j = (int )*(head + a);
#line 150
    tmp___11 = overflow((int )*(cost + a), *(pi + i) - *(pi + j));
    }
#line 150
    if (tmp___11) {
#line 151
      ret = 2;
#line 152
      goto done;
    }
#line 154
    lambda = (int )(*(cost + a) + (int const   )(*(pi + i) - *(pi + j)));
#line 155
    if (*(x + a) < (int )*(low + a)) {
#line 158
      aok = a;
#line 158
      s = j;
#line 158
      t = i;
#line 159
      goto while_break___6;
    } else
#line 155
    if (lambda < 0) {
#line 155
      if (*(x + a) < (int )*(cap + a)) {
#line 158
        aok = a;
#line 158
        s = j;
#line 158
        t = i;
#line 159
        goto while_break___6;
      }
    }
#line 161
    if (*(x + a) > (int )*(cap + a)) {
#line 164
      aok = a;
#line 164
      s = i;
#line 164
      t = j;
#line 165
      goto while_break___6;
    } else
#line 161
    if (lambda > 0) {
#line 161
      if (*(x + a) > (int )*(low + a)) {
#line 164
        aok = a;
#line 164
        s = i;
#line 164
        t = j;
#line 165
        goto while_break___6;
      }
    }
#line 148
    a ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 168
  if (aok == 0) {
#line 171
    a = 1;
    {
#line 171
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 171
      if (! (a <= na)) {
#line 171
        goto while_break___7;
      }
#line 172
      if (*(low + a) <= (int const   )*(x + a)) {
#line 172
        if (! (*(x + a) <= (int )*(cap + a))) {
#line 173
          ret = 3;
#line 174
          goto done;
        }
      } else {
#line 173
        ret = 3;
#line 174
        goto done;
      }
#line 171
      a ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 177
    i = 1;
    {
#line 177
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 177
      if (! (i <= nv)) {
#line 177
        goto while_break___8;
      }
#line 178
      temp = 0;
#line 179
      k = *(ptr + i);
      {
#line 179
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 179
        if (! (k < *(ptr + (i + 1)))) {
#line 179
          goto while_break___9;
        }
#line 180
        a = *(arc + k);
#line 181
        if (*(tail + a) == (int const   )i) {
#line 183
          temp += *(x + a);
        } else
#line 185
        if (*(head + a) == (int const   )i) {
#line 187
          temp -= *(x + a);
        } else
#line 190
        if (a != a) {
#line 190
          tmp___12 = 1;
        } else {
          {
#line 190
          _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                           190);
#line 190
          tmp___12 = 1;
          }
        }
#line 179
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 192
      if (temp != 0) {
#line 193
        ret = 3;
#line 194
        goto done;
      }
#line 177
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 198
    a = 1;
    {
#line 198
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 198
      if (! (a <= na)) {
#line 198
        goto while_break___10;
      }
#line 199
      i = (int )*(tail + a);
#line 199
      j = (int )*(head + a);
#line 200
      lambda = (int )(*(cost + a) + (int const   )(*(pi + i) - *(pi + j)));
#line 201
      if (lambda > 0) {
#line 201
        if (*(x + a) != (int )*(low + a)) {
#line 203
          ret = 3;
#line 204
          goto done;
        } else {
#line 201
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 201
      if (lambda < 0) {
#line 201
        if (*(x + a) != (int )*(cap + a)) {
#line 203
          ret = 3;
#line 204
          goto done;
        }
      }
#line 198
      a ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 208
    ret = 0;
#line 209
    goto done;
  }
#line 217
  i = 1;
  {
#line 217
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 217
    if (! (i <= nv)) {
#line 217
      goto while_break___11;
    }
#line 218
    *(link + i) = 0;
#line 217
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 219
  *(link + s) = aok;
#line 219
  *(list + 1) = s;
#line 219
  pos2 = 1;
#line 219
  pos1 = pos2;
  {
#line 221
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 221
    if (! (pos1 <= pos2)) {
#line 221
      goto while_break___12;
    }
#line 223
    tmp___13 = pos1;
#line 223
    pos1 ++;
#line 223
    i = *(list + tmp___13);
#line 225
    k = *(ptr + i);
    {
#line 225
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 225
      if (! (k < *(ptr + (i + 1)))) {
#line 225
        goto while_break___13;
      }
#line 226
      a = *(arc + k);
#line 227
      if (*(tail + a) == (int const   )i) {
#line 229
        j = (int )*(head + a);
#line 231
        if (*(link + j) != 0) {
#line 231
          goto __Cont;
        }
#line 234
        if (*(x + a) >= (int )*(cap + a)) {
#line 234
          goto __Cont;
        }
        {
#line 235
        tmp___14 = overflow((int )*(cost + a), *(pi + i) - *(pi + j));
        }
#line 235
        if (tmp___14) {
#line 236
          ret = 2;
#line 237
          goto done;
        }
#line 239
        lambda = (int )(*(cost + a) + (int const   )(*(pi + i) - *(pi + j)));
#line 240
        if (lambda > 0) {
#line 240
          if (*(x + a) >= (int )*(low + a)) {
#line 240
            goto __Cont;
          }
        }
      } else
#line 242
      if (*(head + a) == (int const   )i) {
#line 244
        j = (int )*(tail + a);
#line 246
        if (*(link + j) != 0) {
#line 246
          goto __Cont;
        }
#line 249
        if (*(x + a) <= (int )*(low + a)) {
#line 249
          goto __Cont;
        }
        {
#line 250
        tmp___15 = overflow((int )*(cost + a), *(pi + j) - *(pi + i));
        }
#line 250
        if (tmp___15) {
#line 251
          ret = 2;
#line 252
          goto done;
        }
#line 254
        lambda = (int )(*(cost + a) + (int const   )(*(pi + j) - *(pi + i)));
#line 255
        if (lambda < 0) {
#line 255
          if (*(x + a) <= (int )*(cap + a)) {
#line 255
            goto __Cont;
          }
        }
      } else
#line 258
      if (a != a) {
#line 258
        tmp___16 = 1;
      } else {
        {
#line 258
        _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                         258);
#line 258
        tmp___16 = 1;
        }
      }
#line 260
      *(link + j) = a;
#line 260
      pos2 ++;
#line 260
      *(list + pos2) = j;
#line 262
      if (j == t) {
#line 262
        goto brkt;
      }
      __Cont: /* CIL Label */ 
#line 225
      k ++;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 268
  delta = 0;
#line 269
  a = 1;
  {
#line 269
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 269
    if (! (a <= na)) {
#line 269
      goto while_break___14;
    }
#line 270
    i = (int )*(tail + a);
#line 270
    j = (int )*(head + a);
#line 271
    if (*(link + i) != 0) {
#line 271
      if (*(link + j) == 0) {
        {
#line 273
        tmp___17 = overflow((int )*(cost + a), *(pi + i) - *(pi + j));
        }
#line 273
        if (tmp___17) {
#line 274
          ret = 2;
#line 275
          goto done;
        }
#line 277
        lambda = (int )(*(cost + a) + (int const   )(*(pi + i) - *(pi + j)));
#line 278
        if (*(x + a) <= (int )*(cap + a)) {
#line 278
          if (lambda > 0) {
#line 279
            if (delta == 0) {
#line 279
              delta = lambda;
            } else
#line 279
            if (delta > lambda) {
#line 279
              delta = lambda;
            }
          }
        }
      } else {
#line 271
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 281
    if (*(link + i) == 0) {
#line 281
      if (*(link + j) != 0) {
        {
#line 283
        tmp___18 = overflow((int )*(cost + a), *(pi + i) - *(pi + j));
        }
#line 283
        if (tmp___18) {
#line 284
          ret = 2;
#line 285
          goto done;
        }
#line 287
        lambda = (int )(*(cost + a) + (int const   )(*(pi + i) - *(pi + j)));
#line 288
        if (*(x + a) >= (int )*(low + a)) {
#line 288
          if (lambda < 0) {
#line 289
            if (delta == 0) {
#line 289
              delta = - lambda;
            } else
#line 289
            if (delta > - lambda) {
#line 289
              delta = - lambda;
            }
          }
        }
      }
    }
#line 269
    a ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 292
  if (delta == 0) {
#line 294
    ret = 1;
#line 295
    goto done;
  }
#line 298
  i = 1;
  {
#line 298
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 298
    if (! (i <= nv)) {
#line 298
      goto while_break___15;
    }
#line 299
    if (*(link + i) == 0) {
      {
#line 300
      tmp___19 = overflow(*(pi + i), delta);
      }
#line 300
      if (tmp___19) {
#line 301
        ret = 2;
#line 302
        goto done;
      }
#line 304
      *(pi + i) += delta;
    }
#line 298
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 307
  goto loop;
  brkt: 
#line 311
  delta = 0;
#line 312
  j = t;
  {
#line 312
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 314
    a = *(link + j);
#line 315
    if (*(head + a) == (int const   )j) {
#line 317
      i = (int )*(tail + a);
#line 318
      lambda = (int )(*(cost + a) + (int const   )(*(pi + i) - *(pi + j)));
#line 319
      if (lambda > 0) {
#line 319
        if (*(x + a) < (int )*(low + a)) {
#line 321
          temp = (int )(*(low + a) - (int const   )*(x + a));
        } else {
#line 319
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 323
      if (lambda <= 0) {
#line 323
        if (*(x + a) < (int )*(cap + a)) {
#line 325
          temp = (int )(*(cap + a) - (int const   )*(x + a));
        } else {
#line 323
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 328
      if (a != a) {
#line 328
        tmp___20 = 1;
      } else {
        {
#line 328
        _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                         328);
#line 328
        tmp___20 = 1;
        }
      }
    } else
#line 330
    if (*(tail + a) == (int const   )j) {
#line 332
      i = (int )*(head + a);
#line 333
      lambda = (int )(*(cost + a) + (int const   )(*(pi + j) - *(pi + i)));
#line 334
      if (lambda < 0) {
#line 334
        if (*(x + a) > (int )*(cap + a)) {
#line 336
          temp = *(x + a) - (int )*(cap + a);
        } else {
#line 334
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 338
      if (lambda >= 0) {
#line 338
        if (*(x + a) > (int )*(low + a)) {
#line 340
          temp = *(x + a) - (int )*(low + a);
        } else {
#line 338
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 343
      if (a != a) {
#line 343
        tmp___21 = 1;
      } else {
        {
#line 343
        _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                         343);
#line 343
        tmp___21 = 1;
        }
      }
    } else
#line 346
    if (a != a) {
#line 346
      tmp___22 = 1;
    } else {
      {
#line 346
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                       346);
#line 346
      tmp___22 = 1;
      }
    }
#line 347
    if (delta == 0) {
#line 347
      delta = temp;
    } else
#line 347
    if (delta > temp) {
#line 347
      delta = temp;
    }
#line 349
    if (i == t) {
#line 349
      goto while_break___16;
    }
#line 312
    j = i;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 351
  if (delta > 0) {
#line 351
    tmp___23 = 1;
  } else {
    {
#line 351
    _glp_lib_xassert("delta > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                     351);
#line 351
    tmp___23 = 1;
    }
  }
#line 353
  j = t;
  {
#line 353
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 355
    a = *(link + j);
#line 356
    if (*(head + a) == (int const   )j) {
#line 358
      i = (int )*(tail + a);
#line 360
      *(x + a) += delta;
    } else
#line 362
    if (*(tail + a) == (int const   )j) {
#line 364
      i = (int )*(head + a);
#line 366
      *(x + a) -= delta;
    } else
#line 369
    if (a != a) {
#line 369
      tmp___24 = 1;
    } else {
      {
#line 369
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpnet06.c",
                       369);
#line 369
      tmp___24 = 1;
      }
    }
#line 371
    if (i == t) {
#line 371
      goto while_break___17;
    }
#line 353
    j = i;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 373
  goto loop;
  done: 
  {
#line 375
  _glp_lib_xfree((void *)ptr);
#line 376
  _glp_lib_xfree((void *)arc);
#line 377
  _glp_lib_xfree((void *)link);
#line 378
  _glp_lib_xfree((void *)list);
  }
#line 379
  return (ret);
}
}
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 783 "./../include/glpk.h"
void glp_set_graph_name(glp_graph *G , char const   *name ) ;
#line 786
int glp_add_vertices(glp_graph *G , int nadd ) ;
#line 789
glp_arc *glp_add_arc(glp_graph *G , int i , int j ) ;
#line 792
void glp_erase_graph(glp_graph *G , int v_size , int a_size ) ;
#line 844
int glp_rmfgen(glp_graph *G_ , int *_s , int *_t , int _a_cap , int const   *parm ) ;
#line 175 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
static void make_edge(struct csa___1 *csa , int from , int to , int c1 , int c2 ) 
{ 
  double tmp ;

  {
  {
#line 176
  (csa->Ec) ++;
#line 177
  ((csa->N)->edges + csa->Ec)->from = from;
#line 178
  ((csa->N)->edges + csa->Ec)->to = to;
#line 179
  tmp = _glp_rng_unif_01(csa->rand);
#line 179
  ((csa->N)->edges + csa->Ec)->cap = (int )(tmp * (double )((c2 - c1) + 1)) + c1;
  }
#line 180
  return;
}
}
#line 183 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
static void permute(struct csa___1 *csa ) 
{ 
  int i ;
  int j ;
  int tmp ;
  double tmp___0 ;

  {
#line 185
  i = 1;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < csa->AA)) {
#line 185
      goto while_break;
    }
    {
#line 186
    tmp___0 = _glp_rng_unif_01(csa->rand);
#line 186
    j = (int )(tmp___0 * (double )((csa->AA - i) + 1)) + i;
#line 187
    tmp = *(csa->Parr + i);
#line 188
    *(csa->Parr + i) = *(csa->Parr + j);
#line 189
    *(csa->Parr + j) = tmp;
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 194 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
static void connect(struct csa___1 *csa , int offset , int cv , int x1 , int y1___0 ) 
{ 
  int cv1 ;

  {
#line 196
  cv1 = (offset + (x1 - 1) * csa->A) + y1___0;
#line 197
  (csa->Ec) ++;
#line 198
  ((csa->N)->edges + csa->Ec)->from = cv;
#line 199
  ((csa->N)->edges + csa->Ec)->to = cv1;
#line 200
  ((csa->N)->edges + csa->Ec)->cap = csa->C2AA;
#line 201
  return;
}
}
#line 204 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
static network *gen_rmf(struct csa___1 *csa , int a , int b , int c1 , int c2 ) 
{ 
  int x ;
  int y ;
  int z ;
  int offset ;
  int cv ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 209
  csa->A = a;
#line 210
  csa->AA = a * a;
#line 211
  csa->C2AA = c2 * csa->AA;
#line 212
  csa->Ec = 0;
#line 213
  tmp = _glp_lib_xmalloc((int )sizeof(network ));
#line 213
  csa->N = (network *)tmp;
#line 214
  (csa->N)->vertnum = csa->AA * b;
#line 215
  (csa->N)->edgenum = ((5 * csa->AA) * b - (4 * csa->A) * b) - csa->AA;
#line 216
  tmp___0 = _glp_lib_xcalloc((csa->N)->edgenum + 1, (int )sizeof(edge ));
#line 216
  (csa->N)->edges = (edge *)tmp___0;
#line 217
  (csa->N)->source = 1;
#line 218
  (csa->N)->sink = (csa->N)->vertnum;
#line 219
  tmp___1 = _glp_lib_xcalloc(csa->AA + 1, (int )sizeof(int ));
#line 219
  csa->Parr = (int *)tmp___1;
#line 220
  x = 1;
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (x <= csa->AA)) {
#line 220
      goto while_break;
    }
#line 221
    *(csa->Parr + x) = x;
#line 220
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  z = 1;
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 222
    if (! (z <= b)) {
#line 222
      goto while_break___0;
    }
#line 223
    offset = csa->AA * (z - 1);
#line 224
    if (z != b) {
      {
#line 225
      permute(csa);
      }
    }
#line 226
    x = 1;
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 226
      if (! (x <= csa->A)) {
#line 226
        goto while_break___1;
      }
#line 227
      y = 1;
      {
#line 227
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 227
        if (! (y <= csa->A)) {
#line 227
          goto while_break___2;
        }
#line 228
        cv = (offset + (x - 1) * csa->A) + y;
#line 229
        if (z != b) {
          {
#line 230
          make_edge(csa, cv, (offset + csa->AA) + *(csa->Parr + (cv - offset)), c1,
                    c2);
          }
        }
#line 232
        if (y < csa->A) {
          {
#line 233
          connect(csa, offset, cv, x, y + 1);
          }
        }
#line 234
        if (y > 1) {
          {
#line 235
          connect(csa, offset, cv, x, y - 1);
          }
        }
#line 236
        if (x < csa->A) {
          {
#line 237
          connect(csa, offset, cv, x + 1, y);
          }
        }
#line 238
        if (x > 1) {
          {
#line 239
          connect(csa, offset, cv, x - 1, y);
          }
        }
#line 227
        y ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 226
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 222
    z ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 243
  _glp_lib_xfree((void *)csa->Parr);
  }
#line 244
  return (csa->N);
}
}
#line 247 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
static void print_max_format(struct csa___1 *csa , network *n , char **comm , int dim ) 
{ 
  int i ;
  int vnum ;
  int e_num ;
  edge *e ;
  glp_arc *a ;
  glp_arc *tmp ;
  double temp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 253
  vnum = n->vertnum;
#line 254
  e_num = n->edgenum;
#line 255
  if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
#line 256
    i = 0;
    {
#line 256
    while (1) {
      while_continue: /* CIL Label */ ;
#line 256
      if (! (i < dim)) {
#line 256
        goto while_break;
      }
      {
#line 257
      _glp_lib_xprintf("c %s\n", *(comm + i));
#line 256
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 258
    _glp_lib_xprintf("p max %7d %10d\n", vnum, e_num);
#line 259
    _glp_lib_xprintf("n %7d s\n", n->source);
#line 260
    _glp_lib_xprintf("n %7d t\n", n->sink);
    }
  } else {
    {
#line 263
    glp_add_vertices(csa->G, vnum);
    }
#line 264
    if ((unsigned long )csa->s != (unsigned long )((void *)0)) {
#line 264
      *(csa->s) = n->source;
    }
#line 265
    if ((unsigned long )csa->t != (unsigned long )((void *)0)) {
#line 265
      *(csa->t) = n->sink;
    }
  }
#line 267
  i = 1;
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! (i <= e_num)) {
#line 267
      goto while_break___0;
    }
#line 268
    e = n->edges + i;
#line 269
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 270
      _glp_lib_xprintf("a %7d %7d %10d\n", e->from, e->to, e->cap);
      }
    } else {
      {
#line 272
      tmp = glp_add_arc(csa->G, e->from, e->to);
#line 272
      a = tmp;
      }
#line 273
      if (csa->a_cap >= 0) {
        {
#line 274
        temp = (double )e->cap;
#line 275
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cap), (void const   */* __restrict  */)(& temp),
               (size_t )sizeof(double ));
        }
      }
    }
#line 267
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 282 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
static void gen_free_net(network *n ) 
{ 


  {
  {
#line 283
  _glp_lib_xfree((void *)n->edges);
#line 284
  _glp_lib_xfree((void *)n);
  }
#line 285
  return;
}
}
#line 288 "/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c"
int glp_rmfgen(glp_graph *G_ , int *_s , int *_t , int _a_cap , int const   *parm ) 
{ 
  struct csa___1 _csa ;
  struct csa___1 *csa ;
  network *n ;
  char comm[10][80] ;
  char *com1[10] ;
  int seed ;
  int a ;
  int b ;
  int c1 ;
  int c2 ;
  int ret ;
  xerror_t tmp ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 290
  csa = & _csa;
#line 294
  csa->G = G_;
#line 295
  csa->s = _s;
#line 296
  csa->t = _t;
#line 297
  csa->a_cap = _a_cap;
#line 298
  if ((unsigned long )csa->G != (unsigned long )((void *)0)) {
#line 299
    if (csa->a_cap >= 0) {
#line 299
      if (csa->a_cap > (csa->G)->a_size - (int )sizeof(double )) {
        {
#line 300
        tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpnet05.c",
                               300);
#line 300
        (*tmp)("glp_rmfgen: a_cap = %d; invalid offset\n", csa->a_cap);
        }
      }
    }
  }
#line 302
  seed = (int )*(parm + 1);
#line 303
  a = (int )*(parm + 2);
#line 304
  b = (int )*(parm + 3);
#line 305
  c1 = (int )*(parm + 4);
#line 306
  c2 = (int )*(parm + 5);
#line 307
  if (seed > 0) {
#line 307
    if (1 <= a) {
#line 307
      if (a <= 1000) {
#line 307
        if (1 <= b) {
#line 307
          if (b <= 1000) {
#line 307
            if (0 <= c1) {
#line 307
              if (c1 <= c2) {
#line 307
                if (! (c2 <= 1000)) {
#line 309
                  ret = 1;
#line 310
                  goto done;
                }
              } else {
#line 309
                ret = 1;
#line 310
                goto done;
              }
            } else {
#line 309
              ret = 1;
#line 310
              goto done;
            }
          } else {
#line 309
            ret = 1;
#line 310
            goto done;
          }
        } else {
#line 309
          ret = 1;
#line 310
          goto done;
        }
      } else {
#line 309
        ret = 1;
#line 310
        goto done;
      }
    } else {
#line 309
      ret = 1;
#line 310
      goto done;
    }
  } else {
#line 309
    ret = 1;
#line 310
    goto done;
  }
#line 312
  if ((unsigned long )csa->G != (unsigned long )((void *)0)) {
    {
#line 313
    glp_erase_graph(csa->G, (csa->G)->v_size, (csa->G)->a_size);
#line 314
    glp_set_graph_name(csa->G, "RMFGEN");
    }
  }
  {
#line 316
  csa->rand = _glp_rng_create_rand();
#line 317
  _glp_rng_init_rand(csa->rand, seed);
#line 318
  n = gen_rmf(csa, a, b, c1, c2);
#line 319
  sprintf((char */* __restrict  */)(comm[0]), (char const   */* __restrict  */)"This file was generated by genrmf.");
#line 320
  sprintf((char */* __restrict  */)(comm[1]), (char const   */* __restrict  */)"The parameters are: a: %d b: %d c1: %d c2: %d",
          a, b, c1, c2);
#line 322
  com1[0] = comm[0];
#line 323
  com1[1] = comm[1];
#line 324
  print_max_format(csa, n, com1, 2);
#line 325
  gen_free_net(n);
#line 326
  _glp_rng_delete_rand(csa->rand);
#line 327
  ret = 0;
  }
  done: 
#line 328
  return (ret);
}
}
#line 110 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 840 "./../include/glpk.h"
int glp_gridgen(glp_graph *G_ , int _v_rhs , int _a_cap , int _a_cost , int const   *parm ) ;
#line 225 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void assign_capacities(struct csa___2 *csa ) ;
#line 226
static void assign_costs(struct csa___2 *csa ) ;
#line 227
static void assign_imbalance(struct csa___2 *csa ) ;
#line 228
static int exponential(struct csa___2 *csa , double *lambda ) ;
#line 229
static struct arcs *gen_additional_arcs(struct csa___2 *csa , struct arcs *arc_ptr ) ;
#line 231
static struct arcs *gen_basic_grid(struct csa___2 *csa , struct arcs *arc_ptr ) ;
#line 233
static void gen_more_arcs(struct csa___2 *csa , struct arcs *arc_ptr ) ;
#line 234
static void generate(struct csa___2 *csa ) ;
#line 235
static void output(struct csa___2 *csa ) ;
#line 236
static double randy(struct csa___2 *csa ) ;
#line 237
static void select_source_sinks(struct csa___2 *csa ) ;
#line 238
static int uniform(struct csa___2 *csa , double *a ) ;
#line 240 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
int glp_gridgen(glp_graph *G_ , int _v_rhs , int _a_cap , int _a_cost , int const   *parm ) 
{ 
  struct csa___2 _csa ;
  struct csa___2 *csa ;
  int n ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 242
  csa = & _csa;
#line 244
  csa->G = G_;
#line 245
  csa->v_rhs = _v_rhs;
#line 246
  csa->a_cap = _a_cap;
#line 247
  csa->a_cost = _a_cost;
#line 248
  if ((unsigned long )csa->G != (unsigned long )((void *)0)) {
#line 249
    if (csa->v_rhs >= 0) {
#line 249
      if (csa->v_rhs > (csa->G)->v_size - (int )sizeof(double )) {
        {
#line 250
        tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c",
                               250);
#line 250
        (*tmp)("glp_gridgen: v_rhs = %d; invalid offset\n", csa->v_rhs);
        }
      }
    }
#line 251
    if (csa->a_cap >= 0) {
#line 251
      if (csa->a_cap > (csa->G)->a_size - (int )sizeof(double )) {
        {
#line 252
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c",
                                   252);
#line 252
        (*tmp___0)("glp_gridgen: a_cap = %d; invalid offset\n", csa->a_cap);
        }
      }
    }
#line 253
    if (csa->a_cost >= 0) {
#line 253
      if (csa->a_cost > (csa->G)->a_size - (int )sizeof(double )) {
        {
#line 254
        tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c",
                                   254);
#line 254
        (*tmp___1)("glp_gridgen: a_cost = %d; invalid offset\n", csa->a_cost);
        }
      }
    }
  }
#line 258
  if (! (*(parm + 1) == 0)) {
#line 258
    if (! (*(parm + 1) == 1)) {
#line 259
      ret = 1;
#line 260
      goto done;
    }
  }
#line 262
  if (*(parm + 2) < 1) {
#line 263
    ret = 2;
#line 264
    goto done;
  }
#line 266
  if (10 <= (int )*(parm + 3)) {
#line 266
    if (! (*(parm + 3) <= 40000)) {
#line 267
      ret = 3;
#line 268
      goto done;
    }
  } else {
#line 267
    ret = 3;
#line 268
    goto done;
  }
#line 270
  if (1 <= (int )*(parm + 4)) {
#line 270
    if (! (*(parm + 4) <= 40000)) {
#line 271
      ret = 4;
#line 272
      goto done;
    }
  } else {
#line 271
    ret = 4;
#line 272
    goto done;
  }
#line 274
  if (*(parm + 5) >= 0) {
#line 274
    if (*(parm + 6) >= 0) {
#line 274
      if (! (*(parm + 5) + *(parm + 6) <= *(parm + 3))) {
#line 276
        ret = 5;
#line 277
        goto done;
      }
    } else {
#line 276
      ret = 5;
#line 277
      goto done;
    }
  } else {
#line 276
    ret = 5;
#line 277
    goto done;
  }
#line 279
  if (1 <= (int )*(parm + 7)) {
#line 279
    if (! (*(parm + 7) <= *(parm + 3))) {
#line 280
      ret = 6;
#line 281
      goto done;
    }
  } else {
#line 280
    ret = 6;
#line 281
    goto done;
  }
#line 283
  if (*(parm + 8) < 0) {
#line 284
    ret = 7;
#line 285
    goto done;
  }
#line 287
  if (! (*(parm + 9) == 1)) {
#line 287
    if (! (*(parm + 9) == 2)) {
#line 288
      ret = 8;
#line 289
      goto done;
    }
  }
#line 291
  if (*(parm + 9) == 1) {
#line 291
    if (*(parm + 10) > *(parm + 11)) {
#line 293
      ret = 9;
#line 294
      goto done;
    } else {
#line 291
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 291
  if (*(parm + 9) == 2) {
#line 291
    if (*(parm + 10) < 1) {
#line 293
      ret = 9;
#line 294
      goto done;
    }
  }
#line 296
  if (! (*(parm + 12) == 1)) {
#line 296
    if (! (*(parm + 12) == 2)) {
#line 297
      ret = 10;
#line 298
      goto done;
    }
  }
#line 300
  if (*(parm + 12) == 1) {
#line 300
    if (0 <= (int )*(parm + 13)) {
#line 300
      if (*(parm + 13) <= *(parm + 14)) {
#line 300
        goto _L___0;
      } else {
#line 302
        ret = 11;
#line 303
        goto done;
      }
    } else {
#line 302
      ret = 11;
#line 303
      goto done;
    }
  } else
  _L___0: /* CIL Label */ 
#line 300
  if (*(parm + 12) == 2) {
#line 300
    if (*(parm + 13) < 1) {
#line 302
      ret = 11;
#line 303
      goto done;
    }
  }
#line 306
  if ((unsigned long )csa->G != (unsigned long )((void *)0)) {
    {
#line 307
    glp_erase_graph(csa->G, (csa->G)->v_size, (csa->G)->a_size);
#line 308
    glp_set_graph_name(csa->G, "GRIDGEN");
    }
  }
#line 311
  csa->two_way = (int )*(parm + 1);
#line 312
  tmp___2 = (int )*(parm + 2);
#line 312
  csa->seed = tmp___2;
#line 312
  csa->seed_original = tmp___2;
#line 313
  csa->n_node = (int )*(parm + 3);
#line 314
  n = (int )*(parm + 4);
#line 315
  csa->n_source = (int )*(parm + 5);
#line 316
  csa->n_sink = (int )*(parm + 6);
#line 317
  csa->avg_degree = (int )*(parm + 7);
#line 318
  csa->t_supply = (int )*(parm + 8);
#line 319
  csa->arc_costs.distribution = (int )*(parm + 9);
#line 320
  if (*(parm + 9) == 1) {
#line 321
    csa->arc_costs.parameter[0] = (double )*(parm + 10);
#line 322
    csa->arc_costs.parameter[1] = (double )*(parm + 11);
  } else {
#line 325
    csa->arc_costs.parameter[0] = (double )*(parm + 10) / 100.0;
#line 326
    csa->arc_costs.parameter[1] = 0.0;
  }
#line 328
  csa->capacities.distribution = (int )*(parm + 12);
#line 329
  if (*(parm + 12) == 1) {
#line 330
    csa->capacities.parameter[0] = (double )*(parm + 13);
#line 331
    csa->capacities.parameter[1] = (double )*(parm + 14);
  } else {
#line 334
    csa->capacities.parameter[0] = (double )*(parm + 13) / 100.0;
#line 335
    csa->capacities.parameter[1] = 0.0;
  }
#line 339
  if (n * n >= csa->n_node) {
#line 340
    csa->n1 = n;
#line 341
    csa->n2 = (int )((double )csa->n_node / (double )n + 0.5);
  } else {
#line 344
    csa->n2 = n;
#line 345
    csa->n1 = (int )((double )csa->n_node / (double )n + 0.5);
  }
#line 349
  csa->n_node = csa->n1 * csa->n2 + 1;
#line 350
  csa->n_arc = csa->n_node * csa->avg_degree;
#line 351
  csa->n_grid_arc = ((csa->two_way + 1) * ((csa->n1 - 1) * csa->n2 + (csa->n2 - 1) * csa->n1) + csa->n_source) + csa->n_sink;
#line 353
  if (csa->n_grid_arc > csa->n_arc) {
#line 353
    csa->n_arc = csa->n_grid_arc;
  }
  {
#line 354
  tmp___3 = _glp_lib_xcalloc(csa->n_arc, (int )sizeof(struct arcs ));
#line 354
  csa->arc_list = (struct arcs *)tmp___3;
#line 355
  tmp___4 = _glp_lib_xcalloc(csa->n_source, (int )sizeof(struct imbalance ));
#line 355
  csa->source_list = (struct imbalance *)tmp___4;
#line 356
  tmp___5 = _glp_lib_xcalloc(csa->n_sink, (int )sizeof(struct imbalance ));
#line 356
  csa->sink_list = (struct imbalance *)tmp___5;
#line 358
  generate(csa);
#line 360
  output(csa);
#line 362
  _glp_lib_xfree((void *)csa->arc_list);
#line 363
  _glp_lib_xfree((void *)csa->source_list);
#line 364
  _glp_lib_xfree((void *)csa->sink_list);
#line 366
  ret = 0;
  }
  done: 
#line 367
  return (ret);
}
}
#line 372 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void assign_capacities(struct csa___2 *csa ) 
{ 
  struct arcs *arc_ptr ;
  int (*random___0)(struct csa___2 *csa , double * ) ;
  int i ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 374
  arc_ptr = csa->arc_list;
  {
#line 379
  if (csa->arc_costs.distribution == 1) {
#line 379
    goto case_1;
  }
#line 382
  if (csa->arc_costs.distribution == 2) {
#line 382
    goto case_2;
  }
#line 385
  goto switch_default;
  case_1: /* CIL Label */ 
#line 380
  random___0 = (int (*)(struct csa___2 *csa , double * ))(& uniform);
#line 381
  goto switch_break;
  case_2: /* CIL Label */ 
#line 383
  random___0 = (int (*)(struct csa___2 *csa , double * ))(& exponential);
#line 384
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 386
  if ((unsigned long )csa != (unsigned long )csa) {
#line 386
    tmp = 1;
  } else {
    {
#line 386
    _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c",
                     386);
#line 386
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 389
  i = csa->n_source + csa->n_sink;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i < csa->n_grid_arc)) {
#line 389
      goto while_break;
    }
    {
#line 390
    arc_ptr->u = (*random___0)(csa, csa->capacities.parameter);
#line 389
    i ++;
#line 389
    arc_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  i = (i - csa->n_source) - csa->n_sink;
  {
#line 393
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 393
    if (! (i < csa->n_grid_arc)) {
#line 393
      goto while_break___0;
    }
#line 394
    arc_ptr->u = csa->t_supply;
#line 393
    i ++;
#line 393
    arc_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 396
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 396
    if (! (i < csa->n_arc)) {
#line 396
      goto while_break___1;
    }
    {
#line 397
    arc_ptr->u = (*random___0)(csa, csa->capacities.parameter);
#line 396
    i ++;
#line 396
    arc_ptr ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 398
  return;
}
}
#line 401 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void assign_costs(struct csa___2 *csa ) 
{ 
  struct arcs *arc_ptr ;
  int (*random___0)(struct csa___2 *csa , double * ) ;
  int i ;
  int high_cost ;
  int max_cost ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 403
  arc_ptr = csa->arc_list;
#line 409
  max_cost = 0;
  {
#line 412
  if (csa->arc_costs.distribution == 1) {
#line 412
    goto case_1;
  }
#line 415
  if (csa->arc_costs.distribution == 2) {
#line 415
    goto case_2;
  }
#line 418
  goto switch_default;
  case_1: /* CIL Label */ 
#line 413
  random___0 = (int (*)(struct csa___2 *csa , double * ))(& uniform);
#line 414
  goto switch_break;
  case_2: /* CIL Label */ 
#line 416
  random___0 = (int (*)(struct csa___2 *csa , double * ))(& exponential);
#line 417
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 419
  if ((unsigned long )csa != (unsigned long )csa) {
#line 419
    tmp = 1;
  } else {
    {
#line 419
    _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c",
                     419);
#line 419
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 422
  i = csa->n_source + csa->n_sink;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i < csa->n_grid_arc)) {
#line 422
      goto while_break;
    }
    {
#line 423
    arc_ptr->cost = (*random___0)(csa, csa->arc_costs.parameter);
    }
#line 424
    if (max_cost < arc_ptr->cost) {
#line 424
      max_cost = arc_ptr->cost;
    }
#line 422
    i ++;
#line 422
    arc_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  i = (i - csa->n_source) - csa->n_sink;
#line 428
  high_cost = max_cost * 2;
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 429
    if (! (i < csa->n_grid_arc)) {
#line 429
      goto while_break___0;
    }
#line 430
    arc_ptr->cost = high_cost;
#line 429
    i ++;
#line 429
    arc_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 432
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 432
    if (! (i < csa->n_arc)) {
#line 432
      goto while_break___1;
    }
    {
#line 433
    arc_ptr->cost = (*random___0)(csa, csa->arc_costs.parameter);
#line 432
    i ++;
#line 432
    arc_ptr ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 434
  return;
}
}
#line 437 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void assign_imbalance(struct csa___2 *csa ) 
{ 
  int total ;
  int i ;
  double avg ;
  struct imbalance *ptr ;
  double tmp ;
  double tmp___0 ;

  {
#line 443
  avg = (2.0 * (double )csa->t_supply) / (double )csa->n_source;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    i = 1;
#line 445
    total = csa->t_supply;
#line 445
    ptr = csa->source_list + 1;
    {
#line 445
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 445
      if (! (i < csa->n_source)) {
#line 445
        goto while_break___0;
      }
      {
#line 447
      tmp = randy(csa);
#line 447
      ptr->supply = (int )(tmp * avg + 0.5);
#line 448
      total -= ptr->supply;
#line 445
      i ++;
#line 445
      ptr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 450
    (csa->source_list)->supply = total;
#line 444
    if (! (total <= 0)) {
#line 444
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  avg = (- 2.0 * (double )csa->t_supply) / (double )csa->n_sink;
  {
#line 456
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 457
    i = 1;
#line 457
    total = csa->t_supply;
#line 457
    ptr = csa->sink_list + 1;
    {
#line 457
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 457
      if (! (i < csa->n_sink)) {
#line 457
        goto while_break___2;
      }
      {
#line 459
      tmp___0 = randy(csa);
#line 459
      ptr->supply = (int )(tmp___0 * avg - 0.5);
#line 460
      total += ptr->supply;
#line 457
      i ++;
#line 457
      ptr ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 462
    (csa->sink_list)->supply = - total;
#line 456
    if (! (total <= 0)) {
#line 456
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 465
  return;
}
}
#line 468 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static int exponential(struct csa___2 *csa , double *lambda ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 471
  tmp = randy(csa);
#line 471
  tmp___0 = log(tmp);
  }
#line 471
  return ((int )(- *(lambda + 0) * tmp___0 + 0.5));
}
}
#line 474 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static struct arcs *gen_additional_arcs(struct csa___2 *csa , struct arcs *arc_ptr ) 
{ 
  int i ;

  {
#line 479
  i = 0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < csa->n_source)) {
#line 479
      goto while_break;
    }
#line 480
    arc_ptr->from = (csa->source_list + i)->node;
#line 481
    arc_ptr->to = csa->n_node;
#line 479
    i ++;
#line 479
    arc_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  i = 0;
  {
#line 483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 483
    if (! (i < csa->n_sink)) {
#line 483
      goto while_break___0;
    }
#line 484
    arc_ptr->to = (csa->sink_list + i)->node;
#line 485
    arc_ptr->from = csa->n_node;
#line 483
    i ++;
#line 483
    arc_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 487
  return (arc_ptr);
}
}
#line 490 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static struct arcs *gen_basic_grid(struct csa___2 *csa , struct arcs *arc_ptr ) 
{ 
  int direction ;
  int i ;
  int j ;
  int k ;

  {
#line 493
  direction = 1;
#line 494
  if (csa->two_way) {
#line 496
    i = 1;
    {
#line 496
    while (1) {
      while_continue: /* CIL Label */ ;
#line 496
      if (! (i < csa->n_node)) {
#line 496
        goto while_break;
      }
#line 497
      j = i;
#line 497
      k = (j + csa->n1) - 1;
      {
#line 497
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 497
        if (! (j < k)) {
#line 497
          goto while_break___0;
        }
#line 498
        arc_ptr->from = j;
#line 499
        arc_ptr->to = j + 1;
#line 500
        arc_ptr ++;
#line 501
        arc_ptr->from = j + 1;
#line 502
        arc_ptr->to = j;
#line 503
        arc_ptr ++;
#line 497
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 496
      i += csa->n1;
    }
    while_break: /* CIL Label */ ;
    }
#line 506
    i = 1;
    {
#line 506
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 506
      if (! (i <= csa->n1)) {
#line 506
        goto while_break___1;
      }
#line 507
      j = i + csa->n1;
      {
#line 507
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 507
        if (! (j < csa->n_node)) {
#line 507
          goto while_break___2;
        }
#line 508
        arc_ptr->from = j;
#line 509
        arc_ptr->to = j - csa->n1;
#line 510
        arc_ptr ++;
#line 511
        arc_ptr->from = j - csa->n1;
#line 512
        arc_ptr->to = j;
#line 513
        arc_ptr ++;
#line 507
        j += csa->n1;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 506
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 519
    i = 1;
    {
#line 519
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 519
      if (! (i < csa->n_node)) {
#line 519
        goto while_break___3;
      }
#line 520
      if (direction == 1) {
#line 521
        j = i;
      } else {
#line 523
        j = i + 1;
      }
#line 524
      k = (j + csa->n1) - 1;
      {
#line 524
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 524
        if (! (j < k)) {
#line 524
          goto while_break___4;
        }
#line 525
        arc_ptr->from = j;
#line 526
        arc_ptr->to = j + direction;
#line 527
        arc_ptr ++;
#line 524
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 529
      direction = - direction;
#line 519
      i += csa->n1;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 531
    i = 1;
    {
#line 531
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 531
      if (! (i <= csa->n1)) {
#line 531
        goto while_break___5;
      }
#line 532
      j = i + csa->n1;
#line 533
      if (direction == 1) {
        {
#line 534
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 534
          if (! (j < csa->n_node)) {
#line 534
            goto while_break___6;
          }
#line 535
          arc_ptr->from = j - csa->n1;
#line 536
          arc_ptr->to = j;
#line 537
          arc_ptr ++;
#line 534
          j += csa->n1;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
        {
#line 541
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 541
          if (! (j < csa->n_node)) {
#line 541
            goto while_break___7;
          }
#line 542
          arc_ptr->from = j - csa->n1;
#line 543
          arc_ptr->to = j;
#line 544
          arc_ptr ++;
#line 541
          j += csa->n1;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 547
      direction = - direction;
#line 531
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 550
  return (arc_ptr);
}
}
#line 553 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void gen_more_arcs(struct csa___2 *csa , struct arcs *arc_ptr ) 
{ 
  int i ;
  double ab[2] ;
  void *__cil_tmp5 ;

  {
#line 557
  ab[0] = 0.9;
#line 558
  ab[1] = (double )csa->n_node - 0.99;
#line 560
  i = csa->n_grid_arc;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! (i < csa->n_arc)) {
#line 560
      goto while_break;
    }
    {
#line 561
    arc_ptr->from = uniform(csa, (double *)(ab));
#line 562
    arc_ptr->to = uniform(csa, (double *)(ab));
    }
#line 563
    if (arc_ptr->from == arc_ptr->to) {
#line 564
      arc_ptr --;
#line 565
      i --;
    }
#line 560
    i ++;
#line 560
    arc_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  return;
}
}
#line 571 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void generate(struct csa___2 *csa ) 
{ 
  struct arcs *arc_ptr ;

  {
  {
#line 573
  arc_ptr = csa->arc_list;
#line 574
  arc_ptr = gen_basic_grid(csa, arc_ptr);
#line 575
  select_source_sinks(csa);
#line 576
  arc_ptr = gen_additional_arcs(csa, arc_ptr);
#line 577
  gen_more_arcs(csa, arc_ptr);
#line 578
  assign_costs(csa);
#line 579
  assign_capacities(csa);
#line 580
  assign_imbalance(csa);
  }
#line 581
  return;
}
}
#line 584 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void output(struct csa___2 *csa ) 
{ 
  struct arcs *arc_ptr ;
  struct imbalance *imb_ptr ;
  int i ;
  int tmp ;
  int tmp___0 ;
  double zero___1 ;
  glp_vertex *v ;
  double temp ;
  glp_vertex *v___0 ;
  double temp___0 ;
  glp_vertex *v___1 ;
  glp_arc *a ;
  glp_arc *tmp___1 ;
  double temp___1 ;
  double temp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 589
  if ((unsigned long )csa->G != (unsigned long )((void *)0)) {
#line 589
    goto skip;
  }
  {
#line 591
  _glp_lib_xprintf("c generated by GRIDGEN\n");
#line 592
  _glp_lib_xprintf("c seed %d\n", csa->seed_original);
#line 593
  _glp_lib_xprintf("c nodes %d\n", csa->n_node);
#line 594
  _glp_lib_xprintf("c grid size %d X %d\n", csa->n1, csa->n2);
#line 595
  _glp_lib_xprintf("c sources %d sinks %d\n", csa->n_source, csa->n_sink);
#line 596
  _glp_lib_xprintf("c avg. degree %d\n", csa->avg_degree);
#line 597
  _glp_lib_xprintf("c supply %d\n", csa->t_supply);
  }
  {
#line 599
  if (csa->arc_costs.distribution == 1) {
#line 599
    goto case_1;
  }
#line 604
  if (csa->arc_costs.distribution == 2) {
#line 604
    goto case_2;
  }
#line 608
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 600
  _glp_lib_xprintf("c arc costs: UNIFORM distr. min %d max %d\n", (int )csa->arc_costs.parameter[0],
                   (int )csa->arc_costs.parameter[1]);
  }
#line 603
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 605
  _glp_lib_xprintf("c arc costs: EXPONENTIAL distr. lambda %d\n", (int )csa->arc_costs.parameter[0]);
  }
#line 607
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 609
  if ((unsigned long )csa != (unsigned long )csa) {
#line 609
    tmp = 1;
  } else {
    {
#line 609
    _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c",
                     609);
#line 609
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 612
  if (csa->capacities.distribution == 1) {
#line 612
    goto case_1___0;
  }
#line 617
  if (csa->capacities.distribution == 2) {
#line 617
    goto case_2___0;
  }
#line 621
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 613
  _glp_lib_xprintf("c arc caps :  UNIFORM distr. min %d max %d\n", (int )csa->capacities.parameter[0],
                   (int )csa->capacities.parameter[1]);
  }
#line 616
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 618
  _glp_lib_xprintf("c arc caps :  EXPONENTIAL distr. %d lambda %d\n", (int )csa->capacities.parameter[0]);
  }
#line 620
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 622
  if ((unsigned long )csa != (unsigned long )csa) {
#line 622
    tmp___0 = 1;
  } else {
    {
#line 622
    _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c",
                     622);
#line 622
    tmp___0 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  skip: 
#line 624
  if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
    {
#line 625
    _glp_lib_xprintf("p min %d %d\n", csa->n_node, csa->n_arc);
    }
  } else {
    {
#line 627
    glp_add_vertices(csa->G, csa->n_node);
    }
#line 628
    if (csa->v_rhs >= 0) {
#line 629
      zero___1 = 0.0;
#line 630
      i = 1;
      {
#line 630
      while (1) {
        while_continue: /* CIL Label */ ;
#line 630
        if (! (i <= csa->n_node)) {
#line 630
          goto while_break;
        }
        {
#line 631
        v = *((csa->G)->v + i);
#line 632
        memcpy((void */* __restrict  */)((char *)v->data + csa->v_rhs), (void const   */* __restrict  */)(& zero___1),
               (size_t )sizeof(double ));
#line 630
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 637
  i = 0;
#line 637
  imb_ptr = csa->source_list;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (! (i < csa->n_source)) {
#line 637
      goto while_break___0;
    }
#line 638
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 639
      _glp_lib_xprintf("n %d %d\n", imb_ptr->node, imb_ptr->supply);
      }
    } else
#line 641
    if (csa->v_rhs >= 0) {
      {
#line 642
      temp = (double )imb_ptr->supply;
#line 643
      v___0 = *((csa->G)->v + imb_ptr->node);
#line 644
      memcpy((void */* __restrict  */)((char *)v___0->data + csa->v_rhs), (void const   */* __restrict  */)(& temp),
             (size_t )sizeof(double ));
      }
    }
#line 637
    i ++;
#line 637
    imb_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 648
  i = 0;
#line 648
  imb_ptr = csa->sink_list;
  {
#line 648
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 648
    if (! (i < csa->n_sink)) {
#line 648
      goto while_break___1;
    }
#line 649
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 650
      _glp_lib_xprintf("n %d %d\n", imb_ptr->node, imb_ptr->supply);
      }
    } else
#line 652
    if (csa->v_rhs >= 0) {
      {
#line 653
      temp___0 = (double )imb_ptr->supply;
#line 654
      v___1 = *((csa->G)->v + imb_ptr->node);
#line 655
      memcpy((void */* __restrict  */)((char *)v___1->data + csa->v_rhs), (void const   */* __restrict  */)(& temp___0),
             (size_t )sizeof(double ));
      }
    }
#line 648
    i ++;
#line 648
    imb_ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 660
  i = 0;
#line 660
  arc_ptr = csa->arc_list;
  {
#line 660
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 660
    if (! (i < csa->n_arc)) {
#line 660
      goto while_break___2;
    }
#line 661
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 662
      _glp_lib_xprintf("a %d %d 0 %d %d\n", arc_ptr->from, arc_ptr->to, arc_ptr->u,
                       arc_ptr->cost);
      }
    } else {
      {
#line 665
      tmp___1 = glp_add_arc(csa->G, arc_ptr->from, arc_ptr->to);
#line 665
      a = tmp___1;
      }
#line 666
      if (csa->a_cap >= 0) {
        {
#line 667
        temp___1 = (double )arc_ptr->u;
#line 668
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cap), (void const   */* __restrict  */)(& temp___1),
               (size_t )sizeof(double ));
        }
      }
#line 670
      if (csa->a_cost >= 0) {
        {
#line 671
        temp___2 = (double )arc_ptr->cost;
#line 672
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cost), (void const   */* __restrict  */)(& temp___2),
               (size_t )sizeof(double ));
        }
      }
    }
#line 660
    i ++;
#line 660
    arc_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 676
  return;
}
}
#line 679 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static double randy(struct csa___2 *csa ) 
{ 


  {
#line 683
  csa->seed = (16807 * csa->seed) % 2147483647;
#line 684
  if (csa->seed < 0) {
#line 684
    csa->seed = - csa->seed;
  }
#line 685
  return ((double )csa->seed * 4.6566128752459e-10);
}
}
#line 688 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static void select_source_sinks(struct csa___2 *csa ) 
{ 
  int i ;
  int *int_ptr ;
  int *temp_list ;
  struct imbalance *ptr ;
  double ab[2] ;
  void *tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 694
  ab[0] = 0.9;
#line 695
  ab[1] = (double )csa->n_node - 0.99;
#line 697
  tmp = _glp_lib_xcalloc(csa->n_node, (int )sizeof(int ));
#line 697
  temp_list = (int *)tmp;
#line 698
  i = 0;
#line 698
  int_ptr = temp_list;
  }
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (i < csa->n_node)) {
#line 698
      goto while_break;
    }
#line 699
    *int_ptr = 0;
#line 698
    i ++;
#line 698
    int_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  i = 0;
#line 701
  ptr = csa->source_list;
  {
#line 701
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 701
    if (! (i < csa->n_source)) {
#line 701
      goto while_break___0;
    }
    {
#line 702
    ptr->node = uniform(csa, (double *)(ab));
    }
#line 703
    if (*(temp_list + ptr->node) == 1) {
#line 704
      ptr --;
#line 705
      i --;
    } else {
#line 708
      *(temp_list + ptr->node) = 1;
    }
#line 701
    i ++;
#line 701
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 711
  i = 0;
#line 711
  ptr = csa->sink_list;
  {
#line 711
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 711
    if (! (i < csa->n_sink)) {
#line 711
      goto while_break___1;
    }
    {
#line 712
    ptr->node = uniform(csa, (double *)(ab));
    }
#line 713
    if (*(temp_list + ptr->node) == 1) {
#line 714
      ptr --;
#line 715
      i --;
    } else {
#line 718
      *(temp_list + ptr->node) = 1;
    }
#line 711
    i ++;
#line 711
    ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 720
  _glp_lib_xfree((void *)temp_list);
  }
#line 721
  return;
}
}
#line 724 "/home/wslee/benchmarks/glpk-4.38/src/glpnet04.c"
static int uniform(struct csa___2 *csa , double *a ) 
{ 
  double tmp ;

  {
  {
#line 726
  tmp = randy(csa);
  }
#line 726
  return ((int )(((*(a + 1) - *(a + 0)) * tmp + *(a + 0)) + 0.5));
}
}
#line 836 "./../include/glpk.h"
int glp_netgen(glp_graph *G_ , int _v_rhs , int _a_cap , int _a_cost , int const   *parm ) ;
#line 153 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void cresup(struct csa___3 *csa ) ;
#line 154
static void chain(struct csa___3 *csa , int lpick , int lsorc ) ;
#line 155
static void chnarc(struct csa___3 *csa , int lsorc ) ;
#line 156
static void sort(struct csa___3 *csa ) ;
#line 157
static void pickj(struct csa___3 *csa , int it ) ;
#line 158
static void assign(struct csa___3 *csa ) ;
#line 159
static void setran(struct csa___3 *csa , int iseed ) ;
#line 160
static int iran(struct csa___3 *csa , int ilow , int ihigh ) ;
#line 162 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
int glp_netgen(glp_graph *G_ , int _v_rhs , int _a_cap , int _a_cost , int const   *parm ) 
{ 
  struct csa___3 _csa ;
  struct csa___3 *csa ;
  int iseed ;
  int nprob ;
  int ntsorc ;
  int ntsink ;
  int iphic ;
  int i ;
  int nskel ;
  int nltr ;
  int ltsink ;
  int ntrans ;
  int npsink ;
  int nftr ;
  int npsorc ;
  int ntravl ;
  int ntrrem ;
  int lsorc ;
  int lpick ;
  int nsksr ;
  int nsrchn ;
  int j ;
  int item ;
  int l ;
  int ks ;
  int k ;
  int ksp ;
  int li ;
  int n ;
  int ii ;
  int it ;
  int ih ;
  int icap ;
  int jcap ;
  int icost ;
  int jcost ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  double zero___1 ;
  glp_vertex *v ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  double temp ;
  glp_vertex *v___0 ;
  glp_arc *a ;
  glp_arc *tmp___8 ;
  double temp___0 ;
  double temp___1 ;
  double temp___2 ;
  glp_vertex *v___1 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
#line 164
  csa = & _csa;
#line 169
  csa->G = G_;
#line 170
  csa->v_rhs = _v_rhs;
#line 171
  csa->a_cap = _a_cap;
#line 172
  csa->a_cost = _a_cost;
#line 173
  if ((unsigned long )csa->G != (unsigned long )((void *)0)) {
#line 174
    if (csa->v_rhs >= 0) {
#line 174
      if (csa->v_rhs > (csa->G)->v_size - (int )sizeof(double )) {
        {
#line 175
        tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c",
                               175);
#line 175
        (*tmp)("glp_netgen: v_rhs = %d; invalid offset\n", csa->v_rhs);
        }
      }
    }
#line 176
    if (csa->a_cap >= 0) {
#line 176
      if (csa->a_cap > (csa->G)->a_size - (int )sizeof(double )) {
        {
#line 177
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c",
                                   177);
#line 177
        (*tmp___0)("glp_netgen: a_cap = %d; invalid offset\n", csa->a_cap);
        }
      }
    }
#line 178
    if (csa->a_cost >= 0) {
#line 178
      if (csa->a_cost > (csa->G)->a_size - (int )sizeof(double )) {
        {
#line 179
        tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c",
                                   179);
#line 179
        (*tmp___1)("glp_netgen: a_cost = %d; invalid offset\n", csa->a_cost);
        }
      }
    }
  }
#line 183
  iseed = (int )*(parm + 1);
#line 184
  nprob = (int )*(parm + 2);
#line 185
  if (iseed <= 0) {
#line 185
    iseed = 13502460;
  }
  {
#line 186
  setran(csa, iseed);
#line 188
  csa->nodes = (int )*(parm + 3);
#line 189
  csa->nsorc = (int )*(parm + 4);
#line 190
  csa->nsink = (int )*(parm + 5);
#line 191
  csa->iarcs = (int )*(parm + 6);
#line 192
  csa->mincst = (int )*(parm + 7);
#line 193
  csa->maxcst = (int )*(parm + 8);
#line 194
  csa->itsup = (int )*(parm + 9);
#line 195
  ntsorc = (int )*(parm + 10);
#line 196
  ntsink = (int )*(parm + 11);
#line 197
  iphic = (int )*(parm + 12);
#line 198
  csa->ipcap = (int )*(parm + 13);
#line 199
  csa->mincap = (int )*(parm + 14);
#line 200
  csa->maxcap = (int )*(parm + 15);
  }
#line 202
  if (10 <= csa->nodes) {
#line 202
    if (! (csa->nodes <= 100000)) {
#line 203
      ret = 1;
#line 204
      goto done;
    }
  } else {
#line 203
    ret = 1;
#line 204
    goto done;
  }
#line 207
  if (csa->nsorc >= 0) {
#line 207
    if (csa->nsink >= 0) {
#line 207
      if (! (csa->nsorc + csa->nsink <= csa->nodes)) {
#line 208
        ret = 2;
#line 209
        goto done;
      }
    } else {
#line 208
      ret = 2;
#line 209
      goto done;
    }
  } else {
#line 208
    ret = 2;
#line 209
    goto done;
  }
#line 211
  if (csa->iarcs < 0) {
#line 212
    ret = 3;
#line 213
    goto done;
  }
#line 215
  if (csa->mincst > csa->maxcst) {
#line 216
    ret = 4;
#line 217
    goto done;
  }
#line 219
  if (csa->itsup < 0) {
#line 220
    ret = 5;
#line 221
    goto done;
  }
#line 223
  if (0 <= ntsorc) {
#line 223
    if (! (ntsorc <= csa->nsorc)) {
#line 224
      ret = 6;
#line 225
      goto done;
    }
  } else {
#line 224
    ret = 6;
#line 225
    goto done;
  }
#line 227
  if (0 <= ntsink) {
#line 227
    if (! (ntsink <= csa->nsink)) {
#line 228
      ret = 7;
#line 229
      goto done;
    }
  } else {
#line 228
    ret = 7;
#line 229
    goto done;
  }
#line 231
  if (0 <= iphic) {
#line 231
    if (! (iphic <= 100)) {
#line 232
      ret = 8;
#line 233
      goto done;
    }
  } else {
#line 232
    ret = 8;
#line 233
    goto done;
  }
#line 235
  if (0 <= csa->ipcap) {
#line 235
    if (! (csa->ipcap <= 100)) {
#line 236
      ret = 9;
#line 237
      goto done;
    }
  } else {
#line 236
    ret = 9;
#line 237
    goto done;
  }
#line 239
  if (csa->mincap > csa->maxcap) {
#line 240
    ret = 10;
#line 241
    goto done;
  }
#line 244
  if ((unsigned long )csa->G != (unsigned long )((void *)0)) {
    {
#line 245
    glp_erase_graph(csa->G, (csa->G)->v_size, (csa->G)->a_size);
#line 246
    glp_add_vertices(csa->G, csa->nodes);
    }
#line 247
    if (csa->v_rhs >= 0) {
#line 248
      zero___1 = 0.0;
#line 249
      i = 1;
      {
#line 249
      while (1) {
        while_continue: /* CIL Label */ ;
#line 249
        if (! (i <= csa->nodes)) {
#line 249
          goto while_break;
        }
        {
#line 250
        v = *((csa->G)->v + i);
#line 251
        memcpy((void */* __restrict  */)((char *)v->data + csa->v_rhs), (void const   */* __restrict  */)(& zero___1),
               (size_t )sizeof(double ));
#line 249
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 256
  tmp___2 = _glp_lib_xcalloc(1 + csa->nodes, (int )sizeof(int ));
#line 256
  csa->ipred = (int *)tmp___2;
#line 257
  tmp___3 = _glp_lib_xcalloc(1 + csa->nodes, (int )sizeof(int ));
#line 257
  csa->ihead = (int *)tmp___3;
#line 258
  tmp___4 = _glp_lib_xcalloc(1 + csa->nodes, (int )sizeof(int ));
#line 258
  csa->itail = (int *)tmp___4;
#line 259
  tmp___5 = _glp_lib_xcalloc(1 + csa->nodes, (int )sizeof(int ));
#line 259
  csa->iflag = (int *)tmp___5;
#line 260
  tmp___6 = _glp_lib_xcalloc(1 + csa->nodes, (int )sizeof(int ));
#line 260
  csa->isup = (int *)tmp___6;
#line 261
  tmp___7 = _glp_lib_xcalloc(1 + csa->nodes, (int )sizeof(int ));
#line 261
  csa->lsinks = (int *)tmp___7;
  }
#line 263
  if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
    {
#line 264
    _glp_lib_xprintf("BEGIN\n");
#line 265
    _glp_lib_xprintf("NETGEN PROBLEM%8d%10s%10d NODES AND%10d ARCS\n", nprob, "",
                     csa->nodes, csa->iarcs);
#line 267
    _glp_lib_xprintf("USER:%11d%11d%11d%11d%11d%11d\nDATA:%11d%11d%11d%11d%11d%11d\n",
                     iseed, csa->nsorc, csa->nsink, csa->mincst, csa->maxcst, csa->itsup,
                     ntsorc, ntsink, iphic, csa->ipcap, csa->mincap, csa->maxcap);
    }
  } else {
    {
#line 273
    glp_set_graph_name(csa->G, "NETGEN");
    }
  }
#line 275
  csa->narcs = 0;
#line 276
  nskel = 0;
#line 277
  nltr = csa->nodes - csa->nsink;
#line 278
  ltsink = nltr + ntsink;
#line 279
  ntrans = nltr - csa->nsorc;
#line 280
  csa->nfsink = nltr + 1;
#line 281
  csa->nonsor = (csa->nodes - csa->nsorc) + ntsorc;
#line 282
  npsink = csa->nsink - ntsink;
#line 283
  csa->nodlft = (csa->nodes - csa->nsink) + ntsink;
#line 284
  nftr = csa->nsorc + 1;
#line 285
  csa->nftsor = (csa->nsorc - ntsorc) + 1;
#line 286
  npsorc = csa->nsorc - ntsorc;
#line 288
  if (npsorc + npsink == csa->nodes) {
#line 288
    if (npsorc == npsink) {
#line 288
      if (csa->itsup == csa->nsorc) {
        {
#line 290
        assign(csa);
#line 291
        nskel = csa->nsorc;
        }
#line 292
        goto L390;
      }
    }
  }
  {
#line 294
  cresup(csa);
  }
#line 296
  if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
    {
#line 297
    _glp_lib_xprintf("SUPPLY\n");
#line 298
    i = 1;
    }
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 298
      if (! (i <= csa->nsorc)) {
#line 298
        goto while_break___0;
      }
      {
#line 299
      _glp_lib_xprintf("%6s%6d%18s%10d\n", "", i, "", *(csa->isup + i));
#line 298
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 300
    _glp_lib_xprintf("ARCS\n");
    }
  } else
#line 303
  if (csa->v_rhs >= 0) {
#line 304
    i = 1;
    {
#line 304
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 304
      if (! (i <= csa->nsorc)) {
#line 304
        goto while_break___1;
      }
      {
#line 305
      temp = (double )*(csa->isup + i);
#line 306
      v___0 = *((csa->G)->v + i);
#line 307
      memcpy((void */* __restrict  */)((char *)v___0->data + csa->v_rhs), (void const   */* __restrict  */)(& temp),
             (size_t )sizeof(double ));
#line 304
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 312
  i = 1;
  {
#line 312
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 312
    if (! (i <= csa->nsorc)) {
#line 312
      goto while_break___2;
    }
#line 313
    *(csa->ipred + i) = i;
#line 312
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 314
  if (ntrans == 0) {
#line 314
    goto L170;
  }
#line 316
  *(csa->ipred + 0) = nftr;
#line 317
  *(csa->ipred + nltr) = 0;
#line 318
  i = nftr;
  {
#line 318
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 318
    if (! (i < nltr)) {
#line 318
      goto while_break___3;
    }
#line 319
    *(csa->ipred + i) = i + 1;
#line 318
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 321
  ntravl = (6 * ntrans) / 10;
#line 322
  ntrrem = ntrans - ntravl;
  L140: 
#line 323
  lsorc = 1;
  {
#line 324
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 324
    if (! (ntravl != 0)) {
#line 324
      goto while_break___4;
    }
    {
#line 325
    lpick = iran(csa, 1, ntravl + ntrrem);
#line 326
    ntravl --;
#line 327
    chain(csa, lpick, lsorc);
    }
#line 328
    if (lsorc == csa->nsorc) {
#line 328
      goto L140;
    }
#line 329
    lsorc ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 332
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 332
    if (! (ntrrem != 0)) {
#line 332
      goto while_break___5;
    }
    {
#line 334
    lpick = iran(csa, 1, ntrrem);
#line 335
    ntrrem --;
#line 336
    lsorc = iran(csa, 1, csa->nsorc);
#line 337
    chain(csa, lpick, lsorc);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  L170: 
#line 340
  i = csa->nfsink;
  {
#line 340
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 340
    if (! (i <= csa->nodes)) {
#line 340
      goto while_break___6;
    }
#line 341
    *(csa->ipred + i) = 0;
#line 340
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 345
  lsorc = 1;
  {
#line 345
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 345
    if (! (lsorc <= csa->nsorc)) {
#line 345
      goto while_break___7;
    }
    {
#line 346
    chnarc(csa, lsorc);
#line 347
    i = csa->nfsink;
    }
    {
#line 347
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 347
      if (! (i <= csa->nodes)) {
#line 347
        goto while_break___8;
      }
#line 348
      *(csa->iflag + i) = 0;
#line 347
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 351
    if (ntrans != 0) {
#line 352
      nsksr = ((csa->nsort * 2) * csa->nsink) / ntrans;
    } else {
#line 354
      nsksr = csa->nsink / csa->nsorc + 1;
    }
#line 355
    if (nsksr < 2) {
#line 355
      nsksr = 2;
    }
#line 356
    if (nsksr > csa->nsink) {
#line 356
      nsksr = csa->nsink;
    }
#line 357
    nsrchn = csa->nsort;
#line 359
    csa->ktl = csa->nsink;
#line 360
    j = 1;
    {
#line 360
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 360
      if (! (j <= nsksr)) {
#line 360
        goto while_break___9;
      }
      {
#line 361
      item = iran(csa, 1, csa->ktl);
#line 362
      (csa->ktl) --;
#line 363
      l = csa->nfsink;
      }
      {
#line 363
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 363
        if (! (l <= csa->nodes)) {
#line 363
          goto while_break___10;
        }
#line 364
        if (*(csa->iflag + l) != 1) {
#line 365
          item --;
#line 366
          if (item == 0) {
#line 366
            goto L230;
          }
        }
#line 363
        l ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 369
      goto while_break___9;
      L230: 
#line 370
      *(csa->lsinks + j) = l;
#line 371
      *(csa->iflag + l) = 1;
#line 360
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 375
    if (lsorc == csa->nsorc) {
#line 376
      j = csa->nfsink;
      {
#line 376
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 376
        if (! (j <= csa->nodes)) {
#line 376
          goto while_break___11;
        }
#line 377
        if (*(csa->ipred + j) == 0) {
#line 377
          if (*(csa->iflag + j) != 1) {
#line 378
            nsksr ++;
#line 379
            *(csa->lsinks + nsksr) = j;
#line 380
            *(csa->iflag + j) = 1;
          }
        }
#line 376
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 385
    ks = *(csa->isup + lsorc) / nsksr;
#line 386
    k = *(csa->ipred + lsorc);
#line 387
    i = 1;
    {
#line 387
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 387
      if (! (i <= nsksr)) {
#line 387
        goto while_break___12;
      }
      {
#line 388
      (csa->nsort) ++;
#line 389
      ksp = iran(csa, 1, ks);
#line 390
      j = iran(csa, 1, nsksr);
#line 391
      *(csa->itail + csa->nsort) = k;
#line 392
      li = *(csa->lsinks + i);
#line 393
      *(csa->ihead + csa->nsort) = li;
#line 394
      *(csa->ipred + li) += ksp;
#line 395
      li = *(csa->lsinks + j);
#line 396
      *(csa->ipred + li) += ks - ksp;
#line 397
      n = iran(csa, 1, nsrchn);
#line 398
      k = lsorc;
#line 399
      ii = 1;
      }
      {
#line 399
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 399
        if (! (ii <= n)) {
#line 399
          goto while_break___13;
        }
#line 400
        k = *(csa->ipred + k);
#line 399
        ii ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 387
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 402
    li = *(csa->lsinks + 1);
#line 403
    *(csa->ipred + li) += *(csa->isup + lsorc) - ks * nsksr;
#line 404
    nskel += csa->nsort;
#line 407
    sort(csa);
#line 410
    i = 1;
#line 411
    *(csa->itail + (csa->nsort + 1)) = 0;
    }
    L300: 
#line 412
    j = csa->nftsor;
    {
#line 412
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 412
      if (! (j <= csa->nodes)) {
#line 412
        goto while_break___14;
      }
#line 413
      *(csa->iflag + j) = 0;
#line 412
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 414
    csa->ktl = csa->nonsor - 1;
#line 415
    it = *(csa->itail + i);
#line 416
    *(csa->iflag + it) = 1;
    L320: 
    {
#line 417
    ih = *(csa->ihead + i);
#line 418
    *(csa->iflag + ih) = 1;
#line 419
    (csa->narcs) ++;
#line 420
    (csa->ktl) --;
#line 422
    icap = csa->itsup;
#line 423
    jcap = iran(csa, 1, 100);
    }
#line 424
    if (jcap <= csa->ipcap) {
#line 425
      icap = *(csa->isup + lsorc);
#line 426
      if (csa->mincap > icap) {
#line 426
        icap = csa->mincap;
      }
    }
    {
#line 430
    icost = csa->maxcst;
#line 431
    jcost = iran(csa, 1, 100);
    }
#line 432
    if (jcost > iphic) {
      {
#line 433
      icost = iran(csa, csa->mincst, csa->maxcst);
      }
    }
#line 434
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 435
      _glp_lib_xprintf("%6s%6d%6d%2s%10d%10d\n", "", it, ih, "", icost, icap);
      }
    } else {
      {
#line 438
      tmp___8 = glp_add_arc(csa->G, it, ih);
#line 438
      a = tmp___8;
      }
#line 439
      if (csa->a_cap >= 0) {
        {
#line 440
        temp___0 = (double )icap;
#line 441
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cap), (void const   */* __restrict  */)(& temp___0),
               (size_t )sizeof(double ));
        }
      }
#line 443
      if (csa->a_cost >= 0) {
        {
#line 444
        temp___1 = (double )icost;
#line 445
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cost), (void const   */* __restrict  */)(& temp___1),
               (size_t )sizeof(double ));
        }
      }
    }
#line 448
    i ++;
#line 449
    if (*(csa->itail + i) == it) {
#line 449
      goto L320;
    }
    {
#line 450
    pickj(csa, it);
    }
#line 451
    if (i <= csa->nsort) {
#line 451
      goto L300;
    }
#line 345
    lsorc ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 454
  if (ntsink != 0) {
#line 455
    i = csa->nfsink;
    {
#line 455
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 455
      if (! (i <= ltsink)) {
#line 455
        goto while_break___15;
      }
#line 456
      j = csa->nftsor;
      {
#line 456
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 456
        if (! (j <= csa->nodes)) {
#line 456
          goto while_break___16;
        }
#line 457
        *(csa->iflag + j) = 0;
#line 456
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 458
      csa->ktl = csa->nonsor - 1;
#line 459
      *(csa->iflag + i) = 1;
#line 460
      pickj(csa, i);
#line 455
      i ++;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
  }
  L390: 
#line 464
  if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
    {
#line 465
    _glp_lib_xprintf("DEMAND\n");
#line 466
    i = csa->nfsink;
    }
    {
#line 466
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 466
      if (! (i <= csa->nodes)) {
#line 466
        goto while_break___17;
      }
      {
#line 467
      _glp_lib_xprintf("%6s%6d%18s%10d\n", "", i, "", *(csa->ipred + i));
#line 466
      i ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 468
    _glp_lib_xprintf("END\n");
    }
  } else
#line 471
  if (csa->v_rhs >= 0) {
#line 472
    i = csa->nfsink;
    {
#line 472
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 472
      if (! (i <= csa->nodes)) {
#line 472
        goto while_break___18;
      }
      {
#line 473
      temp___2 = - ((double )*(csa->ipred + i));
#line 474
      v___1 = *((csa->G)->v + i);
#line 475
      memcpy((void */* __restrict  */)((char *)v___1->data + csa->v_rhs), (void const   */* __restrict  */)(& temp___2),
             (size_t )sizeof(double ));
#line 472
      i ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
  }
  {
#line 480
  _glp_lib_xfree((void *)csa->ipred);
#line 481
  _glp_lib_xfree((void *)csa->ihead);
#line 482
  _glp_lib_xfree((void *)csa->itail);
#line 483
  _glp_lib_xfree((void *)csa->iflag);
#line 484
  _glp_lib_xfree((void *)csa->isup);
#line 485
  _glp_lib_xfree((void *)csa->lsinks);
#line 487
  ret = 0;
  }
  done: 
#line 488
  return (ret);
}
}
#line 495 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void cresup(struct csa___3 *csa ) 
{ 
  int i ;
  int j ;
  int ks ;
  int ksp ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 497
  if (csa->itsup > csa->nsorc) {
#line 497
    tmp = 1;
  } else {
    {
#line 497
    _glp_lib_xassert("itsup > nsorc", "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c",
                     497);
#line 497
    tmp = 1;
    }
  }
#line 498
  ks = csa->itsup / csa->nsorc;
#line 499
  i = 1;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i <= csa->nsorc)) {
#line 499
      goto while_break;
    }
#line 500
    *(csa->isup + i) = 0;
#line 499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  i = 1;
  {
#line 501
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 501
    if (! (i <= csa->nsorc)) {
#line 501
      goto while_break___0;
    }
    {
#line 502
    ksp = iran(csa, 1, ks);
#line 503
    j = iran(csa, 1, csa->nsorc);
#line 504
    *(csa->isup + i) += ksp;
#line 505
    *(csa->isup + j) += ks - ksp;
#line 501
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 507
  j = iran(csa, 1, csa->nsorc);
#line 508
  *(csa->isup + j) += csa->itsup - ks * csa->nsorc;
  }
#line 509
  return;
}
}
#line 516 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void chain(struct csa___3 *csa , int lpick , int lsorc ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int m ;

  {
#line 518
  k = 0;
#line 519
  m = *(csa->ipred + 0);
#line 520
  i = 1;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i <= lpick)) {
#line 520
      goto while_break;
    }
#line 521
    l = k;
#line 522
    k = m;
#line 523
    m = *(csa->ipred + k);
#line 520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  *(csa->ipred + l) = m;
#line 526
  j = *(csa->ipred + lsorc);
#line 527
  *(csa->ipred + k) = j;
#line 528
  *(csa->ipred + lsorc) = k;
#line 529
  return;
}
}
#line 536 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void chnarc(struct csa___3 *csa , int lsorc ) 
{ 
  int ito ;
  int ifrom ;

  {
#line 538
  csa->nsort = 0;
#line 539
  ito = *(csa->ipred + lsorc);
  L10: 
#line 540
  if (ito == lsorc) {
#line 540
    return;
  }
#line 541
  (csa->nsort) ++;
#line 542
  ifrom = *(csa->ipred + ito);
#line 543
  *(csa->ihead + csa->nsort) = ito;
#line 544
  *(csa->itail + csa->nsort) = ifrom;
#line 545
  ito = ifrom;
#line 546
  goto L10;
}
}
#line 553 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void sort(struct csa___3 *csa ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int m ;
  int n ;
  int it ;

  {
#line 555
  n = csa->nsort;
#line 556
  m = n;
  L10: 
#line 557
  m /= 2;
#line 558
  if (m == 0) {
#line 558
    return;
  }
#line 559
  k = n - m;
#line 560
  j = 1;
  L20: 
#line 561
  i = j;
  L30: 
#line 562
  l = i + m;
#line 563
  if (*(csa->itail + i) <= *(csa->itail + l)) {
#line 563
    goto L40;
  }
#line 564
  it = *(csa->itail + i);
#line 565
  *(csa->itail + i) = *(csa->itail + l);
#line 566
  *(csa->itail + l) = it;
#line 567
  it = *(csa->ihead + i);
#line 568
  *(csa->ihead + i) = *(csa->ihead + l);
#line 569
  *(csa->ihead + l) = it;
#line 570
  i -= m;
#line 571
  if (i >= 1) {
#line 571
    goto L30;
  }
  L40: 
#line 572
  j ++;
#line 573
  if (j <= k) {
#line 573
    goto L20;
  }
#line 574
  goto L10;
}
}
#line 582 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void pickj(struct csa___3 *csa , int it ) 
{ 
  int j ;
  int k ;
  int l ;
  int nn ;
  int nupbnd ;
  int icap ;
  int jcap ;
  int icost ;
  glp_arc *a ;
  glp_arc *tmp ;
  double temp ;
  double temp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 584
  if ((csa->nodlft - 1) * 2 > (csa->iarcs - csa->narcs) - 1) {
#line 585
    (csa->nodlft) --;
#line 586
    return;
  }
#line 588
  if ((((((csa->iarcs - csa->narcs) + csa->nonsor) - csa->ktl) - 1) / csa->nodlft - csa->nonsor) + 1 >= 0) {
#line 589
    k = csa->nonsor;
  } else {
#line 591
    nupbnd = (((csa->iarcs - csa->narcs) - csa->nodlft) / csa->nodlft) * 2;
    L40: 
    {
#line 592
    k = iran(csa, 1, nupbnd);
    }
#line 593
    if (csa->nodlft == 1) {
#line 593
      k = csa->iarcs - csa->narcs;
    }
#line 594
    if ((csa->nodlft - 1) * (csa->nonsor - 1) < (csa->iarcs - csa->narcs) - k) {
#line 594
      goto L40;
    }
  }
#line 596
  (csa->nodlft) --;
#line 597
  j = 1;
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! (j <= k)) {
#line 597
      goto while_break;
    }
    {
#line 598
    nn = iran(csa, 1, csa->ktl);
#line 599
    (csa->ktl) --;
#line 600
    l = csa->nftsor;
    }
    {
#line 600
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 600
      if (! (l <= csa->nodes)) {
#line 600
        goto while_break___0;
      }
#line 601
      if (*(csa->iflag + l) != 1) {
#line 602
        nn --;
#line 603
        if (nn == 0) {
#line 603
          goto L70;
        }
      }
#line 600
      l ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 606
    return;
    L70: 
    {
#line 607
    *(csa->iflag + l) = 1;
#line 608
    icap = csa->itsup;
#line 609
    jcap = iran(csa, 1, 100);
    }
#line 610
    if (jcap <= csa->ipcap) {
      {
#line 611
      icap = iran(csa, csa->mincap, csa->maxcap);
      }
    }
    {
#line 612
    icost = iran(csa, csa->mincst, csa->maxcst);
    }
#line 613
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 614
      _glp_lib_xprintf("%6s%6d%6d%2s%10d%10d\n", "", it, l, "", icost, icap);
      }
    } else {
      {
#line 617
      tmp = glp_add_arc(csa->G, it, l);
#line 617
      a = tmp;
      }
#line 618
      if (csa->a_cap >= 0) {
        {
#line 619
        temp = (double )icap;
#line 620
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cap), (void const   */* __restrict  */)(& temp),
               (size_t )sizeof(double ));
        }
      }
#line 622
      if (csa->a_cost >= 0) {
        {
#line 623
        temp___0 = (double )icost;
#line 624
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cost), (void const   */* __restrict  */)(& temp___0),
               (size_t )sizeof(double ));
        }
      }
    }
#line 627
    (csa->narcs) ++;
#line 597
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 636 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void assign(struct csa___3 *csa ) 
{ 
  int i ;
  int it ;
  int nn ;
  int l ;
  int ll ;
  int icost ;
  double temp ;
  glp_vertex *v ;
  glp_arc *a ;
  glp_arc *tmp ;
  double temp___0 ;
  double temp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 638
  if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
    {
#line 639
    _glp_lib_xprintf("SUPPLY\n");
    }
  }
#line 640
  i = 1;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! (i <= csa->nsorc)) {
#line 640
      goto while_break;
    }
#line 641
    *(csa->isup + i) = 1;
#line 642
    *(csa->iflag + i) = 0;
#line 643
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 644
      _glp_lib_xprintf("%6s%6d%18s%10d\n", "", i, "", *(csa->isup + i));
      }
    } else
#line 646
    if (csa->v_rhs >= 0) {
      {
#line 647
      temp = (double )*(csa->isup + i);
#line 648
      v = *((csa->G)->v + i);
#line 649
      memcpy((void */* __restrict  */)((char *)v->data + csa->v_rhs), (void const   */* __restrict  */)(& temp),
             (size_t )sizeof(double ));
      }
    }
#line 640
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
    {
#line 654
    _glp_lib_xprintf("ARCS\n");
    }
  }
#line 655
  i = csa->nfsink;
  {
#line 655
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 655
    if (! (i <= csa->nodes)) {
#line 655
      goto while_break___0;
    }
#line 656
    *(csa->ipred + i) = 1;
#line 655
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 657
  it = 1;
  {
#line 657
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 657
    if (! (it <= csa->nsorc)) {
#line 657
      goto while_break___1;
    }
#line 658
    i = csa->nfsink;
    {
#line 658
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 658
      if (! (i <= csa->nodes)) {
#line 658
        goto while_break___2;
      }
#line 659
      *(csa->iflag + i) = 0;
#line 658
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 660
    csa->ktl = csa->nsink - 1;
#line 661
    nn = iran(csa, 1, (csa->nsink - it) + 1);
#line 662
    l = 1;
    }
    {
#line 662
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 662
      if (! (l <= csa->nsorc)) {
#line 662
        goto while_break___3;
      }
#line 663
      if (*(csa->iflag + l) != 1) {
#line 664
        nn --;
#line 665
        if (nn == 0) {
#line 665
          goto while_break___3;
        }
      }
#line 662
      l ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 668
    (csa->narcs) ++;
#line 669
    ll = csa->nsorc + l;
#line 670
    icost = iran(csa, csa->mincst, csa->maxcst);
    }
#line 671
    if ((unsigned long )csa->G == (unsigned long )((void *)0)) {
      {
#line 672
      _glp_lib_xprintf("%6s%6d%6d%2s%10d%10d\n", "", it, ll, "", icost, *(csa->isup + 1));
      }
    } else {
      {
#line 675
      tmp = glp_add_arc(csa->G, it, ll);
#line 675
      a = tmp;
      }
#line 676
      if (csa->a_cap >= 0) {
        {
#line 677
        temp___0 = (double )*(csa->isup + 1);
#line 678
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cap), (void const   */* __restrict  */)(& temp___0),
               (size_t )sizeof(double ));
        }
      }
#line 680
      if (csa->a_cost >= 0) {
        {
#line 681
        temp___1 = (double )icost;
#line 682
        memcpy((void */* __restrict  */)((char *)a->data + csa->a_cost), (void const   */* __restrict  */)(& temp___1),
               (size_t )sizeof(double ));
        }
      }
    }
    {
#line 685
    *(csa->iflag + l) = 1;
#line 686
    *(csa->iflag + ll) = 1;
#line 687
    pickj(csa, it);
#line 657
    it ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 689
  return;
}
}
#line 706 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static void setran(struct csa___3 *csa , int iseed ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 707
  if (iseed >= 1) {
#line 707
    tmp = 1;
  } else {
    {
#line 707
    _glp_lib_xassert("iseed >= 1", "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c",
                     707);
#line 707
    tmp = 1;
    }
  }
#line 708
  csa->mult = 16807;
#line 709
  csa->modul = 2147483647;
#line 710
  csa->i15 = 1 << 15;
#line 711
  csa->i16 = 1 << 16;
#line 712
  csa->jran = iseed;
#line 713
  return;
}
}
#line 720 "/home/wslee/benchmarks/glpk-4.38/src/glpnet03.c"
static int iran(struct csa___3 *csa , int ilow , int ihigh ) 
{ 
  int ixhi ;
  int ixlo ;
  int ixalo ;
  int leftlo ;
  int ixahi ;
  int ifulhi ;
  int irtlo ;
  int iover ;
  int irthi ;
  int j ;

  {
#line 723
  ixhi = csa->jran / csa->i16;
#line 724
  ixlo = csa->jran - ixhi * csa->i16;
#line 725
  ixalo = ixlo * csa->mult;
#line 726
  leftlo = ixalo / csa->i16;
#line 727
  ixahi = ixhi * csa->mult;
#line 728
  ifulhi = ixahi + leftlo;
#line 729
  irtlo = ixalo - leftlo * csa->i16;
#line 730
  iover = ifulhi / csa->i15;
#line 731
  irthi = ifulhi - iover * csa->i15;
#line 732
  csa->jran = ((irtlo - csa->modul) + irthi * csa->i16) + iover;
#line 733
  if (csa->jran < 0) {
#line 733
    csa->jran += csa->modul;
  }
#line 734
  j = (ihigh - ilow) + 1;
#line 735
  if (j > 0) {
#line 736
    return (csa->jran % j + ilow);
  } else {
#line 738
    return (ihigh);
  }
}
}
#line 33 "/home/wslee/benchmarks/glpk-4.38/src/glpnet.h"
int _glp_mc13d(int n , int const   *icn , int const   *ip , int const   *lenr , int *ior ,
               int *ib , int *lowl , int *numb , int *prev ) ;
#line 103 "/home/wslee/benchmarks/glpk-4.38/src/glpnet02.c"
int _glp_mc13d(int n , int const   *icn , int const   *ip , int const   *lenr , int *ior ,
               int *ib , int *lowl , int *numb , int *prev ) 
{ 
  int *arp ;
  int dummy ;
  int i ;
  int i1 ;
  int i2 ;
  int icnt ;
  int ii ;
  int isn ;
  int ist ;
  int ist1 ;
  int iv ;
  int iw ;
  int j ;
  int lcnt ;
  int nnm1 ;
  int num ;
  int stp ;
  int tmp ;
  int tmp___0 ;

  {
#line 105
  arp = ior;
#line 110
  icnt = 0;
#line 112
  num = 0;
#line 113
  nnm1 = (n + n) - 1;
#line 115
  j = 1;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (j <= n)) {
#line 115
      goto while_break;
    }
#line 116
    *(numb + j) = 0;
#line 117
    *(arp + j) = (int )(*(lenr + j) - 1);
#line 115
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  isn = 1;
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! (isn <= n)) {
#line 119
      goto while_break___0;
    }
#line 121
    if (*(numb + isn) != 0) {
#line 121
      goto __Cont;
    }
#line 122
    iv = isn;
#line 125
    ist = 1;
#line 127
    tmp = 1;
#line 127
    *(numb + iv) = tmp;
#line 127
    *(lowl + iv) = tmp;
#line 128
    *(ib + n) = iv;
#line 131
    dummy = 1;
    {
#line 131
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 131
      if (! (dummy <= nnm1)) {
#line 131
        goto while_break___1;
      }
#line 132
      i1 = *(arp + iv);
#line 134
      if (i1 >= 0) {
#line 135
        i2 = (int )((*(ip + iv) + *(lenr + iv)) - 1);
#line 136
        i1 = i2 - i1;
#line 139
        ii = i1;
        {
#line 139
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 139
          if (! (ii <= i2)) {
#line 139
            goto while_break___2;
          }
#line 140
          iw = (int )*(icn + ii);
#line 142
          if (*(numb + iw) == 0) {
#line 142
            goto L70;
          }
#line 144
          if (*(lowl + iw) < *(lowl + iv)) {
#line 144
            *(lowl + iv) = *(lowl + iw);
          }
#line 139
          ii ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 147
        *(arp + iv) = -1;
      }
#line 150
      if (*(lowl + iv) < *(numb + iv)) {
#line 150
        goto L60;
      }
#line 152
      num ++;
#line 153
      ist1 = (n + 1) - ist;
#line 154
      lcnt = icnt + 1;
#line 157
      stp = ist1;
      {
#line 157
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 157
        if (! (stp <= n)) {
#line 157
          goto while_break___3;
        }
#line 158
        iw = *(ib + stp);
#line 159
        *(lowl + iw) = n + 1;
#line 160
        icnt ++;
#line 160
        *(numb + iw) = icnt;
#line 161
        if (iw == iv) {
#line 161
          goto while_break___3;
        }
#line 157
        stp ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 163
      ist = n - stp;
#line 164
      *(ib + num) = lcnt;
#line 166
      if (ist != 0) {
#line 166
        goto L60;
      }
#line 168
      if (icnt < n) {
#line 168
        goto while_break___1;
      }
#line 169
      goto L100;
      L60: 
#line 171
      iw = iv;
#line 172
      iv = *(prev + iv);
#line 174
      if (*(lowl + iw) < *(lowl + iv)) {
#line 174
        *(lowl + iv) = *(lowl + iw);
      }
#line 175
      goto __Cont___0;
      L70: 
#line 177
      *(arp + iv) = (i2 - ii) - 1;
#line 178
      *(prev + iw) = iv;
#line 179
      iv = iw;
#line 180
      ist ++;
#line 180
      tmp___0 = ist;
#line 180
      *(numb + iv) = tmp___0;
#line 180
      *(lowl + iv) = tmp___0;
#line 181
      *(ib + ((n + 1) - ist)) = iv;
      __Cont___0: /* CIL Label */ 
#line 131
      dummy ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 119
    isn ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  L100: 
#line 185
  i = 1;
  {
#line 185
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 185
    if (! (i <= n)) {
#line 185
      goto while_break___4;
    }
#line 186
    *(arp + *(numb + i)) = i;
#line 185
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 187
  return (num);
}
}
#line 28 "/home/wslee/benchmarks/glpk-4.38/src/glpnet.h"
int _glp_mc21a(int n , int const   *icn , int const   *ip , int const   *lenr , int *iperm ,
               int *pr , int *arp , int *cv , int *out ) ;
#line 95 "/home/wslee/benchmarks/glpk-4.38/src/glpnet01.c"
int _glp_mc21a(int n , int const   *icn , int const   *ip , int const   *lenr , int *iperm ,
               int *pr , int *arp , int *cv , int *out ) 
{ 
  int i ;
  int ii ;
  int in1 ;
  int in2 ;
  int j ;
  int j1 ;
  int jord ;
  int k ;
  int kk ;
  int numnz ;
  int tmp ;

  {
#line 99
  i = 1;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i <= n)) {
#line 99
      goto while_break;
    }
#line 100
    *(arp + i) = (int )(*(lenr + i) - 1);
#line 101
    tmp = 0;
#line 101
    *(iperm + i) = tmp;
#line 101
    *(cv + i) = tmp;
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  numnz = 0;
#line 107
  jord = 1;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (jord <= n)) {
#line 107
      goto while_break___0;
    }
#line 108
    j = jord;
#line 109
    *(pr + j) = -1;
#line 110
    k = 1;
    {
#line 110
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 110
      if (! (k <= jord)) {
#line 110
        goto while_break___1;
      }
#line 112
      in1 = *(arp + j);
#line 113
      if (in1 >= 0) {
#line 114
        in2 = (int )((*(ip + j) + *(lenr + j)) - 1);
#line 115
        in1 = in2 - in1;
#line 116
        ii = in1;
        {
#line 116
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 116
          if (! (ii <= in2)) {
#line 116
            goto while_break___2;
          }
#line 117
          i = (int )*(icn + ii);
#line 118
          if (*(iperm + i) == 0) {
#line 118
            goto L110;
          }
#line 116
          ii ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 121
        *(arp + j) = -1;
      }
#line 124
      *(out + j) = (int )(*(lenr + j) - 1);
#line 126
      kk = 1;
      {
#line 126
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 126
        if (! (kk <= jord)) {
#line 126
          goto while_break___3;
        }
#line 127
        in1 = *(out + j);
#line 128
        if (in1 >= 0) {
#line 129
          in2 = (int )((*(ip + j) + *(lenr + j)) - 1);
#line 130
          in1 = in2 - in1;
#line 132
          ii = in1;
          {
#line 132
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 132
            if (! (ii <= in2)) {
#line 132
              goto while_break___4;
            }
#line 133
            i = (int )*(icn + ii);
#line 134
            if (*(cv + i) != jord) {
#line 137
              j1 = j;
#line 138
              j = *(iperm + i);
#line 139
              *(cv + i) = jord;
#line 140
              *(pr + j) = j1;
#line 141
              *(out + j1) = (in2 - ii) - 1;
#line 142
              goto L100;
            }
#line 132
            ii ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 147
        j = *(pr + j);
#line 148
        if (j == -1) {
#line 148
          goto L130;
        }
#line 126
        kk ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      L100: 
#line 110
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    L110: 
#line 153
    *(iperm + i) = j;
#line 154
    *(arp + j) = (in2 - ii) - 1;
#line 155
    numnz ++;
#line 156
    k = 1;
    {
#line 156
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 156
      if (! (k <= jord)) {
#line 156
        goto while_break___5;
      }
#line 157
      j = *(pr + j);
#line 158
      if (j == -1) {
#line 158
        goto while_break___5;
      }
#line 159
      ii = (int )(((*(ip + j) + *(lenr + j)) - (int const   )*(out + j)) - 2);
#line 160
      i = (int )*(icn + ii);
#line 161
      *(iperm + i) = j;
#line 156
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    L130: 
#line 107
    jord ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  if (numnz < n) {
#line 168
    i = 1;
    {
#line 168
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 168
      if (! (i <= n)) {
#line 168
        goto while_break___6;
      }
#line 169
      *(arp + i) = 0;
#line 168
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 170
    k = 0;
#line 171
    i = 1;
    {
#line 171
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 171
      if (! (i <= n)) {
#line 171
        goto while_break___7;
      }
#line 172
      if (*(iperm + i) == 0) {
#line 173
        k ++;
#line 173
        *(out + k) = i;
      } else {
#line 175
        *(arp + *(iperm + i)) = i;
      }
#line 171
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 177
    k = 0;
#line 178
    i = 1;
    {
#line 178
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 178
      if (! (i <= n)) {
#line 178
        goto while_break___8;
      }
#line 179
      if (*(arp + i) == 0) {
#line 180
        k ++;
#line 180
        *(iperm + *(out + k)) = i;
      }
#line 178
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 183
  return (numnz);
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 290 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
int _glp_lib_xfflush(XFILE *fp ) ;
#line 301
int _glp_lib_xfprintf(XFILE *file , char const   *fmt___0  , ...) ;
#line 339
char *_glp_lib_strspx(char *str ) ;
#line 343
char *_glp_lib_strtrim(char *str ) ;
#line 395 "./../include/glpk.h"
void glp_create_index(glp_prob *lp ) ;
#line 398
int glp_find_row(glp_prob *lp , char const   *name ) ;
#line 401
int glp_find_col(glp_prob *lp , char const   *name ) ;
#line 404
void glp_delete_index(glp_prob *lp ) ;
#line 512
int glp_get_num_int(glp_prob *mip ) ;
#line 515
int glp_get_num_bin(glp_prob *mip ) ;
#line 668
void glp_init_mpscp(glp_mpscp *parm ) ;
#line 671
int glp_read_mps(glp_prob *P , int fmt___0 , glp_mpscp const   *parm , char const   *fname ) ;
#line 675
int glp_write_mps(glp_prob *P , int fmt___0 , glp_mpscp const   *parm , char const   *fname ) ;
#line 427 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
void _glp_1px_order_matrix(glp_prob *lp ) ;
#line 44 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
void glp_init_mpscp(glp_mpscp *parm ) 
{ 


  {
#line 45
  parm->blank = '\000';
#line 46
  parm->obj_name = (char *)((void *)0);
#line 47
  parm->tol_mps = 1e-12;
#line 48
  return;
}
}
#line 51 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void check_parm(char const   *func___0 , glp_mpscp const   *parm ) 
{ 
  xerror_t tmp ;
  unsigned short const   **tmp___0 ;
  xerror_t tmp___1 ;
  size_t tmp___2 ;
  xerror_t tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 53
  if (0 <= (int )parm->blank) {
#line 53
    if (parm->blank <= 255) {
#line 53
      if (! (parm->blank == 0)) {
        {
#line 53
        tmp___0 = __ctype_b_loc();
        }
#line 53
        if (! ((int const   )*(*tmp___0 + (int )parm->blank) & 16384)) {
          {
#line 55
          tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                                 55);
#line 55
          (*tmp)("%s: blank = 0x%02X; invalid parameter\n", func___0, parm->blank);
          }
        }
      }
    } else {
      {
#line 55
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c", 55);
#line 55
      (*tmp)("%s: blank = 0x%02X; invalid parameter\n", func___0, parm->blank);
      }
    }
  } else {
    {
#line 55
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c", 55);
#line 55
    (*tmp)("%s: blank = 0x%02X; invalid parameter\n", func___0, parm->blank);
    }
  }
#line 57
  if (! ((unsigned long )parm->obj_name == (unsigned long )((void *)0))) {
    {
#line 57
    tmp___2 = strlen((char const   *)parm->obj_name);
    }
#line 57
    if (! (tmp___2 <= 255U)) {
      {
#line 58
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                                 58);
#line 58
      (*tmp___1)("%s: obj_name = \"%.12s...\"; parameter too long\n", func___0, parm->obj_name);
      }
    }
  }
#line 60
  if (0.0 <= (double )parm->tol_mps) {
#line 60
    if (! (parm->tol_mps < (double const   )1.0)) {
      {
#line 61
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                                 61);
#line 61
      (*tmp___3)("%s: tol_mps = %g; invalid parameter\n", func___0, parm->tol_mps);
      }
    }
  } else {
    {
#line 61
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c", 61);
#line 61
    (*tmp___3)("%s: tol_mps = %g; invalid parameter\n", func___0, parm->tol_mps);
    }
  }
#line 63
  return;
}
}
#line 135 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void error(struct csa___4 *csa , char const   *fmt___0  , ...) 
{ 
  va_list arg ;
  char *__cil_tmp4 ;

  {
  {
#line 138
  _glp_lib_xprintf("%s:%d: ", csa->fname, csa->recno);
#line 139
  __builtin_va_start(arg, fmt___0);
#line 140
  _glp_lib_xvprintf(fmt___0, arg);
#line 141
  __builtin_va_end(arg);
#line 142
  longjmp((struct __jmp_buf_tag *)(csa->jump), 1);
  }
}
}
#line 146 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void warning(struct csa___4 *csa , char const   *fmt___0  , ...) 
{ 
  va_list arg ;
  char *__cil_tmp4 ;

  {
  {
#line 149
  _glp_lib_xprintf("%s:%d: warning: ", csa->fname, csa->recno);
#line 150
  __builtin_va_start(arg, fmt___0);
#line 151
  _glp_lib_xvprintf(fmt___0, arg);
#line 152
  __builtin_va_end(arg);
  }
#line 153
  return;
}
}
#line 156 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_char(struct csa___4 *csa ) 
{ 
  int c ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 159
  if (csa->c == 10) {
#line 160
    (csa->recno) ++;
#line 160
    csa->recpos = 0;
  }
#line 161
  (csa->recpos) ++;
  read: 
  {
#line 162
  c = _glp_lib_xfgetc(csa->fp);
  }
#line 163
  if (c < 0) {
    {
#line 164
    tmp___0 = _glp_lib_xferror(csa->fp);
    }
#line 164
    if (tmp___0) {
      {
#line 165
      tmp = _glp_lib_xerrmsg();
#line 165
      error(csa, "read error - %s\n", tmp);
      }
    } else
#line 166
    if (csa->c == 10) {
      {
#line 167
      error(csa, "unexpected end of file\n");
      }
    } else {
      {
#line 169
      warning(csa, "missing final end of line\n");
#line 170
      c = '\n';
      }
    }
  } else
#line 173
  if (! (c == 10)) {
#line 175
    if (csa->c == 13) {
#line 176
      c = '\r';
#line 177
      goto badc;
    } else
#line 179
    if (csa->deck) {
#line 179
      if (c == 13) {
#line 180
        csa->c = '\r';
#line 181
        goto read;
      } else {
#line 179
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 183
    if (! (c == 32)) {
      {
#line 185
      tmp___2 = __ctype_b_loc();
      }
#line 185
      if ((int const   )*(*tmp___2 + c) & 8192) {
#line 186
        if (csa->deck) {
          badc: 
          {
#line 187
          error(csa, "in fixed MPS format white-space character 0x%02X is not allowed\n",
                c);
          }
        }
#line 189
        c = ' ';
      } else {
        {
#line 191
        tmp___1 = __ctype_b_loc();
        }
#line 191
        if ((int const   )*(*tmp___1 + c) & 2) {
          {
#line 192
          error(csa, "invalid control character 0x%02X\n", c);
          }
        }
      }
    }
  }
#line 193
  if (csa->deck) {
#line 193
    if (csa->recpos == 81) {
#line 193
      if (c != 10) {
#line 193
        if (csa->w80 < 1) {
          {
#line 194
          warning(csa, "in fixed MPS format record must not be longer than 80 characters\n");
#line 196
          (csa->w80) ++;
          }
        }
      }
    }
  }
#line 198
  csa->c = c;
#line 199
  return;
}
}
#line 202 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static int indicator(struct csa___4 *csa , int name ) 
{ 
  int ret ;
  int tmp ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 206
  csa->fldno = 0;
  loop: 
#line 208
  if (csa->c == 10) {
#line 208
    tmp = 1;
  } else {
    {
#line 208
    _glp_lib_xassert("csa->c == \'\\n\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                     208);
#line 208
    tmp = 1;
    }
  }
  {
#line 209
  read_char(csa);
  }
#line 210
  if (csa->c == 32) {
#line 212
    ret = 0;
  } else
#line 210
  if (csa->c == 10) {
#line 212
    ret = 0;
  } else
#line 214
  if (csa->c == 42) {
    {
#line 216
    while (1) {
      while_continue: /* CIL Label */ ;
#line 216
      if (! (csa->c != 10)) {
#line 216
        goto while_break;
      }
      {
#line 217
      read_char(csa);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 218
    goto loop;
  } else {
#line 222
    len = 0;
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 223
      if (csa->c != 32) {
#line 223
        if (csa->c != 10) {
#line 223
          if (! (len < 12)) {
#line 223
            goto while_break___0;
          }
        } else {
#line 223
          goto while_break___0;
        }
      } else {
#line 223
        goto while_break___0;
      }
      {
#line 224
      tmp___0 = len;
#line 224
      len ++;
#line 224
      csa->field[tmp___0] = (char )csa->c;
#line 225
      read_char(csa);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 227
    csa->field[len] = (char )'\000';
#line 228
    tmp___1 = strcmp((char const   *)(csa->field), "NAME");
    }
#line 228
    if (! (tmp___1 == 0)) {
      {
#line 228
      tmp___2 = strcmp((char const   *)(csa->field), "ROWS");
      }
#line 228
      if (! (tmp___2 == 0)) {
        {
#line 228
        tmp___3 = strcmp((char const   *)(csa->field), "COLUMNS");
        }
#line 228
        if (! (tmp___3 == 0)) {
          {
#line 228
          tmp___4 = strcmp((char const   *)(csa->field), "RHS");
          }
#line 228
          if (! (tmp___4 == 0)) {
            {
#line 228
            tmp___5 = strcmp((char const   *)(csa->field), "RANGES");
            }
#line 228
            if (! (tmp___5 == 0)) {
              {
#line 228
              tmp___6 = strcmp((char const   *)(csa->field), "BOUNDS");
              }
#line 228
              if (! (tmp___6 == 0)) {
                {
#line 228
                tmp___7 = strcmp((char const   *)(csa->field), "ENDATA");
                }
#line 228
                if (! (tmp___7 == 0)) {
                  {
#line 235
                  error(csa, "invalid indicator record\n");
                  }
                }
              }
            }
          }
        }
      }
    }
#line 236
    if (! name) {
      {
#line 237
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 237
        if (! (csa->c != 10)) {
#line 237
          goto while_break___1;
        }
        {
#line 238
        read_char(csa);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 240
    ret = 1;
  }
#line 242
  return (ret);
}
}
#line 245 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_field(struct csa___4 *csa ) 
{ 
  int beg ;
  int end ;
  int pos ;
  int tmp ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 247
  (csa->fldno) ++;
#line 248
  if (csa->deck) {
#line 252
    if (csa->fldno == 1) {
#line 253
      beg = 2;
#line 253
      end = 3;
    } else
#line 254
    if (csa->fldno == 2) {
#line 255
      beg = 5;
#line 255
      end = 12;
    } else
#line 256
    if (csa->fldno == 3) {
#line 257
      beg = 15;
#line 257
      end = 22;
    } else
#line 258
    if (csa->fldno == 4) {
#line 259
      beg = 25;
#line 259
      end = 36;
    } else
#line 260
    if (csa->fldno == 5) {
#line 261
      beg = 40;
#line 261
      end = 47;
    } else
#line 262
    if (csa->fldno == 6) {
#line 263
      beg = 50;
#line 263
      end = 61;
    } else
#line 265
    if ((unsigned long )csa != (unsigned long )csa) {
#line 265
      tmp = 1;
    } else {
      {
#line 265
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       265);
#line 265
      tmp = 1;
      }
    }
#line 267
    if (csa->c != 10) {
#line 268
      pos = csa->recpos;
      {
#line 269
      while (1) {
        while_continue: /* CIL Label */ ;
#line 269
        if (! (csa->recpos < beg)) {
#line 269
          goto while_break;
        }
#line 270
        if (! (csa->c == 32)) {
#line 272
          if (csa->c == 10) {
#line 273
            goto while_break;
          } else {
            {
#line 275
            error(csa, "in fixed MPS format positions %d-%d must be blank\n", pos,
                  beg - 1);
            }
          }
        }
        {
#line 277
        read_char(csa);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 281
    if (csa->fldno == 3) {
#line 281
      goto _L;
    } else
#line 281
    if (csa->fldno == 5) {
      _L: /* CIL Label */ 
#line 281
      if (csa->c == 36) {
        {
#line 282
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 282
          if (! (csa->c != 10)) {
#line 282
            goto while_break___0;
          }
          {
#line 283
          read_char(csa);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 286
    pos = beg;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (! (pos <= end)) {
#line 286
        goto while_break___1;
      }
#line 287
      if (csa->c == 10) {
#line 287
        goto while_break___1;
      }
      {
#line 288
      csa->field[pos - beg] = (char )csa->c;
#line 289
      read_char(csa);
#line 286
      pos ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 291
    csa->field[pos - beg] = (char )'\000';
#line 292
    _glp_lib_strtrim(csa->field);
    }
#line 294
    if (csa->fldno == 6) {
#line 294
      if (csa->c != 10) {
        {
#line 295
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 295
          if (! (csa->recpos <= 72)) {
#line 295
            goto while_break___2;
          }
#line 296
          if (! (csa->c == 32)) {
#line 298
            if (csa->c == 10) {
#line 299
              goto while_break___2;
            } else {
              {
#line 301
              error(csa, "in fixed MPS format positions 62-72 must be blank\n");
              }
            }
          }
          {
#line 303
          read_char(csa);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 305
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 305
          if (! (csa->c != 10)) {
#line 305
            goto while_break___3;
          }
          {
#line 306
          read_char(csa);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  } else {
    {
#line 313
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 313
      if (! (csa->c == 32)) {
#line 313
        goto while_break___4;
      }
      {
#line 314
      read_char(csa);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 316
    if (csa->c == 36) {
      {
#line 317
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 317
        if (! (csa->c != 10)) {
#line 317
          goto while_break___5;
        }
        {
#line 318
        read_char(csa);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 321
    len = 0;
    {
#line 322
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 322
      if (csa->c == 32) {
#line 322
        goto while_break___6;
      } else
#line 322
      if (csa->c == 10) {
#line 322
        goto while_break___6;
      }
#line 323
      if (len == 255) {
        {
#line 324
        tmp___0 = csa->fldno;
#line 324
        (csa->fldno) ++;
#line 324
        error(csa, "length of field %d exceeds 255 characters\n", tmp___0);
        }
      }
      {
#line 326
      tmp___1 = len;
#line 326
      len ++;
#line 326
      csa->field[tmp___1] = (char )csa->c;
#line 327
      read_char(csa);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 329
    csa->field[len] = (char )'\000';
#line 332
    if (csa->fldno == 6) {
      {
#line 333
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 333
        if (! (csa->c == 32)) {
#line 333
          goto while_break___7;
        }
        {
#line 334
        read_char(csa);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 335
      if (csa->c != 36) {
#line 335
        if (csa->c != 10) {
#line 335
          if (csa->wef < 1) {
            {
#line 336
            warning(csa, "some extra field(s) detected beyond field 6; field(s) ignored\n");
#line 338
            (csa->wef) ++;
            }
          }
        }
      }
      {
#line 340
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 340
        if (! (csa->c != 10)) {
#line 340
          goto while_break___8;
        }
        {
#line 341
        read_char(csa);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
#line 344
  return;
}
}
#line 347 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void patch_name(struct csa___4 *csa , char *name ) 
{ 
  int blank ;

  {
#line 349
  blank = (int )(csa->parm)->blank;
#line 350
  if (blank == 0) {
    {
#line 352
    _glp_lib_strspx(name);
    }
  } else {
    {
#line 356
    while (1) {
      while_continue: /* CIL Label */ ;
#line 356
      if (! ((int )*name != 0)) {
#line 356
        goto while_break;
      }
#line 357
      if ((int )*name == 32) {
#line 357
        *name = (char )blank;
      }
#line 356
      name ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 359
  return;
}
}
#line 362 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static double read_number(struct csa___4 *csa ) 
{ 
  double x ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 367
  read_field(csa);
  }
#line 368
  if (csa->fldno == 4) {
#line 368
    tmp = 1;
  } else
#line 368
  if (csa->fldno == 6) {
#line 368
    tmp = 1;
  } else {
    {
#line 368
    _glp_lib_xassert("csa->fldno == 4 || csa->fldno == 6", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                     368);
#line 368
    tmp = 1;
    }
  }
#line 369
  if ((int )csa->field[0] == 0) {
    {
#line 370
    error(csa, "missing numeric value in field %d\n", csa->fldno);
    }
  }
#line 372
  s = csa->field;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! ((int )*s == 32)) {
#line 372
      goto while_break;
    }
#line 372
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  tmp___0 = _glp_lib_str2num((char const   *)s, & x);
  }
#line 374
  if (tmp___0 != 0) {
    {
#line 375
    error(csa, "cannot convert `%s\' to floating-point number\n", s);
    }
  }
#line 377
  return (x);
}
}
#line 380 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void skip_field(struct csa___4 *csa ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 382
  read_field(csa);
  }
#line 383
  if ((int )csa->field[0] != 0) {
    {
#line 384
    error(csa, "field %d must be blank\n", csa->fldno);
    }
  }
#line 385
  return;
}
}
#line 388 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_name(struct csa___4 *csa ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 390
  tmp = indicator(csa, 1);
  }
#line 390
  if (tmp) {
    {
#line 390
    tmp___0 = strcmp((char const   *)(csa->field), "NAME");
    }
#line 390
    if (! (tmp___0 == 0)) {
      {
#line 391
      error(csa, "missing NAME indicator record\n");
      }
    }
  } else {
    {
#line 391
    error(csa, "missing NAME indicator record\n");
    }
  }
  {
#line 394
  csa->fldno = 2;
#line 396
  read_field(csa);
#line 396
  patch_name(csa, csa->field);
  }
#line 397
  if ((int )csa->field[0] == 0) {
    {
#line 398
    warning(csa, "missing model name in field 3\n");
    }
  } else {
    {
#line 400
    glp_set_prob_name(csa->P, (char const   *)(csa->field));
    }
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (csa->c != 10)) {
#line 402
      goto while_break;
    }
    {
#line 403
    read_char(csa);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  return;
}
}
#line 407 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_rows(struct csa___4 *csa ) 
{ 
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  loop: 
  {
#line 410
  tmp = indicator(csa, 0);
  }
#line 410
  if (tmp) {
#line 410
    goto done;
  }
  {
#line 412
  read_field(csa);
#line 412
  _glp_lib_strspx(csa->field);
#line 413
  tmp___3 = strcmp((char const   *)(csa->field), "N");
  }
#line 413
  if (tmp___3 == 0) {
#line 414
    type = 1;
  } else {
    {
#line 415
    tmp___2 = strcmp((char const   *)(csa->field), "G");
    }
#line 415
    if (tmp___2 == 0) {
#line 416
      type = 2;
    } else {
      {
#line 417
      tmp___1 = strcmp((char const   *)(csa->field), "L");
      }
#line 417
      if (tmp___1 == 0) {
#line 418
        type = 3;
      } else {
        {
#line 419
        tmp___0 = strcmp((char const   *)(csa->field), "E");
        }
#line 419
        if (tmp___0 == 0) {
#line 420
          type = 5;
        } else
#line 421
        if ((int )csa->field[0] == 0) {
          {
#line 422
          error(csa, "missing row type in field 1\n");
          }
        } else {
          {
#line 424
          error(csa, "invalid row type in field 1\n");
          }
        }
      }
    }
  }
  {
#line 426
  read_field(csa);
#line 426
  patch_name(csa, csa->field);
  }
#line 427
  if ((int )csa->field[0] == 0) {
    {
#line 428
    error(csa, "missing row name in field 2\n");
    }
  }
  {
#line 429
  tmp___4 = glp_find_row(csa->P, (char const   *)(csa->field));
  }
#line 429
  if (tmp___4 != 0) {
    {
#line 430
    error(csa, "row `%s\' multiply specified\n", csa->field);
    }
  }
  {
#line 431
  i = glp_add_rows(csa->P, 1);
#line 432
  glp_set_row_name(csa->P, i, (char const   *)(csa->field));
#line 433
  glp_set_row_bnds(csa->P, i, type, 0.0, 0.0);
#line 435
  skip_field(csa);
#line 436
  skip_field(csa);
#line 437
  skip_field(csa);
#line 438
  skip_field(csa);
  }
#line 439
  goto loop;
  done: 
#line 440
  return;
}
}
#line 443 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_columns(struct csa___4 *csa ) 
{ 
  int i ;
  int j ;
  int f ;
  int len ;
  int kind ;
  int *ind ;
  double aij ;
  double *val ;
  char name[256] ;
  char *flag ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 445
  kind = 1;
#line 449
  tmp = _glp_lib_xcalloc(1 + (csa->P)->m, (int )sizeof(int ));
#line 449
  ind = (int *)tmp;
#line 449
  csa->work1 = (void *)ind;
#line 450
  tmp___0 = _glp_lib_xcalloc(1 + (csa->P)->m, (int )sizeof(double ));
#line 450
  val = (double *)tmp___0;
#line 450
  csa->work2 = (void *)val;
#line 451
  tmp___1 = _glp_lib_xcalloc(1 + (csa->P)->m, (int )sizeof(char ));
#line 451
  flag = (char *)tmp___1;
#line 451
  csa->work3 = (void *)flag;
#line 452
  memset((void *)(flag + 1), 0, (size_t )(csa->P)->m);
#line 454
  j = 0;
#line 454
  len = 0;
  }
  loop: 
  {
#line 455
  tmp___2 = indicator(csa, 0);
  }
#line 455
  if (tmp___2) {
#line 455
    goto done;
  }
#line 457
  if (csa->deck) {
    {
#line 458
    read_field(csa);
    }
#line 459
    if ((int )csa->field[0] != 0) {
      {
#line 460
      error(csa, "field 1 must be blank\n");
      }
    }
  } else {
#line 463
    (csa->fldno) ++;
  }
  {
#line 465
  read_field(csa);
#line 465
  patch_name(csa, csa->field);
#line 466
  strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(csa->field));
#line 468
  read_field(csa);
#line 468
  patch_name(csa, csa->field);
#line 469
  tmp___5 = strcmp((char const   *)(csa->field), "\'MARKER\'");
  }
#line 469
  if (tmp___5 == 0) {
#line 472
    if (csa->deck) {
      {
#line 473
      read_field(csa);
      }
#line 474
      if ((int )csa->field[0] != 0) {
        {
#line 475
        error(csa, "field 4 must be blank\n");
        }
      }
    } else {
#line 478
      (csa->fldno) ++;
    }
    {
#line 480
    read_field(csa);
#line 480
    patch_name(csa, csa->field);
#line 481
    tmp___4 = strcmp((char const   *)(csa->field), "\'INTORG\'");
    }
#line 481
    if (tmp___4 == 0) {
#line 482
      kind = 2;
    } else {
      {
#line 483
      tmp___3 = strcmp((char const   *)(csa->field), "\'INTEND\'");
      }
#line 483
      if (tmp___3 == 0) {
#line 484
        kind = 1;
      } else
#line 485
      if ((int )csa->field[0] == 0) {
        {
#line 486
        error(csa, "missing keyword in field 5\n");
        }
      } else {
        {
#line 488
        error(csa, "invalid keyword in field 5\n");
        }
      }
    }
    {
#line 490
    skip_field(csa);
    }
#line 491
    goto loop;
  }
#line 494
  if ((int )name[0] == 0) {
#line 496
    if (j == 0) {
      {
#line 497
      error(csa, "missing column name in field 2\n");
      }
    }
  } else
#line 499
  if (j != 0) {
    {
#line 499
    tmp___10 = strcmp((char const   *)(name), (char const   *)(*((csa->P)->col + j))->name);
    }
#line 499
    if (tmp___10 == 0) {
#line 501
      if (j != 0) {
#line 501
        tmp___6 = 1;
      } else {
        {
#line 501
        _glp_lib_xassert("j != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                         501);
#line 501
        tmp___6 = 1;
        }
      }
    } else {
#line 499
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 505
    if (j != 0) {
      {
#line 506
      glp_set_mat_col(csa->P, j, len, (int const   *)ind, (double const   *)val);
      }
      {
#line 507
      while (1) {
        while_continue: /* CIL Label */ ;
#line 507
        if (! (len > 0)) {
#line 507
          goto while_break;
        }
#line 507
        tmp___7 = len;
#line 507
        len --;
#line 507
        *(flag + *(ind + tmp___7)) = (char)0;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 510
    tmp___8 = glp_find_col(csa->P, (char const   *)(name));
    }
#line 510
    if (tmp___8 != 0) {
      {
#line 511
      error(csa, "column `%s\' multiply specified\n", name);
      }
    }
    {
#line 512
    j = glp_add_cols(csa->P, 1);
#line 513
    glp_set_col_name(csa->P, j, (char const   *)(name));
#line 514
    glp_set_col_kind(csa->P, j, kind);
    }
#line 515
    if (kind == 1) {
      {
#line 516
      glp_set_col_bnds(csa->P, j, 2, 0.0, 0.0);
      }
    } else
#line 517
    if (kind == 2) {
      {
#line 518
      glp_set_col_bnds(csa->P, j, 4, 0.0, 1.0);
      }
    } else
#line 520
    if (kind != kind) {
#line 520
      tmp___9 = 1;
    } else {
      {
#line 520
      _glp_lib_xassert("kind != kind", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       520);
#line 520
      tmp___9 = 1;
      }
    }
  }
#line 523
  f = 3;
  {
#line 523
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 523
    if (! (f <= 5)) {
#line 523
      goto while_break___0;
    }
#line 525
    if (f == 3) {
#line 526
      if ((int )csa->field[0] == 0) {
        {
#line 527
        error(csa, "missing row name in field 3\n");
        }
      }
    } else {
      {
#line 530
      read_field(csa);
#line 530
      patch_name(csa, csa->field);
      }
#line 531
      if ((int )csa->field[0] == 0) {
        {
#line 533
        skip_field(csa);
        }
#line 534
        goto __Cont;
      }
    }
    {
#line 537
    i = glp_find_row(csa->P, (char const   *)(csa->field));
    }
#line 538
    if (i == 0) {
      {
#line 539
      error(csa, "row `%s\' not found\n", csa->field);
      }
    }
#line 540
    if (*(flag + i)) {
      {
#line 541
      error(csa, "duplicate coefficient in row `%s\'\n", csa->field);
      }
    }
    {
#line 544
    aij = read_number(csa);
#line 545
    tmp___11 = fabs(aij);
    }
#line 545
    if (tmp___11 < (double )(csa->parm)->tol_mps) {
#line 545
      aij = 0.0;
    }
#line 546
    len ++;
#line 546
    *(ind + len) = i;
#line 546
    *(val + len) = aij;
#line 546
    *(flag + i) = (char)1;
    __Cont: /* CIL Label */ 
#line 523
    f += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 548
  goto loop;
  done: 
#line 550
  if (j != 0) {
    {
#line 551
    glp_set_mat_col(csa->P, j, len, (int const   *)ind, (double const   *)val);
    }
  }
  {
#line 553
  _glp_lib_xfree((void *)ind);
#line 554
  _glp_lib_xfree((void *)val);
#line 555
  _glp_lib_xfree((void *)flag);
#line 556
  tmp___13 = (void *)0;
#line 556
  csa->work3 = tmp___13;
#line 556
  tmp___12 = tmp___13;
#line 556
  csa->work2 = tmp___12;
#line 556
  csa->work1 = tmp___12;
  }
#line 557
  return;
}
}
#line 560 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_rhs(struct csa___4 *csa ) 
{ 
  int i ;
  int f ;
  int v ;
  int type ;
  double rhs ;
  char name[256] ;
  char *flag ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 566
  tmp = _glp_lib_xcalloc(1 + (csa->P)->m, (int )sizeof(char ));
#line 566
  flag = (char *)tmp;
#line 566
  csa->work3 = (void *)flag;
#line 567
  memset((void *)(flag + 1), 0, (size_t )(csa->P)->m);
#line 569
  v = 0;
  }
  loop: 
  {
#line 570
  tmp___0 = indicator(csa, 0);
  }
#line 570
  if (tmp___0) {
#line 570
    goto done;
  }
#line 572
  if (csa->deck) {
    {
#line 573
    read_field(csa);
    }
#line 574
    if ((int )csa->field[0] != 0) {
      {
#line 575
      error(csa, "field 1 must be blank\n");
      }
    }
  } else {
#line 578
    (csa->fldno) ++;
  }
  {
#line 580
  read_field(csa);
#line 580
  patch_name(csa, csa->field);
  }
#line 581
  if ((int )csa->field[0] == 0) {
#line 583
    if (v == 0) {
      {
#line 584
      warning(csa, "missing RHS vector name in field 2\n");
      }
#line 585
      goto blnk;
    }
  } else
#line 588
  if (v != 0) {
    {
#line 588
    tmp___2 = strcmp((char const   *)(csa->field), (char const   *)(name));
    }
#line 588
    if (tmp___2 == 0) {
#line 590
      if (v != 0) {
#line 590
        tmp___1 = 1;
      } else {
        {
#line 590
        _glp_lib_xassert("v != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                         590);
#line 590
        tmp___1 = 1;
        }
      }
    } else {
#line 588
      goto blnk;
    }
  } else {
    blnk: 
#line 594
    if (v != 0) {
      {
#line 595
      error(csa, "multiple RHS vectors not supported\n");
      }
    }
    {
#line 596
    v ++;
#line 597
    strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(csa->field));
    }
  }
#line 600
  f = 3;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (f <= 5)) {
#line 600
      goto while_break;
    }
    {
#line 602
    read_field(csa);
#line 602
    patch_name(csa, csa->field);
    }
#line 603
    if ((int )csa->field[0] == 0) {
#line 604
      if (f == 3) {
        {
#line 605
        error(csa, "missing row name in field 3\n");
        }
      } else {
        {
#line 608
        skip_field(csa);
        }
#line 609
        goto __Cont;
      }
    }
    {
#line 612
    i = glp_find_row(csa->P, (char const   *)(csa->field));
    }
#line 613
    if (i == 0) {
      {
#line 614
      error(csa, "row `%s\' not found\n", csa->field);
      }
    }
#line 615
    if (*(flag + i)) {
      {
#line 616
      error(csa, "duplicate right-hand side for row `%s\'\n", csa->field);
      }
    }
    {
#line 619
    rhs = read_number(csa);
#line 620
    tmp___3 = fabs(rhs);
    }
#line 620
    if (tmp___3 < (double )(csa->parm)->tol_mps) {
#line 620
      rhs = 0.0;
    }
#line 621
    type = (*((csa->P)->row + i))->type;
#line 622
    if (type == 1) {
#line 623
      if (i == csa->obj_row) {
        {
#line 624
        glp_set_obj_coef(csa->P, 0, rhs);
        }
      } else
#line 625
      if (rhs != 0.0) {
        {
#line 626
        warning(csa, "non-zero right-hand side for free row `%s\' ignored\n", (*((csa->P)->row + i))->name);
        }
      }
    } else {
      {
#line 630
      glp_set_row_bnds(csa->P, i, type, rhs, rhs);
      }
    }
#line 631
    *(flag + i) = (char)1;
    __Cont: /* CIL Label */ 
#line 600
    f += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  goto loop;
  done: 
  {
#line 635
  _glp_lib_xfree((void *)flag);
#line 636
  csa->work3 = (void *)0;
  }
#line 637
  return;
}
}
#line 640 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_ranges(struct csa___4 *csa ) 
{ 
  int i ;
  int f ;
  int v ;
  int type ;
  double rhs ;
  double rng ;
  char name[256] ;
  char *flag ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 646
  tmp = _glp_lib_xcalloc(1 + (csa->P)->m, (int )sizeof(char ));
#line 646
  flag = (char *)tmp;
#line 646
  csa->work3 = (void *)flag;
#line 647
  memset((void *)(flag + 1), 0, (size_t )(csa->P)->m);
#line 649
  v = 0;
  }
  loop: 
  {
#line 650
  tmp___0 = indicator(csa, 0);
  }
#line 650
  if (tmp___0) {
#line 650
    goto done;
  }
#line 652
  if (csa->deck) {
    {
#line 653
    read_field(csa);
    }
#line 654
    if ((int )csa->field[0] != 0) {
      {
#line 655
      error(csa, "field 1 must be blank\n");
      }
    }
  } else {
#line 658
    (csa->fldno) ++;
  }
  {
#line 660
  read_field(csa);
#line 660
  patch_name(csa, csa->field);
  }
#line 661
  if ((int )csa->field[0] == 0) {
#line 663
    if (v == 0) {
      {
#line 664
      warning(csa, "missing RANGES vector name in field 2\n");
      }
#line 665
      goto blnk;
    }
  } else
#line 668
  if (v != 0) {
    {
#line 668
    tmp___2 = strcmp((char const   *)(csa->field), (char const   *)(name));
    }
#line 668
    if (tmp___2 == 0) {
#line 670
      if (v != 0) {
#line 670
        tmp___1 = 1;
      } else {
        {
#line 670
        _glp_lib_xassert("v != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                         670);
#line 670
        tmp___1 = 1;
        }
      }
    } else {
#line 668
      goto blnk;
    }
  } else {
    blnk: 
#line 674
    if (v != 0) {
      {
#line 675
      error(csa, "multiple RANGES vectors not supported\n");
      }
    }
    {
#line 676
    v ++;
#line 677
    strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(csa->field));
    }
  }
#line 680
  f = 3;
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! (f <= 5)) {
#line 680
      goto while_break;
    }
    {
#line 682
    read_field(csa);
#line 682
    patch_name(csa, csa->field);
    }
#line 683
    if ((int )csa->field[0] == 0) {
#line 684
      if (f == 3) {
        {
#line 685
        error(csa, "missing row name in field 3\n");
        }
      } else {
        {
#line 688
        skip_field(csa);
        }
#line 689
        goto __Cont;
      }
    }
    {
#line 692
    i = glp_find_row(csa->P, (char const   *)(csa->field));
    }
#line 693
    if (i == 0) {
      {
#line 694
      error(csa, "row `%s\' not found\n", csa->field);
      }
    }
#line 695
    if (*(flag + i)) {
      {
#line 696
      error(csa, "duplicate range for row `%s\'\n", csa->field);
      }
    }
    {
#line 698
    rng = read_number(csa);
#line 699
    tmp___3 = fabs(rng);
    }
#line 699
    if (tmp___3 < (double )(csa->parm)->tol_mps) {
#line 699
      rng = 0.0;
    }
#line 700
    type = (*((csa->P)->row + i))->type;
#line 701
    if (type == 1) {
      {
#line 702
      warning(csa, "range for free row `%s\' ignored\n", (*((csa->P)->row + i))->name);
      }
    } else
#line 704
    if (type == 2) {
      {
#line 705
      rhs = (*((csa->P)->row + i))->lb;
#line 706
      tmp___4 = fabs(rng);
      }
#line 706
      if (rhs == 0.0) {
#line 706
        tmp___5 = 5;
      } else {
#line 706
        tmp___5 = 4;
      }
      {
#line 706
      glp_set_row_bnds(csa->P, i, tmp___5, rhs, rhs + tmp___4);
      }
    } else
#line 709
    if (type == 3) {
      {
#line 710
      rhs = (*((csa->P)->row + i))->ub;
#line 711
      tmp___6 = fabs(rng);
      }
#line 711
      if (rhs == 0.0) {
#line 711
        tmp___7 = 5;
      } else {
#line 711
        tmp___7 = 4;
      }
      {
#line 711
      glp_set_row_bnds(csa->P, i, tmp___7, rhs - tmp___6, rhs);
      }
    } else
#line 714
    if (type == 5) {
#line 715
      rhs = (*((csa->P)->row + i))->lb;
#line 716
      if (rng > 0.0) {
        {
#line 717
        glp_set_row_bnds(csa->P, i, 4, rhs, rhs + rng);
        }
      } else
#line 718
      if (rng < 0.0) {
        {
#line 719
        glp_set_row_bnds(csa->P, i, 4, rhs + rng, rhs);
        }
      }
    } else
#line 722
    if (type != type) {
#line 722
      tmp___8 = 1;
    } else {
      {
#line 722
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       722);
#line 722
      tmp___8 = 1;
      }
    }
#line 723
    *(flag + i) = (char)1;
    __Cont: /* CIL Label */ 
#line 680
    f += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 725
  goto loop;
  done: 
  {
#line 727
  _glp_lib_xfree((void *)flag);
#line 728
  csa->work3 = (void *)0;
  }
#line 729
  return;
}
}
#line 732 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static void read_bounds(struct csa___4 *csa ) 
{ 
  GLPCOL *col ;
  int j ;
  int v ;
  int mask ;
  int data ;
  double bnd ;
  double lb ;
  double ub ;
  char type[3] ;
  char name[256] ;
  char *flag ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;

  {
  {
#line 739
  tmp = _glp_lib_xcalloc(1 + (csa->P)->n, (int )sizeof(char ));
#line 739
  flag = (char *)tmp;
#line 739
  csa->work3 = (void *)flag;
#line 740
  memset((void *)(flag + 1), 0, (size_t )(csa->P)->n);
#line 742
  v = 0;
  }
  loop: 
  {
#line 743
  tmp___0 = indicator(csa, 0);
  }
#line 743
  if (tmp___0) {
#line 743
    goto done;
  }
  {
#line 745
  read_field(csa);
#line 746
  tmp___9 = strcmp((char const   *)(csa->field), "LO");
  }
#line 746
  if (tmp___9 == 0) {
#line 747
    mask = 1;
#line 747
    data = 1;
  } else {
    {
#line 748
    tmp___8 = strcmp((char const   *)(csa->field), "UP");
    }
#line 748
    if (tmp___8 == 0) {
#line 749
      mask = 16;
#line 749
      data = 1;
    } else {
      {
#line 750
      tmp___7 = strcmp((char const   *)(csa->field), "FX");
      }
#line 750
      if (tmp___7 == 0) {
#line 751
        mask = 17;
#line 751
        data = 1;
      } else {
        {
#line 752
        tmp___6 = strcmp((char const   *)(csa->field), "FR");
        }
#line 752
        if (tmp___6 == 0) {
#line 753
          mask = 17;
#line 753
          data = 0;
        } else {
          {
#line 754
          tmp___5 = strcmp((char const   *)(csa->field), "MI");
          }
#line 754
          if (tmp___5 == 0) {
#line 755
            mask = 1;
#line 755
            data = 0;
          } else {
            {
#line 756
            tmp___4 = strcmp((char const   *)(csa->field), "PL");
            }
#line 756
            if (tmp___4 == 0) {
#line 757
              mask = 16;
#line 757
              data = 0;
            } else {
              {
#line 758
              tmp___3 = strcmp((char const   *)(csa->field), "LI");
              }
#line 758
              if (tmp___3 == 0) {
#line 759
                mask = 1;
#line 759
                data = 1;
              } else {
                {
#line 760
                tmp___2 = strcmp((char const   *)(csa->field), "UI");
                }
#line 760
                if (tmp___2 == 0) {
#line 761
                  mask = 16;
#line 761
                  data = 1;
                } else {
                  {
#line 762
                  tmp___1 = strcmp((char const   *)(csa->field), "BV");
                  }
#line 762
                  if (tmp___1 == 0) {
#line 763
                    mask = 17;
#line 763
                    data = 0;
                  } else
#line 764
                  if ((int )csa->field[0] == 0) {
                    {
#line 765
                    error(csa, "missing bound type in field 1\n");
                    }
                  } else {
                    {
#line 767
                    error(csa, "invalid bound type in field 1\n");
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 768
  strcpy((char */* __restrict  */)(type), (char const   */* __restrict  */)(csa->field));
#line 770
  read_field(csa);
#line 770
  patch_name(csa, csa->field);
  }
#line 771
  if ((int )csa->field[0] == 0) {
#line 773
    if (v == 0) {
      {
#line 774
      warning(csa, "missing BOUNDS vector name in field 2\n");
      }
#line 775
      goto blnk;
    }
  } else
#line 778
  if (v != 0) {
    {
#line 778
    tmp___11 = strcmp((char const   *)(csa->field), (char const   *)(name));
    }
#line 778
    if (tmp___11 == 0) {
#line 780
      if (v != 0) {
#line 780
        tmp___10 = 1;
      } else {
        {
#line 780
        _glp_lib_xassert("v != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                         780);
#line 780
        tmp___10 = 1;
        }
      }
    } else {
#line 778
      goto blnk;
    }
  } else {
    blnk: 
#line 784
    if (v != 0) {
      {
#line 785
      error(csa, "multiple BOUNDS vectors not supported\n");
      }
    }
    {
#line 786
    v ++;
#line 787
    strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(csa->field));
    }
  }
  {
#line 790
  read_field(csa);
#line 790
  patch_name(csa, csa->field);
  }
#line 791
  if ((int )csa->field[0] == 0) {
    {
#line 792
    error(csa, "missing column name in field 3\n");
    }
  }
  {
#line 793
  j = glp_find_col(csa->P, (char const   *)(csa->field));
  }
#line 794
  if (j == 0) {
    {
#line 795
    error(csa, "column `%s\' not found\n", csa->field);
    }
  }
#line 796
  if (((int )*(flag + j) & mask) == 1) {
    {
#line 797
    error(csa, "duplicate lower bound for column `%s\'\n", csa->field);
    }
  }
#line 799
  if (((int )*(flag + j) & mask) == 16) {
    {
#line 800
    error(csa, "duplicate upper bound for column `%s\'\n", csa->field);
    }
  }
#line 802
  if (((int )*(flag + j) & mask) == 0) {
#line 802
    tmp___12 = 1;
  } else {
    {
#line 802
    _glp_lib_xassert("(flag[j] & mask) == 0x00", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                     802);
#line 802
    tmp___12 = 1;
    }
  }
#line 804
  if (data) {
    {
#line 805
    bnd = read_number(csa);
#line 806
    tmp___13 = fabs(bnd);
    }
#line 806
    if (tmp___13 < (double )(csa->parm)->tol_mps) {
#line 806
      bnd = 0.0;
    }
  } else {
    {
#line 809
    read_field(csa);
#line 809
    bnd = 0.0;
    }
  }
#line 811
  col = *((csa->P)->col + j);
#line 812
  if (col->type == 1) {
#line 813
    lb = - 1.7976931348623157e+308;
#line 813
    ub = 1.7976931348623157e+308;
  } else
#line 814
  if (col->type == 2) {
#line 815
    lb = col->lb;
#line 815
    ub = 1.7976931348623157e+308;
  } else
#line 816
  if (col->type == 3) {
#line 817
    lb = - 1.7976931348623157e+308;
#line 817
    ub = col->ub;
  } else
#line 818
  if (col->type == 4) {
#line 819
    lb = col->lb;
#line 819
    ub = col->ub;
  } else
#line 820
  if (col->type == 5) {
#line 821
    ub = col->lb;
#line 821
    lb = ub;
  } else
#line 823
  if ((unsigned long )col != (unsigned long )col) {
#line 823
    tmp___14 = 1;
  } else {
    {
#line 823
    _glp_lib_xassert("col != col", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                     823);
#line 823
    tmp___14 = 1;
    }
  }
  {
#line 825
  tmp___24 = strcmp((char const   *)(type), "LO");
  }
#line 825
  if (tmp___24 == 0) {
#line 826
    lb = bnd;
  } else {
    {
#line 827
    tmp___23 = strcmp((char const   *)(type), "UP");
    }
#line 827
    if (tmp___23 == 0) {
#line 828
      ub = bnd;
    } else {
      {
#line 829
      tmp___22 = strcmp((char const   *)(type), "FX");
      }
#line 829
      if (tmp___22 == 0) {
#line 830
        ub = bnd;
#line 830
        lb = ub;
      } else {
        {
#line 831
        tmp___21 = strcmp((char const   *)(type), "FR");
        }
#line 831
        if (tmp___21 == 0) {
#line 832
          lb = - 1.7976931348623157e+308;
#line 832
          ub = 1.7976931348623157e+308;
        } else {
          {
#line 833
          tmp___20 = strcmp((char const   *)(type), "MI");
          }
#line 833
          if (tmp___20 == 0) {
#line 834
            lb = - 1.7976931348623157e+308;
          } else {
            {
#line 835
            tmp___19 = strcmp((char const   *)(type), "PL");
            }
#line 835
            if (tmp___19 == 0) {
#line 836
              ub = 1.7976931348623157e+308;
            } else {
              {
#line 837
              tmp___18 = strcmp((char const   *)(type), "LI");
              }
#line 837
              if (tmp___18 == 0) {
                {
#line 838
                glp_set_col_kind(csa->P, j, 2);
#line 839
                lb = ceil(bnd);
                }
              } else {
                {
#line 841
                tmp___17 = strcmp((char const   *)(type), "UI");
                }
#line 841
                if (tmp___17 == 0) {
                  {
#line 842
                  glp_set_col_kind(csa->P, j, 2);
#line 843
                  ub = floor(bnd);
                  }
                } else {
                  {
#line 845
                  tmp___16 = strcmp((char const   *)(type), "BV");
                  }
#line 845
                  if (tmp___16 == 0) {
                    {
#line 846
                    glp_set_col_kind(csa->P, j, 2);
#line 847
                    lb = 0.0;
#line 847
                    ub = 1.0;
                    }
                  } else
#line 850
                  if ((unsigned long )(type) != (unsigned long )(type)) {
#line 850
                    tmp___15 = 1;
                  } else {
                    {
#line 850
                    _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                                     850);
#line 850
                    tmp___15 = 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 852
  if (lb == - 1.7976931348623157e+308) {
#line 852
    if (ub == 1.7976931348623157e+308) {
      {
#line 853
      glp_set_col_bnds(csa->P, j, 1, lb, ub);
      }
    } else {
#line 852
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 854
  if (ub == 1.7976931348623157e+308) {
    {
#line 855
    glp_set_col_bnds(csa->P, j, 2, lb, ub);
    }
  } else
#line 856
  if (lb == - 1.7976931348623157e+308) {
    {
#line 857
    glp_set_col_bnds(csa->P, j, 3, lb, ub);
    }
  } else
#line 858
  if (lb != ub) {
    {
#line 859
    glp_set_col_bnds(csa->P, j, 4, lb, ub);
    }
  } else {
    {
#line 861
    glp_set_col_bnds(csa->P, j, 5, lb, ub);
    }
  }
  {
#line 862
  *(flag + j) = (char )((int )*(flag + j) | (int )((char )mask));
#line 864
  skip_field(csa);
#line 865
  skip_field(csa);
  }
#line 866
  goto loop;
  done: 
  {
#line 868
  _glp_lib_xfree((void *)flag);
#line 869
  csa->work3 = (void *)0;
  }
#line 870
  return;
}
}
#line 873 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
int glp_read_mps(glp_prob *P , int fmt___0 , glp_mpscp const   *parm , char const   *fname ) 
{ 
  glp_mpscp _parm ;
  struct csa___4 _csa ;
  struct csa___4 *csa ;
  int ret ;
  xerror_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int i ;
  int i___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  GLPAIJ *aij ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  int ni ;
  int tmp___18 ;
  int nb ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
  {
#line 877
  csa = & _csa;
#line 879
  _glp_lib_xprintf("Reading problem data from `%s\'...\n", fname);
  }
#line 880
  if (! (fmt___0 == 1)) {
#line 880
    if (! (fmt___0 == 2)) {
      {
#line 881
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c", 881);
#line 881
      (*tmp)("glp_read_mps: fmt = %d; invalid parameter\n", fmt___0);
      }
    }
  }
#line 882
  if ((unsigned long )parm == (unsigned long )((void *)0)) {
    {
#line 883
    glp_init_mpscp(& _parm);
#line 883
    parm = (glp_mpscp const   *)(& _parm);
    }
  }
  {
#line 885
  check_parm("glp_read_mps", parm);
#line 887
  csa->P = P;
#line 888
  csa->deck = fmt___0 == 1;
#line 889
  csa->parm = parm;
#line 890
  csa->fname = fname;
#line 891
  csa->fp = (XFILE *)((void *)0);
#line 892
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(csa->jump));
  }
#line 892
  if (tmp___0) {
#line 893
    ret = 1;
#line 894
    goto done;
  }
  {
#line 896
  tmp___1 = 0;
#line 896
  csa->recpos = tmp___1;
#line 896
  csa->recno = tmp___1;
#line 897
  csa->c = '\n';
#line 898
  csa->fldno = 0;
#line 899
  csa->field[0] = (char )'\000';
#line 900
  tmp___2 = 0;
#line 900
  csa->wef = tmp___2;
#line 900
  csa->w80 = tmp___2;
#line 901
  csa->obj_row = 0;
#line 902
  tmp___4 = (void *)0;
#line 902
  csa->work3 = tmp___4;
#line 902
  tmp___3 = tmp___4;
#line 902
  csa->work2 = tmp___3;
#line 902
  csa->work1 = tmp___3;
#line 904
  glp_erase_prob(P);
#line 905
  glp_create_index(P);
#line 907
  csa->fp = _glp_lib_xfopen(fname, "r");
  }
#line 908
  if ((unsigned long )csa->fp == (unsigned long )((void *)0)) {
    {
#line 909
    tmp___5 = _glp_lib_xerrmsg();
#line 909
    _glp_lib_xprintf("Unable to open `%s\' - %s\n", fname, tmp___5);
#line 910
    ret = 1;
    }
#line 911
    goto done;
  }
  {
#line 914
  read_name(csa);
  }
#line 915
  if ((unsigned long )P->name != (unsigned long )((void *)0)) {
    {
#line 916
    _glp_lib_xprintf("Problem: %s\n", P->name);
    }
  }
  {
#line 918
  tmp___6 = indicator(csa, 0);
  }
#line 918
  if (tmp___6) {
    {
#line 918
    tmp___7 = strcmp((char const   *)(csa->field), "ROWS");
    }
#line 918
    if (! (tmp___7 == 0)) {
      {
#line 919
      error(csa, "missing ROWS indicator record\n");
      }
    }
  } else {
    {
#line 919
    error(csa, "missing ROWS indicator record\n");
    }
  }
  {
#line 920
  read_rows(csa);
  }
#line 922
  if ((unsigned long )parm->obj_name == (unsigned long )((void *)0)) {
#line 922
    goto _L;
  } else
#line 922
  if ((int )*(parm->obj_name + 0) == 0) {
    _L: /* CIL Label */ 
#line 925
    i = 1;
    {
#line 925
    while (1) {
      while_continue: /* CIL Label */ ;
#line 925
      if (! (i <= P->m)) {
#line 925
        goto while_break;
      }
#line 926
      if ((*(P->row + i))->type == 1) {
#line 927
        csa->obj_row = i;
#line 928
        goto while_break;
      }
#line 925
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 931
    if (csa->obj_row == 0) {
      {
#line 932
      warning(csa, "unable to determine objective row\n");
      }
    }
  } else {
#line 937
    i___0 = 1;
    {
#line 937
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 937
      if (! (i___0 <= P->m)) {
#line 937
        goto while_break___0;
      }
#line 938
      if ((unsigned long )(*(P->row + i___0))->name != (unsigned long )((void *)0)) {
#line 938
        tmp___8 = 1;
      } else {
        {
#line 938
        _glp_lib_xassert("P->row[i]->name != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                         938);
#line 938
        tmp___8 = 1;
        }
      }
      {
#line 939
      tmp___9 = strcmp((char const   *)parm->obj_name, (char const   *)(*(P->row + i___0))->name);
      }
#line 939
      if (tmp___9 == 0) {
#line 940
        csa->obj_row = i___0;
#line 941
        goto while_break___0;
      }
#line 937
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 944
    if (csa->obj_row == 0) {
      {
#line 945
      error(csa, "objective row `%s\' not found\n", parm->obj_name);
      }
    }
  }
#line 948
  if (csa->obj_row != 0) {
    {
#line 949
    glp_set_obj_name(P, (char const   *)(*(P->row + csa->obj_row))->name);
#line 950
    _glp_lib_xprintf("Objective: %s\n", P->obj);
    }
  }
  {
#line 953
  tmp___10 = strcmp((char const   *)(csa->field), "COLUMNS");
  }
#line 953
  if (tmp___10 != 0) {
    {
#line 954
    error(csa, "missing COLUMNS indicator record\n");
    }
  }
  {
#line 955
  read_columns(csa);
  }
#line 957
  if (csa->obj_row != 0) {
#line 959
    aij = (*(P->row + csa->obj_row))->ptr;
    {
#line 959
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 959
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 959
        goto while_break___1;
      }
      {
#line 960
      glp_set_obj_coef(P, (aij->col)->j, aij->val);
#line 959
      aij = aij->r_next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 963
  tmp___11 = strcmp((char const   *)(csa->field), "RHS");
  }
#line 963
  if (tmp___11 == 0) {
    {
#line 964
    read_rhs(csa);
    }
  }
  {
#line 966
  tmp___12 = strcmp((char const   *)(csa->field), "RANGES");
  }
#line 966
  if (tmp___12 == 0) {
    {
#line 967
    read_ranges(csa);
    }
  }
  {
#line 969
  tmp___13 = strcmp((char const   *)(csa->field), "BOUNDS");
  }
#line 969
  if (tmp___13 == 0) {
    {
#line 970
    read_bounds(csa);
    }
  }
  {
#line 972
  tmp___14 = strcmp((char const   *)(csa->field), "ENDATA");
  }
#line 972
  if (tmp___14 != 0) {
    {
#line 973
    error(csa, "invalid use of %s indicator record\n", csa->field);
    }
  }
#line 976
  if (P->nnz == 1) {
#line 976
    tmp___15 = "";
  } else {
#line 976
    tmp___15 = "s";
  }
#line 976
  if (P->n == 1) {
#line 976
    tmp___16 = "";
  } else {
#line 976
    tmp___16 = "s";
  }
#line 976
  if (P->m == 1) {
#line 976
    tmp___17 = "";
  } else {
#line 976
    tmp___17 = "s";
  }
  {
#line 976
  _glp_lib_xprintf("%d row%s, %d column%s, %d non-zero%s\n", P->m, tmp___17, P->n,
                   tmp___16, P->nnz, tmp___15);
#line 979
  tmp___21 = glp_get_num_int(P);
  }
#line 979
  if (tmp___21 > 0) {
    {
#line 980
    tmp___18 = glp_get_num_int(P);
#line 980
    ni = tmp___18;
#line 981
    tmp___19 = glp_get_num_bin(P);
#line 981
    nb = tmp___19;
    }
#line 982
    if (ni == 1) {
#line 983
      if (nb == 0) {
        {
#line 984
        _glp_lib_xprintf("One variable is integer\n");
        }
      } else {
        {
#line 986
        _glp_lib_xprintf("One variable is binary\n");
        }
      }
    } else {
      {
#line 989
      _glp_lib_xprintf("%d integer variables, ", ni);
      }
#line 990
      if (nb == 0) {
        {
#line 991
        _glp_lib_xprintf("none");
        }
      } else
#line 992
      if (nb == 1) {
        {
#line 993
        _glp_lib_xprintf("one");
        }
      } else
#line 994
      if (nb == ni) {
        {
#line 995
        _glp_lib_xprintf("all");
        }
      } else {
        {
#line 997
        _glp_lib_xprintf("%d", nb);
        }
      }
#line 998
      if (nb == 1) {
#line 998
        tmp___20 = "is";
      } else {
#line 998
        tmp___20 = "are";
      }
      {
#line 998
      _glp_lib_xprintf(" of which %s binary\n", tmp___20);
      }
    }
  }
  {
#line 1001
  _glp_lib_xprintf("%d records were read\n", csa->recno);
#line 1003
  glp_delete_index(P);
#line 1004
  _glp_1px_order_matrix(P);
#line 1005
  ret = 0;
  }
  done: 
#line 1006
  if ((unsigned long )csa->fp != (unsigned long )((void *)0)) {
    {
#line 1006
    _glp_lib_xfclose(csa->fp);
    }
  }
#line 1007
  if ((unsigned long )csa->work1 != (unsigned long )((void *)0)) {
    {
#line 1007
    _glp_lib_xfree(csa->work1);
    }
  }
#line 1008
  if ((unsigned long )csa->work2 != (unsigned long )((void *)0)) {
    {
#line 1008
    _glp_lib_xfree(csa->work2);
    }
  }
#line 1009
  if ((unsigned long )csa->work3 != (unsigned long )((void *)0)) {
    {
#line 1009
    _glp_lib_xfree(csa->work3);
    }
  }
#line 1010
  if (ret != 0) {
    {
#line 1010
    glp_erase_prob(P);
    }
  }
#line 1011
  return (ret);
}
}
#line 1060 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static char *mps_name(struct csa1 *csa1 ) 
{ 
  char *f ;

  {
#line 1063
  if ((unsigned long )(csa1->P)->name == (unsigned long )((void *)0)) {
#line 1064
    csa1->field[0] = (char )'\000';
  } else
#line 1065
  if (csa1->deck) {
    {
#line 1066
    strncpy((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)(csa1->P)->name,
            (size_t )8);
#line 1067
    csa1->field[8] = (char )'\000';
    }
  } else {
    {
#line 1070
    strcpy((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)(csa1->P)->name);
    }
  }
#line 1071
  f = csa1->field;
  {
#line 1071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1071
    if (! ((int )*f != 0)) {
#line 1071
      goto while_break;
    }
#line 1072
    if ((int )*f == 32) {
#line 1072
      *f = (char )'_';
    }
#line 1071
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1073
  return (csa1->field);
}
}
#line 1076 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static char *row_name(struct csa1 *csa1 , int i ) 
{ 
  char *f ;
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1079
  if (0 <= i) {
#line 1079
    if (i <= (csa1->P)->m) {
#line 1079
      tmp = 1;
    } else {
      {
#line 1079
      _glp_lib_xassert("0 <= i && i <= csa->P->m", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       1079);
#line 1079
      tmp = 1;
      }
    }
  } else {
    {
#line 1079
    _glp_lib_xassert("0 <= i && i <= csa->P->m", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                     1079);
#line 1079
    tmp = 1;
    }
  }
#line 1080
  if (i == 0) {
    {
#line 1082
    sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"R%07d",
            i);
    }
  } else
#line 1080
  if ((unsigned long )(*((csa1->P)->row + i))->name == (unsigned long )((void *)0)) {
    {
#line 1082
    sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"R%07d",
            i);
    }
  } else
#line 1080
  if (csa1->deck) {
    {
#line 1080
    tmp___0 = strlen((char const   *)(*((csa1->P)->row + i))->name);
    }
#line 1080
    if (tmp___0 > 8U) {
      {
#line 1082
      sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"R%07d",
              i);
      }
    } else {
#line 1080
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1084
    strcpy((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)(*((csa1->P)->row + i))->name);
#line 1085
    f = csa1->field;
    }
    {
#line 1085
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1085
      if (! ((int )*f != 0)) {
#line 1085
        goto while_break;
      }
#line 1086
      if ((int )*f == 32) {
#line 1086
        *f = (char )'_';
      }
#line 1085
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1088
  return (csa1->field);
}
}
#line 1091 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static char *col_name(struct csa1 *csa1 , int j ) 
{ 
  char *f ;
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1094
  if (1 <= j) {
#line 1094
    if (j <= (csa1->P)->n) {
#line 1094
      tmp = 1;
    } else {
      {
#line 1094
      _glp_lib_xassert("1 <= j && j <= csa->P->n", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       1094);
#line 1094
      tmp = 1;
      }
    }
  } else {
    {
#line 1094
    _glp_lib_xassert("1 <= j && j <= csa->P->n", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                     1094);
#line 1094
    tmp = 1;
    }
  }
#line 1095
  if ((unsigned long )(*((csa1->P)->col + j))->name == (unsigned long )((void *)0)) {
    {
#line 1097
    sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"C%07d",
            j);
    }
  } else
#line 1095
  if (csa1->deck) {
    {
#line 1095
    tmp___0 = strlen((char const   *)(*((csa1->P)->col + j))->name);
    }
#line 1095
    if (tmp___0 > 8U) {
      {
#line 1097
      sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"C%07d",
              j);
      }
    } else {
#line 1095
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1099
    strcpy((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)(*((csa1->P)->col + j))->name);
#line 1100
    f = csa1->field;
    }
    {
#line 1100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1100
      if (! ((int )*f != 0)) {
#line 1100
        goto while_break;
      }
#line 1101
      if ((int )*f == 32) {
#line 1101
        *f = (char )'_';
      }
#line 1100
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1103
  return (csa1->field);
}
}
#line 1106 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
static char *mps_numb(struct csa1 *csa1 , double val ) 
{ 
  int dig ;
  char *exp___0 ;
  double tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1110
  dig = 12;
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1110
    if (! (dig >= 6)) {
#line 1110
      goto while_break;
    }
#line 1111
    if (val != 0.0) {
      {
#line 1111
      tmp = fabs(val);
      }
#line 1111
      if (tmp < 0.002) {
        {
#line 1112
        sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"%.*E",
                dig - 1, val);
        }
      } else {
        {
#line 1114
        sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"%.*G",
                dig, val);
        }
      }
    } else {
      {
#line 1114
      sprintf((char */* __restrict  */)(csa1->field), (char const   */* __restrict  */)"%.*G",
              dig, val);
      }
    }
    {
#line 1115
    exp___0 = strchr((char const   *)(csa1->field), 'E');
    }
#line 1116
    if ((unsigned long )exp___0 != (unsigned long )((void *)0)) {
      {
#line 1117
      tmp___0 = atoi((char const   *)(exp___0 + 1));
#line 1117
      sprintf((char */* __restrict  */)(exp___0 + 1), (char const   */* __restrict  */)"%d",
              tmp___0);
      }
    }
    {
#line 1118
    tmp___1 = strlen((char const   *)(csa1->field));
    }
#line 1118
    if (tmp___1 <= 12U) {
#line 1118
      goto while_break;
    }
#line 1110
    dig --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1120
  tmp___2 = strlen((char const   *)(csa1->field));
  }
#line 1120
  if (tmp___2 <= 12U) {
#line 1120
    tmp___3 = 1;
  } else {
    {
#line 1120
    _glp_lib_xassert("strlen(csa->field) <= 12", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                     1120);
#line 1120
    tmp___3 = 1;
    }
  }
#line 1121
  return (csa1->field);
}
}
#line 1124 "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c"
int glp_write_mps(glp_prob *P , int fmt___0 , glp_mpscp const   *parm , char const   *fname ) 
{ 
  glp_mpscp _parm ;
  struct csa1 _csa ;
  struct csa1 *csa1 ;
  XFILE *fp ;
  int out_obj ;
  int one_col ;
  int empty ;
  int i ;
  int j ;
  int recno ;
  int marker ;
  int count ;
  int gap ;
  int ret ;
  xerror_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int type ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  GLPAIJ cj ;
  GLPAIJ *aij ;
  int kind ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int type___0 ;
  double rhs ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int type___1 ;
  int data[2] ;
  double bnd[2] ;
  char *spec[2] ;
  int tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  char const   *tmp___71 ;
  int tmp___72 ;
  void *__cil_tmp103 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;

  {
  {
#line 1128
  csa1 = & _csa;
#line 1130
  one_col = 0;
#line 1130
  empty = 0;
#line 1132
  _glp_lib_xprintf("Writing problem data to `%s\'...\n", fname);
  }
#line 1133
  if (! (fmt___0 == 1)) {
#line 1133
    if (! (fmt___0 == 2)) {
      {
#line 1134
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmps.c", 1134);
#line 1134
      (*tmp)("glp_write_mps: fmt = %d; invalid parameter\n", fmt___0);
      }
    }
  }
#line 1135
  if ((unsigned long )parm == (unsigned long )((void *)0)) {
    {
#line 1136
    glp_init_mpscp(& _parm);
#line 1136
    parm = (glp_mpscp const   *)(& _parm);
    }
  }
  {
#line 1138
  check_parm("glp_write_mps", parm);
#line 1140
  csa1->P = P;
#line 1141
  csa1->deck = fmt___0 == 1;
#line 1142
  csa1->parm = parm;
#line 1144
  fp = _glp_lib_xfopen(fname, "w");
#line 1144
  recno = 0;
  }
#line 1145
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1146
    tmp___0 = _glp_lib_xerrmsg();
#line 1146
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp___0);
#line 1147
    ret = 1;
    }
#line 1148
    goto done;
  }
#line 1151
  if ((unsigned long )P->name == (unsigned long )((void *)0)) {
#line 1151
    tmp___1 = "";
  } else {
#line 1151
    tmp___1 = (char const   *)P->name;
  }
#line 1151
  if ((unsigned long )P->name == (unsigned long )((void *)0)) {
#line 1151
    tmp___2 = 1;
  } else {
#line 1151
    tmp___2 = 12;
  }
  {
#line 1151
  _glp_lib_xfprintf(fp, "* %-*s%s\n", tmp___2, "Problem:", tmp___1);
#line 1151
  recno ++;
#line 1153
  tmp___5 = glp_get_num_int(P);
  }
#line 1153
  if (tmp___5 == 0) {
#line 1153
    tmp___4 = "LP";
  } else {
#line 1153
    tmp___4 = "MIP";
  }
  {
#line 1153
  _glp_lib_xfprintf(fp, "* %-12s%s\n", "Class:", tmp___4);
#line 1153
  recno ++;
#line 1155
  _glp_lib_xfprintf(fp, "* %-12s%d\n", "Rows:", P->m);
#line 1155
  recno ++;
#line 1156
  tmp___8 = glp_get_num_int(P);
  }
#line 1156
  if (tmp___8 == 0) {
    {
#line 1157
    _glp_lib_xfprintf(fp, "* %-12s%d\n", "Columns:", P->n);
#line 1157
    recno ++;
    }
  } else {
    {
#line 1159
    tmp___6 = glp_get_num_bin(P);
#line 1159
    tmp___7 = glp_get_num_int(P);
#line 1159
    _glp_lib_xfprintf(fp, "* %-12s%d (%d integer, %d binary)\n", "Columns:", P->n,
                      tmp___7, tmp___6);
#line 1159
    recno ++;
    }
  }
  {
#line 1162
  _glp_lib_xfprintf(fp, "* %-12s%d\n", "Non-zeros:", P->nnz);
#line 1162
  recno ++;
  }
#line 1163
  if (csa1->deck) {
#line 1163
    tmp___9 = "Fixed MPS";
  } else {
#line 1163
    tmp___9 = "Free MPS";
  }
  {
#line 1163
  _glp_lib_xfprintf(fp, "* %-12s%s\n", "Format:", tmp___9);
#line 1163
  recno ++;
#line 1165
  tmp___10 = recno;
#line 1165
  recno ++;
#line 1165
  _glp_lib_xfprintf(fp, "*\n", tmp___10);
#line 1167
  tmp___11 = mps_name(csa1);
  }
#line 1167
  if ((unsigned long )P->name == (unsigned long )((void *)0)) {
#line 1167
    tmp___13 = 0;
  } else {
#line 1167
    if (csa1->deck) {
#line 1167
      tmp___12 = 10;
    } else {
#line 1167
      tmp___12 = 1;
    }
#line 1167
    tmp___13 = tmp___12;
  }
  {
#line 1167
  _glp_lib_xfprintf(fp, "NAME%*s%s\n", tmp___13, "", tmp___11);
#line 1167
  recno ++;
#line 1172
  out_obj = 1;
#line 1173
  i = 1;
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! (i <= P->m)) {
#line 1173
      goto while_break;
    }
#line 1174
    if ((*(P->row + i))->type == 1) {
#line 1175
      out_obj = 0;
#line 1176
      goto while_break;
    }
#line 1173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1181
  _glp_lib_xfprintf(fp, "ROWS\n");
#line 1181
  recno ++;
  }
#line 1182
  if (out_obj) {
#line 1182
    i = 0;
  } else {
#line 1182
    i = 1;
  }
  {
#line 1182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1182
    if (! (i <= P->m)) {
#line 1182
      goto while_break___0;
    }
#line 1184
    if (i == 0) {
#line 1184
      type = 1;
    } else {
#line 1184
      type = (*(P->row + i))->type;
    }
#line 1185
    if (type == 1) {
#line 1186
      type = 'N';
    } else
#line 1187
    if (type == 2) {
#line 1188
      type = 'G';
    } else
#line 1189
    if (type == 3) {
#line 1190
      type = 'L';
    } else
#line 1191
    if (type == 4) {
#line 1192
      type = 'E';
    } else
#line 1191
    if (type == 5) {
#line 1192
      type = 'E';
    } else
#line 1194
    if (type != type) {
#line 1194
      tmp___14 = 1;
    } else {
      {
#line 1194
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       1194);
#line 1194
      tmp___14 = 1;
      }
    }
    {
#line 1195
    tmp___15 = row_name(csa1, i);
    }
#line 1195
    if (csa1->deck) {
#line 1195
      tmp___16 = 2;
    } else {
#line 1195
      tmp___16 = 1;
    }
    {
#line 1195
    _glp_lib_xfprintf(fp, " %c%*s%s\n", type, tmp___16, "", tmp___15);
#line 1195
    recno ++;
#line 1182
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1199
  _glp_lib_xfprintf(fp, "COLUMNS\n");
#line 1199
  recno ++;
#line 1200
  marker = 0;
#line 1201
  j = 1;
  }
  {
#line 1201
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1201
    if (! (j <= P->n)) {
#line 1201
      goto while_break___1;
    }
#line 1204
    kind = (*(P->col + j))->kind;
#line 1205
    if (kind == 1) {
#line 1206
      if (marker % 2 == 1) {
#line 1208
        marker ++;
#line 1209
        if (csa1->deck) {
#line 1209
          tmp___17 = 17;
        } else {
#line 1209
          tmp___17 = 1;
        }
#line 1209
        if (csa1->deck) {
#line 1209
          tmp___18 = 2;
        } else {
#line 1209
          tmp___18 = 1;
        }
#line 1209
        if (csa1->deck) {
#line 1209
          tmp___19 = 4;
        } else {
#line 1209
          tmp___19 = 1;
        }
        {
#line 1209
        _glp_lib_xfprintf(fp, "%*sM%07d%*s\'MARKER\'%*s\'INTEND\'\n", tmp___19, "",
                          marker, tmp___18, "", tmp___17, "");
#line 1209
        recno ++;
        }
      }
    } else
#line 1214
    if (kind == 2) {
#line 1215
      if (marker % 2 == 0) {
#line 1217
        marker ++;
#line 1218
        if (csa1->deck) {
#line 1218
          tmp___20 = 17;
        } else {
#line 1218
          tmp___20 = 1;
        }
#line 1218
        if (csa1->deck) {
#line 1218
          tmp___21 = 2;
        } else {
#line 1218
          tmp___21 = 1;
        }
#line 1218
        if (csa1->deck) {
#line 1218
          tmp___22 = 4;
        } else {
#line 1218
          tmp___22 = 1;
        }
        {
#line 1218
        _glp_lib_xfprintf(fp, "%*sM%07d%*s\'MARKER\'%*s\'INTORG\'\n", tmp___22, "",
                          marker, tmp___21, "", tmp___20, "");
#line 1218
        recno ++;
        }
      }
    } else
#line 1224
    if (kind != kind) {
#line 1224
      tmp___23 = 1;
    } else {
      {
#line 1224
      _glp_lib_xassert("kind != kind", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       1224);
#line 1224
      tmp___23 = 1;
      }
    }
#line 1225
    if (out_obj) {
#line 1225
      if ((*(P->col + j))->coef != 0.0) {
#line 1227
        aij = & cj;
#line 1228
        aij->row = (GLPROW *)((void *)0);
#line 1229
        aij->val = (*(P->col + j))->coef;
#line 1230
        aij->c_next = (*(P->col + j))->ptr;
      } else {
#line 1233
        aij = (*(P->col + j))->ptr;
      }
    } else {
#line 1233
      aij = (*(P->col + j))->ptr;
    }
#line 1235
    if ((unsigned long )aij == (unsigned long )((void *)0)) {
      {
#line 1237
      empty ++;
#line 1238
      tmp___24 = col_name(csa1, j);
      }
#line 1238
      if (csa1->deck) {
#line 1238
        tmp___25 = 8;
      } else {
#line 1238
        tmp___25 = 1;
      }
#line 1238
      if (csa1->deck) {
#line 1238
        tmp___26 = 4;
      } else {
#line 1238
        tmp___26 = 1;
      }
      {
#line 1238
      _glp_lib_xfprintf(fp, "%*s%-*s", tmp___26, "", tmp___25, tmp___24);
      }
#line 1241
      if (P->m > 0) {
#line 1241
        tmp___27 = 1;
      } else {
        {
#line 1241
        _glp_lib_xassert("P->m > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                         1241);
#line 1241
        tmp___27 = 1;
        }
      }
      {
#line 1242
      tmp___28 = row_name(csa1, 1);
      }
#line 1242
      if (csa1->deck) {
#line 1242
        tmp___29 = 8;
      } else {
#line 1242
        tmp___29 = 1;
      }
#line 1242
      if (csa1->deck) {
#line 1242
        tmp___30 = 2;
      } else {
#line 1242
        tmp___30 = 1;
      }
      {
#line 1242
      _glp_lib_xfprintf(fp, "%*s%-*s", tmp___30, "", tmp___29, tmp___28);
      }
#line 1245
      if (csa1->deck) {
#line 1245
        tmp___31 = 3;
      } else {
#line 1245
        tmp___31 = 1;
      }
#line 1245
      if (csa1->deck) {
#line 1245
        tmp___32 = 13;
      } else {
#line 1245
        tmp___32 = 1;
      }
      {
#line 1245
      _glp_lib_xfprintf(fp, "%*s0%*s$ empty column\n", tmp___32, "", tmp___31, "");
#line 1245
      recno ++;
      }
    }
#line 1249
    count = 0;
#line 1250
    aij = aij;
    {
#line 1250
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1250
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1250
        goto while_break___2;
      }
#line 1251
      if (one_col) {
#line 1251
        goto _L;
      } else
#line 1251
      if (count % 2 == 0) {
        _L: /* CIL Label */ 
        {
#line 1252
        tmp___33 = col_name(csa1, j);
        }
#line 1252
        if (csa1->deck) {
#line 1252
          tmp___34 = 8;
        } else {
#line 1252
          tmp___34 = 1;
        }
#line 1252
        if (csa1->deck) {
#line 1252
          tmp___35 = 4;
        } else {
#line 1252
          tmp___35 = 1;
        }
        {
#line 1252
        _glp_lib_xfprintf(fp, "%*s%-*s", tmp___35, "", tmp___34, tmp___33);
        }
      }
#line 1254
      if (one_col) {
#line 1254
        gap = 2;
      } else
#line 1254
      if (count % 2 == 0) {
#line 1254
        gap = 2;
      } else {
#line 1254
        gap = 3;
      }
#line 1255
      if ((unsigned long )aij->row == (unsigned long )((void *)0)) {
#line 1255
        tmp___36 = 0;
      } else {
#line 1255
        tmp___36 = (aij->row)->i;
      }
      {
#line 1255
      tmp___37 = row_name(csa1, tmp___36);
      }
#line 1255
      if (csa1->deck) {
#line 1255
        tmp___38 = 8;
      } else {
#line 1255
        tmp___38 = 1;
      }
#line 1255
      if (csa1->deck) {
#line 1255
        tmp___39 = gap;
      } else {
#line 1255
        tmp___39 = 1;
      }
      {
#line 1255
      _glp_lib_xfprintf(fp, "%*s%-*s", tmp___39, "", tmp___38, tmp___37);
#line 1258
      tmp___40 = mps_numb(csa1, aij->val);
      }
#line 1258
      if (csa1->deck) {
#line 1258
        tmp___41 = 12;
      } else {
#line 1258
        tmp___41 = 1;
      }
#line 1258
      if (csa1->deck) {
#line 1258
        tmp___42 = 2;
      } else {
#line 1258
        tmp___42 = 1;
      }
      {
#line 1258
      _glp_lib_xfprintf(fp, "%*s%*s", tmp___42, "", tmp___41, tmp___40);
#line 1258
      count ++;
      }
#line 1261
      if (one_col) {
        {
#line 1262
        _glp_lib_xfprintf(fp, "\n");
#line 1262
        recno ++;
        }
      } else
#line 1261
      if (count % 2 == 0) {
        {
#line 1262
        _glp_lib_xfprintf(fp, "\n");
#line 1262
        recno ++;
        }
      }
#line 1250
      aij = aij->c_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1264
    if (! one_col) {
#line 1264
      if (! (count % 2 == 0)) {
        {
#line 1265
        _glp_lib_xfprintf(fp, "\n");
#line 1265
        recno ++;
        }
      }
    }
#line 1201
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1267
  if (marker % 2 == 1) {
#line 1269
    marker ++;
#line 1270
    if (csa1->deck) {
#line 1270
      tmp___43 = 17;
    } else {
#line 1270
      tmp___43 = 1;
    }
#line 1270
    if (csa1->deck) {
#line 1270
      tmp___44 = 2;
    } else {
#line 1270
      tmp___44 = 1;
    }
#line 1270
    if (csa1->deck) {
#line 1270
      tmp___45 = 4;
    } else {
#line 1270
      tmp___45 = 1;
    }
    {
#line 1270
    _glp_lib_xfprintf(fp, "%*sM%07d%*s\'MARKER\'%*s\'INTEND\'\n", tmp___45, "", marker,
                      tmp___44, "", tmp___43, "");
#line 1270
    recno ++;
    }
  }
#line 1275
  if (empty > 0) {
    {
#line 1276
    _glp_lib_xprintf("Warning: problem has %d empty column(s)\n", empty);
    }
  }
  {
#line 1279
  _glp_lib_xfprintf(fp, "RHS\n");
#line 1279
  recno ++;
#line 1280
  count = 0;
  }
#line 1281
  if (out_obj) {
#line 1281
    i = 0;
  } else {
#line 1281
    i = 1;
  }
  {
#line 1281
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1281
    if (! (i <= P->m)) {
#line 1281
      goto while_break___3;
    }
#line 1284
    if (i == 0) {
#line 1285
      rhs = P->c0;
    } else {
#line 1287
      type___0 = (*(P->row + i))->type;
#line 1288
      if (type___0 == 1) {
#line 1289
        rhs = 0.0;
      } else
#line 1290
      if (type___0 == 2) {
#line 1291
        rhs = (*(P->row + i))->lb;
      } else
#line 1292
      if (type___0 == 3) {
#line 1293
        rhs = (*(P->row + i))->ub;
      } else
#line 1294
      if (type___0 == 4) {
#line 1295
        rhs = (*(P->row + i))->lb;
      } else
#line 1294
      if (type___0 == 5) {
#line 1295
        rhs = (*(P->row + i))->lb;
      } else
#line 1297
      if (type___0 != type___0) {
#line 1297
        tmp___46 = 1;
      } else {
        {
#line 1297
        _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                         1297);
#line 1297
        tmp___46 = 1;
        }
      }
    }
#line 1299
    if (rhs != 0.0) {
#line 1300
      if (one_col) {
#line 1300
        goto _L___0;
      } else
#line 1300
      if (count % 2 == 0) {
        _L___0: /* CIL Label */ 
#line 1301
        if (csa1->deck) {
#line 1301
          tmp___47 = 8;
        } else {
#line 1301
          tmp___47 = 1;
        }
#line 1301
        if (csa1->deck) {
#line 1301
          tmp___48 = 4;
        } else {
#line 1301
          tmp___48 = 1;
        }
        {
#line 1301
        _glp_lib_xfprintf(fp, "%*s%-*s", tmp___48, "", tmp___47, "RHS1");
        }
      }
#line 1303
      if (one_col) {
#line 1303
        gap = 2;
      } else
#line 1303
      if (count % 2 == 0) {
#line 1303
        gap = 2;
      } else {
#line 1303
        gap = 3;
      }
      {
#line 1304
      tmp___49 = row_name(csa1, i);
      }
#line 1304
      if (csa1->deck) {
#line 1304
        tmp___50 = 8;
      } else {
#line 1304
        tmp___50 = 1;
      }
#line 1304
      if (csa1->deck) {
#line 1304
        tmp___51 = gap;
      } else {
#line 1304
        tmp___51 = 1;
      }
      {
#line 1304
      _glp_lib_xfprintf(fp, "%*s%-*s", tmp___51, "", tmp___50, tmp___49);
#line 1307
      tmp___52 = mps_numb(csa1, rhs);
      }
#line 1307
      if (csa1->deck) {
#line 1307
        tmp___53 = 12;
      } else {
#line 1307
        tmp___53 = 1;
      }
#line 1307
      if (csa1->deck) {
#line 1307
        tmp___54 = 2;
      } else {
#line 1307
        tmp___54 = 1;
      }
      {
#line 1307
      _glp_lib_xfprintf(fp, "%*s%*s", tmp___54, "", tmp___53, tmp___52);
#line 1307
      count ++;
      }
#line 1310
      if (one_col) {
        {
#line 1311
        _glp_lib_xfprintf(fp, "\n");
#line 1311
        recno ++;
        }
      } else
#line 1310
      if (count % 2 == 0) {
        {
#line 1311
        _glp_lib_xfprintf(fp, "\n");
#line 1311
        recno ++;
        }
      }
    }
#line 1281
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1314
  if (! one_col) {
#line 1314
    if (! (count % 2 == 0)) {
      {
#line 1315
      _glp_lib_xfprintf(fp, "\n");
#line 1315
      recno ++;
      }
    }
  }
#line 1317
  i = P->m;
  {
#line 1317
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1317
    if (! (i >= 1)) {
#line 1317
      goto while_break___4;
    }
#line 1318
    if ((*(P->row + i))->type == 4) {
#line 1318
      goto while_break___4;
    }
#line 1317
    i --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1319
  if (i == 0) {
#line 1319
    goto bnds;
  }
  {
#line 1320
  _glp_lib_xfprintf(fp, "RANGES\n");
#line 1320
  recno ++;
#line 1321
  count = 0;
#line 1322
  i = 1;
  }
  {
#line 1322
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1322
    if (! (i <= P->m)) {
#line 1322
      goto while_break___5;
    }
#line 1323
    if ((*(P->row + i))->type == 4) {
#line 1324
      if (one_col) {
#line 1324
        goto _L___1;
      } else
#line 1324
      if (count % 2 == 0) {
        _L___1: /* CIL Label */ 
#line 1325
        if (csa1->deck) {
#line 1325
          tmp___55 = 8;
        } else {
#line 1325
          tmp___55 = 1;
        }
#line 1325
        if (csa1->deck) {
#line 1325
          tmp___56 = 4;
        } else {
#line 1325
          tmp___56 = 1;
        }
        {
#line 1325
        _glp_lib_xfprintf(fp, "%*s%-*s", tmp___56, "", tmp___55, "RNG1");
        }
      }
#line 1327
      if (one_col) {
#line 1327
        gap = 2;
      } else
#line 1327
      if (count % 2 == 0) {
#line 1327
        gap = 2;
      } else {
#line 1327
        gap = 3;
      }
      {
#line 1328
      tmp___57 = row_name(csa1, i);
      }
#line 1328
      if (csa1->deck) {
#line 1328
        tmp___58 = 8;
      } else {
#line 1328
        tmp___58 = 1;
      }
#line 1328
      if (csa1->deck) {
#line 1328
        tmp___59 = gap;
      } else {
#line 1328
        tmp___59 = 1;
      }
      {
#line 1328
      _glp_lib_xfprintf(fp, "%*s%-*s", tmp___59, "", tmp___58, tmp___57);
#line 1331
      tmp___60 = mps_numb(csa1, (*(P->row + i))->ub - (*(P->row + i))->lb);
      }
#line 1331
      if (csa1->deck) {
#line 1331
        tmp___61 = 12;
      } else {
#line 1331
        tmp___61 = 1;
      }
#line 1331
      if (csa1->deck) {
#line 1331
        tmp___62 = 2;
      } else {
#line 1331
        tmp___62 = 1;
      }
      {
#line 1331
      _glp_lib_xfprintf(fp, "%*s%*s", tmp___62, "", tmp___61, tmp___60);
#line 1331
      count ++;
      }
#line 1334
      if (one_col) {
        {
#line 1335
        _glp_lib_xfprintf(fp, "\n");
#line 1335
        recno ++;
        }
      } else
#line 1334
      if (count % 2 == 0) {
        {
#line 1335
        _glp_lib_xfprintf(fp, "\n");
#line 1335
        recno ++;
        }
      }
    }
#line 1322
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1338
  if (! one_col) {
#line 1338
    if (! (count % 2 == 0)) {
      {
#line 1339
      _glp_lib_xfprintf(fp, "\n");
#line 1339
      recno ++;
      }
    }
  }
  bnds: 
#line 1341
  j = P->n;
  {
#line 1341
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1341
    if (! (j >= 1)) {
#line 1341
      goto while_break___6;
    }
#line 1342
    if ((*(P->col + j))->type == 2) {
#line 1342
      if (! ((*(P->col + j))->lb == 0.0)) {
#line 1343
        goto while_break___6;
      }
    } else {
#line 1343
      goto while_break___6;
    }
#line 1341
    j --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1344
  if (j == 0) {
#line 1344
    goto endt;
  }
  {
#line 1345
  _glp_lib_xfprintf(fp, "BOUNDS\n");
#line 1345
  recno ++;
#line 1346
  j = 1;
  }
  {
#line 1346
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1346
    if (! (j <= P->n)) {
#line 1346
      goto while_break___7;
    }
#line 1350
    spec[1] = (char *)((void *)0);
#line 1350
    spec[0] = spec[1];
#line 1351
    type___1 = (*(P->col + j))->type;
#line 1352
    if (type___1 == 1) {
#line 1353
      spec[0] = (char *)"FR";
#line 1353
      data[0] = 0;
    } else
#line 1354
    if (type___1 == 2) {
#line 1355
      if ((*(P->col + j))->lb != 0.0) {
#line 1356
        spec[0] = (char *)"LO";
#line 1356
        data[0] = 1;
#line 1356
        bnd[0] = (*(P->col + j))->lb;
      }
#line 1357
      if ((*(P->col + j))->kind == 2) {
#line 1358
        spec[1] = (char *)"PL";
#line 1358
        data[1] = 0;
      }
    } else
#line 1360
    if (type___1 == 3) {
#line 1361
      spec[0] = (char *)"MI";
#line 1361
      data[0] = 0;
#line 1362
      spec[1] = (char *)"UP";
#line 1362
      data[1] = 1;
#line 1362
      bnd[1] = (*(P->col + j))->ub;
    } else
#line 1364
    if (type___1 == 4) {
#line 1365
      if ((*(P->col + j))->lb != 0.0) {
#line 1366
        spec[0] = (char *)"LO";
#line 1366
        data[0] = 1;
#line 1366
        bnd[0] = (*(P->col + j))->lb;
      }
#line 1367
      spec[1] = (char *)"UP";
#line 1367
      data[1] = 1;
#line 1367
      bnd[1] = (*(P->col + j))->ub;
    } else
#line 1369
    if (type___1 == 5) {
#line 1370
      spec[0] = (char *)"FX";
#line 1370
      data[0] = 1;
#line 1370
      bnd[0] = (*(P->col + j))->lb;
    } else
#line 1372
    if (type___1 != type___1) {
#line 1372
      tmp___63 = 1;
    } else {
      {
#line 1372
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpmps.c",
                       1372);
#line 1372
      tmp___63 = 1;
      }
    }
#line 1373
    i = 0;
    {
#line 1373
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1373
      if (! (i <= 1)) {
#line 1373
        goto while_break___8;
      }
#line 1374
      if ((unsigned long )spec[i] != (unsigned long )((void *)0)) {
        {
#line 1375
        tmp___64 = col_name(csa1, j);
        }
#line 1375
        if (csa1->deck) {
#line 1375
          tmp___65 = 8;
        } else {
#line 1375
          tmp___65 = 1;
        }
#line 1375
        if (csa1->deck) {
#line 1375
          tmp___66 = 2;
        } else {
#line 1375
          tmp___66 = 1;
        }
#line 1375
        if (csa1->deck) {
#line 1375
          tmp___67 = 8;
        } else {
#line 1375
          tmp___67 = 1;
        }
        {
#line 1375
        _glp_lib_xfprintf(fp, " %s %-*s%*s%-*s", spec[i], tmp___67, "BND1", tmp___66,
                          "", tmp___65, tmp___64);
        }
#line 1378
        if (data[i]) {
          {
#line 1379
          tmp___68 = mps_numb(csa1, bnd[i]);
          }
#line 1379
          if (csa1->deck) {
#line 1379
            tmp___69 = 12;
          } else {
#line 1379
            tmp___69 = 1;
          }
#line 1379
          if (csa1->deck) {
#line 1379
            tmp___70 = 2;
          } else {
#line 1379
            tmp___70 = 1;
          }
          {
#line 1379
          _glp_lib_xfprintf(fp, "%*s%*s", tmp___70, "", tmp___69, tmp___68);
          }
        }
        {
#line 1381
        _glp_lib_xfprintf(fp, "\n");
#line 1381
        recno ++;
        }
      }
#line 1373
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1346
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  endt: 
  {
#line 1386
  _glp_lib_xfprintf(fp, "ENDATA\n");
#line 1386
  recno ++;
#line 1387
  _glp_lib_xfflush(fp);
#line 1388
  tmp___72 = _glp_lib_xferror(fp);
  }
#line 1388
  if (tmp___72) {
    {
#line 1389
    tmp___71 = _glp_lib_xerrmsg();
#line 1389
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___71);
#line 1390
    ret = 1;
    }
#line 1391
    goto done;
  }
  {
#line 1394
  _glp_lib_xprintf("%d records were written\n", recno);
#line 1395
  ret = 0;
  }
  done: 
#line 1396
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1396
    _glp_lib_xfclose(fp);
    }
  }
#line 1397
  return (ret);
}
}
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 1924 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
int _glp_mpl_tab_num_args(TABDCA *dca ) ;
#line 1927
char const   *_glp_mpl_tab_get_arg(TABDCA *dca , int k ) ;
#line 1930
int _glp_mpl_tab_num_flds(TABDCA *dca ) ;
#line 1933
char const   *_glp_mpl_tab_get_name(TABDCA *dca , int k ) ;
#line 1936
int _glp_mpl_tab_get_type(TABDCA *dca , int k ) ;
#line 1939
double _glp_mpl_tab_get_num(TABDCA *dca , int k ) ;
#line 1942
char const   *_glp_mpl_tab_get_str(TABDCA *dca , int k ) ;
#line 1945
void _glp_mpl_tab_set_num(TABDCA *dca , int k , double num ) ;
#line 1948
void _glp_mpl_tab_set_str(TABDCA *dca , int k , char const   *str ) ;
#line 1951
void _glp_mpl_tab_drv_open(MPL *mpl , int mode ) ;
#line 1954
int _glp_mpl_tab_drv_read(MPL *mpl ) ;
#line 1957
void _glp_mpl_tab_drv_write(MPL *mpl ) ;
#line 1960
void _glp_mpl_tab_drv_close(MPL *mpl ) ;
#line 2447
void _glp_mpl_error(MPL *mpl , char *fmt___0  , ...) ;
#line 71 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static void read_char___0(struct csv *csv ) 
{ 
  int c ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 74
  if (csv->c != -1) {
#line 74
    tmp = 1;
  } else {
    {
#line 74
    _glp_lib_xassert("csv->c != EOF", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     74);
#line 74
    tmp = 1;
    }
  }
#line 75
  if (csv->c == 10) {
#line 75
    (csv->count) ++;
  }
  loop: 
  {
#line 76
  c = fgetc(csv->fp);
#line 77
  tmp___2 = ferror(csv->fp);
  }
#line 77
  if (tmp___2) {
    {
#line 78
    tmp___0 = __errno_location();
#line 78
    tmp___1 = strerror(*tmp___0);
#line 78
    _glp_lib_xprintf("%s:%d: read error - %s\n", csv->fname, csv->count, tmp___1);
#line 80
    longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
    }
  }
  {
#line 82
  tmp___4 = feof(csv->fp);
  }
#line 82
  if (tmp___4) {
#line 83
    if (csv->c == 10) {
#line 84
      (csv->count) --;
#line 85
      c = -1;
    } else {
      {
#line 88
      _glp_lib_xprintf("%s:%d: warning: missing final end-of-line\n", csv->fname,
                       csv->count);
#line 90
      c = '\n';
      }
    }
  } else
#line 93
  if (c == 13) {
#line 94
    goto loop;
  } else
#line 95
  if (! (c == 10)) {
    {
#line 97
    tmp___3 = __ctype_b_loc();
    }
#line 97
    if ((int const   )*(*tmp___3 + c) & 2) {
      {
#line 98
      _glp_lib_xprintf("%s:%d: invalid control character 0x%02X\n", csv->fname, csv->count,
                       c);
#line 100
      longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
      }
    }
  }
#line 102
  csv->c = c;
#line 103
  return;
}
}
#line 106 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static void read_field___0(struct csv *csv ) 
{ 
  int quote ;
  int len ;
  int tmp ;
  int len___0 ;
  double temp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 109
  if (csv->c == -1) {
    {
#line 110
    csv->what = 0;
#line 111
    strcpy((char */* __restrict  */)(csv->field), (char const   */* __restrict  */)"EOF");
    }
#line 112
    goto done;
  }
#line 115
  if (csv->c == 10) {
    {
#line 116
    csv->what = 1;
#line 117
    strcpy((char */* __restrict  */)(csv->field), (char const   */* __restrict  */)"EOR");
#line 118
    read_char___0(csv);
    }
#line 119
    if (csv->c == 44) {
      err1: 
      {
#line 120
      _glp_lib_xprintf("%s:%d: empty field not allowed\n", csv->fname, csv->count);
#line 122
      longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
      }
    }
#line 124
    if (csv->c == 10) {
      {
#line 125
      _glp_lib_xprintf("%s:%d: empty record not allowed\n", csv->fname, csv->count);
#line 127
      longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
      }
    }
#line 129
    goto done;
  }
#line 132
  if (csv->c == 44) {
    {
#line 133
    read_char___0(csv);
    }
  }
#line 135
  if (csv->c == 39) {
#line 135
    goto _L;
  } else
#line 135
  if (csv->c == 34) {
    _L: /* CIL Label */ 
    {
#line 137
    quote = csv->c;
#line 137
    len = 0;
#line 138
    csv->what = 3;
#line 140
    read_char___0(csv);
    }
    {
#line 142
    while (1) {
      while_continue: /* CIL Label */ ;
#line 144
      if (csv->c == quote) {
        {
#line 145
        read_char___0(csv);
        }
#line 146
        if (! (csv->c == quote)) {
#line 148
          if (csv->c == 44) {
#line 149
            goto while_break;
          } else
#line 148
          if (csv->c == 10) {
#line 149
            goto while_break;
          } else {
            {
#line 151
            _glp_lib_xprintf("%s:%d: invalid field\n", csv->fname, csv->count);
#line 153
            longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
            }
          }
        }
      }
#line 157
      if (len == 100) {
        err2: 
        {
#line 158
        _glp_lib_xprintf("%s:%d: field too long\n", csv->fname, csv->count);
#line 160
        longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
        }
      }
      {
#line 163
      tmp = len;
#line 163
      len ++;
#line 163
      csv->field[tmp] = (char )csv->c;
#line 165
      read_char___0(csv);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 168
    if (len == 0) {
#line 168
      goto err1;
    }
#line 169
    csv->field[len] = (char )'\000';
  } else {
#line 173
    len___0 = 0;
#line 175
    csv->what = 2;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 176
      if (csv->c == 44) {
#line 176
        goto while_break___0;
      } else
#line 176
      if (csv->c == 10) {
#line 176
        goto while_break___0;
      }
#line 178
      if (csv->c == 39) {
        {
#line 179
        _glp_lib_xprintf("%s:%d: invalid use of single or double quote within field\n",
                         csv->fname, csv->count);
#line 181
        longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
        }
      } else
#line 178
      if (csv->c == 34) {
        {
#line 179
        _glp_lib_xprintf("%s:%d: invalid use of single or double quote within field\n",
                         csv->fname, csv->count);
#line 181
        longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
        }
      }
#line 184
      if (len___0 == 100) {
#line 184
        goto err2;
      }
      {
#line 186
      tmp___0 = len___0;
#line 186
      len___0 ++;
#line 186
      csv->field[tmp___0] = (char )csv->c;
#line 188
      read_char___0(csv);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 191
    if (len___0 == 0) {
#line 191
      goto err1;
    }
    {
#line 192
    csv->field[len___0] = (char )'\000';
#line 194
    tmp___1 = _glp_lib_str2num((char const   *)(csv->field), & temp);
    }
#line 194
    if (tmp___1) {
#line 194
      csv->what = 3;
    }
  }
  done: 
#line 196
  return;
}
}
#line 199 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static struct csv *csv_open_file(TABDCA *dca , int mode ) 
{ 
  struct csv *csv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  int k ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int k___0 ;
  int nf ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 203
  tmp = _glp_lib_xmalloc((int )sizeof(struct csv ));
#line 203
  csv = (struct csv *)tmp;
#line 204
  csv->mode = mode;
#line 205
  csv->fname = (char *)((void *)0);
#line 206
  csv->fp = (FILE *)((void *)0);
#line 207
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(csv->jump));
  }
#line 207
  if (tmp___0) {
#line 207
    goto fail;
  }
  {
#line 208
  csv->count = 0;
#line 209
  csv->c = '\n';
#line 210
  csv->what = 0;
#line 211
  csv->field[0] = (char )'\000';
#line 212
  csv->nf = 0;
#line 214
  tmp___1 = _glp_mpl_tab_num_args(dca);
  }
#line 214
  if (tmp___1 < 2) {
    {
#line 215
    _glp_lib_xprintf("csv_driver: file name not specified\n");
#line 216
    longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
    }
  }
  {
#line 218
  tmp___2 = _glp_mpl_tab_get_arg(dca, 2);
#line 218
  tmp___3 = strlen(tmp___2);
#line 218
  tmp___4 = _glp_lib_xmalloc((int )(tmp___3 + 1U));
#line 218
  csv->fname = (char *)tmp___4;
#line 219
  tmp___5 = _glp_mpl_tab_get_arg(dca, 2);
#line 219
  strcpy((char */* __restrict  */)csv->fname, (char const   */* __restrict  */)tmp___5);
  }
#line 220
  if (mode == 82) {
    {
#line 223
    csv->fp = fopen((char const   */* __restrict  */)csv->fname, (char const   */* __restrict  */)"r");
    }
#line 224
    if ((unsigned long )csv->fp == (unsigned long )((void *)0)) {
      {
#line 225
      tmp___6 = __errno_location();
#line 225
      tmp___7 = strerror(*tmp___6);
#line 225
      _glp_lib_xprintf("csv_driver: unable to open %s - %s\n", csv->fname, tmp___7);
#line 227
      longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
      }
    }
    {
#line 230
    read_field___0(csv);
    }
#line 231
    if (csv->what == 1) {
#line 231
      tmp___8 = 1;
    } else {
      {
#line 231
      _glp_lib_xassert("csv->what == CSV_EOR", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                       231);
#line 231
      tmp___8 = 1;
      }
    }
#line 233
    if (csv->nf == 0) {
#line 233
      tmp___9 = 1;
    } else {
      {
#line 233
      _glp_lib_xassert("csv->nf == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                       233);
#line 233
      tmp___9 = 1;
      }
    }
    {
#line 234
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 235
      read_field___0(csv);
      }
#line 236
      if (csv->what == 1) {
#line 237
        goto while_break;
      }
#line 238
      if (csv->what != 3) {
        {
#line 239
        _glp_lib_xprintf("%s:%d: invalid field name\n", csv->fname, csv->count);
#line 241
        longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
        }
      }
#line 243
      if (csv->nf == 50) {
        {
#line 244
        _glp_lib_xprintf("%s:%d: too many fields\n", csv->fname, csv->count);
#line 246
        longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
        }
      }
      {
#line 248
      (csv->nf) ++;
#line 250
      k = _glp_mpl_tab_num_flds(dca);
      }
      {
#line 250
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 250
        if (! (k >= 1)) {
#line 250
          goto while_break___0;
        }
        {
#line 251
        tmp___10 = _glp_mpl_tab_get_name(dca, k);
#line 251
        tmp___11 = strcmp(tmp___10, (char const   *)(csv->field));
        }
#line 251
        if (tmp___11 == 0) {
#line 252
          goto while_break___0;
        }
#line 250
        k --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 254
      csv->ref[csv->nf] = k;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 257
    k = _glp_mpl_tab_num_flds(dca);
    }
    {
#line 257
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 257
      if (! (k >= 1)) {
#line 257
        goto while_break___1;
      }
      {
#line 258
      tmp___12 = _glp_mpl_tab_get_name(dca, k);
#line 258
      tmp___13 = strcmp(tmp___12, "RECNO");
      }
#line 258
      if (tmp___13 == 0) {
#line 258
        goto while_break___1;
      }
#line 257
      k --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 259
    csv->ref[0] = k;
  } else
#line 261
  if (mode == 87) {
    {
#line 264
    csv->fp = fopen((char const   */* __restrict  */)csv->fname, (char const   */* __restrict  */)"w");
    }
#line 265
    if ((unsigned long )csv->fp == (unsigned long )((void *)0)) {
      {
#line 266
      tmp___14 = __errno_location();
#line 266
      tmp___15 = strerror(*tmp___14);
#line 266
      _glp_lib_xprintf("csv_driver: unable to create %s - %s\n", csv->fname, tmp___15);
#line 268
      longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
      }
    }
    {
#line 271
    nf = _glp_mpl_tab_num_flds(dca);
#line 272
    k___0 = 1;
    }
    {
#line 272
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 272
      if (! (k___0 <= nf)) {
#line 272
        goto while_break___2;
      }
#line 273
      if (k___0 < nf) {
#line 273
        tmp___16 = ',';
      } else {
#line 273
        tmp___16 = '\n';
      }
      {
#line 273
      tmp___17 = _glp_mpl_tab_get_name(dca, k___0);
#line 273
      fprintf((FILE */* __restrict  */)csv->fp, (char const   */* __restrict  */)"%s%c",
              tmp___17, tmp___16);
#line 272
      k___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 275
    (csv->count) ++;
  } else
#line 278
  if (mode != mode) {
#line 278
    tmp___18 = 1;
  } else {
    {
#line 278
    _glp_lib_xassert("mode != mode", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     278);
#line 278
    tmp___18 = 1;
    }
  }
#line 280
  return (csv);
  fail: 
#line 282
  if ((unsigned long )csv->fname != (unsigned long )((void *)0)) {
    {
#line 282
    _glp_lib_xfree((void *)csv->fname);
    }
  }
#line 283
  if ((unsigned long )csv->fp != (unsigned long )((void *)0)) {
    {
#line 283
    fclose(csv->fp);
    }
  }
  {
#line 284
  _glp_lib_xfree((void *)csv);
  }
#line 285
  return ((struct csv *)((void *)0));
}
}
#line 288 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static int csv_read_record(TABDCA *dca , struct csv *csv ) 
{ 
  int k ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int lack ;
  double num ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 290
  ret = 0;
#line 291
  if (csv->mode == 82) {
#line 291
    tmp = 1;
  } else {
    {
#line 291
    _glp_lib_xassert("csv->mode == \'R\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     291);
#line 291
    tmp = 1;
    }
  }
  {
#line 292
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(csv->jump));
  }
#line 292
  if (tmp___0) {
#line 293
    ret = 1;
#line 294
    goto done;
  }
#line 297
  if (csv->ref[0] > 0) {
    {
#line 298
    _glp_mpl_tab_set_num(dca, csv->ref[0], (double )(csv->count - 1));
    }
  }
#line 300
  k = 1;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (k <= csv->nf)) {
#line 300
      goto while_break;
    }
    {
#line 301
    read_field___0(csv);
    }
#line 302
    if (csv->what == 0) {
#line 304
      if (k == 1) {
#line 304
        tmp___1 = 1;
      } else {
        {
#line 304
        _glp_lib_xassert("k == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                         304);
#line 304
        tmp___1 = 1;
        }
      }
#line 305
      ret = -1;
#line 306
      goto done;
    } else
#line 308
    if (csv->what == 1) {
#line 310
      lack = (csv->nf - k) + 1;
#line 311
      if (lack == 1) {
        {
#line 312
        _glp_lib_xprintf("%s:%d: one field missing\n", csv->fname, csv->count);
        }
      } else {
        {
#line 315
        _glp_lib_xprintf("%s:%d: %d fields missing\n", csv->fname, csv->count, lack);
        }
      }
      {
#line 317
      longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
      }
    } else
#line 319
    if (csv->what == 2) {
#line 321
      if (csv->ref[k] > 0) {
        {
#line 323
        tmp___2 = _glp_lib_str2num((char const   *)(csv->field), & num);
        }
#line 323
        if (tmp___2 == 0) {
#line 323
          tmp___3 = 1;
        } else {
          {
#line 323
          _glp_lib_xassert("str2num(csv->field, &num) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                           323);
#line 323
          tmp___3 = 1;
          }
        }
        {
#line 324
        _glp_mpl_tab_set_num(dca, csv->ref[k], num);
        }
      }
    } else
#line 327
    if (csv->what == 3) {
#line 329
      if (csv->ref[k] > 0) {
        {
#line 330
        _glp_mpl_tab_set_str(dca, csv->ref[k], (char const   *)(csv->field));
        }
      }
    } else
#line 333
    if ((unsigned long )csv != (unsigned long )csv) {
#line 333
      tmp___4 = 1;
    } else {
      {
#line 333
      _glp_lib_xassert("csv != csv", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                       333);
#line 333
      tmp___4 = 1;
      }
    }
#line 300
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  read_field___0(csv);
  }
#line 337
  if (csv->what != 0) {
#line 337
    tmp___5 = 1;
  } else {
    {
#line 337
    _glp_lib_xassert("csv->what != CSV_EOF", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     337);
#line 337
    tmp___5 = 1;
    }
  }
#line 338
  if (csv->what != 1) {
    {
#line 339
    _glp_lib_xprintf("%s:%d: too many fields\n", csv->fname, csv->count);
#line 340
    longjmp((struct __jmp_buf_tag *)(csv->jump), 0);
    }
  }
  done: 
#line 342
  return (ret);
}
}
#line 345 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static int csv_write_record(TABDCA *dca , struct csv *csv ) 
{ 
  int k ;
  int nf ;
  int ret ;
  char const   *c ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 347
  ret = 0;
#line 349
  if (csv->mode == 87) {
#line 349
    tmp = 1;
  } else {
    {
#line 349
    _glp_lib_xassert("csv->mode == \'W\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     349);
#line 349
    tmp = 1;
    }
  }
  {
#line 350
  nf = _glp_mpl_tab_num_flds(dca);
#line 351
  k = 1;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! (k <= nf)) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp___0 = _glp_mpl_tab_get_type(dca, k);
    }
    {
#line 353
    if (tmp___0 == 78) {
#line 353
      goto case_78;
    }
#line 357
    if (tmp___0 == 83) {
#line 357
      goto case_83;
    }
#line 367
    goto switch_default;
    case_78: /* CIL Label */ 
    {
#line 354
    tmp___1 = _glp_mpl_tab_get_num(dca, k);
#line 354
    fprintf((FILE */* __restrict  */)csv->fp, (char const   */* __restrict  */)"%.*g",
            15, tmp___1);
    }
#line 356
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 358
    fputc('\"', csv->fp);
#line 359
    c = _glp_mpl_tab_get_str(dca, k);
    }
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! ((int const   )*c != 0)) {
#line 359
        goto while_break___0;
      }
#line 360
      if ((int const   )*c == 34) {
        {
#line 361
        fputc('\"', csv->fp);
#line 361
        fputc('\"', csv->fp);
        }
      } else {
        {
#line 363
        fputc((int )*c, csv->fp);
        }
      }
#line 359
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 365
    fputc('\"', csv->fp);
    }
#line 366
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 368
    if ((unsigned long )dca != (unsigned long )dca) {
#line 368
      tmp___2 = 1;
    } else {
      {
#line 368
      _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                       368);
#line 368
      tmp___2 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 370
    if (k < nf) {
#line 370
      tmp___3 = ',';
    } else {
#line 370
      tmp___3 = '\n';
    }
    {
#line 370
    fputc(tmp___3, csv->fp);
#line 351
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  (csv->count) ++;
#line 373
  tmp___6 = ferror(csv->fp);
  }
#line 373
  if (tmp___6) {
    {
#line 374
    tmp___4 = __errno_location();
#line 374
    tmp___5 = strerror(*tmp___4);
#line 374
    _glp_lib_xprintf("%s:%d: write error - %s\n", csv->fname, csv->count, tmp___5);
#line 376
    ret = 1;
    }
  }
#line 378
  return (ret);
}
}
#line 381 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static int csv_close_file(TABDCA *dca , struct csv *csv ) 
{ 
  int ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 383
  ret = 0;
#line 384
  if ((unsigned long )dca == (unsigned long )dca) {
#line 384
    tmp = 1;
  } else {
    {
#line 384
    _glp_lib_xassert("dca == dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     384);
#line 384
    tmp = 1;
    }
  }
#line 385
  if (csv->mode == 87) {
    {
#line 386
    fflush(csv->fp);
#line 387
    tmp___2 = ferror(csv->fp);
    }
#line 387
    if (tmp___2) {
      {
#line 388
      tmp___0 = __errno_location();
#line 388
      tmp___1 = strerror(*tmp___0);
#line 388
      _glp_lib_xprintf("%s:%d: write error - %s\n", csv->fname, csv->count, tmp___1);
#line 390
      ret = 1;
      }
    }
  }
  {
#line 393
  _glp_lib_xfree((void *)csv->fname);
#line 394
  fclose(csv->fp);
#line 395
  _glp_lib_xfree((void *)csv);
  }
#line 396
  return (ret);
}
}
#line 435 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static int read_byte(struct dbf *dbf ) 
{ 
  int b ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 438
  b = fgetc(dbf->fp);
#line 439
  tmp___1 = ferror(dbf->fp);
  }
#line 439
  if (tmp___1) {
    {
#line 440
    tmp = __errno_location();
#line 440
    tmp___0 = strerror(*tmp);
#line 440
    _glp_lib_xprintf("%s:0x%X: read error - %s\n", dbf->fname, dbf->offset, tmp___0);
#line 442
    longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
    }
  }
  {
#line 444
  tmp___2 = feof(dbf->fp);
  }
#line 444
  if (tmp___2) {
    {
#line 445
    _glp_lib_xprintf("%s:0x%X: unexpected end of file\n", dbf->fname, dbf->offset);
#line 447
    longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
    }
  }
#line 449
  if (0 <= b) {
#line 449
    if (b <= 255) {
#line 449
      tmp___3 = 1;
    } else {
      {
#line 449
      _glp_lib_xassert("0x00 <= b && b <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                       449);
#line 449
      tmp___3 = 1;
      }
    }
  } else {
    {
#line 449
    _glp_lib_xassert("0x00 <= b && b <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     449);
#line 449
    tmp___3 = 1;
    }
  }
#line 450
  (dbf->offset) ++;
#line 451
  return (b);
}
}
#line 454 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static void read_header(TABDCA *dca , struct dbf *dbf ) 
{ 
  int b ;
  int j ;
  int k ;
  int recl ;
  char name[11] ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 459
  j = 1;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! (j <= 10)) {
#line 459
      goto while_break;
    }
    {
#line 460
    read_byte(dbf);
#line 459
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 462
  recl = read_byte(dbf);
#line 463
  tmp = read_byte(dbf);
#line 463
  recl += tmp << 8;
#line 465
  j = 1;
  }
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 465
    if (! (j <= 20)) {
#line 465
      goto while_break___0;
    }
    {
#line 466
    read_byte(dbf);
#line 465
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 468
  if (dbf->nf == 0) {
#line 468
    tmp___0 = 1;
  } else {
    {
#line 468
    _glp_lib_xassert("dbf->nf == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     468);
#line 468
    tmp___0 = 1;
    }
  }
  {
#line 469
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 471
    b = read_byte(dbf);
    }
#line 472
    if (b == 13) {
#line 472
      goto while_break___1;
    }
#line 473
    if (dbf->nf == 50) {
      {
#line 474
      _glp_lib_xprintf("%s:0x%X: too many fields\n", dbf->fname, dbf->offset);
#line 476
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
#line 478
    (dbf->nf) ++;
#line 480
    name[0] = (char )b;
#line 481
    j = 1;
    {
#line 481
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 481
      if (! (j < 10)) {
#line 481
        goto while_break___2;
      }
      {
#line 482
      b = read_byte(dbf);
#line 483
      name[j] = (char )b;
#line 481
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 485
    name[10] = (char )'\000';
#line 486
    b = read_byte(dbf);
    }
#line 487
    if (b != 0) {
      {
#line 488
      _glp_lib_xprintf("%s:0x%X: invalid field name\n", dbf->fname, dbf->offset);
#line 490
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
    {
#line 493
    k = _glp_mpl_tab_num_flds(dca);
    }
    {
#line 493
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 493
      if (! (k >= 1)) {
#line 493
        goto while_break___3;
      }
      {
#line 494
      tmp___1 = _glp_mpl_tab_get_name(dca, k);
#line 494
      tmp___2 = strcmp(tmp___1, (char const   *)(name));
      }
#line 494
      if (tmp___2 == 0) {
#line 494
        goto while_break___3;
      }
#line 493
      k --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 495
    dbf->ref[dbf->nf] = k;
#line 497
    b = read_byte(dbf);
    }
#line 498
    if (! (b == 67)) {
#line 498
      if (! (b == 78)) {
        {
#line 499
        _glp_lib_xprintf("%s:0x%X: invalid field type\n", dbf->fname, dbf->offset);
#line 501
        longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
        }
      }
    }
#line 503
    dbf->type[dbf->nf] = b;
#line 505
    j = 1;
    {
#line 505
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 505
      if (! (j <= 4)) {
#line 505
        goto while_break___4;
      }
      {
#line 506
      read_byte(dbf);
#line 505
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 508
    b = read_byte(dbf);
    }
#line 509
    if (b == 0) {
      {
#line 510
      _glp_lib_xprintf("%s:0x%X: invalid field length\n", dbf->fname, dbf->offset);
#line 512
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
#line 514
    if (b > 100) {
      {
#line 515
      _glp_lib_xprintf("%s:0x%X: field too long\n", dbf->fname, dbf->offset);
#line 517
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
#line 519
    dbf->len[dbf->nf] = b;
#line 520
    recl -= b;
#line 522
    j = 1;
    {
#line 522
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 522
      if (! (j <= 15)) {
#line 522
        goto while_break___5;
      }
      {
#line 523
      read_byte(dbf);
#line 522
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 525
  if (recl != 1) {
    {
#line 526
    _glp_lib_xprintf("%s:0x%X: invalid file header\n", dbf->fname, dbf->offset);
#line 528
    longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
    }
  }
  {
#line 531
  k = _glp_mpl_tab_num_flds(dca);
  }
  {
#line 531
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 531
    if (! (k >= 1)) {
#line 531
      goto while_break___6;
    }
    {
#line 532
    tmp___3 = _glp_mpl_tab_get_name(dca, k);
#line 532
    tmp___4 = strcmp(tmp___3, "RECNO");
    }
#line 532
    if (tmp___4 == 0) {
#line 532
      goto while_break___6;
    }
#line 531
    k --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 533
  dbf->ref[0] = k;
#line 534
  return;
}
}
#line 537 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static void parse_third_arg(TABDCA *dca , struct dbf *dbf ) 
{ 
  int j ;
  int k ;
  int temp ;
  char const   *arg ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char const   *tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 541
  dbf->nf = _glp_mpl_tab_num_flds(dca);
#line 542
  arg = _glp_mpl_tab_get_arg(dca, 3);
#line 542
  j = 0;
#line 543
  k = 1;
  }
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (k <= dbf->nf)) {
#line 543
      goto while_break;
    }
#line 545
    if ((int const   )*(arg + j) == 0) {
      {
#line 546
      tmp = _glp_mpl_tab_get_name(dca, k);
#line 546
      _glp_lib_xprintf("xBASE driver: field %s: specification missing\n", tmp);
#line 548
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
#line 551
    if ((int const   )*(arg + j) == 67) {
#line 552
      dbf->type[k] = (int )*(arg + j);
#line 552
      j ++;
    } else
#line 551
    if ((int const   )*(arg + j) == 78) {
#line 552
      dbf->type[k] = (int )*(arg + j);
#line 552
      j ++;
    } else {
      {
#line 554
      tmp___0 = _glp_mpl_tab_get_name(dca, k);
#line 554
      _glp_lib_xprintf("xBASE driver: field %s: invalid field type\n", tmp___0);
#line 556
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
#line 559
    if ((int const   )*(arg + j) == 40) {
#line 560
      j ++;
    } else {
      err: 
      {
#line 562
      tmp___1 = _glp_mpl_tab_get_name(dca, k);
#line 562
      _glp_lib_xprintf("xBASE driver: field %s: invalid field format\n", tmp___1);
#line 564
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
#line 567
    temp = 0;
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 568
      tmp___2 = __ctype_b_loc();
      }
#line 568
      if (! ((int const   )*(*tmp___2 + (int )*(arg + j)) & 2048)) {
#line 568
        goto while_break___0;
      }
#line 569
      if (temp > 100) {
#line 569
        goto while_break___0;
      }
#line 570
      temp = 10 * temp + (int )((int const   )*(arg + j) - 48);
#line 570
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 572
    if (1 <= temp) {
#line 572
      if (! (temp <= 100)) {
        {
#line 573
        tmp___3 = _glp_mpl_tab_get_name(dca, k);
#line 573
        _glp_lib_xprintf("xBASE driver: field %s: invalid field length\n", tmp___3);
#line 575
        longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
        }
      }
    } else {
      {
#line 573
      tmp___3 = _glp_mpl_tab_get_name(dca, k);
#line 573
      _glp_lib_xprintf("xBASE driver: field %s: invalid field length\n", tmp___3);
#line 575
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
#line 577
    dbf->len[k] = temp;
#line 579
    if (dbf->type[k] == 78) {
#line 579
      if ((int const   )*(arg + j) == 44) {
#line 580
        j ++;
#line 581
        temp = 0;
        {
#line 582
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 582
          tmp___4 = __ctype_b_loc();
          }
#line 582
          if (! ((int const   )*(*tmp___4 + (int )*(arg + j)) & 2048)) {
#line 582
            goto while_break___1;
          }
#line 583
          if (temp > dbf->len[k]) {
#line 583
            goto while_break___1;
          }
#line 584
          temp = 10 * temp + (int )((int const   )*(arg + j) - 48);
#line 584
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 586
        if (temp > dbf->len[k]) {
          {
#line 587
          tmp___5 = _glp_mpl_tab_get_name(dca, k);
#line 587
          _glp_lib_xprintf("xBASE driver: field %s: invalid field precision\n", tmp___5);
#line 589
          longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
          }
        }
#line 591
        dbf->prec[k] = temp;
      } else {
#line 594
        dbf->prec[k] = 0;
      }
    } else {
#line 594
      dbf->prec[k] = 0;
    }
#line 596
    if ((int const   )*(arg + j) == 41) {
#line 597
      j ++;
    } else {
#line 599
      goto err;
    }
#line 543
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  return;
}
}
#line 605 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static void write_byte(struct dbf *dbf , int b ) 
{ 


  {
  {
#line 607
  fputc(b, dbf->fp);
#line 608
  (dbf->offset) ++;
  }
#line 609
  return;
}
}
#line 612 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static void write_header(TABDCA *dca , struct dbf *dbf ) 
{ 
  int j ;
  int k ;
  int temp ;
  char const   *name ;

  {
  {
#line 617
  write_byte(dbf, 3);
#line 619
  write_byte(dbf, 70);
#line 620
  write_byte(dbf, 1);
#line 621
  write_byte(dbf, 1);
#line 623
  j = 1;
  }
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! (j <= 4)) {
#line 623
      goto while_break;
    }
    {
#line 624
    write_byte(dbf, 255);
#line 623
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 626
  temp = (32 + dbf->nf * 32) + 1;
#line 627
  write_byte(dbf, temp);
#line 628
  write_byte(dbf, temp >> 8);
#line 630
  temp = 1;
#line 631
  k = 1;
  }
  {
#line 631
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 631
    if (! (k <= dbf->nf)) {
#line 631
      goto while_break___0;
    }
#line 632
    temp += dbf->len[k];
#line 631
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 633
  write_byte(dbf, temp);
#line 634
  write_byte(dbf, temp >> 8);
#line 636
  j = 1;
  }
  {
#line 636
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 636
    if (! (j <= 20)) {
#line 636
      goto while_break___1;
    }
    {
#line 637
    write_byte(dbf, 0);
#line 636
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 639
  k = 1;
  {
#line 639
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 639
    if (! (k <= dbf->nf)) {
#line 639
      goto while_break___2;
    }
    {
#line 641
    name = _glp_mpl_tab_get_name(dca, k);
#line 642
    j = 0;
    }
    {
#line 642
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 642
      if (j < 10) {
#line 642
        if (! ((int const   )*(name + j) != 0)) {
#line 642
          goto while_break___3;
        }
      } else {
#line 642
        goto while_break___3;
      }
      {
#line 643
      write_byte(dbf, (int )*(name + j));
#line 642
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 644
    j = j;
    {
#line 644
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 644
      if (! (j < 11)) {
#line 644
        goto while_break___4;
      }
      {
#line 645
      write_byte(dbf, 0);
#line 644
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 647
    write_byte(dbf, dbf->type[k]);
#line 649
    j = 1;
    }
    {
#line 649
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 649
      if (! (j <= 4)) {
#line 649
        goto while_break___5;
      }
      {
#line 650
      write_byte(dbf, 0);
#line 649
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 652
    write_byte(dbf, dbf->len[k]);
#line 654
    write_byte(dbf, dbf->prec[k]);
#line 656
    j = 1;
    }
    {
#line 656
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 656
      if (! (j <= 14)) {
#line 656
        goto while_break___6;
      }
      {
#line 657
      write_byte(dbf, 0);
#line 656
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 639
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 660
  write_byte(dbf, 13);
  }
#line 661
  return;
}
}
#line 664 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static struct dbf *dbf_open_file(TABDCA *dca , int mode ) 
{ 
  struct dbf *dbf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 668
  tmp = _glp_lib_xmalloc((int )sizeof(struct dbf ));
#line 668
  dbf = (struct dbf *)tmp;
#line 669
  dbf->mode = mode;
#line 670
  dbf->fname = (char *)((void *)0);
#line 671
  dbf->fp = (FILE *)((void *)0);
#line 672
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(dbf->jump));
  }
#line 672
  if (tmp___0) {
#line 672
    goto fail;
  }
  {
#line 673
  dbf->offset = 0;
#line 674
  dbf->count = 0;
#line 675
  dbf->nf = 0;
#line 677
  tmp___1 = _glp_mpl_tab_num_args(dca);
  }
#line 677
  if (tmp___1 < 2) {
    {
#line 678
    _glp_lib_xprintf("xBASE driver: file name not specified\n");
#line 679
    longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
    }
  }
  {
#line 681
  tmp___2 = _glp_mpl_tab_get_arg(dca, 2);
#line 681
  tmp___3 = strlen(tmp___2);
#line 681
  tmp___4 = _glp_lib_xmalloc((int )(tmp___3 + 1U));
#line 681
  dbf->fname = (char *)tmp___4;
#line 682
  tmp___5 = _glp_mpl_tab_get_arg(dca, 2);
#line 682
  strcpy((char */* __restrict  */)dbf->fname, (char const   */* __restrict  */)tmp___5);
  }
#line 683
  if (mode == 82) {
    {
#line 685
    dbf->fp = fopen((char const   */* __restrict  */)dbf->fname, (char const   */* __restrict  */)"rb");
    }
#line 686
    if ((unsigned long )dbf->fp == (unsigned long )((void *)0)) {
      {
#line 687
      tmp___6 = __errno_location();
#line 687
      tmp___7 = strerror(*tmp___6);
#line 687
      _glp_lib_xprintf("xBASE driver: unable to open %s - %s\n", dbf->fname, tmp___7);
#line 689
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
    {
#line 691
    read_header(dca, dbf);
    }
  } else
#line 693
  if (mode == 87) {
    {
#line 695
    tmp___8 = _glp_mpl_tab_num_args(dca);
    }
#line 695
    if (tmp___8 < 3) {
      {
#line 696
      _glp_lib_xprintf("xBASE driver: file format not specified\n");
#line 697
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
    {
#line 699
    parse_third_arg(dca, dbf);
#line 700
    dbf->fp = fopen((char const   */* __restrict  */)dbf->fname, (char const   */* __restrict  */)"wb");
    }
#line 701
    if ((unsigned long )dbf->fp == (unsigned long )((void *)0)) {
      {
#line 702
      tmp___9 = __errno_location();
#line 702
      tmp___10 = strerror(*tmp___9);
#line 702
      _glp_lib_xprintf("xBASE driver: unable to create %s - %s\n", dbf->fname, tmp___10);
#line 704
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
    {
#line 706
    write_header(dca, dbf);
    }
  } else
#line 709
  if (mode != mode) {
#line 709
    tmp___11 = 1;
  } else {
    {
#line 709
    _glp_lib_xassert("mode != mode", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     709);
#line 709
    tmp___11 = 1;
    }
  }
#line 711
  return (dbf);
  fail: 
#line 713
  if ((unsigned long )dbf->fname != (unsigned long )((void *)0)) {
    {
#line 713
    _glp_lib_xfree((void *)dbf->fname);
    }
  }
#line 714
  if ((unsigned long )dbf->fp != (unsigned long )((void *)0)) {
    {
#line 714
    fclose(dbf->fp);
    }
  }
  {
#line 715
  _glp_lib_xfree((void *)dbf);
  }
#line 716
  return ((struct dbf *)((void *)0));
}
}
#line 719 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static int dbf_read_record(TABDCA *dca , struct dbf *dbf ) 
{ 
  int b ;
  int j ;
  int k ;
  int ret ;
  char buf[101] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  double num ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 721
  ret = 0;
#line 723
  if (dbf->mode == 82) {
#line 723
    tmp = 1;
  } else {
    {
#line 723
    _glp_lib_xassert("dbf->mode == \'R\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     723);
#line 723
    tmp = 1;
    }
  }
  {
#line 724
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(dbf->jump));
  }
#line 724
  if (tmp___0) {
#line 725
    ret = 1;
#line 726
    goto done;
  }
  {
#line 729
  b = read_byte(dbf);
  }
#line 730
  if (b == 26) {
#line 732
    ret = -1;
#line 733
    goto done;
  }
#line 735
  if (b != 32) {
    {
#line 736
    _glp_lib_xprintf("%s:0x%X: invalid record flag\n", dbf->fname, dbf->offset);
#line 738
    longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
    }
  }
#line 741
  if (dbf->ref[0] > 0) {
    {
#line 742
    _glp_mpl_tab_set_num(dca, dbf->ref[0], (double )(dbf->count + 1));
    }
  }
#line 744
  k = 1;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (! (k <= dbf->nf)) {
#line 744
      goto while_break;
    }
#line 746
    j = 0;
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 746
      if (! (j < dbf->len[k])) {
#line 746
        goto while_break___0;
      }
      {
#line 747
      tmp___1 = read_byte(dbf);
#line 747
      buf[j] = (char )tmp___1;
#line 746
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 748
    buf[dbf->len[k]] = (char )'\000';
#line 750
    if (dbf->type[k] == 67) {
#line 752
      if (dbf->ref[k] > 0) {
        {
#line 753
        tmp___2 = _glp_lib_strtrim(buf);
#line 753
        _glp_mpl_tab_set_str(dca, dbf->ref[k], (char const   *)tmp___2);
        }
      }
    } else
#line 755
    if (dbf->type[k] == 78) {
#line 757
      if (dbf->ref[k] > 0) {
        {
#line 759
        _glp_lib_strspx(buf);
#line 760
        tmp___3 = _glp_lib_str2num((char const   *)(buf), & num);
        }
#line 760
        if (tmp___3 == 0) {
#line 760
          tmp___4 = 1;
        } else {
          {
#line 760
          _glp_lib_xassert("str2num(buf, &num) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                           760);
#line 760
          tmp___4 = 1;
          }
        }
        {
#line 761
        _glp_mpl_tab_set_num(dca, dbf->ref[k], num);
        }
      }
    } else
#line 765
    if ((unsigned long )dbf != (unsigned long )dbf) {
#line 765
      tmp___5 = 1;
    } else {
      {
#line 765
      _glp_lib_xassert("dbf != dbf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                       765);
#line 765
      tmp___5 = 1;
      }
    }
#line 744
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 768
  (dbf->count) ++;
  done: 
#line 769
  return (ret);
}
}
#line 772 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static int dbf_write_record(TABDCA *dca , struct dbf *dbf ) 
{ 
  int j ;
  int k ;
  int ret ;
  char buf[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *str ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  double num ;
  double tmp___9 ;
  char const   *tmp___10 ;
  double tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 774
  ret = 0;
#line 776
  if (dbf->mode == 87) {
#line 776
    tmp = 1;
  } else {
    {
#line 776
    _glp_lib_xassert("dbf->mode == \'W\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     776);
#line 776
    tmp = 1;
    }
  }
  {
#line 777
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(dbf->jump));
  }
#line 777
  if (tmp___0) {
#line 778
    ret = 1;
#line 779
    goto done;
  }
  {
#line 782
  write_byte(dbf, 32);
#line 783
  tmp___1 = _glp_mpl_tab_num_flds(dca);
  }
#line 783
  if (dbf->nf == tmp___1) {
#line 783
    tmp___2 = 1;
  } else {
    {
#line 783
    _glp_lib_xassert("dbf->nf == mpl_tab_num_flds(dca)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     783);
#line 783
    tmp___2 = 1;
    }
  }
#line 784
  k = 1;
  {
#line 784
  while (1) {
    while_continue: /* CIL Label */ ;
#line 784
    if (! (k <= dbf->nf)) {
#line 784
      goto while_break;
    }
#line 785
    if (dbf->type[k] == 67) {
      {
#line 788
      tmp___6 = _glp_mpl_tab_get_type(dca, k);
      }
#line 788
      if (tmp___6 == 78) {
        {
#line 789
        tmp___3 = _glp_mpl_tab_get_num(dca, k);
#line 789
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%.*g",
                15, tmp___3);
#line 790
        str = (char const   *)(buf);
        }
      } else {
        {
#line 792
        tmp___5 = _glp_mpl_tab_get_type(dca, k);
        }
#line 792
        if (tmp___5 == 83) {
          {
#line 793
          str = _glp_mpl_tab_get_str(dca, k);
          }
        } else
#line 795
        if ((unsigned long )dca != (unsigned long )dca) {
#line 795
          tmp___4 = 1;
        } else {
          {
#line 795
          _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                           795);
#line 795
          tmp___4 = 1;
          }
        }
      }
      {
#line 796
      tmp___8 = strlen(str);
      }
#line 796
      if ((int )tmp___8 > dbf->len[k]) {
        {
#line 797
        tmp___7 = _glp_mpl_tab_get_name(dca, k);
#line 797
        _glp_lib_xprintf("xBASE driver: field %s: cannot convert %.15s... to field format\n",
                         tmp___7, str);
#line 799
        longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
        }
      }
#line 801
      j = 0;
      {
#line 801
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 801
        if (j < dbf->len[k]) {
#line 801
          if (! ((int const   )*(str + j) != 0)) {
#line 801
            goto while_break___0;
          }
        } else {
#line 801
          goto while_break___0;
        }
        {
#line 802
        write_byte(dbf, (int )*(str + j));
#line 801
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 803
      j = j;
      {
#line 803
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 803
        if (! (j < dbf->len[k])) {
#line 803
          goto while_break___1;
        }
        {
#line 804
        write_byte(dbf, ' ');
#line 803
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 806
    if (dbf->type[k] == 78) {
      {
#line 808
      tmp___9 = _glp_mpl_tab_get_num(dca, k);
#line 808
      num = tmp___9;
#line 809
      tmp___11 = fabs(num);
      }
#line 809
      if (tmp___11 > 1e20) {
        err: 
        {
#line 810
        tmp___10 = _glp_mpl_tab_get_name(dca, k);
#line 810
        _glp_lib_xprintf("xBASE driver: field %s: cannot convert %g to field format\n",
                         tmp___10, num);
#line 812
        longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
        }
      }
      {
#line 814
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%*.*f",
              dbf->len[k], dbf->prec[k], num);
#line 815
      tmp___12 = strlen((char const   *)(buf));
      }
#line 815
      if ((unsigned long )tmp___12 < sizeof(buf)) {
#line 815
        tmp___13 = 1;
      } else {
        {
#line 815
        _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                         815);
#line 815
        tmp___13 = 1;
        }
      }
      {
#line 816
      tmp___14 = strlen((char const   *)(buf));
      }
#line 816
      if ((int )tmp___14 != dbf->len[k]) {
#line 816
        goto err;
      }
#line 817
      j = 0;
      {
#line 817
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 817
        if (! (j < dbf->len[k])) {
#line 817
          goto while_break___2;
        }
        {
#line 818
        write_byte(dbf, (int )buf[j]);
#line 817
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 821
    if ((unsigned long )dbf != (unsigned long )dbf) {
#line 821
      tmp___15 = 1;
    } else {
      {
#line 821
      _glp_lib_xassert("dbf != dbf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                       821);
#line 821
      tmp___15 = 1;
      }
    }
#line 784
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  (dbf->count) ++;
  done: 
#line 825
  return (ret);
}
}
#line 828 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
static int dbf_close_file(TABDCA *dca , struct dbf *dbf ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 830
  ret = 0;
#line 831
  if ((unsigned long )dca == (unsigned long )dca) {
#line 831
    tmp = 1;
  } else {
    {
#line 831
    _glp_lib_xassert("dca == dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     831);
#line 831
    tmp = 1;
    }
  }
#line 832
  if (dbf->mode == 87) {
    {
#line 833
    tmp___0 = _setjmp((struct __jmp_buf_tag *)(dbf->jump));
    }
#line 833
    if (tmp___0) {
#line 834
      ret = 1;
#line 835
      goto skip;
    }
    {
#line 838
    write_byte(dbf, 26);
#line 840
    dbf->offset = 4;
#line 841
    tmp___3 = fseek(dbf->fp, (long )dbf->offset, 0);
    }
#line 841
    if (tmp___3) {
      {
#line 842
      tmp___1 = __errno_location();
#line 842
      tmp___2 = strerror(*tmp___1);
#line 842
      _glp_lib_xprintf("%s:0x%X: seek error - %s\n", dbf->fname, dbf->offset, tmp___2);
#line 844
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
    {
#line 846
    write_byte(dbf, dbf->count);
#line 847
    write_byte(dbf, dbf->count >> 8);
#line 848
    write_byte(dbf, dbf->count >> 16);
#line 849
    write_byte(dbf, dbf->count >> 24);
#line 850
    fflush(dbf->fp);
#line 851
    tmp___6 = ferror(dbf->fp);
    }
#line 851
    if (tmp___6) {
      {
#line 852
      tmp___4 = __errno_location();
#line 852
      tmp___5 = strerror(*tmp___4);
#line 852
      _glp_lib_xprintf("%s:0x%X: write error - %s\n", dbf->fname, dbf->offset, tmp___5);
#line 854
      longjmp((struct __jmp_buf_tag *)(dbf->jump), 0);
      }
    }
    skip: ;
  }
  {
#line 858
  _glp_lib_xfree((void *)dbf->fname);
#line 859
  fclose(dbf->fp);
#line 860
  _glp_lib_xfree((void *)dbf);
  }
#line 861
  return (ret);
}
}
#line 871 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
void _glp_mpl_tab_drv_open(MPL *mpl , int mode ) 
{ 
  TABDCA *dca ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct csv *tmp___2 ;
  struct dbf *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 872
  dca = mpl->dca;
#line 873
  if (dca->id == 0) {
#line 873
    tmp = 1;
  } else {
    {
#line 873
    _glp_lib_xassert("dca->id == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     873);
#line 873
    tmp = 1;
    }
  }
#line 874
  if ((unsigned long )dca->link == (unsigned long )((void *)0)) {
#line 874
    tmp___0 = 1;
  } else {
    {
#line 874
    _glp_lib_xassert("dca->link == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     874);
#line 874
    tmp___0 = 1;
    }
  }
#line 875
  if (dca->na >= 1) {
#line 875
    tmp___1 = 1;
  } else {
    {
#line 875
    _glp_lib_xassert("dca->na >= 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     875);
#line 875
    tmp___1 = 1;
    }
  }
  {
#line 876
  tmp___8 = strcmp((char const   *)*(dca->arg + 1), "CSV");
  }
#line 876
  if (tmp___8 == 0) {
    {
#line 877
    dca->id = 1;
#line 878
    tmp___2 = csv_open_file(dca, mode);
#line 878
    dca->link = (void *)tmp___2;
    }
  } else {
    {
#line 880
    tmp___7 = strcmp((char const   *)*(dca->arg + 1), "xBASE");
    }
#line 880
    if (tmp___7 == 0) {
      {
#line 881
      dca->id = 2;
#line 882
      tmp___3 = dbf_open_file(dca, mode);
#line 882
      dca->link = (void *)tmp___3;
      }
    } else {
      {
#line 884
      tmp___5 = strcmp((char const   *)*(dca->arg + 1), "ODBC");
      }
#line 884
      if (tmp___5 == 0) {
        {
#line 886
        dca->id = 3;
#line 887
        dca->link = _glp_db_iodbc_open(dca, mode);
        }
      } else {
        {
#line 884
        tmp___6 = strcmp((char const   *)*(dca->arg + 1), "iODBC");
        }
#line 884
        if (tmp___6 == 0) {
          {
#line 886
          dca->id = 3;
#line 887
          dca->link = _glp_db_iodbc_open(dca, mode);
          }
        } else {
          {
#line 889
          tmp___4 = strcmp((char const   *)*(dca->arg + 1), "MySQL");
          }
#line 889
          if (tmp___4 == 0) {
            {
#line 890
            dca->id = 4;
#line 891
            dca->link = _glp_db_mysql_open(dca, mode);
            }
          } else {
            {
#line 894
            _glp_lib_xprintf("Invalid table driver `%s\'\n", *(dca->arg + 1));
            }
          }
        }
      }
    }
  }
#line 895
  if ((unsigned long )dca->link == (unsigned long )((void *)0)) {
    {
#line 896
    _glp_mpl_error(mpl, (char *)"error on opening table %s", ((mpl->stmt)->u.tab)->name);
    }
  }
#line 898
  return;
}
}
#line 901 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
int _glp_mpl_tab_drv_read(MPL *mpl ) 
{ 
  TABDCA *dca ;
  int ret ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 902
  dca = mpl->dca;
  {
#line 905
  if (dca->id == 1) {
#line 905
    goto case_1;
  }
#line 908
  if (dca->id == 2) {
#line 908
    goto case_2;
  }
#line 911
  if (dca->id == 3) {
#line 911
    goto case_3;
  }
#line 914
  if (dca->id == 4) {
#line 914
    goto case_4;
  }
#line 917
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 906
  ret = csv_read_record(dca, (struct csv *)dca->link);
  }
#line 907
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 909
  ret = dbf_read_record(dca, (struct dbf *)dca->link);
  }
#line 910
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 912
  ret = _glp_db_iodbc_read(dca, dca->link);
  }
#line 913
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 915
  ret = _glp_db_mysql_read(dca, dca->link);
  }
#line 916
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 918
  if ((unsigned long )dca != (unsigned long )dca) {
#line 918
    tmp = 1;
  } else {
    {
#line 918
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     918);
#line 918
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 920
  if (ret > 0) {
    {
#line 921
    _glp_mpl_error(mpl, (char *)"error on reading data from table %s", ((mpl->stmt)->u.tab)->name);
    }
  }
#line 923
  return (ret);
}
}
#line 926 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
void _glp_mpl_tab_drv_write(MPL *mpl ) 
{ 
  TABDCA *dca ;
  int ret ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 927
  dca = mpl->dca;
  {
#line 930
  if (dca->id == 1) {
#line 930
    goto case_1;
  }
#line 933
  if (dca->id == 2) {
#line 933
    goto case_2;
  }
#line 936
  if (dca->id == 3) {
#line 936
    goto case_3;
  }
#line 939
  if (dca->id == 4) {
#line 939
    goto case_4;
  }
#line 942
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 931
  ret = csv_write_record(dca, (struct csv *)dca->link);
  }
#line 932
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 934
  ret = dbf_write_record(dca, (struct dbf *)dca->link);
  }
#line 935
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 937
  ret = _glp_db_iodbc_write(dca, dca->link);
  }
#line 938
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 940
  ret = _glp_db_mysql_write(dca, dca->link);
  }
#line 941
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 943
  if ((unsigned long )dca != (unsigned long )dca) {
#line 943
    tmp = 1;
  } else {
    {
#line 943
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     943);
#line 943
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 945
  if (ret) {
    {
#line 946
    _glp_mpl_error(mpl, (char *)"error on writing data to table %s", ((mpl->stmt)->u.tab)->name);
    }
  }
#line 948
  return;
}
}
#line 951 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c"
void _glp_mpl_tab_drv_close(MPL *mpl ) 
{ 
  TABDCA *dca ;
  int ret ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 952
  dca = mpl->dca;
  {
#line 955
  if (dca->id == 1) {
#line 955
    goto case_1;
  }
#line 958
  if (dca->id == 2) {
#line 958
    goto case_2;
  }
#line 961
  if (dca->id == 3) {
#line 961
    goto case_3;
  }
#line 964
  if (dca->id == 4) {
#line 964
    goto case_4;
  }
#line 967
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 956
  ret = csv_close_file(dca, (struct csv *)dca->link);
  }
#line 957
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 959
  ret = dbf_close_file(dca, (struct dbf *)dca->link);
  }
#line 960
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 962
  ret = _glp_db_iodbc_close(dca, dca->link);
  }
#line 963
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 965
  ret = _glp_db_mysql_close(dca, dca->link);
  }
#line 966
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 968
  if ((unsigned long )dca != (unsigned long )dca) {
#line 968
    tmp = 1;
  } else {
    {
#line 968
    _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl06.c",
                     968);
#line 968
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 970
  dca->id = 0;
#line 971
  dca->link = (void *)0;
#line 972
  if (ret) {
    {
#line 973
    _glp_mpl_error(mpl, (char *)"error on closing table %s", ((mpl->stmt)->u.tab)->name);
    }
  }
#line 975
  return;
}
}
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 233
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 375 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
int _glp_lib_jday(int d___0 , int m , int y ) ;
#line 379
int _glp_lib_jdate(int j , int *_d , int *_m , int *_y ) ;
#line 871 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
double _glp_mpl_fn_gmtime(MPL *mpl ) ;
#line 875
double _glp_mpl_fn_str2time(MPL *mpl , char const   *str , char const   *fmt___0 ) ;
#line 879
void _glp_mpl_fn_time2str(MPL *mpl , char *str , double t , char const   *fmt___0 ) ;
#line 31 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
double _glp_mpl_fn_gmtime(MPL *mpl ) 
{ 
  time_t timer ;
  struct tm *tm ;
  int j ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 36
  time(& timer);
  }
#line 37
  if (timer == -1L) {
    err: 
    {
#line 38
    _glp_mpl_error(mpl, (char *)"gmtime(); unable to obtain current calendar time");
    }
  }
  {
#line 39
  tm = gmtime((time_t const   *)(& timer));
  }
#line 40
  if ((unsigned long )tm == (unsigned long )((void *)0)) {
#line 40
    goto err;
  }
  {
#line 41
  j = _glp_lib_jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);
  }
#line 42
  if (j < 0) {
#line 42
    goto err;
  }
  {
#line 43
  tmp = _glp_lib_jday(1, 1, 1970);
  }
#line 43
  return ((((double )(j - tmp) * 24.0 + (double )tm->tm_hour) * 60.0 + (double )tm->tm_min) * 60.0 + (double )tm->tm_sec);
}
}
#line 48 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
static char *week[7]  = {      (char *)"Monday",      (char *)"Tuesday",      (char *)"Wednesday",      (char *)"Thursday", 
        (char *)"Friday",      (char *)"Saturday",      (char *)"Sunday"};
#line 51 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
static char *moon[12]  = 
#line 51
  {      (char *)"January",      (char *)"February",      (char *)"March",      (char *)"April", 
        (char *)"May",      (char *)"June",      (char *)"July",      (char *)"August", 
        (char *)"September",      (char *)"October",      (char *)"November",      (char *)"December"};
#line 55 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
static void error1(MPL *mpl , char const   *str , char const   *s , char const   *fmt___0 ,
                   char const   *f , char const   *msg ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 57
  _glp_lib_xprintf("Input string passed to str2time:\n");
#line 58
  _glp_lib_xprintf("%s\n", str);
#line 59
  _glp_lib_xprintf("%*s\n", (s - str) + 1L, "^");
#line 60
  _glp_lib_xprintf("Format string passed to str2time:\n");
#line 61
  _glp_lib_xprintf("%s\n", fmt___0);
#line 62
  _glp_lib_xprintf("%*s\n", (f - fmt___0) + 1L, "^");
#line 63
  _glp_mpl_error(mpl, (char *)"%s", msg);
  }
#line 65
  return;
}
}
#line 67 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
double _glp_mpl_fn_str2time(MPL *mpl , char const   *str , char const   *fmt___0 ) 
{ 
  int j ;
  int year ;
  int month ;
  int day ;
  int hh ;
  int mm ;
  int ss ;
  int zone ;
  char const   *s ;
  char const   *f ;
  int k ;
  char *name ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int z ;
  int hh___0 ;
  int mm___0 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;

  {
#line 71
  ss = -1;
#line 71
  mm = ss;
#line 71
  hh = mm;
#line 71
  day = hh;
#line 71
  month = day;
#line 71
  year = month;
#line 71
  zone = 2147483647;
#line 72
  s = str;
#line 73
  f = fmt___0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((int const   )*f != 0)) {
#line 73
      goto while_break;
    }
#line 74
    if ((int const   )*f == 37) {
#line 75
      f ++;
#line 76
      if ((int const   )*f == 98) {
#line 76
        goto _L___0;
      } else
#line 76
      if ((int const   )*f == 104) {
        _L___0: /* CIL Label */ 
#line 80
        if (month >= 0) {
          {
#line 81
          error1(mpl, str, s, fmt___0, f, "month multiply specified");
          }
        }
        {
#line 83
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 83
          if (! ((int const   )*s == 32)) {
#line 83
            goto while_break___0;
          }
#line 83
          s ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 84
        month = 1;
        {
#line 84
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 84
          if (! (month <= 12)) {
#line 84
            goto while_break___1;
          }
#line 85
          name = moon[month - 1];
#line 86
          k = 0;
          {
#line 86
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 86
            if (! (k <= 2)) {
#line 86
              goto while_break___2;
            }
            {
#line 87
            tmp = toupper((int )((unsigned char )*(s + k)));
#line 87
            tmp___0 = toupper((int )((unsigned char )*(name + k)));
            }
#line 87
            if (tmp != tmp___0) {
#line 88
              goto next;
            }
#line 86
            k ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 90
          s += 3;
#line 91
          k = 3;
          {
#line 91
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 91
            if (! ((int )*(name + k) != 0)) {
#line 91
              goto while_break___3;
            }
            {
#line 92
            tmp___1 = toupper((int )((unsigned char )*s));
#line 92
            tmp___2 = toupper((int )((unsigned char )*(name + k)));
            }
#line 92
            if (tmp___1 != tmp___2) {
#line 93
              goto while_break___3;
            }
#line 94
            s ++;
#line 91
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 96
          goto while_break___1;
          next: 
#line 84
          month ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 99
        if (month > 12) {
          {
#line 100
          error1(mpl, str, s, fmt___0, f, "abbreviated month name missing or invalid");
          }
        }
      } else
#line 103
      if ((int const   )*f == 100) {
#line 105
        if (day >= 0) {
          {
#line 106
          error1(mpl, str, s, fmt___0, f, "day multiply specified");
          }
        }
        {
#line 107
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 107
          if (! ((int const   )*s == 32)) {
#line 107
            goto while_break___4;
          }
#line 107
          s ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 108
        if (48 <= (int )*s) {
#line 108
          if (! ((int const   )*s <= 57)) {
            {
#line 109
            error1(mpl, str, s, fmt___0, f, "day missing or invalid");
            }
          }
        } else {
          {
#line 109
          error1(mpl, str, s, fmt___0, f, "day missing or invalid");
          }
        }
#line 110
        tmp___3 = s;
#line 110
        s ++;
#line 110
        day = (int )((int const   )*tmp___3 - 48);
#line 111
        if (48 <= (int )*s) {
#line 111
          if ((int const   )*s <= 57) {
#line 112
            tmp___4 = s;
#line 112
            s ++;
#line 112
            day = 10 * day + (int )((int const   )*tmp___4 - 48);
          }
        }
#line 113
        if (1 <= day) {
#line 113
          if (! (day <= 31)) {
            {
#line 114
            error1(mpl, str, s, fmt___0, f, "day out of range");
            }
          }
        } else {
          {
#line 114
          error1(mpl, str, s, fmt___0, f, "day out of range");
          }
        }
      } else
#line 116
      if ((int const   )*f == 72) {
#line 119
        if (hh >= 0) {
          {
#line 120
          error1(mpl, str, s, fmt___0, f, "hour multiply specified");
          }
        }
        {
#line 122
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 122
          if (! ((int const   )*s == 32)) {
#line 122
            goto while_break___5;
          }
#line 122
          s ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 123
        if (48 <= (int )*s) {
#line 123
          if (! ((int const   )*s <= 57)) {
            {
#line 124
            error1(mpl, str, s, fmt___0, f, "hour missing or invalid");
            }
          }
        } else {
          {
#line 124
          error1(mpl, str, s, fmt___0, f, "hour missing or invalid");
          }
        }
#line 126
        tmp___5 = s;
#line 126
        s ++;
#line 126
        hh = (int )((int const   )*tmp___5 - 48);
#line 127
        if (48 <= (int )*s) {
#line 127
          if ((int const   )*s <= 57) {
#line 128
            tmp___6 = s;
#line 128
            s ++;
#line 128
            hh = 10 * hh + (int )((int const   )*tmp___6 - 48);
          }
        }
#line 129
        if (0 <= hh) {
#line 129
          if (! (hh <= 23)) {
            {
#line 130
            error1(mpl, str, s, fmt___0, f, "hour out of range");
            }
          }
        } else {
          {
#line 130
          error1(mpl, str, s, fmt___0, f, "hour out of range");
          }
        }
      } else
#line 132
      if ((int const   )*f == 109) {
#line 134
        if (month >= 0) {
          {
#line 135
          error1(mpl, str, s, fmt___0, f, "month multiply specified");
          }
        }
        {
#line 137
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 137
          if (! ((int const   )*s == 32)) {
#line 137
            goto while_break___6;
          }
#line 137
          s ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 138
        if (48 <= (int )*s) {
#line 138
          if (! ((int const   )*s <= 57)) {
            {
#line 139
            error1(mpl, str, s, fmt___0, f, "month missing or invalid");
            }
          }
        } else {
          {
#line 139
          error1(mpl, str, s, fmt___0, f, "month missing or invalid");
          }
        }
#line 141
        tmp___7 = s;
#line 141
        s ++;
#line 141
        month = (int )((int const   )*tmp___7 - 48);
#line 142
        if (48 <= (int )*s) {
#line 142
          if ((int const   )*s <= 57) {
#line 143
            tmp___8 = s;
#line 143
            s ++;
#line 143
            month = 10 * month + (int )((int const   )*tmp___8 - 48);
          }
        }
#line 144
        if (1 <= month) {
#line 144
          if (! (month <= 12)) {
            {
#line 145
            error1(mpl, str, s, fmt___0, f, "month out of range");
            }
          }
        } else {
          {
#line 145
          error1(mpl, str, s, fmt___0, f, "month out of range");
          }
        }
      } else
#line 147
      if ((int const   )*f == 77) {
#line 149
        if (mm >= 0) {
          {
#line 150
          error1(mpl, str, s, fmt___0, f, "minute multiply specified");
          }
        }
        {
#line 152
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 152
          if (! ((int const   )*s == 32)) {
#line 152
            goto while_break___7;
          }
#line 152
          s ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 153
        if (48 <= (int )*s) {
#line 153
          if (! ((int const   )*s <= 57)) {
            {
#line 154
            error1(mpl, str, s, fmt___0, f, "minute missing or invalid");
            }
          }
        } else {
          {
#line 154
          error1(mpl, str, s, fmt___0, f, "minute missing or invalid");
          }
        }
#line 156
        tmp___9 = s;
#line 156
        s ++;
#line 156
        mm = (int )((int const   )*tmp___9 - 48);
#line 157
        if (48 <= (int )*s) {
#line 157
          if ((int const   )*s <= 57) {
#line 158
            tmp___10 = s;
#line 158
            s ++;
#line 158
            mm = 10 * mm + (int )((int const   )*tmp___10 - 48);
          }
        }
#line 159
        if (0 <= mm) {
#line 159
          if (! (mm <= 59)) {
            {
#line 160
            error1(mpl, str, s, fmt___0, f, "minute out of range");
            }
          }
        } else {
          {
#line 160
          error1(mpl, str, s, fmt___0, f, "minute out of range");
          }
        }
      } else
#line 162
      if ((int const   )*f == 83) {
#line 164
        if (ss >= 0) {
          {
#line 165
          error1(mpl, str, s, fmt___0, f, "second multiply specified");
          }
        }
        {
#line 167
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 167
          if (! ((int const   )*s == 32)) {
#line 167
            goto while_break___8;
          }
#line 167
          s ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 168
        if (48 <= (int )*s) {
#line 168
          if (! ((int const   )*s <= 57)) {
            {
#line 169
            error1(mpl, str, s, fmt___0, f, "second missing or invalid");
            }
          }
        } else {
          {
#line 169
          error1(mpl, str, s, fmt___0, f, "second missing or invalid");
          }
        }
#line 171
        tmp___11 = s;
#line 171
        s ++;
#line 171
        ss = (int )((int const   )*tmp___11 - 48);
#line 172
        if (48 <= (int )*s) {
#line 172
          if ((int const   )*s <= 57) {
#line 173
            tmp___12 = s;
#line 173
            s ++;
#line 173
            ss = 10 * ss + (int )((int const   )*tmp___12 - 48);
          }
        }
#line 174
        if (0 <= ss) {
#line 174
          if (! (ss <= 60)) {
            {
#line 175
            error1(mpl, str, s, fmt___0, f, "second out of range");
            }
          }
        } else {
          {
#line 175
          error1(mpl, str, s, fmt___0, f, "second out of range");
          }
        }
      } else
#line 177
      if ((int const   )*f == 121) {
#line 182
        if (year >= 0) {
          {
#line 183
          error1(mpl, str, s, fmt___0, f, "year multiply specified");
          }
        }
        {
#line 185
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 185
          if (! ((int const   )*s == 32)) {
#line 185
            goto while_break___9;
          }
#line 185
          s ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 186
        if (48 <= (int )*s) {
#line 186
          if (! ((int const   )*s <= 57)) {
            {
#line 187
            error1(mpl, str, s, fmt___0, f, "year missing or invalid");
            }
          }
        } else {
          {
#line 187
          error1(mpl, str, s, fmt___0, f, "year missing or invalid");
          }
        }
#line 189
        tmp___13 = s;
#line 189
        s ++;
#line 189
        year = (int )((int const   )*tmp___13 - 48);
#line 190
        if (48 <= (int )*s) {
#line 190
          if ((int const   )*s <= 57) {
#line 191
            tmp___14 = s;
#line 191
            s ++;
#line 191
            year = 10 * year + (int )((int const   )*tmp___14 - 48);
          }
        }
#line 192
        if (year >= 69) {
#line 192
          tmp___15 = 1900;
        } else {
#line 192
          tmp___15 = 2000;
        }
#line 192
        year += tmp___15;
      } else
#line 194
      if ((int const   )*f == 89) {
#line 197
        if (year >= 0) {
          {
#line 198
          error1(mpl, str, s, fmt___0, f, "year multiply specified");
          }
        }
        {
#line 200
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 200
          if (! ((int const   )*s == 32)) {
#line 200
            goto while_break___10;
          }
#line 200
          s ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 201
        if (48 <= (int )*s) {
#line 201
          if (! ((int const   )*s <= 57)) {
            {
#line 202
            error1(mpl, str, s, fmt___0, f, "year missing or invalid");
            }
          }
        } else {
          {
#line 202
          error1(mpl, str, s, fmt___0, f, "year missing or invalid");
          }
        }
#line 204
        year = 0;
#line 205
        j = 1;
        {
#line 205
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 205
          if (! (j <= 4)) {
#line 205
            goto while_break___11;
          }
#line 206
          if (48 <= (int )*s) {
#line 206
            if (! ((int const   )*s <= 57)) {
#line 206
              goto while_break___11;
            }
          } else {
#line 206
            goto while_break___11;
          }
#line 207
          tmp___16 = s;
#line 207
          s ++;
#line 207
          year = 10 * year + (int )((int const   )*tmp___16 - 48);
#line 205
          j ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 209
        if (1 <= year) {
#line 209
          if (! (year <= 4000)) {
            {
#line 210
            error1(mpl, str, s, fmt___0, f, "year out of range");
            }
          }
        } else {
          {
#line 210
          error1(mpl, str, s, fmt___0, f, "year out of range");
          }
        }
      } else
#line 212
      if ((int const   )*f == 122) {
#line 215
        if (zone != 2147483647) {
          {
#line 216
          error1(mpl, str, s, fmt___0, f, "time zone offset multiply specified");
          }
        }
        {
#line 218
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 218
          if (! ((int const   )*s == 32)) {
#line 218
            goto while_break___12;
          }
#line 218
          s ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 219
        if ((int const   )*s == 90) {
#line 220
          mm___0 = 0;
#line 220
          hh___0 = mm___0;
#line 220
          z = hh___0;
#line 220
          s ++;
#line 221
          goto skip;
        }
#line 223
        if ((int const   )*s == 43) {
#line 224
          z = 1;
#line 224
          s ++;
        } else
#line 225
        if ((int const   )*s == 45) {
#line 226
          z = -1;
#line 226
          s ++;
        } else {
          {
#line 228
          error1(mpl, str, s, fmt___0, f, "time zone offset sign missing");
          }
        }
#line 230
        hh___0 = 0;
#line 231
        j = 1;
        {
#line 231
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 231
          if (! (j <= 2)) {
#line 231
            goto while_break___13;
          }
#line 232
          if (48 <= (int )*s) {
#line 232
            if (! ((int const   )*s <= 57)) {
#line 232
              goto err1;
            }
          } else {
            err1: 
            {
#line 233
            error1(mpl, str, s, fmt___0, f, "time zone offset value incomplete or invalid");
            }
          }
#line 235
          tmp___17 = s;
#line 235
          s ++;
#line 235
          hh___0 = 10 * hh___0 + (int )((int const   )*tmp___17 - 48);
#line 231
          j ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 237
        if (hh___0 > 23) {
          err2: 
          {
#line 238
          error1(mpl, str, s, fmt___0, f, "time zone offset value out of range");
          }
        }
#line 240
        if ((int const   )*s == 58) {
#line 241
          s ++;
#line 242
          if (48 <= (int )*s) {
#line 242
            if (! ((int const   )*s <= 57)) {
#line 242
              goto err1;
            }
          } else {
#line 242
            goto err1;
          }
        }
#line 244
        mm___0 = 0;
#line 245
        if (48 <= (int )*s) {
#line 245
          if (! ((int const   )*s <= 57)) {
#line 245
            goto skip;
          }
        } else {
#line 245
          goto skip;
        }
#line 246
        j = 1;
        {
#line 246
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 246
          if (! (j <= 2)) {
#line 246
            goto while_break___14;
          }
#line 247
          if (48 <= (int )*s) {
#line 247
            if (! ((int const   )*s <= 57)) {
#line 247
              goto err1;
            }
          } else {
#line 247
            goto err1;
          }
#line 248
          tmp___18 = s;
#line 248
          s ++;
#line 248
          mm___0 = 10 * mm___0 + (int )((int const   )*tmp___18 - 48);
#line 246
          j ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 250
        if (mm___0 > 59) {
#line 250
          goto err2;
        }
        skip: 
#line 251
        zone = z * (60 * hh___0 + mm___0);
      } else
#line 253
      if ((int const   )*f == 37) {
#line 255
        goto test;
      } else {
        {
#line 258
        error1(mpl, str, s, fmt___0, f, "invalid conversion specifier");
        }
      }
    } else
#line 261
    if (! ((int const   )*f == 32)) {
      test: 
#line 265
      if ((int const   )*s != (int const   )*f) {
        {
#line 266
        error1(mpl, str, s, fmt___0, f, "character mismatch");
        }
      }
#line 267
      s ++;
    }
#line 73
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  if (year < 0) {
#line 270
    year = 1970;
  }
#line 271
  if (month < 0) {
#line 271
    month = 1;
  }
#line 272
  if (day < 0) {
#line 272
    day = 1;
  }
#line 273
  if (hh < 0) {
#line 273
    hh = 0;
  }
#line 274
  if (mm < 0) {
#line 274
    mm = 0;
  }
#line 275
  if (ss < 0) {
#line 275
    ss = 0;
  }
#line 276
  if (zone == 2147483647) {
#line 276
    zone = 0;
  }
  {
#line 277
  j = _glp_lib_jday(day, month, year);
  }
#line 278
  if (j >= 0) {
#line 278
    tmp___19 = 1;
  } else {
    {
#line 278
    _glp_lib_xassert("j >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c",
                     278);
#line 278
    tmp___19 = 1;
    }
  }
  {
#line 279
  tmp___20 = _glp_lib_jday(1, 1, 1970);
  }
#line 279
  return (((((double )(j - tmp___20) * 24.0 + (double )hh) * 60.0 + (double )mm) * 60.0 + (double )ss) - 60.0 * (double )zone);
}
}
#line 283 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
static void error2(MPL *mpl , char const   *fmt___0 , char const   *f , char const   *msg ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 285
  _glp_lib_xprintf("Format string passed to time2str:\n");
#line 286
  _glp_lib_xprintf("%s\n", fmt___0);
#line 287
  _glp_lib_xprintf("%*s\n", (f - fmt___0) + 1L, "^");
#line 288
  _glp_mpl_error(mpl, (char *)"%s", msg);
  }
#line 290
  return;
}
}
#line 292 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
static int weekday(int j ) 
{ 
  int tmp ;

  {
  {
#line 294
  tmp = _glp_lib_jday(1, 1, 1970);
  }
#line 294
  return ((j + tmp) % 7 + 1);
}
}
#line 297 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
static int firstday(int year ) 
{ 
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 304
  tmp = _glp_lib_jday(1, 1, year);
#line 304
  tmp___0 = _glp_lib_jday(1, 1, 1970);
#line 304
  j = tmp - tmp___0;
#line 305
  tmp___1 = weekday(j);
  }
  {
#line 306
  if (tmp___1 == 1) {
#line 306
    goto case_1;
  }
#line 307
  if (tmp___1 == 2) {
#line 307
    goto case_2;
  }
#line 308
  if (tmp___1 == 3) {
#line 308
    goto case_3;
  }
#line 309
  if (tmp___1 == 4) {
#line 309
    goto case_4;
  }
#line 310
  if (tmp___1 == 5) {
#line 310
    goto case_5;
  }
#line 311
  if (tmp___1 == 6) {
#line 311
    goto case_6;
  }
#line 312
  if (tmp___1 == 7) {
#line 312
    goto case_7;
  }
#line 313
  goto switch_default;
  case_1: /* CIL Label */ 
#line 306
  j = j;
#line 306
  goto switch_break;
  case_2: /* CIL Label */ 
#line 307
  j --;
#line 307
  goto switch_break;
  case_3: /* CIL Label */ 
#line 308
  j -= 2;
#line 308
  goto switch_break;
  case_4: /* CIL Label */ 
#line 309
  j -= 3;
#line 309
  goto switch_break;
  case_5: /* CIL Label */ 
#line 310
  j += 3;
#line 310
  goto switch_break;
  case_6: /* CIL Label */ 
#line 311
  j += 2;
#line 311
  goto switch_break;
  case_7: /* CIL Label */ 
#line 312
  j ++;
#line 312
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 313
  if (j != j) {
#line 313
    tmp___2 = 1;
  } else {
    {
#line 313
    _glp_lib_xassert("j != j", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c",
                     313);
#line 313
    tmp___2 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 316
  tmp___3 = weekday(j);
  }
#line 316
  if (tmp___3 == 1) {
#line 316
    tmp___4 = 1;
  } else {
    {
#line 316
    _glp_lib_xassert("weekday(j) == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c",
                     316);
#line 316
    tmp___4 = 1;
    }
  }
#line 317
  return (j);
}
}
#line 320 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c"
void _glp_mpl_fn_time2str(MPL *mpl , char *str , double t , char const   *fmt___0 ) 
{ 
  int j ;
  int year ;
  int month ;
  int day ;
  int hh ;
  int mm ;
  int ss ;
  int len ;
  double temp ;
  char const   *f ;
  char buf[101] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int iso ;
  int tmp___8 ;
  int tmp___9 ;
  int iso___0 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int sun ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int iso___1 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int mon ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  void *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;

  {
#line 326
  if (- 62135596800.0 <= t) {
#line 326
    if (! (t <= 64092211199.0)) {
      {
#line 327
      _glp_mpl_error(mpl, (char *)"time2str(%.*g,...); argument out of range", 15,
                     t);
      }
    }
  } else {
    {
#line 327
    _glp_mpl_error(mpl, (char *)"time2str(%.*g,...); argument out of range", 15, t);
    }
  }
  {
#line 329
  t = floor(t + 0.5);
#line 330
  tmp = fabs(t);
#line 330
  temp = tmp / 86400.0;
#line 331
  tmp___0 = floor(temp);
#line 331
  j = (int )tmp___0;
  }
#line 332
  if (t < 0.0) {
    {
#line 333
    tmp___1 = floor(temp);
    }
#line 333
    if (temp == tmp___1) {
#line 334
      j = - j;
    } else {
#line 336
      j = - (j + 1);
    }
  }
  {
#line 338
  tmp___2 = _glp_lib_jday(1, 1, 1970);
#line 338
  tmp___3 = _glp_lib_jdate(j + tmp___2, & day, & month, & year);
  }
#line 338
  if (tmp___3 == 0) {
#line 338
    tmp___4 = 1;
  } else {
    {
#line 338
    _glp_lib_xassert("jdate(j + jday(1, 1, 1970), &day, &month, &year) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c",
                     338);
#line 338
    tmp___4 = 1;
    }
  }
#line 339
  ss = (int )(t - 86400.0 * (double )j);
#line 340
  if (0 <= ss) {
#line 340
    if (ss < 86400) {
#line 340
      tmp___5 = 1;
    } else {
      {
#line 340
      _glp_lib_xassert("0 <= ss && ss < 86400", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c",
                       340);
#line 340
      tmp___5 = 1;
      }
    }
  } else {
    {
#line 340
    _glp_lib_xassert("0 <= ss && ss < 86400", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl05.c",
                     340);
#line 340
    tmp___5 = 1;
    }
  }
#line 341
  mm = ss / 60;
#line 341
  ss %= 60;
#line 342
  hh = mm / 60;
#line 342
  mm %= 60;
#line 343
  len = 0;
#line 344
  f = fmt___0;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((int const   )*f != 0)) {
#line 344
      goto while_break;
    }
#line 345
    if ((int const   )*f == 37) {
#line 346
      f ++;
#line 347
      if ((int const   )*f == 97) {
        {
#line 349
        tmp___6 = weekday(j);
#line 349
        memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)week[tmp___6 - 1],
               (size_t )3);
#line 349
        buf[3] = (char )'\000';
        }
      } else
#line 351
      if ((int const   )*f == 65) {
        {
#line 353
        tmp___7 = weekday(j);
#line 353
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)week[tmp___7 - 1]);
        }
      } else
#line 355
      if ((int const   )*f == 98) {
        {
#line 357
        memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)moon[month - 1],
               (size_t )3);
#line 357
        buf[3] = (char )'\000';
        }
      } else
#line 355
      if ((int const   )*f == 104) {
        {
#line 357
        memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)moon[month - 1],
               (size_t )3);
#line 357
        buf[3] = (char )'\000';
        }
      } else
#line 359
      if ((int const   )*f == 66) {
        {
#line 361
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)moon[month - 1]);
        }
      } else
#line 363
      if ((int const   )*f == 67) {
        {
#line 365
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                year / 100);
        }
      } else
#line 367
      if ((int const   )*f == 100) {
        {
#line 369
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                day);
        }
      } else
#line 371
      if ((int const   )*f == 68) {
        {
#line 373
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d/%02d/%02d",
                month, day, year % 100);
        }
      } else
#line 375
      if ((int const   )*f == 101) {
        {
#line 378
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%2d",
                day);
        }
      } else
#line 380
      if ((int const   )*f == 70) {
        {
#line 382
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%04d-%02d-%02d",
                year, month, day);
        }
      } else
#line 384
      if ((int const   )*f == 103) {
        {
#line 391
        tmp___9 = firstday(year);
        }
#line 391
        if (j < tmp___9) {
#line 392
          iso = year - 1;
        } else {
          {
#line 393
          tmp___8 = firstday(year + 1);
          }
#line 393
          if (j < tmp___8) {
#line 394
            iso = year;
          } else {
#line 396
            iso = year + 1;
          }
        }
        {
#line 397
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                iso % 100);
        }
      } else
#line 399
      if ((int const   )*f == 71) {
        {
#line 405
        tmp___11 = firstday(year);
        }
#line 405
        if (j < tmp___11) {
#line 406
          iso___0 = year - 1;
        } else {
          {
#line 407
          tmp___10 = firstday(year + 1);
          }
#line 407
          if (j < tmp___10) {
#line 408
            iso___0 = year;
          } else {
#line 410
            iso___0 = year + 1;
          }
        }
        {
#line 411
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%04d",
                iso___0);
        }
      } else
#line 413
      if ((int const   )*f == 72) {
        {
#line 416
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                hh);
        }
      } else
#line 418
      if ((int const   )*f == 73) {
#line 421
        if (hh == 0) {
#line 421
          tmp___13 = 12;
        } else {
#line 421
          if (hh <= 12) {
#line 421
            tmp___12 = hh;
          } else {
#line 421
            tmp___12 = hh - 12;
          }
#line 421
          tmp___13 = tmp___12;
        }
        {
#line 421
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                tmp___13);
        }
      } else
#line 424
      if ((int const   )*f == 106) {
        {
#line 426
        tmp___14 = _glp_lib_jday(day, month, year);
#line 426
        tmp___15 = _glp_lib_jday(1, 1, year);
#line 426
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%03d",
                (tmp___14 - tmp___15) + 1);
        }
      } else
#line 429
      if ((int const   )*f == 107) {
        {
#line 432
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%2d",
                hh);
        }
      } else
#line 434
      if ((int const   )*f == 108) {
#line 437
        if (hh == 0) {
#line 437
          tmp___17 = 12;
        } else {
#line 437
          if (hh <= 12) {
#line 437
            tmp___16 = hh;
          } else {
#line 437
            tmp___16 = hh - 12;
          }
#line 437
          tmp___17 = tmp___16;
        }
        {
#line 437
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%2d",
                tmp___17);
        }
      } else
#line 440
      if ((int const   )*f == 109) {
        {
#line 442
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                month);
        }
      } else
#line 444
      if ((int const   )*f == 77) {
        {
#line 446
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                mm);
        }
      } else
#line 448
      if ((int const   )*f == 112) {
#line 451
        if (hh <= 11) {
#line 451
          tmp___18 = "AM";
        } else {
#line 451
          tmp___18 = "PM";
        }
        {
#line 451
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___18);
        }
      } else
#line 453
      if ((int const   )*f == 80) {
#line 456
        if (hh <= 11) {
#line 456
          tmp___19 = "am";
        } else {
#line 456
          tmp___19 = "pm";
        }
        {
#line 456
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___19);
        }
      } else
#line 458
      if ((int const   )*f == 114) {
#line 460
        if (hh <= 11) {
#line 460
          tmp___20 = "AM";
        } else {
#line 460
          tmp___20 = "PM";
        }
#line 460
        if (hh == 0) {
#line 460
          tmp___22 = 12;
        } else {
#line 460
          if (hh <= 12) {
#line 460
            tmp___21 = hh;
          } else {
#line 460
            tmp___21 = hh - 12;
          }
#line 460
          tmp___22 = tmp___21;
        }
        {
#line 460
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d:%02d:%02d %s",
                tmp___22, mm, ss, tmp___20);
        }
      } else
#line 464
      if ((int const   )*f == 82) {
        {
#line 466
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d:%02d",
                hh, mm);
        }
      } else
#line 468
      if ((int const   )*f == 83) {
        {
#line 470
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                ss);
        }
      } else
#line 472
      if ((int const   )*f == 84) {
        {
#line 474
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d:%02d:%02d",
                hh, mm, ss);
        }
      } else
#line 476
      if ((int const   )*f == 117) {
        {
#line 479
        tmp___23 = weekday(j);
#line 479
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
                tmp___23);
        }
      } else
#line 481
      if ((int const   )*f == 85) {
        {
#line 493
        tmp___24 = _glp_lib_jday(1, 1, year);
#line 493
        tmp___25 = _glp_lib_jday(1, 1, 1970);
#line 493
        sun = tmp___24 - tmp___25;
#line 494
        tmp___26 = weekday(sun);
#line 494
        sun += 7 - tmp___26;
#line 495
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                ((j + 7) - sun) / 7);
        }
      } else
#line 497
      if ((int const   )*f == 86) {
        {
#line 507
        tmp___31 = firstday(year);
        }
#line 507
        if (j < tmp___31) {
          {
#line 508
          tmp___27 = firstday(year - 1);
#line 508
          iso___1 = j - tmp___27;
          }
        } else {
          {
#line 509
          tmp___30 = firstday(year + 1);
          }
#line 509
          if (j < tmp___30) {
            {
#line 510
            tmp___28 = firstday(year);
#line 510
            iso___1 = j - tmp___28;
            }
          } else {
            {
#line 512
            tmp___29 = firstday(year + 1);
#line 512
            iso___1 = j - tmp___29;
            }
          }
        }
        {
#line 513
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                iso___1 / 7 + 1);
        }
      } else
#line 515
      if ((int const   )*f == 119) {
        {
#line 518
        tmp___32 = weekday(j);
#line 518
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
                tmp___32 % 7);
        }
      } else
#line 520
      if ((int const   )*f == 87) {
        {
#line 528
        tmp___33 = _glp_lib_jday(1, 1, year);
#line 528
        tmp___34 = _glp_lib_jday(1, 1, 1970);
#line 528
        mon = tmp___33 - tmp___34;
#line 529
        tmp___35 = weekday(mon);
#line 529
        mon += (8 - tmp___35) % 7;
#line 530
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                ((j + 7) - mon) / 7);
        }
      } else
#line 532
      if ((int const   )*f == 121) {
        {
#line 535
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d",
                year % 100);
        }
      } else
#line 537
      if ((int const   )*f == 89) {
        {
#line 540
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%04d",
                year);
        }
      } else
#line 542
      if ((int const   )*f == 37) {
#line 544
        buf[0] = (char )'%';
#line 544
        buf[1] = (char )'\000';
      } else {
        {
#line 547
        error2(mpl, fmt___0, f, "invalid conversion specifier");
        }
      }
    } else {
#line 550
      buf[0] = (char )*f;
#line 550
      buf[1] = (char )'\000';
    }
    {
#line 551
    tmp___36 = strlen((char const   *)(buf));
    }
#line 551
    if ((size_t )len + tmp___36 > 100U) {
      {
#line 552
      _glp_mpl_error(mpl, (char *)"time2str; output string length exceeds %d characters",
                     100);
      }
    }
    {
#line 554
    tmp___37 = strlen((char const   *)(buf));
#line 554
    memcpy((void */* __restrict  */)(str + len), (void const   */* __restrict  */)(buf),
           tmp___37);
#line 555
    tmp___38 = strlen((char const   *)(buf));
#line 555
    len = (int )((size_t )len + tmp___38);
#line 344
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  *(str + len) = (char )'\000';
#line 558
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 356
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.h"
xlong_t _glp_dmp_in_use(DMP *pool ) ;
#line 80 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
AVL *_glp_avl_create_tree(int (*fcmp___3)(void *info , void const   *key1 , void const   *key2 ) ,
                          void *info ) ;
#line 85
int _glp_avl_strcmp(void *info , void const   *key1 , void const   *key2 ) ;
#line 117
void _glp_avl_delete_tree(AVL *tree ) ;
#line 335 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
void _glp_mpl_print_context(MPL *mpl ) ;
#line 339
void _glp_mpl_get_char(MPL *mpl ) ;
#line 347
void _glp_mpl_get_token(MPL *mpl ) ;
#line 355
int _glp_mpl_is_keyword(MPL *mpl , char *keyword ) ;
#line 588
void _glp_mpl_end_statement(MPL *mpl ) ;
#line 596
void _glp_mpl_model_section(MPL *mpl ) ;
#line 662
int _glp_mpl_is_literal(MPL *mpl , char *literal ) ;
#line 763
void _glp_mpl_data_section(MPL *mpl ) ;
#line 1046
char *_glp_mpl_format_tuple(MPL *mpl , int c , TUPLE *tuple ) ;
#line 1362
ARRAY *_glp_mpl_create_array(MPL *mpl , int type , int dim ) ;
#line 2325
void _glp_mpl_free_dca(MPL *mpl ) ;
#line 2365
void _glp_mpl_execute_statement(MPL *mpl , STATEMENT *stmt ) ;
#line 2369
void _glp_mpl_clean_statement(MPL *mpl , STATEMENT *stmt ) ;
#line 2377
void _glp_mpl_alloc_content(MPL *mpl ) ;
#line 2381
void _glp_mpl_generate_model(MPL *mpl ) ;
#line 2385
void _glp_mpl_build_problem(MPL *mpl ) ;
#line 2389
void _glp_mpl_postsolve_model(MPL *mpl ) ;
#line 2393
void _glp_mpl_clean_model(MPL *mpl ) ;
#line 2401
void _glp_mpl_open_input(MPL *mpl , char *file ) ;
#line 2405
int _glp_mpl_read_char(MPL *mpl ) ;
#line 2409
void _glp_mpl_close_input(MPL *mpl ) ;
#line 2413
void _glp_mpl_open_output(MPL *mpl , char *file ) ;
#line 2417
void _glp_mpl_write_char(MPL *mpl , int c ) ;
#line 2421
void _glp_mpl_write_text(MPL *mpl , char *fmt___0  , ...) ;
#line 2425
void _glp_mpl_flush_output(MPL *mpl ) ;
#line 2451
void _glp_mpl_warning(MPL *mpl , char *fmt___0  , ...) ;
#line 2455
MPL *_glp_mpl_initialize(void) ;
#line 2459
int _glp_mpl_read_model(MPL *mpl , char *file , int skip_data ) ;
#line 2463
int _glp_mpl_read_data(MPL *mpl , char *file ) ;
#line 2467
int _glp_mpl_generate(MPL *mpl , char *file ) ;
#line 2471
char *_glp_mpl_get_prob_name(MPL *mpl ) ;
#line 2475
int _glp_mpl_get_num_rows(MPL *mpl ) ;
#line 2479
int _glp_mpl_get_num_cols(MPL *mpl ) ;
#line 2483
char *_glp_mpl_get_row_name(MPL *mpl , int i ) ;
#line 2487
int _glp_mpl_get_row_kind(MPL *mpl , int i ) ;
#line 2491
int _glp_mpl_get_row_bnds(MPL *mpl , int i , double *_lb , double *_ub ) ;
#line 2495
int _glp_mpl_get_mat_row(MPL *mpl , int i , int *ndx , double *val ) ;
#line 2499
double _glp_mpl_get_row_c0(MPL *mpl , int i ) ;
#line 2503
char *_glp_mpl_get_col_name(MPL *mpl , int j ) ;
#line 2507
int _glp_mpl_get_col_kind(MPL *mpl , int j ) ;
#line 2511
int _glp_mpl_get_col_bnds(MPL *mpl , int j , double *_lb , double *_ub ) ;
#line 2515
int _glp_mpl_has_solve_stmt(MPL *mpl ) ;
#line 2519
void _glp_mpl_put_col_value(MPL *mpl , int j , double val ) ;
#line 2523
int _glp_mpl_postsolve(MPL *mpl ) ;
#line 2527
void _glp_mpl_terminate(MPL *mpl ) ;
#line 43 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_alloc_content(MPL *mpl ) 
{ 
  STATEMENT *stmt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 46
  stmt = mpl->model;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 46
      goto while_break;
    }
    {
#line 48
    if (stmt->type == 122) {
#line 48
      goto case_122;
    }
#line 54
    if (stmt->type == 120) {
#line 54
      goto case_120;
    }
#line 72
    if (stmt->type == 127) {
#line 72
      goto case_127;
    }
#line 78
    if (stmt->type == 103) {
#line 78
      goto case_103;
    }
#line 91
    if (stmt->type == 109) {
#line 91
      goto case_109;
    }
#line 91
    if (stmt->type == 121) {
#line 91
      goto case_109;
    }
#line 91
    if (stmt->type == 104) {
#line 91
      goto case_109;
    }
#line 91
    if (stmt->type == 102) {
#line 91
      goto case_109;
    }
#line 91
    if (stmt->type == 123) {
#line 91
      goto case_109;
    }
#line 91
    if (stmt->type == 125) {
#line 91
      goto case_109;
    }
#line 94
    goto switch_default___0;
    case_122: /* CIL Label */ 
#line 50
    if ((unsigned long )(stmt->u.set)->array == (unsigned long )((void *)0)) {
#line 50
      tmp = 1;
    } else {
      {
#line 50
      _glp_lib_xassert("stmt->u.set->array == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       50);
#line 50
      tmp = 1;
      }
    }
    {
#line 51
    (stmt->u.set)->array = _glp_mpl_create_array(mpl, 106, (stmt->u.set)->dim);
    }
#line 53
    goto switch_break;
    case_120: /* CIL Label */ 
#line 56
    if ((unsigned long )(stmt->u.par)->array == (unsigned long )((void *)0)) {
#line 56
      tmp___0 = 1;
    } else {
      {
#line 56
      _glp_lib_xassert("stmt->u.par->array == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       56);
#line 56
      tmp___0 = 1;
      }
    }
    {
#line 60
    if ((stmt->u.par)->type == 101) {
#line 60
      goto case_101;
    }
#line 60
    if ((stmt->u.par)->type == 113) {
#line 60
      goto case_101;
    }
#line 60
    if ((stmt->u.par)->type == 118) {
#line 60
      goto case_101;
    }
#line 64
    if ((stmt->u.par)->type == 124) {
#line 64
      goto case_124;
    }
#line 68
    goto switch_default;
    case_101: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_118: /* CIL Label */ 
    {
#line 61
    (stmt->u.par)->array = _glp_mpl_create_array(mpl, 118, (stmt->u.par)->dim);
    }
#line 63
    goto switch_break___0;
    case_124: /* CIL Label */ 
    {
#line 65
    (stmt->u.par)->array = _glp_mpl_create_array(mpl, 124, (stmt->u.par)->dim);
    }
#line 67
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 69
    if ((unsigned long )stmt != (unsigned long )stmt) {
#line 69
      tmp___1 = 1;
    } else {
      {
#line 69
      _glp_lib_xassert("stmt != stmt", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       69);
#line 69
      tmp___1 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 71
    goto switch_break;
    case_127: /* CIL Label */ 
#line 74
    if ((unsigned long )(stmt->u.var)->array == (unsigned long )((void *)0)) {
#line 74
      tmp___2 = 1;
    } else {
      {
#line 74
      _glp_lib_xassert("stmt->u.var->array == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       74);
#line 74
      tmp___2 = 1;
      }
    }
    {
#line 75
    (stmt->u.var)->array = _glp_mpl_create_array(mpl, 107, (stmt->u.var)->dim);
    }
#line 77
    goto switch_break;
    case_103: /* CIL Label */ 
#line 80
    if ((unsigned long )(stmt->u.con)->array == (unsigned long )((void *)0)) {
#line 80
      tmp___3 = 1;
    } else {
      {
#line 80
      _glp_lib_xassert("stmt->u.con->array == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       80);
#line 80
      tmp___3 = 1;
      }
    }
    {
#line 81
    (stmt->u.con)->array = _glp_mpl_create_array(mpl, 105, (stmt->u.con)->dim);
    }
#line 83
    goto switch_break;
    case_109: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_125: /* CIL Label */ 
#line 93
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 95
    if ((unsigned long )stmt != (unsigned long )stmt) {
#line 95
      tmp___4 = 1;
    } else {
      {
#line 95
      _glp_lib_xassert("stmt != stmt", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       95);
#line 95
      tmp___4 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 46
    stmt = stmt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 107 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_generate_model(MPL *mpl ) 
{ 
  STATEMENT *stmt ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 109
  if (! mpl->flag_p) {
#line 109
    tmp = 1;
  } else {
    {
#line 109
    _glp_lib_xassert("!mpl->flag_p", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     109);
#line 109
    tmp = 1;
    }
  }
#line 110
  stmt = mpl->model;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 110
      goto while_break;
    }
    {
#line 111
    _glp_mpl_execute_statement(mpl, stmt);
    }
#line 112
    if ((mpl->stmt)->type == 123) {
#line 112
      goto while_break;
    }
#line 110
    stmt = stmt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  mpl->stmt = stmt;
#line 115
  return;
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_build_problem(MPL *mpl ) 
{ 
  STATEMENT *stmt ;
  MEMBER *memb ;
  VARIABLE *v ;
  CONSTRAINT *c ;
  FORMULA *t ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 131
  if (mpl->m == 0) {
#line 131
    tmp = 1;
  } else {
    {
#line 131
    _glp_lib_xassert("mpl->m == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     131);
#line 131
    tmp = 1;
    }
  }
#line 132
  if (mpl->n == 0) {
#line 132
    tmp___0 = 1;
  } else {
    {
#line 132
    _glp_lib_xassert("mpl->n == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     132);
#line 132
    tmp___0 = 1;
    }
  }
#line 133
  if ((unsigned long )mpl->row == (unsigned long )((void *)0)) {
#line 133
    tmp___1 = 1;
  } else {
    {
#line 133
    _glp_lib_xassert("mpl->row == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     133);
#line 133
    tmp___1 = 1;
    }
  }
#line 134
  if ((unsigned long )mpl->col == (unsigned long )((void *)0)) {
#line 134
    tmp___2 = 1;
  } else {
    {
#line 134
    _glp_lib_xassert("mpl->col == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     134);
#line 134
    tmp___2 = 1;
    }
  }
#line 136
  stmt = mpl->model;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 136
      goto while_break;
    }
#line 137
    if (stmt->type == 127) {
#line 138
      v = stmt->u.var;
#line 139
      memb = (v->array)->head;
      {
#line 139
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 139
        if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 139
          goto while_break___0;
        }
#line 140
        if ((memb->value.var)->j == 0) {
#line 140
          tmp___3 = 1;
        } else {
          {
#line 140
          _glp_lib_xassert("memb->value.var->j == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                           140);
#line 140
          tmp___3 = 1;
          }
        }
#line 139
        memb = memb->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 136
    stmt = stmt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  stmt = mpl->model;
  {
#line 144
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 144
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 144
      goto while_break___1;
    }
#line 145
    if (stmt->type == 103) {
#line 146
      c = stmt->u.con;
#line 147
      memb = (c->array)->head;
      {
#line 147
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 147
        if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 147
          goto while_break___2;
        }
#line 148
        if ((memb->value.con)->i == 0) {
#line 148
          tmp___4 = 1;
        } else {
          {
#line 148
          _glp_lib_xassert("memb->value.con->i == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                           148);
#line 148
          tmp___4 = 1;
          }
        }
#line 149
        (mpl->m) ++;
#line 149
        (memb->value.con)->i = mpl->m;
#line 152
        t = (memb->value.con)->form;
        {
#line 152
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 152
          if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 152
            goto while_break___3;
          }
#line 153
          if ((unsigned long )t->var != (unsigned long )((void *)0)) {
#line 153
            tmp___5 = 1;
          } else {
            {
#line 153
            _glp_lib_xassert("t->var != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                             153);
#line 153
            tmp___5 = 1;
            }
          }
#line 154
          (((t->var)->memb)->value.var)->j = -1;
#line 152
          t = t->next;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 147
        memb = memb->next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 144
    stmt = stmt->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 160
  stmt = mpl->model;
  {
#line 160
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 160
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 160
      goto while_break___4;
    }
#line 161
    if (stmt->type == 127) {
#line 162
      v = stmt->u.var;
#line 163
      memb = (v->array)->head;
      {
#line 163
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 163
        if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 163
          goto while_break___5;
        }
#line 164
        if ((memb->value.var)->j != 0) {
#line 164
          (mpl->n) ++;
#line 164
          (memb->value.var)->j = mpl->n;
        }
#line 163
        memb = memb->next;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 160
    stmt = stmt->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 169
  tmp___6 = _glp_lib_xcalloc(1 + mpl->m, (int )sizeof(ELEMCON *));
#line 169
  mpl->row = (ELEMCON **)tmp___6;
#line 170
  i = 1;
  }
  {
#line 170
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 170
    if (! (i <= mpl->m)) {
#line 170
      goto while_break___6;
    }
#line 170
    *(mpl->row + i) = (ELEMCON *)((void *)0);
#line 170
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 171
  stmt = mpl->model;
  {
#line 171
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 171
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 171
      goto while_break___7;
    }
#line 172
    if (stmt->type == 103) {
#line 173
      c = stmt->u.con;
#line 174
      memb = (c->array)->head;
      {
#line 174
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 174
        if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 174
          goto while_break___8;
        }
#line 175
        i = (memb->value.con)->i;
#line 176
        if (1 <= i) {
#line 176
          if (i <= mpl->m) {
#line 176
            tmp___7 = 1;
          } else {
            {
#line 176
            _glp_lib_xassert("1 <= i && i <= mpl->m", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                             176);
#line 176
            tmp___7 = 1;
            }
          }
        } else {
          {
#line 176
          _glp_lib_xassert("1 <= i && i <= mpl->m", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                           176);
#line 176
          tmp___7 = 1;
          }
        }
#line 177
        if ((unsigned long )*(mpl->row + i) == (unsigned long )((void *)0)) {
#line 177
          tmp___8 = 1;
        } else {
          {
#line 177
          _glp_lib_xassert("mpl->row[i] == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                           177);
#line 177
          tmp___8 = 1;
          }
        }
#line 178
        *(mpl->row + i) = memb->value.con;
#line 174
        memb = memb->next;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 171
    stmt = stmt->next;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 182
  i = 1;
  {
#line 182
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 182
    if (! (i <= mpl->m)) {
#line 182
      goto while_break___9;
    }
#line 182
    if ((unsigned long )*(mpl->row + i) != (unsigned long )((void *)0)) {
#line 182
      tmp___9 = 1;
    } else {
      {
#line 182
      _glp_lib_xassert("mpl->row[i] != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       182);
#line 182
      tmp___9 = 1;
      }
    }
#line 182
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 184
  tmp___10 = _glp_lib_xcalloc(1 + mpl->n, (int )sizeof(ELEMVAR *));
#line 184
  mpl->col = (ELEMVAR **)tmp___10;
#line 185
  j = 1;
  }
  {
#line 185
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 185
    if (! (j <= mpl->n)) {
#line 185
      goto while_break___10;
    }
#line 185
    *(mpl->col + j) = (ELEMVAR *)((void *)0);
#line 185
    j ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 186
  stmt = mpl->model;
  {
#line 186
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 186
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 186
      goto while_break___11;
    }
#line 187
    if (stmt->type == 127) {
#line 188
      v = stmt->u.var;
#line 189
      memb = (v->array)->head;
      {
#line 189
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 189
        if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 189
          goto while_break___12;
        }
#line 190
        j = (memb->value.var)->j;
#line 191
        if (j == 0) {
#line 191
          goto __Cont;
        }
#line 192
        if (1 <= j) {
#line 192
          if (j <= mpl->n) {
#line 192
            tmp___11 = 1;
          } else {
            {
#line 192
            _glp_lib_xassert("1 <= j && j <= mpl->n", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                             192);
#line 192
            tmp___11 = 1;
            }
          }
        } else {
          {
#line 192
          _glp_lib_xassert("1 <= j && j <= mpl->n", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                           192);
#line 192
          tmp___11 = 1;
          }
        }
#line 193
        if ((unsigned long )*(mpl->col + j) == (unsigned long )((void *)0)) {
#line 193
          tmp___12 = 1;
        } else {
          {
#line 193
          _glp_lib_xassert("mpl->col[j] == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                           193);
#line 193
          tmp___12 = 1;
          }
        }
#line 194
        *(mpl->col + j) = memb->value.var;
        __Cont: /* CIL Label */ 
#line 189
        memb = memb->next;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 186
    stmt = stmt->next;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 198
  j = 1;
  {
#line 198
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 198
    if (! (j <= mpl->n)) {
#line 198
      goto while_break___13;
    }
#line 198
    if ((unsigned long )*(mpl->col + j) != (unsigned long )((void *)0)) {
#line 198
      tmp___13 = 1;
    } else {
      {
#line 198
      _glp_lib_xassert("mpl->col[j] != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       198);
#line 198
      tmp___13 = 1;
      }
    }
#line 198
    j ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 199
  return;
}
}
#line 208 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_postsolve_model(MPL *mpl ) 
{ 
  STATEMENT *stmt ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 210
  if (! mpl->flag_p) {
#line 210
    tmp = 1;
  } else {
    {
#line 210
    _glp_lib_xassert("!mpl->flag_p", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     210);
#line 210
    tmp = 1;
    }
  }
#line 211
  mpl->flag_p = 1;
#line 212
  stmt = mpl->stmt;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 212
      goto while_break;
    }
    {
#line 213
    _glp_mpl_execute_statement(mpl, stmt);
#line 212
    stmt = stmt->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  mpl->stmt = (STATEMENT *)((void *)0);
#line 215
  return;
}
}
#line 231 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_clean_model(MPL *mpl ) 
{ 
  STATEMENT *stmt ;
  xlong_t tmp ;
  xlong_t tmp___0 ;
  xlong_t tmp___1 ;
  xlong_t tmp___2 ;
  xlong_t tmp___3 ;
  xlong_t tmp___4 ;
  xlong_t tmp___5 ;
  xlong_t tmp___6 ;
  xlong_t tmp___7 ;
  xlong_t tmp___8 ;
  xlong_t tmp___9 ;
  xlong_t tmp___10 ;
  xlong_t tmp___11 ;
  xlong_t tmp___12 ;
  xlong_t tmp___13 ;
  xlong_t tmp___14 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 233
  stmt = mpl->model;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 233
      goto while_break;
    }
    {
#line 234
    _glp_mpl_clean_statement(mpl, stmt);
#line 233
    stmt = stmt->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  tmp___0 = _glp_dmp_in_use(mpl->strings);
  }
#line 236
  if (tmp___0.lo != 0) {
    {
#line 237
    tmp = _glp_dmp_in_use(mpl->strings);
#line 237
    _glp_mpl_error(mpl, (char *)"internal logic error: %d string segment(s) were lost",
                   tmp.lo);
    }
  }
  {
#line 239
  tmp___2 = _glp_dmp_in_use(mpl->symbols);
  }
#line 239
  if (tmp___2.lo != 0) {
    {
#line 240
    tmp___1 = _glp_dmp_in_use(mpl->symbols);
#line 240
    _glp_mpl_error(mpl, (char *)"internal logic error: %d symbol(s) were lost", tmp___1.lo);
    }
  }
  {
#line 242
  tmp___4 = _glp_dmp_in_use(mpl->tuples);
  }
#line 242
  if (tmp___4.lo != 0) {
    {
#line 243
    tmp___3 = _glp_dmp_in_use(mpl->tuples);
#line 243
    _glp_mpl_error(mpl, (char *)"internal logic error: %d n-tuple component(s) were lost",
                   tmp___3.lo);
    }
  }
  {
#line 245
  tmp___6 = _glp_dmp_in_use(mpl->arrays);
  }
#line 245
  if (tmp___6.lo != 0) {
    {
#line 246
    tmp___5 = _glp_dmp_in_use(mpl->arrays);
#line 246
    _glp_mpl_error(mpl, (char *)"internal logic error: %d array(s) were lost", tmp___5.lo);
    }
  }
  {
#line 248
  tmp___8 = _glp_dmp_in_use(mpl->members);
  }
#line 248
  if (tmp___8.lo != 0) {
    {
#line 249
    tmp___7 = _glp_dmp_in_use(mpl->members);
#line 249
    _glp_mpl_error(mpl, (char *)"internal logic error: %d array member(s) were lost",
                   tmp___7.lo);
    }
  }
  {
#line 251
  tmp___10 = _glp_dmp_in_use(mpl->elemvars);
  }
#line 251
  if (tmp___10.lo != 0) {
    {
#line 252
    tmp___9 = _glp_dmp_in_use(mpl->elemvars);
#line 252
    _glp_mpl_error(mpl, (char *)"internal logic error: %d elemental variable(s) were lost",
                   tmp___9.lo);
    }
  }
  {
#line 254
  tmp___12 = _glp_dmp_in_use(mpl->formulae);
  }
#line 254
  if (tmp___12.lo != 0) {
    {
#line 255
    tmp___11 = _glp_dmp_in_use(mpl->formulae);
#line 255
    _glp_mpl_error(mpl, (char *)"internal logic error: %d linear term(s) were lost",
                   tmp___11.lo);
    }
  }
  {
#line 257
  tmp___14 = _glp_dmp_in_use(mpl->elemcons);
  }
#line 257
  if (tmp___14.lo != 0) {
    {
#line 258
    tmp___13 = _glp_dmp_in_use(mpl->elemcons);
#line 258
    _glp_mpl_error(mpl, (char *)"internal logic error: %d elemental constraint(s) were lost",
                   tmp___13.lo);
    }
  }
#line 260
  return;
}
}
#line 272 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_open_input(MPL *mpl , char *file ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 273
  mpl->line = 0;
#line 274
  mpl->c = '\n';
#line 275
  mpl->token = 0;
#line 276
  mpl->imlen = 0;
#line 277
  *(mpl->image + 0) = (char )'\000';
#line 278
  mpl->value = 0.0;
#line 279
  mpl->b_token = 201;
#line 280
  mpl->b_imlen = 0;
#line 281
  *(mpl->b_image + 0) = (char )'\000';
#line 282
  mpl->b_value = 0.0;
#line 283
  mpl->f_dots = 0;
#line 284
  mpl->f_scan = 0;
#line 285
  mpl->f_token = 0;
#line 286
  mpl->f_imlen = 0;
#line 287
  *(mpl->f_image + 0) = (char )'\000';
#line 288
  mpl->f_value = 0.0;
#line 289
  memset((void *)mpl->context, ' ', (size_t )60);
#line 290
  mpl->c_ptr = 0;
  }
#line 291
  if ((unsigned long )mpl->in_fp == (unsigned long )((void *)0)) {
#line 291
    tmp = 1;
  } else {
    {
#line 291
    _glp_lib_xassert("mpl->in_fp == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     291);
#line 291
    tmp = 1;
    }
  }
  {
#line 292
  mpl->in_fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 293
  if ((unsigned long )mpl->in_fp == (unsigned long )((void *)0)) {
    {
#line 294
    tmp___0 = __errno_location();
#line 294
    tmp___1 = strerror(*tmp___0);
#line 294
    _glp_mpl_error(mpl, (char *)"unable to open %s - %s", file, tmp___1);
    }
  }
  {
#line 295
  mpl->in_file = file;
#line 297
  _glp_mpl_get_char(mpl);
#line 299
  _glp_mpl_get_token(mpl);
  }
#line 300
  return;
}
}
#line 309 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_read_char(MPL *mpl ) 
{ 
  int c ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 311
  if ((unsigned long )mpl->in_fp != (unsigned long )((void *)0)) {
#line 311
    tmp = 1;
  } else {
    {
#line 311
    _glp_lib_xassert("mpl->in_fp != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     311);
#line 311
    tmp = 1;
    }
  }
  {
#line 312
  c = fgetc(mpl->in_fp);
#line 313
  tmp___2 = ferror(mpl->in_fp);
  }
#line 313
  if (tmp___2) {
    {
#line 314
    tmp___0 = __errno_location();
#line 314
    tmp___1 = strerror(*tmp___0);
#line 314
    _glp_mpl_error(mpl, (char *)"read error on %s - %s", mpl->in_file, tmp___1);
    }
  }
  {
#line 316
  tmp___3 = feof(mpl->in_fp);
  }
#line 316
  if (tmp___3) {
#line 316
    c = -1;
  }
#line 317
  return (c);
}
}
#line 325 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_close_input(MPL *mpl ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 326
  if ((unsigned long )mpl->in_fp != (unsigned long )((void *)0)) {
#line 326
    tmp = 1;
  } else {
    {
#line 326
    _glp_lib_xassert("mpl->in_fp != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     326);
#line 326
    tmp = 1;
    }
  }
  {
#line 327
  fclose(mpl->in_fp);
#line 328
  mpl->in_fp = (FILE *)((void *)0);
#line 329
  mpl->in_file = (char *)((void *)0);
  }
#line 330
  return;
}
}
#line 339 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_open_output(MPL *mpl , char *file ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 340
  if ((unsigned long )mpl->out_fp == (unsigned long )((void *)0)) {
#line 340
    tmp = 1;
  } else {
    {
#line 340
    _glp_lib_xassert("mpl->out_fp == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     340);
#line 340
    tmp = 1;
    }
  }
#line 341
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 342
    file = (char *)"<stdout>";
#line 343
    mpl->out_fp = stdout;
  } else {
    {
#line 346
    mpl->out_fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
    }
#line 347
    if ((unsigned long )mpl->out_fp == (unsigned long )((void *)0)) {
      {
#line 348
      tmp___0 = __errno_location();
#line 348
      tmp___1 = strerror(*tmp___0);
#line 348
      _glp_mpl_error(mpl, (char *)"unable to create %s - %s", file, tmp___1);
      }
    }
  }
  {
#line 351
  tmp___2 = strlen((char const   *)file);
#line 351
  tmp___3 = _glp_lib_xmalloc((int )(tmp___2 + 1U));
#line 351
  mpl->out_file = (char *)tmp___3;
#line 352
  strcpy((char */* __restrict  */)mpl->out_file, (char const   */* __restrict  */)file);
#line 353
  tmp___4 = _glp_lib_xmalloc(1024);
#line 353
  mpl->out_buf = (char *)tmp___4;
#line 354
  mpl->out_cnt = 0;
  }
#line 355
  return;
}
}
#line 366 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_write_char(MPL *mpl , int c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 367
  if ((unsigned long )mpl->out_fp != (unsigned long )((void *)0)) {
#line 367
    tmp = 1;
  } else {
    {
#line 367
    _glp_lib_xassert("mpl->out_fp != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     367);
#line 367
    tmp = 1;
    }
  }
#line 368
  if (mpl->out_cnt < 1024) {
#line 368
    tmp___0 = 1;
  } else {
    {
#line 368
    _glp_lib_xassert("mpl->out_cnt < OUTBUF_SIZE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     368);
#line 368
    tmp___0 = 1;
    }
  }
#line 369
  if (c == 10) {
#line 371
    *(mpl->out_buf + mpl->out_cnt) = (char )'\000';
#line 372
    if ((unsigned long )mpl->out_fp == (unsigned long )stdout) {
      {
#line 373
      _glp_lib_xprintf("%s\n", mpl->out_buf);
      }
    } else {
      {
#line 375
      fprintf((FILE */* __restrict  */)mpl->out_fp, (char const   */* __restrict  */)"%s\n",
              mpl->out_buf);
      }
    }
#line 376
    mpl->out_cnt = 0;
  } else {
#line 380
    tmp___1 = mpl->out_cnt;
#line 380
    (mpl->out_cnt) ++;
#line 380
    *(mpl->out_buf + tmp___1) = (char )c;
#line 381
    if (mpl->out_cnt == 1024) {
      {
#line 382
      _glp_mpl_error(mpl, (char *)"write error on %s - output buffer overflow", mpl->out_file);
      }
    }
  }
#line 385
  return;
}
}
#line 394 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_write_text(MPL *mpl , char *fmt___0  , ...) 
{ 
  va_list arg ;
  char buf[1024] ;
  char *c ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 397
  __builtin_va_start(arg, fmt___0);
#line 398
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fmt___0,
           arg);
#line 399
  tmp = strlen((char const   *)(buf));
  }
#line 399
  if ((unsigned long )tmp < sizeof(buf)) {
#line 399
    tmp___0 = 1;
  } else {
    {
#line 399
    _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     399);
#line 399
    tmp___0 = 1;
    }
  }
  {
#line 400
  __builtin_va_end(arg);
#line 401
  c = buf;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! ((int )*c != 0)) {
#line 401
      goto while_break;
    }
    {
#line 401
    _glp_mpl_write_char(mpl, (int )*c);
#line 401
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  return;
}
}
#line 410 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_flush_output(MPL *mpl ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 411
  if ((unsigned long )mpl->out_fp != (unsigned long )((void *)0)) {
#line 411
    tmp = 1;
  } else {
    {
#line 411
    _glp_lib_xassert("mpl->out_fp != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     411);
#line 411
    tmp = 1;
    }
  }
#line 412
  if (mpl->out_cnt > 0) {
    {
#line 412
    _glp_mpl_write_char(mpl, '\n');
    }
  }
#line 413
  if ((unsigned long )mpl->out_fp != (unsigned long )stdout) {
    {
#line 414
    fflush(mpl->out_fp);
#line 415
    tmp___2 = ferror(mpl->out_fp);
    }
#line 415
    if (tmp___2) {
      {
#line 416
      tmp___0 = __errno_location();
#line 416
      tmp___1 = strerror(*tmp___0);
#line 416
      _glp_mpl_error(mpl, (char *)"write error on %s - %s", mpl->out_file, tmp___1);
      }
    }
  }
#line 419
  return;
}
}
#line 432 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_error(MPL *mpl , char *fmt___0  , ...) 
{ 
  va_list arg ;
  char msg[4096] ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 435
  __builtin_va_start(arg, fmt___0);
#line 436
  vsprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)fmt___0,
           arg);
#line 437
  tmp = strlen((char const   *)(msg));
  }
#line 437
  if ((unsigned long )tmp < sizeof(msg)) {
#line 437
    tmp___0 = 1;
  } else {
    {
#line 437
    _glp_lib_xassert("strlen(msg) < sizeof(msg)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     437);
#line 437
    tmp___0 = 1;
    }
  }
  {
#line 438
  __builtin_va_end(arg);
  }
  {
#line 441
  if (mpl->phase == 2) {
#line 441
    goto case_2;
  }
#line 441
  if (mpl->phase == 1) {
#line 441
    goto case_2;
  }
#line 448
  if (mpl->phase == 3) {
#line 448
    goto case_3;
  }
#line 454
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 443
  if ((unsigned long )mpl->in_file == (unsigned long )((void *)0)) {
#line 443
    tmp___1 = "(unknown)";
  } else {
#line 443
    tmp___1 = (char const   *)mpl->in_file;
  }
  {
#line 443
  _glp_lib_xprintf("%s:%d: %s\n", tmp___1, mpl->line, msg);
#line 446
  _glp_mpl_print_context(mpl);
  }
#line 447
  goto switch_break;
  case_3: /* CIL Label */ 
#line 450
  if ((unsigned long )mpl->stmt == (unsigned long )((void *)0)) {
#line 450
    tmp___2 = 0;
  } else {
#line 450
    tmp___2 = (mpl->stmt)->line;
  }
#line 450
  if ((unsigned long )mpl->mod_file == (unsigned long )((void *)0)) {
#line 450
    tmp___3 = "(unknown)";
  } else {
#line 450
    tmp___3 = (char const   *)mpl->mod_file;
  }
  {
#line 450
  _glp_lib_xprintf("%s:%d: %s\n", tmp___3, tmp___2, msg);
  }
#line 453
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 455
  if ((unsigned long )mpl != (unsigned long )mpl) {
#line 455
    tmp___4 = 1;
  } else {
    {
#line 455
    _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     455);
#line 455
    tmp___4 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 457
  mpl->phase = 4;
#line 458
  longjmp((struct __jmp_buf_tag *)(mpl->jump), 1);
  }
}
}
#line 468 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_warning(MPL *mpl , char *fmt___0  , ...) 
{ 
  va_list arg ;
  char msg[4096] ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 471
  __builtin_va_start(arg, fmt___0);
#line 472
  vsprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)fmt___0,
           arg);
#line 473
  tmp = strlen((char const   *)(msg));
  }
#line 473
  if ((unsigned long )tmp < sizeof(msg)) {
#line 473
    tmp___0 = 1;
  } else {
    {
#line 473
    _glp_lib_xassert("strlen(msg) < sizeof(msg)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     473);
#line 473
    tmp___0 = 1;
    }
  }
  {
#line 474
  __builtin_va_end(arg);
  }
  {
#line 477
  if (mpl->phase == 2) {
#line 477
    goto case_2;
  }
#line 477
  if (mpl->phase == 1) {
#line 477
    goto case_2;
  }
#line 483
  if (mpl->phase == 3) {
#line 483
    goto case_3;
  }
#line 489
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 479
  if ((unsigned long )mpl->in_file == (unsigned long )((void *)0)) {
#line 479
    tmp___1 = "(unknown)";
  } else {
#line 479
    tmp___1 = (char const   *)mpl->in_file;
  }
  {
#line 479
  _glp_lib_xprintf("%s:%d: warning: %s\n", tmp___1, mpl->line, msg);
  }
#line 482
  goto switch_break;
  case_3: /* CIL Label */ 
#line 485
  if ((unsigned long )mpl->stmt == (unsigned long )((void *)0)) {
#line 485
    tmp___2 = 0;
  } else {
#line 485
    tmp___2 = (mpl->stmt)->line;
  }
#line 485
  if ((unsigned long )mpl->mod_file == (unsigned long )((void *)0)) {
#line 485
    tmp___3 = "(unknown)";
  } else {
#line 485
    tmp___3 = (char const   *)mpl->mod_file;
  }
  {
#line 485
  _glp_lib_xprintf("%s:%d: warning: %s\n", tmp___3, tmp___2, msg);
  }
#line 488
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 490
  if ((unsigned long )mpl != (unsigned long )mpl) {
#line 490
    tmp___4 = 1;
  } else {
    {
#line 490
    _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     490);
#line 490
    tmp___4 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 492
  return;
}
}
#line 512 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
MPL *_glp_mpl_initialize(void) 
{ 
  MPL *mpl ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 514
  tmp = _glp_lib_xmalloc((int )sizeof(MPL ));
#line 514
  mpl = (MPL *)tmp;
#line 516
  mpl->line = 0;
#line 517
  mpl->c = 0;
#line 518
  mpl->token = 0;
#line 519
  mpl->imlen = 0;
#line 520
  tmp___0 = _glp_lib_xcalloc(101, (int )sizeof(char ));
#line 520
  mpl->image = (char *)tmp___0;
#line 521
  *(mpl->image + 0) = (char )'\000';
#line 522
  mpl->value = 0.0;
#line 523
  mpl->b_token = 0;
#line 524
  mpl->b_imlen = 0;
#line 525
  tmp___1 = _glp_lib_xcalloc(101, (int )sizeof(char ));
#line 525
  mpl->b_image = (char *)tmp___1;
#line 526
  *(mpl->b_image + 0) = (char )'\000';
#line 527
  mpl->b_value = 0.0;
#line 528
  mpl->f_dots = 0;
#line 529
  mpl->f_scan = 0;
#line 530
  mpl->f_token = 0;
#line 531
  mpl->f_imlen = 0;
#line 532
  tmp___2 = _glp_lib_xcalloc(101, (int )sizeof(char ));
#line 532
  mpl->f_image = (char *)tmp___2;
#line 533
  *(mpl->f_image + 0) = (char )'\000';
#line 534
  mpl->f_value = 0.0;
#line 535
  tmp___3 = _glp_lib_xcalloc(60, (int )sizeof(char ));
#line 535
  mpl->context = (char *)tmp___3;
#line 536
  memset((void *)mpl->context, ' ', (size_t )60);
#line 537
  mpl->c_ptr = 0;
#line 538
  mpl->flag_d = 0;
#line 540
  mpl->pool = _glp_dmp_create_pool();
#line 541
  mpl->tree = _glp_avl_create_tree(& _glp_avl_strcmp, (void *)0);
#line 542
  mpl->model = (STATEMENT *)((void *)0);
#line 543
  mpl->flag_x = 0;
#line 544
  mpl->as_within = 0;
#line 545
  mpl->as_in = 0;
#line 546
  mpl->as_binary = 0;
#line 547
  mpl->flag_s = 0;
#line 549
  mpl->strings = _glp_dmp_create_pool();
#line 550
  mpl->symbols = _glp_dmp_create_pool();
#line 551
  mpl->tuples = _glp_dmp_create_pool();
#line 552
  mpl->arrays = _glp_dmp_create_pool();
#line 553
  mpl->members = _glp_dmp_create_pool();
#line 554
  mpl->elemvars = _glp_dmp_create_pool();
#line 555
  mpl->formulae = _glp_dmp_create_pool();
#line 556
  mpl->elemcons = _glp_dmp_create_pool();
#line 557
  mpl->a_list = (ARRAY *)((void *)0);
#line 558
  tmp___4 = _glp_lib_xcalloc(256, (int )sizeof(char ));
#line 558
  mpl->sym_buf = (char *)tmp___4;
#line 559
  *(mpl->sym_buf + 0) = (char )'\000';
#line 560
  tmp___5 = _glp_lib_xcalloc(256, (int )sizeof(char ));
#line 560
  mpl->tup_buf = (char *)tmp___5;
#line 561
  *(mpl->tup_buf + 0) = (char )'\000';
#line 563
  mpl->rand = _glp_rng_create_rand();
#line 564
  mpl->flag_p = 0;
#line 565
  mpl->stmt = (STATEMENT *)((void *)0);
#line 567
  mpl->dca = (TABDCA *)((void *)0);
#line 569
  mpl->m = 0;
#line 570
  mpl->n = 0;
#line 571
  mpl->row = (ELEMCON **)((void *)0);
#line 572
  mpl->col = (ELEMVAR **)((void *)0);
#line 574
  mpl->in_fp = (FILE *)((void *)0);
#line 575
  mpl->in_file = (char *)((void *)0);
#line 576
  mpl->out_fp = (FILE *)((void *)0);
#line 577
  mpl->out_file = (char *)((void *)0);
#line 578
  mpl->out_buf = (char *)((void *)0);
#line 579
  mpl->out_cnt = 0;
#line 581
  mpl->prt_fp = (FILE *)((void *)0);
#line 582
  mpl->prt_file = (char *)((void *)0);
#line 585
  tmp___7 = _setjmp((struct __jmp_buf_tag *)(mpl->jump));
  }
#line 585
  if (tmp___7) {
#line 585
    if ((unsigned long )mpl != (unsigned long )mpl) {
#line 585
      tmp___6 = 1;
    } else {
      {
#line 585
      _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       585);
#line 585
      tmp___6 = 1;
      }
    }
  }
  {
#line 586
  mpl->phase = 0;
#line 587
  mpl->mod_file = (char *)((void *)0);
#line 588
  tmp___8 = _glp_lib_xcalloc(256, (int )sizeof(char ));
#line 588
  mpl->mpl_buf = (char *)tmp___8;
#line 589
  *(mpl->mpl_buf + 0) = (char )'\000';
  }
#line 590
  return (mpl);
}
}
#line 630 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_read_model(MPL *mpl , char *file , int skip_data ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 631
  if (mpl->phase != 0) {
    {
#line 632
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 632);
#line 632
    (*tmp)("mpl_read_model: invalid call sequence\n");
    }
  }
#line 633
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 634
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               634);
#line 634
    (*tmp___0)("mpl_read_model: no input filename specified\n");
    }
  }
  {
#line 636
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(mpl->jump));
  }
#line 636
  if (tmp___1) {
#line 636
    goto done;
  }
  {
#line 638
  mpl->phase = 1;
#line 639
  _glp_lib_xprintf("Reading model section from %s...\n", file);
#line 640
  _glp_mpl_open_input(mpl, file);
#line 641
  _glp_mpl_model_section(mpl);
  }
#line 642
  if ((unsigned long )mpl->model == (unsigned long )((void *)0)) {
    {
#line 643
    _glp_mpl_error(mpl, (char *)"empty model section not allowed");
    }
  }
  {
#line 646
  tmp___2 = strlen((char const   *)file);
#line 646
  tmp___3 = _glp_lib_xcalloc((int )(tmp___2 + 1U), (int )sizeof(char ));
#line 646
  mpl->mod_file = (char *)tmp___3;
#line 647
  strcpy((char */* __restrict  */)mpl->mod_file, (char const   */* __restrict  */)mpl->in_file);
#line 649
  _glp_mpl_alloc_content(mpl);
#line 651
  tmp___4 = _glp_mpl_is_keyword(mpl, (char *)"data");
  }
#line 651
  if (tmp___4) {
#line 652
    if (skip_data) {
      {
#line 653
      _glp_mpl_warning(mpl, (char *)"data section ignored");
      }
#line 654
      goto skip;
    }
    {
#line 656
    mpl->flag_d = 1;
#line 657
    _glp_mpl_get_token(mpl);
    }
#line 658
    if (mpl->token != 241) {
      {
#line 659
      _glp_mpl_error(mpl, (char *)"semicolon missing where expected");
      }
    }
    {
#line 660
    _glp_mpl_get_token(mpl);
#line 662
    mpl->phase = 2;
#line 663
    _glp_lib_xprintf("Reading data section from %s...\n", file);
#line 664
    _glp_mpl_data_section(mpl);
    }
  }
  {
#line 667
  _glp_mpl_end_statement(mpl);
  }
  skip: 
#line 668
  if (mpl->line == 1) {
#line 668
    tmp___5 = "";
  } else {
#line 668
    tmp___5 = "s";
  }
  {
#line 668
  _glp_lib_xprintf("%d line%s were read\n", mpl->line, tmp___5);
#line 670
  _glp_mpl_close_input(mpl);
  }
  done: 
#line 672
  return (mpl->phase);
}
}
#line 701 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_read_data(MPL *mpl , char *file ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 705
  if (! (mpl->phase == 1)) {
#line 705
    if (! (mpl->phase == 2)) {
      {
#line 707
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 707);
#line 707
      (*tmp)("mpl_read_data: invalid call sequence\n");
      }
    }
  }
#line 708
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 709
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               709);
#line 709
    (*tmp___0)("mpl_read_data: no input filename specified\n");
    }
  }
  {
#line 711
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(mpl->jump));
  }
#line 711
  if (tmp___1) {
#line 711
    goto done;
  }
  {
#line 713
  mpl->phase = 2;
#line 714
  _glp_lib_xprintf("Reading data section from %s...\n", file);
#line 715
  mpl->flag_d = 1;
#line 716
  _glp_mpl_open_input(mpl, file);
#line 718
  tmp___2 = _glp_mpl_is_literal(mpl, (char *)"data");
  }
#line 718
  if (tmp___2) {
    {
#line 719
    _glp_mpl_get_token(mpl);
    }
#line 720
    if (mpl->token != 241) {
      {
#line 721
      _glp_mpl_error(mpl, (char *)"semicolon missing where expected");
      }
    }
    {
#line 722
    _glp_mpl_get_token(mpl);
    }
  }
  {
#line 724
  _glp_mpl_data_section(mpl);
#line 726
  _glp_mpl_end_statement(mpl);
  }
#line 727
  if (mpl->line == 1) {
#line 727
    tmp___3 = "";
  } else {
#line 727
    tmp___3 = "s";
  }
  {
#line 727
  _glp_lib_xprintf("%d line%s were read\n", mpl->line, tmp___3);
#line 729
  _glp_mpl_close_input(mpl);
  }
  done: 
#line 731
  return (mpl->phase);
}
}
#line 769 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_generate(MPL *mpl , char *file ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 770
  if (! (mpl->phase == 1)) {
#line 770
    if (! (mpl->phase == 2)) {
      {
#line 771
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 771);
#line 771
      (*tmp)("mpl_generate: invalid call sequence\n");
      }
    }
  }
  {
#line 773
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(mpl->jump));
  }
#line 773
  if (tmp___0) {
#line 773
    goto done;
  }
  {
#line 775
  mpl->phase = 3;
#line 776
  _glp_mpl_open_output(mpl, file);
#line 777
  _glp_mpl_generate_model(mpl);
#line 778
  _glp_mpl_flush_output(mpl);
#line 780
  _glp_mpl_build_problem(mpl);
#line 782
  _glp_lib_xprintf("Model has been successfully generated\n");
  }
  done: 
#line 784
  return (mpl->phase);
}
}
#line 807 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
char *_glp_mpl_get_prob_name(MPL *mpl ) 
{ 
  char *name ;
  char *file ;
  int k ;
  xerror_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 808
  name = mpl->mpl_buf;
#line 809
  file = mpl->mod_file;
#line 811
  if (mpl->phase != 3) {
    {
#line 812
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 812);
#line 812
    (*tmp)("mpl_get_prob_name: invalid call sequence\n");
    }
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 814
    tmp___5 = strchr((char const   *)file, '/');
    }
#line 814
    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
      {
#line 815
      tmp___0 = strchr((char const   *)file, '/');
#line 815
      file = tmp___0 + 1;
      }
    } else {
      {
#line 816
      tmp___4 = strchr((char const   *)file, '\\');
      }
#line 816
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
        {
#line 817
        tmp___1 = strchr((char const   *)file, '\\');
#line 817
        file = tmp___1 + 1;
        }
      } else {
        {
#line 818
        tmp___3 = strchr((char const   *)file, ':');
        }
#line 818
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
          {
#line 819
          tmp___2 = strchr((char const   *)file, ':');
#line 819
          file = tmp___2 + 1;
          }
        } else {
#line 821
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 823
  k = 0;
  {
#line 823
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 824
    if (k == 255) {
#line 824
      goto while_break___0;
    }
    {
#line 825
    tmp___6 = __ctype_b_loc();
    }
#line 825
    if (! ((int const   )*(*tmp___6 + (int )((unsigned char )*file)) & 8)) {
#line 825
      if (! ((int )*file == 95)) {
#line 825
        goto while_break___0;
      }
    }
#line 826
    tmp___7 = file;
#line 826
    file ++;
#line 826
    *(name + k) = *tmp___7;
#line 823
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 828
  if (k == 0) {
    {
#line 829
    strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)"Unknown");
    }
  } else {
#line 831
    *(name + k) = (char )'\000';
  }
  {
#line 832
  tmp___8 = strlen((char const   *)name);
  }
#line 832
  if (tmp___8 <= 255U) {
#line 832
    tmp___9 = 1;
  } else {
    {
#line 832
    _glp_lib_xassert("strlen(name) <= 255", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     832);
#line 832
    tmp___9 = 1;
    }
  }
#line 833
  return (name);
}
}
#line 849 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_get_num_rows(MPL *mpl ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 850
  if (mpl->phase != 3) {
    {
#line 851
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 851);
#line 851
    (*tmp)("mpl_get_num_rows: invalid call sequence\n");
    }
  }
#line 852
  return (mpl->m);
}
}
#line 868 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_get_num_cols(MPL *mpl ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 869
  if (mpl->phase != 3) {
    {
#line 870
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 870);
#line 870
    (*tmp)("mpl_get_num_cols: invalid call sequence\n");
    }
  }
#line 871
  return (mpl->n);
}
}
#line 887 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
char *_glp_mpl_get_row_name(MPL *mpl , int i ) 
{ 
  char *name ;
  char *t ;
  int len ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 888
  name = mpl->mpl_buf;
#line 890
  if (mpl->phase != 3) {
    {
#line 891
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 891);
#line 891
    (*tmp)("mpl_get_row_name: invalid call sequence\n");
    }
  }
#line 892
  if (1 <= i) {
#line 892
    if (! (i <= mpl->m)) {
      {
#line 893
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 893);
#line 893
      (*tmp___0)("mpl_get_row_name: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 893
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               893);
#line 893
    (*tmp___0)("mpl_get_row_name: i = %d; row number out of range\n", i);
    }
  }
  {
#line 895
  strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)((*(mpl->row + i))->con)->name);
#line 896
  tmp___1 = strlen((char const   *)name);
#line 896
  len = (int )tmp___1;
  }
#line 897
  if (len <= 255) {
#line 897
    tmp___2 = 1;
  } else {
    {
#line 897
    _glp_lib_xassert("len <= 255", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     897);
#line 897
    tmp___2 = 1;
    }
  }
  {
#line 898
  t = _glp_mpl_format_tuple(mpl, '[', ((*(mpl->row + i))->memb)->tuple);
  }
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! *t) {
#line 899
      goto while_break;
    }
#line 900
    if (len == 255) {
#line 900
      goto while_break;
    }
#line 901
    tmp___3 = len;
#line 901
    len ++;
#line 901
    tmp___4 = t;
#line 901
    t ++;
#line 901
    *(name + tmp___3) = *tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  *(name + len) = (char )'\000';
#line 904
  if (len == 255) {
    {
#line 904
    strcpy((char */* __restrict  */)(name + 252), (char const   */* __restrict  */)"...");
    }
  }
  {
#line 905
  tmp___5 = strlen((char const   *)name);
  }
#line 905
  if (tmp___5 <= 255U) {
#line 905
    tmp___6 = 1;
  } else {
    {
#line 905
    _glp_lib_xassert("strlen(name) <= 255", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     905);
#line 905
    tmp___6 = 1;
    }
  }
#line 906
  return (name);
}
}
#line 926 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_get_row_kind(MPL *mpl , int i ) 
{ 
  int kind ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 928
  if (mpl->phase != 3) {
    {
#line 929
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 929);
#line 929
    (*tmp)("mpl_get_row_kind: invalid call sequence\n");
    }
  }
#line 930
  if (1 <= i) {
#line 930
    if (! (i <= mpl->m)) {
      {
#line 931
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 931);
#line 931
      (*tmp___0)("mpl_get_row_kind: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 931
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               931);
#line 931
    (*tmp___0)("mpl_get_row_kind: i = %d; row number out of range\n", i);
    }
  }
  {
#line 934
  if (((*(mpl->row + i))->con)->type == 103) {
#line 934
    goto case_103;
  }
#line 936
  if (((*(mpl->row + i))->con)->type == 116) {
#line 936
    goto case_116;
  }
#line 938
  if (((*(mpl->row + i))->con)->type == 115) {
#line 938
    goto case_115;
  }
#line 940
  goto switch_default;
  case_103: /* CIL Label */ 
#line 935
  kind = 411;
#line 935
  goto switch_break;
  case_116: /* CIL Label */ 
#line 937
  kind = 412;
#line 937
  goto switch_break;
  case_115: /* CIL Label */ 
#line 939
  kind = 413;
#line 939
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 941
  if ((unsigned long )mpl != (unsigned long )mpl) {
#line 941
    tmp___1 = 1;
  } else {
    {
#line 941
    _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     941);
#line 941
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 943
  return (kind);
}
}
#line 985 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_get_row_bnds(MPL *mpl , int i , double *_lb , double *_ub ) 
{ 
  ELEMCON *con ;
  int type ;
  double lb ;
  double ub ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 989
  if (mpl->phase != 3) {
    {
#line 990
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 990);
#line 990
    (*tmp)("mpl_get_row_bnds: invalid call sequence\n");
    }
  }
#line 991
  if (1 <= i) {
#line 991
    if (! (i <= mpl->m)) {
      {
#line 992
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 992);
#line 992
      (*tmp___0)("mpl_get_row_bnds: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 992
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               992);
#line 992
    (*tmp___0)("mpl_get_row_bnds: i = %d; row number out of range\n", i);
    }
  }
#line 994
  con = *(mpl->row + i);
#line 1007
  if ((unsigned long )(con->con)->lbnd == (unsigned long )((void *)0)) {
#line 1007
    lb = - 1.7976931348623157e+308;
  } else {
#line 1007
    lb = con->lbnd;
  }
#line 1008
  if ((unsigned long )(con->con)->ubnd == (unsigned long )((void *)0)) {
#line 1008
    ub = 1.7976931348623157e+308;
  } else {
#line 1008
    ub = con->ubnd;
  }
#line 1009
  if (lb == - 1.7976931348623157e+308) {
#line 1009
    if (ub == 1.7976931348623157e+308) {
#line 1010
      type = 401;
#line 1010
      ub = 0.0;
#line 1010
      lb = ub;
    } else {
#line 1009
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1011
  if (ub == 1.7976931348623157e+308) {
#line 1012
    type = 402;
#line 1012
    ub = 0.0;
  } else
#line 1013
  if (lb == - 1.7976931348623157e+308) {
#line 1014
    type = 403;
#line 1014
    lb = 0.0;
  } else
#line 1015
  if ((unsigned long )(con->con)->lbnd != (unsigned long )(con->con)->ubnd) {
#line 1016
    type = 404;
  } else {
#line 1018
    type = 405;
  }
#line 1020
  if ((unsigned long )_lb != (unsigned long )((void *)0)) {
#line 1020
    *_lb = lb;
  }
#line 1021
  if ((unsigned long )_ub != (unsigned long )((void *)0)) {
#line 1021
    *_ub = ub;
  }
#line 1022
  return (type);
}
}
#line 1054 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_get_mat_row(MPL *mpl , int i , int *ndx , double *val ) 
{ 
  FORMULA *term ;
  int len ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1056
  len = 0;
#line 1057
  if (mpl->phase != 3) {
    {
#line 1058
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1058);
#line 1058
    (*tmp)("mpl_get_mat_row: invalid call sequence\n");
    }
  }
#line 1059
  if (1 <= i) {
#line 1059
    if (! (i <= mpl->m)) {
      {
#line 1060
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 1060);
#line 1060
      (*tmp___0)("mpl_get_mat_row: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 1060
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               1060);
#line 1060
    (*tmp___0)("mpl_get_mat_row: i = %d; row number out of range\n", i);
    }
  }
#line 1062
  term = (*(mpl->row + i))->form;
  {
#line 1062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1062
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 1062
      goto while_break;
    }
#line 1063
    if ((unsigned long )term->var != (unsigned long )((void *)0)) {
#line 1063
      tmp___1 = 1;
    } else {
      {
#line 1063
      _glp_lib_xassert("term->var != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       1063);
#line 1063
      tmp___1 = 1;
      }
    }
#line 1064
    len ++;
#line 1065
    if (len <= mpl->n) {
#line 1065
      tmp___2 = 1;
    } else {
      {
#line 1065
      _glp_lib_xassert("len <= mpl->n", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       1065);
#line 1065
      tmp___2 = 1;
      }
    }
#line 1066
    if ((unsigned long )ndx != (unsigned long )((void *)0)) {
#line 1066
      *(ndx + len) = (term->var)->j;
    }
#line 1067
    if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 1067
      *(val + len) = term->coef;
    }
#line 1062
    term = term->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  return (len);
}
}
#line 1088 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
double _glp_mpl_get_row_c0(MPL *mpl , int i ) 
{ 
  ELEMCON *con ;
  double c0 ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1091
  if (mpl->phase != 3) {
    {
#line 1092
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1092);
#line 1092
    (*tmp)("mpl_get_row_c0: invalid call sequence\n");
    }
  }
#line 1093
  if (1 <= i) {
#line 1093
    if (! (i <= mpl->m)) {
      {
#line 1094
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 1094);
#line 1094
      (*tmp___0)("mpl_get_row_c0: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 1094
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               1094);
#line 1094
    (*tmp___0)("mpl_get_row_c0: i = %d; row number out of range\n", i);
    }
  }
#line 1096
  con = *(mpl->row + i);
#line 1097
  if ((unsigned long )(con->con)->lbnd == (unsigned long )((void *)0)) {
#line 1097
    if ((unsigned long )(con->con)->ubnd == (unsigned long )((void *)0)) {
#line 1098
      c0 = - con->lbnd;
    } else {
#line 1100
      c0 = 0.0;
    }
  } else {
#line 1100
    c0 = 0.0;
  }
#line 1101
  return (c0);
}
}
#line 1117 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
char *_glp_mpl_get_col_name(MPL *mpl , int j ) 
{ 
  char *name ;
  char *t ;
  int len ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1118
  name = mpl->mpl_buf;
#line 1120
  if (mpl->phase != 3) {
    {
#line 1121
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1121);
#line 1121
    (*tmp)("mpl_get_col_name: invalid call sequence\n");
    }
  }
#line 1122
  if (1 <= j) {
#line 1122
    if (! (j <= mpl->n)) {
      {
#line 1123
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 1123);
#line 1123
      (*tmp___0)("mpl_get_col_name: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 1123
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               1123);
#line 1123
    (*tmp___0)("mpl_get_col_name: j = %d; column number out of range\n", j);
    }
  }
  {
#line 1125
  strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)((*(mpl->col + j))->var)->name);
#line 1126
  tmp___1 = strlen((char const   *)name);
#line 1126
  len = (int )tmp___1;
  }
#line 1127
  if (len <= 255) {
#line 1127
    tmp___2 = 1;
  } else {
    {
#line 1127
    _glp_lib_xassert("len <= 255", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     1127);
#line 1127
    tmp___2 = 1;
    }
  }
  {
#line 1128
  t = _glp_mpl_format_tuple(mpl, '[', ((*(mpl->col + j))->memb)->tuple);
  }
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! *t) {
#line 1129
      goto while_break;
    }
#line 1130
    if (len == 255) {
#line 1130
      goto while_break;
    }
#line 1131
    tmp___3 = len;
#line 1131
    len ++;
#line 1131
    tmp___4 = t;
#line 1131
    t ++;
#line 1131
    *(name + tmp___3) = *tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 1133
  *(name + len) = (char )'\000';
#line 1134
  if (len == 255) {
    {
#line 1134
    strcpy((char */* __restrict  */)(name + 252), (char const   */* __restrict  */)"...");
    }
  }
  {
#line 1135
  tmp___5 = strlen((char const   *)name);
  }
#line 1135
  if (tmp___5 <= 255U) {
#line 1135
    tmp___6 = 1;
  } else {
    {
#line 1135
    _glp_lib_xassert("strlen(name) <= 255", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     1135);
#line 1135
    tmp___6 = 1;
    }
  }
#line 1136
  return (name);
}
}
#line 1162 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_get_col_kind(MPL *mpl , int j ) 
{ 
  int kind ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1164
  if (mpl->phase != 3) {
    {
#line 1165
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1165);
#line 1165
    (*tmp)("mpl_get_col_kind: invalid call sequence\n");
    }
  }
#line 1166
  if (1 <= j) {
#line 1166
    if (! (j <= mpl->n)) {
      {
#line 1167
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 1167);
#line 1167
      (*tmp___0)("mpl_get_col_kind: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 1167
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               1167);
#line 1167
    (*tmp___0)("mpl_get_col_kind: j = %d; column number out of range\n", j);
    }
  }
  {
#line 1170
  if (((*(mpl->col + j))->var)->type == 118) {
#line 1170
    goto case_118;
  }
#line 1172
  if (((*(mpl->col + j))->var)->type == 113) {
#line 1172
    goto case_113;
  }
#line 1174
  if (((*(mpl->col + j))->var)->type == 101) {
#line 1174
    goto case_101;
  }
#line 1176
  goto switch_default;
  case_118: /* CIL Label */ 
#line 1171
  kind = 421;
#line 1171
  goto switch_break;
  case_113: /* CIL Label */ 
#line 1173
  kind = 422;
#line 1173
  goto switch_break;
  case_101: /* CIL Label */ 
#line 1175
  kind = 423;
#line 1175
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1177
  if ((unsigned long )mpl != (unsigned long )mpl) {
#line 1177
    tmp___1 = 1;
  } else {
    {
#line 1177
    _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     1177);
#line 1177
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1179
  return (kind);
}
}
#line 1221 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_get_col_bnds(MPL *mpl , int j , double *_lb , double *_ub ) 
{ 
  ELEMVAR *var ;
  int type ;
  double lb ;
  double ub ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1225
  if (mpl->phase != 3) {
    {
#line 1226
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1226);
#line 1226
    (*tmp)("mpl_get_col_bnds: invalid call sequence\n");
    }
  }
#line 1227
  if (1 <= j) {
#line 1227
    if (! (j <= mpl->n)) {
      {
#line 1228
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 1228);
#line 1228
      (*tmp___0)("mpl_get_col_bnds: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 1228
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               1228);
#line 1228
    (*tmp___0)("mpl_get_col_bnds: j = %d; column number out of range\n", j);
    }
  }
#line 1230
  var = *(mpl->col + j);
#line 1243
  if ((unsigned long )(var->var)->lbnd == (unsigned long )((void *)0)) {
#line 1243
    lb = - 1.7976931348623157e+308;
  } else {
#line 1243
    lb = var->lbnd;
  }
#line 1244
  if ((unsigned long )(var->var)->ubnd == (unsigned long )((void *)0)) {
#line 1244
    ub = 1.7976931348623157e+308;
  } else {
#line 1244
    ub = var->ubnd;
  }
#line 1245
  if (lb == - 1.7976931348623157e+308) {
#line 1245
    if (ub == 1.7976931348623157e+308) {
#line 1246
      type = 401;
#line 1246
      ub = 0.0;
#line 1246
      lb = ub;
    } else {
#line 1245
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1247
  if (ub == 1.7976931348623157e+308) {
#line 1248
    type = 402;
#line 1248
    ub = 0.0;
  } else
#line 1249
  if (lb == - 1.7976931348623157e+308) {
#line 1250
    type = 403;
#line 1250
    lb = 0.0;
  } else
#line 1251
  if ((unsigned long )(var->var)->lbnd != (unsigned long )(var->var)->ubnd) {
#line 1252
    type = 404;
  } else {
#line 1254
    type = 405;
  }
#line 1256
  if ((unsigned long )_lb != (unsigned long )((void *)0)) {
#line 1256
    *_lb = lb;
  }
#line 1257
  if ((unsigned long )_ub != (unsigned long )((void *)0)) {
#line 1257
    *_ub = ub;
  }
#line 1258
  return (type);
}
}
#line 1274 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_has_solve_stmt(MPL *mpl ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 1275
  if (mpl->phase != 3) {
    {
#line 1276
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1276);
#line 1276
    (*tmp)("mpl_has_solve_stmt: invalid call sequence\n");
    }
  }
#line 1277
  return (mpl->flag_s);
}
}
#line 1294 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_put_col_value(MPL *mpl , int j , double val ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1295
  if (mpl->phase != 3) {
    {
#line 1296
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1296);
#line 1296
    (*tmp)("mpl_put_col_value: invalid call sequence\n");
    }
  }
#line 1297
  if (1 <= j) {
#line 1297
    if (! (j <= mpl->n)) {
      {
#line 1298
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                                 1298);
#line 1298
      (*tmp___0)("mpl_put_col_value: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 1298
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                               1298);
#line 1298
    (*tmp___0)("mpl_put_col_value: j = %d; column number out of range\n", j);
    }
  }
#line 1300
  (*(mpl->col + j))->value = val;
#line 1301
  return;
}
}
#line 1330 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
int _glp_mpl_postsolve(MPL *mpl ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1331
  if (mpl->phase == 3) {
#line 1331
    if (! (! mpl->flag_p)) {
      {
#line 1332
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1332);
#line 1332
      (*tmp)("mpl_postsolve: invalid call sequence\n");
      }
    }
  } else {
    {
#line 1332
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c", 1332);
#line 1332
    (*tmp)("mpl_postsolve: invalid call sequence\n");
    }
  }
  {
#line 1334
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(mpl->jump));
  }
#line 1334
  if (tmp___0) {
#line 1334
    goto done;
  }
  {
#line 1336
  _glp_mpl_postsolve_model(mpl);
#line 1337
  _glp_mpl_flush_output(mpl);
#line 1339
  _glp_lib_xprintf("Model has been successfully processed\n");
  }
  done: 
#line 1341
  return (mpl->phase);
}
}
#line 1357 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c"
void _glp_mpl_terminate(MPL *mpl ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ARRAY *a ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1358
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(mpl->jump));
  }
#line 1358
  if (tmp___0) {
#line 1358
    if ((unsigned long )mpl != (unsigned long )mpl) {
#line 1358
      tmp = 1;
    } else {
      {
#line 1358
      _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                       1358);
#line 1358
      tmp = 1;
      }
    }
  }
  {
#line 1363
  if (mpl->phase == 3) {
#line 1363
    goto case_3;
  }
#line 1363
  if (mpl->phase == 2) {
#line 1363
    goto case_3;
  }
#line 1363
  if (mpl->phase == 1) {
#line 1363
    goto case_3;
  }
#line 1363
  if (mpl->phase == 0) {
#line 1363
    goto case_3;
  }
#line 1371
  if (mpl->phase == 4) {
#line 1371
    goto case_4;
  }
#line 1382
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1365
  _glp_mpl_clean_model(mpl);
  }
#line 1366
  if ((unsigned long )mpl->a_list == (unsigned long )((void *)0)) {
#line 1366
    tmp___1 = 1;
  } else {
    {
#line 1366
    _glp_lib_xassert("mpl->a_list == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     1366);
#line 1366
    tmp___1 = 1;
    }
  }
#line 1368
  if ((unsigned long )mpl->dca == (unsigned long )((void *)0)) {
#line 1368
    tmp___2 = 1;
  } else {
    {
#line 1368
    _glp_lib_xassert("mpl->dca == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     1368);
#line 1368
    tmp___2 = 1;
    }
  }
#line 1370
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1375
  a = mpl->a_list;
  {
#line 1375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1375
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 1375
      goto while_break;
    }
#line 1376
    if ((unsigned long )a->tree != (unsigned long )((void *)0)) {
      {
#line 1376
      _glp_avl_delete_tree(a->tree);
      }
    }
#line 1375
    a = a->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1379
  _glp_mpl_free_dca(mpl);
  }
#line 1381
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1383
  if ((unsigned long )mpl != (unsigned long )mpl) {
#line 1383
    tmp___3 = 1;
  } else {
    {
#line 1383
    _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl04.c",
                     1383);
#line 1383
    tmp___3 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1386
  _glp_lib_xfree((void *)mpl->image);
#line 1387
  _glp_lib_xfree((void *)mpl->b_image);
#line 1388
  _glp_lib_xfree((void *)mpl->f_image);
#line 1389
  _glp_lib_xfree((void *)mpl->context);
#line 1390
  _glp_dmp_delete_pool(mpl->pool);
#line 1391
  _glp_avl_delete_tree(mpl->tree);
#line 1392
  _glp_dmp_delete_pool(mpl->strings);
#line 1393
  _glp_dmp_delete_pool(mpl->symbols);
#line 1394
  _glp_dmp_delete_pool(mpl->tuples);
#line 1395
  _glp_dmp_delete_pool(mpl->arrays);
#line 1396
  _glp_dmp_delete_pool(mpl->members);
#line 1397
  _glp_dmp_delete_pool(mpl->elemvars);
#line 1398
  _glp_dmp_delete_pool(mpl->formulae);
#line 1399
  _glp_dmp_delete_pool(mpl->elemcons);
#line 1400
  _glp_lib_xfree((void *)mpl->sym_buf);
#line 1401
  _glp_lib_xfree((void *)mpl->tup_buf);
#line 1402
  _glp_rng_delete_rand(mpl->rand);
  }
#line 1403
  if ((unsigned long )mpl->row != (unsigned long )((void *)0)) {
    {
#line 1403
    _glp_lib_xfree((void *)mpl->row);
    }
  }
#line 1404
  if ((unsigned long )mpl->col != (unsigned long )((void *)0)) {
    {
#line 1404
    _glp_lib_xfree((void *)mpl->col);
    }
  }
#line 1405
  if ((unsigned long )mpl->in_fp != (unsigned long )((void *)0)) {
    {
#line 1405
    fclose(mpl->in_fp);
    }
  }
#line 1406
  if ((unsigned long )mpl->out_fp != (unsigned long )((void *)0)) {
#line 1406
    if ((unsigned long )mpl->out_fp != (unsigned long )stdout) {
      {
#line 1407
      fclose(mpl->out_fp);
      }
    }
  }
#line 1408
  if ((unsigned long )mpl->out_file != (unsigned long )((void *)0)) {
    {
#line 1408
    _glp_lib_xfree((void *)mpl->out_file);
    }
  }
#line 1409
  if ((unsigned long )mpl->out_buf != (unsigned long )((void *)0)) {
    {
#line 1409
    _glp_lib_xfree((void *)mpl->out_buf);
    }
  }
#line 1411
  if ((unsigned long )mpl->prt_fp != (unsigned long )((void *)0)) {
    {
#line 1411
    fclose(mpl->prt_fp);
    }
  }
#line 1412
  if ((unsigned long )mpl->prt_file != (unsigned long )((void *)0)) {
    {
#line 1412
    _glp_lib_xfree((void *)mpl->prt_file);
    }
  }
#line 1414
  if ((unsigned long )mpl->mod_file != (unsigned long )((void *)0)) {
    {
#line 1414
    _glp_lib_xfree((void *)mpl->mod_file);
    }
  }
  {
#line 1415
  _glp_lib_xfree((void *)mpl->mpl_buf);
#line 1416
  _glp_lib_xfree((void *)mpl);
  }
#line 1417
  return;
}
}
#line 59 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 61
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 113
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 188
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 89 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
AVLNODE *_glp_avl_insert_node(AVL *tree , void const   *key ) ;
#line 97
void _glp_avl_set_node_link(AVLNODE *node , void *link ) ;
#line 101
AVLNODE *_glp_avl_find_node(AVL *tree , void const   *key ) ;
#line 109
void *_glp_avl_get_node_link(AVLNODE *node ) ;
#line 771 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
double _glp_mpl_fp_add(MPL *mpl , double x , double y ) ;
#line 775
double _glp_mpl_fp_sub(MPL *mpl , double x , double y ) ;
#line 779
double _glp_mpl_fp_less(MPL *mpl , double x , double y ) ;
#line 783
double _glp_mpl_fp_mul(MPL *mpl , double x , double y ) ;
#line 787
double _glp_mpl_fp_div(MPL *mpl , double x , double y ) ;
#line 791
double _glp_mpl_fp_idiv(MPL *mpl , double x , double y ) ;
#line 795
double _glp_mpl_fp_mod(MPL *mpl , double x , double y ) ;
#line 799
double _glp_mpl_fp_power(MPL *mpl , double x , double y ) ;
#line 803
double _glp_mpl_fp_exp(MPL *mpl , double x ) ;
#line 807
double _glp_mpl_fp_log(MPL *mpl , double x ) ;
#line 811
double _glp_mpl_fp_log10(MPL *mpl , double x ) ;
#line 815
double _glp_mpl_fp_sqrt(MPL *mpl , double x ) ;
#line 819
double _glp_mpl_fp_sin(MPL *mpl , double x ) ;
#line 823
double _glp_mpl_fp_cos(MPL *mpl , double x ) ;
#line 827
double _glp_mpl_fp_atan(MPL *mpl , double x ) ;
#line 831
double _glp_mpl_fp_atan2(MPL *mpl , double y , double x ) ;
#line 835
double _glp_mpl_fp_round(MPL *mpl , double x , double n ) ;
#line 839
double _glp_mpl_fp_trunc(MPL *mpl , double x , double n ) ;
#line 847
double _glp_mpl_fp_irand224(MPL *mpl ) ;
#line 851
double _glp_mpl_fp_uniform01(MPL *mpl ) ;
#line 855
double _glp_mpl_uniform(MPL *mpl , double a , double b ) ;
#line 859
double _glp_mpl_fp_normal01(MPL *mpl ) ;
#line 863
double _glp_mpl_fp_normal(MPL *mpl , double mu , double sigma ) ;
#line 887
STRING *_glp_mpl_create_string(MPL *mpl , char *buf ) ;
#line 894
STRING *_glp_mpl_copy_string(MPL *mpl , STRING *str ) ;
#line 901
int _glp_mpl_compare_strings(MPL *mpl , STRING *str1 , STRING *str2 ) ;
#line 909
char *_glp_mpl_fetch_string(MPL *mpl , STRING *str , char *buf ) ;
#line 917
void _glp_mpl_delete_string(MPL *mpl , STRING *str ) ;
#line 936
SYMBOL *_glp_mpl_create_symbol_num(MPL *mpl , double num ) ;
#line 940
SYMBOL *_glp_mpl_create_symbol_str(MPL *mpl , STRING *str ) ;
#line 947
SYMBOL *_glp_mpl_copy_symbol(MPL *mpl , SYMBOL *sym ) ;
#line 954
int _glp_mpl_compare_symbols(MPL *mpl , SYMBOL *sym1 , SYMBOL *sym2 ) ;
#line 962
void _glp_mpl_delete_symbol(MPL *mpl , SYMBOL *sym ) ;
#line 969
char *_glp_mpl_format_symbol(MPL *mpl , SYMBOL *sym ) ;
#line 976
SYMBOL *_glp_mpl_concat_symbols(MPL *mpl , SYMBOL *sym1 , SYMBOL *sym2 ) ;
#line 997
TUPLE *_glp_mpl_create_tuple(MPL *mpl ) ;
#line 1001
TUPLE *_glp_mpl_expand_tuple(MPL *mpl , TUPLE *tuple , SYMBOL *sym ) ;
#line 1009
int _glp_mpl_tuple_dimen(MPL *mpl , TUPLE *tuple ) ;
#line 1016
TUPLE *_glp_mpl_copy_tuple(MPL *mpl , TUPLE *tuple ) ;
#line 1023
int _glp_mpl_compare_tuples(MPL *mpl , TUPLE *tuple1 , TUPLE *tuple2 ) ;
#line 1031
TUPLE *_glp_mpl_build_subtuple(MPL *mpl , TUPLE *tuple , int dim ) ;
#line 1039
void _glp_mpl_delete_tuple(MPL *mpl , TUPLE *tuple ) ;
#line 1068
ELEMSET *_glp_mpl_create_elemset(MPL *mpl , int dim ) ;
#line 1072
MEMBER *_glp_mpl_find_tuple(MPL *mpl , ELEMSET *set___0 , TUPLE *tuple ) ;
#line 1080
MEMBER *_glp_mpl_add_tuple(MPL *mpl , ELEMSET *set___0 , TUPLE *tuple ) ;
#line 1088
MEMBER *_glp_mpl_check_then_add(MPL *mpl , ELEMSET *set___0 , TUPLE *tuple ) ;
#line 1096
ELEMSET *_glp_mpl_copy_elemset(MPL *mpl , ELEMSET *set___0 ) ;
#line 1103
void _glp_mpl_delete_elemset(MPL *mpl , ELEMSET *set___0 ) ;
#line 1110
int _glp_mpl_arelset_size(MPL *mpl , double t0 , double tf , double dt ) ;
#line 1114
double _glp_mpl_arelset_member(MPL *mpl , double t0 , double tf , double dt , int j ) ;
#line 1118
ELEMSET *_glp_mpl_create_arelset(MPL *mpl , double t0 , double tf , double dt ) ;
#line 1122
ELEMSET *_glp_mpl_set_union(MPL *mpl , ELEMSET *X , ELEMSET *Y ) ;
#line 1130
ELEMSET *_glp_mpl_set_diff(MPL *mpl , ELEMSET *X , ELEMSET *Y ) ;
#line 1138
ELEMSET *_glp_mpl_set_symdiff(MPL *mpl , ELEMSET *X , ELEMSET *Y ) ;
#line 1146
ELEMSET *_glp_mpl_set_inter(MPL *mpl , ELEMSET *X , ELEMSET *Y ) ;
#line 1154
ELEMSET *_glp_mpl_set_cross(MPL *mpl , ELEMSET *X , ELEMSET *Y ) ;
#line 1204
FORMULA *_glp_mpl_constant_term(MPL *mpl , double coef ) ;
#line 1208
FORMULA *_glp_mpl_single_variable(MPL *mpl , ELEMVAR *var ) ;
#line 1215
FORMULA *_glp_mpl_copy_formula(MPL *mpl , FORMULA *form ) ;
#line 1222
void _glp_mpl_delete_formula(MPL *mpl , FORMULA *form ) ;
#line 1229
FORMULA *_glp_mpl_linear_comb(MPL *mpl , double a , FORMULA *fx , double b , FORMULA *fy ) ;
#line 1237
FORMULA *_glp_mpl_remove_constant(MPL *mpl , FORMULA *form , double *coef ) ;
#line 1245
FORMULA *_glp_mpl_reduce_terms(MPL *mpl , FORMULA *form ) ;
#line 1304
void _glp_mpl_delete_value(MPL *mpl , int type , VALUE *value ) ;
#line 1366
MEMBER *_glp_mpl_find_member(MPL *mpl , ARRAY *array , TUPLE *tuple ) ;
#line 1374
MEMBER *_glp_mpl_add_member(MPL *mpl , ARRAY *array , TUPLE *tuple ) ;
#line 1382
void _glp_mpl_delete_array(MPL *mpl , ARRAY *array ) ;
#line 1450
void _glp_mpl_assign_dummy_index(MPL *mpl , DOMAIN_SLOT *slot , SYMBOL *value ) ;
#line 1458
void _glp_mpl_update_dummy_indices(MPL *mpl , DOMAIN_BLOCK *block ) ;
#line 1465
int _glp_mpl_enter_domain_block(MPL *mpl , DOMAIN_BLOCK *block , TUPLE *tuple , void *info ,
                                void (*func___0)(MPL *mpl , void *info ) ) ;
#line 1474
int _glp_mpl_eval_within_domain(MPL *mpl , DOMAIN1 *domain , TUPLE *tuple , void *info ,
                                void (*func___0)(MPL *mpl , void *info ) ) ;
#line 1483
void _glp_mpl_loop_within_domain(MPL *mpl , DOMAIN1 *domain , void *info , int (*func___0)(MPL *mpl ,
                                                                                           void *info ) ) ;
#line 1491
void _glp_mpl_out_of_domain(MPL *mpl , char *name , TUPLE *tuple ) ;
#line 1499
TUPLE *_glp_mpl_get_domain_tuple(MPL *mpl , DOMAIN1 *domain ) ;
#line 1506
void _glp_mpl_clean_domain(MPL *mpl , DOMAIN1 *domain ) ;
#line 1564
void _glp_mpl_check_elem_set(MPL *mpl , SET *set___0 , TUPLE *tuple , ELEMSET *refer ) ;
#line 1573
ELEMSET *_glp_mpl_take_member_set(MPL *mpl , SET *set___0 , TUPLE *tuple ) ;
#line 1581
ELEMSET *_glp_mpl_eval_member_set(MPL *mpl , SET *set___0 , TUPLE *tuple ) ;
#line 1589
void _glp_mpl_eval_whole_set(MPL *mpl , SET *set___0 ) ;
#line 1593
void _glp_mpl_clean_set(MPL *mpl , SET *set___0 ) ;
#line 1657
void _glp_mpl_check_value_num(MPL *mpl , PARAMETER *par , TUPLE *tuple , double value ) ;
#line 1666
double _glp_mpl_take_member_num(MPL *mpl , PARAMETER *par , TUPLE *tuple ) ;
#line 1674
double _glp_mpl_eval_member_num(MPL *mpl , PARAMETER *par , TUPLE *tuple ) ;
#line 1682
void _glp_mpl_check_value_sym(MPL *mpl , PARAMETER *par , TUPLE *tuple , SYMBOL *value ) ;
#line 1691
SYMBOL *_glp_mpl_take_member_sym(MPL *mpl , PARAMETER *par , TUPLE *tuple ) ;
#line 1699
SYMBOL *_glp_mpl_eval_member_sym(MPL *mpl , PARAMETER *par , TUPLE *tuple ) ;
#line 1707
void _glp_mpl_eval_whole_par(MPL *mpl , PARAMETER *par ) ;
#line 1711
void _glp_mpl_clean_parameter(MPL *mpl , PARAMETER *par ) ;
#line 1747
ELEMVAR *_glp_mpl_take_member_var(MPL *mpl , VARIABLE *var , TUPLE *tuple ) ;
#line 1755
ELEMVAR *_glp_mpl_eval_member_var(MPL *mpl , VARIABLE *var , TUPLE *tuple ) ;
#line 1763
void _glp_mpl_eval_whole_var(MPL *mpl , VARIABLE *var ) ;
#line 1767
void _glp_mpl_clean_variable(MPL *mpl , VARIABLE *var ) ;
#line 1805
ELEMCON *_glp_mpl_take_member_con(MPL *mpl , CONSTRAINT *con , TUPLE *tuple ) ;
#line 1813
ELEMCON *_glp_mpl_eval_member_con(MPL *mpl , CONSTRAINT *con , TUPLE *tuple ) ;
#line 1821
void _glp_mpl_eval_whole_con(MPL *mpl , CONSTRAINT *con ) ;
#line 1825
void _glp_mpl_clean_constraint(MPL *mpl , CONSTRAINT *con ) ;
#line 2178
double _glp_mpl_eval_numeric(MPL *mpl , CODE *code ) ;
#line 2182
SYMBOL *_glp_mpl_eval_symbolic(MPL *mpl , CODE *code ) ;
#line 2186
int _glp_mpl_eval_logical(MPL *mpl , CODE *code ) ;
#line 2190
TUPLE *_glp_mpl_eval_tuple(MPL *mpl , CODE *code ) ;
#line 2194
ELEMSET *_glp_mpl_eval_elemset(MPL *mpl , CODE *code ) ;
#line 2198
int _glp_mpl_is_member(MPL *mpl , CODE *code , TUPLE *tuple ) ;
#line 2202
FORMULA *_glp_mpl_eval_formula(MPL *mpl , CODE *code ) ;
#line 2206
void _glp_mpl_clean_code(MPL *mpl , CODE *code ) ;
#line 2321
void _glp_mpl_execute_table(MPL *mpl , TABLE *tab ) ;
#line 2329
void _glp_mpl_clean_table(MPL *mpl , TABLE *tab ) ;
#line 2333
void _glp_mpl_execute_check(MPL *mpl , CHECK *chk ) ;
#line 2337
void _glp_mpl_clean_check(MPL *mpl , CHECK *chk ) ;
#line 2341
void _glp_mpl_execute_display(MPL *mpl , DISPLAY *dpy ) ;
#line 2345
void _glp_mpl_clean_display(MPL *mpl , DISPLAY *dpy ) ;
#line 2349
void _glp_mpl_execute_printf(MPL *mpl , PRINTF *prt ) ;
#line 2353
void _glp_mpl_clean_printf(MPL *mpl , PRINTF *prt ) ;
#line 2357
void _glp_mpl_execute_for(MPL *mpl , FOR *fur ) ;
#line 2361
void _glp_mpl_clean_for(MPL *mpl , FOR *fur ) ;
#line 38 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_add(MPL *mpl , double x , double y ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 39
  if (x > 0.0) {
#line 39
    if (y > 0.0) {
#line 39
      if (x > 0.999 * 1.7976931348623157e+308 - y) {
        {
#line 41
        _glp_mpl_error(mpl, (char *)"%.*g + %.*g; floating-point overflow", 15, x,
                       15, y);
        }
      } else {
#line 39
        goto _L___0;
      }
    } else {
#line 39
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 39
  if (x < 0.0) {
#line 39
    if (y < 0.0) {
#line 39
      if (x < - 0.999 * 1.7976931348623157e+308 - y) {
        {
#line 41
        _glp_mpl_error(mpl, (char *)"%.*g + %.*g; floating-point overflow", 15, x,
                       15, y);
        }
      }
    }
  }
#line 43
  return (x + y);
}
}
#line 51 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_sub(MPL *mpl , double x , double y ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 52
  if (x > 0.0) {
#line 52
    if (y < 0.0) {
#line 52
      if (x > 0.999 * 1.7976931348623157e+308 + y) {
        {
#line 54
        _glp_mpl_error(mpl, (char *)"%.*g - %.*g; floating-point overflow", 15, x,
                       15, y);
        }
      } else {
#line 52
        goto _L___0;
      }
    } else {
#line 52
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 52
  if (x < 0.0) {
#line 52
    if (y > 0.0) {
#line 52
      if (x < - 0.999 * 1.7976931348623157e+308 + y) {
        {
#line 54
        _glp_mpl_error(mpl, (char *)"%.*g - %.*g; floating-point overflow", 15, x,
                       15, y);
        }
      }
    }
  }
#line 56
  return (x - y);
}
}
#line 64 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_less(MPL *mpl , double x , double y ) 
{ 
  char *__cil_tmp4 ;

  {
#line 65
  if (x < y) {
#line 65
    return (0.0);
  }
#line 66
  if (x > 0.0) {
#line 66
    if (y < 0.0) {
#line 66
      if (x > 0.999 * 1.7976931348623157e+308 + y) {
        {
#line 67
        _glp_mpl_error(mpl, (char *)"%.*g less %.*g; floating-point overflow", 15,
                       x, 15, y);
        }
      }
    }
  }
#line 69
  return (x - y);
}
}
#line 77 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_mul(MPL *mpl , double x , double y ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 78
  tmp = fabs(y);
  }
#line 78
  if (tmp > 1.0) {
    {
#line 78
    tmp___0 = fabs(x);
#line 78
    tmp___1 = fabs(y);
    }
#line 78
    if (tmp___0 > (0.999 * 1.7976931348623157e+308) / tmp___1) {
      {
#line 79
      _glp_mpl_error(mpl, (char *)"%.*g * %.*g; floating-point overflow", 15, x, 15,
                     y);
      }
    }
  }
#line 81
  return (x * y);
}
}
#line 89 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_div(MPL *mpl , double x , double y ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 90
  tmp = fabs(y);
  }
#line 90
  if (tmp < 2.2250738585072014e-308) {
    {
#line 91
    _glp_mpl_error(mpl, (char *)"%.*g / %.*g; floating-point zero divide", 15, x,
                   15, y);
    }
  }
  {
#line 93
  tmp___0 = fabs(y);
  }
#line 93
  if (tmp___0 < 1.0) {
    {
#line 93
    tmp___1 = fabs(x);
#line 93
    tmp___2 = fabs(y);
    }
#line 93
    if (tmp___1 > (0.999 * 1.7976931348623157e+308) * tmp___2) {
      {
#line 94
      _glp_mpl_error(mpl, (char *)"%.*g / %.*g; floating-point overflow", 15, x, 15,
                     y);
      }
    }
  }
#line 96
  return (x / y);
}
}
#line 104 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_idiv(MPL *mpl , double x , double y ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 105
  tmp = fabs(y);
  }
#line 105
  if (tmp < 2.2250738585072014e-308) {
    {
#line 106
    _glp_mpl_error(mpl, (char *)"%.*g div %.*g; floating-point zero divide", 15, x,
                   15, y);
    }
  }
  {
#line 108
  tmp___0 = fabs(y);
  }
#line 108
  if (tmp___0 < 1.0) {
    {
#line 108
    tmp___1 = fabs(x);
#line 108
    tmp___2 = fabs(y);
    }
#line 108
    if (tmp___1 > (0.999 * 1.7976931348623157e+308) * tmp___2) {
      {
#line 109
      _glp_mpl_error(mpl, (char *)"%.*g div %.*g; floating-point overflow", 15, x,
                     15, y);
      }
    }
  }
#line 111
  x /= y;
#line 112
  if (x > 0.0) {
    {
#line 112
    tmp___3 = floor(x);
#line 112
    tmp___6 = tmp___3;
    }
  } else {
#line 112
    if (x < 0.0) {
      {
#line 112
      tmp___4 = ceil(x);
#line 112
      tmp___5 = tmp___4;
      }
    } else {
#line 112
      tmp___5 = 0.0;
    }
#line 112
    tmp___6 = tmp___5;
  }
#line 112
  return (tmp___6);
}
}
#line 122 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_mod(MPL *mpl , double x , double y ) 
{ 
  double r ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 124
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 124
    tmp = 1;
  } else {
    {
#line 124
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     124);
#line 124
    tmp = 1;
    }
  }
#line 125
  if (x == 0.0) {
#line 126
    r = 0.0;
  } else
#line 127
  if (y == 0.0) {
#line 128
    r = x;
  } else {
    {
#line 130
    tmp___0 = fabs(y);
#line 130
    tmp___1 = fabs(x);
#line 130
    r = fmod(tmp___1, tmp___0);
    }
#line 131
    if (r != 0.0) {
#line 132
      if (x < 0.0) {
#line 132
        r = - r;
      }
#line 133
      if (x > 0.0) {
#line 133
        if (y < 0.0) {
#line 133
          r += y;
        } else {
#line 133
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 133
      if (x < 0.0) {
#line 133
        if (y > 0.0) {
#line 133
          r += y;
        }
      }
    }
  }
#line 136
  return (r);
}
}
#line 144 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_power(MPL *mpl , double x , double y ) 
{ 
  double r ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 146
  if (x == 0.0) {
#line 146
    if (y <= 0.0) {
      {
#line 147
      _glp_mpl_error(mpl, (char *)"%.*g ** %.*g; result undefined", 15, x, 15, y);
      }
    } else {
#line 146
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 146
  if (x < 0.0) {
    {
#line 146
    tmp = floor(y);
    }
#line 146
    if (y != tmp) {
      {
#line 147
      _glp_mpl_error(mpl, (char *)"%.*g ** %.*g; result undefined", 15, x, 15, y);
      }
    }
  }
#line 149
  if (x == 0.0) {
#line 149
    goto eval;
  }
  {
#line 150
  tmp___0 = fabs(x);
  }
#line 150
  if (tmp___0 > 1.0) {
#line 150
    if (y > 1.0) {
      {
#line 150
      tmp___1 = fabs(x);
#line 150
      tmp___2 = log(tmp___1);
#line 150
      tmp___3 = log(1.7976931348623157e+308);
      }
#line 150
      if (tmp___2 > (0.999 * tmp___3) / y) {
        {
#line 154
        _glp_mpl_error(mpl, (char *)"%.*g ** %.*g; floating-point overflow", 15, x,
                       15, y);
        }
      } else {
#line 150
        goto _L___1;
      }
    } else {
#line 150
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 150
    tmp___4 = fabs(x);
    }
#line 150
    if (tmp___4 < 1.0) {
#line 150
      if (y < - 1.0) {
        {
#line 150
        tmp___5 = fabs(x);
#line 150
        tmp___6 = log(tmp___5);
#line 150
        tmp___7 = log(1.7976931348623157e+308);
        }
#line 150
        if (tmp___6 < (0.999 * tmp___7) / y) {
          {
#line 154
          _glp_mpl_error(mpl, (char *)"%.*g ** %.*g; floating-point overflow", 15,
                         x, 15, y);
          }
        }
      }
    }
  }
  {
#line 156
  tmp___8 = fabs(x);
  }
#line 156
  if (tmp___8 > 1.0) {
#line 156
    if (y < - 1.0) {
      {
#line 156
      tmp___9 = fabs(x);
#line 156
      tmp___10 = log(tmp___9);
#line 156
      tmp___11 = log(1.7976931348623157e+308);
      }
#line 156
      if (- tmp___10 < (0.999 * tmp___11) / y) {
#line 160
        r = 0.0;
      } else {
#line 156
        goto _L___5;
      }
    } else {
#line 156
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    {
#line 156
    tmp___12 = fabs(x);
    }
#line 156
    if (tmp___12 < 1.0) {
#line 156
      if (y > 1.0) {
        {
#line 156
        tmp___13 = fabs(x);
#line 156
        tmp___14 = log(tmp___13);
#line 156
        tmp___15 = log(1.7976931348623157e+308);
        }
#line 156
        if (- tmp___14 > (0.999 * tmp___15) / y) {
#line 160
          r = 0.0;
        } else {
#line 156
          goto eval;
        }
      } else {
#line 156
        goto eval;
      }
    } else {
      eval: 
      {
#line 162
      r = pow(x, y);
      }
    }
  }
#line 163
  return (r);
}
}
#line 171 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_exp(MPL *mpl , double x ) 
{ 
  double tmp ;
  double tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 172
  tmp = log(1.7976931348623157e+308);
  }
#line 172
  if (x > 0.999 * tmp) {
    {
#line 173
    _glp_mpl_error(mpl, (char *)"exp(%.*g); floating-point overflow", 15, x);
    }
  }
  {
#line 174
  tmp___0 = exp(x);
  }
#line 174
  return (tmp___0);
}
}
#line 182 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_log(MPL *mpl , double x ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;

  {
#line 183
  if (x <= 0.0) {
    {
#line 184
    _glp_mpl_error(mpl, (char *)"log(%.*g); non-positive argument", 15, x);
    }
  }
  {
#line 185
  tmp = log(x);
  }
#line 185
  return (tmp);
}
}
#line 193 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_log10(MPL *mpl , double x ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;

  {
#line 194
  if (x <= 0.0) {
    {
#line 195
    _glp_mpl_error(mpl, (char *)"log10(%.*g); non-positive argument", 15, x);
    }
  }
  {
#line 196
  tmp = log10(x);
  }
#line 196
  return (tmp);
}
}
#line 204 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_sqrt(MPL *mpl , double x ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;

  {
#line 205
  if (x < 0.0) {
    {
#line 206
    _glp_mpl_error(mpl, (char *)"sqrt(%.*g); negative argument", 15, x);
    }
  }
  {
#line 207
  tmp = sqrt(x);
  }
#line 207
  return (tmp);
}
}
#line 215 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_sin(MPL *mpl , double x ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 216
  if (- 1e6 <= x) {
#line 216
    if (! (x <= 1e6)) {
      {
#line 217
      _glp_mpl_error(mpl, (char *)"sin(%.*g); argument too large", 15, x);
      }
    }
  } else {
    {
#line 217
    _glp_mpl_error(mpl, (char *)"sin(%.*g); argument too large", 15, x);
    }
  }
  {
#line 218
  tmp = sin(x);
  }
#line 218
  return (tmp);
}
}
#line 226 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_cos(MPL *mpl , double x ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 227
  if (- 1e6 <= x) {
#line 227
    if (! (x <= 1e6)) {
      {
#line 228
      _glp_mpl_error(mpl, (char *)"cos(%.*g); argument too large", 15, x);
      }
    }
  } else {
    {
#line 228
    _glp_mpl_error(mpl, (char *)"cos(%.*g); argument too large", 15, x);
    }
  }
  {
#line 229
  tmp = cos(x);
  }
#line 229
  return (tmp);
}
}
#line 237 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_atan(MPL *mpl , double x ) 
{ 
  int tmp ;
  double tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 238
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 238
    tmp = 1;
  } else {
    {
#line 238
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     238);
#line 238
    tmp = 1;
    }
  }
  {
#line 239
  tmp___0 = atan(x);
  }
#line 239
  return (tmp___0);
}
}
#line 247 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_atan2(MPL *mpl , double y , double x ) 
{ 
  int tmp ;
  double tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 248
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 248
    tmp = 1;
  } else {
    {
#line 248
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     248);
#line 248
    tmp = 1;
    }
  }
  {
#line 249
  tmp___0 = atan2(y, x);
  }
#line 249
  return (tmp___0);
}
}
#line 262 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_round(MPL *mpl , double x , double n ) 
{ 
  double ten_to_n ;
  double tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 264
  tmp = floor(n);
  }
#line 264
  if (n != tmp) {
    {
#line 265
    _glp_mpl_error(mpl, (char *)"round(%.*g, %.*g); non-integer second argument",
                   15, x, 15, n);
    }
  }
#line 267
  if (n <= (double )17) {
    {
#line 268
    ten_to_n = pow(10.0, n);
#line 269
    tmp___0 = fabs(x);
    }
#line 269
    if (tmp___0 < (0.999 * 1.7976931348623157e+308) / ten_to_n) {
      {
#line 270
      x = floor(x * ten_to_n + 0.5);
      }
#line 271
      if (x != 0.0) {
#line 271
        x /= ten_to_n;
      }
    }
  }
#line 274
  return (x);
}
}
#line 289 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_trunc(MPL *mpl , double x , double n ) 
{ 
  double ten_to_n ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 291
  tmp = floor(n);
  }
#line 291
  if (n != tmp) {
    {
#line 292
    _glp_mpl_error(mpl, (char *)"trunc(%.*g, %.*g); non-integer second argument",
                   15, x, 15, n);
    }
  }
#line 294
  if (n <= (double )17) {
    {
#line 295
    ten_to_n = pow(10.0, n);
#line 296
    tmp___2 = fabs(x);
    }
#line 296
    if (tmp___2 < (0.999 * 1.7976931348623157e+308) / ten_to_n) {
#line 297
      if (x >= 0.0) {
        {
#line 297
        tmp___0 = floor(x * ten_to_n);
#line 297
        x = tmp___0;
        }
      } else {
        {
#line 297
        tmp___1 = ceil(x * ten_to_n);
#line 297
        x = tmp___1;
        }
      }
#line 298
      if (x != 0.0) {
#line 298
        x /= ten_to_n;
      }
    }
  }
#line 301
  return (x);
}
}
#line 317 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_irand224(MPL *mpl ) 
{ 
  int tmp ;

  {
  {
#line 318
  tmp = _glp_rng_unif_rand(mpl->rand, 16777216);
  }
#line 318
  return ((double )tmp);
}
}
#line 330 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_uniform01(MPL *mpl ) 
{ 
  int tmp ;

  {
  {
#line 331
  tmp = _glp_rng_next_rand(mpl->rand);
  }
#line 331
  return ((double )tmp / (double )2147483648U);
}
}
#line 341 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_uniform(MPL *mpl , double a , double b ) 
{ 
  double x ;
  char *__cil_tmp5 ;

  {
#line 343
  if (a >= b) {
    {
#line 344
    _glp_mpl_error(mpl, (char *)"Uniform(%.*g, %.*g); invalid range", 15, a, 15, b);
    }
  }
  {
#line 346
  x = _glp_mpl_fp_uniform01(mpl);
#line 350
  x = _glp_mpl_fp_add(mpl, a * (1.0 - x), b * x);
  }
#line 352
  return (x);
}
}
#line 364 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_normal01(MPL *mpl ) 
{ 
  double x ;
  double y ;
  double r2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    tmp = _glp_mpl_fp_uniform01(mpl);
#line 368
    x = - 1.0 + 2.0 * tmp;
#line 369
    tmp___0 = _glp_mpl_fp_uniform01(mpl);
#line 369
    y = - 1.0 + 2.0 * tmp___0;
#line 371
    r2 = x * x + y * y;
    }
#line 366
    if (! (r2 > 1.0)) {
#line 366
      if (! (r2 == 0.0)) {
#line 366
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  tmp___1 = log(r2);
#line 374
  tmp___2 = sqrt((- 2.0 * tmp___1) / r2);
  }
#line 374
  return (y * tmp___2);
}
}
#line 383 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_fp_normal(MPL *mpl , double mu , double sigma ) 
{ 
  double x ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 388
  tmp = _glp_mpl_fp_normal01(mpl);
#line 388
  tmp___0 = _glp_mpl_fp_mul(mpl, sigma, tmp);
#line 388
  x = _glp_mpl_fp_add(mpl, mu, tmp___0);
  }
#line 390
  return (x);
}
}
#line 403 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
STRING *_glp_mpl_create_string(MPL *mpl , char *buf ) 
{ 
  STRING *str ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 423
  tmp = strlen((char const   *)buf);
  }
#line 423
  if (tmp <= 100U) {
#line 423
    tmp___0 = 1;
  } else {
    {
#line 423
    _glp_lib_xassert("strlen(buf) <= MAX_LENGTH", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     423);
#line 423
    tmp___0 = 1;
    }
  }
  {
#line 424
  tmp___1 = strlen((char const   *)buf);
#line 424
  tmp___2 = _glp_dmp_get_atom(mpl->strings, (int )(tmp___1 + 1U));
#line 424
  str = (STRING *)tmp___2;
#line 425
  strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)buf);
  }
#line 426
  return (str);
}
}
#line 435 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
STRING *_glp_mpl_copy_string(MPL *mpl , STRING *str ) 
{ 
  int tmp ;
  STRING *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 452
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 452
    tmp = 1;
  } else {
    {
#line 452
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     452);
#line 452
    tmp = 1;
    }
  }
  {
#line 453
  tmp___0 = _glp_mpl_create_string(mpl, (char *)str);
  }
#line 453
  return (tmp___0);
}
}
#line 467 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_compare_strings(MPL *mpl , STRING *str1 , STRING *str2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 489
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 489
    tmp = 1;
  } else {
    {
#line 489
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     489);
#line 489
    tmp = 1;
    }
  }
  {
#line 490
  tmp___0 = strcmp((char const   *)str1, (char const   *)str2);
  }
#line 490
  return (tmp___0);
}
}
#line 500 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
char *_glp_mpl_fetch_string(MPL *mpl , STRING *str , char *buf ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 518
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 518
    tmp = 1;
  } else {
    {
#line 518
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     518);
#line 518
    tmp = 1;
    }
  }
  {
#line 519
  tmp___0 = strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)str);
  }
#line 519
  return (tmp___0);
}
}
#line 528 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_delete_string(MPL *mpl , STRING *str ) 
{ 
  size_t tmp ;

  {
  {
#line 543
  tmp = strlen((char const   *)str);
#line 543
  _glp_dmp_free_atom(mpl->strings, (void *)str, (int )(tmp + 1U));
  }
#line 544
  return;
}
}
#line 558 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
SYMBOL *_glp_mpl_create_symbol_num(MPL *mpl , double num ) 
{ 
  SYMBOL *sym ;
  void *tmp ;

  {
  {
#line 560
  tmp = _glp_dmp_get_atom(mpl->symbols, (int )sizeof(SYMBOL ));
#line 560
  sym = (SYMBOL *)tmp;
#line 561
  sym->num = num;
#line 562
  sym->str = (STRING *)((void *)0);
  }
#line 563
  return (sym);
}
}
#line 572 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
SYMBOL *_glp_mpl_create_symbol_str(MPL *mpl , STRING *str ) 
{ 
  SYMBOL *sym ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 577
  if ((unsigned long )str != (unsigned long )((void *)0)) {
#line 577
    tmp = 1;
  } else {
    {
#line 577
    _glp_lib_xassert("str != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     577);
#line 577
    tmp = 1;
    }
  }
  {
#line 578
  tmp___0 = _glp_dmp_get_atom(mpl->symbols, (int )sizeof(SYMBOL ));
#line 578
  sym = (SYMBOL *)tmp___0;
#line 579
  sym->num = 0.0;
#line 580
  sym->str = str;
  }
#line 581
  return (sym);
}
}
#line 589 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
SYMBOL *_glp_mpl_copy_symbol(MPL *mpl , SYMBOL *sym ) 
{ 
  SYMBOL *copy ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 594
  if ((unsigned long )sym != (unsigned long )((void *)0)) {
#line 594
    tmp = 1;
  } else {
    {
#line 594
    _glp_lib_xassert("sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     594);
#line 594
    tmp = 1;
    }
  }
  {
#line 595
  tmp___0 = _glp_dmp_get_atom(mpl->symbols, (int )sizeof(SYMBOL ));
#line 595
  copy = (SYMBOL *)tmp___0;
  }
#line 596
  if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
#line 597
    copy->num = sym->num;
#line 598
    copy->str = (STRING *)((void *)0);
  } else {
    {
#line 601
    copy->num = 0.0;
#line 602
    copy->str = _glp_mpl_copy_string(mpl, sym->str);
    }
  }
#line 604
  return (copy);
}
}
#line 620 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_compare_symbols(MPL *mpl , SYMBOL *sym1 , SYMBOL *sym2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 625
  if ((unsigned long )sym1 != (unsigned long )((void *)0)) {
#line 625
    tmp = 1;
  } else {
    {
#line 625
    _glp_lib_xassert("sym1 != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     625);
#line 625
    tmp = 1;
    }
  }
#line 626
  if ((unsigned long )sym2 != (unsigned long )((void *)0)) {
#line 626
    tmp___0 = 1;
  } else {
    {
#line 626
    _glp_lib_xassert("sym2 != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     626);
#line 626
    tmp___0 = 1;
    }
  }
#line 628
  if ((unsigned long )sym1->str == (unsigned long )((void *)0)) {
#line 628
    if ((unsigned long )sym2->str == (unsigned long )((void *)0)) {
#line 629
      if (sym1->num < sym2->num) {
#line 629
        return (-1);
      }
#line 630
      if (sym1->num > sym2->num) {
#line 630
        return (1);
      }
#line 631
      return (0);
    }
  }
#line 633
  if ((unsigned long )sym1->str == (unsigned long )((void *)0)) {
#line 633
    return (-1);
  }
#line 634
  if ((unsigned long )sym2->str == (unsigned long )((void *)0)) {
#line 634
    return (1);
  }
  {
#line 635
  tmp___1 = _glp_mpl_compare_strings(mpl, sym1->str, sym2->str);
  }
#line 635
  return (tmp___1);
}
}
#line 643 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_delete_symbol(MPL *mpl , SYMBOL *sym ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 647
  if ((unsigned long )sym != (unsigned long )((void *)0)) {
#line 647
    tmp = 1;
  } else {
    {
#line 647
    _glp_lib_xassert("sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     647);
#line 647
    tmp = 1;
    }
  }
#line 648
  if ((unsigned long )sym->str != (unsigned long )((void *)0)) {
    {
#line 648
    _glp_mpl_delete_string(mpl, sym->str);
    }
  }
  {
#line 649
  _glp_dmp_free_atom(mpl->symbols, (void *)sym, (int )sizeof(SYMBOL ));
  }
#line 650
  return;
}
}
#line 662 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
char *_glp_mpl_format_symbol(MPL *mpl , SYMBOL *sym ) 
{ 
  char *buf ;
  int tmp ;
  char str[101] ;
  int quoted ;
  int j ;
  int len ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 666
  buf = mpl->sym_buf;
#line 667
  if ((unsigned long )sym != (unsigned long )((void *)0)) {
#line 667
    tmp = 1;
  } else {
    {
#line 667
    _glp_lib_xassert("sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     667);
#line 667
    tmp = 1;
    }
  }
#line 668
  if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
    {
#line 669
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%.*g",
            15, sym->num);
    }
  } else {
    {
#line 673
    _glp_mpl_fetch_string(mpl, sym->str, (char *)(str));
#line 674
    tmp___2 = __ctype_b_loc();
    }
#line 674
    if ((int const   )*(*tmp___2 + (int )((unsigned char )str[0])) & 1024) {
#line 674
      goto _L;
    } else
#line 674
    if ((int )str[0] == 95) {
      _L: /* CIL Label */ 
#line 677
      quoted = 0;
#line 678
      j = 1;
      {
#line 678
      while (1) {
        while_continue: /* CIL Label */ ;
#line 678
        if (! ((int )str[j] != 0)) {
#line 678
          goto while_break;
        }
        {
#line 679
        tmp___0 = __ctype_b_loc();
        }
#line 679
        if (! ((int const   )*(*tmp___0 + (int )((unsigned char )str[j])) & 8)) {
          {
#line 679
          tmp___1 = strchr("+-._", (int )((unsigned char )str[j]));
          }
#line 679
          if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 681
            quoted = 1;
#line 682
            goto while_break;
          }
        }
#line 678
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 675
      quoted = 1;
    }
#line 688
    *(buf + 0) = (char )'\000';
#line 688
    len = 0;
#line 689
    if (quoted) {
#line 689
      if (len < 255) {
#line 689
        tmp___3 = len;
#line 689
        len ++;
#line 689
        *(buf + tmp___3) = (char )'\'';
      }
    }
#line 690
    j = 0;
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 690
      if (! ((int )str[j] != 0)) {
#line 690
        goto while_break___0;
      }
#line 691
      if (quoted) {
#line 691
        if ((int )str[j] == 39) {
#line 691
          if (len < 255) {
#line 691
            tmp___4 = len;
#line 691
            len ++;
#line 691
            *(buf + tmp___4) = (char )'\'';
          }
        }
      }
#line 692
      if (len < 255) {
#line 692
        tmp___5 = len;
#line 692
        len ++;
#line 692
        *(buf + tmp___5) = str[j];
      }
#line 690
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 694
    if (quoted) {
#line 694
      if (len < 255) {
#line 694
        tmp___6 = len;
#line 694
        len ++;
#line 694
        *(buf + tmp___6) = (char )'\'';
      }
    }
#line 696
    *(buf + len) = (char )'\000';
#line 697
    if (len == 255) {
      {
#line 697
      strcpy((char */* __restrict  */)(buf + 252), (char const   */* __restrict  */)"...");
      }
    }
  }
  {
#line 699
  tmp___7 = strlen((char const   *)buf);
  }
#line 699
  if (tmp___7 <= 255U) {
#line 699
    tmp___8 = 1;
  } else {
    {
#line 699
    _glp_lib_xassert("strlen(buf) <= 255", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     699);
#line 699
    tmp___8 = 1;
    }
  }
#line 700
  return (buf);
}
}
#line 710 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
SYMBOL *_glp_mpl_concat_symbols(MPL *mpl , SYMBOL *sym1 , SYMBOL *sym2 ) 
{ 
  char str1[101] ;
  char str2[101] ;
  char buf[256] ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  STRING *tmp___6 ;
  SYMBOL *tmp___7 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 717
  if ((unsigned long )sym1->str == (unsigned long )((void *)0)) {
    {
#line 718
    sprintf((char */* __restrict  */)(str1), (char const   */* __restrict  */)"%.*g",
            15, sym1->num);
    }
  } else {
    {
#line 720
    _glp_mpl_fetch_string(mpl, sym1->str, (char *)(str1));
    }
  }
#line 721
  if ((unsigned long )sym2->str == (unsigned long )((void *)0)) {
    {
#line 722
    sprintf((char */* __restrict  */)(str2), (char const   */* __restrict  */)"%.*g",
            15, sym2->num);
    }
  } else {
    {
#line 724
    _glp_mpl_fetch_string(mpl, sym2->str, (char *)(str2));
    }
  }
  {
#line 725
  tmp___3 = strlen((char const   *)(str1));
#line 725
  tmp___4 = strlen((char const   *)(str2));
  }
#line 725
  if (tmp___3 + tmp___4 > 100U) {
    {
#line 727
    tmp = _glp_mpl_format_symbol(mpl, sym1);
#line 727
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp);
#line 728
    tmp___0 = strlen((char const   *)(buf));
    }
#line 728
    if ((unsigned long )tmp___0 < sizeof(buf)) {
#line 728
      tmp___1 = 1;
    } else {
      {
#line 728
      _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       728);
#line 728
      tmp___1 = 1;
      }
    }
    {
#line 729
    tmp___2 = _glp_mpl_format_symbol(mpl, sym2);
#line 729
    _glp_mpl_error(mpl, (char *)"%s & %s; resultant symbol exceeds %d characters",
                   buf, tmp___2, 100);
    }
  }
  {
#line 732
  _glp_mpl_delete_symbol(mpl, sym1);
#line 733
  _glp_mpl_delete_symbol(mpl, sym2);
#line 734
  tmp___5 = strcat((char */* __restrict  */)(str1), (char const   */* __restrict  */)(str2));
#line 734
  tmp___6 = _glp_mpl_create_string(mpl, (char *)tmp___5);
#line 734
  tmp___7 = _glp_mpl_create_symbol_str(mpl, tmp___6);
  }
#line 734
  return (tmp___7);
}
}
#line 748 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
TUPLE *_glp_mpl_create_tuple(MPL *mpl ) 
{ 
  TUPLE *tuple ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 750
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 750
    tmp = 1;
  } else {
    {
#line 750
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     750);
#line 750
    tmp = 1;
    }
  }
#line 751
  tuple = (TUPLE *)((void *)0);
#line 752
  return (tuple);
}
}
#line 761 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
TUPLE *_glp_mpl_expand_tuple(MPL *mpl , TUPLE *tuple , SYMBOL *sym ) 
{ 
  TUPLE *tail ;
  TUPLE *temp ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 767
  if ((unsigned long )sym != (unsigned long )((void *)0)) {
#line 767
    tmp = 1;
  } else {
    {
#line 767
    _glp_lib_xassert("sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     767);
#line 767
    tmp = 1;
    }
  }
  {
#line 769
  tmp___0 = _glp_dmp_get_atom(mpl->tuples, (int )sizeof(TUPLE ));
#line 769
  tail = (TUPLE *)tmp___0;
#line 770
  tail->sym = sym;
#line 771
  tail->next = (TUPLE *)((void *)0);
  }
#line 773
  if ((unsigned long )tuple == (unsigned long )((void *)0)) {
#line 774
    tuple = tail;
  } else {
#line 776
    temp = tuple;
    {
#line 776
    while (1) {
      while_continue: /* CIL Label */ ;
#line 776
      if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 776
        goto while_break;
      }
#line 776
      temp = temp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 777
    temp->next = tail;
  }
#line 779
  return (tuple);
}
}
#line 788 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_tuple_dimen(MPL *mpl , TUPLE *tuple ) 
{ 
  TUPLE *temp ;
  int dim ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 793
  dim = 0;
#line 794
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 794
    tmp = 1;
  } else {
    {
#line 794
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     794);
#line 794
    tmp = 1;
    }
  }
#line 795
  temp = tuple;
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 795
      goto while_break;
    }
#line 795
    dim ++;
#line 795
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  return (dim);
}
}
#line 804 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
TUPLE *_glp_mpl_copy_tuple(MPL *mpl , TUPLE *tuple ) 
{ 
  TUPLE *head ;
  TUPLE *tail ;
  void *tmp ;
  int tmp___0 ;
  TUPLE *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 809
  if ((unsigned long )tuple == (unsigned long )((void *)0)) {
#line 810
    head = (TUPLE *)((void *)0);
  } else {
    {
#line 812
    tmp = _glp_dmp_get_atom(mpl->tuples, (int )sizeof(TUPLE ));
#line 812
    tail = (TUPLE *)tmp;
#line 812
    head = tail;
    }
    {
#line 813
    while (1) {
      while_continue: /* CIL Label */ ;
#line 813
      if (! ((unsigned long )tuple != (unsigned long )((void *)0))) {
#line 813
        goto while_break;
      }
#line 814
      if ((unsigned long )tuple->sym != (unsigned long )((void *)0)) {
#line 814
        tmp___0 = 1;
      } else {
        {
#line 814
        _glp_lib_xassert("tuple->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         814);
#line 814
        tmp___0 = 1;
        }
      }
      {
#line 815
      tail->sym = _glp_mpl_copy_symbol(mpl, tuple->sym);
      }
#line 816
      if ((unsigned long )tuple->next != (unsigned long )((void *)0)) {
        {
#line 817
        tmp___2 = _glp_dmp_get_atom(mpl->tuples, (int )sizeof(TUPLE ));
#line 817
        tmp___1 = (TUPLE *)tmp___2;
#line 817
        tail->next = tmp___1;
#line 817
        tail = tmp___1;
        }
      }
#line 813
      tuple = tuple->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 819
    tail->next = (TUPLE *)((void *)0);
  }
#line 821
  return (head);
}
}
#line 838 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_compare_tuples(MPL *mpl , TUPLE *tuple1 , TUPLE *tuple2 ) 
{ 
  TUPLE *item1 ;
  TUPLE *item2 ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 845
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 845
    tmp = 1;
  } else {
    {
#line 845
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     845);
#line 845
    tmp = 1;
    }
  }
#line 846
  item1 = tuple1;
#line 846
  item2 = tuple2;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! ((unsigned long )item1 != (unsigned long )((void *)0))) {
#line 846
      goto while_break;
    }
#line 848
    if ((unsigned long )item2 != (unsigned long )((void *)0)) {
#line 848
      tmp___0 = 1;
    } else {
      {
#line 848
      _glp_lib_xassert("item2 != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       848);
#line 848
      tmp___0 = 1;
      }
    }
#line 849
    if ((unsigned long )item1->sym != (unsigned long )((void *)0)) {
#line 849
      tmp___1 = 1;
    } else {
      {
#line 849
      _glp_lib_xassert("item1->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       849);
#line 849
      tmp___1 = 1;
      }
    }
#line 850
    if ((unsigned long )item2->sym != (unsigned long )((void *)0)) {
#line 850
      tmp___2 = 1;
    } else {
      {
#line 850
      _glp_lib_xassert("item2->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       850);
#line 850
      tmp___2 = 1;
      }
    }
    {
#line 851
    ret = _glp_mpl_compare_symbols(mpl, item1->sym, item2->sym);
    }
#line 852
    if (ret != 0) {
#line 852
      return (ret);
    }
#line 846
    item1 = item1->next;
#line 846
    item2 = item2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  if ((unsigned long )item2 == (unsigned long )((void *)0)) {
#line 854
    tmp___3 = 1;
  } else {
    {
#line 854
    _glp_lib_xassert("item2 == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     854);
#line 854
    tmp___3 = 1;
    }
  }
#line 855
  return (0);
}
}
#line 864 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
TUPLE *_glp_mpl_build_subtuple(MPL *mpl , TUPLE *tuple , int dim ) 
{ 
  TUPLE *head ;
  TUPLE *temp ;
  int j ;
  int tmp ;
  SYMBOL *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 871
  head = _glp_mpl_create_tuple(mpl);
#line 872
  j = 1;
#line 872
  temp = tuple;
  }
  {
#line 872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    if (! (j <= dim)) {
#line 872
      goto while_break;
    }
#line 873
    if ((unsigned long )temp != (unsigned long )((void *)0)) {
#line 873
      tmp = 1;
    } else {
      {
#line 873
      _glp_lib_xassert("temp != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       873);
#line 873
      tmp = 1;
      }
    }
    {
#line 874
    tmp___0 = _glp_mpl_copy_symbol(mpl, temp->sym);
#line 874
    head = _glp_mpl_expand_tuple(mpl, head, tmp___0);
#line 872
    j ++;
#line 872
    temp = temp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return (head);
}
}
#line 884 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_delete_tuple(MPL *mpl , TUPLE *tuple ) 
{ 
  TUPLE *temp ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 889
    if (! ((unsigned long )tuple != (unsigned long )((void *)0))) {
#line 889
      goto while_break;
    }
#line 890
    temp = tuple;
#line 891
    tuple = temp->next;
#line 892
    if ((unsigned long )temp->sym != (unsigned long )((void *)0)) {
#line 892
      tmp = 1;
    } else {
      {
#line 892
      _glp_lib_xassert("temp->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       892);
#line 892
      tmp = 1;
      }
    }
    {
#line 893
    _glp_mpl_delete_symbol(mpl, temp->sym);
#line 894
    _glp_dmp_free_atom(mpl->tuples, (void *)temp, (int )sizeof(TUPLE ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 896
  return;
}
}
#line 908 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
char *_glp_mpl_format_tuple(MPL *mpl , int c , TUPLE *tuple ) 
{ 
  TUPLE *temp ;
  int dim ;
  int j ;
  int len ;
  char *buf ;
  char str[256] ;
  char *save ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 915
  buf = mpl->tup_buf;
#line 918
  *(buf + 0) = (char )'\000';
#line 918
  len = 0;
#line 919
  dim = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 920
  if (c == 91) {
#line 920
    if (dim > 0) {
#line 920
      if (len < 255) {
#line 920
        tmp = len;
#line 920
        len ++;
#line 920
        *(buf + tmp) = (char )'[';
      }
    }
  }
#line 921
  if (c == 40) {
#line 921
    if (dim > 1) {
#line 921
      if (len < 255) {
#line 921
        tmp___0 = len;
#line 921
        len ++;
#line 921
        *(buf + tmp___0) = (char )'(';
      }
    }
  }
#line 922
  temp = tuple;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 922
      goto while_break;
    }
#line 923
    if ((unsigned long )temp != (unsigned long )tuple) {
#line 923
      if (len < 255) {
#line 923
        tmp___1 = len;
#line 923
        len ++;
#line 923
        *(buf + tmp___1) = (char )',';
      }
    }
#line 924
    if ((unsigned long )temp->sym != (unsigned long )((void *)0)) {
#line 924
      tmp___2 = 1;
    } else {
      {
#line 924
      _glp_lib_xassert("temp->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       924);
#line 924
      tmp___2 = 1;
      }
    }
    {
#line 925
    save = mpl->sym_buf;
#line 926
    mpl->sym_buf = str;
#line 927
    _glp_mpl_format_symbol(mpl, temp->sym);
#line 928
    mpl->sym_buf = save;
#line 929
    tmp___3 = strlen((char const   *)(str));
    }
#line 929
    if ((unsigned long )tmp___3 < sizeof(str)) {
#line 929
      tmp___4 = 1;
    } else {
      {
#line 929
      _glp_lib_xassert("strlen(str) < sizeof(str)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       929);
#line 929
      tmp___4 = 1;
      }
    }
#line 930
    j = 0;
    {
#line 930
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 930
      if (! ((int )str[j] != 0)) {
#line 930
        goto while_break___0;
      }
#line 930
      if (len < 255) {
#line 930
        tmp___5 = len;
#line 930
        len ++;
#line 930
        *(buf + tmp___5) = str[j];
      }
#line 930
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 922
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  if (c == 91) {
#line 932
    if (dim > 0) {
#line 932
      if (len < 255) {
#line 932
        tmp___6 = len;
#line 932
        len ++;
#line 932
        *(buf + tmp___6) = (char )']';
      }
    }
  }
#line 933
  if (c == 40) {
#line 933
    if (dim > 1) {
#line 933
      if (len < 255) {
#line 933
        tmp___7 = len;
#line 933
        len ++;
#line 933
        *(buf + tmp___7) = (char )')';
      }
    }
  }
#line 935
  *(buf + len) = (char )'\000';
#line 936
  if (len == 255) {
    {
#line 936
    strcpy((char */* __restrict  */)(buf + 252), (char const   */* __restrict  */)"...");
    }
  }
  {
#line 937
  tmp___8 = strlen((char const   *)buf);
  }
#line 937
  if (tmp___8 <= 255U) {
#line 937
    tmp___9 = 1;
  } else {
    {
#line 937
    _glp_lib_xassert("strlen(buf) <= 255", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     937);
#line 937
    tmp___9 = 1;
    }
  }
#line 938
  return (buf);
}
}
#line 951 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_create_elemset(MPL *mpl , int dim ) 
{ 
  ELEMSET *set___0 ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 953
  if (dim > 0) {
#line 953
    tmp = 1;
  } else {
    {
#line 953
    _glp_lib_xassert("dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     953);
#line 953
    tmp = 1;
    }
  }
  {
#line 954
  set___0 = _glp_mpl_create_array(mpl, 117, dim);
  }
#line 955
  return (set___0);
}
}
#line 966 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
MEMBER *_glp_mpl_find_tuple(MPL *mpl , ELEMSET *set___0 , TUPLE *tuple ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  MEMBER *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 971
  if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
#line 971
    tmp = 1;
  } else {
    {
#line 971
    _glp_lib_xassert("set != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     971);
#line 971
    tmp = 1;
    }
  }
#line 972
  if (set___0->type == 117) {
#line 972
    tmp___0 = 1;
  } else {
    {
#line 972
    _glp_lib_xassert("set->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     972);
#line 972
    tmp___0 = 1;
    }
  }
  {
#line 973
  tmp___1 = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 973
  if (set___0->dim == tmp___1) {
#line 973
    tmp___2 = 1;
  } else {
    {
#line 973
    _glp_lib_xassert("set->dim == tuple_dimen(mpl, tuple)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     973);
#line 973
    tmp___2 = 1;
    }
  }
  {
#line 974
  tmp___3 = _glp_mpl_find_member(mpl, set___0, tuple);
  }
#line 974
  return (tmp___3);
}
}
#line 988 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
MEMBER *_glp_mpl_add_tuple(MPL *mpl , ELEMSET *set___0 , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 994
  if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
#line 994
    tmp = 1;
  } else {
    {
#line 994
    _glp_lib_xassert("set != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     994);
#line 994
    tmp = 1;
    }
  }
#line 995
  if (set___0->type == 117) {
#line 995
    tmp___0 = 1;
  } else {
    {
#line 995
    _glp_lib_xassert("set->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     995);
#line 995
    tmp___0 = 1;
    }
  }
  {
#line 996
  tmp___1 = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 996
  if (set___0->dim == tmp___1) {
#line 996
    tmp___2 = 1;
  } else {
    {
#line 996
    _glp_lib_xassert("set->dim == tuple_dimen(mpl, tuple)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     996);
#line 996
    tmp___2 = 1;
    }
  }
  {
#line 997
  memb = _glp_mpl_add_member(mpl, set___0, tuple);
#line 998
  memb->value.none = (void *)0;
  }
#line 999
  return (memb);
}
}
#line 1008 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
MEMBER *_glp_mpl_check_then_add(MPL *mpl , ELEMSET *set___0 , TUPLE *tuple ) 
{ 
  char *tmp ;
  MEMBER *tmp___0 ;
  MEMBER *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 1013
  tmp___0 = _glp_mpl_find_tuple(mpl, set___0, tuple);
  }
#line 1013
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 1014
    tmp = _glp_mpl_format_tuple(mpl, '(', tuple);
#line 1014
    _glp_mpl_error(mpl, (char *)"duplicate tuple %s detected", tmp);
    }
  }
  {
#line 1016
  tmp___1 = _glp_mpl_add_tuple(mpl, set___0, tuple);
  }
#line 1016
  return (tmp___1);
}
}
#line 1024 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_copy_elemset(MPL *mpl , ELEMSET *set___0 ) 
{ 
  ELEMSET *copy ;
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  TUPLE *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1030
  if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
#line 1030
    tmp = 1;
  } else {
    {
#line 1030
    _glp_lib_xassert("set != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1030);
#line 1030
    tmp = 1;
    }
  }
#line 1031
  if (set___0->type == 117) {
#line 1031
    tmp___0 = 1;
  } else {
    {
#line 1031
    _glp_lib_xassert("set->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1031);
#line 1031
    tmp___0 = 1;
    }
  }
#line 1032
  if (set___0->dim > 0) {
#line 1032
    tmp___1 = 1;
  } else {
    {
#line 1032
    _glp_lib_xassert("set->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1032);
#line 1032
    tmp___1 = 1;
    }
  }
  {
#line 1033
  copy = _glp_mpl_create_elemset(mpl, set___0->dim);
#line 1034
  memb = set___0->head;
  }
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1034
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1034
      goto while_break;
    }
    {
#line 1035
    tmp___2 = _glp_mpl_copy_tuple(mpl, memb->tuple);
#line 1035
    _glp_mpl_add_tuple(mpl, copy, tmp___2);
#line 1034
    memb = memb->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  return (copy);
}
}
#line 1044 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_delete_elemset(MPL *mpl , ELEMSET *set___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1048
  if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
#line 1048
    tmp = 1;
  } else {
    {
#line 1048
    _glp_lib_xassert("set != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1048);
#line 1048
    tmp = 1;
    }
  }
#line 1049
  if (set___0->type == 117) {
#line 1049
    tmp___0 = 1;
  } else {
    {
#line 1049
    _glp_lib_xassert("set->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1049);
#line 1049
    tmp___0 = 1;
    }
  }
  {
#line 1050
  _glp_mpl_delete_array(mpl, set___0);
  }
#line 1051
  return;
}
}
#line 1066 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_arelset_size(MPL *mpl , double t0 , double tf , double dt ) 
{ 
  double temp ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1068
  if (dt == 0.0) {
    {
#line 1069
    _glp_mpl_error(mpl, (char *)"%.*g .. %.*g by %.*g; zero stride not allowed", 15,
                   t0, 15, tf, 15, dt);
    }
  }
#line 1071
  if (tf > 0.0) {
#line 1071
    if (t0 < 0.0) {
#line 1071
      if (tf > 0.999 * 1.7976931348623157e+308 + t0) {
#line 1072
        temp = 1.7976931348623157e+308;
      } else {
#line 1071
        goto _L___0;
      }
    } else {
#line 1071
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1073
  if (tf < 0.0) {
#line 1073
    if (t0 > 0.0) {
#line 1073
      if (tf < - 0.999 * 1.7976931348623157e+308 + t0) {
#line 1074
        temp = - 1.7976931348623157e+308;
      } else {
#line 1076
        temp = tf - t0;
      }
    } else {
#line 1076
      temp = tf - t0;
    }
  } else {
#line 1076
    temp = tf - t0;
  }
  {
#line 1077
  tmp___0 = fabs(dt);
  }
#line 1077
  if (tmp___0 < 1.0) {
    {
#line 1077
    tmp___1 = fabs(temp);
#line 1077
    tmp___2 = fabs(dt);
    }
#line 1077
    if (tmp___1 > (0.999 * 1.7976931348623157e+308) * tmp___2) {
#line 1078
      if (temp > 0.0) {
#line 1078
        if (dt > 0.0) {
#line 1079
          temp = 1.7976931348623157e+308;
        } else {
#line 1078
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1078
      if (temp < 0.0) {
#line 1078
        if (dt < 0.0) {
#line 1079
          temp = 1.7976931348623157e+308;
        } else {
#line 1081
          temp = 0.0;
        }
      } else {
#line 1081
        temp = 0.0;
      }
    } else {
#line 1077
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 1084
    tmp = floor(temp / dt);
#line 1084
    temp = tmp + 1.0;
    }
#line 1085
    if (temp < 0.0) {
#line 1085
      temp = 0.0;
    }
  }
#line 1087
  if (temp >= 0.0) {
#line 1087
    tmp___3 = 1;
  } else {
    {
#line 1087
    _glp_lib_xassert("temp >= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1087);
#line 1087
    tmp___3 = 1;
    }
  }
#line 1088
  if (temp > (double )2147483646) {
    {
#line 1089
    _glp_mpl_error(mpl, (char *)"%.*g .. %.*g by %.*g; set too large", 15, t0, 15,
                   tf, 15, dt);
    }
  }
#line 1091
  return ((int )(temp + 0.5));
}
}
#line 1110 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_arelset_member(MPL *mpl , double t0 , double tf , double dt , int j ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1111
  if (1 <= j) {
    {
#line 1111
    tmp = _glp_mpl_arelset_size(mpl, t0, tf, dt);
    }
#line 1111
    if (j <= tmp) {
#line 1111
      tmp___0 = 1;
    } else {
      {
#line 1111
      _glp_lib_xassert("1 <= j && j <= arelset_size(mpl, t0, tf, dt)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       1111);
#line 1111
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1111
    _glp_lib_xassert("1 <= j && j <= arelset_size(mpl, t0, tf, dt)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1111);
#line 1111
    tmp___0 = 1;
    }
  }
#line 1112
  return (t0 + (double )(j - 1) * dt);
}
}
#line 1125 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_create_arelset(MPL *mpl , double t0 , double tf , double dt ) 
{ 
  ELEMSET *set___0 ;
  int j ;
  int n ;
  double tmp ;
  SYMBOL *tmp___0 ;
  TUPLE *tmp___1 ;
  TUPLE *tmp___2 ;

  {
  {
#line 1128
  set___0 = _glp_mpl_create_elemset(mpl, 1);
#line 1129
  n = _glp_mpl_arelset_size(mpl, t0, tf, dt);
#line 1130
  j = 1;
  }
  {
#line 1130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1130
    if (! (j <= n)) {
#line 1130
      goto while_break;
    }
    {
#line 1131
    tmp = _glp_mpl_arelset_member(mpl, t0, tf, dt, j);
#line 1131
    tmp___0 = _glp_mpl_create_symbol_num(mpl, tmp);
#line 1131
    tmp___1 = _glp_mpl_create_tuple(mpl);
#line 1131
    tmp___2 = _glp_mpl_expand_tuple(mpl, tmp___1, tmp___0);
#line 1131
    _glp_mpl_add_tuple(mpl, set___0, tmp___2);
#line 1130
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1144
  return (set___0);
}
}
#line 1156 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_set_union(MPL *mpl , ELEMSET *X , ELEMSET *Y ) 
{ 
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  TUPLE *tmp___6 ;
  MEMBER *tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 1162
  if ((unsigned long )X != (unsigned long )((void *)0)) {
#line 1162
    tmp = 1;
  } else {
    {
#line 1162
    _glp_lib_xassert("X != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1162);
#line 1162
    tmp = 1;
    }
  }
#line 1163
  if (X->type == 117) {
#line 1163
    tmp___0 = 1;
  } else {
    {
#line 1163
    _glp_lib_xassert("X->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1163);
#line 1163
    tmp___0 = 1;
    }
  }
#line 1164
  if (X->dim > 0) {
#line 1164
    tmp___1 = 1;
  } else {
    {
#line 1164
    _glp_lib_xassert("X->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1164);
#line 1164
    tmp___1 = 1;
    }
  }
#line 1165
  if ((unsigned long )Y != (unsigned long )((void *)0)) {
#line 1165
    tmp___2 = 1;
  } else {
    {
#line 1165
    _glp_lib_xassert("Y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1165);
#line 1165
    tmp___2 = 1;
    }
  }
#line 1166
  if (Y->type == 117) {
#line 1166
    tmp___3 = 1;
  } else {
    {
#line 1166
    _glp_lib_xassert("Y->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1166);
#line 1166
    tmp___3 = 1;
    }
  }
#line 1167
  if (Y->dim > 0) {
#line 1167
    tmp___4 = 1;
  } else {
    {
#line 1167
    _glp_lib_xassert("Y->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1167);
#line 1167
    tmp___4 = 1;
    }
  }
#line 1168
  if (X->dim == Y->dim) {
#line 1168
    tmp___5 = 1;
  } else {
    {
#line 1168
    _glp_lib_xassert("X->dim == Y->dim", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1168);
#line 1168
    tmp___5 = 1;
    }
  }
#line 1169
  memb = Y->head;
  {
#line 1169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1169
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1169
      goto while_break;
    }
    {
#line 1170
    tmp___7 = _glp_mpl_find_tuple(mpl, X, memb->tuple);
    }
#line 1170
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
      {
#line 1171
      tmp___6 = _glp_mpl_copy_tuple(mpl, memb->tuple);
#line 1171
      _glp_mpl_add_tuple(mpl, X, tmp___6);
      }
    }
#line 1169
    memb = memb->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1173
  _glp_mpl_delete_elemset(mpl, Y);
  }
#line 1174
  return (X);
}
}
#line 1186 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_set_diff(MPL *mpl , ELEMSET *X , ELEMSET *Y ) 
{ 
  ELEMSET *Z ;
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  TUPLE *tmp___6 ;
  MEMBER *tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 1193
  if ((unsigned long )X != (unsigned long )((void *)0)) {
#line 1193
    tmp = 1;
  } else {
    {
#line 1193
    _glp_lib_xassert("X != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1193);
#line 1193
    tmp = 1;
    }
  }
#line 1194
  if (X->type == 117) {
#line 1194
    tmp___0 = 1;
  } else {
    {
#line 1194
    _glp_lib_xassert("X->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1194);
#line 1194
    tmp___0 = 1;
    }
  }
#line 1195
  if (X->dim > 0) {
#line 1195
    tmp___1 = 1;
  } else {
    {
#line 1195
    _glp_lib_xassert("X->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1195);
#line 1195
    tmp___1 = 1;
    }
  }
#line 1196
  if ((unsigned long )Y != (unsigned long )((void *)0)) {
#line 1196
    tmp___2 = 1;
  } else {
    {
#line 1196
    _glp_lib_xassert("Y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1196);
#line 1196
    tmp___2 = 1;
    }
  }
#line 1197
  if (Y->type == 117) {
#line 1197
    tmp___3 = 1;
  } else {
    {
#line 1197
    _glp_lib_xassert("Y->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1197);
#line 1197
    tmp___3 = 1;
    }
  }
#line 1198
  if (Y->dim > 0) {
#line 1198
    tmp___4 = 1;
  } else {
    {
#line 1198
    _glp_lib_xassert("Y->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1198);
#line 1198
    tmp___4 = 1;
    }
  }
#line 1199
  if (X->dim == Y->dim) {
#line 1199
    tmp___5 = 1;
  } else {
    {
#line 1199
    _glp_lib_xassert("X->dim == Y->dim", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1199);
#line 1199
    tmp___5 = 1;
    }
  }
  {
#line 1200
  Z = _glp_mpl_create_elemset(mpl, X->dim);
#line 1201
  memb = X->head;
  }
  {
#line 1201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1201
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1201
      goto while_break;
    }
    {
#line 1202
    tmp___7 = _glp_mpl_find_tuple(mpl, Y, memb->tuple);
    }
#line 1202
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
      {
#line 1203
      tmp___6 = _glp_mpl_copy_tuple(mpl, memb->tuple);
#line 1203
      _glp_mpl_add_tuple(mpl, Z, tmp___6);
      }
    }
#line 1201
    memb = memb->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1205
  _glp_mpl_delete_elemset(mpl, X);
#line 1206
  _glp_mpl_delete_elemset(mpl, Y);
  }
#line 1207
  return (Z);
}
}
#line 1219 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_set_symdiff(MPL *mpl , ELEMSET *X , ELEMSET *Y ) 
{ 
  ELEMSET *Z ;
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  TUPLE *tmp___6 ;
  MEMBER *tmp___7 ;
  TUPLE *tmp___8 ;
  MEMBER *tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 1226
  if ((unsigned long )X != (unsigned long )((void *)0)) {
#line 1226
    tmp = 1;
  } else {
    {
#line 1226
    _glp_lib_xassert("X != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1226);
#line 1226
    tmp = 1;
    }
  }
#line 1227
  if (X->type == 117) {
#line 1227
    tmp___0 = 1;
  } else {
    {
#line 1227
    _glp_lib_xassert("X->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1227);
#line 1227
    tmp___0 = 1;
    }
  }
#line 1228
  if (X->dim > 0) {
#line 1228
    tmp___1 = 1;
  } else {
    {
#line 1228
    _glp_lib_xassert("X->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1228);
#line 1228
    tmp___1 = 1;
    }
  }
#line 1229
  if ((unsigned long )Y != (unsigned long )((void *)0)) {
#line 1229
    tmp___2 = 1;
  } else {
    {
#line 1229
    _glp_lib_xassert("Y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1229);
#line 1229
    tmp___2 = 1;
    }
  }
#line 1230
  if (Y->type == 117) {
#line 1230
    tmp___3 = 1;
  } else {
    {
#line 1230
    _glp_lib_xassert("Y->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1230);
#line 1230
    tmp___3 = 1;
    }
  }
#line 1231
  if (Y->dim > 0) {
#line 1231
    tmp___4 = 1;
  } else {
    {
#line 1231
    _glp_lib_xassert("Y->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1231);
#line 1231
    tmp___4 = 1;
    }
  }
#line 1232
  if (X->dim == Y->dim) {
#line 1232
    tmp___5 = 1;
  } else {
    {
#line 1232
    _glp_lib_xassert("X->dim == Y->dim", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1232);
#line 1232
    tmp___5 = 1;
    }
  }
  {
#line 1234
  Z = _glp_mpl_create_elemset(mpl, X->dim);
#line 1235
  memb = X->head;
  }
  {
#line 1235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1235
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1235
      goto while_break;
    }
    {
#line 1236
    tmp___7 = _glp_mpl_find_tuple(mpl, Y, memb->tuple);
    }
#line 1236
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
      {
#line 1237
      tmp___6 = _glp_mpl_copy_tuple(mpl, memb->tuple);
#line 1237
      _glp_mpl_add_tuple(mpl, Z, tmp___6);
      }
    }
#line 1235
    memb = memb->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1240
  memb = Y->head;
  {
#line 1240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1240
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1240
      goto while_break___0;
    }
    {
#line 1241
    tmp___9 = _glp_mpl_find_tuple(mpl, X, memb->tuple);
    }
#line 1241
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
      {
#line 1242
      tmp___8 = _glp_mpl_copy_tuple(mpl, memb->tuple);
#line 1242
      _glp_mpl_add_tuple(mpl, Z, tmp___8);
      }
    }
#line 1240
    memb = memb->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1244
  _glp_mpl_delete_elemset(mpl, X);
#line 1245
  _glp_mpl_delete_elemset(mpl, Y);
  }
#line 1246
  return (Z);
}
}
#line 1258 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_set_inter(MPL *mpl , ELEMSET *X , ELEMSET *Y ) 
{ 
  ELEMSET *Z ;
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  TUPLE *tmp___6 ;
  MEMBER *tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 1265
  if ((unsigned long )X != (unsigned long )((void *)0)) {
#line 1265
    tmp = 1;
  } else {
    {
#line 1265
    _glp_lib_xassert("X != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1265);
#line 1265
    tmp = 1;
    }
  }
#line 1266
  if (X->type == 117) {
#line 1266
    tmp___0 = 1;
  } else {
    {
#line 1266
    _glp_lib_xassert("X->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1266);
#line 1266
    tmp___0 = 1;
    }
  }
#line 1267
  if (X->dim > 0) {
#line 1267
    tmp___1 = 1;
  } else {
    {
#line 1267
    _glp_lib_xassert("X->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1267);
#line 1267
    tmp___1 = 1;
    }
  }
#line 1268
  if ((unsigned long )Y != (unsigned long )((void *)0)) {
#line 1268
    tmp___2 = 1;
  } else {
    {
#line 1268
    _glp_lib_xassert("Y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1268);
#line 1268
    tmp___2 = 1;
    }
  }
#line 1269
  if (Y->type == 117) {
#line 1269
    tmp___3 = 1;
  } else {
    {
#line 1269
    _glp_lib_xassert("Y->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1269);
#line 1269
    tmp___3 = 1;
    }
  }
#line 1270
  if (Y->dim > 0) {
#line 1270
    tmp___4 = 1;
  } else {
    {
#line 1270
    _glp_lib_xassert("Y->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1270);
#line 1270
    tmp___4 = 1;
    }
  }
#line 1271
  if (X->dim == Y->dim) {
#line 1271
    tmp___5 = 1;
  } else {
    {
#line 1271
    _glp_lib_xassert("X->dim == Y->dim", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1271);
#line 1271
    tmp___5 = 1;
    }
  }
  {
#line 1272
  Z = _glp_mpl_create_elemset(mpl, X->dim);
#line 1273
  memb = X->head;
  }
  {
#line 1273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1273
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1273
      goto while_break;
    }
    {
#line 1274
    tmp___7 = _glp_mpl_find_tuple(mpl, Y, memb->tuple);
    }
#line 1274
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      {
#line 1275
      tmp___6 = _glp_mpl_copy_tuple(mpl, memb->tuple);
#line 1275
      _glp_mpl_add_tuple(mpl, Z, tmp___6);
      }
    }
#line 1273
    memb = memb->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1277
  _glp_mpl_delete_elemset(mpl, X);
#line 1278
  _glp_mpl_delete_elemset(mpl, Y);
  }
#line 1279
  return (Z);
}
}
#line 1291 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_set_cross(MPL *mpl , ELEMSET *X , ELEMSET *Y ) 
{ 
  ELEMSET *Z ;
  MEMBER *memx ;
  MEMBER *memy ;
  TUPLE *tuple ;
  TUPLE *temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  SYMBOL *tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 1299
  if ((unsigned long )X != (unsigned long )((void *)0)) {
#line 1299
    tmp = 1;
  } else {
    {
#line 1299
    _glp_lib_xassert("X != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1299);
#line 1299
    tmp = 1;
    }
  }
#line 1300
  if (X->type == 117) {
#line 1300
    tmp___0 = 1;
  } else {
    {
#line 1300
    _glp_lib_xassert("X->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1300);
#line 1300
    tmp___0 = 1;
    }
  }
#line 1301
  if (X->dim > 0) {
#line 1301
    tmp___1 = 1;
  } else {
    {
#line 1301
    _glp_lib_xassert("X->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1301);
#line 1301
    tmp___1 = 1;
    }
  }
#line 1302
  if ((unsigned long )Y != (unsigned long )((void *)0)) {
#line 1302
    tmp___2 = 1;
  } else {
    {
#line 1302
    _glp_lib_xassert("Y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1302);
#line 1302
    tmp___2 = 1;
    }
  }
#line 1303
  if (Y->type == 117) {
#line 1303
    tmp___3 = 1;
  } else {
    {
#line 1303
    _glp_lib_xassert("Y->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1303);
#line 1303
    tmp___3 = 1;
    }
  }
#line 1304
  if (Y->dim > 0) {
#line 1304
    tmp___4 = 1;
  } else {
    {
#line 1304
    _glp_lib_xassert("Y->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1304);
#line 1304
    tmp___4 = 1;
    }
  }
  {
#line 1305
  Z = _glp_mpl_create_elemset(mpl, X->dim + Y->dim);
#line 1306
  memx = X->head;
  }
  {
#line 1306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1306
    if (! ((unsigned long )memx != (unsigned long )((void *)0))) {
#line 1306
      goto while_break;
    }
#line 1307
    memy = Y->head;
    {
#line 1307
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1307
      if (! ((unsigned long )memy != (unsigned long )((void *)0))) {
#line 1307
        goto while_break___0;
      }
      {
#line 1308
      tuple = _glp_mpl_copy_tuple(mpl, memx->tuple);
#line 1309
      temp = memy->tuple;
      }
      {
#line 1309
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1309
        if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 1309
          goto while_break___1;
        }
        {
#line 1310
        tmp___5 = _glp_mpl_copy_symbol(mpl, temp->sym);
#line 1310
        tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___5);
#line 1309
        temp = temp->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1312
      _glp_mpl_add_tuple(mpl, Z, tuple);
#line 1307
      memy = memy->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1306
    memx = memx->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1315
  _glp_mpl_delete_elemset(mpl, X);
#line 1316
  _glp_mpl_delete_elemset(mpl, Y);
  }
#line 1317
  return (Z);
}
}
#line 1335 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
FORMULA *_glp_mpl_constant_term(MPL *mpl , double coef ) 
{ 
  FORMULA *form ;
  void *tmp ;

  {
#line 1337
  if (coef == 0.0) {
#line 1338
    form = (FORMULA *)((void *)0);
  } else {
    {
#line 1340
    tmp = _glp_dmp_get_atom(mpl->formulae, (int )sizeof(FORMULA ));
#line 1340
    form = (FORMULA *)tmp;
#line 1341
    form->coef = coef;
#line 1342
    form->var = (ELEMVAR *)((void *)0);
#line 1343
    form->next = (FORMULA *)((void *)0);
    }
  }
#line 1345
  return (form);
}
}
#line 1354 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
FORMULA *_glp_mpl_single_variable(MPL *mpl , ELEMVAR *var ) 
{ 
  FORMULA *form ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1359
  if ((unsigned long )var != (unsigned long )((void *)0)) {
#line 1359
    tmp = 1;
  } else {
    {
#line 1359
    _glp_lib_xassert("var != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1359);
#line 1359
    tmp = 1;
    }
  }
  {
#line 1360
  tmp___0 = _glp_dmp_get_atom(mpl->formulae, (int )sizeof(FORMULA ));
#line 1360
  form = (FORMULA *)tmp___0;
#line 1361
  form->coef = 1.0;
#line 1362
  form->var = var;
#line 1363
  form->next = (FORMULA *)((void *)0);
  }
#line 1364
  return (form);
}
}
#line 1372 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
FORMULA *_glp_mpl_copy_formula(MPL *mpl , FORMULA *form ) 
{ 
  FORMULA *head ;
  FORMULA *tail ;
  void *tmp ;
  FORMULA *tmp___0 ;
  void *tmp___1 ;

  {
#line 1377
  if ((unsigned long )form == (unsigned long )((void *)0)) {
#line 1378
    head = (FORMULA *)((void *)0);
  } else {
    {
#line 1380
    tmp = _glp_dmp_get_atom(mpl->formulae, (int )sizeof(FORMULA ));
#line 1380
    tail = (FORMULA *)tmp;
#line 1380
    head = tail;
    }
    {
#line 1381
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1381
      if (! ((unsigned long )form != (unsigned long )((void *)0))) {
#line 1381
        goto while_break;
      }
#line 1382
      tail->coef = form->coef;
#line 1383
      tail->var = form->var;
#line 1384
      if ((unsigned long )form->next != (unsigned long )((void *)0)) {
        {
#line 1385
        tmp___1 = _glp_dmp_get_atom(mpl->formulae, (int )sizeof(FORMULA ));
#line 1385
        tmp___0 = (FORMULA *)tmp___1;
#line 1385
        tail->next = tmp___0;
#line 1385
        tail = tmp___0;
        }
      }
#line 1381
      form = form->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1387
    tail->next = (FORMULA *)((void *)0);
  }
#line 1389
  return (head);
}
}
#line 1397 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_delete_formula(MPL *mpl , FORMULA *form ) 
{ 
  FORMULA *temp ;

  {
  {
#line 1402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1402
    if (! ((unsigned long )form != (unsigned long )((void *)0))) {
#line 1402
      goto while_break;
    }
    {
#line 1403
    temp = form;
#line 1404
    form = form->next;
#line 1405
    _glp_dmp_free_atom(mpl->formulae, (void *)temp, (int )sizeof(FORMULA ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1407
  return;
}
}
#line 1420 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
FORMULA *_glp_mpl_linear_comb(MPL *mpl , double a , FORMULA *fx , double b , FORMULA *fy ) 
{ 
  FORMULA *form ;
  FORMULA *term ;
  FORMULA *temp ;
  double c0 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 1425
  form = (FORMULA *)((void *)0);
#line 1426
  c0 = 0.0;
#line 1427
  term = fx;
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1427
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 1427
      goto while_break;
    }
#line 1428
    if ((unsigned long )term->var == (unsigned long )((void *)0)) {
      {
#line 1429
      tmp = _glp_mpl_fp_mul(mpl, a, term->coef);
#line 1429
      c0 = _glp_mpl_fp_add(mpl, c0, tmp);
      }
    } else {
      {
#line 1431
      tmp___0 = _glp_mpl_fp_mul(mpl, a, term->coef);
#line 1431
      (term->var)->temp = _glp_mpl_fp_add(mpl, (term->var)->temp, tmp___0);
      }
    }
#line 1427
    term = term->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1434
  term = fy;
  {
#line 1434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1434
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 1434
      goto while_break___0;
    }
#line 1435
    if ((unsigned long )term->var == (unsigned long )((void *)0)) {
      {
#line 1436
      tmp___1 = _glp_mpl_fp_mul(mpl, b, term->coef);
#line 1436
      c0 = _glp_mpl_fp_add(mpl, c0, tmp___1);
      }
    } else {
      {
#line 1438
      tmp___2 = _glp_mpl_fp_mul(mpl, b, term->coef);
#line 1438
      (term->var)->temp = _glp_mpl_fp_add(mpl, (term->var)->temp, tmp___2);
      }
    }
#line 1434
    term = term->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1441
  term = fx;
  {
#line 1441
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1441
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 1441
      goto while_break___1;
    }
#line 1442
    if ((unsigned long )term->var != (unsigned long )((void *)0)) {
#line 1442
      if ((term->var)->temp != 0.0) {
        {
#line 1443
        tmp___3 = _glp_dmp_get_atom(mpl->formulae, (int )sizeof(FORMULA ));
#line 1443
        temp = (FORMULA *)tmp___3;
#line 1444
        temp->coef = (term->var)->temp;
#line 1444
        temp->var = term->var;
#line 1445
        temp->next = form;
#line 1445
        form = temp;
#line 1446
        (term->var)->temp = 0.0;
        }
      }
    }
#line 1441
    term = term->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1449
  term = fy;
  {
#line 1449
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1449
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 1449
      goto while_break___2;
    }
#line 1450
    if ((unsigned long )term->var != (unsigned long )((void *)0)) {
#line 1450
      if ((term->var)->temp != 0.0) {
        {
#line 1451
        tmp___4 = _glp_dmp_get_atom(mpl->formulae, (int )sizeof(FORMULA ));
#line 1451
        temp = (FORMULA *)tmp___4;
#line 1452
        temp->coef = (term->var)->temp;
#line 1452
        temp->var = term->var;
#line 1453
        temp->next = form;
#line 1453
        form = temp;
#line 1454
        (term->var)->temp = 0.0;
        }
      }
    }
#line 1449
    term = term->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1457
  if (c0 != 0.0) {
    {
#line 1458
    tmp___5 = _glp_dmp_get_atom(mpl->formulae, (int )sizeof(FORMULA ));
#line 1458
    temp = (FORMULA *)tmp___5;
#line 1459
    temp->coef = c0;
#line 1459
    temp->var = (ELEMVAR *)((void *)0);
#line 1460
    temp->next = form;
#line 1460
    form = temp;
    }
  }
  {
#line 1462
  _glp_mpl_delete_formula(mpl, fx);
#line 1463
  _glp_mpl_delete_formula(mpl, fy);
  }
#line 1464
  return (form);
}
}
#line 1473 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
FORMULA *_glp_mpl_remove_constant(MPL *mpl , FORMULA *form , double *coef ) 
{ 
  FORMULA *head ;
  FORMULA *temp ;

  {
#line 1478
  head = (FORMULA *)((void *)0);
#line 1479
  *coef = 0.0;
  {
#line 1480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1480
    if (! ((unsigned long )form != (unsigned long )((void *)0))) {
#line 1480
      goto while_break;
    }
#line 1481
    temp = form;
#line 1482
    form = form->next;
#line 1483
    if ((unsigned long )temp->var == (unsigned long )((void *)0)) {
      {
#line 1485
      *coef = _glp_mpl_fp_add(mpl, *coef, temp->coef);
#line 1486
      _glp_dmp_free_atom(mpl->formulae, (void *)temp, (int )sizeof(FORMULA ));
      }
    } else {
#line 1490
      temp->next = head;
#line 1491
      head = temp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  return (head);
}
}
#line 1502 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
FORMULA *_glp_mpl_reduce_terms(MPL *mpl , FORMULA *form ) 
{ 
  FORMULA *term ;
  FORMULA *next_term ;
  double c0 ;

  {
#line 1507
  c0 = 0.0;
#line 1508
  term = form;
  {
#line 1508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1508
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 1508
      goto while_break;
    }
#line 1509
    if ((unsigned long )term->var == (unsigned long )((void *)0)) {
      {
#line 1510
      c0 = _glp_mpl_fp_add(mpl, c0, term->coef);
      }
    } else {
      {
#line 1512
      (term->var)->temp = _glp_mpl_fp_add(mpl, (term->var)->temp, term->coef);
      }
    }
#line 1508
    term = term->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1514
  next_term = form;
#line 1514
  form = (FORMULA *)((void *)0);
#line 1515
  term = next_term;
  {
#line 1515
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1515
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 1515
      goto while_break___0;
    }
#line 1516
    next_term = term->next;
#line 1517
    if ((unsigned long )term->var == (unsigned long )((void *)0)) {
#line 1517
      if (c0 != 0.0) {
#line 1518
        term->coef = c0;
#line 1518
        c0 = 0.0;
#line 1519
        term->next = form;
#line 1519
        form = term;
      } else {
#line 1517
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1521
    if ((unsigned long )term->var != (unsigned long )((void *)0)) {
#line 1521
      if ((term->var)->temp != 0.0) {
#line 1522
        term->coef = (term->var)->temp;
#line 1522
        (term->var)->temp = 0.0;
#line 1523
        term->next = form;
#line 1523
        form = term;
      } else {
        {
#line 1526
        _glp_dmp_free_atom(mpl->formulae, (void *)term, (int )sizeof(FORMULA ));
        }
      }
    } else {
      {
#line 1526
      _glp_dmp_free_atom(mpl->formulae, (void *)term, (int )sizeof(FORMULA ));
      }
    }
#line 1515
    term = next_term;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1528
  return (form);
}
}
#line 1548 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_delete_value(MPL *mpl , int type , VALUE *value ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1553
  if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 1553
    tmp = 1;
  } else {
    {
#line 1553
    _glp_lib_xassert("value != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1553);
#line 1553
    tmp = 1;
    }
  }
  {
#line 1555
  if (type == 117) {
#line 1555
    goto case_117;
  }
#line 1558
  if (type == 118) {
#line 1558
    goto case_118;
  }
#line 1561
  if (type == 124) {
#line 1561
    goto case_124;
  }
#line 1564
  if (type == 114) {
#line 1564
    goto case_114;
  }
#line 1567
  if (type == 126) {
#line 1567
    goto case_126;
  }
#line 1570
  if (type == 106) {
#line 1570
    goto case_106;
  }
#line 1573
  if (type == 107) {
#line 1573
    goto case_107;
  }
#line 1576
  if (type == 110) {
#line 1576
    goto case_110;
  }
#line 1579
  if (type == 105) {
#line 1579
    goto case_105;
  }
#line 1582
  goto switch_default;
  case_117: /* CIL Label */ 
#line 1556
  value->none = (void *)0;
#line 1557
  goto switch_break;
  case_118: /* CIL Label */ 
#line 1559
  value->num = 0.0;
#line 1560
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 1562
  _glp_mpl_delete_symbol(mpl, value->sym);
#line 1562
  value->sym = (SYMBOL *)((void *)0);
  }
#line 1563
  goto switch_break;
  case_114: /* CIL Label */ 
#line 1565
  value->bit = 0;
#line 1566
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 1568
  _glp_mpl_delete_tuple(mpl, value->tuple);
#line 1568
  value->tuple = (TUPLE *)((void *)0);
  }
#line 1569
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 1571
  _glp_mpl_delete_elemset(mpl, value->set);
#line 1571
  value->set = (ELEMSET *)((void *)0);
  }
#line 1572
  goto switch_break;
  case_107: /* CIL Label */ 
#line 1574
  value->var = (ELEMVAR *)((void *)0);
#line 1575
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 1577
  _glp_mpl_delete_formula(mpl, value->form);
#line 1577
  value->form = (FORMULA *)((void *)0);
  }
#line 1578
  goto switch_break;
  case_105: /* CIL Label */ 
#line 1580
  value->con = (ELEMCON *)((void *)0);
#line 1581
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1583
  if (type != type) {
#line 1583
    tmp___0 = 1;
  } else {
    {
#line 1583
    _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1583);
#line 1583
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1585
  return;
}
}
#line 1611 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ARRAY *_glp_mpl_create_array(MPL *mpl , int type , int dim ) 
{ 
  ARRAY *array ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1613
  if (type == 117) {
#line 1613
    tmp = 1;
  } else
#line 1613
  if (type == 118) {
#line 1613
    tmp = 1;
  } else
#line 1613
  if (type == 124) {
#line 1613
    tmp = 1;
  } else
#line 1613
  if (type == 106) {
#line 1613
    tmp = 1;
  } else
#line 1613
  if (type == 107) {
#line 1613
    tmp = 1;
  } else
#line 1613
  if (type == 105) {
#line 1613
    tmp = 1;
  } else {
    {
#line 1613
    _glp_lib_xassert("type == A_NONE || type == A_NUMERIC || type == A_SYMBOLIC || type == A_ELEMSET || type == A_ELEMVAR || type == A_ELEMCON",
                     "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c", 1615);
#line 1613
    tmp = 1;
    }
  }
#line 1616
  if (dim >= 0) {
#line 1616
    tmp___0 = 1;
  } else {
    {
#line 1616
    _glp_lib_xassert("dim >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1616);
#line 1616
    tmp___0 = 1;
    }
  }
  {
#line 1617
  tmp___1 = _glp_dmp_get_atom(mpl->arrays, (int )sizeof(ARRAY ));
#line 1617
  array = (ARRAY *)tmp___1;
#line 1618
  array->type = type;
#line 1619
  array->dim = dim;
#line 1620
  array->size = 0;
#line 1621
  array->head = (MEMBER *)((void *)0);
#line 1622
  array->tail = (MEMBER *)((void *)0);
#line 1623
  array->tree = (AVL *)((void *)0);
#line 1624
  array->prev = (ARRAY *)((void *)0);
#line 1625
  array->next = mpl->a_list;
  }
#line 1627
  if ((unsigned long )array->next != (unsigned long )((void *)0)) {
#line 1627
    (array->next)->prev = array;
  }
#line 1628
  mpl->a_list = array;
#line 1629
  return (array);
}
}
#line 1640 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int compare_member_tuples(void *info , void const   *key1 , void const   *key2 ) 
{ 
  int tmp ;

  {
  {
#line 1644
  tmp = _glp_mpl_compare_tuples((MPL *)info, (TUPLE *)key1, (TUPLE *)key2);
  }
#line 1644
  return (tmp);
}
}
#line 1647 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
MEMBER *_glp_mpl_find_member(MPL *mpl , ARRAY *array , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  AVLNODE *tmp___2 ;
  int tmp___3 ;
  AVLNODE *node ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1653
  if ((unsigned long )array != (unsigned long )((void *)0)) {
#line 1653
    tmp = 1;
  } else {
    {
#line 1653
    _glp_lib_xassert("array != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1653);
#line 1653
    tmp = 1;
    }
  }
  {
#line 1655
  tmp___0 = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 1655
  if (tmp___0 == array->dim) {
#line 1655
    tmp___1 = 1;
  } else {
    {
#line 1655
    _glp_lib_xassert("tuple_dimen(mpl, tuple) == array->dim", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1655);
#line 1655
    tmp___1 = 1;
    }
  }
#line 1658
  if (array->size > 30) {
#line 1658
    if ((unsigned long )array->tree == (unsigned long )((void *)0)) {
      {
#line 1659
      array->tree = _glp_avl_create_tree(& compare_member_tuples, (void *)mpl);
#line 1660
      memb = array->head;
      }
      {
#line 1660
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1660
        if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1660
          goto while_break;
        }
        {
#line 1661
        tmp___2 = _glp_avl_insert_node(array->tree, (void const   *)memb->tuple);
#line 1661
        _glp_avl_set_node_link(tmp___2, (void *)memb);
#line 1660
        memb = memb->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1665
  if ((unsigned long )array->tree == (unsigned long )((void *)0)) {
#line 1667
    memb = array->head;
    {
#line 1667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1667
      if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 1667
        goto while_break___0;
      }
      {
#line 1668
      tmp___3 = _glp_mpl_compare_tuples(mpl, memb->tuple, tuple);
      }
#line 1668
      if (tmp___3 == 0) {
#line 1668
        goto while_break___0;
      }
#line 1667
      memb = memb->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1673
    node = _glp_avl_find_node(array->tree, (void const   *)tuple);
    }
#line 1674
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1674
      tmp___5 = (void *)0;
    } else {
      {
#line 1674
      tmp___4 = _glp_avl_get_node_link(node);
#line 1674
      tmp___5 = tmp___4;
      }
    }
#line 1674
    memb = (MEMBER *)tmp___5;
  }
#line 1676
  return (memb);
}
}
#line 1694 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
MEMBER *_glp_mpl_add_member(MPL *mpl , ARRAY *array , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  AVLNODE *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1700
  if ((unsigned long )array != (unsigned long )((void *)0)) {
#line 1700
    tmp = 1;
  } else {
    {
#line 1700
    _glp_lib_xassert("array != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1700);
#line 1700
    tmp = 1;
    }
  }
  {
#line 1702
  tmp___0 = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 1702
  if (tmp___0 == array->dim) {
#line 1702
    tmp___1 = 1;
  } else {
    {
#line 1702
    _glp_lib_xassert("tuple_dimen(mpl, tuple) == array->dim", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1702);
#line 1702
    tmp___1 = 1;
    }
  }
  {
#line 1704
  tmp___2 = _glp_dmp_get_atom(mpl->members, (int )sizeof(MEMBER ));
#line 1704
  memb = (MEMBER *)tmp___2;
#line 1705
  memb->tuple = tuple;
#line 1706
  memb->next = (MEMBER *)((void *)0);
#line 1707
  memset((void *)(& memb->value), '?', (size_t )sizeof(VALUE ));
#line 1709
  (array->size) ++;
  }
#line 1710
  if ((unsigned long )array->head == (unsigned long )((void *)0)) {
#line 1711
    array->head = memb;
  } else {
#line 1713
    (array->tail)->next = memb;
  }
#line 1714
  array->tail = memb;
#line 1716
  if ((unsigned long )array->tree != (unsigned long )((void *)0)) {
    {
#line 1717
    tmp___3 = _glp_avl_insert_node(array->tree, (void const   *)memb->tuple);
#line 1717
    _glp_avl_set_node_link(tmp___3, (void *)memb);
    }
  }
#line 1719
  return (memb);
}
}
#line 1731 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_delete_array(MPL *mpl , ARRAY *array ) 
{ 
  MEMBER *memb ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1736
  if ((unsigned long )array != (unsigned long )((void *)0)) {
#line 1736
    tmp = 1;
  } else {
    {
#line 1736
    _glp_lib_xassert("array != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1736);
#line 1736
    tmp = 1;
    }
  }
  {
#line 1738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1738
    if (! ((unsigned long )array->head != (unsigned long )((void *)0))) {
#line 1738
      goto while_break;
    }
    {
#line 1739
    memb = array->head;
#line 1740
    array->head = memb->next;
#line 1741
    _glp_mpl_delete_tuple(mpl, memb->tuple);
#line 1742
    _glp_dmp_free_atom(mpl->members, (void *)memb, (int )sizeof(MEMBER ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1745
  if ((unsigned long )array->tree != (unsigned long )((void *)0)) {
    {
#line 1745
    _glp_avl_delete_tree(array->tree);
    }
  }
#line 1747
  if ((unsigned long )array->prev == (unsigned long )((void *)0)) {
#line 1748
    mpl->a_list = array->next;
  } else {
#line 1750
    (array->prev)->next = array->next;
  }
#line 1751
  if (! ((unsigned long )array->next == (unsigned long )((void *)0))) {
#line 1754
    (array->next)->prev = array->prev;
  }
  {
#line 1756
  _glp_dmp_free_atom(mpl->arrays, (void *)array, (int )sizeof(ARRAY ));
  }
#line 1757
  return;
}
}
#line 1771 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_assign_dummy_index(MPL *mpl , DOMAIN_SLOT *slot , SYMBOL *value ) 
{ 
  CODE *leaf ;
  CODE *code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1777
  if ((unsigned long )slot != (unsigned long )((void *)0)) {
#line 1777
    tmp = 1;
  } else {
    {
#line 1777
    _glp_lib_xassert("slot != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1777);
#line 1777
    tmp = 1;
    }
  }
#line 1778
  if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 1778
    tmp___0 = 1;
  } else {
    {
#line 1778
    _glp_lib_xassert("value != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1778);
#line 1778
    tmp___0 = 1;
    }
  }
#line 1780
  if ((unsigned long )slot->value != (unsigned long )((void *)0)) {
    {
#line 1783
    tmp___1 = _glp_mpl_compare_symbols(mpl, slot->value, value);
    }
#line 1783
    if (tmp___1 == 0) {
#line 1783
      goto done;
    }
    {
#line 1785
    _glp_mpl_delete_symbol(mpl, slot->value);
#line 1785
    slot->value = (SYMBOL *)((void *)0);
    }
  }
#line 1790
  leaf = slot->list;
  {
#line 1790
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1790
    if (! ((unsigned long )leaf != (unsigned long )((void *)0))) {
#line 1790
      goto while_break;
    }
#line 1792
    if (leaf->op == 303) {
#line 1792
      tmp___2 = 1;
    } else {
      {
#line 1792
      _glp_lib_xassert("leaf->op == O_INDEX", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       1792);
#line 1792
      tmp___2 = 1;
      }
    }
#line 1796
    code = leaf;
    {
#line 1796
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1796
      if (! ((unsigned long )code != (unsigned long )((void *)0))) {
#line 1796
        goto while_break___0;
      }
#line 1797
      if (code->valid) {
        {
#line 1799
        code->valid = 0;
#line 1800
        _glp_mpl_delete_value(mpl, code->type, & code->value);
        }
      }
#line 1796
      code = code->up;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1790
    leaf = leaf->arg.index.next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1805
  slot->value = _glp_mpl_copy_symbol(mpl, value);
  }
  done: 
#line 1806
  return;
}
}
#line 1816 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_update_dummy_indices(MPL *mpl , DOMAIN_BLOCK *block ) 
{ 
  DOMAIN_SLOT *slot ;
  TUPLE *temp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1822
  if ((unsigned long )block->backup != (unsigned long )((void *)0)) {
#line 1823
    slot = block->list;
#line 1823
    temp = block->backup;
    {
#line 1823
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1823
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1823
        goto while_break;
      }
#line 1825
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
#line 1825
        tmp = 1;
      } else {
        {
#line 1825
        _glp_lib_xassert("temp != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         1825);
#line 1825
        tmp = 1;
        }
      }
#line 1826
      if ((unsigned long )temp->sym != (unsigned long )((void *)0)) {
#line 1826
        tmp___0 = 1;
      } else {
        {
#line 1826
        _glp_lib_xassert("temp->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         1826);
#line 1826
        tmp___0 = 1;
        }
      }
      {
#line 1827
      _glp_mpl_assign_dummy_index(mpl, slot, temp->sym);
#line 1823
      slot = slot->next;
#line 1823
      temp = temp->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1830
  return;
}
}
#line 1865 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_enter_domain_block(MPL *mpl , DOMAIN_BLOCK *block , TUPLE *tuple , void *info ,
                                void (*func___0)(MPL *mpl , void *info ) ) 
{ 
  TUPLE *backup ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1872
  ret = 0;
#line 1874
  if ((unsigned long )block->code != (unsigned long )((void *)0)) {
#line 1874
    tmp = 1;
  } else {
    {
#line 1874
    _glp_lib_xassert("block->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     1874);
#line 1874
    tmp = 1;
    }
  }
  {
#line 1875
  tmp___0 = _glp_mpl_is_member(mpl, block->code, tuple);
  }
#line 1875
  if (! tmp___0) {
#line 1876
    ret = 1;
#line 1877
    goto done;
  }
  {
#line 1884
  backup = block->backup;
#line 1887
  block->backup = tuple;
#line 1889
  _glp_mpl_update_dummy_indices(mpl, block);
#line 1891
  (*func___0)(mpl, info);
#line 1893
  block->backup = backup;
#line 1902
  _glp_mpl_update_dummy_indices(mpl, block);
  }
  done: 
#line 1903
  return (ret);
}
}
#line 1951 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void eval_domain_func(MPL *mpl , void *_my_info ) 
{ 
  struct eval_domain_info *my_info ;
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;
  TUPLE *tuple ;
  TUPLE *temp ;
  void *tmp ;
  TUPLE *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1954
  my_info = (struct eval_domain_info *)_my_info;
#line 1955
  if ((unsigned long )my_info->block != (unsigned long )((void *)0)) {
#line 1959
    tuple = (TUPLE *)((void *)0);
#line 1959
    temp = (TUPLE *)((void *)0);
#line 1961
    block = my_info->block;
#line 1963
    my_info->block = block->next;
#line 1971
    slot = block->list;
    {
#line 1971
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1971
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1971
        goto while_break;
      }
#line 1973
      if ((unsigned long )tuple == (unsigned long )((void *)0)) {
        {
#line 1974
        tmp = _glp_dmp_get_atom(mpl->tuples, (int )sizeof(TUPLE ));
#line 1974
        temp = (TUPLE *)tmp;
#line 1974
        tuple = temp;
        }
      } else {
        {
#line 1976
        tmp___1 = _glp_dmp_get_atom(mpl->tuples, (int )sizeof(TUPLE ));
#line 1976
        tmp___0 = (TUPLE *)tmp___1;
#line 1976
        temp->next = tmp___0;
#line 1976
        temp = tmp___0;
        }
      }
#line 1977
      if ((unsigned long )slot->code == (unsigned long )((void *)0)) {
#line 1981
        if ((unsigned long )my_info->tuple != (unsigned long )((void *)0)) {
#line 1981
          tmp___2 = 1;
        } else {
          {
#line 1981
          _glp_lib_xassert("my_info->tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           1981);
#line 1981
          tmp___2 = 1;
          }
        }
#line 1982
        temp->sym = (my_info->tuple)->sym;
#line 1983
        if ((unsigned long )temp->sym != (unsigned long )((void *)0)) {
#line 1983
          tmp___3 = 1;
        } else {
          {
#line 1983
          _glp_lib_xassert("temp->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           1983);
#line 1983
          tmp___3 = 1;
          }
        }
#line 1984
        my_info->tuple = (my_info->tuple)->next;
      } else {
        {
#line 1989
        temp->sym = _glp_mpl_eval_symbolic(mpl, slot->code);
        }
      }
#line 1971
      slot = slot->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1992
    temp->next = (TUPLE *)((void *)0);
#line 1994
    tmp___4 = _glp_mpl_enter_domain_block(mpl, block, tuple, (void *)my_info, & eval_domain_func);
    }
#line 1994
    if (tmp___4) {
#line 1995
      my_info->failure = 1;
    }
#line 1998
    slot = block->list;
    {
#line 1998
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1998
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1998
        goto while_break___0;
      }
#line 1999
      if ((unsigned long )tuple != (unsigned long )((void *)0)) {
#line 1999
        tmp___5 = 1;
      } else {
        {
#line 1999
        _glp_lib_xassert("tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         1999);
#line 1999
        tmp___5 = 1;
        }
      }
#line 2000
      temp = tuple;
#line 2001
      tuple = tuple->next;
#line 2002
      if ((unsigned long )slot->code != (unsigned long )((void *)0)) {
        {
#line 2004
        _glp_mpl_delete_symbol(mpl, temp->sym);
        }
      }
      {
#line 2007
      _glp_dmp_free_atom(mpl->tuples, (void *)temp, (int )sizeof(TUPLE ));
#line 1998
      slot = slot->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 2013
    if ((unsigned long )my_info->tuple == (unsigned long )((void *)0)) {
#line 2013
      tmp___6 = 1;
    } else {
      {
#line 2013
      _glp_lib_xassert("my_info->tuple == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2013);
#line 2013
      tmp___6 = 1;
      }
    }
#line 2015
    if ((unsigned long )(my_info->domain)->code != (unsigned long )((void *)0)) {
      {
#line 2015
      tmp___7 = _glp_mpl_eval_logical(mpl, (my_info->domain)->code);
      }
#line 2015
      if (tmp___7) {
        {
#line 2022
        (*(my_info->func))(mpl, my_info->info);
        }
      } else {
#line 2018
        my_info->failure = 2;
      }
    } else {
      {
#line 2022
      (*(my_info->func))(mpl, my_info->info);
      }
    }
  }
#line 2025
  return;
}
}
#line 2028 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_eval_within_domain(MPL *mpl , DOMAIN1 *domain , TUPLE *tuple , void *info ,
                                void (*func___0)(MPL *mpl , void *info ) ) 
{ 
  struct eval_domain_info _my_info ;
  struct eval_domain_info *my_info ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 2035
  my_info = & _my_info;
#line 2036
  if ((unsigned long )domain == (unsigned long )((void *)0)) {
#line 2037
    if ((unsigned long )tuple == (unsigned long )((void *)0)) {
#line 2037
      tmp = 1;
    } else {
      {
#line 2037
      _glp_lib_xassert("tuple == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2037);
#line 2037
      tmp = 1;
      }
    }
    {
#line 2038
    (*func___0)(mpl, info);
#line 2039
    my_info->failure = 0;
    }
  } else {
#line 2042
    if ((unsigned long )tuple != (unsigned long )((void *)0)) {
#line 2042
      tmp___0 = 1;
    } else {
      {
#line 2042
      _glp_lib_xassert("tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2042);
#line 2042
      tmp___0 = 1;
      }
    }
    {
#line 2043
    my_info->domain = domain;
#line 2044
    my_info->block = domain->list;
#line 2045
    my_info->tuple = tuple;
#line 2046
    my_info->info = info;
#line 2047
    my_info->func = func___0;
#line 2048
    my_info->failure = 0;
#line 2050
    eval_domain_func(mpl, (void *)my_info);
    }
  }
#line 2052
  return (my_info->failure);
}
}
#line 2087 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void loop_domain_func(MPL *mpl , void *_my_info ) 
{ 
  struct loop_domain_info *my_info ;
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;
  TUPLE *bound ;
  SYMBOL *tmp ;
  int tmp___0 ;
  TUPLE *tuple ;
  int n ;
  int j ;
  double t0 ;
  double tf ;
  double dt ;
  SYMBOL *tmp___1 ;
  TUPLE *tmp___2 ;
  int tmp___3 ;
  ELEMSET *set___0 ;
  MEMBER *memb ;
  TUPLE *temp1 ;
  TUPLE *temp2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 2091
  my_info = (struct loop_domain_info *)_my_info;
#line 2092
  if ((unsigned long )my_info->block != (unsigned long )((void *)0)) {
    {
#line 2098
    block = my_info->block;
#line 2100
    my_info->block = block->next;
#line 2105
    bound = _glp_mpl_create_tuple(mpl);
#line 2106
    slot = block->list;
    }
    {
#line 2106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2106
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 2106
        goto while_break;
      }
#line 2107
      if ((unsigned long )slot->code != (unsigned long )((void *)0)) {
        {
#line 2108
        tmp = _glp_mpl_eval_symbolic(mpl, slot->code);
#line 2108
        bound = _glp_mpl_expand_tuple(mpl, bound, tmp);
        }
      }
#line 2106
      slot = slot->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2112
    if ((unsigned long )block->code != (unsigned long )((void *)0)) {
#line 2112
      tmp___0 = 1;
    } else {
      {
#line 2112
      _glp_lib_xassert("block->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2112);
#line 2112
      tmp___0 = 1;
      }
    }
#line 2113
    if ((block->code)->op == 371) {
      {
#line 2120
      t0 = _glp_mpl_eval_numeric(mpl, (block->code)->arg.arg.x);
#line 2121
      tf = _glp_mpl_eval_numeric(mpl, (block->code)->arg.arg.y);
      }
#line 2122
      if ((unsigned long )(block->code)->arg.arg.z == (unsigned long )((void *)0)) {
#line 2123
        dt = 1.0;
      } else {
        {
#line 2125
        dt = _glp_mpl_eval_numeric(mpl, (block->code)->arg.arg.z);
        }
      }
      {
#line 2127
      n = _glp_mpl_arelset_size(mpl, t0, tf, dt);
#line 2129
      tmp___1 = _glp_mpl_create_symbol_num(mpl, 0.0);
#line 2129
      tmp___2 = _glp_mpl_create_tuple(mpl);
#line 2129
      tuple = _glp_mpl_expand_tuple(mpl, tmp___2, tmp___1);
      }
#line 2133
      if ((unsigned long )bound == (unsigned long )((void *)0)) {
#line 2133
        tmp___3 = 1;
      } else {
        {
#line 2133
        _glp_lib_xassert("bound == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2133);
#line 2133
        tmp___3 = 1;
        }
      }
#line 2135
      j = 1;
      {
#line 2135
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2135
        if (j <= n) {
#line 2135
          if (! my_info->looping) {
#line 2135
            goto while_break___0;
          }
        } else {
#line 2135
          goto while_break___0;
        }
        {
#line 2137
        (tuple->sym)->num = _glp_mpl_arelset_member(mpl, t0, tf, dt, j);
#line 2139
        _glp_mpl_enter_domain_block(mpl, block, tuple, (void *)my_info, & loop_domain_func);
#line 2135
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2143
      _glp_mpl_delete_tuple(mpl, tuple);
      }
    } else {
      {
#line 2152
      set___0 = _glp_mpl_eval_elemset(mpl, block->code);
#line 2154
      memb = set___0->head;
      }
      {
#line 2154
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2154
        if ((unsigned long )memb != (unsigned long )((void *)0)) {
#line 2154
          if (! my_info->looping) {
#line 2154
            goto while_break___1;
          }
        } else {
#line 2154
          goto while_break___1;
        }
#line 2159
        temp1 = memb->tuple;
#line 2160
        temp2 = bound;
#line 2161
        slot = block->list;
        {
#line 2161
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2161
          if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 2161
            goto while_break___2;
          }
#line 2162
          if ((unsigned long )temp1 != (unsigned long )((void *)0)) {
#line 2162
            tmp___4 = 1;
          } else {
            {
#line 2162
            _glp_lib_xassert("temp1 != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                             2162);
#line 2162
            tmp___4 = 1;
            }
          }
#line 2163
          if ((unsigned long )slot->code != (unsigned long )((void *)0)) {
#line 2165
            if ((unsigned long )temp2 != (unsigned long )((void *)0)) {
#line 2165
              tmp___5 = 1;
            } else {
              {
#line 2165
              _glp_lib_xassert("temp2 != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                               2165);
#line 2165
              tmp___5 = 1;
              }
            }
            {
#line 2166
            tmp___6 = _glp_mpl_compare_symbols(mpl, temp1->sym, temp2->sym);
            }
#line 2166
            if (tmp___6 != 0) {
#line 2169
              goto skip;
            }
#line 2171
            temp2 = temp2->next;
          }
#line 2173
          temp1 = temp1->next;
#line 2161
          slot = slot->next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2175
        if ((unsigned long )temp1 == (unsigned long )((void *)0)) {
#line 2175
          tmp___7 = 1;
        } else {
          {
#line 2175
          _glp_lib_xassert("temp1 == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           2175);
#line 2175
          tmp___7 = 1;
          }
        }
#line 2176
        if ((unsigned long )temp2 == (unsigned long )((void *)0)) {
#line 2176
          tmp___8 = 1;
        } else {
          {
#line 2176
          _glp_lib_xassert("temp2 == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           2176);
#line 2176
          tmp___8 = 1;
          }
        }
        {
#line 2178
        _glp_mpl_enter_domain_block(mpl, block, memb->tuple, (void *)my_info, & loop_domain_func);
        }
        skip: 
#line 2154
        memb = memb->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2183
      _glp_mpl_delete_elemset(mpl, set___0);
      }
    }
    {
#line 2186
    _glp_mpl_delete_tuple(mpl, bound);
#line 2188
    my_info->block = block;
    }
  } else
#line 2194
  if ((unsigned long )(my_info->domain)->code != (unsigned long )((void *)0)) {
    {
#line 2194
    tmp___11 = _glp_mpl_eval_logical(mpl, (my_info->domain)->code);
    }
#line 2194
    if (tmp___11) {
#line 2194
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2201
    tmp___9 = (*(my_info->func))(mpl, my_info->info);
    }
#line 2201
    if (tmp___9) {
#line 2201
      tmp___10 = 0;
    } else {
#line 2201
      tmp___10 = 1;
    }
#line 2201
    my_info->looping = tmp___10;
  }
#line 2204
  return;
}
}
#line 2207 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_loop_within_domain(MPL *mpl , DOMAIN1 *domain , void *info , int (*func___0)(MPL *mpl ,
                                                                                           void *info ) ) 
{ 
  struct loop_domain_info _my_info ;
  struct loop_domain_info *my_info ;

  {
#line 2213
  my_info = & _my_info;
#line 2214
  if ((unsigned long )domain == (unsigned long )((void *)0)) {
    {
#line 2215
    (*func___0)(mpl, info);
    }
  } else {
    {
#line 2217
    my_info->domain = domain;
#line 2218
    my_info->block = domain->list;
#line 2219
    my_info->looping = 1;
#line 2220
    my_info->info = info;
#line 2221
    my_info->func = func___0;
#line 2223
    loop_domain_func(mpl, (void *)my_info);
    }
  }
#line 2225
  return;
}
}
#line 2234 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_out_of_domain(MPL *mpl , char *name , TUPLE *tuple ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2239
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 2239
    tmp = 1;
  } else {
    {
#line 2239
    _glp_lib_xassert("name != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2239);
#line 2239
    tmp = 1;
    }
  }
#line 2240
  if ((unsigned long )tuple != (unsigned long )((void *)0)) {
#line 2240
    tmp___0 = 1;
  } else {
    {
#line 2240
    _glp_lib_xassert("tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2240);
#line 2240
    tmp___0 = 1;
    }
  }
  {
#line 2241
  tmp___1 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2241
  _glp_mpl_error(mpl, (char *)"%s%s out of domain", name, tmp___1);
  }
#line 2244
  return;
}
}
#line 2257 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
TUPLE *_glp_mpl_get_domain_tuple(MPL *mpl , DOMAIN1 *domain ) 
{ 
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;
  TUPLE *tuple ;
  int tmp ;
  SYMBOL *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2264
  tuple = _glp_mpl_create_tuple(mpl);
  }
#line 2265
  if ((unsigned long )domain != (unsigned long )((void *)0)) {
#line 2266
    block = domain->list;
    {
#line 2266
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2266
      if (! ((unsigned long )block != (unsigned long )((void *)0))) {
#line 2266
        goto while_break;
      }
#line 2267
      slot = block->list;
      {
#line 2267
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2267
        if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 2267
          goto while_break___0;
        }
#line 2268
        if ((unsigned long )slot->code == (unsigned long )((void *)0)) {
#line 2269
          if ((unsigned long )slot->value != (unsigned long )((void *)0)) {
#line 2269
            tmp = 1;
          } else {
            {
#line 2269
            _glp_lib_xassert("slot->value != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                             2269);
#line 2269
            tmp = 1;
            }
          }
          {
#line 2270
          tmp___0 = _glp_mpl_copy_symbol(mpl, slot->value);
#line 2270
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___0);
          }
        }
#line 2267
        slot = slot->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2266
      block = block->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2276
  return (tuple);
}
}
#line 2285 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_domain(MPL *mpl , DOMAIN1 *domain ) 
{ 
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;

  {
#line 2289
  if ((unsigned long )domain == (unsigned long )((void *)0)) {
#line 2289
    goto done;
  }
#line 2291
  block = domain->list;
  {
#line 2291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2291
    if (! ((unsigned long )block != (unsigned long )((void *)0))) {
#line 2291
      goto while_break;
    }
#line 2293
    slot = block->list;
    {
#line 2293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2293
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 2293
        goto while_break___0;
      }
      {
#line 2295
      _glp_mpl_clean_code(mpl, slot->code);
      }
#line 2297
      if ((unsigned long )slot->value != (unsigned long )((void *)0)) {
        {
#line 2298
        _glp_mpl_delete_symbol(mpl, slot->value);
#line 2298
        slot->value = (SYMBOL *)((void *)0);
        }
      }
#line 2293
      slot = slot->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2301
    _glp_mpl_clean_code(mpl, block->code);
#line 2291
    block = block->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2304
  _glp_mpl_clean_code(mpl, domain->code);
  }
  done: 
#line 2305
  return;
}
}
#line 2320 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_check_elem_set(MPL *mpl , SET *set___0 , TUPLE *tuple , ELEMSET *refer ) 
{ 
  WITHIN *within ;
  MEMBER *memb ;
  int eqno ;
  int tmp ;
  char buf[256] ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2330
  within = set___0->within;
#line 2330
  eqno = 1;
  {
#line 2330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2330
    if (! ((unsigned long )within != (unsigned long )((void *)0))) {
#line 2330
      goto while_break;
    }
#line 2332
    if ((unsigned long )within->code != (unsigned long )((void *)0)) {
#line 2332
      tmp = 1;
    } else {
      {
#line 2332
      _glp_lib_xassert("within->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2332);
#line 2332
      tmp = 1;
      }
    }
#line 2333
    memb = refer->head;
    {
#line 2333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2333
      if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 2333
        goto while_break___0;
      }
      {
#line 2334
      tmp___4 = _glp_mpl_is_member(mpl, within->code, memb->tuple);
      }
#line 2334
      if (! tmp___4) {
        {
#line 2336
        tmp___0 = _glp_mpl_format_tuple(mpl, '(', memb->tuple);
#line 2336
        strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___0);
#line 2337
        tmp___1 = strlen((char const   *)(buf));
        }
#line 2337
        if ((unsigned long )tmp___1 < sizeof(buf)) {
#line 2337
          tmp___2 = 1;
        } else {
          {
#line 2337
          _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           2337);
#line 2337
          tmp___2 = 1;
          }
        }
        {
#line 2338
        tmp___3 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2338
        _glp_mpl_error(mpl, (char *)"%s%s contains %s which not within specified set; see (%d)",
                       set___0->name, tmp___3, buf, eqno);
        }
      }
#line 2333
      memb = memb->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2330
    within = within->next;
#line 2330
    eqno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2344
  return;
}
}
#line 2355 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_take_member_set(MPL *mpl , SET *set___0 , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  ELEMSET *refer ;
  TUPLE *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 2363
  memb = _glp_mpl_find_member(mpl, set___0->array, tuple);
  }
#line 2364
  if ((unsigned long )memb != (unsigned long )((void *)0)) {
#line 2366
    refer = memb->value.set;
  } else
#line 2368
  if ((unsigned long )set___0->assign != (unsigned long )((void *)0)) {
    {
#line 2370
    refer = _glp_mpl_eval_elemset(mpl, set___0->assign);
    }
    add: 
    {
#line 2373
    _glp_mpl_check_elem_set(mpl, set___0, tuple, refer);
#line 2374
    tmp = _glp_mpl_copy_tuple(mpl, tuple);
#line 2374
    memb = _glp_mpl_add_member(mpl, set___0->array, tmp);
#line 2375
    memb->value.set = refer;
    }
  } else
#line 2377
  if ((unsigned long )set___0->option != (unsigned long )((void *)0)) {
    {
#line 2379
    refer = _glp_mpl_eval_elemset(mpl, set___0->option);
    }
#line 2380
    goto add;
  } else {
    {
#line 2384
    tmp___0 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2384
    _glp_mpl_error(mpl, (char *)"no value for %s%s", set___0->name, tmp___0);
    }
  }
#line 2387
  return (refer);
}
}
#line 2412 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void eval_set_func(MPL *mpl , void *_info ) 
{ 
  struct eval_set_info *info ;

  {
#line 2414
  info = (struct eval_set_info *)_info;
#line 2415
  if ((unsigned long )info->memb != (unsigned long )((void *)0)) {
    {
#line 2417
    _glp_mpl_check_elem_set(mpl, info->set, (info->memb)->tuple, (info->memb)->value.set);
    }
  } else {
    {
#line 2422
    info->refer = _glp_mpl_take_member_set(mpl, info->set, info->tuple);
    }
  }
#line 2424
  return;
}
}
#line 2428 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void saturate_set(MPL *mpl , SET *set___0 ) 
{ 
  GADGET *gadget ;
  ELEMSET *data ;
  MEMBER *elem ;
  MEMBER *memb ;
  TUPLE *tuple ;
  TUPLE *work[20] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 2429
  gadget = set___0->gadget;
#line 2434
  _glp_lib_xprintf("Generating %s...\n", set___0->name);
#line 2435
  _glp_mpl_eval_whole_set(mpl, gadget->set);
  }
#line 2437
  if ((unsigned long )(gadget->set)->array != (unsigned long )((void *)0)) {
#line 2437
    tmp = 1;
  } else {
    {
#line 2437
    _glp_lib_xassert("gadget->set->array != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2437);
#line 2437
    tmp = 1;
    }
  }
#line 2438
  if ((unsigned long )((gadget->set)->array)->head != (unsigned long )((void *)0)) {
#line 2438
    tmp___0 = 1;
  } else {
    {
#line 2438
    _glp_lib_xassert("gadget->set->array->head != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2438);
#line 2438
    tmp___0 = 1;
    }
  }
#line 2439
  if ((unsigned long )((gadget->set)->array)->head == (unsigned long )((gadget->set)->array)->tail) {
#line 2439
    tmp___1 = 1;
  } else {
    {
#line 2439
    _glp_lib_xassert("gadget->set->array->head == gadget->set->array->tail", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2439);
#line 2439
    tmp___1 = 1;
    }
  }
#line 2440
  data = (((gadget->set)->array)->head)->value.set;
#line 2441
  if (data->type == 117) {
#line 2441
    tmp___2 = 1;
  } else {
    {
#line 2441
    _glp_lib_xassert("data->type == A_NONE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2441);
#line 2441
    tmp___2 = 1;
    }
  }
#line 2442
  if (data->dim == (gadget->set)->dimen) {
#line 2442
    tmp___3 = 1;
  } else {
    {
#line 2442
    _glp_lib_xassert("data->dim == gadget->set->dimen", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2442);
#line 2442
    tmp___3 = 1;
    }
  }
#line 2444
  elem = data->head;
  {
#line 2444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2444
    if (! ((unsigned long )elem != (unsigned long )((void *)0))) {
#line 2444
      goto while_break;
    }
    {
#line 2446
    tuple = _glp_mpl_copy_tuple(mpl, elem->tuple);
#line 2448
    i = 0;
    }
    {
#line 2448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2448
      if (! (i < (gadget->set)->dimen)) {
#line 2448
        goto while_break___0;
      }
#line 2449
      work[i] = (TUPLE *)((void *)0);
#line 2448
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2450
    i = 0;
    {
#line 2450
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2450
      if (! ((unsigned long )tuple != (unsigned long )((void *)0))) {
#line 2450
        goto while_break___1;
      }
#line 2451
      tmp___4 = i;
#line 2451
      i ++;
#line 2451
      work[gadget->ind[tmp___4] - 1] = tuple;
#line 2450
      tuple = tuple->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2452
    if (i == (gadget->set)->dimen) {
#line 2452
      tmp___5 = 1;
    } else {
      {
#line 2452
      _glp_lib_xassert("i == gadget->set->dimen", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2452);
#line 2452
      tmp___5 = 1;
      }
    }
#line 2453
    i = 0;
    {
#line 2453
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2453
      if (! (i < (gadget->set)->dimen)) {
#line 2453
        goto while_break___2;
      }
#line 2454
      if ((unsigned long )work[i] != (unsigned long )((void *)0)) {
#line 2454
        tmp___6 = 1;
      } else {
        {
#line 2454
        _glp_lib_xassert("work[i] != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2454);
#line 2454
        tmp___6 = 1;
        }
      }
#line 2455
      (work[i])->next = work[i + 1];
#line 2453
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2458
    if (set___0->dim == 0) {
#line 2459
      tuple = (TUPLE *)((void *)0);
    } else {
#line 2461
      tuple = work[0];
#line 2461
      (work[set___0->dim - 1])->next = (TUPLE *)((void *)0);
    }
    {
#line 2463
    memb = _glp_mpl_find_member(mpl, set___0->array, tuple);
    }
#line 2464
    if ((unsigned long )memb == (unsigned long )((void *)0)) {
      {
#line 2467
      memb = _glp_mpl_add_member(mpl, set___0->array, tuple);
#line 2468
      memb->value.set = _glp_mpl_create_elemset(mpl, set___0->dimen);
      }
    } else {
      {
#line 2472
      _glp_mpl_delete_tuple(mpl, tuple);
      }
    }
#line 2475
    tuple = work[set___0->dim];
#line 2476
    if (set___0->dim + set___0->dimen == (gadget->set)->dimen) {
#line 2476
      tmp___7 = 1;
    } else {
      {
#line 2476
      _glp_lib_xassert("set->dim + set->dimen == gadget->set->dimen", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2476);
#line 2476
      tmp___7 = 1;
      }
    }
    {
#line 2477
    (work[(gadget->set)->dimen - 1])->next = (TUPLE *)((void *)0);
#line 2480
    _glp_mpl_add_tuple(mpl, memb->value.set, tuple);
#line 2444
    elem = elem->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2483
  set___0->data = 1;
#line 2484
  return;
}
}
#line 2488 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_eval_member_set(MPL *mpl , SET *set___0 , TUPLE *tuple ) 
{ 
  struct eval_set_info _info ;
  struct eval_set_info *info ;
  int tmp ;
  int tmp___0 ;
  MEMBER *tail ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 2494
  info = & _info;
#line 2495
  tmp = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 2495
  if (set___0->dim == tmp) {
#line 2495
    tmp___0 = 1;
  } else {
    {
#line 2495
    _glp_lib_xassert("set->dim == tuple_dimen(mpl, tuple)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2495);
#line 2495
    tmp___0 = 1;
    }
  }
#line 2496
  info->set = set___0;
#line 2497
  info->tuple = tuple;
#line 2499
  if ((unsigned long )set___0->gadget != (unsigned long )((void *)0)) {
#line 2499
    if (set___0->data == 0) {
      {
#line 2501
      saturate_set(mpl, set___0);
      }
    }
  }
#line 2504
  if (set___0->data == 1) {
#line 2513
    tail = (set___0->array)->tail;
#line 2516
    set___0->data = 2;
#line 2519
    info->memb = (set___0->array)->head;
    {
#line 2519
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2519
      if (! ((unsigned long )info->memb != (unsigned long )((void *)0))) {
#line 2519
        goto while_break;
      }
      {
#line 2521
      tmp___1 = _glp_mpl_eval_within_domain(mpl, set___0->domain, (info->memb)->tuple,
                                            (void *)info, & eval_set_func);
      }
#line 2521
      if (tmp___1) {
        {
#line 2523
        _glp_mpl_out_of_domain(mpl, set___0->name, (info->memb)->tuple);
        }
      }
#line 2524
      if ((unsigned long )info->memb == (unsigned long )tail) {
#line 2524
        goto while_break;
      }
#line 2519
      info->memb = (info->memb)->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2529
  info->memb = (MEMBER *)((void *)0);
#line 2530
  tmp___2 = _glp_mpl_eval_within_domain(mpl, (info->set)->domain, info->tuple, (void *)info,
                                        & eval_set_func);
  }
#line 2530
  if (tmp___2) {
    {
#line 2532
    _glp_mpl_out_of_domain(mpl, set___0->name, info->tuple);
    }
  }
#line 2534
  return (info->refer);
}
}
#line 2543 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int whole_set_func(MPL *mpl , void *info ) 
{ 
  SET *set___0 ;
  TUPLE *tuple ;
  TUPLE *tmp ;

  {
  {
#line 2545
  set___0 = (SET *)info;
#line 2546
  tmp = _glp_mpl_get_domain_tuple(mpl, set___0->domain);
#line 2546
  tuple = tmp;
#line 2547
  _glp_mpl_eval_member_set(mpl, set___0, tuple);
#line 2548
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 2549
  return (0);
}
}
#line 2552 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_eval_whole_set(MPL *mpl , SET *set___0 ) 
{ 


  {
  {
#line 2553
  _glp_mpl_loop_within_domain(mpl, set___0->domain, (void *)set___0, & whole_set_func);
  }
#line 2554
  return;
}
}
#line 2563 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_set(MPL *mpl , SET *set___0 ) 
{ 
  WITHIN *within ;
  MEMBER *memb ;

  {
  {
#line 2567
  _glp_mpl_clean_domain(mpl, set___0->domain);
#line 2569
  within = set___0->within;
  }
  {
#line 2569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2569
    if (! ((unsigned long )within != (unsigned long )((void *)0))) {
#line 2569
      goto while_break;
    }
    {
#line 2570
    _glp_mpl_clean_code(mpl, within->code);
#line 2569
    within = within->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2572
  _glp_mpl_clean_code(mpl, set___0->assign);
#line 2574
  _glp_mpl_clean_code(mpl, set___0->option);
#line 2576
  set___0->data = 0;
#line 2578
  memb = (set___0->array)->head;
  }
  {
#line 2578
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2578
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 2578
      goto while_break___0;
    }
    {
#line 2579
    _glp_mpl_delete_value(mpl, (set___0->array)->type, & memb->value);
#line 2578
    memb = memb->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2580
  _glp_mpl_delete_array(mpl, set___0->array);
#line 2580
  set___0->array = (ARRAY *)((void *)0);
  }
#line 2581
  return;
}
}
#line 2596 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_check_value_num(MPL *mpl , PARAMETER *par , TUPLE *tuple , double value ) 
{ 
  CONDITION *cond ;
  WITHIN *in ;
  int eqno ;
  char *tmp ;
  double tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  double bound ;
  char *rho ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  TUPLE *dummy ;
  int tmp___6 ;
  int tmp___7 ;
  SYMBOL *tmp___8 ;
  TUPLE *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 2607
  if (par->type == 118) {
#line 2607
    goto case_118;
  }
#line 2609
  if (par->type == 113) {
#line 2609
    goto case_113;
  }
#line 2614
  if (par->type == 101) {
#line 2614
    goto case_101;
  }
#line 2619
  goto switch_default;
  case_118: /* CIL Label */ 
#line 2608
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 2610
  tmp___0 = floor(value);
  }
#line 2610
  if (value != tmp___0) {
    {
#line 2611
    tmp = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2611
    _glp_mpl_error(mpl, (char *)"%s%s = %.*g not integer", par->name, tmp, 15, value);
    }
  }
#line 2613
  goto switch_break;
  case_101: /* CIL Label */ 
#line 2615
  if (! (value == 0.0)) {
#line 2615
    if (! (value == 1.0)) {
      {
#line 2616
      tmp___1 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2616
      _glp_mpl_error(mpl, (char *)"%s%s = %.*g not binary", par->name, tmp___1, 15,
                     value);
      }
    }
  }
#line 2618
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2620
  if ((unsigned long )par != (unsigned long )par) {
#line 2620
    tmp___2 = 1;
  } else {
    {
#line 2620
    _glp_lib_xassert("par != par", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2620);
#line 2620
    tmp___2 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 2623
  cond = par->cond;
#line 2623
  eqno = 1;
  {
#line 2623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2623
    if (! ((unsigned long )cond != (unsigned long )((void *)0))) {
#line 2623
      goto while_break;
    }
#line 2627
    if ((unsigned long )cond->code != (unsigned long )((void *)0)) {
#line 2627
      tmp___3 = 1;
    } else {
      {
#line 2627
      _glp_lib_xassert("cond->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2627);
#line 2627
      tmp___3 = 1;
      }
    }
    {
#line 2628
    bound = _glp_mpl_eval_numeric(mpl, cond->code);
    }
    {
#line 2630
    if (cond->rho == 351) {
#line 2630
      goto case_351;
    }
#line 2638
    if (cond->rho == 352) {
#line 2638
      goto case_352;
    }
#line 2641
    if (cond->rho == 353) {
#line 2641
      goto case_353;
    }
#line 2644
    if (cond->rho == 354) {
#line 2644
      goto case_354;
    }
#line 2647
    if (cond->rho == 355) {
#line 2647
      goto case_355;
    }
#line 2650
    if (cond->rho == 356) {
#line 2650
      goto case_356;
    }
#line 2653
    goto switch_default___0;
    case_351: /* CIL Label */ 
#line 2631
    if (! (value < bound)) {
#line 2632
      rho = (char *)"<";
      err: 
      {
#line 2633
      tmp___4 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2633
      _glp_mpl_error(mpl, (char *)"%s%s = %.*g not %s %.*g; see (%d)", par->name,
                     tmp___4, 15, value, rho, 15, bound, eqno);
      }
    }
#line 2637
    goto switch_break___0;
    case_352: /* CIL Label */ 
#line 2639
    if (! (value <= bound)) {
#line 2639
      rho = (char *)"<=";
#line 2639
      goto err;
    }
#line 2640
    goto switch_break___0;
    case_353: /* CIL Label */ 
#line 2642
    if (! (value == bound)) {
#line 2642
      rho = (char *)"=";
#line 2642
      goto err;
    }
#line 2643
    goto switch_break___0;
    case_354: /* CIL Label */ 
#line 2645
    if (! (value >= bound)) {
#line 2645
      rho = (char *)">=";
#line 2645
      goto err;
    }
#line 2646
    goto switch_break___0;
    case_355: /* CIL Label */ 
#line 2648
    if (! (value > bound)) {
#line 2648
      rho = (char *)">";
#line 2648
      goto err;
    }
#line 2649
    goto switch_break___0;
    case_356: /* CIL Label */ 
#line 2651
    if (! (value != bound)) {
#line 2651
      rho = (char *)"<>";
#line 2651
      goto err;
    }
#line 2652
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 2654
    if ((unsigned long )cond != (unsigned long )cond) {
#line 2654
      tmp___5 = 1;
    } else {
      {
#line 2654
      _glp_lib_xassert("cond != cond", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2654);
#line 2654
      tmp___5 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 2623
    cond = cond->next;
#line 2623
    eqno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2658
  in = par->in;
#line 2658
  eqno = 1;
  {
#line 2658
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2658
    if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 2658
      goto while_break___0;
    }
#line 2660
    if ((unsigned long )in->code != (unsigned long )((void *)0)) {
#line 2660
      tmp___6 = 1;
    } else {
      {
#line 2660
      _glp_lib_xassert("in->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2660);
#line 2660
      tmp___6 = 1;
      }
    }
#line 2661
    if ((in->code)->dim == 1) {
#line 2661
      tmp___7 = 1;
    } else {
      {
#line 2661
      _glp_lib_xassert("in->code->dim == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2661);
#line 2661
      tmp___7 = 1;
      }
    }
    {
#line 2662
    tmp___8 = _glp_mpl_create_symbol_num(mpl, value);
#line 2662
    tmp___9 = _glp_mpl_create_tuple(mpl);
#line 2662
    dummy = _glp_mpl_expand_tuple(mpl, tmp___9, tmp___8);
#line 2664
    tmp___11 = _glp_mpl_is_member(mpl, in->code, dummy);
    }
#line 2664
    if (! tmp___11) {
      {
#line 2665
      tmp___10 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2665
      _glp_mpl_error(mpl, (char *)"%s%s = %.*g not in specified set; see (%d)", par->name,
                     tmp___10, 15, value, eqno);
      }
    }
    {
#line 2668
    _glp_mpl_delete_tuple(mpl, dummy);
#line 2658
    in = in->next;
#line 2658
    eqno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2670
  return;
}
}
#line 2681 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_take_member_num(MPL *mpl , PARAMETER *par , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  double value ;
  TUPLE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2689
  memb = _glp_mpl_find_member(mpl, par->array, tuple);
  }
#line 2690
  if ((unsigned long )memb != (unsigned long )((void *)0)) {
#line 2692
    value = memb->value.num;
  } else
#line 2694
  if ((unsigned long )par->assign != (unsigned long )((void *)0)) {
    {
#line 2696
    value = _glp_mpl_eval_numeric(mpl, par->assign);
    }
    add: 
    {
#line 2699
    _glp_mpl_check_value_num(mpl, par, tuple, value);
#line 2700
    tmp = _glp_mpl_copy_tuple(mpl, tuple);
#line 2700
    memb = _glp_mpl_add_member(mpl, par->array, tmp);
#line 2701
    memb->value.num = value;
    }
  } else
#line 2703
  if ((unsigned long )par->option != (unsigned long )((void *)0)) {
    {
#line 2705
    value = _glp_mpl_eval_numeric(mpl, par->option);
    }
#line 2706
    goto add;
  } else
#line 2708
  if ((unsigned long )par->defval != (unsigned long )((void *)0)) {
#line 2710
    if ((unsigned long )(par->defval)->str != (unsigned long )((void *)0)) {
      {
#line 2711
      tmp___0 = _glp_mpl_format_symbol(mpl, par->defval);
#line 2711
      _glp_mpl_error(mpl, (char *)"cannot convert %s to floating-point number", tmp___0);
      }
    }
#line 2713
    value = (par->defval)->num;
#line 2714
    goto add;
  } else {
    {
#line 2718
    tmp___1 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2718
    _glp_mpl_error(mpl, (char *)"no value for %s%s", par->name, tmp___1);
    }
  }
#line 2721
  return (value);
}
}
#line 2746 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void eval_num_func(MPL *mpl , void *_info ) 
{ 
  struct eval_num_info *info ;

  {
#line 2748
  info = (struct eval_num_info *)_info;
#line 2749
  if ((unsigned long )info->memb != (unsigned long )((void *)0)) {
    {
#line 2751
    _glp_mpl_check_value_num(mpl, info->par, (info->memb)->tuple, (info->memb)->value.num);
    }
  } else {
    {
#line 2756
    info->value = _glp_mpl_take_member_num(mpl, info->par, info->tuple);
    }
  }
#line 2758
  return;
}
}
#line 2761 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_eval_member_num(MPL *mpl , PARAMETER *par , TUPLE *tuple ) 
{ 
  struct eval_num_info _info ;
  struct eval_num_info *info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  MEMBER *tail ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2767
  info = & _info;
#line 2768
  if (par->type == 118) {
#line 2768
    tmp = 1;
  } else
#line 2768
  if (par->type == 113) {
#line 2768
    tmp = 1;
  } else
#line 2768
  if (par->type == 101) {
#line 2768
    tmp = 1;
  } else {
    {
#line 2768
    _glp_lib_xassert("par->type == A_NUMERIC || par->type == A_INTEGER || par->type == A_BINARY",
                     "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c", 2769);
#line 2768
    tmp = 1;
    }
  }
  {
#line 2770
  tmp___0 = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 2770
  if (par->dim == tmp___0) {
#line 2770
    tmp___1 = 1;
  } else {
    {
#line 2770
    _glp_lib_xassert("par->dim == tuple_dimen(mpl, tuple)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     2770);
#line 2770
    tmp___1 = 1;
    }
  }
#line 2771
  info->par = par;
#line 2772
  info->tuple = tuple;
#line 2773
  if (par->data == 1) {
#line 2782
    tail = (par->array)->tail;
#line 2785
    par->data = 2;
#line 2788
    info->memb = (par->array)->head;
    {
#line 2788
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2788
      if (! ((unsigned long )info->memb != (unsigned long )((void *)0))) {
#line 2788
        goto while_break;
      }
      {
#line 2790
      tmp___2 = _glp_mpl_eval_within_domain(mpl, par->domain, (info->memb)->tuple,
                                            (void *)info, & eval_num_func);
      }
#line 2790
      if (tmp___2) {
        {
#line 2792
        _glp_mpl_out_of_domain(mpl, par->name, (info->memb)->tuple);
        }
      }
#line 2793
      if ((unsigned long )info->memb == (unsigned long )tail) {
#line 2793
        goto while_break;
      }
#line 2788
      info->memb = (info->memb)->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2798
  info->memb = (MEMBER *)((void *)0);
#line 2799
  tmp___3 = _glp_mpl_eval_within_domain(mpl, (info->par)->domain, info->tuple, (void *)info,
                                        & eval_num_func);
  }
#line 2799
  if (tmp___3) {
    {
#line 2801
    _glp_mpl_out_of_domain(mpl, par->name, info->tuple);
    }
  }
#line 2803
  return (info->value);
}
}
#line 2814 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_check_value_sym(MPL *mpl , PARAMETER *par , TUPLE *tuple , SYMBOL *value ) 
{ 
  CONDITION *cond ;
  WITHIN *in ;
  int eqno ;
  SYMBOL *bound ;
  char buf[256] ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  TUPLE *dummy ;
  int tmp___37 ;
  int tmp___38 ;
  SYMBOL *tmp___39 ;
  TUPLE *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;

  {
#line 2824
  cond = par->cond;
#line 2824
  eqno = 1;
  {
#line 2824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2824
    if (! ((unsigned long )cond != (unsigned long )((void *)0))) {
#line 2824
      goto while_break;
    }
#line 2828
    if ((unsigned long )cond->code != (unsigned long )((void *)0)) {
#line 2828
      tmp = 1;
    } else {
      {
#line 2828
      _glp_lib_xassert("cond->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2828);
#line 2828
      tmp = 1;
      }
    }
    {
#line 2829
    bound = _glp_mpl_eval_symbolic(mpl, cond->code);
    }
    {
#line 2833
    if (cond->rho == 351) {
#line 2833
      goto case_351;
    }
#line 2842
    if (cond->rho == 352) {
#line 2842
      goto case_352;
    }
#line 2852
    if (cond->rho == 353) {
#line 2852
      goto case_353;
    }
#line 2862
    if (cond->rho == 354) {
#line 2862
      goto case_354;
    }
#line 2871
    if (cond->rho == 355) {
#line 2871
      goto case_355;
    }
#line 2881
    if (cond->rho == 356) {
#line 2881
      goto case_356;
    }
#line 2890
    goto switch_default;
    case_351: /* CIL Label */ 
    {
#line 2834
    tmp___5 = _glp_mpl_compare_symbols(mpl, value, bound);
    }
#line 2834
    if (! (tmp___5 < 0)) {
      {
#line 2835
      tmp___0 = _glp_mpl_format_symbol(mpl, bound);
#line 2835
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___0);
#line 2836
      tmp___1 = strlen((char const   *)(buf));
      }
#line 2836
      if ((unsigned long )tmp___1 < sizeof(buf)) {
#line 2836
        tmp___2 = 1;
      } else {
        {
#line 2836
        _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2836);
#line 2836
        tmp___2 = 1;
        }
      }
      {
#line 2837
      tmp___3 = _glp_mpl_format_symbol(mpl, value);
#line 2837
      tmp___4 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2837
      _glp_mpl_error(mpl, (char *)"%s%s = %s not < %s", par->name, tmp___4, tmp___3,
                     buf, eqno);
      }
    }
#line 2841
    goto switch_break;
    case_352: /* CIL Label */ 
    {
#line 2843
    tmp___11 = _glp_mpl_compare_symbols(mpl, value, bound);
    }
#line 2843
    if (! (tmp___11 <= 0)) {
      {
#line 2844
      tmp___6 = _glp_mpl_format_symbol(mpl, bound);
#line 2844
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___6);
#line 2845
      tmp___7 = strlen((char const   *)(buf));
      }
#line 2845
      if ((unsigned long )tmp___7 < sizeof(buf)) {
#line 2845
        tmp___8 = 1;
      } else {
        {
#line 2845
        _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2845);
#line 2845
        tmp___8 = 1;
        }
      }
      {
#line 2846
      tmp___9 = _glp_mpl_format_symbol(mpl, value);
#line 2846
      tmp___10 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2846
      _glp_mpl_error(mpl, (char *)"%s%s = %s not <= %s", par->name, tmp___10, tmp___9,
                     buf, eqno);
      }
    }
#line 2850
    goto switch_break;
    case_353: /* CIL Label */ 
    {
#line 2853
    tmp___17 = _glp_mpl_compare_symbols(mpl, value, bound);
    }
#line 2853
    if (! (tmp___17 == 0)) {
      {
#line 2854
      tmp___12 = _glp_mpl_format_symbol(mpl, bound);
#line 2854
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___12);
#line 2855
      tmp___13 = strlen((char const   *)(buf));
      }
#line 2855
      if ((unsigned long )tmp___13 < sizeof(buf)) {
#line 2855
        tmp___14 = 1;
      } else {
        {
#line 2855
        _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2855);
#line 2855
        tmp___14 = 1;
        }
      }
      {
#line 2856
      tmp___15 = _glp_mpl_format_symbol(mpl, value);
#line 2856
      tmp___16 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2856
      _glp_mpl_error(mpl, (char *)"%s%s = %s not = %s", par->name, tmp___16, tmp___15,
                     buf, eqno);
      }
    }
#line 2860
    goto switch_break;
    case_354: /* CIL Label */ 
    {
#line 2863
    tmp___23 = _glp_mpl_compare_symbols(mpl, value, bound);
    }
#line 2863
    if (! (tmp___23 >= 0)) {
      {
#line 2864
      tmp___18 = _glp_mpl_format_symbol(mpl, bound);
#line 2864
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___18);
#line 2865
      tmp___19 = strlen((char const   *)(buf));
      }
#line 2865
      if ((unsigned long )tmp___19 < sizeof(buf)) {
#line 2865
        tmp___20 = 1;
      } else {
        {
#line 2865
        _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2865);
#line 2865
        tmp___20 = 1;
        }
      }
      {
#line 2866
      tmp___21 = _glp_mpl_format_symbol(mpl, value);
#line 2866
      tmp___22 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2866
      _glp_mpl_error(mpl, (char *)"%s%s = %s not >= %s", par->name, tmp___22, tmp___21,
                     buf, eqno);
      }
    }
#line 2870
    goto switch_break;
    case_355: /* CIL Label */ 
    {
#line 2872
    tmp___29 = _glp_mpl_compare_symbols(mpl, value, bound);
    }
#line 2872
    if (! (tmp___29 > 0)) {
      {
#line 2873
      tmp___24 = _glp_mpl_format_symbol(mpl, bound);
#line 2873
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___24);
#line 2874
      tmp___25 = strlen((char const   *)(buf));
      }
#line 2874
      if ((unsigned long )tmp___25 < sizeof(buf)) {
#line 2874
        tmp___26 = 1;
      } else {
        {
#line 2874
        _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2874);
#line 2874
        tmp___26 = 1;
        }
      }
      {
#line 2875
      tmp___27 = _glp_mpl_format_symbol(mpl, value);
#line 2875
      tmp___28 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2875
      _glp_mpl_error(mpl, (char *)"%s%s = %s not > %s", par->name, tmp___28, tmp___27,
                     buf, eqno);
      }
    }
#line 2879
    goto switch_break;
    case_356: /* CIL Label */ 
    {
#line 2882
    tmp___35 = _glp_mpl_compare_symbols(mpl, value, bound);
    }
#line 2882
    if (! (tmp___35 != 0)) {
      {
#line 2883
      tmp___30 = _glp_mpl_format_symbol(mpl, bound);
#line 2883
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___30);
#line 2884
      tmp___31 = strlen((char const   *)(buf));
      }
#line 2884
      if ((unsigned long )tmp___31 < sizeof(buf)) {
#line 2884
        tmp___32 = 1;
      } else {
        {
#line 2884
        _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         2884);
#line 2884
        tmp___32 = 1;
        }
      }
      {
#line 2885
      tmp___33 = _glp_mpl_format_symbol(mpl, value);
#line 2885
      tmp___34 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2885
      _glp_mpl_error(mpl, (char *)"%s%s = %s not <> %s", par->name, tmp___34, tmp___33,
                     buf, eqno);
      }
    }
#line 2889
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2891
    if ((unsigned long )cond != (unsigned long )cond) {
#line 2891
      tmp___36 = 1;
    } else {
      {
#line 2891
      _glp_lib_xassert("cond != cond", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2891);
#line 2891
      tmp___36 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 2893
    _glp_mpl_delete_symbol(mpl, bound);
#line 2824
    cond = cond->next;
#line 2824
    eqno ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2896
  in = par->in;
#line 2896
  eqno = 1;
  {
#line 2896
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2896
    if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 2896
      goto while_break___0;
    }
#line 2898
    if ((unsigned long )in->code != (unsigned long )((void *)0)) {
#line 2898
      tmp___37 = 1;
    } else {
      {
#line 2898
      _glp_lib_xassert("in->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2898);
#line 2898
      tmp___37 = 1;
      }
    }
#line 2899
    if ((in->code)->dim == 1) {
#line 2899
      tmp___38 = 1;
    } else {
      {
#line 2899
      _glp_lib_xassert("in->code->dim == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       2899);
#line 2899
      tmp___38 = 1;
      }
    }
    {
#line 2900
    tmp___39 = _glp_mpl_copy_symbol(mpl, value);
#line 2900
    tmp___40 = _glp_mpl_create_tuple(mpl);
#line 2900
    dummy = _glp_mpl_expand_tuple(mpl, tmp___40, tmp___39);
#line 2902
    tmp___43 = _glp_mpl_is_member(mpl, in->code, dummy);
    }
#line 2902
    if (! tmp___43) {
      {
#line 2903
      tmp___41 = _glp_mpl_format_symbol(mpl, value);
#line 2903
      tmp___42 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2903
      _glp_mpl_error(mpl, (char *)"%s%s = %s not in specified set; see (%d)", par->name,
                     tmp___42, tmp___41, eqno);
      }
    }
    {
#line 2906
    _glp_mpl_delete_tuple(mpl, dummy);
#line 2896
    in = in->next;
#line 2896
    eqno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2908
  return;
}
}
#line 2919 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
SYMBOL *_glp_mpl_take_member_sym(MPL *mpl , PARAMETER *par , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  SYMBOL *value ;
  TUPLE *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 2927
  memb = _glp_mpl_find_member(mpl, par->array, tuple);
  }
#line 2928
  if ((unsigned long )memb != (unsigned long )((void *)0)) {
    {
#line 2930
    value = _glp_mpl_copy_symbol(mpl, memb->value.sym);
    }
  } else
#line 2932
  if ((unsigned long )par->assign != (unsigned long )((void *)0)) {
    {
#line 2934
    value = _glp_mpl_eval_symbolic(mpl, par->assign);
    }
    add: 
    {
#line 2937
    _glp_mpl_check_value_sym(mpl, par, tuple, value);
#line 2938
    tmp = _glp_mpl_copy_tuple(mpl, tuple);
#line 2938
    memb = _glp_mpl_add_member(mpl, par->array, tmp);
#line 2939
    memb->value.sym = _glp_mpl_copy_symbol(mpl, value);
    }
  } else
#line 2941
  if ((unsigned long )par->option != (unsigned long )((void *)0)) {
    {
#line 2943
    value = _glp_mpl_eval_symbolic(mpl, par->option);
    }
#line 2944
    goto add;
  } else
#line 2946
  if ((unsigned long )par->defval != (unsigned long )((void *)0)) {
    {
#line 2948
    value = _glp_mpl_copy_symbol(mpl, par->defval);
    }
#line 2949
    goto add;
  } else {
    {
#line 2953
    tmp___0 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 2953
    _glp_mpl_error(mpl, (char *)"no value for %s%s", par->name, tmp___0);
    }
  }
#line 2956
  return (value);
}
}
#line 2981 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void eval_sym_func(MPL *mpl , void *_info ) 
{ 
  struct eval_sym_info *info ;

  {
#line 2983
  info = (struct eval_sym_info *)_info;
#line 2984
  if ((unsigned long )info->memb != (unsigned long )((void *)0)) {
    {
#line 2986
    _glp_mpl_check_value_sym(mpl, info->par, (info->memb)->tuple, (info->memb)->value.sym);
    }
  } else {
    {
#line 2991
    info->value = _glp_mpl_take_member_sym(mpl, info->par, info->tuple);
    }
  }
#line 2993
  return;
}
}
#line 2996 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
SYMBOL *_glp_mpl_eval_member_sym(MPL *mpl , PARAMETER *par , TUPLE *tuple ) 
{ 
  struct eval_sym_info _info ;
  struct eval_sym_info *info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  MEMBER *tail ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 3002
  info = & _info;
#line 3003
  if (par->type == 124) {
#line 3003
    tmp = 1;
  } else {
    {
#line 3003
    _glp_lib_xassert("par->type == A_SYMBOLIC", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3003);
#line 3003
    tmp = 1;
    }
  }
  {
#line 3004
  tmp___0 = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 3004
  if (par->dim == tmp___0) {
#line 3004
    tmp___1 = 1;
  } else {
    {
#line 3004
    _glp_lib_xassert("par->dim == tuple_dimen(mpl, tuple)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3004);
#line 3004
    tmp___1 = 1;
    }
  }
#line 3005
  info->par = par;
#line 3006
  info->tuple = tuple;
#line 3007
  if (par->data == 1) {
#line 3016
    tail = (par->array)->tail;
#line 3019
    par->data = 2;
#line 3022
    info->memb = (par->array)->head;
    {
#line 3022
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3022
      if (! ((unsigned long )info->memb != (unsigned long )((void *)0))) {
#line 3022
        goto while_break;
      }
      {
#line 3024
      tmp___2 = _glp_mpl_eval_within_domain(mpl, par->domain, (info->memb)->tuple,
                                            (void *)info, & eval_sym_func);
      }
#line 3024
      if (tmp___2) {
        {
#line 3026
        _glp_mpl_out_of_domain(mpl, par->name, (info->memb)->tuple);
        }
      }
#line 3027
      if ((unsigned long )info->memb == (unsigned long )tail) {
#line 3027
        goto while_break;
      }
#line 3022
      info->memb = (info->memb)->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 3032
  info->memb = (MEMBER *)((void *)0);
#line 3033
  tmp___3 = _glp_mpl_eval_within_domain(mpl, (info->par)->domain, info->tuple, (void *)info,
                                        & eval_sym_func);
  }
#line 3033
  if (tmp___3) {
    {
#line 3035
    _glp_mpl_out_of_domain(mpl, par->name, info->tuple);
    }
  }
#line 3037
  return (info->value);
}
}
#line 3046 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int whole_par_func(MPL *mpl , void *info ) 
{ 
  PARAMETER *par ;
  TUPLE *tuple ;
  TUPLE *tmp ;
  SYMBOL *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 3048
  par = (PARAMETER *)info;
#line 3049
  tmp = _glp_mpl_get_domain_tuple(mpl, par->domain);
#line 3049
  tuple = tmp;
  }
  {
#line 3053
  if (par->type == 101) {
#line 3053
    goto case_101;
  }
#line 3053
  if (par->type == 113) {
#line 3053
    goto case_101;
  }
#line 3053
  if (par->type == 118) {
#line 3053
    goto case_101;
  }
#line 3056
  if (par->type == 124) {
#line 3056
    goto case_124;
  }
#line 3059
  goto switch_default;
  case_101: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_118: /* CIL Label */ 
  {
#line 3054
  _glp_mpl_eval_member_num(mpl, par, tuple);
  }
#line 3055
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 3057
  tmp___0 = _glp_mpl_eval_member_sym(mpl, par, tuple);
#line 3057
  _glp_mpl_delete_symbol(mpl, tmp___0);
  }
#line 3058
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3060
  if ((unsigned long )par != (unsigned long )par) {
#line 3060
    tmp___1 = 1;
  } else {
    {
#line 3060
    _glp_lib_xassert("par != par", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3060);
#line 3060
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 3062
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 3063
  return (0);
}
}
#line 3066 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_eval_whole_par(MPL *mpl , PARAMETER *par ) 
{ 


  {
  {
#line 3067
  _glp_mpl_loop_within_domain(mpl, par->domain, (void *)par, & whole_par_func);
  }
#line 3068
  return;
}
}
#line 3077 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_parameter(MPL *mpl , PARAMETER *par ) 
{ 
  CONDITION *cond ;
  WITHIN *in ;
  MEMBER *memb ;

  {
  {
#line 3082
  _glp_mpl_clean_domain(mpl, par->domain);
#line 3084
  cond = par->cond;
  }
  {
#line 3084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3084
    if (! ((unsigned long )cond != (unsigned long )((void *)0))) {
#line 3084
      goto while_break;
    }
    {
#line 3085
    _glp_mpl_clean_code(mpl, cond->code);
#line 3084
    cond = cond->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3087
  in = par->in;
  {
#line 3087
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3087
    if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 3087
      goto while_break___0;
    }
    {
#line 3088
    _glp_mpl_clean_code(mpl, in->code);
#line 3087
    in = in->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3090
  _glp_mpl_clean_code(mpl, par->assign);
#line 3092
  _glp_mpl_clean_code(mpl, par->option);
#line 3094
  par->data = 0;
  }
#line 3096
  if ((unsigned long )par->defval != (unsigned long )((void *)0)) {
    {
#line 3097
    _glp_mpl_delete_symbol(mpl, par->defval);
#line 3097
    par->defval = (SYMBOL *)((void *)0);
    }
  }
#line 3099
  memb = (par->array)->head;
  {
#line 3099
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3099
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 3099
      goto while_break___1;
    }
    {
#line 3100
    _glp_mpl_delete_value(mpl, (par->array)->type, & memb->value);
#line 3099
    memb = memb->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3101
  _glp_mpl_delete_array(mpl, par->array);
#line 3101
  par->array = (ARRAY *)((void *)0);
  }
#line 3102
  return;
}
}
#line 3118 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMVAR *_glp_mpl_take_member_var(MPL *mpl , VARIABLE *var , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  ELEMVAR *refer ;
  TUPLE *tmp ;
  ELEMVAR *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 3126
  memb = _glp_mpl_find_member(mpl, var->array, tuple);
  }
#line 3127
  if ((unsigned long )memb != (unsigned long )((void *)0)) {
#line 3129
    refer = memb->value.var;
  } else {
    {
#line 3135
    tmp = _glp_mpl_copy_tuple(mpl, tuple);
#line 3135
    memb = _glp_mpl_add_member(mpl, var->array, tmp);
#line 3136
    tmp___1 = _glp_dmp_get_atom(mpl->elemvars, (int )sizeof(ELEMVAR ));
#line 3136
    tmp___0 = (ELEMVAR *)tmp___1;
#line 3136
    memb->value.var = tmp___0;
#line 3136
    refer = tmp___0;
#line 3138
    refer->j = 0;
#line 3139
    refer->var = var;
#line 3140
    refer->memb = memb;
    }
#line 3142
    if ((unsigned long )var->lbnd == (unsigned long )((void *)0)) {
#line 3143
      refer->lbnd = 0.0;
    } else {
      {
#line 3145
      refer->lbnd = _glp_mpl_eval_numeric(mpl, var->lbnd);
      }
    }
#line 3147
    if ((unsigned long )var->ubnd == (unsigned long )((void *)0)) {
#line 3148
      refer->ubnd = 0.0;
    } else
#line 3149
    if ((unsigned long )var->ubnd == (unsigned long )var->lbnd) {
#line 3150
      refer->ubnd = refer->lbnd;
    } else {
      {
#line 3152
      refer->ubnd = _glp_mpl_eval_numeric(mpl, var->ubnd);
      }
    }
#line 3154
    refer->temp = 0.0;
#line 3156
    refer->value = 0.0;
  }
#line 3158
  return (refer);
}
}
#line 3177 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void eval_var_func(MPL *mpl , void *_info ) 
{ 
  struct eval_var_info *info ;

  {
  {
#line 3179
  info = (struct eval_var_info *)_info;
#line 3180
  info->refer = _glp_mpl_take_member_var(mpl, info->var, info->tuple);
  }
#line 3181
  return;
}
}
#line 3184 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMVAR *_glp_mpl_eval_member_var(MPL *mpl , VARIABLE *var , TUPLE *tuple ) 
{ 
  struct eval_var_info _info ;
  struct eval_var_info *info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3190
  info = & _info;
#line 3191
  tmp = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 3191
  if (var->dim == tmp) {
#line 3191
    tmp___0 = 1;
  } else {
    {
#line 3191
    _glp_lib_xassert("var->dim == tuple_dimen(mpl, tuple)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3191);
#line 3191
    tmp___0 = 1;
    }
  }
  {
#line 3192
  info->var = var;
#line 3193
  info->tuple = tuple;
#line 3195
  tmp___1 = _glp_mpl_eval_within_domain(mpl, (info->var)->domain, info->tuple, (void *)info,
                                        & eval_var_func);
  }
#line 3195
  if (tmp___1) {
    {
#line 3197
    _glp_mpl_out_of_domain(mpl, var->name, info->tuple);
    }
  }
#line 3199
  return (info->refer);
}
}
#line 3208 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int whole_var_func(MPL *mpl , void *info ) 
{ 
  VARIABLE *var ;
  TUPLE *tuple ;
  TUPLE *tmp ;

  {
  {
#line 3210
  var = (VARIABLE *)info;
#line 3211
  tmp = _glp_mpl_get_domain_tuple(mpl, var->domain);
#line 3211
  tuple = tmp;
#line 3212
  _glp_mpl_eval_member_var(mpl, var, tuple);
#line 3213
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 3214
  return (0);
}
}
#line 3217 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_eval_whole_var(MPL *mpl , VARIABLE *var ) 
{ 


  {
  {
#line 3218
  _glp_mpl_loop_within_domain(mpl, var->domain, (void *)var, & whole_var_func);
  }
#line 3219
  return;
}
}
#line 3228 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_variable(MPL *mpl , VARIABLE *var ) 
{ 
  MEMBER *memb ;

  {
  {
#line 3231
  _glp_mpl_clean_domain(mpl, var->domain);
#line 3233
  _glp_mpl_clean_code(mpl, var->lbnd);
  }
#line 3235
  if ((unsigned long )var->ubnd != (unsigned long )var->lbnd) {
    {
#line 3235
    _glp_mpl_clean_code(mpl, var->ubnd);
    }
  }
#line 3237
  memb = (var->array)->head;
  {
#line 3237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3237
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 3237
      goto while_break;
    }
    {
#line 3238
    _glp_dmp_free_atom(mpl->elemvars, (void *)memb->value.var, (int )sizeof(ELEMVAR ));
#line 3237
    memb = memb->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3239
  _glp_mpl_delete_array(mpl, var->array);
#line 3239
  var->array = (ARRAY *)((void *)0);
  }
#line 3240
  return;
}
}
#line 3256 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMCON *_glp_mpl_take_member_con(MPL *mpl , CONSTRAINT *con , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  ELEMCON *refer ;
  TUPLE *tmp ;
  ELEMCON *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  double temp ;
  int tmp___3 ;
  double tmp___4 ;
  double temp___0 ;
  int tmp___5 ;
  FORMULA *tmp___6 ;
  double temp___1 ;
  int tmp___7 ;
  FORMULA *tmp___8 ;
  double temp___2 ;
  int tmp___9 ;
  FORMULA *tmp___10 ;
  double tmp___11 ;
  double temp___3 ;
  double temp1 ;
  double temp2 ;
  int tmp___12 ;
  FORMULA *tmp___13 ;
  FORMULA *tmp___14 ;
  int tmp___15 ;
  FORMULA *tmp___16 ;
  FORMULA *tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 3264
  memb = _glp_mpl_find_member(mpl, con->array, tuple);
  }
#line 3265
  if ((unsigned long )memb != (unsigned long )((void *)0)) {
#line 3267
    refer = memb->value.con;
  } else {
    {
#line 3273
    tmp = _glp_mpl_copy_tuple(mpl, tuple);
#line 3273
    memb = _glp_mpl_add_member(mpl, con->array, tmp);
#line 3274
    tmp___1 = _glp_dmp_get_atom(mpl->elemcons, (int )sizeof(ELEMCON ));
#line 3274
    tmp___0 = (ELEMCON *)tmp___1;
#line 3274
    memb->value.con = tmp___0;
#line 3274
    refer = tmp___0;
#line 3276
    refer->i = 0;
#line 3277
    refer->con = con;
#line 3278
    refer->memb = memb;
    }
#line 3280
    if ((unsigned long )con->code != (unsigned long )((void *)0)) {
#line 3280
      tmp___2 = 1;
    } else {
      {
#line 3280
      _glp_lib_xassert("con->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       3280);
#line 3280
      tmp___2 = 1;
      }
    }
    {
#line 3281
    refer->form = _glp_mpl_eval_formula(mpl, con->code);
    }
#line 3283
    if ((unsigned long )con->lbnd == (unsigned long )((void *)0)) {
#line 3283
      if ((unsigned long )con->ubnd == (unsigned long )((void *)0)) {
#line 3286
        if (con->type == 116) {
#line 3286
          tmp___3 = 1;
        } else
#line 3286
        if (con->type == 115) {
#line 3286
          tmp___3 = 1;
        } else {
          {
#line 3286
          _glp_lib_xassert("con->type == A_MINIMIZE || con->type == A_MAXIMIZE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           3286);
#line 3286
          tmp___3 = 1;
          }
        }
        {
#line 3288
        refer->form = _glp_mpl_remove_constant(mpl, refer->form, & temp);
#line 3289
        tmp___4 = - temp;
#line 3289
        refer->ubnd = tmp___4;
#line 3289
        refer->lbnd = tmp___4;
        }
      } else {
#line 3283
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3291
    if ((unsigned long )con->lbnd != (unsigned long )((void *)0)) {
#line 3291
      if ((unsigned long )con->ubnd == (unsigned long )((void *)0)) {
#line 3295
        if (con->type == 103) {
#line 3295
          tmp___5 = 1;
        } else {
          {
#line 3295
          _glp_lib_xassert("con->type == A_CONSTRAINT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           3295);
#line 3295
          tmp___5 = 1;
          }
        }
        {
#line 3296
        tmp___6 = _glp_mpl_eval_formula(mpl, con->lbnd);
#line 3296
        refer->form = _glp_mpl_linear_comb(mpl, 1.0, refer->form, - 1.0, tmp___6);
#line 3299
        refer->form = _glp_mpl_remove_constant(mpl, refer->form, & temp___0);
#line 3300
        refer->lbnd = - temp___0;
#line 3301
        refer->ubnd = 0.0;
        }
      } else {
#line 3291
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3303
    if ((unsigned long )con->lbnd == (unsigned long )((void *)0)) {
#line 3303
      if ((unsigned long )con->ubnd != (unsigned long )((void *)0)) {
#line 3307
        if (con->type == 103) {
#line 3307
          tmp___7 = 1;
        } else {
          {
#line 3307
          _glp_lib_xassert("con->type == A_CONSTRAINT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           3307);
#line 3307
          tmp___7 = 1;
          }
        }
        {
#line 3308
        tmp___8 = _glp_mpl_eval_formula(mpl, con->ubnd);
#line 3308
        refer->form = _glp_mpl_linear_comb(mpl, 1.0, refer->form, - 1.0, tmp___8);
#line 3311
        refer->form = _glp_mpl_remove_constant(mpl, refer->form, & temp___1);
#line 3312
        refer->lbnd = 0.0;
#line 3313
        refer->ubnd = - temp___1;
        }
      } else {
#line 3303
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3315
    if ((unsigned long )con->lbnd == (unsigned long )con->ubnd) {
#line 3319
      if (con->type == 103) {
#line 3319
        tmp___9 = 1;
      } else {
        {
#line 3319
        _glp_lib_xassert("con->type == A_CONSTRAINT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         3319);
#line 3319
        tmp___9 = 1;
        }
      }
      {
#line 3320
      tmp___10 = _glp_mpl_eval_formula(mpl, con->lbnd);
#line 3320
      refer->form = _glp_mpl_linear_comb(mpl, 1.0, refer->form, - 1.0, tmp___10);
#line 3323
      refer->form = _glp_mpl_remove_constant(mpl, refer->form, & temp___2);
#line 3324
      tmp___11 = - temp___2;
#line 3324
      refer->ubnd = tmp___11;
#line 3324
      refer->lbnd = tmp___11;
      }
    } else {
#line 3330
      if (con->type == 103) {
#line 3330
        tmp___12 = 1;
      } else {
        {
#line 3330
        _glp_lib_xassert("con->type == A_CONSTRAINT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         3330);
#line 3330
        tmp___12 = 1;
        }
      }
      {
#line 3331
      refer->form = _glp_mpl_remove_constant(mpl, refer->form, & temp___3);
#line 3332
      tmp___13 = _glp_mpl_eval_formula(mpl, con->lbnd);
#line 3332
      tmp___14 = _glp_mpl_remove_constant(mpl, tmp___13, & temp1);
      }
#line 3332
      if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
#line 3332
        tmp___15 = 1;
      } else {
        {
#line 3332
        _glp_lib_xassert("remove_constant(mpl, eval_formula(mpl, con->lbnd), &temp1) == NULL",
                         "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c", 3333);
#line 3332
        tmp___15 = 1;
        }
      }
      {
#line 3334
      tmp___16 = _glp_mpl_eval_formula(mpl, con->ubnd);
#line 3334
      tmp___17 = _glp_mpl_remove_constant(mpl, tmp___16, & temp2);
      }
#line 3334
      if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
#line 3334
        tmp___18 = 1;
      } else {
        {
#line 3334
        _glp_lib_xassert("remove_constant(mpl, eval_formula(mpl, con->ubnd), &temp2) == NULL",
                         "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c", 3335);
#line 3334
        tmp___18 = 1;
        }
      }
      {
#line 3336
      refer->lbnd = _glp_mpl_fp_sub(mpl, temp1, temp___3);
#line 3337
      refer->ubnd = _glp_mpl_fp_sub(mpl, temp2, temp___3);
      }
    }
  }
#line 3340
  return (refer);
}
}
#line 3359 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void eval_con_func(MPL *mpl , void *_info ) 
{ 
  struct eval_con_info *info ;

  {
  {
#line 3361
  info = (struct eval_con_info *)_info;
#line 3362
  info->refer = _glp_mpl_take_member_con(mpl, info->con, info->tuple);
  }
#line 3363
  return;
}
}
#line 3366 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMCON *_glp_mpl_eval_member_con(MPL *mpl , CONSTRAINT *con , TUPLE *tuple ) 
{ 
  struct eval_con_info _info ;
  struct eval_con_info *info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3372
  info = & _info;
#line 3373
  tmp = _glp_mpl_tuple_dimen(mpl, tuple);
  }
#line 3373
  if (con->dim == tmp) {
#line 3373
    tmp___0 = 1;
  } else {
    {
#line 3373
    _glp_lib_xassert("con->dim == tuple_dimen(mpl, tuple)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3373);
#line 3373
    tmp___0 = 1;
    }
  }
  {
#line 3374
  info->con = con;
#line 3375
  info->tuple = tuple;
#line 3377
  tmp___1 = _glp_mpl_eval_within_domain(mpl, (info->con)->domain, info->tuple, (void *)info,
                                        & eval_con_func);
  }
#line 3377
  if (tmp___1) {
    {
#line 3379
    _glp_mpl_out_of_domain(mpl, con->name, info->tuple);
    }
  }
#line 3381
  return (info->refer);
}
}
#line 3390 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int whole_con_func(MPL *mpl , void *info ) 
{ 
  CONSTRAINT *con ;
  TUPLE *tuple ;
  TUPLE *tmp ;

  {
  {
#line 3392
  con = (CONSTRAINT *)info;
#line 3393
  tmp = _glp_mpl_get_domain_tuple(mpl, con->domain);
#line 3393
  tuple = tmp;
#line 3394
  _glp_mpl_eval_member_con(mpl, con, tuple);
#line 3395
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 3396
  return (0);
}
}
#line 3399 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_eval_whole_con(MPL *mpl , CONSTRAINT *con ) 
{ 


  {
  {
#line 3400
  _glp_mpl_loop_within_domain(mpl, con->domain, (void *)con, & whole_con_func);
  }
#line 3401
  return;
}
}
#line 3410 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_constraint(MPL *mpl , CONSTRAINT *con ) 
{ 
  MEMBER *memb ;

  {
  {
#line 3413
  _glp_mpl_clean_domain(mpl, con->domain);
#line 3415
  _glp_mpl_clean_code(mpl, con->code);
#line 3417
  _glp_mpl_clean_code(mpl, con->lbnd);
  }
#line 3419
  if ((unsigned long )con->ubnd != (unsigned long )con->lbnd) {
    {
#line 3419
    _glp_mpl_clean_code(mpl, con->ubnd);
    }
  }
#line 3421
  memb = (con->array)->head;
  {
#line 3421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3421
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 3421
      goto while_break;
    }
    {
#line 3422
    _glp_mpl_delete_formula(mpl, (memb->value.con)->form);
#line 3423
    _glp_dmp_free_atom(mpl->elemcons, (void *)memb->value.con, (int )sizeof(ELEMCON ));
#line 3421
    memb = memb->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3425
  _glp_mpl_delete_array(mpl, con->array);
#line 3425
  con->array = (ARRAY *)((void *)0);
  }
#line 3426
  return;
}
}
#line 3447 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int iter_num_func(MPL *mpl , void *_info ) 
{ 
  struct iter_num_info *info ;
  double temp ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 3450
  info = (struct iter_num_info *)_info;
#line 3452
  temp = _glp_mpl_eval_numeric(mpl, (info->code)->arg.loop.x);
  }
  {
#line 3454
  if ((info->code)->op == 376) {
#line 3454
    goto case_376;
  }
#line 3458
  if ((info->code)->op == 377) {
#line 3458
    goto case_377;
  }
#line 3462
  if ((info->code)->op == 378) {
#line 3462
    goto case_378;
  }
#line 3466
  if ((info->code)->op == 379) {
#line 3466
    goto case_379;
  }
#line 3470
  goto switch_default;
  case_376: /* CIL Label */ 
  {
#line 3456
  info->value = _glp_mpl_fp_add(mpl, info->value, temp);
  }
#line 3457
  goto switch_break;
  case_377: /* CIL Label */ 
  {
#line 3460
  info->value = _glp_mpl_fp_mul(mpl, info->value, temp);
  }
#line 3461
  goto switch_break;
  case_378: /* CIL Label */ 
#line 3464
  if (info->value > temp) {
#line 3464
    info->value = temp;
  }
#line 3465
  goto switch_break;
  case_379: /* CIL Label */ 
#line 3468
  if (info->value < temp) {
#line 3468
    info->value = temp;
  }
#line 3469
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3471
  if ((unsigned long )info != (unsigned long )info) {
#line 3471
    tmp = 1;
  } else {
    {
#line 3471
    _glp_lib_xassert("info != info", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3471);
#line 3471
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 3473
  return (0);
}
}
#line 3476 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_eval_numeric(MPL *mpl , CODE *code ) 
{ 
  double value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  TUPLE *tuple ;
  ARG_LIST *e ;
  SYMBOL *tmp___2 ;
  TUPLE *tuple___0 ;
  ARG_LIST *e___0 ;
  SYMBOL *tmp___3 ;
  ELEMVAR *tmp___4 ;
  SYMBOL *sym ;
  char *tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;
  double tmp___35 ;
  double tmp___36 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  double tmp___40 ;
  double tmp___41 ;
  double tmp___42 ;
  double tmp___43 ;
  double tmp___44 ;
  double tmp___45 ;
  ELEMSET *set___0 ;
  SYMBOL *sym___0 ;
  char str[101] ;
  size_t tmp___46 ;
  SYMBOL *sym___1 ;
  char str___0[101] ;
  char fmt___0[101] ;
  int tmp___47 ;
  ARG_LIST *e___1 ;
  double temp ;
  ARG_LIST *e___2 ;
  double temp___0 ;
  struct iter_num_info _info ;
  struct iter_num_info *info ;
  struct iter_num_info _info___0 ;
  struct iter_num_info *info___0 ;
  struct iter_num_info _info___1 ;
  struct iter_num_info *info___1 ;
  struct iter_num_info _info___2 ;
  struct iter_num_info *info___2 ;
  int tmp___48 ;
  int tmp___49 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;

  {
#line 3478
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 3478
    tmp = 1;
  } else {
    {
#line 3478
    _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3478);
#line 3478
    tmp = 1;
    }
  }
#line 3479
  if (code->type == 118) {
#line 3479
    tmp___0 = 1;
  } else {
    {
#line 3479
    _glp_lib_xassert("code->type == A_NUMERIC", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3479);
#line 3479
    tmp___0 = 1;
    }
  }
#line 3480
  if (code->dim == 0) {
#line 3480
    tmp___1 = 1;
  } else {
    {
#line 3480
    _glp_lib_xassert("code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3480);
#line 3480
    tmp___1 = 1;
    }
  }
#line 3483
  if (code->vflag) {
#line 3483
    if (code->valid) {
      {
#line 3484
      code->valid = 0;
#line 3485
      _glp_mpl_delete_value(mpl, code->type, & code->value);
      }
    }
  }
#line 3488
  if (code->valid) {
#line 3489
    value = code->value.num;
#line 3490
    goto done;
  }
  {
#line 3494
  if (code->op == 301) {
#line 3494
    goto case_301;
  }
#line 3498
  if (code->op == 304) {
#line 3498
    goto case_304;
  }
#line 3510
  if (code->op == 307) {
#line 3510
    goto case_307;
  }
#line 3523
  if (code->op == 311) {
#line 3523
    goto case_311;
  }
#line 3527
  if (code->op == 312) {
#line 3527
    goto case_312;
  }
#line 3531
  if (code->op == 313) {
#line 3531
    goto case_313;
  }
#line 3535
  if (code->op == 314) {
#line 3535
    goto case_314;
  }
#line 3539
  if (code->op == 315) {
#line 3539
    goto case_315;
  }
#line 3560
  if (code->op == 320) {
#line 3560
    goto case_320;
  }
#line 3564
  if (code->op == 321) {
#line 3564
    goto case_321;
  }
#line 3568
  if (code->op == 323) {
#line 3568
    goto case_323;
  }
#line 3572
  if (code->op == 324) {
#line 3572
    goto case_324;
  }
#line 3576
  if (code->op == 325) {
#line 3576
    goto case_325;
  }
#line 3580
  if (code->op == 326) {
#line 3580
    goto case_326;
  }
#line 3584
  if (code->op == 327) {
#line 3584
    goto case_327;
  }
#line 3588
  if (code->op == 328) {
#line 3588
    goto case_328;
  }
#line 3592
  if (code->op == 329) {
#line 3592
    goto case_329;
  }
#line 3596
  if (code->op == 330) {
#line 3596
    goto case_330;
  }
#line 3600
  if (code->op == 331) {
#line 3600
    goto case_331;
  }
#line 3604
  if (code->op == 332) {
#line 3604
    goto case_332;
  }
#line 3608
  if (code->op == 345) {
#line 3608
    goto case_345;
  }
#line 3614
  if (code->op == 333) {
#line 3614
    goto case_333;
  }
#line 3619
  if (code->op == 346) {
#line 3619
    goto case_346;
  }
#line 3625
  if (code->op == 334) {
#line 3625
    goto case_334;
  }
#line 3630
  if (code->op == 347) {
#line 3630
    goto case_347;
  }
#line 3636
  if (code->op == 337) {
#line 3636
    goto case_337;
  }
#line 3642
  if (code->op == 338) {
#line 3642
    goto case_338;
  }
#line 3648
  if (code->op == 339) {
#line 3648
    goto case_339;
  }
#line 3654
  if (code->op == 340) {
#line 3654
    goto case_340;
  }
#line 3660
  if (code->op == 341) {
#line 3660
    goto case_341;
  }
#line 3666
  if (code->op == 342) {
#line 3666
    goto case_342;
  }
#line 3672
  if (code->op == 343) {
#line 3672
    goto case_343;
  }
#line 3678
  if (code->op == 344) {
#line 3678
    goto case_344;
  }
#line 3684
  if (code->op == 348) {
#line 3684
    goto case_348;
  }
#line 3690
  if (code->op == 349) {
#line 3690
    goto case_349;
  }
#line 3696
  if (code->op == 335) {
#line 3696
    goto case_335;
  }
#line 3703
  if (code->op == 336) {
#line 3703
    goto case_336;
  }
#line 3715
  if (code->op == 369) {
#line 3715
    goto case_369;
  }
#line 3733
  if (code->op == 372) {
#line 3733
    goto case_372;
  }
#line 3742
  if (code->op == 374) {
#line 3742
    goto case_374;
  }
#line 3753
  if (code->op == 375) {
#line 3753
    goto case_375;
  }
#line 3764
  if (code->op == 376) {
#line 3764
    goto case_376;
  }
#line 3774
  if (code->op == 377) {
#line 3774
    goto case_377;
  }
#line 3784
  if (code->op == 378) {
#line 3784
    goto case_378;
  }
#line 3796
  if (code->op == 379) {
#line 3796
    goto case_379;
  }
#line 3808
  goto switch_default;
  case_301: /* CIL Label */ 
#line 3496
  value = code->arg.num;
#line 3497
  goto switch_break;
  case_304: /* CIL Label */ 
  {
#line 3502
  tuple = _glp_mpl_create_tuple(mpl);
#line 3503
  e = code->arg.par.list;
  }
  {
#line 3503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3503
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 3503
      goto while_break;
    }
    {
#line 3504
    tmp___2 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 3504
    tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___2);
#line 3503
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3506
  value = _glp_mpl_eval_member_num(mpl, code->arg.par.par, tuple);
#line 3507
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 3509
  goto switch_break;
  case_307: /* CIL Label */ 
  {
#line 3514
  tuple___0 = _glp_mpl_create_tuple(mpl);
#line 3515
  e___0 = code->arg.var.list;
  }
  {
#line 3515
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3515
    if (! ((unsigned long )e___0 != (unsigned long )((void *)0))) {
#line 3515
      goto while_break___0;
    }
    {
#line 3516
    tmp___3 = _glp_mpl_eval_symbolic(mpl, e___0->x);
#line 3516
    tuple___0 = _glp_mpl_expand_tuple(mpl, tuple___0, tmp___3);
#line 3515
    e___0 = e___0->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3518
  tmp___4 = _glp_mpl_eval_member_var(mpl, code->arg.var.var, tuple___0);
#line 3518
  value = tmp___4->value;
#line 3520
  _glp_mpl_delete_tuple(mpl, tuple___0);
  }
#line 3522
  goto switch_break;
  case_311: /* CIL Label */ 
  {
#line 3525
  value = _glp_mpl_fp_irand224(mpl);
  }
#line 3526
  goto switch_break;
  case_312: /* CIL Label */ 
  {
#line 3529
  value = _glp_mpl_fp_uniform01(mpl);
  }
#line 3530
  goto switch_break;
  case_313: /* CIL Label */ 
  {
#line 3533
  value = _glp_mpl_fp_normal01(mpl);
  }
#line 3534
  goto switch_break;
  case_314: /* CIL Label */ 
  {
#line 3537
  value = _glp_mpl_fn_gmtime(mpl);
  }
#line 3538
  goto switch_break;
  case_315: /* CIL Label */ 
  {
#line 3542
  sym = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
  }
#line 3549
  if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
#line 3550
    value = sym->num;
  } else {
    {
#line 3552
    tmp___6 = _glp_lib_str2num((char const   *)sym->str, & value);
    }
#line 3552
    if (tmp___6) {
      {
#line 3553
      tmp___5 = _glp_mpl_format_symbol(mpl, sym);
#line 3553
      _glp_mpl_error(mpl, (char *)"cannot convert %s to floating-point number", tmp___5);
      }
    }
  }
  {
#line 3557
  _glp_mpl_delete_symbol(mpl, sym);
  }
#line 3559
  goto switch_break;
  case_320: /* CIL Label */ 
  {
#line 3562
  value = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
  }
#line 3563
  goto switch_break;
  case_321: /* CIL Label */ 
  {
#line 3566
  tmp___7 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3566
  value = - tmp___7;
  }
#line 3567
  goto switch_break;
  case_323: /* CIL Label */ 
  {
#line 3570
  tmp___8 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3570
  value = fabs(tmp___8);
  }
#line 3571
  goto switch_break;
  case_324: /* CIL Label */ 
  {
#line 3574
  tmp___9 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3574
  value = ceil(tmp___9);
  }
#line 3575
  goto switch_break;
  case_325: /* CIL Label */ 
  {
#line 3578
  tmp___10 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3578
  value = floor(tmp___10);
  }
#line 3579
  goto switch_break;
  case_326: /* CIL Label */ 
  {
#line 3582
  tmp___11 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3582
  value = _glp_mpl_fp_exp(mpl, tmp___11);
  }
#line 3583
  goto switch_break;
  case_327: /* CIL Label */ 
  {
#line 3586
  tmp___12 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3586
  value = _glp_mpl_fp_log(mpl, tmp___12);
  }
#line 3587
  goto switch_break;
  case_328: /* CIL Label */ 
  {
#line 3590
  tmp___13 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3590
  value = _glp_mpl_fp_log10(mpl, tmp___13);
  }
#line 3591
  goto switch_break;
  case_329: /* CIL Label */ 
  {
#line 3594
  tmp___14 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3594
  value = _glp_mpl_fp_sqrt(mpl, tmp___14);
  }
#line 3595
  goto switch_break;
  case_330: /* CIL Label */ 
  {
#line 3598
  tmp___15 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3598
  value = _glp_mpl_fp_sin(mpl, tmp___15);
  }
#line 3599
  goto switch_break;
  case_331: /* CIL Label */ 
  {
#line 3602
  tmp___16 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3602
  value = _glp_mpl_fp_cos(mpl, tmp___16);
  }
#line 3603
  goto switch_break;
  case_332: /* CIL Label */ 
  {
#line 3606
  tmp___17 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3606
  value = _glp_mpl_fp_atan(mpl, tmp___17);
  }
#line 3607
  goto switch_break;
  case_345: /* CIL Label */ 
  {
#line 3610
  tmp___18 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3610
  tmp___19 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3610
  value = _glp_mpl_fp_atan2(mpl, tmp___19, tmp___18);
  }
#line 3613
  goto switch_break;
  case_333: /* CIL Label */ 
  {
#line 3616
  tmp___20 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3616
  value = _glp_mpl_fp_round(mpl, tmp___20, 0.0);
  }
#line 3618
  goto switch_break;
  case_346: /* CIL Label */ 
  {
#line 3621
  tmp___21 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3621
  tmp___22 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3621
  value = _glp_mpl_fp_round(mpl, tmp___22, tmp___21);
  }
#line 3624
  goto switch_break;
  case_334: /* CIL Label */ 
  {
#line 3627
  tmp___23 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3627
  value = _glp_mpl_fp_trunc(mpl, tmp___23, 0.0);
  }
#line 3629
  goto switch_break;
  case_347: /* CIL Label */ 
  {
#line 3632
  tmp___24 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3632
  tmp___25 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3632
  value = _glp_mpl_fp_trunc(mpl, tmp___25, tmp___24);
  }
#line 3635
  goto switch_break;
  case_337: /* CIL Label */ 
  {
#line 3638
  tmp___26 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3638
  tmp___27 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3638
  value = _glp_mpl_fp_add(mpl, tmp___27, tmp___26);
  }
#line 3641
  goto switch_break;
  case_338: /* CIL Label */ 
  {
#line 3644
  tmp___28 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3644
  tmp___29 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3644
  value = _glp_mpl_fp_sub(mpl, tmp___29, tmp___28);
  }
#line 3647
  goto switch_break;
  case_339: /* CIL Label */ 
  {
#line 3650
  tmp___30 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3650
  tmp___31 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3650
  value = _glp_mpl_fp_less(mpl, tmp___31, tmp___30);
  }
#line 3653
  goto switch_break;
  case_340: /* CIL Label */ 
  {
#line 3656
  tmp___32 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3656
  tmp___33 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3656
  value = _glp_mpl_fp_mul(mpl, tmp___33, tmp___32);
  }
#line 3659
  goto switch_break;
  case_341: /* CIL Label */ 
  {
#line 3662
  tmp___34 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3662
  tmp___35 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3662
  value = _glp_mpl_fp_div(mpl, tmp___35, tmp___34);
  }
#line 3665
  goto switch_break;
  case_342: /* CIL Label */ 
  {
#line 3668
  tmp___36 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3668
  tmp___37 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3668
  value = _glp_mpl_fp_idiv(mpl, tmp___37, tmp___36);
  }
#line 3671
  goto switch_break;
  case_343: /* CIL Label */ 
  {
#line 3674
  tmp___38 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3674
  tmp___39 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3674
  value = _glp_mpl_fp_mod(mpl, tmp___39, tmp___38);
  }
#line 3677
  goto switch_break;
  case_344: /* CIL Label */ 
  {
#line 3680
  tmp___40 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3680
  tmp___41 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3680
  value = _glp_mpl_fp_power(mpl, tmp___41, tmp___40);
  }
#line 3683
  goto switch_break;
  case_348: /* CIL Label */ 
  {
#line 3686
  tmp___42 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3686
  tmp___43 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3686
  value = _glp_mpl_uniform(mpl, tmp___43, tmp___42);
  }
#line 3689
  goto switch_break;
  case_349: /* CIL Label */ 
  {
#line 3692
  tmp___44 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3692
  tmp___45 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3692
  value = _glp_mpl_fp_normal(mpl, tmp___45, tmp___44);
  }
#line 3695
  goto switch_break;
  case_335: /* CIL Label */ 
  {
#line 3698
  set___0 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 3699
  value = (double )set___0->size;
#line 3700
  _glp_mpl_delete_array(mpl, set___0);
  }
#line 3702
  goto switch_break;
  case_336: /* CIL Label */ 
  {
#line 3706
  sym___0 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
  }
#line 3707
  if ((unsigned long )sym___0->str == (unsigned long )((void *)0)) {
    {
#line 3708
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%.*g",
            15, sym___0->num);
    }
  } else {
    {
#line 3710
    _glp_mpl_fetch_string(mpl, sym___0->str, (char *)(str));
    }
  }
  {
#line 3711
  _glp_mpl_delete_symbol(mpl, sym___0);
#line 3712
  tmp___46 = strlen((char const   *)(str));
#line 3712
  value = (double )tmp___46;
  }
#line 3714
  goto switch_break;
  case_369: /* CIL Label */ 
  {
#line 3718
  sym___1 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
  }
#line 3719
  if ((unsigned long )sym___1->str == (unsigned long )((void *)0)) {
    {
#line 3720
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"%.*g",
            15, sym___1->num);
    }
  } else {
    {
#line 3722
    _glp_mpl_fetch_string(mpl, sym___1->str, (char *)(str___0));
    }
  }
  {
#line 3723
  _glp_mpl_delete_symbol(mpl, sym___1);
#line 3724
  sym___1 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
  }
#line 3725
  if ((unsigned long )sym___1->str == (unsigned long )((void *)0)) {
    {
#line 3726
    sprintf((char */* __restrict  */)(fmt___0), (char const   */* __restrict  */)"%.*g",
            15, sym___1->num);
    }
  } else {
    {
#line 3728
    _glp_mpl_fetch_string(mpl, sym___1->str, (char *)(fmt___0));
    }
  }
  {
#line 3729
  _glp_mpl_delete_symbol(mpl, sym___1);
#line 3730
  value = _glp_mpl_fn_str2time(mpl, (char const   *)(str___0), (char const   *)(fmt___0));
  }
#line 3732
  goto switch_break;
  case_372: /* CIL Label */ 
  {
#line 3735
  tmp___47 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 3735
  if (tmp___47) {
    {
#line 3736
    value = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
    }
  } else
#line 3737
  if ((unsigned long )code->arg.arg.z == (unsigned long )((void *)0)) {
#line 3738
    value = 0.0;
  } else {
    {
#line 3740
    value = _glp_mpl_eval_numeric(mpl, code->arg.arg.z);
    }
  }
#line 3741
  goto switch_break;
  case_374: /* CIL Label */ 
#line 3746
  value = 1.7976931348623157e+308;
#line 3747
  e___1 = code->arg.list;
  {
#line 3747
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3747
    if (! ((unsigned long )e___1 != (unsigned long )((void *)0))) {
#line 3747
      goto while_break___1;
    }
    {
#line 3748
    temp = _glp_mpl_eval_numeric(mpl, e___1->x);
    }
#line 3749
    if (value > temp) {
#line 3749
      value = temp;
    }
#line 3747
    e___1 = e___1->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3752
  goto switch_break;
  case_375: /* CIL Label */ 
#line 3757
  value = - 1.7976931348623157e+308;
#line 3758
  e___2 = code->arg.list;
  {
#line 3758
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3758
    if (! ((unsigned long )e___2 != (unsigned long )((void *)0))) {
#line 3758
      goto while_break___2;
    }
    {
#line 3759
    temp___0 = _glp_mpl_eval_numeric(mpl, e___2->x);
    }
#line 3760
    if (value < temp___0) {
#line 3760
      value = temp___0;
    }
#line 3758
    e___2 = e___2->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3763
  goto switch_break;
  case_376: /* CIL Label */ 
  {
#line 3766
  info = & _info;
#line 3767
  info->code = code;
#line 3768
  info->value = 0.0;
#line 3769
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info, & iter_num_func);
#line 3771
  value = info->value;
  }
#line 3773
  goto switch_break;
  case_377: /* CIL Label */ 
  {
#line 3776
  info___0 = & _info___0;
#line 3777
  info___0->code = code;
#line 3778
  info___0->value = 1.0;
#line 3779
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info___0, & iter_num_func);
#line 3781
  value = info___0->value;
  }
#line 3783
  goto switch_break;
  case_378: /* CIL Label */ 
  {
#line 3786
  info___1 = & _info___1;
#line 3787
  info___1->code = code;
#line 3788
  info___1->value = 1.7976931348623157e+308;
#line 3789
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info___1, & iter_num_func);
  }
#line 3791
  if (info___1->value == 1.7976931348623157e+308) {
    {
#line 3792
    _glp_mpl_error(mpl, (char *)"min{} over empty set; result undefined");
    }
  }
#line 3793
  value = info___1->value;
#line 3795
  goto switch_break;
  case_379: /* CIL Label */ 
  {
#line 3798
  info___2 = & _info___2;
#line 3799
  info___2->code = code;
#line 3800
  info___2->value = - 1.7976931348623157e+308;
#line 3801
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info___2, & iter_num_func);
  }
#line 3803
  if (info___2->value == - 1.7976931348623157e+308) {
    {
#line 3804
    _glp_mpl_error(mpl, (char *)"max{} over empty set; result undefined");
    }
  }
#line 3805
  value = info___2->value;
#line 3807
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3809
  if ((unsigned long )code != (unsigned long )code) {
#line 3809
    tmp___48 = 1;
  } else {
    {
#line 3809
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3809);
#line 3809
    tmp___48 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 3812
  if (! code->valid) {
#line 3812
    tmp___49 = 1;
  } else {
    {
#line 3812
    _glp_lib_xassert("!code->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3812);
#line 3812
    tmp___49 = 1;
    }
  }
#line 3813
  code->valid = 1;
#line 3814
  code->value.num = value;
  done: 
#line 3815
  return (value);
}
}
#line 3824 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
SYMBOL *_glp_mpl_eval_symbolic(MPL *mpl , CODE *code ) 
{ 
  SYMBOL *value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  STRING *tmp___2 ;
  int tmp___3 ;
  TUPLE *tuple ;
  ARG_LIST *e ;
  SYMBOL *tmp___4 ;
  double tmp___5 ;
  SYMBOL *tmp___6 ;
  SYMBOL *tmp___7 ;
  int tmp___8 ;
  double pos ;
  double len ;
  char str[101] ;
  double tmp___9 ;
  size_t tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  size_t tmp___13 ;
  STRING *tmp___14 ;
  double num ;
  SYMBOL *sym ;
  char str___0[101] ;
  char fmt___0[101] ;
  STRING *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 3826
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 3826
    tmp = 1;
  } else {
    {
#line 3826
    _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3826);
#line 3826
    tmp = 1;
    }
  }
#line 3827
  if (code->type == 124) {
#line 3827
    tmp___0 = 1;
  } else {
    {
#line 3827
    _glp_lib_xassert("code->type == A_SYMBOLIC", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3827);
#line 3827
    tmp___0 = 1;
    }
  }
#line 3828
  if (code->dim == 0) {
#line 3828
    tmp___1 = 1;
  } else {
    {
#line 3828
    _glp_lib_xassert("code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3828);
#line 3828
    tmp___1 = 1;
    }
  }
#line 3831
  if (code->vflag) {
#line 3831
    if (code->valid) {
      {
#line 3832
      code->valid = 0;
#line 3833
      _glp_mpl_delete_value(mpl, code->type, & code->value);
      }
    }
  }
#line 3836
  if (code->valid) {
    {
#line 3837
    value = _glp_mpl_copy_symbol(mpl, code->value.sym);
    }
#line 3838
    goto done;
  }
  {
#line 3842
  if (code->op == 302) {
#line 3842
    goto case_302;
  }
#line 3847
  if (code->op == 303) {
#line 3847
    goto case_303;
  }
#line 3852
  if (code->op == 305) {
#line 3852
    goto case_305;
  }
#line 3864
  if (code->op == 316) {
#line 3864
    goto case_316;
  }
#line 3869
  if (code->op == 350) {
#line 3869
    goto case_350;
  }
#line 3875
  if (code->op == 372) {
#line 3875
    goto case_372;
  }
#line 3885
  if (code->op == 373) {
#line 3885
    goto case_373;
  }
#line 3885
  if (code->op == 368) {
#line 3885
    goto case_373;
  }
#line 3919
  if (code->op == 370) {
#line 3919
    goto case_370;
  }
#line 3934
  goto switch_default;
  case_302: /* CIL Label */ 
  {
#line 3844
  tmp___2 = _glp_mpl_create_string(mpl, (char *)code->arg.str);
#line 3844
  value = _glp_mpl_create_symbol_str(mpl, tmp___2);
  }
#line 3846
  goto switch_break;
  case_303: /* CIL Label */ 
#line 3849
  if ((unsigned long )(code->arg.index.slot)->value != (unsigned long )((void *)0)) {
#line 3849
    tmp___3 = 1;
  } else {
    {
#line 3849
    _glp_lib_xassert("code->arg.index.slot->value != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3849);
#line 3849
    tmp___3 = 1;
    }
  }
  {
#line 3850
  value = _glp_mpl_copy_symbol(mpl, (code->arg.index.slot)->value);
  }
#line 3851
  goto switch_break;
  case_305: /* CIL Label */ 
  {
#line 3856
  tuple = _glp_mpl_create_tuple(mpl);
#line 3857
  e = code->arg.par.list;
  }
  {
#line 3857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3857
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 3857
      goto while_break;
    }
    {
#line 3858
    tmp___4 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 3858
    tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___4);
#line 3857
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3860
  value = _glp_mpl_eval_member_sym(mpl, code->arg.par.par, tuple);
#line 3861
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 3863
  goto switch_break;
  case_316: /* CIL Label */ 
  {
#line 3866
  tmp___5 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3866
  value = _glp_mpl_create_symbol_num(mpl, tmp___5);
  }
#line 3868
  goto switch_break;
  case_350: /* CIL Label */ 
  {
#line 3871
  tmp___6 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
#line 3871
  tmp___7 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 3871
  value = _glp_mpl_concat_symbols(mpl, tmp___7, tmp___6);
  }
#line 3874
  goto switch_break;
  case_372: /* CIL Label */ 
  {
#line 3877
  tmp___8 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 3877
  if (tmp___8) {
    {
#line 3878
    value = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
    }
  } else
#line 3879
  if ((unsigned long )code->arg.arg.z == (unsigned long )((void *)0)) {
    {
#line 3880
    value = _glp_mpl_create_symbol_num(mpl, 0.0);
    }
  } else {
    {
#line 3882
    value = _glp_mpl_eval_symbolic(mpl, code->arg.arg.z);
    }
  }
#line 3883
  goto switch_break;
  case_373: /* CIL Label */ 
  case_368: /* CIL Label */ 
  {
#line 3888
  value = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
  }
#line 3889
  if ((unsigned long )value->str == (unsigned long )((void *)0)) {
    {
#line 3890
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%.*g",
            15, value->num);
    }
  } else {
    {
#line 3892
    _glp_mpl_fetch_string(mpl, value->str, (char *)(str));
    }
  }
  {
#line 3893
  _glp_mpl_delete_symbol(mpl, value);
  }
#line 3894
  if (code->op == 368) {
    {
#line 3895
    pos = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3896
    tmp___9 = floor(pos);
    }
#line 3896
    if (pos != tmp___9) {
      {
#line 3897
      _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g); non-integer second argument",
                     15, pos);
      }
    }
#line 3899
    if (pos < (double )1) {
      {
#line 3900
      _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g); substring out of range",
                     15, pos);
      }
    } else {
      {
#line 3899
      tmp___10 = strlen((char const   *)(str));
      }
#line 3899
      if (pos > (double )(tmp___10 + 1U)) {
        {
#line 3900
        _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g); substring out of range",
                       15, pos);
        }
      }
    }
  } else {
    {
#line 3904
    pos = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 3905
    len = _glp_mpl_eval_numeric(mpl, code->arg.arg.z);
#line 3906
    tmp___11 = floor(pos);
    }
#line 3906
    if (pos != tmp___11) {
      {
#line 3907
      _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g, %.*g); non-integer second and/or third argument",
                     15, pos, 15, len);
      }
    } else {
      {
#line 3906
      tmp___12 = floor(len);
      }
#line 3906
      if (len != tmp___12) {
        {
#line 3907
        _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g, %.*g); non-integer second and/or third argument",
                       15, pos, 15, len);
        }
      }
    }
#line 3910
    if (pos < (double )1) {
      {
#line 3911
      _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g, %.*g); substring out of range",
                     15, pos, 15, len);
      }
    } else
#line 3910
    if (len < (double )0) {
      {
#line 3911
      _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g, %.*g); substring out of range",
                     15, pos, 15, len);
      }
    } else {
      {
#line 3910
      tmp___13 = strlen((char const   *)(str));
      }
#line 3910
      if (pos + len > (double )(tmp___13 + 1U)) {
        {
#line 3911
        _glp_mpl_error(mpl, (char *)"substr(\'...\', %.*g, %.*g); substring out of range",
                       15, pos, 15, len);
        }
      }
    }
#line 3913
    str[((int )pos + (int )len) - 1] = (char )'\000';
  }
  {
#line 3915
  tmp___14 = _glp_mpl_create_string(mpl, (char *)((str + (int )pos) - 1));
#line 3915
  value = _glp_mpl_create_symbol_str(mpl, tmp___14);
  }
#line 3918
  goto switch_break;
  case_370: /* CIL Label */ 
  {
#line 3923
  num = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3924
  sym = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
  }
#line 3925
  if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
    {
#line 3926
    sprintf((char */* __restrict  */)(fmt___0), (char const   */* __restrict  */)"%.*g",
            15, sym->num);
    }
  } else {
    {
#line 3928
    _glp_mpl_fetch_string(mpl, sym->str, (char *)(fmt___0));
    }
  }
  {
#line 3929
  _glp_mpl_delete_symbol(mpl, sym);
#line 3930
  _glp_mpl_fn_time2str(mpl, str___0, num, (char const   *)(fmt___0));
#line 3931
  tmp___15 = _glp_mpl_create_string(mpl, (char *)(str___0));
#line 3931
  value = _glp_mpl_create_symbol_str(mpl, tmp___15);
  }
#line 3933
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3935
  if ((unsigned long )code != (unsigned long )code) {
#line 3935
    tmp___16 = 1;
  } else {
    {
#line 3935
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3935);
#line 3935
    tmp___16 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 3938
  if (! code->valid) {
#line 3938
    tmp___17 = 1;
  } else {
    {
#line 3938
    _glp_lib_xassert("!code->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3938);
#line 3938
    tmp___17 = 1;
    }
  }
  {
#line 3939
  code->valid = 1;
#line 3940
  code->value.sym = _glp_mpl_copy_symbol(mpl, value);
  }
  done: 
#line 3941
  return (value);
}
}
#line 3958 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int iter_log_func(MPL *mpl , void *_info ) 
{ 
  struct iter_log_info *info ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3961
  info = (struct iter_log_info *)_info;
#line 3962
  ret = 0;
  {
#line 3964
  if ((info->code)->op == 380) {
#line 3964
    goto case_380;
  }
#line 3969
  if ((info->code)->op == 381) {
#line 3969
    goto case_381;
  }
#line 3974
  goto switch_default;
  case_380: /* CIL Label */ 
  {
#line 3966
  tmp = _glp_mpl_eval_logical(mpl, (info->code)->arg.loop.x);
#line 3966
  info->value &= tmp;
  }
#line 3967
  if (! info->value) {
#line 3967
    ret = 1;
  }
#line 3968
  goto switch_break;
  case_381: /* CIL Label */ 
  {
#line 3971
  tmp___0 = _glp_mpl_eval_logical(mpl, (info->code)->arg.loop.x);
#line 3971
  info->value |= tmp___0;
  }
#line 3972
  if (info->value) {
#line 3972
    ret = 1;
  }
#line 3973
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3975
  if ((unsigned long )info != (unsigned long )info) {
#line 3975
    tmp___1 = 1;
  } else {
    {
#line 3975
    _glp_lib_xassert("info != info", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3975);
#line 3975
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 3977
  return (ret);
}
}
#line 3980 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_eval_logical(MPL *mpl , CODE *code ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  SYMBOL *sym1 ;
  SYMBOL *tmp___7 ;
  SYMBOL *sym2 ;
  SYMBOL *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  SYMBOL *sym1___0 ;
  SYMBOL *tmp___13 ;
  SYMBOL *sym2___0 ;
  SYMBOL *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  SYMBOL *sym1___1 ;
  SYMBOL *tmp___19 ;
  SYMBOL *sym2___1 ;
  SYMBOL *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  SYMBOL *sym1___2 ;
  SYMBOL *tmp___25 ;
  SYMBOL *sym2___2 ;
  SYMBOL *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  SYMBOL *sym1___3 ;
  SYMBOL *tmp___31 ;
  SYMBOL *sym2___3 ;
  SYMBOL *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  double tmp___35 ;
  double tmp___36 ;
  SYMBOL *sym1___4 ;
  SYMBOL *tmp___37 ;
  SYMBOL *sym2___4 ;
  SYMBOL *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  TUPLE *tuple ;
  TUPLE *tuple___0 ;
  int tmp___46 ;
  int tmp___47 ;
  ELEMSET *set___0 ;
  MEMBER *memb ;
  int tmp___48 ;
  ELEMSET *set___1 ;
  MEMBER *memb___0 ;
  int tmp___49 ;
  struct iter_log_info _info ;
  struct iter_log_info *info ;
  struct iter_log_info _info___0 ;
  struct iter_log_info *info___0 ;
  int tmp___50 ;
  int tmp___51 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;

  {
#line 3982
  if (code->type == 114) {
#line 3982
    tmp = 1;
  } else {
    {
#line 3982
    _glp_lib_xassert("code->type == A_LOGICAL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3982);
#line 3982
    tmp = 1;
    }
  }
#line 3983
  if (code->dim == 0) {
#line 3983
    tmp___0 = 1;
  } else {
    {
#line 3983
    _glp_lib_xassert("code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     3983);
#line 3983
    tmp___0 = 1;
    }
  }
#line 3986
  if (code->vflag) {
#line 3986
    if (code->valid) {
      {
#line 3987
      code->valid = 0;
#line 3988
      _glp_mpl_delete_value(mpl, code->type, & code->value);
      }
    }
  }
#line 3991
  if (code->valid) {
#line 3992
    value = code->value.bit;
#line 3993
    goto done;
  }
  {
#line 3997
  if (code->op == 317) {
#line 3997
    goto case_317;
  }
#line 4001
  if (code->op == 322) {
#line 4001
    goto case_322;
  }
#line 4005
  if (code->op == 351) {
#line 4005
    goto case_351;
  }
#line 4024
  if (code->op == 352) {
#line 4024
    goto case_352;
  }
#line 4043
  if (code->op == 353) {
#line 4043
    goto case_353;
  }
#line 4057
  if (code->op == 354) {
#line 4057
    goto case_354;
  }
#line 4076
  if (code->op == 355) {
#line 4076
    goto case_355;
  }
#line 4095
  if (code->op == 356) {
#line 4095
    goto case_356;
  }
#line 4109
  if (code->op == 357) {
#line 4109
    goto case_357;
  }
#line 4114
  if (code->op == 358) {
#line 4114
    goto case_358;
  }
#line 4119
  if (code->op == 364) {
#line 4119
    goto case_364;
  }
#line 4127
  if (code->op == 365) {
#line 4127
    goto case_365;
  }
#line 4135
  if (code->op == 366) {
#line 4135
    goto case_366;
  }
#line 4150
  if (code->op == 367) {
#line 4150
    goto case_367;
  }
#line 4165
  if (code->op == 380) {
#line 4165
    goto case_380;
  }
#line 4175
  if (code->op == 381) {
#line 4175
    goto case_381;
  }
#line 4185
  goto switch_default;
  case_317: /* CIL Label */ 
  {
#line 3999
  tmp___1 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 3999
  value = tmp___1 != 0.0;
  }
#line 4000
  goto switch_break;
  case_322: /* CIL Label */ 
  {
#line 4003
  tmp___2 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 4003
  if (tmp___2) {
#line 4003
    tmp___3 = 0;
  } else {
#line 4003
    tmp___3 = 1;
  }
#line 4003
  value = tmp___3;
#line 4004
  goto switch_break;
  case_351: /* CIL Label */ 
#line 4011
  if ((unsigned long )code->arg.arg.x != (unsigned long )((void *)0)) {
#line 4011
    tmp___4 = 1;
  } else {
    {
#line 4011
    _glp_lib_xassert("code->arg.arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4011);
#line 4011
    tmp___4 = 1;
    }
  }
#line 4012
  if ((code->arg.arg.x)->type == 118) {
    {
#line 4013
    tmp___5 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4013
    tmp___6 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4013
    value = tmp___5 < tmp___6;
    }
  } else {
    {
#line 4016
    tmp___7 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 4016
    sym1 = tmp___7;
#line 4017
    tmp___8 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
#line 4017
    sym2 = tmp___8;
#line 4018
    tmp___9 = _glp_mpl_compare_symbols(mpl, sym1, sym2);
#line 4018
    value = tmp___9 < 0;
#line 4019
    _glp_mpl_delete_symbol(mpl, sym1);
#line 4020
    _glp_mpl_delete_symbol(mpl, sym2);
    }
  }
#line 4023
  goto switch_break;
  case_352: /* CIL Label */ 
#line 4030
  if ((unsigned long )code->arg.arg.x != (unsigned long )((void *)0)) {
#line 4030
    tmp___10 = 1;
  } else {
    {
#line 4030
    _glp_lib_xassert("code->arg.arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4030);
#line 4030
    tmp___10 = 1;
    }
  }
#line 4031
  if ((code->arg.arg.x)->type == 118) {
    {
#line 4032
    tmp___11 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4032
    tmp___12 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4032
    value = tmp___11 <= tmp___12;
    }
  } else {
    {
#line 4035
    tmp___13 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 4035
    sym1___0 = tmp___13;
#line 4036
    tmp___14 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
#line 4036
    sym2___0 = tmp___14;
#line 4037
    tmp___15 = _glp_mpl_compare_symbols(mpl, sym1___0, sym2___0);
#line 4037
    value = tmp___15 <= 0;
#line 4038
    _glp_mpl_delete_symbol(mpl, sym1___0);
#line 4039
    _glp_mpl_delete_symbol(mpl, sym2___0);
    }
  }
#line 4042
  goto switch_break;
  case_353: /* CIL Label */ 
#line 4045
  if ((unsigned long )code->arg.arg.x != (unsigned long )((void *)0)) {
#line 4045
    tmp___16 = 1;
  } else {
    {
#line 4045
    _glp_lib_xassert("code->arg.arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4045);
#line 4045
    tmp___16 = 1;
    }
  }
#line 4046
  if ((code->arg.arg.x)->type == 118) {
    {
#line 4047
    tmp___17 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4047
    tmp___18 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4047
    value = tmp___17 == tmp___18;
    }
  } else {
    {
#line 4050
    tmp___19 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 4050
    sym1___1 = tmp___19;
#line 4051
    tmp___20 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
#line 4051
    sym2___1 = tmp___20;
#line 4052
    tmp___21 = _glp_mpl_compare_symbols(mpl, sym1___1, sym2___1);
#line 4052
    value = tmp___21 == 0;
#line 4053
    _glp_mpl_delete_symbol(mpl, sym1___1);
#line 4054
    _glp_mpl_delete_symbol(mpl, sym2___1);
    }
  }
#line 4056
  goto switch_break;
  case_354: /* CIL Label */ 
#line 4063
  if ((unsigned long )code->arg.arg.x != (unsigned long )((void *)0)) {
#line 4063
    tmp___22 = 1;
  } else {
    {
#line 4063
    _glp_lib_xassert("code->arg.arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4063);
#line 4063
    tmp___22 = 1;
    }
  }
#line 4064
  if ((code->arg.arg.x)->type == 118) {
    {
#line 4065
    tmp___23 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4065
    tmp___24 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4065
    value = tmp___23 >= tmp___24;
    }
  } else {
    {
#line 4068
    tmp___25 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 4068
    sym1___2 = tmp___25;
#line 4069
    tmp___26 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
#line 4069
    sym2___2 = tmp___26;
#line 4070
    tmp___27 = _glp_mpl_compare_symbols(mpl, sym1___2, sym2___2);
#line 4070
    value = tmp___27 >= 0;
#line 4071
    _glp_mpl_delete_symbol(mpl, sym1___2);
#line 4072
    _glp_mpl_delete_symbol(mpl, sym2___2);
    }
  }
#line 4075
  goto switch_break;
  case_355: /* CIL Label */ 
#line 4082
  if ((unsigned long )code->arg.arg.x != (unsigned long )((void *)0)) {
#line 4082
    tmp___28 = 1;
  } else {
    {
#line 4082
    _glp_lib_xassert("code->arg.arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4082);
#line 4082
    tmp___28 = 1;
    }
  }
#line 4083
  if ((code->arg.arg.x)->type == 118) {
    {
#line 4084
    tmp___29 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4084
    tmp___30 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4084
    value = tmp___29 > tmp___30;
    }
  } else {
    {
#line 4087
    tmp___31 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 4087
    sym1___3 = tmp___31;
#line 4088
    tmp___32 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
#line 4088
    sym2___3 = tmp___32;
#line 4089
    tmp___33 = _glp_mpl_compare_symbols(mpl, sym1___3, sym2___3);
#line 4089
    value = tmp___33 > 0;
#line 4090
    _glp_mpl_delete_symbol(mpl, sym1___3);
#line 4091
    _glp_mpl_delete_symbol(mpl, sym2___3);
    }
  }
#line 4094
  goto switch_break;
  case_356: /* CIL Label */ 
#line 4097
  if ((unsigned long )code->arg.arg.x != (unsigned long )((void *)0)) {
#line 4097
    tmp___34 = 1;
  } else {
    {
#line 4097
    _glp_lib_xassert("code->arg.arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4097);
#line 4097
    tmp___34 = 1;
    }
  }
#line 4098
  if ((code->arg.arg.x)->type == 118) {
    {
#line 4099
    tmp___35 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4099
    tmp___36 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4099
    value = tmp___35 != tmp___36;
    }
  } else {
    {
#line 4102
    tmp___37 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 4102
    sym1___4 = tmp___37;
#line 4103
    tmp___38 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.y);
#line 4103
    sym2___4 = tmp___38;
#line 4104
    tmp___39 = _glp_mpl_compare_symbols(mpl, sym1___4, sym2___4);
#line 4104
    value = tmp___39 != 0;
#line 4105
    _glp_mpl_delete_symbol(mpl, sym1___4);
#line 4106
    _glp_mpl_delete_symbol(mpl, sym2___4);
    }
  }
#line 4108
  goto switch_break;
  case_357: /* CIL Label */ 
  {
#line 4111
  tmp___40 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 4111
  if (tmp___40) {
    {
#line 4111
    tmp___41 = _glp_mpl_eval_logical(mpl, code->arg.arg.y);
    }
#line 4111
    if (tmp___41) {
#line 4111
      tmp___42 = 1;
    } else {
#line 4111
      tmp___42 = 0;
    }
  } else {
#line 4111
    tmp___42 = 0;
  }
#line 4111
  value = tmp___42;
#line 4113
  goto switch_break;
  case_358: /* CIL Label */ 
  {
#line 4116
  tmp___43 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 4116
  if (tmp___43) {
#line 4116
    tmp___45 = 1;
  } else {
    {
#line 4116
    tmp___44 = _glp_mpl_eval_logical(mpl, code->arg.arg.y);
    }
#line 4116
    if (tmp___44) {
#line 4116
      tmp___45 = 1;
    } else {
#line 4116
      tmp___45 = 0;
    }
  }
#line 4116
  value = tmp___45;
#line 4118
  goto switch_break;
  case_364: /* CIL Label */ 
  {
#line 4122
  tuple = _glp_mpl_eval_tuple(mpl, code->arg.arg.x);
#line 4123
  value = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple);
#line 4124
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 4126
  goto switch_break;
  case_365: /* CIL Label */ 
  {
#line 4130
  tuple___0 = _glp_mpl_eval_tuple(mpl, code->arg.arg.x);
#line 4131
  tmp___46 = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple___0);
  }
#line 4131
  if (tmp___46) {
#line 4131
    tmp___47 = 0;
  } else {
#line 4131
    tmp___47 = 1;
  }
  {
#line 4131
  value = tmp___47;
#line 4132
  _glp_mpl_delete_tuple(mpl, tuple___0);
  }
#line 4134
  goto switch_break;
  case_366: /* CIL Label */ 
  {
#line 4139
  set___0 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 4140
  value = 1;
#line 4141
  memb = set___0->head;
  }
  {
#line 4141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4141
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 4141
      goto while_break;
    }
    {
#line 4142
    tmp___48 = _glp_mpl_is_member(mpl, code->arg.arg.y, memb->tuple);
    }
#line 4142
    if (! tmp___48) {
#line 4143
      value = 0;
#line 4144
      goto while_break;
    }
#line 4141
    memb = memb->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4147
  _glp_mpl_delete_elemset(mpl, set___0);
  }
#line 4149
  goto switch_break;
  case_367: /* CIL Label */ 
  {
#line 4154
  set___1 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 4155
  value = 1;
#line 4156
  memb___0 = set___1->head;
  }
  {
#line 4156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4156
    if (! ((unsigned long )memb___0 != (unsigned long )((void *)0))) {
#line 4156
      goto while_break___0;
    }
    {
#line 4157
    tmp___49 = _glp_mpl_is_member(mpl, code->arg.arg.y, memb___0->tuple);
    }
#line 4157
    if (tmp___49) {
#line 4158
      value = 0;
#line 4159
      goto while_break___0;
    }
#line 4156
    memb___0 = memb___0->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4162
  _glp_mpl_delete_elemset(mpl, set___1);
  }
#line 4164
  goto switch_break;
  case_380: /* CIL Label */ 
  {
#line 4167
  info = & _info;
#line 4168
  info->code = code;
#line 4169
  info->value = 1;
#line 4170
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info, & iter_log_func);
#line 4172
  value = info->value;
  }
#line 4174
  goto switch_break;
  case_381: /* CIL Label */ 
  {
#line 4177
  info___0 = & _info___0;
#line 4178
  info___0->code = code;
#line 4179
  info___0->value = 0;
#line 4180
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info___0, & iter_log_func);
#line 4182
  value = info___0->value;
  }
#line 4184
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4186
  if ((unsigned long )code != (unsigned long )code) {
#line 4186
    tmp___50 = 1;
  } else {
    {
#line 4186
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4186);
#line 4186
    tmp___50 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 4189
  if (! code->valid) {
#line 4189
    tmp___51 = 1;
  } else {
    {
#line 4189
    _glp_lib_xassert("!code->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4189);
#line 4189
    tmp___51 = 1;
    }
  }
#line 4190
  code->valid = 1;
#line 4191
  code->value.bit = value;
  done: 
#line 4192
  return (value);
}
}
#line 4201 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
TUPLE *_glp_mpl_eval_tuple(MPL *mpl , CODE *code ) 
{ 
  TUPLE *value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ARG_LIST *e ;
  SYMBOL *tmp___2 ;
  SYMBOL *tmp___3 ;
  TUPLE *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 4203
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 4203
    tmp = 1;
  } else {
    {
#line 4203
    _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4203);
#line 4203
    tmp = 1;
    }
  }
#line 4204
  if (code->type == 126) {
#line 4204
    tmp___0 = 1;
  } else {
    {
#line 4204
    _glp_lib_xassert("code->type == A_TUPLE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4204);
#line 4204
    tmp___0 = 1;
    }
  }
#line 4205
  if (code->dim > 0) {
#line 4205
    tmp___1 = 1;
  } else {
    {
#line 4205
    _glp_lib_xassert("code->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4205);
#line 4205
    tmp___1 = 1;
    }
  }
#line 4208
  if (code->vflag) {
#line 4208
    if (code->valid) {
      {
#line 4209
      code->valid = 0;
#line 4210
      _glp_mpl_delete_value(mpl, code->type, & code->value);
      }
    }
  }
#line 4213
  if (code->valid) {
    {
#line 4214
    value = _glp_mpl_copy_tuple(mpl, code->value.tuple);
    }
#line 4215
    goto done;
  }
  {
#line 4219
  if (code->op == 308) {
#line 4219
    goto case_308;
  }
#line 4228
  if (code->op == 318) {
#line 4228
    goto case_318;
  }
#line 4233
  goto switch_default;
  case_308: /* CIL Label */ 
  {
#line 4222
  value = _glp_mpl_create_tuple(mpl);
#line 4223
  e = code->arg.list;
  }
  {
#line 4223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4223
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4223
      goto while_break;
    }
    {
#line 4224
    tmp___2 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 4224
    value = _glp_mpl_expand_tuple(mpl, value, tmp___2);
#line 4223
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4227
  goto switch_break;
  case_318: /* CIL Label */ 
  {
#line 4230
  tmp___3 = _glp_mpl_eval_symbolic(mpl, code->arg.arg.x);
#line 4230
  tmp___4 = _glp_mpl_create_tuple(mpl);
#line 4230
  value = _glp_mpl_expand_tuple(mpl, tmp___4, tmp___3);
  }
#line 4232
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4234
  if ((unsigned long )code != (unsigned long )code) {
#line 4234
    tmp___5 = 1;
  } else {
    {
#line 4234
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4234);
#line 4234
    tmp___5 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 4237
  if (! code->valid) {
#line 4237
    tmp___6 = 1;
  } else {
    {
#line 4237
    _glp_lib_xassert("!code->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4237);
#line 4237
    tmp___6 = 1;
    }
  }
  {
#line 4238
  code->valid = 1;
#line 4239
  code->value.tuple = _glp_mpl_copy_tuple(mpl, value);
  }
  done: 
#line 4240
  return (value);
}
}
#line 4257 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int iter_set_func(MPL *mpl , void *_info ) 
{ 
  struct iter_set_info *info ;
  TUPLE *tuple ;
  MEMBER *tmp ;
  TUPLE *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4260
  info = (struct iter_set_info *)_info;
  {
#line 4263
  if ((info->code)->op == 382) {
#line 4263
    goto case_382;
  }
#line 4272
  if ((info->code)->op == 383) {
#line 4272
    goto case_383;
  }
#line 4279
  goto switch_default;
  case_382: /* CIL Label */ 
  {
#line 4266
  tuple = _glp_mpl_eval_tuple(mpl, (info->code)->arg.loop.x);
#line 4267
  tmp = _glp_mpl_find_tuple(mpl, info->value, tuple);
  }
#line 4267
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 4268
    _glp_mpl_add_tuple(mpl, info->value, tuple);
    }
  } else {
    {
#line 4270
    _glp_mpl_delete_tuple(mpl, tuple);
    }
  }
#line 4271
  goto switch_break;
  case_383: /* CIL Label */ 
  {
#line 4276
  tmp___0 = _glp_mpl_get_domain_tuple(mpl, (info->code)->arg.loop.domain);
#line 4276
  _glp_mpl_add_tuple(mpl, info->value, tmp___0);
  }
#line 4278
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4280
  if ((unsigned long )info != (unsigned long )info) {
#line 4280
    tmp___1 = 1;
  } else {
    {
#line 4280
    _glp_lib_xassert("info != info", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4280);
#line 4280
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 4282
  return (0);
}
}
#line 4285 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
ELEMSET *_glp_mpl_eval_elemset(MPL *mpl , CODE *code ) 
{ 
  ELEMSET *value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  TUPLE *tuple ;
  ARG_LIST *e ;
  SYMBOL *tmp___2 ;
  ELEMSET *tmp___3 ;
  ARG_LIST *e___0 ;
  TUPLE *tmp___4 ;
  ELEMSET *tmp___5 ;
  ELEMSET *tmp___6 ;
  ELEMSET *tmp___7 ;
  ELEMSET *tmp___8 ;
  ELEMSET *tmp___9 ;
  ELEMSET *tmp___10 ;
  ELEMSET *tmp___11 ;
  ELEMSET *tmp___12 ;
  ELEMSET *tmp___13 ;
  ELEMSET *tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  int tmp___19 ;
  struct iter_set_info _info ;
  struct iter_set_info *info ;
  struct iter_set_info _info___0 ;
  struct iter_set_info *info___0 ;
  int tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 4287
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 4287
    tmp = 1;
  } else {
    {
#line 4287
    _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4287);
#line 4287
    tmp = 1;
    }
  }
#line 4288
  if (code->type == 106) {
#line 4288
    tmp___0 = 1;
  } else {
    {
#line 4288
    _glp_lib_xassert("code->type == A_ELEMSET", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4288);
#line 4288
    tmp___0 = 1;
    }
  }
#line 4289
  if (code->dim > 0) {
#line 4289
    tmp___1 = 1;
  } else {
    {
#line 4289
    _glp_lib_xassert("code->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4289);
#line 4289
    tmp___1 = 1;
    }
  }
#line 4292
  if (code->vflag) {
#line 4292
    if (code->valid) {
      {
#line 4293
      code->valid = 0;
#line 4294
      _glp_mpl_delete_value(mpl, code->type, & code->value);
      }
    }
  }
#line 4297
  if (code->valid) {
    {
#line 4298
    value = _glp_mpl_copy_elemset(mpl, code->value.set);
    }
#line 4299
    goto done;
  }
  {
#line 4303
  if (code->op == 306) {
#line 4303
    goto case_306;
  }
#line 4316
  if (code->op == 309) {
#line 4316
    goto case_309;
  }
#line 4324
  if (code->op == 359) {
#line 4324
    goto case_359;
  }
#line 4330
  if (code->op == 360) {
#line 4330
    goto case_360;
  }
#line 4336
  if (code->op == 361) {
#line 4336
    goto case_361;
  }
#line 4342
  if (code->op == 362) {
#line 4342
    goto case_362;
  }
#line 4348
  if (code->op == 363) {
#line 4348
    goto case_363;
  }
#line 4354
  if (code->op == 371) {
#line 4354
    goto case_371;
  }
#line 4362
  if (code->op == 372) {
#line 4362
    goto case_372;
  }
#line 4369
  if (code->op == 382) {
#line 4369
    goto case_382;
  }
#line 4379
  if (code->op == 383) {
#line 4379
    goto case_383;
  }
#line 4389
  goto switch_default;
  case_306: /* CIL Label */ 
  {
#line 4307
  tuple = _glp_mpl_create_tuple(mpl);
#line 4308
  e = code->arg.set.list;
  }
  {
#line 4308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4308
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4308
      goto while_break;
    }
    {
#line 4309
    tmp___2 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 4309
    tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___2);
#line 4308
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4311
  tmp___3 = _glp_mpl_eval_member_set(mpl, code->arg.set.set, tuple);
#line 4311
  value = _glp_mpl_copy_elemset(mpl, tmp___3);
#line 4313
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 4315
  goto switch_break;
  case_309: /* CIL Label */ 
  {
#line 4319
  value = _glp_mpl_create_elemset(mpl, code->dim);
#line 4320
  e___0 = code->arg.list;
  }
  {
#line 4320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4320
    if (! ((unsigned long )e___0 != (unsigned long )((void *)0))) {
#line 4320
      goto while_break___0;
    }
    {
#line 4321
    tmp___4 = _glp_mpl_eval_tuple(mpl, e___0->x);
#line 4321
    _glp_mpl_check_then_add(mpl, value, tmp___4);
#line 4320
    e___0 = e___0->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4323
  goto switch_break;
  case_359: /* CIL Label */ 
  {
#line 4326
  tmp___5 = _glp_mpl_eval_elemset(mpl, code->arg.arg.y);
#line 4326
  tmp___6 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 4326
  value = _glp_mpl_set_union(mpl, tmp___6, tmp___5);
  }
#line 4329
  goto switch_break;
  case_360: /* CIL Label */ 
  {
#line 4332
  tmp___7 = _glp_mpl_eval_elemset(mpl, code->arg.arg.y);
#line 4332
  tmp___8 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 4332
  value = _glp_mpl_set_diff(mpl, tmp___8, tmp___7);
  }
#line 4335
  goto switch_break;
  case_361: /* CIL Label */ 
  {
#line 4338
  tmp___9 = _glp_mpl_eval_elemset(mpl, code->arg.arg.y);
#line 4338
  tmp___10 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 4338
  value = _glp_mpl_set_symdiff(mpl, tmp___10, tmp___9);
  }
#line 4341
  goto switch_break;
  case_362: /* CIL Label */ 
  {
#line 4344
  tmp___11 = _glp_mpl_eval_elemset(mpl, code->arg.arg.y);
#line 4344
  tmp___12 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 4344
  value = _glp_mpl_set_inter(mpl, tmp___12, tmp___11);
  }
#line 4347
  goto switch_break;
  case_363: /* CIL Label */ 
  {
#line 4350
  tmp___13 = _glp_mpl_eval_elemset(mpl, code->arg.arg.y);
#line 4350
  tmp___14 = _glp_mpl_eval_elemset(mpl, code->arg.arg.x);
#line 4350
  value = _glp_mpl_set_cross(mpl, tmp___14, tmp___13);
  }
#line 4353
  goto switch_break;
  case_371: /* CIL Label */ 
#line 4356
  if ((unsigned long )code->arg.arg.z == (unsigned long )((void *)0)) {
#line 4356
    tmp___16 = 1.0;
  } else {
    {
#line 4356
    tmp___15 = _glp_mpl_eval_numeric(mpl, code->arg.arg.z);
#line 4356
    tmp___16 = tmp___15;
    }
  }
  {
#line 4356
  tmp___17 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4356
  tmp___18 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4356
  value = _glp_mpl_create_arelset(mpl, tmp___18, tmp___17, tmp___16);
  }
#line 4361
  goto switch_break;
  case_372: /* CIL Label */ 
  {
#line 4364
  tmp___19 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 4364
  if (tmp___19) {
    {
#line 4365
    value = _glp_mpl_eval_elemset(mpl, code->arg.arg.y);
    }
  } else {
    {
#line 4367
    value = _glp_mpl_eval_elemset(mpl, code->arg.arg.z);
    }
  }
#line 4368
  goto switch_break;
  case_382: /* CIL Label */ 
  {
#line 4371
  info = & _info;
#line 4372
  info->code = code;
#line 4373
  info->value = _glp_mpl_create_elemset(mpl, code->dim);
#line 4374
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info, & iter_set_func);
#line 4376
  value = info->value;
  }
#line 4378
  goto switch_break;
  case_383: /* CIL Label */ 
  {
#line 4381
  info___0 = & _info___0;
#line 4382
  info___0->code = code;
#line 4383
  info___0->value = _glp_mpl_create_elemset(mpl, code->dim);
#line 4384
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info___0, & iter_set_func);
#line 4386
  value = info___0->value;
  }
#line 4388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4390
  if ((unsigned long )code != (unsigned long )code) {
#line 4390
    tmp___20 = 1;
  } else {
    {
#line 4390
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4390);
#line 4390
    tmp___20 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 4393
  if (! code->valid) {
#line 4393
    tmp___21 = 1;
  } else {
    {
#line 4393
    _glp_lib_xassert("!code->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4393);
#line 4393
    tmp___21 = 1;
    }
  }
  {
#line 4394
  code->valid = 1;
#line 4395
  code->value.set = _glp_mpl_copy_elemset(mpl, value);
  }
  done: 
#line 4396
  return (value);
}
}
#line 4408 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void null_func(MPL *mpl , void *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 4410
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 4410
    tmp = 1;
  } else {
    {
#line 4410
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4410);
#line 4410
    tmp = 1;
    }
  }
#line 4411
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 4411
    tmp___0 = 1;
  } else {
    {
#line 4411
    _glp_lib_xassert("info == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4411);
#line 4411
    tmp___0 = 1;
    }
  }
#line 4412
  return;
}
}
#line 4415 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_is_member(MPL *mpl , CODE *code , TUPLE *tuple ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ARG_LIST *e ;
  TUPLE *temp ;
  ELEMSET *set___0 ;
  SYMBOL *tmp___3 ;
  MEMBER *tmp___4 ;
  ARG_LIST *e___0 ;
  TUPLE *temp___0 ;
  TUPLE *that ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int in1 ;
  int tmp___12 ;
  int in2 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int j ;
  int tmp___18 ;
  int j___0 ;
  double x ;
  double t0 ;
  double tf ;
  double dt ;
  int tmp___19 ;
  int tmp___20 ;
  double tmp___21 ;
  int tmp___22 ;
  TUPLE *temp___1 ;
  int tmp___23 ;
  int tmp___24 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
#line 4417
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 4417
    tmp = 1;
  } else {
    {
#line 4417
    _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4417);
#line 4417
    tmp = 1;
    }
  }
#line 4418
  if (code->type == 106) {
#line 4418
    tmp___0 = 1;
  } else {
    {
#line 4418
    _glp_lib_xassert("code->type == A_ELEMSET", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4418);
#line 4418
    tmp___0 = 1;
    }
  }
#line 4419
  if (code->dim > 0) {
#line 4419
    tmp___1 = 1;
  } else {
    {
#line 4419
    _glp_lib_xassert("code->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4419);
#line 4419
    tmp___1 = 1;
    }
  }
#line 4420
  if ((unsigned long )tuple != (unsigned long )((void *)0)) {
#line 4420
    tmp___2 = 1;
  } else {
    {
#line 4420
    _glp_lib_xassert("tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4420);
#line 4420
    tmp___2 = 1;
    }
  }
  {
#line 4422
  if (code->op == 306) {
#line 4422
    goto case_306;
  }
#line 4441
  if (code->op == 309) {
#line 4441
    goto case_309;
  }
#line 4456
  if (code->op == 359) {
#line 4456
    goto case_359;
  }
#line 4460
  if (code->op == 360) {
#line 4460
    goto case_360;
  }
#line 4464
  if (code->op == 361) {
#line 4464
    goto case_361;
  }
#line 4470
  if (code->op == 362) {
#line 4470
    goto case_362;
  }
#line 4474
  if (code->op == 363) {
#line 4474
    goto case_363;
  }
#line 4486
  if (code->op == 371) {
#line 4486
    goto case_371;
  }
#line 4522
  if (code->op == 372) {
#line 4522
    goto case_372;
  }
#line 4529
  if (code->op == 382) {
#line 4529
    goto case_382;
  }
#line 4536
  if (code->op == 383) {
#line 4536
    goto case_383;
  }
#line 4547
  goto switch_default;
  case_306: /* CIL Label */ 
  {
#line 4429
  temp = _glp_mpl_create_tuple(mpl);
#line 4430
  e = code->arg.set.list;
  }
  {
#line 4430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4430
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4430
      goto while_break;
    }
    {
#line 4431
    tmp___3 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 4431
    temp = _glp_mpl_expand_tuple(mpl, temp, tmp___3);
#line 4430
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4433
  set___0 = _glp_mpl_eval_member_set(mpl, code->arg.set.set, temp);
#line 4434
  _glp_mpl_delete_tuple(mpl, temp);
#line 4436
  temp = _glp_mpl_build_subtuple(mpl, tuple, set___0->dim);
#line 4437
  tmp___4 = _glp_mpl_find_tuple(mpl, set___0, temp);
#line 4437
  value = (unsigned long )tmp___4 != (unsigned long )((void *)0);
#line 4438
  _glp_mpl_delete_tuple(mpl, temp);
  }
#line 4440
  goto switch_break;
  case_309: /* CIL Label */ 
  {
#line 4445
  value = 0;
#line 4446
  temp___0 = _glp_mpl_build_subtuple(mpl, tuple, code->dim);
#line 4447
  e___0 = code->arg.list;
  }
  {
#line 4447
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4447
    if (! ((unsigned long )e___0 != (unsigned long )((void *)0))) {
#line 4447
      goto while_break___0;
    }
    {
#line 4448
    that = _glp_mpl_eval_tuple(mpl, e___0->x);
#line 4449
    tmp___5 = _glp_mpl_compare_tuples(mpl, temp___0, that);
#line 4449
    value = tmp___5 == 0;
#line 4450
    _glp_mpl_delete_tuple(mpl, that);
    }
#line 4451
    if (value) {
#line 4451
      goto while_break___0;
    }
#line 4447
    e___0 = e___0->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4453
  _glp_mpl_delete_tuple(mpl, temp___0);
  }
#line 4455
  goto switch_break;
  case_359: /* CIL Label */ 
  {
#line 4457
  tmp___6 = _glp_mpl_is_member(mpl, code->arg.arg.x, tuple);
  }
#line 4457
  if (tmp___6) {
#line 4457
    tmp___8 = 1;
  } else {
    {
#line 4457
    tmp___7 = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple);
    }
#line 4457
    if (tmp___7) {
#line 4457
      tmp___8 = 1;
    } else {
#line 4457
      tmp___8 = 0;
    }
  }
#line 4457
  value = tmp___8;
#line 4459
  goto switch_break;
  case_360: /* CIL Label */ 
  {
#line 4461
  tmp___9 = _glp_mpl_is_member(mpl, code->arg.arg.x, tuple);
  }
#line 4461
  if (tmp___9) {
    {
#line 4461
    tmp___10 = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple);
    }
#line 4461
    if (tmp___10) {
#line 4461
      tmp___11 = 0;
    } else {
#line 4461
      tmp___11 = 1;
    }
  } else {
#line 4461
    tmp___11 = 0;
  }
#line 4461
  value = tmp___11;
#line 4463
  goto switch_break;
  case_361: /* CIL Label */ 
  {
#line 4465
  tmp___12 = _glp_mpl_is_member(mpl, code->arg.arg.x, tuple);
#line 4465
  in1 = tmp___12;
#line 4466
  tmp___13 = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple);
#line 4466
  in2 = tmp___13;
  }
#line 4467
  if (in1) {
#line 4467
    if (! in2) {
#line 4467
      tmp___14 = 1;
    } else {
#line 4467
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4467
  if (! in1) {
#line 4467
    if (in2) {
#line 4467
      tmp___14 = 1;
    } else {
#line 4467
      tmp___14 = 0;
    }
  } else {
#line 4467
    tmp___14 = 0;
  }
#line 4467
  value = tmp___14;
#line 4469
  goto switch_break;
  case_362: /* CIL Label */ 
  {
#line 4471
  tmp___15 = _glp_mpl_is_member(mpl, code->arg.arg.x, tuple);
  }
#line 4471
  if (tmp___15) {
    {
#line 4471
    tmp___16 = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple);
    }
#line 4471
    if (tmp___16) {
#line 4471
      tmp___17 = 1;
    } else {
#line 4471
      tmp___17 = 0;
    }
  } else {
#line 4471
    tmp___17 = 0;
  }
#line 4471
  value = tmp___17;
#line 4473
  goto switch_break;
  case_363: /* CIL Label */ 
  {
#line 4476
  value = _glp_mpl_is_member(mpl, code->arg.arg.x, tuple);
  }
#line 4477
  if (value) {
#line 4478
    j = 1;
    {
#line 4478
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4478
      if (! (j <= (code->arg.arg.x)->dim)) {
#line 4478
        goto while_break___1;
      }
#line 4479
      if ((unsigned long )tuple != (unsigned long )((void *)0)) {
#line 4479
        tmp___18 = 1;
      } else {
        {
#line 4479
        _glp_lib_xassert("tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         4479);
#line 4479
        tmp___18 = 1;
        }
      }
#line 4480
      tuple = tuple->next;
#line 4478
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 4482
    value = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple);
    }
  }
#line 4485
  goto switch_break;
  case_371: /* CIL Label */ 
#line 4490
  if (code->dim == 1) {
#line 4490
    tmp___19 = 1;
  } else {
    {
#line 4490
    _glp_lib_xassert("code->dim == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4490);
#line 4490
    tmp___19 = 1;
    }
  }
  {
#line 4492
  t0 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4493
  tf = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
  }
#line 4494
  if ((unsigned long )code->arg.arg.z == (unsigned long )((void *)0)) {
#line 4495
    dt = 1.0;
  } else {
    {
#line 4497
    dt = _glp_mpl_eval_numeric(mpl, code->arg.arg.z);
    }
  }
  {
#line 4499
  _glp_mpl_arelset_size(mpl, t0, tf, dt);
  }
#line 4502
  if ((unsigned long )tuple->sym != (unsigned long )((void *)0)) {
#line 4502
    tmp___20 = 1;
  } else {
    {
#line 4502
    _glp_lib_xassert("tuple->sym != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4502);
#line 4502
    tmp___20 = 1;
    }
  }
#line 4503
  if ((unsigned long )(tuple->sym)->str != (unsigned long )((void *)0)) {
#line 4504
    value = 0;
#line 4505
    goto switch_break;
  }
#line 4508
  x = (tuple->sym)->num;
#line 4511
  if (dt > 0.0) {
#line 4511
    if (t0 <= x) {
#line 4511
      if (x <= tf) {
#line 4511
        goto _L___0;
      } else {
#line 4513
        value = 0;
#line 4514
        goto switch_break;
      }
    } else {
#line 4513
      value = 0;
#line 4514
      goto switch_break;
    }
  } else
  _L___0: /* CIL Label */ 
#line 4511
  if (dt < 0.0) {
#line 4511
    if (tf <= x) {
#line 4511
      if (! (x <= t0)) {
#line 4513
        value = 0;
#line 4514
        goto switch_break;
      }
    } else {
#line 4513
      value = 0;
#line 4514
      goto switch_break;
    }
  }
  {
#line 4517
  j___0 = (int )((x - t0) / dt + 0.5) + 1;
#line 4519
  tmp___21 = _glp_mpl_arelset_member(mpl, t0, tf, dt, j___0);
#line 4519
  value = tmp___21 == x;
  }
#line 4521
  goto switch_break;
  case_372: /* CIL Label */ 
  {
#line 4524
  tmp___22 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 4524
  if (tmp___22) {
    {
#line 4525
    value = _glp_mpl_is_member(mpl, code->arg.arg.y, tuple);
    }
  } else {
    {
#line 4527
    value = _glp_mpl_is_member(mpl, code->arg.arg.z, tuple);
    }
  }
#line 4528
  goto switch_break;
  case_382: /* CIL Label */ 
  {
#line 4533
  _glp_mpl_error(mpl, (char *)"implementation restriction; in/within setof{} not allowed");
  }
#line 4535
  goto switch_break;
  case_383: /* CIL Label */ 
  {
#line 4539
  temp___1 = _glp_mpl_build_subtuple(mpl, tuple, code->dim);
#line 4542
  tmp___23 = _glp_mpl_eval_within_domain(mpl, code->arg.loop.domain, temp___1, (void *)0,
                                         & null_func);
#line 4542
  value = tmp___23 == 0;
#line 4544
  _glp_mpl_delete_tuple(mpl, temp___1);
  }
#line 4546
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4548
  if ((unsigned long )code != (unsigned long )code) {
#line 4548
    tmp___24 = 1;
  } else {
    {
#line 4548
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4548);
#line 4548
    tmp___24 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 4550
  return (value);
}
}
#line 4569 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int iter_form_func(MPL *mpl , void *_info ) 
{ 
  struct iter_form_info *info ;
  FORMULA *form ;
  FORMULA *term ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 4572
  info = (struct iter_form_info *)_info;
  {
#line 4574
  if ((info->code)->op == 376) {
#line 4574
    goto case_376;
  }
#line 4604
  goto switch_default;
  case_376: /* CIL Label */ 
  {
#line 4590
  form = _glp_mpl_eval_formula(mpl, (info->code)->arg.loop.x);
  }
#line 4591
  if ((unsigned long )info->value == (unsigned long )((void *)0)) {
#line 4592
    if ((unsigned long )info->tail == (unsigned long )((void *)0)) {
#line 4592
      tmp = 1;
    } else {
      {
#line 4592
      _glp_lib_xassert("info->tail == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4592);
#line 4592
      tmp = 1;
      }
    }
#line 4593
    info->value = form;
  } else {
#line 4596
    if ((unsigned long )info->tail != (unsigned long )((void *)0)) {
#line 4596
      tmp___0 = 1;
    } else {
      {
#line 4596
      _glp_lib_xassert("info->tail != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4596);
#line 4596
      tmp___0 = 1;
      }
    }
#line 4597
    (info->tail)->next = form;
  }
#line 4599
  term = form;
  {
#line 4599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4599
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 4599
      goto while_break;
    }
#line 4600
    info->tail = term;
#line 4599
    term = term->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4603
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4605
  if ((unsigned long )info != (unsigned long )info) {
#line 4605
    tmp___1 = 1;
  } else {
    {
#line 4605
    _glp_lib_xassert("info != info", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4605);
#line 4605
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 4607
  return (0);
}
}
#line 4610 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
FORMULA *_glp_mpl_eval_formula(MPL *mpl , CODE *code ) 
{ 
  FORMULA *value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  TUPLE *tuple ;
  ARG_LIST *e ;
  SYMBOL *tmp___2 ;
  ELEMVAR *tmp___3 ;
  double tmp___4 ;
  FORMULA *tmp___5 ;
  FORMULA *tmp___6 ;
  FORMULA *tmp___7 ;
  FORMULA *tmp___8 ;
  FORMULA *tmp___9 ;
  FORMULA *tmp___10 ;
  FORMULA *tmp___11 ;
  FORMULA *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  FORMULA *tmp___16 ;
  FORMULA *tmp___17 ;
  double tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  FORMULA *tmp___21 ;
  FORMULA *tmp___22 ;
  double tmp___23 ;
  FORMULA *tmp___24 ;
  FORMULA *tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  int tmp___28 ;
  struct iter_form_info _info ;
  struct iter_form_info *info ;
  int tmp___29 ;
  int tmp___30 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 4612
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 4612
    tmp = 1;
  } else {
    {
#line 4612
    _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4612);
#line 4612
    tmp = 1;
    }
  }
#line 4613
  if (code->type == 110) {
#line 4613
    tmp___0 = 1;
  } else {
    {
#line 4613
    _glp_lib_xassert("code->type == A_FORMULA", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4613);
#line 4613
    tmp___0 = 1;
    }
  }
#line 4614
  if (code->dim == 0) {
#line 4614
    tmp___1 = 1;
  } else {
    {
#line 4614
    _glp_lib_xassert("code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4614);
#line 4614
    tmp___1 = 1;
    }
  }
#line 4617
  if (code->vflag) {
#line 4617
    if (code->valid) {
      {
#line 4618
      code->valid = 0;
#line 4619
      _glp_mpl_delete_value(mpl, code->type, & code->value);
      }
    }
  }
#line 4622
  if (code->valid) {
    {
#line 4623
    value = _glp_mpl_copy_formula(mpl, code->value.form);
    }
#line 4624
    goto done;
  }
  {
#line 4628
  if (code->op == 307) {
#line 4628
    goto case_307;
  }
#line 4641
  if (code->op == 319) {
#line 4641
    goto case_319;
  }
#line 4646
  if (code->op == 320) {
#line 4646
    goto case_320;
  }
#line 4652
  if (code->op == 321) {
#line 4652
    goto case_321;
  }
#line 4658
  if (code->op == 337) {
#line 4658
    goto case_337;
  }
#line 4664
  if (code->op == 338) {
#line 4664
    goto case_338;
  }
#line 4670
  if (code->op == 340) {
#line 4670
    goto case_340;
  }
#line 4690
  if (code->op == 341) {
#line 4690
    goto case_341;
  }
#line 4697
  if (code->op == 372) {
#line 4697
    goto case_372;
  }
#line 4706
  if (code->op == 376) {
#line 4706
    goto case_376;
  }
#line 4717
  goto switch_default;
  case_307: /* CIL Label */ 
  {
#line 4632
  tuple = _glp_mpl_create_tuple(mpl);
#line 4633
  e = code->arg.var.list;
  }
  {
#line 4633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4633
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4633
      goto while_break;
    }
    {
#line 4634
    tmp___2 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 4634
    tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___2);
#line 4633
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4636
  tmp___3 = _glp_mpl_eval_member_var(mpl, code->arg.var.var, tuple);
#line 4636
  value = _glp_mpl_single_variable(mpl, tmp___3);
#line 4638
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 4640
  goto switch_break;
  case_319: /* CIL Label */ 
  {
#line 4643
  tmp___4 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4643
  value = _glp_mpl_constant_term(mpl, tmp___4);
  }
#line 4645
  goto switch_break;
  case_320: /* CIL Label */ 
  {
#line 4648
  tmp___5 = _glp_mpl_eval_formula(mpl, code->arg.arg.x);
#line 4648
  tmp___6 = _glp_mpl_constant_term(mpl, 0.0);
#line 4648
  value = _glp_mpl_linear_comb(mpl, 0.0, tmp___6, 1.0, tmp___5);
  }
#line 4651
  goto switch_break;
  case_321: /* CIL Label */ 
  {
#line 4654
  tmp___7 = _glp_mpl_eval_formula(mpl, code->arg.arg.x);
#line 4654
  tmp___8 = _glp_mpl_constant_term(mpl, 0.0);
#line 4654
  value = _glp_mpl_linear_comb(mpl, 0.0, tmp___8, - 1.0, tmp___7);
  }
#line 4657
  goto switch_break;
  case_337: /* CIL Label */ 
  {
#line 4660
  tmp___9 = _glp_mpl_eval_formula(mpl, code->arg.arg.y);
#line 4660
  tmp___10 = _glp_mpl_eval_formula(mpl, code->arg.arg.x);
#line 4660
  value = _glp_mpl_linear_comb(mpl, 1.0, tmp___10, 1.0, tmp___9);
  }
#line 4663
  goto switch_break;
  case_338: /* CIL Label */ 
  {
#line 4666
  tmp___11 = _glp_mpl_eval_formula(mpl, code->arg.arg.y);
#line 4666
  tmp___12 = _glp_mpl_eval_formula(mpl, code->arg.arg.x);
#line 4666
  value = _glp_mpl_linear_comb(mpl, 1.0, tmp___12, - 1.0, tmp___11);
  }
#line 4669
  goto switch_break;
  case_340: /* CIL Label */ 
#line 4672
  if ((unsigned long )code->arg.arg.x != (unsigned long )((void *)0)) {
#line 4672
    tmp___13 = 1;
  } else {
    {
#line 4672
    _glp_lib_xassert("code->arg.arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4672);
#line 4672
    tmp___13 = 1;
    }
  }
#line 4673
  if ((unsigned long )code->arg.arg.y != (unsigned long )((void *)0)) {
#line 4673
    tmp___14 = 1;
  } else {
    {
#line 4673
    _glp_lib_xassert("code->arg.arg.y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4673);
#line 4673
    tmp___14 = 1;
    }
  }
#line 4674
  if ((code->arg.arg.x)->type == 118) {
#line 4675
    if ((code->arg.arg.y)->type == 110) {
#line 4675
      tmp___15 = 1;
    } else {
      {
#line 4675
      _glp_lib_xassert("code->arg.arg.y->type == A_FORMULA", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4675);
#line 4675
      tmp___15 = 1;
      }
    }
    {
#line 4676
    tmp___16 = _glp_mpl_constant_term(mpl, 0.0);
#line 4676
    tmp___17 = _glp_mpl_eval_formula(mpl, code->arg.arg.y);
#line 4676
    tmp___18 = _glp_mpl_eval_numeric(mpl, code->arg.arg.x);
#line 4676
    value = _glp_mpl_linear_comb(mpl, tmp___18, tmp___17, 0.0, tmp___16);
    }
  } else {
#line 4682
    if ((code->arg.arg.x)->type == 110) {
#line 4682
      tmp___19 = 1;
    } else {
      {
#line 4682
      _glp_lib_xassert("code->arg.arg.x->type == A_FORMULA", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4682);
#line 4682
      tmp___19 = 1;
      }
    }
#line 4683
    if ((code->arg.arg.y)->type == 118) {
#line 4683
      tmp___20 = 1;
    } else {
      {
#line 4683
      _glp_lib_xassert("code->arg.arg.y->type == A_NUMERIC", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4683);
#line 4683
      tmp___20 = 1;
      }
    }
    {
#line 4684
    tmp___21 = _glp_mpl_constant_term(mpl, 0.0);
#line 4684
    tmp___22 = _glp_mpl_eval_formula(mpl, code->arg.arg.x);
#line 4684
    tmp___23 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4684
    value = _glp_mpl_linear_comb(mpl, tmp___23, tmp___22, 0.0, tmp___21);
    }
  }
#line 4689
  goto switch_break;
  case_341: /* CIL Label */ 
  {
#line 4692
  tmp___24 = _glp_mpl_constant_term(mpl, 0.0);
#line 4692
  tmp___25 = _glp_mpl_eval_formula(mpl, code->arg.arg.x);
#line 4692
  tmp___26 = _glp_mpl_eval_numeric(mpl, code->arg.arg.y);
#line 4692
  tmp___27 = _glp_mpl_fp_div(mpl, 1.0, tmp___26);
#line 4692
  value = _glp_mpl_linear_comb(mpl, tmp___27, tmp___25, 0.0, tmp___24);
  }
#line 4696
  goto switch_break;
  case_372: /* CIL Label */ 
  {
#line 4699
  tmp___28 = _glp_mpl_eval_logical(mpl, code->arg.arg.x);
  }
#line 4699
  if (tmp___28) {
    {
#line 4700
    value = _glp_mpl_eval_formula(mpl, code->arg.arg.y);
    }
  } else
#line 4701
  if ((unsigned long )code->arg.arg.z == (unsigned long )((void *)0)) {
    {
#line 4702
    value = _glp_mpl_constant_term(mpl, 0.0);
    }
  } else {
    {
#line 4704
    value = _glp_mpl_eval_formula(mpl, code->arg.arg.z);
    }
  }
#line 4705
  goto switch_break;
  case_376: /* CIL Label */ 
  {
#line 4708
  info = & _info;
#line 4709
  info->code = code;
#line 4710
  info->value = _glp_mpl_constant_term(mpl, 0.0);
#line 4711
  info->tail = (FORMULA *)((void *)0);
#line 4712
  _glp_mpl_loop_within_domain(mpl, code->arg.loop.domain, (void *)info, & iter_form_func);
#line 4714
  value = _glp_mpl_reduce_terms(mpl, info->value);
  }
#line 4716
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4718
  if ((unsigned long )code != (unsigned long )code) {
#line 4718
    tmp___29 = 1;
  } else {
    {
#line 4718
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4718);
#line 4718
    tmp___29 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 4721
  if (! code->valid) {
#line 4721
    tmp___30 = 1;
  } else {
    {
#line 4721
    _glp_lib_xassert("!code->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4721);
#line 4721
    tmp___30 = 1;
    }
  }
  {
#line 4722
  code->valid = 1;
#line 4723
  code->value.form = _glp_mpl_copy_formula(mpl, value);
  }
  done: 
#line 4724
  return (value);
}
}
#line 4733 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_code(MPL *mpl , CODE *code ) 
{ 
  ARG_LIST *e ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4736
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 4736
    goto done;
  }
#line 4738
  if (code->valid) {
    {
#line 4739
    code->valid = 0;
#line 4740
    _glp_mpl_delete_value(mpl, code->type, & code->value);
    }
  }
  {
#line 4746
  if (code->op == 303) {
#line 4746
    goto case_303;
  }
#line 4746
  if (code->op == 302) {
#line 4746
    goto case_303;
  }
#line 4746
  if (code->op == 301) {
#line 4746
    goto case_303;
  }
#line 4749
  if (code->op == 305) {
#line 4749
    goto case_305;
  }
#line 4749
  if (code->op == 304) {
#line 4749
    goto case_305;
  }
#line 4753
  if (code->op == 306) {
#line 4753
    goto case_306;
  }
#line 4757
  if (code->op == 307) {
#line 4757
    goto case_307;
  }
#line 4762
  if (code->op == 309) {
#line 4762
    goto case_309;
  }
#line 4762
  if (code->op == 308) {
#line 4762
    goto case_309;
  }
#line 4766
  if (code->op == 310) {
#line 4766
    goto case_310;
  }
#line 4771
  if (code->op == 314) {
#line 4771
    goto case_314;
  }
#line 4771
  if (code->op == 313) {
#line 4771
    goto case_314;
  }
#line 4771
  if (code->op == 312) {
#line 4771
    goto case_314;
  }
#line 4771
  if (code->op == 311) {
#line 4771
    goto case_314;
  }
#line 4794
  if (code->op == 336) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 335) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 334) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 333) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 332) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 331) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 330) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 329) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 328) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 327) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 326) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 325) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 324) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 323) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 322) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 321) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 320) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 319) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 318) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 317) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 316) {
#line 4794
    goto case_336;
  }
#line 4794
  if (code->op == 315) {
#line 4794
    goto case_336;
  }
#line 4831
  if (code->op == 370) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 369) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 368) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 367) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 366) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 365) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 364) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 363) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 362) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 361) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 360) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 359) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 358) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 357) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 356) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 355) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 354) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 353) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 352) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 351) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 350) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 349) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 348) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 347) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 346) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 345) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 344) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 343) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 342) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 341) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 340) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 339) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 338) {
#line 4831
    goto case_370;
  }
#line 4831
  if (code->op == 337) {
#line 4831
    goto case_370;
  }
#line 4838
  if (code->op == 373) {
#line 4838
    goto case_373;
  }
#line 4838
  if (code->op == 372) {
#line 4838
    goto case_373;
  }
#line 4838
  if (code->op == 371) {
#line 4838
    goto case_373;
  }
#line 4845
  if (code->op == 375) {
#line 4845
    goto case_375;
  }
#line 4845
  if (code->op == 374) {
#line 4845
    goto case_375;
  }
#line 4857
  if (code->op == 383) {
#line 4857
    goto case_383;
  }
#line 4857
  if (code->op == 382) {
#line 4857
    goto case_383;
  }
#line 4857
  if (code->op == 381) {
#line 4857
    goto case_383;
  }
#line 4857
  if (code->op == 380) {
#line 4857
    goto case_383;
  }
#line 4857
  if (code->op == 379) {
#line 4857
    goto case_383;
  }
#line 4857
  if (code->op == 378) {
#line 4857
    goto case_383;
  }
#line 4857
  if (code->op == 377) {
#line 4857
    goto case_383;
  }
#line 4857
  if (code->op == 376) {
#line 4857
    goto case_383;
  }
#line 4862
  goto switch_default;
  case_303: /* CIL Label */ 
  case_302: /* CIL Label */ 
  case_301: /* CIL Label */ 
#line 4747
  goto switch_break;
  case_305: /* CIL Label */ 
  case_304: /* CIL Label */ 
#line 4750
  e = code->arg.par.list;
  {
#line 4750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4750
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4750
      goto while_break;
    }
    {
#line 4751
    _glp_mpl_clean_code(mpl, e->x);
#line 4750
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4752
  goto switch_break;
  case_306: /* CIL Label */ 
#line 4754
  e = code->arg.set.list;
  {
#line 4754
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4754
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4754
      goto while_break___0;
    }
    {
#line 4755
    _glp_mpl_clean_code(mpl, e->x);
#line 4754
    e = e->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4756
  goto switch_break;
  case_307: /* CIL Label */ 
#line 4758
  e = code->arg.var.list;
  {
#line 4758
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4758
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4758
      goto while_break___1;
    }
    {
#line 4759
    _glp_mpl_clean_code(mpl, e->x);
#line 4758
    e = e->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4760
  goto switch_break;
  case_309: /* CIL Label */ 
  case_308: /* CIL Label */ 
#line 4763
  e = code->arg.list;
  {
#line 4763
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4763
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4763
      goto while_break___2;
    }
    {
#line 4764
    _glp_mpl_clean_code(mpl, e->x);
#line 4763
    e = e->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4765
  goto switch_break;
  case_310: /* CIL Label */ 
#line 4767
  if ((unsigned long )code != (unsigned long )code) {
#line 4767
    tmp = 1;
  } else {
    {
#line 4767
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4767);
#line 4767
    tmp = 1;
    }
  }
  case_314: /* CIL Label */ 
  case_313: /* CIL Label */ 
  case_312: /* CIL Label */ 
  case_311: /* CIL Label */ 
#line 4772
  goto switch_break;
  case_336: /* CIL Label */ 
  case_335: /* CIL Label */ 
  case_334: /* CIL Label */ 
  case_333: /* CIL Label */ 
  case_332: /* CIL Label */ 
  case_331: /* CIL Label */ 
  case_330: /* CIL Label */ 
  case_329: /* CIL Label */ 
  case_328: /* CIL Label */ 
  case_327: /* CIL Label */ 
  case_326: /* CIL Label */ 
  case_325: /* CIL Label */ 
  case_324: /* CIL Label */ 
  case_323: /* CIL Label */ 
  case_322: /* CIL Label */ 
  case_321: /* CIL Label */ 
  case_320: /* CIL Label */ 
  case_319: /* CIL Label */ 
  case_318: /* CIL Label */ 
  case_317: /* CIL Label */ 
  case_316: /* CIL Label */ 
  case_315: /* CIL Label */ 
  {
#line 4796
  _glp_mpl_clean_code(mpl, code->arg.arg.x);
  }
#line 4797
  goto switch_break;
  case_370: /* CIL Label */ 
  case_369: /* CIL Label */ 
  case_368: /* CIL Label */ 
  case_367: /* CIL Label */ 
  case_366: /* CIL Label */ 
  case_365: /* CIL Label */ 
  case_364: /* CIL Label */ 
  case_363: /* CIL Label */ 
  case_362: /* CIL Label */ 
  case_361: /* CIL Label */ 
  case_360: /* CIL Label */ 
  case_359: /* CIL Label */ 
  case_358: /* CIL Label */ 
  case_357: /* CIL Label */ 
  case_356: /* CIL Label */ 
  case_355: /* CIL Label */ 
  case_354: /* CIL Label */ 
  case_353: /* CIL Label */ 
  case_352: /* CIL Label */ 
  case_351: /* CIL Label */ 
  case_350: /* CIL Label */ 
  case_349: /* CIL Label */ 
  case_348: /* CIL Label */ 
  case_347: /* CIL Label */ 
  case_346: /* CIL Label */ 
  case_345: /* CIL Label */ 
  case_344: /* CIL Label */ 
  case_343: /* CIL Label */ 
  case_342: /* CIL Label */ 
  case_341: /* CIL Label */ 
  case_340: /* CIL Label */ 
  case_339: /* CIL Label */ 
  case_338: /* CIL Label */ 
  case_337: /* CIL Label */ 
  {
#line 4833
  _glp_mpl_clean_code(mpl, code->arg.arg.x);
#line 4834
  _glp_mpl_clean_code(mpl, code->arg.arg.y);
  }
#line 4835
  goto switch_break;
  case_373: /* CIL Label */ 
  case_372: /* CIL Label */ 
  case_371: /* CIL Label */ 
  {
#line 4840
  _glp_mpl_clean_code(mpl, code->arg.arg.x);
#line 4841
  _glp_mpl_clean_code(mpl, code->arg.arg.y);
#line 4842
  _glp_mpl_clean_code(mpl, code->arg.arg.z);
  }
#line 4843
  goto switch_break;
  case_375: /* CIL Label */ 
  case_374: /* CIL Label */ 
#line 4847
  e = code->arg.list;
  {
#line 4847
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 4847
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 4847
      goto while_break___3;
    }
    {
#line 4848
    _glp_mpl_clean_code(mpl, e->x);
#line 4847
    e = e->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 4849
  goto switch_break;
  case_383: /* CIL Label */ 
  case_382: /* CIL Label */ 
  case_381: /* CIL Label */ 
  case_380: /* CIL Label */ 
  case_379: /* CIL Label */ 
  case_378: /* CIL Label */ 
  case_377: /* CIL Label */ 
  case_376: /* CIL Label */ 
  {
#line 4859
  _glp_mpl_clean_domain(mpl, code->arg.loop.domain);
#line 4860
  _glp_mpl_clean_code(mpl, code->arg.loop.x);
  }
#line 4861
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4863
  if (code->op != code->op) {
#line 4863
    tmp___0 = 1;
  } else {
    {
#line 4863
    _glp_lib_xassert("code->op != code->op", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4863);
#line 4863
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  done: 
#line 4865
  return;
}
}
#line 4873 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_tab_num_args(TABDCA *dca ) 
{ 


  {
#line 4875
  return (dca->na);
}
}
#line 4878 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
char const   *_glp_mpl_tab_get_arg(TABDCA *dca , int k ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 4880
  if (1 <= k) {
#line 4880
    if (k <= dca->na) {
#line 4880
      tmp = 1;
    } else {
      {
#line 4880
      _glp_lib_xassert("1 <= k && k <= dca->na", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4880);
#line 4880
      tmp = 1;
      }
    }
  } else {
    {
#line 4880
    _glp_lib_xassert("1 <= k && k <= dca->na", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4880);
#line 4880
    tmp = 1;
    }
  }
#line 4881
  return ((char const   *)*(dca->arg + k));
}
}
#line 4884 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_tab_num_flds(TABDCA *dca ) 
{ 


  {
#line 4886
  return (dca->nf);
}
}
#line 4889 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
char const   *_glp_mpl_tab_get_name(TABDCA *dca , int k ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 4891
  if (1 <= k) {
#line 4891
    if (k <= dca->nf) {
#line 4891
      tmp = 1;
    } else {
      {
#line 4891
      _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4891);
#line 4891
      tmp = 1;
      }
    }
  } else {
    {
#line 4891
    _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4891);
#line 4891
    tmp = 1;
    }
  }
#line 4892
  return ((char const   *)*(dca->name + k));
}
}
#line 4895 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
int _glp_mpl_tab_get_type(TABDCA *dca , int k ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 4897
  if (1 <= k) {
#line 4897
    if (k <= dca->nf) {
#line 4897
      tmp = 1;
    } else {
      {
#line 4897
      _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4897);
#line 4897
      tmp = 1;
      }
    }
  } else {
    {
#line 4897
    _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4897);
#line 4897
    tmp = 1;
    }
  }
#line 4898
  return (*(dca->type + k));
}
}
#line 4901 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
double _glp_mpl_tab_get_num(TABDCA *dca , int k ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 4903
  if (1 <= k) {
#line 4903
    if (k <= dca->nf) {
#line 4903
      tmp = 1;
    } else {
      {
#line 4903
      _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4903);
#line 4903
      tmp = 1;
      }
    }
  } else {
    {
#line 4903
    _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4903);
#line 4903
    tmp = 1;
    }
  }
#line 4904
  if (*(dca->type + k) == 78) {
#line 4904
    tmp___0 = 1;
  } else {
    {
#line 4904
    _glp_lib_xassert("dca->type[k] == \'N\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4904);
#line 4904
    tmp___0 = 1;
    }
  }
#line 4905
  return (*(dca->num + k));
}
}
#line 4908 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
char const   *_glp_mpl_tab_get_str(TABDCA *dca , int k ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 4910
  if (1 <= k) {
#line 4910
    if (k <= dca->nf) {
#line 4910
      tmp = 1;
    } else {
      {
#line 4910
      _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4910);
#line 4910
      tmp = 1;
      }
    }
  } else {
    {
#line 4910
    _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4910);
#line 4910
    tmp = 1;
    }
  }
#line 4911
  if (*(dca->type + k) == 83) {
#line 4911
    tmp___0 = 1;
  } else {
    {
#line 4911
    _glp_lib_xassert("dca->type[k] == \'S\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4911);
#line 4911
    tmp___0 = 1;
    }
  }
#line 4912
  if ((unsigned long )*(dca->str + k) != (unsigned long )((void *)0)) {
#line 4912
    tmp___1 = 1;
  } else {
    {
#line 4912
    _glp_lib_xassert("dca->str[k] != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4912);
#line 4912
    tmp___1 = 1;
    }
  }
#line 4913
  return ((char const   *)*(dca->str + k));
}
}
#line 4916 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_tab_set_num(TABDCA *dca , int k , double num ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 4918
  if (1 <= k) {
#line 4918
    if (k <= dca->nf) {
#line 4918
      tmp = 1;
    } else {
      {
#line 4918
      _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4918);
#line 4918
      tmp = 1;
      }
    }
  } else {
    {
#line 4918
    _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4918);
#line 4918
    tmp = 1;
    }
  }
#line 4919
  if (*(dca->type + k) == 63) {
#line 4919
    tmp___0 = 1;
  } else {
    {
#line 4919
    _glp_lib_xassert("dca->type[k] == \'?\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4919);
#line 4919
    tmp___0 = 1;
    }
  }
#line 4920
  *(dca->type + k) = 'N';
#line 4921
  *(dca->num + k) = num;
#line 4922
  return;
}
}
#line 4925 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_tab_set_str(TABDCA *dca , int k , char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 4927
  if (1 <= k) {
#line 4927
    if (k <= dca->nf) {
#line 4927
      tmp = 1;
    } else {
      {
#line 4927
      _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4927);
#line 4927
      tmp = 1;
      }
    }
  } else {
    {
#line 4927
    _glp_lib_xassert("1 <= k && k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4927);
#line 4927
    tmp = 1;
    }
  }
#line 4928
  if (*(dca->type + k) == 63) {
#line 4928
    tmp___0 = 1;
  } else {
    {
#line 4928
    _glp_lib_xassert("dca->type[k] == \'?\'", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4928);
#line 4928
    tmp___0 = 1;
    }
  }
  {
#line 4929
  tmp___1 = strlen(str);
  }
#line 4929
  if (tmp___1 <= 100U) {
#line 4929
    tmp___2 = 1;
  } else {
    {
#line 4929
    _glp_lib_xassert("strlen(str) <= MAX_LENGTH", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4929);
#line 4929
    tmp___2 = 1;
    }
  }
#line 4930
  if ((unsigned long )*(dca->str + k) != (unsigned long )((void *)0)) {
#line 4930
    tmp___3 = 1;
  } else {
    {
#line 4930
    _glp_lib_xassert("dca->str[k] != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4930);
#line 4930
    tmp___3 = 1;
    }
  }
  {
#line 4931
  *(dca->type + k) = 'S';
#line 4932
  strcpy((char */* __restrict  */)*(dca->str + k), (char const   */* __restrict  */)str);
  }
#line 4933
  return;
}
}
#line 4936 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int write_func(MPL *mpl , void *info ) 
{ 
  TABLE *tab ;
  TABDCA *dca ;
  TABOUT *out ;
  SYMBOL *sym ;
  int k ;
  char buf[101] ;
  int tmp ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 4938
  tab = (TABLE *)info;
#line 4939
  dca = mpl->dca;
#line 4945
  k = 0;
#line 4946
  out = tab->u.out.list;
  {
#line 4946
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4946
    if (! ((unsigned long )out != (unsigned long )((void *)0))) {
#line 4946
      goto while_break;
    }
#line 4947
    k ++;
    {
#line 4949
    if ((out->code)->type == 118) {
#line 4949
      goto case_118;
    }
#line 4954
    if ((out->code)->type == 124) {
#line 4954
      goto case_124;
    }
#line 4969
    goto switch_default;
    case_118: /* CIL Label */ 
    {
#line 4950
    *(dca->type + k) = 'N';
#line 4951
    *(dca->num + k) = _glp_mpl_eval_numeric(mpl, out->code);
#line 4952
    *(*(dca->str + k) + 0) = (char )'\000';
    }
#line 4953
    goto switch_break;
    case_124: /* CIL Label */ 
    {
#line 4955
    sym = _glp_mpl_eval_symbolic(mpl, out->code);
    }
#line 4956
    if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
#line 4957
      *(dca->type + k) = 'N';
#line 4958
      *(dca->num + k) = sym->num;
#line 4959
      *(*(dca->str + k) + 0) = (char )'\000';
    } else {
      {
#line 4962
      *(dca->type + k) = 'S';
#line 4963
      *(dca->num + k) = 0.0;
#line 4964
      _glp_mpl_fetch_string(mpl, sym->str, (char *)(buf));
#line 4965
      strcpy((char */* __restrict  */)*(dca->str + k), (char const   */* __restrict  */)(buf));
      }
    }
    {
#line 4967
    _glp_mpl_delete_symbol(mpl, sym);
    }
#line 4968
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 4970
    if ((unsigned long )out != (unsigned long )out) {
#line 4970
      tmp = 1;
    } else {
      {
#line 4970
      _glp_lib_xassert("out != out", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       4970);
#line 4970
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 4946
    out = out->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4974
  _glp_mpl_tab_drv_write(mpl);
  }
#line 4975
  return (0);
}
}
#line 4978 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_execute_table(MPL *mpl , TABLE *tab ) 
{ 
  TABARG *arg ;
  TABFLD *fld ;
  TABIN *in ;
  TABOUT *out ;
  TABDCA *dca ;
  SET *set___0 ;
  int k ;
  char buf[101] ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  SYMBOL *sym ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  MEMBER *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  TUPLE *tup ;
  int tmp___16 ;
  int tmp___17 ;
  SYMBOL *tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  STRING *tmp___21 ;
  SYMBOL *tmp___22 ;
  int tmp___23 ;
  TUPLE *tmp___24 ;
  MEMBER *memb ;
  int tmp___25 ;
  char *tmp___26 ;
  MEMBER *tmp___27 ;
  TUPLE *tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  STRING *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  void *tmp___37 ;
  void *tmp___38 ;
  void *tmp___39 ;
  void *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;

  {
#line 4989
  if ((unsigned long )mpl->dca == (unsigned long )((void *)0)) {
#line 4989
    tmp = 1;
  } else {
    {
#line 4989
    _glp_lib_xassert("mpl->dca == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     4989);
#line 4989
    tmp = 1;
    }
  }
  {
#line 4990
  tmp___0 = _glp_lib_xmalloc((int )sizeof(TABDCA ));
#line 4990
  dca = (TABDCA *)tmp___0;
#line 4990
  mpl->dca = dca;
#line 4991
  dca->id = 0;
#line 4992
  dca->link = (void *)0;
#line 4993
  dca->na = 0;
#line 4994
  dca->arg = (char **)((void *)0);
#line 4995
  dca->nf = 0;
#line 4996
  dca->name = (char **)((void *)0);
#line 4997
  dca->type = (int *)((void *)0);
#line 4998
  dca->num = (double *)((void *)0);
#line 4999
  dca->str = (char **)((void *)0);
  }
#line 5001
  if (dca->na == 0) {
#line 5001
    tmp___1 = 1;
  } else {
    {
#line 5001
    _glp_lib_xassert("dca->na == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5001);
#line 5001
    tmp___1 = 1;
    }
  }
#line 5002
  arg = tab->arg;
  {
#line 5002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5002
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 5002
      goto while_break;
    }
#line 5003
    (dca->na) ++;
#line 5002
    arg = arg->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5004
  tmp___2 = _glp_lib_xcalloc(1 + dca->na, (int )sizeof(char *));
#line 5004
  dca->arg = (char **)tmp___2;
#line 5006
  k = 1;
  }
  {
#line 5006
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5006
    if (! (k <= dca->na)) {
#line 5006
      goto while_break___0;
    }
#line 5006
    *(dca->arg + k) = (char *)((void *)0);
#line 5006
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5009
  k = 0;
#line 5010
  arg = tab->arg;
  {
#line 5010
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5010
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 5010
      goto while_break___1;
    }
#line 5012
    k ++;
#line 5013
    if ((arg->code)->type == 124) {
#line 5013
      tmp___3 = 1;
    } else {
      {
#line 5013
      _glp_lib_xassert("arg->code->type == A_SYMBOLIC", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       5013);
#line 5013
      tmp___3 = 1;
      }
    }
    {
#line 5014
    sym = _glp_mpl_eval_symbolic(mpl, arg->code);
    }
#line 5015
    if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
      {
#line 5016
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%.*g",
              15, sym->num);
      }
    } else {
      {
#line 5018
      _glp_mpl_fetch_string(mpl, sym->str, (char *)(buf));
      }
    }
    {
#line 5019
    _glp_mpl_delete_symbol(mpl, sym);
#line 5020
    tmp___4 = strlen((char const   *)(buf));
#line 5020
    tmp___5 = _glp_lib_xmalloc((int )(tmp___4 + 1U));
#line 5020
    *(dca->arg + k) = (char *)tmp___5;
#line 5021
    strcpy((char */* __restrict  */)*(dca->arg + k), (char const   */* __restrict  */)(buf));
#line 5010
    arg = arg->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 5025
  if (tab->type == 112) {
#line 5025
    goto case_112;
  }
#line 5026
  if (tab->type == 119) {
#line 5026
    goto case_119;
  }
#line 5027
  goto switch_default;
  case_112: /* CIL Label */ 
#line 5025
  goto read_table;
  case_119: /* CIL Label */ 
#line 5026
  goto write_table;
  switch_default: /* CIL Label */ 
#line 5027
  if ((unsigned long )tab != (unsigned long )tab) {
#line 5027
    tmp___6 = 1;
  } else {
    {
#line 5027
    _glp_lib_xassert("tab != tab", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5027);
#line 5027
    tmp___6 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  read_table: 
#line 5033
  set___0 = tab->u.in.set;
#line 5034
  if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
#line 5035
    if (set___0->data) {
      {
#line 5036
      _glp_mpl_error(mpl, (char *)"%s already provided with data", set___0->name);
      }
    }
#line 5037
    if ((unsigned long )(set___0->array)->head == (unsigned long )((void *)0)) {
#line 5037
      tmp___7 = 1;
    } else {
      {
#line 5037
      _glp_lib_xassert("set->array->head == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       5037);
#line 5037
      tmp___7 = 1;
      }
    }
    {
#line 5038
    tmp___8 = _glp_mpl_add_member(mpl, set___0->array, (TUPLE *)((void *)0));
#line 5038
    tmp___8->value.set = _glp_mpl_create_elemset(mpl, set___0->dimen);
#line 5040
    set___0->data = 1;
    }
  }
#line 5043
  in = tab->u.in.list;
  {
#line 5043
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5043
    if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 5043
      goto while_break___2;
    }
#line 5044
    if ((in->par)->data) {
      {
#line 5045
      _glp_mpl_error(mpl, (char *)"%s already provided with data", (in->par)->name);
      }
    }
#line 5046
    (in->par)->data = 1;
#line 5043
    in = in->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5049
  if (dca->nf == 0) {
#line 5049
    tmp___9 = 1;
  } else {
    {
#line 5049
    _glp_lib_xassert("dca->nf == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5049);
#line 5049
    tmp___9 = 1;
    }
  }
#line 5050
  fld = tab->u.in.fld;
  {
#line 5050
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5050
    if (! ((unsigned long )fld != (unsigned long )((void *)0))) {
#line 5050
      goto while_break___3;
    }
#line 5051
    (dca->nf) ++;
#line 5050
    fld = fld->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5052
  in = tab->u.in.list;
  {
#line 5052
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 5052
    if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 5052
      goto while_break___4;
    }
#line 5053
    (dca->nf) ++;
#line 5052
    in = in->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 5054
  tmp___10 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(char *));
#line 5054
  dca->name = (char **)tmp___10;
#line 5055
  tmp___11 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(int ));
#line 5055
  dca->type = (int *)tmp___11;
#line 5056
  tmp___12 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(double ));
#line 5056
  dca->num = (double *)tmp___12;
#line 5057
  tmp___13 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(char *));
#line 5057
  dca->str = (char **)tmp___13;
#line 5058
  k = 0;
#line 5059
  fld = tab->u.in.fld;
  }
  {
#line 5059
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 5059
    if (! ((unsigned long )fld != (unsigned long )((void *)0))) {
#line 5059
      goto while_break___5;
    }
    {
#line 5060
    k ++;
#line 5061
    *(dca->name + k) = fld->name;
#line 5062
    *(dca->type + k) = '?';
#line 5063
    *(dca->num + k) = 0.0;
#line 5064
    tmp___14 = _glp_lib_xmalloc(101);
#line 5064
    *(dca->str + k) = (char *)tmp___14;
#line 5065
    *(*(dca->str + k) + 0) = (char )'\000';
#line 5059
    fld = fld->next;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 5067
  in = tab->u.in.list;
  {
#line 5067
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 5067
    if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 5067
      goto while_break___6;
    }
    {
#line 5068
    k ++;
#line 5069
    *(dca->name + k) = in->name;
#line 5070
    *(dca->type + k) = '?';
#line 5071
    *(dca->num + k) = 0.0;
#line 5072
    tmp___15 = _glp_lib_xmalloc(101);
#line 5072
    *(dca->str + k) = (char *)tmp___15;
#line 5073
    *(*(dca->str + k) + 0) = (char )'\000';
#line 5067
    in = in->next;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 5076
  _glp_mpl_tab_drv_open(mpl, 'R');
  }
  {
#line 5078
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 5081
    k = 1;
    {
#line 5081
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 5081
      if (! (k <= dca->nf)) {
#line 5081
        goto while_break___8;
      }
#line 5082
      *(dca->type + k) = '?';
#line 5081
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 5084
    tmp___16 = _glp_mpl_tab_drv_read(mpl);
    }
#line 5084
    if (tmp___16) {
#line 5084
      goto while_break___7;
    }
#line 5086
    k = 1;
    {
#line 5086
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 5086
      if (! (k <= dca->nf)) {
#line 5086
        goto while_break___9;
      }
#line 5087
      if (*(dca->type + k) == 63) {
        {
#line 5088
        _glp_mpl_error(mpl, (char *)"field %s missing in input table", *(dca->name + k));
        }
      }
#line 5086
      k ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 5092
    tup = _glp_mpl_create_tuple(mpl);
#line 5093
    k = 0;
#line 5094
    fld = tab->u.in.fld;
    }
    {
#line 5094
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 5094
      if (! ((unsigned long )fld != (unsigned long )((void *)0))) {
#line 5094
        goto while_break___10;
      }
#line 5095
      k ++;
#line 5096
      if (k <= dca->nf) {
#line 5096
        tmp___17 = 1;
      } else {
        {
#line 5096
        _glp_lib_xassert("k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         5096);
#line 5096
        tmp___17 = 1;
        }
      }
      {
#line 5098
      if (*(dca->type + k) == 78) {
#line 5098
        goto case_78;
      }
#line 5102
      if (*(dca->type + k) == 83) {
#line 5102
        goto case_83;
      }
#line 5107
      goto switch_default___0;
      case_78: /* CIL Label */ 
      {
#line 5099
      tmp___18 = _glp_mpl_create_symbol_num(mpl, *(dca->num + k));
#line 5099
      tup = _glp_mpl_expand_tuple(mpl, tup, tmp___18);
      }
#line 5101
      goto switch_break___0;
      case_83: /* CIL Label */ 
      {
#line 5103
      tmp___19 = strlen((char const   *)*(dca->str + k));
      }
#line 5103
      if (tmp___19 <= 100U) {
#line 5103
        tmp___20 = 1;
      } else {
        {
#line 5103
        _glp_lib_xassert("strlen(dca->str[k]) <= MAX_LENGTH", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         5103);
#line 5103
        tmp___20 = 1;
        }
      }
      {
#line 5104
      tmp___21 = _glp_mpl_create_string(mpl, (char *)*(dca->str + k));
#line 5104
      tmp___22 = _glp_mpl_create_symbol_str(mpl, tmp___21);
#line 5104
      tup = _glp_mpl_expand_tuple(mpl, tup, tmp___22);
      }
#line 5106
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 5108
      if ((unsigned long )dca != (unsigned long )dca) {
#line 5108
        tmp___23 = 1;
      } else {
        {
#line 5108
        _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         5108);
#line 5108
        tmp___23 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 5094
      fld = fld->next;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 5112
    if ((unsigned long )tab->u.in.set != (unsigned long )((void *)0)) {
      {
#line 5113
      tmp___24 = _glp_mpl_copy_tuple(mpl, tup);
#line 5113
      _glp_mpl_check_then_add(mpl, (((tab->u.in.set)->array)->head)->value.set, tmp___24);
      }
    }
#line 5116
    in = tab->u.in.list;
    {
#line 5116
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 5116
      if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 5116
        goto while_break___11;
      }
#line 5118
      k ++;
#line 5119
      if (k <= dca->nf) {
#line 5119
        tmp___25 = 1;
      } else {
        {
#line 5119
        _glp_lib_xassert("k <= dca->nf", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         5119);
#line 5119
        tmp___25 = 1;
        }
      }
      {
#line 5121
      tmp___27 = _glp_mpl_find_member(mpl, (in->par)->array, tup);
      }
#line 5121
      if ((unsigned long )tmp___27 != (unsigned long )((void *)0)) {
        {
#line 5122
        tmp___26 = _glp_mpl_format_tuple(mpl, '[', tup);
#line 5122
        _glp_mpl_error(mpl, (char *)"%s%s already defined", (in->par)->name, tmp___26);
        }
      }
      {
#line 5125
      tmp___28 = _glp_mpl_copy_tuple(mpl, tup);
#line 5125
      memb = _glp_mpl_add_member(mpl, (in->par)->array, tmp___28);
      }
      {
#line 5131
      if ((in->par)->type == 101) {
#line 5131
        goto case_101;
      }
#line 5131
      if ((in->par)->type == 113) {
#line 5131
        goto case_101;
      }
#line 5131
      if ((in->par)->type == 118) {
#line 5131
        goto case_101;
      }
#line 5137
      if ((in->par)->type == 124) {
#line 5137
        goto case_124;
      }
#line 5152
      goto switch_default___2;
      case_101: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_118: /* CIL Label */ 
#line 5132
      if (*(dca->type + k) != 78) {
        {
#line 5133
        _glp_mpl_error(mpl, (char *)"%s requires numeric data", (in->par)->name);
        }
      }
#line 5135
      memb->value.num = *(dca->num + k);
#line 5136
      goto switch_break___1;
      case_124: /* CIL Label */ 
      {
#line 5139
      if (*(dca->type + k) == 78) {
#line 5139
        goto case_78___0;
      }
#line 5143
      if (*(dca->type + k) == 83) {
#line 5143
        goto case_83___0;
      }
#line 5148
      goto switch_default___1;
      case_78___0: /* CIL Label */ 
      {
#line 5140
      memb->value.sym = _glp_mpl_create_symbol_num(mpl, *(dca->num + k));
      }
#line 5142
      goto switch_break___2;
      case_83___0: /* CIL Label */ 
      {
#line 5144
      tmp___29 = strlen((char const   *)*(dca->str + k));
      }
#line 5144
      if (tmp___29 <= 100U) {
#line 5144
        tmp___30 = 1;
      } else {
        {
#line 5144
        _glp_lib_xassert("strlen(dca->str[k]) <= MAX_LENGTH", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         5144);
#line 5144
        tmp___30 = 1;
        }
      }
      {
#line 5145
      tmp___31 = _glp_mpl_create_string(mpl, (char *)*(dca->str + k));
#line 5145
      memb->value.sym = _glp_mpl_create_symbol_str(mpl, tmp___31);
      }
#line 5147
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 5149
      if ((unsigned long )dca != (unsigned long )dca) {
#line 5149
        tmp___32 = 1;
      } else {
        {
#line 5149
        _glp_lib_xassert("dca != dca", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         5149);
#line 5149
        tmp___32 = 1;
        }
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 5151
      goto switch_break___1;
      switch_default___2: /* CIL Label */ 
#line 5153
      if ((unsigned long )in != (unsigned long )in) {
#line 5153
        tmp___33 = 1;
      } else {
        {
#line 5153
        _glp_lib_xassert("in != in", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                         5153);
#line 5153
        tmp___33 = 1;
        }
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 5116
      in = in->next;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 5157
    _glp_mpl_delete_tuple(mpl, tup);
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 5160
  _glp_mpl_tab_drv_close(mpl);
  }
#line 5161
  goto done;
  write_table: 
#line 5165
  if (dca->nf == 0) {
#line 5165
    tmp___34 = 1;
  } else {
    {
#line 5165
    _glp_lib_xassert("dca->nf == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5165);
#line 5165
    tmp___34 = 1;
    }
  }
#line 5166
  out = tab->u.out.list;
  {
#line 5166
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 5166
    if (! ((unsigned long )out != (unsigned long )((void *)0))) {
#line 5166
      goto while_break___12;
    }
#line 5167
    (dca->nf) ++;
#line 5166
    out = out->next;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 5168
  tmp___35 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(char *));
#line 5168
  dca->name = (char **)tmp___35;
#line 5169
  tmp___36 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(int ));
#line 5169
  dca->type = (int *)tmp___36;
#line 5170
  tmp___37 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(double ));
#line 5170
  dca->num = (double *)tmp___37;
#line 5171
  tmp___38 = _glp_lib_xcalloc(1 + dca->nf, (int )sizeof(char *));
#line 5171
  dca->str = (char **)tmp___38;
#line 5172
  k = 0;
#line 5173
  out = tab->u.out.list;
  }
  {
#line 5173
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 5173
    if (! ((unsigned long )out != (unsigned long )((void *)0))) {
#line 5173
      goto while_break___13;
    }
    {
#line 5174
    k ++;
#line 5175
    *(dca->name + k) = out->name;
#line 5176
    *(dca->type + k) = '?';
#line 5177
    *(dca->num + k) = 0.0;
#line 5178
    tmp___39 = _glp_lib_xmalloc(101);
#line 5178
    *(dca->str + k) = (char *)tmp___39;
#line 5179
    *(*(dca->str + k) + 0) = (char )'\000';
#line 5173
    out = out->next;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 5182
  _glp_mpl_tab_drv_open(mpl, 'W');
#line 5184
  _glp_mpl_loop_within_domain(mpl, tab->u.out.domain, (void *)tab, & write_func);
#line 5186
  _glp_mpl_tab_drv_close(mpl);
  }
  done: 
  {
#line 5188
  _glp_mpl_free_dca(mpl);
  }
#line 5189
  return;
}
}
#line 5192 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_free_dca(MPL *mpl ) 
{ 
  TABDCA *dca ;
  int k ;

  {
#line 5194
  dca = mpl->dca;
#line 5196
  if ((unsigned long )dca != (unsigned long )((void *)0)) {
#line 5197
    if ((unsigned long )dca->link != (unsigned long )((void *)0)) {
      {
#line 5198
      _glp_mpl_tab_drv_close(mpl);
      }
    }
#line 5199
    if ((unsigned long )dca->arg != (unsigned long )((void *)0)) {
#line 5200
      k = 1;
      {
#line 5200
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5200
        if (! (k <= dca->na)) {
#line 5200
          goto while_break;
        }
#line 5202
        if ((unsigned long )*(dca->arg + k) != (unsigned long )((void *)0)) {
          {
#line 5204
          _glp_lib_xfree((void *)*(dca->arg + k));
          }
        }
#line 5200
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 5205
      _glp_lib_xfree((void *)dca->arg);
      }
    }
#line 5207
    if ((unsigned long )dca->name != (unsigned long )((void *)0)) {
      {
#line 5207
      _glp_lib_xfree((void *)dca->name);
      }
    }
#line 5208
    if ((unsigned long )dca->type != (unsigned long )((void *)0)) {
      {
#line 5208
      _glp_lib_xfree((void *)dca->type);
      }
    }
#line 5209
    if ((unsigned long )dca->num != (unsigned long )((void *)0)) {
      {
#line 5209
      _glp_lib_xfree((void *)dca->num);
      }
    }
#line 5210
    if ((unsigned long )dca->str != (unsigned long )((void *)0)) {
#line 5211
      k = 1;
      {
#line 5211
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5211
        if (! (k <= dca->nf)) {
#line 5211
          goto while_break___0;
        }
        {
#line 5212
        _glp_lib_xfree((void *)*(dca->str + k));
#line 5211
        k ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 5213
      _glp_lib_xfree((void *)dca->str);
      }
    }
    {
#line 5215
    _glp_lib_xfree((void *)dca);
#line 5215
    mpl->dca = (TABDCA *)((void *)0);
    }
  }
#line 5217
  return;
}
}
#line 5220 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_table(MPL *mpl , TABLE *tab ) 
{ 
  TABARG *arg ;
  TABOUT *out ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 5225
  arg = tab->arg;
  {
#line 5225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5225
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 5225
      goto while_break;
    }
    {
#line 5226
    _glp_mpl_clean_code(mpl, arg->code);
#line 5225
    arg = arg->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5228
  if (tab->type == 112) {
#line 5228
    goto case_112;
  }
#line 5230
  if (tab->type == 119) {
#line 5230
    goto case_119;
  }
#line 5237
  goto switch_default;
  case_112: /* CIL Label */ 
#line 5229
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 5232
  _glp_mpl_clean_domain(mpl, tab->u.out.domain);
#line 5234
  out = tab->u.out.list;
  }
  {
#line 5234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5234
    if (! ((unsigned long )out != (unsigned long )((void *)0))) {
#line 5234
      goto while_break___0;
    }
    {
#line 5235
    _glp_mpl_clean_code(mpl, out->code);
#line 5234
    out = out->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5236
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5238
  if ((unsigned long )tab != (unsigned long )tab) {
#line 5238
    tmp = 1;
  } else {
    {
#line 5238
    _glp_lib_xassert("tab != tab", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5238);
#line 5238
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 5240
  return;
}
}
#line 5253 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int check_func(MPL *mpl , void *info ) 
{ 
  CHECK *chk ;
  TUPLE *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 5255
  chk = (CHECK *)info;
#line 5256
  tmp___1 = _glp_mpl_eval_logical(mpl, chk->code);
  }
#line 5256
  if (! tmp___1) {
    {
#line 5257
    tmp = _glp_mpl_get_domain_tuple(mpl, chk->domain);
#line 5257
    tmp___0 = _glp_mpl_format_tuple(mpl, '[', tmp);
#line 5257
    _glp_mpl_error(mpl, (char *)"check%s failed", tmp___0);
    }
  }
#line 5259
  return (0);
}
}
#line 5262 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_execute_check(MPL *mpl , CHECK *chk ) 
{ 


  {
  {
#line 5263
  _glp_mpl_loop_within_domain(mpl, chk->domain, (void *)chk, & check_func);
  }
#line 5264
  return;
}
}
#line 5273 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_check(MPL *mpl , CHECK *chk ) 
{ 


  {
  {
#line 5275
  _glp_mpl_clean_domain(mpl, chk->domain);
#line 5277
  _glp_mpl_clean_code(mpl, chk->code);
  }
#line 5278
  return;
}
}
#line 5286 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void display_set(MPL *mpl , SET *set___0 , MEMBER *memb ) 
{ 
  ELEMSET *s ;
  MEMBER *m ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 5288
  s = memb->value.set;
#line 5290
  if ((unsigned long )s->head == (unsigned long )((void *)0)) {
#line 5290
    tmp = " is empty";
  } else {
#line 5290
    tmp = ":";
  }
  {
#line 5290
  tmp___0 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5290
  _glp_mpl_write_text(mpl, (char *)"%s%s%s\n", set___0->name, tmp___0, tmp);
#line 5293
  m = s->head;
  }
  {
#line 5293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5293
    if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 5293
      goto while_break;
    }
    {
#line 5294
    tmp___1 = _glp_mpl_format_tuple(mpl, '(', m->tuple);
#line 5294
    _glp_mpl_write_text(mpl, (char *)"   %s\n", tmp___1);
#line 5293
    m = m->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5295
  return;
}
}
#line 5298 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void display_par(MPL *mpl , PARAMETER *par , MEMBER *memb ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 5303
  if (par->type == 101) {
#line 5303
    goto case_101;
  }
#line 5303
  if (par->type == 113) {
#line 5303
    goto case_101;
  }
#line 5303
  if (par->type == 118) {
#line 5303
    goto case_101;
  }
#line 5308
  if (par->type == 124) {
#line 5308
    goto case_124;
  }
#line 5313
  goto switch_default;
  case_101: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_118: /* CIL Label */ 
  {
#line 5304
  tmp = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5304
  _glp_mpl_write_text(mpl, (char *)"%s%s = %.*g\n", par->name, tmp, 15, memb->value.num);
  }
#line 5307
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 5309
  tmp___0 = _glp_mpl_format_symbol(mpl, memb->value.sym);
#line 5309
  tmp___1 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5309
  _glp_mpl_write_text(mpl, (char *)"%s%s = %s\n", par->name, tmp___1, tmp___0);
  }
#line 5312
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5314
  if ((unsigned long )par != (unsigned long )par) {
#line 5314
    tmp___2 = 1;
  } else {
    {
#line 5314
    _glp_lib_xassert("par != par", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5314);
#line 5314
    tmp___2 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 5316
  return;
}
}
#line 5319 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void display_var(MPL *mpl , VARIABLE *var , MEMBER *memb ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 5321
  if (mpl->flag_p) {
    {
#line 5322
    tmp = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5322
    _glp_mpl_write_text(mpl, (char *)"%s%s = %.*g\n", var->name, tmp, 15, (memb->value.var)->value);
    }
  } else
#line 5325
  if ((unsigned long )var->lbnd == (unsigned long )((void *)0)) {
#line 5325
    if ((unsigned long )var->ubnd == (unsigned long )((void *)0)) {
      {
#line 5326
      tmp___0 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5326
      _glp_mpl_write_text(mpl, (char *)"%s%s\n", var->name, tmp___0);
      }
    } else {
#line 5325
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 5328
  if ((unsigned long )var->ubnd == (unsigned long )((void *)0)) {
    {
#line 5329
    tmp___1 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5329
    _glp_mpl_write_text(mpl, (char *)"%s%s >= %.*g\n", var->name, tmp___1, 15, (memb->value.var)->lbnd);
    }
  } else
#line 5332
  if ((unsigned long )var->lbnd == (unsigned long )((void *)0)) {
    {
#line 5333
    tmp___2 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5333
    _glp_mpl_write_text(mpl, (char *)"%s%s <= %.*g\n", var->name, tmp___2, 15, (memb->value.var)->ubnd);
    }
  } else
#line 5336
  if ((unsigned long )var->lbnd == (unsigned long )var->ubnd) {
    {
#line 5337
    tmp___3 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5337
    _glp_mpl_write_text(mpl, (char *)"%s%s = %.*g\n", var->name, tmp___3, 15, (memb->value.var)->lbnd);
    }
  } else {
    {
#line 5341
    tmp___4 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5341
    _glp_mpl_write_text(mpl, (char *)"%.*g <= %s%s <= %.*g\n", 15, (memb->value.var)->lbnd,
                        var->name, tmp___4, 15, (memb->value.var)->ubnd);
    }
  }
#line 5345
  return;
}
}
#line 5348 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void display_con(MPL *mpl , CONSTRAINT *con , MEMBER *memb ) 
{ 
  FORMULA *term ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 5351
  if ((unsigned long )con->lbnd == (unsigned long )((void *)0)) {
#line 5351
    if ((unsigned long )con->ubnd == (unsigned long )((void *)0)) {
      {
#line 5352
      tmp = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5352
      _glp_mpl_write_text(mpl, (char *)"%s%s:\n", con->name, tmp);
      }
    } else {
#line 5351
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 5354
  if ((unsigned long )con->ubnd == (unsigned long )((void *)0)) {
    {
#line 5355
    tmp___0 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5355
    _glp_mpl_write_text(mpl, (char *)"%s%s >= %.*g:\n", con->name, tmp___0, 15, (memb->value.con)->lbnd);
    }
  } else
#line 5358
  if ((unsigned long )con->lbnd == (unsigned long )((void *)0)) {
    {
#line 5359
    tmp___1 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5359
    _glp_mpl_write_text(mpl, (char *)"%s%s <= %.*g:\n", con->name, tmp___1, 15, (memb->value.con)->ubnd);
    }
  } else
#line 5362
  if ((unsigned long )con->lbnd == (unsigned long )con->ubnd) {
    {
#line 5363
    tmp___2 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5363
    _glp_mpl_write_text(mpl, (char *)"%s%s = %.*g:\n", con->name, tmp___2, 15, (memb->value.con)->lbnd);
    }
  } else {
    {
#line 5367
    tmp___3 = _glp_mpl_format_tuple(mpl, '[', memb->tuple);
#line 5367
    _glp_mpl_write_text(mpl, (char *)"%.*g <= %s%s <= %.*g:\n", 15, (memb->value.con)->lbnd,
                        con->name, tmp___3, 15, (memb->value.con)->ubnd);
    }
  }
#line 5371
  if (con->type == 116) {
#line 5371
    goto _L___1;
  } else
#line 5371
  if (con->type == 115) {
    _L___1: /* CIL Label */ 
#line 5371
    if ((memb->value.con)->lbnd != (double )0) {
      {
#line 5373
      _glp_mpl_write_text(mpl, (char *)"   %.*g\n", 15, - (memb->value.con)->lbnd);
      }
    } else {
#line 5371
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 5374
  if ((unsigned long )(memb->value.con)->form == (unsigned long )((void *)0)) {
    {
#line 5375
    _glp_mpl_write_text(mpl, (char *)"   empty linear form\n");
    }
  }
#line 5376
  term = (memb->value.con)->form;
  {
#line 5376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5376
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 5376
      goto while_break;
    }
#line 5378
    if ((unsigned long )term->var != (unsigned long )((void *)0)) {
#line 5378
      tmp___4 = 1;
    } else {
      {
#line 5378
      _glp_lib_xassert("term->var != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       5378);
#line 5378
      tmp___4 = 1;
      }
    }
    {
#line 5379
    tmp___5 = _glp_mpl_format_tuple(mpl, '[', ((term->var)->memb)->tuple);
#line 5379
    _glp_mpl_write_text(mpl, (char *)"   %.*g %s%s\n", 15, term->coef, ((term->var)->var)->name,
                        tmp___5);
#line 5376
    term = term->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5383
  return;
}
}
#line 5386 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void display_memb(MPL *mpl , CODE *code ) 
{ 
  MEMBER memb ;
  ARG_LIST *e ;
  int tmp ;
  SYMBOL *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 5390
  if (code->op == 304) {
#line 5390
    tmp = 1;
  } else
#line 5390
  if (code->op == 305) {
#line 5390
    tmp = 1;
  } else
#line 5390
  if (code->op == 306) {
#line 5390
    tmp = 1;
  } else
#line 5390
  if (code->op == 307) {
#line 5390
    tmp = 1;
  } else {
    {
#line 5390
    _glp_lib_xassert("code->op == O_MEMNUM || code->op == O_MEMSYM || code->op == O_MEMSET || code->op == O_MEMVAR",
                     "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c", 5391);
#line 5390
    tmp = 1;
    }
  }
  {
#line 5392
  memb.tuple = _glp_mpl_create_tuple(mpl);
#line 5393
  e = code->arg.par.list;
  }
  {
#line 5393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5393
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 5393
      goto while_break;
    }
    {
#line 5394
    tmp___0 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 5394
    memb.tuple = _glp_mpl_expand_tuple(mpl, memb.tuple, tmp___0);
#line 5393
    e = e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5397
  if (code->op == 304) {
#line 5397
    goto case_304;
  }
#line 5402
  if (code->op == 305) {
#line 5402
    goto case_305;
  }
#line 5408
  if (code->op == 306) {
#line 5408
    goto case_306;
  }
#line 5413
  if (code->op == 307) {
#line 5413
    goto case_307;
  }
#line 5418
  goto switch_default;
  case_304: /* CIL Label */ 
  {
#line 5398
  memb.value.num = _glp_mpl_eval_member_num(mpl, code->arg.par.par, memb.tuple);
#line 5400
  display_par(mpl, code->arg.par.par, & memb);
  }
#line 5401
  goto switch_break;
  case_305: /* CIL Label */ 
  {
#line 5403
  memb.value.sym = _glp_mpl_eval_member_sym(mpl, code->arg.par.par, memb.tuple);
#line 5405
  display_par(mpl, code->arg.par.par, & memb);
#line 5406
  _glp_mpl_delete_symbol(mpl, memb.value.sym);
  }
#line 5407
  goto switch_break;
  case_306: /* CIL Label */ 
  {
#line 5409
  memb.value.set = _glp_mpl_eval_member_set(mpl, code->arg.set.set, memb.tuple);
#line 5411
  display_set(mpl, code->arg.set.set, & memb);
  }
#line 5412
  goto switch_break;
  case_307: /* CIL Label */ 
  {
#line 5414
  memb.value.var = _glp_mpl_eval_member_var(mpl, code->arg.var.var, memb.tuple);
#line 5416
  display_var(mpl, code->arg.var.var, & memb);
  }
#line 5417
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5419
  if ((unsigned long )code != (unsigned long )code) {
#line 5419
    tmp___1 = 1;
  } else {
    {
#line 5419
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5419);
#line 5419
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 5421
  _glp_mpl_delete_tuple(mpl, memb.tuple);
  }
#line 5422
  return;
}
}
#line 5425 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void display_code(MPL *mpl , CODE *code ) 
{ 
  double num ;
  SYMBOL *sym ;
  char *tmp ;
  int bit ;
  char const   *tmp___0 ;
  TUPLE *tuple ;
  char *tmp___1 ;
  ELEMSET *set___0 ;
  MEMBER *memb ;
  char *tmp___2 ;
  FORMULA *form ;
  FORMULA *term ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 5428
  if (code->type == 118) {
#line 5428
    goto case_118;
  }
#line 5435
  if (code->type == 124) {
#line 5435
    goto case_124;
  }
#line 5443
  if (code->type == 114) {
#line 5443
    goto case_114;
  }
#line 5450
  if (code->type == 126) {
#line 5450
    goto case_126;
  }
#line 5458
  if (code->type == 106) {
#line 5458
    goto case_106;
  }
#line 5471
  if (code->type == 110) {
#line 5471
    goto case_110;
  }
#line 5488
  goto switch_default;
  case_118: /* CIL Label */ 
  {
#line 5431
  num = _glp_mpl_eval_numeric(mpl, code);
#line 5432
  _glp_mpl_write_text(mpl, (char *)"%.*g\n", 15, num);
  }
#line 5434
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 5438
  sym = _glp_mpl_eval_symbolic(mpl, code);
#line 5439
  tmp = _glp_mpl_format_symbol(mpl, sym);
#line 5439
  _glp_mpl_write_text(mpl, (char *)"%s\n", tmp);
#line 5440
  _glp_mpl_delete_symbol(mpl, sym);
  }
#line 5442
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 5446
  bit = _glp_mpl_eval_logical(mpl, code);
  }
#line 5447
  if (bit) {
#line 5447
    tmp___0 = "true";
  } else {
#line 5447
    tmp___0 = "false";
  }
  {
#line 5447
  _glp_mpl_write_text(mpl, (char *)"%s\n", tmp___0);
  }
#line 5449
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 5453
  tuple = _glp_mpl_eval_tuple(mpl, code);
#line 5454
  tmp___1 = _glp_mpl_format_tuple(mpl, '(', tuple);
#line 5454
  _glp_mpl_write_text(mpl, (char *)"%s\n", tmp___1);
#line 5455
  _glp_mpl_delete_tuple(mpl, tuple);
  }
#line 5457
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 5462
  set___0 = _glp_mpl_eval_elemset(mpl, code);
  }
#line 5463
  if ((unsigned long )set___0->head == (unsigned long )((MEMBER *)0)) {
    {
#line 5464
    _glp_mpl_write_text(mpl, (char *)"set is empty\n");
    }
  }
#line 5465
  memb = set___0->head;
  {
#line 5465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5465
    if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 5465
      goto while_break;
    }
    {
#line 5466
    tmp___2 = _glp_mpl_format_tuple(mpl, '(', memb->tuple);
#line 5466
    _glp_mpl_write_text(mpl, (char *)"   %s\n", tmp___2);
#line 5465
    memb = memb->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5468
  _glp_mpl_delete_elemset(mpl, set___0);
  }
#line 5470
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 5474
  form = _glp_mpl_eval_formula(mpl, code);
  }
#line 5475
  if ((unsigned long )form == (unsigned long )((void *)0)) {
    {
#line 5476
    _glp_mpl_write_text(mpl, (char *)"linear form is empty\n");
    }
  }
#line 5477
  term = form;
  {
#line 5477
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5477
    if (! ((unsigned long )term != (unsigned long )((void *)0))) {
#line 5477
      goto while_break___0;
    }
#line 5478
    if ((unsigned long )term->var == (unsigned long )((void *)0)) {
      {
#line 5479
      _glp_mpl_write_text(mpl, (char *)"   %.*g\n", term->coef);
      }
    } else {
      {
#line 5481
      tmp___3 = _glp_mpl_format_tuple(mpl, '[', ((term->var)->memb)->tuple);
#line 5481
      _glp_mpl_write_text(mpl, (char *)"   %.*g %s%s\n", 15, term->coef, ((term->var)->var)->name,
                          tmp___3);
      }
    }
#line 5477
    term = term->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5485
  _glp_mpl_delete_formula(mpl, form);
  }
#line 5487
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5489
  if ((unsigned long )code != (unsigned long )code) {
#line 5489
    tmp___4 = 1;
  } else {
    {
#line 5489
    _glp_lib_xassert("code != code", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5489);
#line 5489
    tmp___4 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 5491
  return;
}
}
#line 5494 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int display_func(MPL *mpl , void *info ) 
{ 
  DISPLAY *dpy ;
  DISPLAY1 *entry ;
  DOMAIN_SLOT *slot ;
  char *tmp ;
  SET *set___0 ;
  MEMBER *memb ;
  PARAMETER *par ;
  MEMBER *memb___0 ;
  SYMBOL *tmp___0 ;
  VARIABLE *var ;
  MEMBER *memb___1 ;
  CONSTRAINT *con ;
  MEMBER *memb___2 ;
  TUPLE *tuple ;
  ARG_LIST *e ;
  ELEMCON *c ;
  SYMBOL *tmp___1 ;
  CODE *code ;
  int tmp___2 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 5496
  dpy = (DISPLAY *)info;
#line 5498
  entry = dpy->list;
  {
#line 5498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5498
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 5498
      goto while_break;
    }
#line 5499
    if (entry->type == 111) {
      {
#line 5501
      slot = entry->u.slot;
#line 5502
      tmp = _glp_mpl_format_symbol(mpl, slot->value);
#line 5502
      _glp_mpl_write_text(mpl, (char *)"%s = %s\n", slot->name, tmp);
      }
    } else
#line 5505
    if (entry->type == 122) {
#line 5507
      set___0 = entry->u.set;
#line 5509
      if ((unsigned long )set___0->assign != (unsigned long )((void *)0)) {
        {
#line 5512
        _glp_mpl_eval_whole_set(mpl, set___0);
        }
      } else {
#line 5519
        if ((unsigned long )set___0->gadget != (unsigned long )((void *)0)) {
#line 5519
          if (set___0->data == 0) {
            {
#line 5521
            saturate_set(mpl, set___0);
            }
          }
        }
#line 5524
        if ((unsigned long )(set___0->array)->head != (unsigned long )((void *)0)) {
          {
#line 5525
          _glp_mpl_eval_member_set(mpl, set___0, ((set___0->array)->head)->tuple);
          }
        }
      }
#line 5528
      if ((unsigned long )(set___0->array)->head == (unsigned long )((void *)0)) {
        {
#line 5529
        _glp_mpl_write_text(mpl, (char *)"%s has empty content\n", set___0->name);
        }
      }
#line 5530
      memb = (set___0->array)->head;
      {
#line 5530
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5530
        if (! ((unsigned long )memb != (unsigned long )((void *)0))) {
#line 5530
          goto while_break___0;
        }
        {
#line 5531
        display_set(mpl, set___0, memb);
#line 5530
        memb = memb->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 5533
    if (entry->type == 120) {
#line 5535
      par = entry->u.par;
#line 5537
      if ((unsigned long )par->assign != (unsigned long )((void *)0)) {
        {
#line 5540
        _glp_mpl_eval_whole_par(mpl, par);
        }
      } else
#line 5546
      if ((unsigned long )(par->array)->head != (unsigned long )((void *)0)) {
#line 5547
        if (par->type != 124) {
          {
#line 5548
          _glp_mpl_eval_member_num(mpl, par, ((par->array)->head)->tuple);
          }
        } else {
          {
#line 5550
          tmp___0 = _glp_mpl_eval_member_sym(mpl, par, ((par->array)->head)->tuple);
#line 5550
          _glp_mpl_delete_symbol(mpl, tmp___0);
          }
        }
      }
#line 5555
      if ((unsigned long )(par->array)->head == (unsigned long )((void *)0)) {
        {
#line 5556
        _glp_mpl_write_text(mpl, (char *)"%s has empty content\n", par->name);
        }
      }
#line 5557
      memb___0 = (par->array)->head;
      {
#line 5557
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5557
        if (! ((unsigned long )memb___0 != (unsigned long )((void *)0))) {
#line 5557
          goto while_break___1;
        }
        {
#line 5558
        display_par(mpl, par, memb___0);
#line 5557
        memb___0 = memb___0->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 5560
    if (entry->type == 127) {
#line 5562
      var = entry->u.var;
#line 5565
      if ((unsigned long )(var->array)->head == (unsigned long )((void *)0)) {
        {
#line 5566
        _glp_mpl_write_text(mpl, (char *)"%s has empty content\n", var->name);
        }
      }
#line 5567
      memb___1 = (var->array)->head;
      {
#line 5567
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5567
        if (! ((unsigned long )memb___1 != (unsigned long )((void *)0))) {
#line 5567
          goto while_break___2;
        }
        {
#line 5568
        display_var(mpl, var, memb___1);
#line 5567
        memb___1 = memb___1->next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 5570
    if (entry->type == 103) {
#line 5572
      con = entry->u.con;
#line 5573
      if ((unsigned long )entry->list == (unsigned long )((void *)0)) {
        {
#line 5576
        _glp_mpl_eval_whole_con(mpl, con);
        }
#line 5577
        if ((unsigned long )(con->array)->head == (unsigned long )((void *)0)) {
          {
#line 5578
          _glp_mpl_write_text(mpl, (char *)"%s has empty content\n", con->name);
          }
        }
#line 5579
        memb___2 = (con->array)->head;
        {
#line 5579
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 5579
          if (! ((unsigned long )memb___2 != (unsigned long )((void *)0))) {
#line 5579
            goto while_break___3;
          }
          {
#line 5580
          display_con(mpl, con, memb___2);
#line 5579
          memb___2 = memb___2->next;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        {
#line 5587
        tuple = _glp_mpl_create_tuple(mpl);
#line 5588
        e = entry->list;
        }
        {
#line 5588
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 5588
          if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 5588
            goto while_break___4;
          }
          {
#line 5589
          tmp___1 = _glp_mpl_eval_symbolic(mpl, e->x);
#line 5589
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___1);
#line 5588
          e = e->next;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 5591
        c = _glp_mpl_eval_member_con(mpl, con, tuple);
#line 5592
        _glp_mpl_delete_tuple(mpl, tuple);
#line 5593
        display_con(mpl, con, c->memb);
        }
      }
    } else
#line 5596
    if (entry->type == 108) {
#line 5598
      code = entry->u.code;
#line 5599
      if (code->op == 304) {
        {
#line 5601
        display_memb(mpl, code);
        }
      } else
#line 5599
      if (code->op == 305) {
        {
#line 5601
        display_memb(mpl, code);
        }
      } else
#line 5599
      if (code->op == 306) {
        {
#line 5601
        display_memb(mpl, code);
        }
      } else
#line 5599
      if (code->op == 307) {
        {
#line 5601
        display_memb(mpl, code);
        }
      } else {
        {
#line 5603
        display_code(mpl, code);
        }
      }
    } else
#line 5606
    if ((unsigned long )entry != (unsigned long )entry) {
#line 5606
      tmp___2 = 1;
    } else {
      {
#line 5606
      _glp_lib_xassert("entry != entry", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                       5606);
#line 5606
      tmp___2 = 1;
      }
    }
#line 5498
    entry = entry->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 5608
  return (0);
}
}
#line 5611 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_execute_display(MPL *mpl , DISPLAY *dpy ) 
{ 


  {
  {
#line 5612
  _glp_mpl_loop_within_domain(mpl, dpy->domain, (void *)dpy, & display_func);
  }
#line 5613
  return;
}
}
#line 5622 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_display(MPL *mpl , DISPLAY *dpy ) 
{ 
  DISPLAY1 *d___0 ;
  ARG_LIST *e ;

  {
  {
#line 5626
  _glp_mpl_clean_domain(mpl, dpy->domain);
#line 5628
  d___0 = dpy->list;
  }
  {
#line 5628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5628
    if (! ((unsigned long )d___0 != (unsigned long )((void *)0))) {
#line 5628
      goto while_break;
    }
#line 5630
    if (d___0->type == 108) {
      {
#line 5631
      _glp_mpl_clean_code(mpl, d___0->u.code);
      }
    }
#line 5633
    e = d___0->list;
    {
#line 5633
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5633
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 5633
        goto while_break___0;
      }
      {
#line 5634
      _glp_mpl_clean_code(mpl, e->x);
#line 5633
      e = e->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5628
    d___0 = d___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 5636
  return;
}
}
#line 5645 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void print_char(MPL *mpl , int c ) 
{ 


  {
#line 5646
  if ((unsigned long )mpl->prt_fp == (unsigned long )((void *)0)) {
    {
#line 5647
    _glp_mpl_write_char(mpl, c);
    }
  } else {
    {
#line 5649
    fputc(c, mpl->prt_fp);
    }
  }
#line 5650
  return;
}
}
#line 5653 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static void print_text(MPL *mpl , char *fmt___0  , ...) 
{ 
  va_list arg ;
  char buf[1024] ;
  char *c ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 5656
  __builtin_va_start(arg, fmt___0);
#line 5657
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fmt___0,
           arg);
#line 5658
  tmp = strlen((char const   *)(buf));
  }
#line 5658
  if ((unsigned long )tmp < sizeof(buf)) {
#line 5658
    tmp___0 = 1;
  } else {
    {
#line 5658
    _glp_lib_xassert("strlen(buf) < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5658);
#line 5658
    tmp___0 = 1;
    }
  }
  {
#line 5659
  __builtin_va_end(arg);
#line 5660
  c = buf;
  }
  {
#line 5660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5660
    if (! ((int )*c != 0)) {
#line 5660
      goto while_break;
    }
    {
#line 5660
    print_char(mpl, (int )*c);
#line 5660
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5661
  return;
}
}
#line 5665 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int printf_func(MPL *mpl , void *info ) 
{ 
  PRINTF *prt ;
  PRINTF1 *entry ;
  SYMBOL *sym ;
  char fmt___0[101] ;
  char *c ;
  char *from ;
  char save ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  double value ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double int_max ;
  double tmp___6 ;
  char value___0[101] ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 5667
  prt = (PRINTF *)info;
#line 5672
  sym = _glp_mpl_eval_symbolic(mpl, prt->fmt);
  }
#line 5673
  if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
    {
#line 5674
    sprintf((char */* __restrict  */)(fmt___0), (char const   */* __restrict  */)"%.*g",
            15, sym->num);
    }
  } else {
    {
#line 5676
    _glp_mpl_fetch_string(mpl, sym->str, (char *)(fmt___0));
    }
  }
  {
#line 5677
  _glp_mpl_delete_symbol(mpl, sym);
#line 5679
  entry = prt->list;
#line 5680
  c = fmt___0;
  }
  {
#line 5680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5680
    if (! ((int )*c != 0)) {
#line 5680
      goto while_break;
    }
#line 5681
    if ((int )*c == 37) {
#line 5683
      tmp = c;
#line 5683
      c ++;
#line 5683
      from = tmp;
#line 5684
      if ((int )*c == 37) {
        {
#line 5685
        print_char(mpl, '%');
        }
#line 5686
        goto __Cont;
      }
#line 5688
      if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 5688
        goto while_break;
      }
      {
#line 5690
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5690
        if (! ((int )*c == 45)) {
#line 5690
          if (! ((int )*c == 43)) {
#line 5690
            if (! ((int )*c == 32)) {
#line 5690
              if (! ((int )*c == 35)) {
#line 5690
                if (! ((int )*c == 48)) {
#line 5690
                  goto while_break___0;
                }
              }
            }
          }
        }
#line 5691
        c ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 5693
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 5693
        tmp___0 = __ctype_b_loc();
        }
#line 5693
        if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*c)) & 2048)) {
#line 5693
          goto while_break___1;
        }
#line 5693
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5695
      if ((int )*c == 46) {
#line 5696
        c ++;
        {
#line 5697
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 5697
          tmp___1 = __ctype_b_loc();
          }
#line 5697
          if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*c)) & 2048)) {
#line 5697
            goto while_break___2;
          }
#line 5697
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 5700
      save = *(c + 1);
#line 5700
      *(c + 1) = (char )'\000';
#line 5701
      if ((int )*c == 100) {
#line 5701
        goto _L___0;
      } else
#line 5701
      if ((int )*c == 105) {
#line 5701
        goto _L___0;
      } else
#line 5701
      if ((int )*c == 101) {
#line 5701
        goto _L___0;
      } else
#line 5701
      if ((int )*c == 69) {
#line 5701
        goto _L___0;
      } else
#line 5701
      if ((int )*c == 102) {
#line 5701
        goto _L___0;
      } else
#line 5701
      if ((int )*c == 70) {
#line 5701
        goto _L___0;
      } else
#line 5701
      if ((int )*c == 103) {
#line 5701
        goto _L___0;
      } else
#line 5701
      if ((int )*c == 71) {
        _L___0: /* CIL Label */ 
#line 5705
        if ((unsigned long )entry != (unsigned long )((void *)0)) {
#line 5705
          tmp___2 = 1;
        } else {
          {
#line 5705
          _glp_lib_xassert("entry != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           5705);
#line 5705
          tmp___2 = 1;
          }
        }
        {
#line 5707
        if ((entry->code)->type == 118) {
#line 5707
          goto case_118;
        }
#line 5710
        if ((entry->code)->type == 124) {
#line 5710
          goto case_124;
        }
#line 5718
        if ((entry->code)->type == 114) {
#line 5718
          goto case_114;
        }
#line 5724
        goto switch_default;
        case_118: /* CIL Label */ 
        {
#line 5708
        value = _glp_mpl_eval_numeric(mpl, entry->code);
        }
#line 5709
        goto switch_break;
        case_124: /* CIL Label */ 
        {
#line 5711
        sym = _glp_mpl_eval_symbolic(mpl, entry->code);
        }
#line 5712
        if ((unsigned long )sym->str != (unsigned long )((void *)0)) {
          {
#line 5713
          tmp___3 = _glp_mpl_format_symbol(mpl, sym);
#line 5713
          _glp_mpl_error(mpl, (char *)"cannot convert %s to floating-point number",
                         tmp___3);
          }
        }
        {
#line 5715
        value = sym->num;
#line 5716
        _glp_mpl_delete_symbol(mpl, sym);
        }
#line 5717
        goto switch_break;
        case_114: /* CIL Label */ 
        {
#line 5719
        tmp___4 = _glp_mpl_eval_logical(mpl, entry->code);
        }
#line 5719
        if (tmp___4) {
#line 5720
          value = 1.0;
        } else {
#line 5722
          value = 0.0;
        }
#line 5723
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 5725
        if ((unsigned long )entry != (unsigned long )entry) {
#line 5725
          tmp___5 = 1;
        } else {
          {
#line 5725
          _glp_lib_xassert("entry != entry", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           5725);
#line 5725
          tmp___5 = 1;
          }
        }
        switch_break: /* CIL Label */ ;
        }
#line 5727
        if ((int )*c == 100) {
#line 5727
          goto _L;
        } else
#line 5727
        if ((int )*c == 105) {
          _L: /* CIL Label */ 
#line 5728
          int_max = (double )2147483647;
#line 5729
          if (- int_max <= value) {
#line 5729
            if (! (value <= int_max)) {
              {
#line 5730
              _glp_mpl_error(mpl, (char *)"cannot convert %.*g to integer", 15, value);
              }
            }
          } else {
            {
#line 5730
            _glp_mpl_error(mpl, (char *)"cannot convert %.*g to integer", 15, value);
            }
          }
          {
#line 5732
          tmp___6 = floor(value + 0.5);
#line 5732
          print_text(mpl, from, (int )tmp___6);
          }
        } else {
          {
#line 5735
          print_text(mpl, from, value);
          }
        }
      } else
#line 5737
      if ((int )*c == 115) {
        {
#line 5741
        if ((entry->code)->type == 118) {
#line 5741
          goto case_118___0;
        }
#line 5745
        if ((entry->code)->type == 114) {
#line 5745
          goto case_114___0;
        }
#line 5751
        if ((entry->code)->type == 124) {
#line 5751
          goto case_124___0;
        }
#line 5759
        goto switch_default___0;
        case_118___0: /* CIL Label */ 
        {
#line 5742
        tmp___7 = _glp_mpl_eval_numeric(mpl, entry->code);
#line 5742
        sprintf((char */* __restrict  */)(value___0), (char const   */* __restrict  */)"%.*g",
                15, tmp___7);
        }
#line 5744
        goto switch_break___0;
        case_114___0: /* CIL Label */ 
        {
#line 5746
        tmp___8 = _glp_mpl_eval_logical(mpl, entry->code);
        }
#line 5746
        if (tmp___8) {
          {
#line 5747
          strcpy((char */* __restrict  */)(value___0), (char const   */* __restrict  */)"T");
          }
        } else {
          {
#line 5749
          strcpy((char */* __restrict  */)(value___0), (char const   */* __restrict  */)"F");
          }
        }
#line 5750
        goto switch_break___0;
        case_124___0: /* CIL Label */ 
        {
#line 5752
        sym = _glp_mpl_eval_symbolic(mpl, entry->code);
        }
#line 5753
        if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
          {
#line 5754
          sprintf((char */* __restrict  */)(value___0), (char const   */* __restrict  */)"%.*g",
                  15, sym->num);
          }
        } else {
          {
#line 5756
          _glp_mpl_fetch_string(mpl, sym->str, (char *)(value___0));
          }
        }
        {
#line 5757
        _glp_mpl_delete_symbol(mpl, sym);
        }
#line 5758
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 5760
        if ((unsigned long )entry != (unsigned long )entry) {
#line 5760
          tmp___9 = 1;
        } else {
          {
#line 5760
          _glp_lib_xassert("entry != entry", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                           5760);
#line 5760
          tmp___9 = 1;
          }
        }
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 5762
        print_text(mpl, from, value___0);
        }
      } else {
        {
#line 5765
        _glp_mpl_error(mpl, (char *)"format specifier missing or invalid");
        }
      }
#line 5766
      *(c + 1) = save;
#line 5767
      entry = entry->next;
    } else
#line 5769
    if ((int )*c == 92) {
#line 5771
      c ++;
#line 5772
      if ((int )*c == 116) {
        {
#line 5773
        print_char(mpl, '\t');
        }
      } else
#line 5774
      if ((int )*c == 110) {
        {
#line 5775
        print_char(mpl, '\n');
        }
      } else {
        {
#line 5777
        print_char(mpl, (int )*c);
        }
      }
    } else {
      {
#line 5781
      print_char(mpl, (int )*c);
      }
    }
    __Cont: /* CIL Label */ 
#line 5680
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5784
  return (0);
}
}
#line 5793 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_execute_printf(MPL *mpl , PRINTF *prt ) 
{ 
  SYMBOL *sym ;
  char fname[101] ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 5794
  if ((unsigned long )prt->fname == (unsigned long )((void *)0)) {
#line 5796
    if ((unsigned long )mpl->prt_fp != (unsigned long )((void *)0)) {
      {
#line 5797
      fclose(mpl->prt_fp);
#line 5797
      mpl->prt_fp = (FILE *)((void *)0);
#line 5798
      _glp_lib_xfree((void *)mpl->prt_file);
#line 5798
      mpl->prt_file = (char *)((void *)0);
      }
    }
  } else {
    {
#line 5805
    sym = _glp_mpl_eval_symbolic(mpl, prt->fname);
    }
#line 5806
    if ((unsigned long )sym->str == (unsigned long )((void *)0)) {
      {
#line 5807
      sprintf((char */* __restrict  */)(fname), (char const   */* __restrict  */)"%.*g",
              15, sym->num);
      }
    } else {
      {
#line 5809
      _glp_mpl_fetch_string(mpl, sym->str, (char *)(fname));
      }
    }
    {
#line 5810
    _glp_mpl_delete_symbol(mpl, sym);
    }
#line 5812
    if ((unsigned long )mpl->prt_fp != (unsigned long )((void *)0)) {
#line 5812
      if (! prt->app) {
        {
#line 5814
        fclose(mpl->prt_fp);
#line 5814
        mpl->prt_fp = (FILE *)((void *)0);
#line 5815
        _glp_lib_xfree((void *)mpl->prt_file);
#line 5815
        mpl->prt_file = (char *)((void *)0);
        }
      } else {
        {
#line 5812
        tmp = strcmp((char const   *)mpl->prt_file, (char const   *)(fname));
        }
#line 5812
        if (tmp != 0) {
          {
#line 5814
          fclose(mpl->prt_fp);
#line 5814
          mpl->prt_fp = (FILE *)((void *)0);
#line 5815
          _glp_lib_xfree((void *)mpl->prt_file);
#line 5815
          mpl->prt_file = (char *)((void *)0);
          }
        }
      }
    }
#line 5818
    if ((unsigned long )mpl->prt_fp == (unsigned long )((void *)0)) {
#line 5819
      if (prt->app) {
#line 5819
        tmp___0 = "a";
      } else {
#line 5819
        tmp___0 = "w";
      }
      {
#line 5819
      mpl->prt_fp = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)tmp___0);
      }
#line 5820
      if ((unsigned long )mpl->prt_fp == (unsigned long )((void *)0)) {
        {
#line 5821
        tmp___1 = __errno_location();
#line 5821
        tmp___2 = strerror(*tmp___1);
#line 5821
        _glp_mpl_error(mpl, (char *)"unable to open `%s\' for writing - %s", fname,
                       tmp___2);
        }
      }
      {
#line 5823
      tmp___3 = strlen((char const   *)(fname));
#line 5823
      tmp___4 = _glp_lib_xmalloc((int )(tmp___3 + 1U));
#line 5823
      mpl->prt_file = (char *)tmp___4;
#line 5824
      strcpy((char */* __restrict  */)mpl->prt_file, (char const   */* __restrict  */)(fname));
      }
    }
  }
  {
#line 5827
  _glp_mpl_loop_within_domain(mpl, prt->domain, (void *)prt, & printf_func);
  }
#line 5828
  if ((unsigned long )mpl->prt_fp != (unsigned long )((void *)0)) {
    {
#line 5829
    fflush(mpl->prt_fp);
#line 5830
    tmp___7 = ferror(mpl->prt_fp);
    }
#line 5830
    if (tmp___7) {
      {
#line 5831
      tmp___5 = __errno_location();
#line 5831
      tmp___6 = strerror(*tmp___5);
#line 5831
      _glp_mpl_error(mpl, (char *)"writing error to `%s\' - %s", mpl->prt_file, tmp___6);
      }
    }
  }
#line 5834
  return;
}
}
#line 5844 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_printf(MPL *mpl , PRINTF *prt ) 
{ 
  PRINTF1 *p ;

  {
  {
#line 5847
  _glp_mpl_clean_domain(mpl, prt->domain);
#line 5849
  _glp_mpl_clean_code(mpl, prt->fmt);
#line 5851
  p = prt->list;
  }
  {
#line 5851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5851
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 5851
      goto while_break;
    }
    {
#line 5853
    _glp_mpl_clean_code(mpl, p->code);
#line 5851
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5857
  _glp_mpl_clean_code(mpl, prt->fname);
  }
#line 5859
  return;
}
}
#line 5867 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
static int for_func(MPL *mpl , void *info ) 
{ 
  FOR *fur ;
  STATEMENT *stmt ;
  STATEMENT *save ;

  {
#line 5869
  fur = (FOR *)info;
#line 5871
  save = mpl->stmt;
#line 5872
  stmt = fur->list;
  {
#line 5872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5872
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 5872
      goto while_break;
    }
    {
#line 5873
    _glp_mpl_execute_statement(mpl, stmt);
#line 5872
    stmt = stmt->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5874
  mpl->stmt = save;
#line 5875
  return (0);
}
}
#line 5878 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_execute_for(MPL *mpl , FOR *fur ) 
{ 


  {
  {
#line 5879
  _glp_mpl_loop_within_domain(mpl, fur->domain, (void *)fur, & for_func);
  }
#line 5880
  return;
}
}
#line 5889 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_for(MPL *mpl , FOR *fur ) 
{ 
  STATEMENT *stmt ;

  {
  {
#line 5892
  _glp_mpl_clean_domain(mpl, fur->domain);
#line 5894
  stmt = fur->list;
  }
  {
#line 5894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5894
    if (! ((unsigned long )stmt != (unsigned long )((void *)0))) {
#line 5894
      goto while_break;
    }
    {
#line 5895
    _glp_mpl_clean_statement(mpl, stmt);
#line 5894
    stmt = stmt->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5896
  return;
}
}
#line 5904 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_execute_statement(MPL *mpl , STATEMENT *stmt ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 5905
  mpl->stmt = stmt;
  {
#line 5909
  if (stmt->type == 127) {
#line 5909
    goto case_127;
  }
#line 5909
  if (stmt->type == 120) {
#line 5909
    goto case_127;
  }
#line 5909
  if (stmt->type == 122) {
#line 5909
    goto case_127;
  }
#line 5911
  if (stmt->type == 103) {
#line 5911
    goto case_103;
  }
#line 5915
  if (stmt->type == 125) {
#line 5915
    goto case_125;
  }
#line 5928
  if (stmt->type == 123) {
#line 5928
    goto case_123;
  }
#line 5930
  if (stmt->type == 102) {
#line 5930
    goto case_102;
  }
#line 5934
  if (stmt->type == 104) {
#line 5934
    goto case_104;
  }
#line 5939
  if (stmt->type == 121) {
#line 5939
    goto case_121;
  }
#line 5942
  if (stmt->type == 109) {
#line 5942
    goto case_109;
  }
#line 5945
  goto switch_default___0;
  case_127: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_122: /* CIL Label */ 
#line 5910
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 5912
  _glp_lib_xprintf("Generating %s...\n", (stmt->u.con)->name);
#line 5913
  _glp_mpl_eval_whole_con(mpl, stmt->u.con);
  }
#line 5914
  goto switch_break;
  case_125: /* CIL Label */ 
  {
#line 5917
  if ((stmt->u.tab)->type == 112) {
#line 5917
    goto case_112;
  }
#line 5920
  if ((stmt->u.tab)->type == 119) {
#line 5920
    goto case_119;
  }
#line 5923
  goto switch_default;
  case_112: /* CIL Label */ 
  {
#line 5918
  _glp_lib_xprintf("Reading %s...\n", (stmt->u.tab)->name);
  }
#line 5919
  goto switch_break___0;
  case_119: /* CIL Label */ 
  {
#line 5921
  _glp_lib_xprintf("Writing %s...\n", (stmt->u.tab)->name);
  }
#line 5922
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 5924
  if ((unsigned long )stmt != (unsigned long )stmt) {
#line 5924
    tmp = 1;
  } else {
    {
#line 5924
    _glp_lib_xassert("stmt != stmt", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5924);
#line 5924
    tmp = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 5926
  _glp_mpl_execute_table(mpl, stmt->u.tab);
  }
#line 5927
  goto switch_break;
  case_123: /* CIL Label */ 
#line 5929
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 5931
  _glp_lib_xprintf("Checking (line %d)...\n", stmt->line);
#line 5932
  _glp_mpl_execute_check(mpl, stmt->u.chk);
  }
#line 5933
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 5935
  _glp_mpl_write_text(mpl, (char *)"Display statement at line %d\n", stmt->line);
#line 5937
  _glp_mpl_execute_display(mpl, stmt->u.dpy);
  }
#line 5938
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 5940
  _glp_mpl_execute_printf(mpl, stmt->u.prt);
  }
#line 5941
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 5943
  _glp_mpl_execute_for(mpl, stmt->u.fur);
  }
#line 5944
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 5946
  if ((unsigned long )stmt != (unsigned long )stmt) {
#line 5946
    tmp___0 = 1;
  } else {
    {
#line 5946
    _glp_lib_xassert("stmt != stmt", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5946);
#line 5946
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 5948
  return;
}
}
#line 5957 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c"
void _glp_mpl_clean_statement(MPL *mpl , STATEMENT *stmt ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 5959
  if (stmt->type == 122) {
#line 5959
    goto case_122;
  }
#line 5961
  if (stmt->type == 120) {
#line 5961
    goto case_120;
  }
#line 5963
  if (stmt->type == 127) {
#line 5963
    goto case_127;
  }
#line 5965
  if (stmt->type == 103) {
#line 5965
    goto case_103;
  }
#line 5968
  if (stmt->type == 125) {
#line 5968
    goto case_125;
  }
#line 5971
  if (stmt->type == 123) {
#line 5971
    goto case_123;
  }
#line 5973
  if (stmt->type == 102) {
#line 5973
    goto case_102;
  }
#line 5975
  if (stmt->type == 104) {
#line 5975
    goto case_104;
  }
#line 5977
  if (stmt->type == 121) {
#line 5977
    goto case_121;
  }
#line 5979
  if (stmt->type == 109) {
#line 5979
    goto case_109;
  }
#line 5981
  goto switch_default;
  case_122: /* CIL Label */ 
  {
#line 5960
  _glp_mpl_clean_set(mpl, stmt->u.set);
  }
#line 5960
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 5962
  _glp_mpl_clean_parameter(mpl, stmt->u.par);
  }
#line 5962
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 5964
  _glp_mpl_clean_variable(mpl, stmt->u.var);
  }
#line 5964
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 5966
  _glp_mpl_clean_constraint(mpl, stmt->u.con);
  }
#line 5966
  goto switch_break;
  case_125: /* CIL Label */ 
  {
#line 5969
  _glp_mpl_clean_table(mpl, stmt->u.tab);
  }
#line 5969
  goto switch_break;
  case_123: /* CIL Label */ 
#line 5972
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 5974
  _glp_mpl_clean_check(mpl, stmt->u.chk);
  }
#line 5974
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 5976
  _glp_mpl_clean_display(mpl, stmt->u.dpy);
  }
#line 5976
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 5978
  _glp_mpl_clean_printf(mpl, stmt->u.prt);
  }
#line 5978
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 5980
  _glp_mpl_clean_for(mpl, stmt->u.fur);
  }
#line 5980
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5982
  if ((unsigned long )stmt != (unsigned long )stmt) {
#line 5982
    tmp = 1;
  } else {
    {
#line 5982
    _glp_lib_xassert("stmt != stmt", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl03.c",
                     5982);
#line 5982
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 5984
  return;
}
}
#line 105 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
int _glp_avl_get_node_type(AVLNODE *node ) ;
#line 351 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
void _glp_mpl_unget_token(MPL *mpl ) ;
#line 617
SLICE *_glp_mpl_create_slice(MPL *mpl ) ;
#line 621
SLICE *_glp_mpl_expand_slice(MPL *mpl , SLICE *slice , SYMBOL *sym ) ;
#line 629
int _glp_mpl_slice_dimen(MPL *mpl , SLICE *slice ) ;
#line 636
int _glp_mpl_slice_arity(MPL *mpl , SLICE *slice ) ;
#line 643
SLICE *_glp_mpl_fake_slice(MPL *mpl , int dim ) ;
#line 647
void _glp_mpl_delete_slice(MPL *mpl , SLICE *slice ) ;
#line 654
int _glp_mpl_is_number(MPL *mpl ) ;
#line 658
int _glp_mpl_is_symbol(MPL *mpl ) ;
#line 666
double _glp_mpl_read_number(MPL *mpl ) ;
#line 670
SYMBOL *_glp_mpl_read_symbol(MPL *mpl ) ;
#line 674
SLICE *_glp_mpl_read_slice(MPL *mpl , char *name , int dim ) ;
#line 682
SET *_glp_mpl_select_set(MPL *mpl , char *name ) ;
#line 689
void _glp_mpl_simple_format(MPL *mpl , SET *set___0 , MEMBER *memb , SLICE *slice ) ;
#line 698
void _glp_mpl_matrix_format(MPL *mpl , SET *set___0 , MEMBER *memb , SLICE *slice ,
                            int tr ) ;
#line 708
void _glp_mpl_set_data(MPL *mpl ) ;
#line 712
PARAMETER *_glp_mpl_select_parameter(MPL *mpl , char *name ) ;
#line 719
void _glp_mpl_set_default(MPL *mpl , PARAMETER *par , SYMBOL *altval ) ;
#line 727
MEMBER *_glp_mpl_read_value(MPL *mpl , PARAMETER *par , TUPLE *tuple ) ;
#line 735
void _glp_mpl_plain_format(MPL *mpl , PARAMETER *par , SLICE *slice ) ;
#line 743
void _glp_mpl_tabular_format(MPL *mpl , PARAMETER *par , SLICE *slice , int tr ) ;
#line 752
void _glp_mpl_tabbing_format(MPL *mpl , SYMBOL *altval ) ;
#line 759
void _glp_mpl_parameter_data(MPL *mpl ) ;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
SLICE *_glp_mpl_create_slice(MPL *mpl ) 
{ 
  SLICE *slice ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 39
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 39
    tmp = 1;
  } else {
    {
#line 39
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     39);
#line 39
    tmp = 1;
    }
  }
#line 40
  slice = (SLICE *)((void *)0);
#line 41
  return (slice);
}
}
#line 50 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
SLICE *_glp_mpl_expand_slice(MPL *mpl , SLICE *slice , SYMBOL *sym ) 
{ 
  SLICE *tail ;
  SLICE *temp ;
  void *tmp ;

  {
  {
#line 57
  tmp = _glp_dmp_get_atom(mpl->tuples, (int )sizeof(SLICE ));
#line 57
  tail = (SLICE *)tmp;
#line 58
  tail->sym = sym;
#line 59
  tail->next = (TUPLE *)((void *)0);
  }
#line 61
  if ((unsigned long )slice == (unsigned long )((void *)0)) {
#line 62
    slice = tail;
  } else {
#line 64
    temp = slice;
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
#line 64
      if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 64
        goto while_break;
      }
#line 64
      temp = temp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 65
    temp->next = tail;
  }
#line 67
  return (slice);
}
}
#line 76 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
int _glp_mpl_slice_dimen(MPL *mpl , SLICE *slice ) 
{ 
  SLICE *temp ;
  int dim ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 82
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 82
    tmp = 1;
  } else {
    {
#line 82
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     82);
#line 82
    tmp = 1;
    }
  }
#line 83
  dim = 0;
#line 84
  temp = slice;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 84
      goto while_break;
    }
#line 84
    dim ++;
#line 84
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (dim);
}
}
#line 94 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
int _glp_mpl_slice_arity(MPL *mpl , SLICE *slice ) 
{ 
  SLICE *temp ;
  int arity ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 100
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 100
    tmp = 1;
  } else {
    {
#line 100
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     100);
#line 100
    tmp = 1;
    }
  }
#line 101
  arity = 0;
#line 102
  temp = slice;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 102
      goto while_break;
    }
#line 103
    if ((unsigned long )temp->sym == (unsigned long )((void *)0)) {
#line 103
      arity ++;
    }
#line 102
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (arity);
}
}
#line 113 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
SLICE *_glp_mpl_fake_slice(MPL *mpl , int dim ) 
{ 
  SLICE *slice ;
  int tmp ;

  {
  {
#line 115
  slice = _glp_mpl_create_slice(mpl);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    tmp = dim;
#line 116
    dim --;
#line 116
    if (! (tmp > 0)) {
#line 116
      goto while_break;
    }
    {
#line 116
    slice = _glp_mpl_expand_slice(mpl, slice, (SYMBOL *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return (slice);
}
}
#line 125 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_delete_slice(MPL *mpl , SLICE *slice ) 
{ 
  SLICE *temp ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! ((unsigned long )slice != (unsigned long )((void *)0))) {
#line 130
      goto while_break;
    }
#line 131
    temp = slice;
#line 132
    slice = temp->next;
#line 133
    if ((unsigned long )temp->sym != (unsigned long )((void *)0)) {
      {
#line 133
      _glp_mpl_delete_symbol(mpl, temp->sym);
      }
    }
#line 134
    if (sizeof(SLICE ) == sizeof(TUPLE )) {
#line 134
      tmp = 1;
    } else {
      {
#line 134
      _glp_lib_xassert("sizeof(SLICE) == sizeof(TUPLE)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                       134);
#line 134
      tmp = 1;
      }
    }
    {
#line 135
    _glp_dmp_free_atom(mpl->tuples, (void *)temp, (int )sizeof(TUPLE ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 146 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
int _glp_mpl_is_number(MPL *mpl ) 
{ 


  {
#line 147
  return (mpl->token == 204);
}
}
#line 157 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
int _glp_mpl_is_symbol(MPL *mpl ) 
{ 
  int tmp ;

  {
#line 158
  if (mpl->token == 204) {
#line 158
    tmp = 1;
  } else
#line 158
  if (mpl->token == 203) {
#line 158
    tmp = 1;
  } else
#line 158
  if (mpl->token == 205) {
#line 158
    tmp = 1;
  } else {
#line 158
    tmp = 0;
  }
#line 158
  return (tmp);
}
}
#line 173 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
int _glp_mpl_is_literal(MPL *mpl , char *literal ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 174
  tmp = _glp_mpl_is_symbol(mpl);
  }
#line 174
  if (tmp) {
    {
#line 174
    tmp___0 = strcmp((char const   *)mpl->image, (char const   *)literal);
    }
#line 174
    if (tmp___0 == 0) {
#line 174
      tmp___1 = 1;
    } else {
#line 174
      tmp___1 = 0;
    }
  } else {
#line 174
    tmp___1 = 0;
  }
#line 174
  return (tmp___1);
}
}
#line 184 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
double _glp_mpl_read_number(MPL *mpl ) 
{ 
  double num ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 186
  tmp = _glp_mpl_is_number(mpl);
  }
#line 186
  if (tmp) {
#line 186
    tmp___0 = 1;
  } else {
    {
#line 186
    _glp_lib_xassert("is_number(mpl)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     186);
#line 186
    tmp___0 = 1;
    }
  }
  {
#line 187
  num = mpl->value;
#line 188
  _glp_mpl_get_token(mpl);
  }
#line 189
  return (num);
}
}
#line 198 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
SYMBOL *_glp_mpl_read_symbol(MPL *mpl ) 
{ 
  SYMBOL *sym ;
  int tmp ;
  int tmp___0 ;
  STRING *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 200
  tmp = _glp_mpl_is_symbol(mpl);
  }
#line 200
  if (tmp) {
#line 200
    tmp___0 = 1;
  } else {
    {
#line 200
    _glp_lib_xassert("is_symbol(mpl)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     200);
#line 200
    tmp___0 = 1;
    }
  }
  {
#line 201
  tmp___2 = _glp_mpl_is_number(mpl);
  }
#line 201
  if (tmp___2) {
    {
#line 202
    sym = _glp_mpl_create_symbol_num(mpl, mpl->value);
    }
  } else {
    {
#line 204
    tmp___1 = _glp_mpl_create_string(mpl, (char *)mpl->image);
#line 204
    sym = _glp_mpl_create_symbol_str(mpl, tmp___1);
    }
  }
  {
#line 205
  _glp_mpl_get_token(mpl);
  }
#line 206
  return (sym);
}
}
#line 224 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
SLICE *_glp_mpl_read_slice(MPL *mpl , char *name , int dim ) 
{ 
  SLICE *slice ;
  int close ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  SYMBOL *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 231
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 231
    tmp = 1;
  } else {
    {
#line 231
    _glp_lib_xassert("name != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     231);
#line 231
    tmp = 1;
    }
  }
  {
#line 233
  if (mpl->token == 246) {
#line 233
    goto case_246;
  }
#line 236
  if (mpl->token == 244) {
#line 236
    goto case_244;
  }
#line 240
  goto switch_default;
  case_246: /* CIL Label */ 
#line 234
  close = 247;
#line 235
  goto switch_break;
  case_244: /* CIL Label */ 
#line 237
  if (dim > 0) {
#line 237
    tmp___0 = 1;
  } else {
    {
#line 237
    _glp_lib_xassert("dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     237);
#line 237
    tmp___0 = 1;
    }
  }
#line 238
  close = 245;
#line 239
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 241
  if ((unsigned long )mpl != (unsigned long )mpl) {
#line 241
    tmp___1 = 1;
  } else {
    {
#line 241
    _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     241);
#line 241
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 243
  if (dim == 0) {
    {
#line 244
    _glp_mpl_error(mpl, (char *)"%s cannot be subscripted", name);
    }
  }
  {
#line 245
  _glp_mpl_get_token(mpl);
#line 247
  slice = _glp_mpl_create_slice(mpl);
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 250
    tmp___3 = _glp_mpl_is_symbol(mpl);
    }
#line 250
    if (tmp___3) {
      {
#line 251
      tmp___2 = _glp_mpl_read_symbol(mpl);
#line 251
      slice = _glp_mpl_expand_slice(mpl, slice, tmp___2);
      }
    } else
#line 252
    if (mpl->token == 227) {
      {
#line 253
      slice = _glp_mpl_expand_slice(mpl, slice, (SYMBOL *)((void *)0));
#line 254
      _glp_mpl_get_token(mpl);
      }
    } else {
      {
#line 257
      _glp_mpl_error(mpl, (char *)"number, symbol, or asterisk missing where expected");
      }
    }
#line 260
    if (mpl->token == 239) {
      {
#line 261
      _glp_mpl_get_token(mpl);
      }
    } else
#line 262
    if (mpl->token == close) {
#line 263
      goto while_break;
    } else {
      {
#line 265
      _glp_mpl_error(mpl, (char *)"syntax error in slice");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  tmp___8 = _glp_mpl_slice_dimen(mpl, slice);
  }
#line 269
  if (tmp___8 != dim) {
    {
#line 271
    if (close == 247) {
#line 271
      goto case_247;
    }
#line 275
    if (close == 245) {
#line 275
      goto case_245;
    }
#line 279
    goto switch_default___0;
    case_247: /* CIL Label */ 
    {
#line 272
    tmp___4 = _glp_mpl_slice_dimen(mpl, slice);
    }
#line 272
    if (dim == 1) {
#line 272
      tmp___5 = "";
    } else {
#line 272
      tmp___5 = "s";
    }
    {
#line 272
    _glp_mpl_error(mpl, (char *)"%s must have %d subscript%s, not %d", name, dim,
                   tmp___5, tmp___4);
    }
#line 274
    goto switch_break___0;
    case_245: /* CIL Label */ 
    {
#line 276
    tmp___6 = _glp_mpl_slice_dimen(mpl, slice);
#line 276
    _glp_mpl_error(mpl, (char *)"%s has dimension %d, not %d", name, dim, tmp___6);
    }
#line 278
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 280
    if (close != close) {
#line 280
      tmp___7 = 1;
    } else {
      {
#line 280
      _glp_lib_xassert("close != close", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                       280);
#line 280
      tmp___7 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 283
  _glp_mpl_get_token(mpl);
  }
#line 284
  return (slice);
}
}
#line 293 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
SET *_glp_mpl_select_set(MPL *mpl , char *name ) 
{ 
  SET *set___0 ;
  AVLNODE *node ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 299
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 299
    tmp = 1;
  } else {
    {
#line 299
    _glp_lib_xassert("name != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     299);
#line 299
    tmp = 1;
    }
  }
  {
#line 300
  node = _glp_avl_find_node(mpl->tree, (void const   *)name);
  }
#line 301
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 302
    _glp_mpl_error(mpl, (char *)"%s not a set", name);
    }
  } else {
    {
#line 301
    tmp___0 = _glp_avl_get_node_type(node);
    }
#line 301
    if (tmp___0 != 122) {
      {
#line 302
      _glp_mpl_error(mpl, (char *)"%s not a set", name);
      }
    }
  }
  {
#line 303
  tmp___1 = _glp_avl_get_node_link(node);
#line 303
  set___0 = (SET *)tmp___1;
  }
#line 304
  if ((unsigned long )set___0->assign != (unsigned long )((void *)0)) {
    {
#line 305
    _glp_mpl_error(mpl, (char *)"%s needs no data", name);
    }
  } else
#line 304
  if ((unsigned long )set___0->gadget != (unsigned long )((void *)0)) {
    {
#line 305
    _glp_mpl_error(mpl, (char *)"%s needs no data", name);
    }
  }
#line 306
  set___0->data = 1;
#line 307
  return (set___0);
}
}
#line 330 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_simple_format(MPL *mpl , SET *set___0 , MEMBER *memb , SLICE *slice ) 
{ 
  TUPLE *tuple ;
  SLICE *temp ;
  SYMBOL *sym ;
  SYMBOL *with ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int lack ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 338
  with = (SYMBOL *)((void *)0);
#line 339
  if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
#line 339
    tmp = 1;
  } else {
    {
#line 339
    _glp_lib_xassert("set != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     339);
#line 339
    tmp = 1;
    }
  }
#line 340
  if ((unsigned long )memb != (unsigned long )((void *)0)) {
#line 340
    tmp___0 = 1;
  } else {
    {
#line 340
    _glp_lib_xassert("memb != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     340);
#line 340
    tmp___0 = 1;
    }
  }
#line 341
  if ((unsigned long )slice != (unsigned long )((void *)0)) {
#line 341
    tmp___1 = 1;
  } else {
    {
#line 341
    _glp_lib_xassert("slice != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     341);
#line 341
    tmp___1 = 1;
    }
  }
  {
#line 342
  tmp___2 = _glp_mpl_slice_dimen(mpl, slice);
  }
#line 342
  if (set___0->dimen == tmp___2) {
#line 342
    tmp___3 = 1;
  } else {
    {
#line 342
    _glp_lib_xassert("set->dimen == slice_dimen(mpl, slice)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     342);
#line 342
    tmp___3 = 1;
    }
  }
#line 343
  if ((memb->value.set)->dim == set___0->dimen) {
#line 343
    tmp___4 = 1;
  } else {
    {
#line 343
    _glp_lib_xassert("memb->value.set->dim == set->dimen", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     343);
#line 343
    tmp___4 = 1;
    }
  }
  {
#line 344
  tmp___7 = _glp_mpl_slice_arity(mpl, slice);
  }
#line 344
  if (tmp___7 > 0) {
    {
#line 344
    tmp___5 = _glp_mpl_is_symbol(mpl);
    }
#line 344
    if (tmp___5) {
#line 344
      tmp___6 = 1;
    } else {
      {
#line 344
      _glp_lib_xassert("is_symbol(mpl)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                       344);
#line 344
      tmp___6 = 1;
      }
    }
  }
  {
#line 346
  tuple = _glp_mpl_create_tuple(mpl);
#line 347
  temp = slice;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 347
      goto while_break;
    }
#line 348
    if ((unsigned long )temp->sym == (unsigned long )((void *)0)) {
      {
#line 350
      tmp___12 = _glp_mpl_is_symbol(mpl);
      }
#line 350
      if (! tmp___12) {
        {
#line 351
        tmp___8 = _glp_mpl_slice_arity(mpl, temp);
#line 351
        lack = tmp___8;
        }
#line 353
        if ((unsigned long )with != (unsigned long )((void *)0)) {
#line 353
          tmp___9 = 1;
        } else {
          {
#line 353
          _glp_lib_xassert("with != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                           353);
#line 353
          tmp___9 = 1;
          }
        }
#line 354
        if (lack == 1) {
          {
#line 355
          tmp___10 = _glp_mpl_format_symbol(mpl, with);
#line 355
          _glp_mpl_error(mpl, (char *)"one item missing in data group beginning with %s",
                         tmp___10);
          }
        } else {
          {
#line 358
          tmp___11 = _glp_mpl_format_symbol(mpl, with);
#line 358
          _glp_mpl_error(mpl, (char *)"%d items missing in data group beginning with %s",
                         lack, tmp___11);
          }
        }
      }
      {
#line 361
      sym = _glp_mpl_read_symbol(mpl);
      }
#line 362
      if ((unsigned long )with == (unsigned long )((void *)0)) {
#line 362
        with = sym;
      }
    } else {
      {
#line 366
      sym = _glp_mpl_copy_symbol(mpl, temp->sym);
      }
    }
    {
#line 369
    tuple = _glp_mpl_expand_tuple(mpl, tuple, sym);
    }
#line 371
    if ((unsigned long )temp->next != (unsigned long )((void *)0)) {
#line 371
      if (mpl->token == 239) {
        {
#line 372
        _glp_mpl_get_token(mpl);
        }
      }
    }
#line 347
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 375
  _glp_mpl_check_then_add(mpl, memb->value.set, tuple);
  }
#line 376
  return;
}
}
#line 402 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_matrix_format(MPL *mpl , SET *set___0 , MEMBER *memb , SLICE *slice ,
                            int tr ) 
{ 
  SLICE *list ;
  SLICE *col ;
  SLICE *temp ;
  TUPLE *tuple ;
  SYMBOL *row ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  SYMBOL *tmp___8 ;
  int which ;
  int lack ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  SYMBOL *tmp___14 ;
  SYMBOL *tmp___15 ;
  SYMBOL *tmp___16 ;
  SYMBOL *tmp___17 ;
  int tmp___18 ;
  SYMBOL *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 412
  if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
#line 412
    tmp = 1;
  } else {
    {
#line 412
    _glp_lib_xassert("set != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     412);
#line 412
    tmp = 1;
    }
  }
#line 413
  if ((unsigned long )memb != (unsigned long )((void *)0)) {
#line 413
    tmp___0 = 1;
  } else {
    {
#line 413
    _glp_lib_xassert("memb != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     413);
#line 413
    tmp___0 = 1;
    }
  }
#line 414
  if ((unsigned long )slice != (unsigned long )((void *)0)) {
#line 414
    tmp___1 = 1;
  } else {
    {
#line 414
    _glp_lib_xassert("slice != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     414);
#line 414
    tmp___1 = 1;
    }
  }
  {
#line 415
  tmp___2 = _glp_mpl_slice_dimen(mpl, slice);
  }
#line 415
  if (set___0->dimen == tmp___2) {
#line 415
    tmp___3 = 1;
  } else {
    {
#line 415
    _glp_lib_xassert("set->dimen == slice_dimen(mpl, slice)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     415);
#line 415
    tmp___3 = 1;
    }
  }
#line 416
  if ((memb->value.set)->dim == set___0->dimen) {
#line 416
    tmp___4 = 1;
  } else {
    {
#line 416
    _glp_lib_xassert("memb->value.set->dim == set->dimen", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     416);
#line 416
    tmp___4 = 1;
    }
  }
  {
#line 417
  tmp___5 = _glp_mpl_slice_arity(mpl, slice);
  }
#line 417
  if (tmp___5 == 2) {
#line 417
    tmp___6 = 1;
  } else {
    {
#line 417
    _glp_lib_xassert("slice_arity(mpl, slice) == 2", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     417);
#line 417
    tmp___6 = 1;
    }
  }
  {
#line 420
  list = _glp_mpl_create_slice(mpl);
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (mpl->token != 242)) {
#line 421
      goto while_break;
    }
    {
#line 423
    tmp___7 = _glp_mpl_is_symbol(mpl);
    }
#line 423
    if (! tmp___7) {
      {
#line 424
      _glp_mpl_error(mpl, (char *)"number, symbol, or := missing where expected");
      }
    }
    {
#line 425
    tmp___8 = _glp_mpl_read_symbol(mpl);
#line 425
    list = _glp_mpl_expand_slice(mpl, list, tmp___8);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  _glp_mpl_get_token(mpl);
  }
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 429
    tmp___21 = _glp_mpl_is_symbol(mpl);
    }
#line 429
    if (! tmp___21) {
#line 429
      goto while_break___0;
    }
    {
#line 432
    row = _glp_mpl_read_symbol(mpl);
#line 434
    col = list;
    }
    {
#line 434
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 434
      if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 434
        goto while_break___1;
      }
      {
#line 435
      which = 0;
#line 437
      tmp___13 = _glp_mpl_is_literal(mpl, (char *)"+");
      }
#line 437
      if (! tmp___13) {
        {
#line 439
        tmp___12 = _glp_mpl_is_literal(mpl, (char *)"-");
        }
#line 439
        if (tmp___12) {
          {
#line 440
          _glp_mpl_get_token(mpl);
          }
#line 441
          goto __Cont;
        } else {
          {
#line 444
          tmp___9 = _glp_mpl_slice_dimen(mpl, col);
#line 444
          lack = tmp___9;
          }
#line 445
          if (lack == 1) {
            {
#line 446
            tmp___10 = _glp_mpl_format_symbol(mpl, row);
#line 446
            _glp_mpl_error(mpl, (char *)"one item missing in data group beginning with %s",
                           tmp___10);
            }
          } else {
            {
#line 449
            tmp___11 = _glp_mpl_format_symbol(mpl, row);
#line 449
            _glp_mpl_error(mpl, (char *)"%d items missing in data group beginning with %s",
                           lack, tmp___11);
            }
          }
        }
      }
      {
#line 453
      tuple = _glp_mpl_create_tuple(mpl);
#line 454
      temp = slice;
      }
      {
#line 454
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 454
        if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 454
          goto while_break___2;
        }
#line 455
        if ((unsigned long )temp->sym == (unsigned long )((void *)0)) {
#line 457
          which ++;
          {
#line 458
          if (which == 1) {
#line 458
            goto case_1;
          }
#line 463
          if (which == 2) {
#line 463
            goto case_2;
          }
#line 468
          goto switch_default;
          case_1: /* CIL Label */ 
#line 460
          if (tr) {
#line 460
            tmp___14 = col->sym;
          } else {
#line 460
            tmp___14 = row;
          }
          {
#line 460
          tmp___15 = _glp_mpl_copy_symbol(mpl, tmp___14);
#line 460
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___15);
          }
#line 462
          goto switch_break;
          case_2: /* CIL Label */ 
#line 465
          if (tr) {
#line 465
            tmp___16 = row;
          } else {
#line 465
            tmp___16 = col->sym;
          }
          {
#line 465
          tmp___17 = _glp_mpl_copy_symbol(mpl, tmp___16);
#line 465
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___17);
          }
#line 467
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 469
          if (which != which) {
#line 469
            tmp___18 = 1;
          } else {
            {
#line 469
            _glp_lib_xassert("which != which", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                             469);
#line 469
            tmp___18 = 1;
            }
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 474
          tmp___19 = _glp_mpl_copy_symbol(mpl, temp->sym);
#line 474
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___19);
          }
        }
#line 454
        temp = temp->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 478
      if (which == 2) {
#line 478
        tmp___20 = 1;
      } else {
        {
#line 478
        _glp_lib_xassert("which == 2", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                         478);
#line 478
        tmp___20 = 1;
        }
      }
      {
#line 480
      _glp_mpl_check_then_add(mpl, memb->value.set, tuple);
#line 481
      _glp_mpl_get_token(mpl);
      }
      __Cont: /* CIL Label */ 
#line 434
      col = col->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 484
    _glp_mpl_delete_symbol(mpl, row);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  _glp_mpl_delete_slice(mpl, list);
  }
#line 488
  return;
}
}
#line 509 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_set_data(MPL *mpl ) 
{ 
  SET *set___0 ;
  TUPLE *tuple ;
  MEMBER *memb ;
  SLICE *slice ;
  int tr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  SYMBOL *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  MEMBER *tmp___8 ;
  int is_tr ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 514
  tr = 0;
#line 515
  tmp = _glp_mpl_is_literal(mpl, (char *)"set");
  }
#line 515
  if (tmp) {
#line 515
    tmp___0 = 1;
  } else {
    {
#line 515
    _glp_lib_xassert("is_literal(mpl, \"set\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     515);
#line 515
    tmp___0 = 1;
    }
  }
  {
#line 516
  _glp_mpl_get_token(mpl);
#line 518
  tmp___1 = _glp_mpl_is_symbol(mpl);
  }
#line 518
  if (! tmp___1) {
    {
#line 519
    _glp_mpl_error(mpl, (char *)"set name missing where expected");
    }
  }
  {
#line 521
  set___0 = _glp_mpl_select_set(mpl, mpl->image);
#line 522
  _glp_mpl_get_token(mpl);
#line 525
  tuple = _glp_mpl_create_tuple(mpl);
  }
#line 526
  if (mpl->token == 246) {
#line 528
    if (set___0->dim == 0) {
      {
#line 529
      _glp_mpl_error(mpl, (char *)"%s cannot be subscripted", set___0->name);
      }
    }
    {
#line 530
    _glp_mpl_get_token(mpl);
    }
    {
#line 532
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 533
      tmp___2 = _glp_mpl_is_symbol(mpl);
      }
#line 533
      if (! tmp___2) {
        {
#line 534
        _glp_mpl_error(mpl, (char *)"number or symbol missing where expected");
        }
      }
      {
#line 535
      tmp___3 = _glp_mpl_read_symbol(mpl);
#line 535
      tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___3);
      }
#line 536
      if (mpl->token == 239) {
        {
#line 537
        _glp_mpl_get_token(mpl);
        }
      } else
#line 538
      if (mpl->token == 247) {
#line 539
        goto while_break;
      } else {
        {
#line 541
        _glp_mpl_error(mpl, (char *)"syntax error in subscript list");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 543
    tmp___6 = _glp_mpl_tuple_dimen(mpl, tuple);
    }
#line 543
    if (set___0->dim != tmp___6) {
      {
#line 544
      tmp___4 = _glp_mpl_tuple_dimen(mpl, tuple);
      }
#line 544
      if (set___0->dim == 1) {
#line 544
        tmp___5 = "";
      } else {
#line 544
        tmp___5 = "s";
      }
      {
#line 544
      _glp_mpl_error(mpl, (char *)"%s must have %d subscript%s rather than %d", set___0->name,
                     set___0->dim, tmp___5, tmp___4);
      }
    }
    {
#line 547
    _glp_mpl_get_token(mpl);
    }
  } else
#line 551
  if (set___0->dim != 0) {
    {
#line 552
    _glp_mpl_error(mpl, (char *)"%s must be subscripted", set___0->name);
    }
  }
  {
#line 555
  tmp___8 = _glp_mpl_find_member(mpl, set___0->array, tuple);
  }
#line 555
  if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
    {
#line 556
    tmp___7 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 556
    _glp_mpl_error(mpl, (char *)"%s%s already defined", set___0->name, tmp___7);
    }
  }
  {
#line 559
  memb = _glp_mpl_add_member(mpl, set___0->array, tuple);
#line 560
  memb->value.set = _glp_mpl_create_elemset(mpl, set___0->dimen);
#line 562
  slice = _glp_mpl_fake_slice(mpl, set___0->dimen);
  }
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 566
    if (mpl->token == 239) {
      {
#line 566
      _glp_mpl_get_token(mpl);
      }
    }
#line 568
    if (mpl->token == 242) {
      {
#line 570
      _glp_mpl_get_token(mpl);
      }
    } else
#line 572
    if (mpl->token == 244) {
      {
#line 576
      _glp_mpl_get_token(mpl);
#line 577
      is_tr = _glp_mpl_is_literal(mpl, (char *)"tr");
#line 578
      _glp_mpl_unget_token(mpl);
      }
#line 579
      if (is_tr) {
#line 579
        goto left;
      }
      {
#line 581
      _glp_mpl_delete_slice(mpl, slice);
#line 582
      slice = _glp_mpl_read_slice(mpl, set___0->name, set___0->dimen);
#line 584
      tr = 0;
#line 587
      tmp___9 = _glp_mpl_slice_arity(mpl, slice);
      }
#line 587
      if (tmp___9 == 0) {
        {
#line 588
        _glp_mpl_simple_format(mpl, set___0, memb, slice);
        }
      }
    } else {
      {
#line 590
      tmp___14 = _glp_mpl_is_symbol(mpl);
      }
#line 590
      if (tmp___14) {
        {
#line 592
        _glp_mpl_simple_format(mpl, set___0, memb, slice);
        }
      } else
#line 594
      if (mpl->token == 240) {
        {
#line 596
        tmp___11 = _glp_mpl_slice_arity(mpl, slice);
        }
#line 596
        if (tmp___11 != 2) {
          err1: 
          {
#line 597
          tmp___10 = _glp_mpl_slice_arity(mpl, slice);
#line 597
          _glp_mpl_error(mpl, (char *)"slice currently used must specify 2 asterisks, not %d",
                         tmp___10);
          }
        }
        {
#line 599
        _glp_mpl_get_token(mpl);
#line 601
        _glp_mpl_matrix_format(mpl, set___0, memb, slice, tr);
        }
      } else
#line 603
      if (mpl->token == 244) {
        left: 
        {
#line 606
        _glp_mpl_get_token(mpl);
#line 607
        tmp___12 = _glp_mpl_is_literal(mpl, (char *)"tr");
        }
#line 607
        if (! tmp___12) {
          err2: 
          {
#line 608
          _glp_mpl_error(mpl, (char *)"transpose indicator (tr) incomplete");
          }
        }
        {
#line 609
        tmp___13 = _glp_mpl_slice_arity(mpl, slice);
        }
#line 609
        if (tmp___13 != 2) {
#line 609
          goto err1;
        }
        {
#line 610
        _glp_mpl_get_token(mpl);
        }
#line 611
        if (mpl->token != 245) {
#line 611
          goto err2;
        }
        {
#line 612
        _glp_mpl_get_token(mpl);
        }
#line 614
        if (mpl->token == 240) {
          {
#line 614
          _glp_mpl_get_token(mpl);
          }
        }
        {
#line 616
        tr = 1;
#line 618
        _glp_mpl_matrix_format(mpl, set___0, memb, slice, tr);
        }
      } else
#line 620
      if (mpl->token == 241) {
        {
#line 622
        _glp_mpl_get_token(mpl);
        }
#line 623
        goto while_break___0;
      } else {
        {
#line 626
        _glp_mpl_error(mpl, (char *)"syntax error in set data block");
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 629
  _glp_mpl_delete_slice(mpl, slice);
  }
#line 630
  return;
}
}
#line 639 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
PARAMETER *_glp_mpl_select_parameter(MPL *mpl , char *name ) 
{ 
  PARAMETER *par ;
  AVLNODE *node ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 645
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 645
    tmp = 1;
  } else {
    {
#line 645
    _glp_lib_xassert("name != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     645);
#line 645
    tmp = 1;
    }
  }
  {
#line 646
  node = _glp_avl_find_node(mpl->tree, (void const   *)name);
  }
#line 647
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 648
    _glp_mpl_error(mpl, (char *)"%s not a parameter", name);
    }
  } else {
    {
#line 647
    tmp___0 = _glp_avl_get_node_type(node);
    }
#line 647
    if (tmp___0 != 120) {
      {
#line 648
      _glp_mpl_error(mpl, (char *)"%s not a parameter", name);
      }
    }
  }
  {
#line 649
  tmp___1 = _glp_avl_get_node_link(node);
#line 649
  par = (PARAMETER *)tmp___1;
  }
#line 650
  if ((unsigned long )par->assign != (unsigned long )((void *)0)) {
    {
#line 651
    _glp_mpl_error(mpl, (char *)"%s needs no data", name);
    }
  }
#line 652
  if (par->data) {
    {
#line 653
    _glp_mpl_error(mpl, (char *)"%s already provided with data", name);
    }
  }
#line 654
  par->data = 1;
#line 655
  return (par);
}
}
#line 663 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_set_default(MPL *mpl , PARAMETER *par , SYMBOL *altval ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 668
  if ((unsigned long )par != (unsigned long )((void *)0)) {
#line 668
    tmp = 1;
  } else {
    {
#line 668
    _glp_lib_xassert("par != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     668);
#line 668
    tmp = 1;
    }
  }
#line 669
  if ((unsigned long )altval != (unsigned long )((void *)0)) {
#line 669
    tmp___0 = 1;
  } else {
    {
#line 669
    _glp_lib_xassert("altval != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     669);
#line 669
    tmp___0 = 1;
    }
  }
#line 670
  if ((unsigned long )par->option != (unsigned long )((void *)0)) {
    {
#line 671
    _glp_mpl_error(mpl, (char *)"default value for %s already specified in model section",
                   par->name);
    }
  }
#line 673
  if ((unsigned long )par->defval == (unsigned long )((void *)0)) {
#line 673
    tmp___1 = 1;
  } else {
    {
#line 673
    _glp_lib_xassert("par->defval == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     673);
#line 673
    tmp___1 = 1;
    }
  }
#line 674
  par->defval = altval;
#line 675
  return;
}
}
#line 685 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
MEMBER *_glp_mpl_read_value(MPL *mpl , PARAMETER *par , TUPLE *tuple ) 
{ 
  MEMBER *memb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  MEMBER *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 691
  if ((unsigned long )par != (unsigned long )((void *)0)) {
#line 691
    tmp = 1;
  } else {
    {
#line 691
    _glp_lib_xassert("par != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     691);
#line 691
    tmp = 1;
    }
  }
  {
#line 692
  tmp___0 = _glp_mpl_is_symbol(mpl);
  }
#line 692
  if (tmp___0) {
#line 692
    tmp___1 = 1;
  } else {
    {
#line 692
    _glp_lib_xassert("is_symbol(mpl)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     692);
#line 692
    tmp___1 = 1;
    }
  }
  {
#line 694
  tmp___3 = _glp_mpl_find_member(mpl, par->array, tuple);
  }
#line 694
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
    {
#line 695
    tmp___2 = _glp_mpl_format_tuple(mpl, '[', tuple);
#line 695
    _glp_mpl_error(mpl, (char *)"%s%s already defined", par->name, tmp___2);
    }
  }
  {
#line 698
  memb = _glp_mpl_add_member(mpl, par->array, tuple);
  }
  {
#line 703
  if (par->type == 101) {
#line 703
    goto case_101;
  }
#line 703
  if (par->type == 113) {
#line 703
    goto case_101;
  }
#line 703
  if (par->type == 118) {
#line 703
    goto case_101;
  }
#line 708
  if (par->type == 124) {
#line 708
    goto case_124;
  }
#line 711
  goto switch_default;
  case_101: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_118: /* CIL Label */ 
  {
#line 704
  tmp___4 = _glp_mpl_is_number(mpl);
  }
#line 704
  if (! tmp___4) {
    {
#line 705
    _glp_mpl_error(mpl, (char *)"%s requires numeric data", par->name);
    }
  }
  {
#line 706
  memb->value.num = _glp_mpl_read_number(mpl);
  }
#line 707
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 709
  memb->value.sym = _glp_mpl_read_symbol(mpl);
  }
#line 710
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 712
  if ((unsigned long )par != (unsigned long )par) {
#line 712
    tmp___5 = 1;
  } else {
    {
#line 712
    _glp_lib_xassert("par != par", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     712);
#line 712
    tmp___5 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 714
  return (memb);
}
}
#line 733 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_plain_format(MPL *mpl , PARAMETER *par , SLICE *slice ) 
{ 
  TUPLE *tuple ;
  SLICE *temp ;
  SYMBOL *sym ;
  SYMBOL *with ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int lack ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 740
  with = (SYMBOL *)((void *)0);
#line 741
  if ((unsigned long )par != (unsigned long )((void *)0)) {
#line 741
    tmp = 1;
  } else {
    {
#line 741
    _glp_lib_xassert("par != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     741);
#line 741
    tmp = 1;
    }
  }
  {
#line 742
  tmp___0 = _glp_mpl_slice_dimen(mpl, slice);
  }
#line 742
  if (par->dim == tmp___0) {
#line 742
    tmp___1 = 1;
  } else {
    {
#line 742
    _glp_lib_xassert("par->dim == slice_dimen(mpl, slice)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     742);
#line 742
    tmp___1 = 1;
    }
  }
  {
#line 743
  tmp___2 = _glp_mpl_is_symbol(mpl);
  }
#line 743
  if (tmp___2) {
#line 743
    tmp___3 = 1;
  } else {
    {
#line 743
    _glp_lib_xassert("is_symbol(mpl)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     743);
#line 743
    tmp___3 = 1;
    }
  }
  {
#line 745
  tuple = _glp_mpl_create_tuple(mpl);
#line 746
  temp = slice;
  }
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 746
      goto while_break;
    }
#line 747
    if ((unsigned long )temp->sym == (unsigned long )((void *)0)) {
      {
#line 749
      tmp___8 = _glp_mpl_is_symbol(mpl);
      }
#line 749
      if (! tmp___8) {
        {
#line 750
        tmp___4 = _glp_mpl_slice_arity(mpl, temp);
#line 750
        lack = tmp___4 + 1;
        }
#line 751
        if ((unsigned long )with != (unsigned long )((void *)0)) {
#line 751
          tmp___5 = 1;
        } else {
          {
#line 751
          _glp_lib_xassert("with != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                           751);
#line 751
          tmp___5 = 1;
          }
        }
#line 752
        if (lack > 1) {
#line 752
          tmp___6 = 1;
        } else {
          {
#line 752
          _glp_lib_xassert("lack > 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                           752);
#line 752
          tmp___6 = 1;
          }
        }
        {
#line 753
        tmp___7 = _glp_mpl_format_symbol(mpl, with);
#line 753
        _glp_mpl_error(mpl, (char *)"%d items missing in data group beginning with %s",
                       lack, tmp___7);
        }
      }
      {
#line 756
      sym = _glp_mpl_read_symbol(mpl);
      }
#line 757
      if ((unsigned long )with == (unsigned long )((void *)0)) {
#line 757
        with = sym;
      }
    } else {
      {
#line 761
      sym = _glp_mpl_copy_symbol(mpl, temp->sym);
      }
    }
    {
#line 764
    tuple = _glp_mpl_expand_tuple(mpl, tuple, sym);
    }
#line 766
    if (mpl->token == 239) {
      {
#line 766
      _glp_mpl_get_token(mpl);
      }
    }
#line 746
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 769
  tmp___11 = _glp_mpl_is_symbol(mpl);
  }
#line 769
  if (! tmp___11) {
#line 770
    if ((unsigned long )with != (unsigned long )((void *)0)) {
#line 770
      tmp___9 = 1;
    } else {
      {
#line 770
      _glp_lib_xassert("with != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                       770);
#line 770
      tmp___9 = 1;
      }
    }
    {
#line 771
    tmp___10 = _glp_mpl_format_symbol(mpl, with);
#line 771
    _glp_mpl_error(mpl, (char *)"one item missing in data group beginning with %s",
                   tmp___10);
    }
  }
  {
#line 774
  _glp_mpl_read_value(mpl, par, tuple);
  }
#line 775
  return;
}
}
#line 801 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_tabular_format(MPL *mpl , PARAMETER *par , SLICE *slice , int tr ) 
{ 
  SLICE *list ;
  SLICE *col ;
  SLICE *temp ;
  TUPLE *tuple ;
  SYMBOL *row ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  SYMBOL *tmp___5 ;
  int which ;
  int tmp___6 ;
  SYMBOL *tmp___7 ;
  SYMBOL *tmp___8 ;
  SYMBOL *tmp___9 ;
  SYMBOL *tmp___10 ;
  int tmp___11 ;
  SYMBOL *tmp___12 ;
  int tmp___13 ;
  int lack ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 810
  if ((unsigned long )par != (unsigned long )((void *)0)) {
#line 810
    tmp = 1;
  } else {
    {
#line 810
    _glp_lib_xassert("par != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     810);
#line 810
    tmp = 1;
    }
  }
  {
#line 811
  tmp___0 = _glp_mpl_slice_dimen(mpl, slice);
  }
#line 811
  if (par->dim == tmp___0) {
#line 811
    tmp___1 = 1;
  } else {
    {
#line 811
    _glp_lib_xassert("par->dim == slice_dimen(mpl, slice)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     811);
#line 811
    tmp___1 = 1;
    }
  }
  {
#line 812
  tmp___2 = _glp_mpl_slice_arity(mpl, slice);
  }
#line 812
  if (tmp___2 == 2) {
#line 812
    tmp___3 = 1;
  } else {
    {
#line 812
    _glp_lib_xassert("slice_arity(mpl, slice) == 2", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     812);
#line 812
    tmp___3 = 1;
    }
  }
  {
#line 815
  list = _glp_mpl_create_slice(mpl);
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! (mpl->token != 242)) {
#line 816
      goto while_break;
    }
    {
#line 818
    tmp___4 = _glp_mpl_is_symbol(mpl);
    }
#line 818
    if (! tmp___4) {
      {
#line 819
      _glp_mpl_error(mpl, (char *)"number, symbol, or := missing where expected");
      }
    }
    {
#line 820
    tmp___5 = _glp_mpl_read_symbol(mpl);
#line 820
    list = _glp_mpl_expand_slice(mpl, list, tmp___5);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 822
  _glp_mpl_get_token(mpl);
  }
  {
#line 824
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 824
    tmp___18 = _glp_mpl_is_symbol(mpl);
    }
#line 824
    if (! tmp___18) {
#line 824
      goto while_break___0;
    }
    {
#line 827
    row = _glp_mpl_read_symbol(mpl);
#line 829
    col = list;
    }
    {
#line 829
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 829
      if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 829
        goto while_break___1;
      }
      {
#line 830
      which = 0;
#line 832
      tmp___6 = _glp_mpl_is_literal(mpl, (char *)".");
      }
#line 832
      if (tmp___6) {
        {
#line 833
        _glp_mpl_get_token(mpl);
        }
#line 834
        goto __Cont;
      }
      {
#line 837
      tuple = _glp_mpl_create_tuple(mpl);
#line 838
      temp = slice;
      }
      {
#line 838
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 838
        if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 838
          goto while_break___2;
        }
#line 839
        if ((unsigned long )temp->sym == (unsigned long )((void *)0)) {
#line 841
          which ++;
          {
#line 842
          if (which == 1) {
#line 842
            goto case_1;
          }
#line 847
          if (which == 2) {
#line 847
            goto case_2;
          }
#line 852
          goto switch_default;
          case_1: /* CIL Label */ 
#line 844
          if (tr) {
#line 844
            tmp___7 = col->sym;
          } else {
#line 844
            tmp___7 = row;
          }
          {
#line 844
          tmp___8 = _glp_mpl_copy_symbol(mpl, tmp___7);
#line 844
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___8);
          }
#line 846
          goto switch_break;
          case_2: /* CIL Label */ 
#line 849
          if (tr) {
#line 849
            tmp___9 = row;
          } else {
#line 849
            tmp___9 = col->sym;
          }
          {
#line 849
          tmp___10 = _glp_mpl_copy_symbol(mpl, tmp___9);
#line 849
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___10);
          }
#line 851
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 853
          if (which != which) {
#line 853
            tmp___11 = 1;
          } else {
            {
#line 853
            _glp_lib_xassert("which != which", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                             853);
#line 853
            tmp___11 = 1;
            }
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 858
          tmp___12 = _glp_mpl_copy_symbol(mpl, temp->sym);
#line 858
          tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___12);
          }
        }
#line 838
        temp = temp->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 862
      if (which == 2) {
#line 862
        tmp___13 = 1;
      } else {
        {
#line 862
        _glp_lib_xassert("which == 2", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                         862);
#line 862
        tmp___13 = 1;
        }
      }
      {
#line 864
      tmp___17 = _glp_mpl_is_symbol(mpl);
      }
#line 864
      if (! tmp___17) {
        {
#line 865
        tmp___14 = _glp_mpl_slice_dimen(mpl, col);
#line 865
        lack = tmp___14;
        }
#line 866
        if (lack == 1) {
          {
#line 867
          tmp___15 = _glp_mpl_format_symbol(mpl, row);
#line 867
          _glp_mpl_error(mpl, (char *)"one item missing in data group beginning with %s",
                         tmp___15);
          }
        } else {
          {
#line 870
          tmp___16 = _glp_mpl_format_symbol(mpl, row);
#line 870
          _glp_mpl_error(mpl, (char *)"%d items missing in data group beginning with %s",
                         lack, tmp___16);
          }
        }
      }
      {
#line 873
      _glp_mpl_read_value(mpl, par, tuple);
      }
      __Cont: /* CIL Label */ 
#line 829
      col = col->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 876
    _glp_mpl_delete_symbol(mpl, row);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 879
  _glp_mpl_delete_slice(mpl, list);
  }
#line 880
  return;
}
}
#line 908 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_tabbing_format(MPL *mpl , SYMBOL *altval ) 
{ 
  SET *set___0 ;
  PARAMETER *par ;
  SLICE *list ;
  SLICE *col ;
  TUPLE *tuple ;
  int next_token ;
  int j ;
  int dim ;
  char *last_name ;
  MEMBER *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  SYMBOL *tmp___4 ;
  int tmp___5 ;
  int lack ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  SYMBOL *tmp___11 ;
  TUPLE *tmp___12 ;
  int tmp___13 ;
  int lack___0 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  TUPLE *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 912
  set___0 = (SET *)((void *)0);
#line 916
  dim = 0;
#line 917
  last_name = (char *)((void *)0);
#line 919
  tmp___1 = _glp_mpl_is_symbol(mpl);
  }
#line 919
  if (tmp___1) {
    {
#line 920
    _glp_mpl_get_token(mpl);
#line 921
    next_token = mpl->token;
#line 922
    _glp_mpl_unget_token(mpl);
    }
#line 923
    if (next_token == 240) {
      {
#line 925
      set___0 = _glp_mpl_select_set(mpl, mpl->image);
      }
#line 927
      if (set___0->dim != 0) {
        {
#line 928
        _glp_mpl_error(mpl, (char *)"%s must be a simple set", set___0->name);
        }
      }
#line 930
      if ((unsigned long )(set___0->array)->head != (unsigned long )((void *)0)) {
        {
#line 931
        _glp_mpl_error(mpl, (char *)"%s already defined", set___0->name);
        }
      }
      {
#line 934
      tmp = _glp_mpl_add_member(mpl, set___0->array, (TUPLE *)((void *)0));
#line 934
      tmp->value.set = _glp_mpl_create_elemset(mpl, set___0->dimen);
#line 936
      last_name = set___0->name;
#line 936
      dim = set___0->dimen;
#line 937
      _glp_mpl_get_token(mpl);
      }
#line 938
      if (mpl->token == 240) {
#line 938
        tmp___0 = 1;
      } else {
        {
#line 938
        _glp_lib_xassert("mpl->token == T_COLON", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                         938);
#line 938
        tmp___0 = 1;
        }
      }
      {
#line 939
      _glp_mpl_get_token(mpl);
      }
    }
  }
  {
#line 943
  list = _glp_mpl_create_slice(mpl);
  }
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (mpl->token != 242)) {
#line 944
      goto while_break;
    }
    {
#line 946
    tmp___2 = _glp_mpl_is_symbol(mpl);
    }
#line 946
    if (! tmp___2) {
      {
#line 947
      _glp_mpl_error(mpl, (char *)"parameter name or := missing where expected");
      }
    }
    {
#line 949
    par = _glp_mpl_select_parameter(mpl, mpl->image);
    }
#line 951
    if (par->dim == 0) {
      {
#line 952
      _glp_mpl_error(mpl, (char *)"%s not a subscripted parameter", mpl->image);
      }
    }
#line 955
    if (dim != 0) {
#line 955
      if (par->dim != dim) {
#line 956
        if ((unsigned long )last_name != (unsigned long )((void *)0)) {
#line 956
          tmp___3 = 1;
        } else {
          {
#line 956
          _glp_lib_xassert("last_name != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                           956);
#line 956
          tmp___3 = 1;
          }
        }
        {
#line 957
        _glp_mpl_error(mpl, (char *)"%s has dimension %d while %s has dimension %d",
                       last_name, dim, par->name, par->dim);
        }
      }
    }
#line 961
    if ((unsigned long )altval != (unsigned long )((void *)0)) {
      {
#line 962
      tmp___4 = _glp_mpl_copy_symbol(mpl, altval);
#line 962
      _glp_mpl_set_default(mpl, par, tmp___4);
      }
    }
    {
#line 964
    list = _glp_mpl_expand_slice(mpl, list, (SYMBOL *)par);
#line 965
    last_name = par->name;
#line 965
    dim = par->dim;
#line 966
    _glp_mpl_get_token(mpl);
    }
#line 968
    if (mpl->token == 239) {
      {
#line 968
      _glp_mpl_get_token(mpl);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 970
  tmp___5 = _glp_mpl_slice_dimen(mpl, list);
  }
#line 970
  if (tmp___5 == 0) {
    {
#line 971
    _glp_mpl_error(mpl, (char *)"at least one parameter name required");
    }
  }
  {
#line 972
  _glp_mpl_get_token(mpl);
  }
#line 974
  if (mpl->token == 239) {
    {
#line 974
    _glp_mpl_get_token(mpl);
    }
  }
  {
#line 976
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 976
    tmp___21 = _glp_mpl_is_symbol(mpl);
    }
#line 976
    if (! tmp___21) {
#line 976
      goto while_break___0;
    }
    {
#line 978
    tuple = _glp_mpl_create_tuple(mpl);
#line 979
    j = 1;
    }
    {
#line 979
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 979
      if (! (j <= dim)) {
#line 979
        goto while_break___1;
      }
      {
#line 981
      tmp___10 = _glp_mpl_is_symbol(mpl);
      }
#line 981
      if (! tmp___10) {
        {
#line 982
        tmp___6 = _glp_mpl_slice_dimen(mpl, list);
#line 982
        lack = ((tmp___6 + dim) - j) + 1;
        }
#line 983
        if ((unsigned long )tuple != (unsigned long )((void *)0)) {
#line 983
          tmp___7 = 1;
        } else {
          {
#line 983
          _glp_lib_xassert("tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                           983);
#line 983
          tmp___7 = 1;
          }
        }
#line 984
        if (lack > 1) {
#line 984
          tmp___8 = 1;
        } else {
          {
#line 984
          _glp_lib_xassert("lack > 1", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                           984);
#line 984
          tmp___8 = 1;
          }
        }
        {
#line 985
        tmp___9 = _glp_mpl_format_symbol(mpl, tuple->sym);
#line 985
        _glp_mpl_error(mpl, (char *)"%d items missing in data group beginning with %s",
                       lack, tmp___9);
        }
      }
      {
#line 989
      tmp___11 = _glp_mpl_read_symbol(mpl);
#line 989
      tuple = _glp_mpl_expand_tuple(mpl, tuple, tmp___11);
      }
#line 991
      if (j < dim) {
#line 991
        if (mpl->token == 239) {
          {
#line 992
          _glp_mpl_get_token(mpl);
          }
        }
      }
#line 979
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 996
    if ((unsigned long )set___0 != (unsigned long )((void *)0)) {
      {
#line 997
      tmp___12 = _glp_mpl_copy_tuple(mpl, tuple);
#line 997
      _glp_mpl_check_then_add(mpl, ((set___0->array)->head)->value.set, tmp___12);
      }
    }
#line 1000
    if (mpl->token == 239) {
      {
#line 1000
      _glp_mpl_get_token(mpl);
      }
    }
#line 1002
    col = list;
    {
#line 1002
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1002
      if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 1002
        goto while_break___2;
      }
      {
#line 1004
      tmp___13 = _glp_mpl_is_literal(mpl, (char *)".");
      }
#line 1004
      if (tmp___13) {
        {
#line 1005
        _glp_mpl_get_token(mpl);
        }
#line 1006
        goto __Cont;
      }
      {
#line 1009
      tmp___18 = _glp_mpl_is_symbol(mpl);
      }
#line 1009
      if (! tmp___18) {
        {
#line 1010
        tmp___14 = _glp_mpl_slice_dimen(mpl, col);
#line 1010
        lack___0 = tmp___14;
        }
#line 1011
        if ((unsigned long )tuple != (unsigned long )((void *)0)) {
#line 1011
          tmp___15 = 1;
        } else {
          {
#line 1011
          _glp_lib_xassert("tuple != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                           1011);
#line 1011
          tmp___15 = 1;
          }
        }
#line 1012
        if (lack___0 == 1) {
          {
#line 1013
          tmp___16 = _glp_mpl_format_symbol(mpl, tuple->sym);
#line 1013
          _glp_mpl_error(mpl, (char *)"one item missing in data group beginning with %s",
                         tmp___16);
          }
        } else {
          {
#line 1016
          tmp___17 = _glp_mpl_format_symbol(mpl, tuple->sym);
#line 1016
          _glp_mpl_error(mpl, (char *)"%d items missing in data group beginning with %s",
                         lack___0, tmp___17);
          }
        }
      }
      {
#line 1019
      tmp___19 = _glp_mpl_copy_tuple(mpl, tuple);
#line 1019
      _glp_mpl_read_value(mpl, (PARAMETER *)col->sym, tmp___19);
      }
#line 1022
      if ((unsigned long )col->next != (unsigned long )((void *)0)) {
#line 1022
        if (mpl->token == 239) {
          {
#line 1023
          _glp_mpl_get_token(mpl);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1002
      col = col->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1026
    _glp_mpl_delete_tuple(mpl, tuple);
    }
#line 1028
    if (mpl->token == 239) {
      {
#line 1029
      _glp_mpl_get_token(mpl);
#line 1030
      tmp___20 = _glp_mpl_is_symbol(mpl);
      }
#line 1030
      if (! tmp___20) {
        {
#line 1030
        _glp_mpl_unget_token(mpl);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1035
  col = list;
  {
#line 1035
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1035
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 1035
      goto while_break___3;
    }
#line 1035
    col->sym = (SYMBOL *)((void *)0);
#line 1035
    col = col->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1036
  _glp_mpl_delete_slice(mpl, list);
  }
#line 1037
  return;
}
}
#line 1061 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_parameter_data(MPL *mpl ) 
{ 
  PARAMETER *par ;
  SYMBOL *altval ;
  SLICE *slice ;
  int tr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 1063
  altval = (SYMBOL *)((void *)0);
#line 1065
  tr = 0;
#line 1066
  tmp = _glp_mpl_is_literal(mpl, (char *)"param");
  }
#line 1066
  if (tmp) {
#line 1066
    tmp___0 = 1;
  } else {
    {
#line 1066
    _glp_lib_xassert("is_literal(mpl, \"param\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c",
                     1066);
#line 1066
    tmp___0 = 1;
    }
  }
  {
#line 1067
  _glp_mpl_get_token(mpl);
#line 1069
  tmp___2 = _glp_mpl_is_literal(mpl, (char *)"default");
  }
#line 1069
  if (tmp___2) {
    {
#line 1070
    _glp_mpl_get_token(mpl);
#line 1071
    tmp___1 = _glp_mpl_is_symbol(mpl);
    }
#line 1071
    if (! tmp___1) {
      {
#line 1072
      _glp_mpl_error(mpl, (char *)"default value missing where expected");
      }
    }
    {
#line 1073
    altval = _glp_mpl_read_symbol(mpl);
    }
#line 1076
    if (mpl->token != 240) {
      {
#line 1077
      _glp_mpl_error(mpl, (char *)"colon missing where expected");
      }
    }
  }
#line 1081
  if (mpl->token == 240) {
    {
#line 1082
    _glp_mpl_get_token(mpl);
    }
#line 1084
    if (mpl->token == 239) {
      {
#line 1084
      _glp_mpl_get_token(mpl);
      }
    }
    {
#line 1086
    _glp_mpl_tabbing_format(mpl, altval);
    }
#line 1089
    if ((unsigned long )altval != (unsigned long )((void *)0)) {
      {
#line 1089
      _glp_mpl_delete_symbol(mpl, altval);
      }
    }
#line 1091
    if (mpl->token != 241) {
      {
#line 1092
      _glp_mpl_error(mpl, (char *)"symbol, number, or semicolon missing where expected");
      }
    }
    {
#line 1094
    _glp_mpl_get_token(mpl);
    }
#line 1095
    goto done;
  }
  {
#line 1099
  tmp___3 = _glp_mpl_is_symbol(mpl);
  }
#line 1099
  if (! tmp___3) {
    {
#line 1100
    _glp_mpl_error(mpl, (char *)"parameter name missing where expected");
    }
  }
  {
#line 1102
  par = _glp_mpl_select_parameter(mpl, mpl->image);
#line 1103
  _glp_mpl_get_token(mpl);
#line 1105
  tmp___5 = _glp_mpl_is_literal(mpl, (char *)"default");
  }
#line 1105
  if (tmp___5) {
    {
#line 1106
    _glp_mpl_get_token(mpl);
#line 1107
    tmp___4 = _glp_mpl_is_symbol(mpl);
    }
#line 1107
    if (! tmp___4) {
      {
#line 1108
      _glp_mpl_error(mpl, (char *)"default value missing where expected");
      }
    }
    {
#line 1109
    altval = _glp_mpl_read_symbol(mpl);
#line 1111
    _glp_mpl_set_default(mpl, par, altval);
    }
  }
  {
#line 1114
  slice = _glp_mpl_fake_slice(mpl, par->dim);
  }
  {
#line 1116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1118
    if (mpl->token == 239) {
      {
#line 1118
      _glp_mpl_get_token(mpl);
      }
    }
#line 1120
    if (mpl->token == 242) {
      {
#line 1122
      _glp_mpl_get_token(mpl);
      }
    } else
#line 1124
    if (mpl->token == 246) {
      {
#line 1127
      _glp_mpl_delete_slice(mpl, slice);
#line 1128
      slice = _glp_mpl_read_slice(mpl, par->name, par->dim);
#line 1130
      tr = 0;
      }
    } else {
      {
#line 1132
      tmp___10 = _glp_mpl_is_symbol(mpl);
      }
#line 1132
      if (tmp___10) {
        {
#line 1134
        _glp_mpl_plain_format(mpl, par, slice);
        }
      } else
#line 1136
      if (mpl->token == 240) {
#line 1138
        if (par->dim == 0) {
          err1: 
          {
#line 1139
          _glp_mpl_error(mpl, (char *)"%s not a subscripted parameter", par->name);
          }
        }
        {
#line 1141
        tmp___7 = _glp_mpl_slice_arity(mpl, slice);
        }
#line 1141
        if (tmp___7 != 2) {
          err2: 
          {
#line 1142
          tmp___6 = _glp_mpl_slice_arity(mpl, slice);
#line 1142
          _glp_mpl_error(mpl, (char *)"slice currently used must specify 2 asterisks, not %d",
                         tmp___6);
          }
        }
        {
#line 1144
        _glp_mpl_get_token(mpl);
#line 1146
        _glp_mpl_tabular_format(mpl, par, slice, tr);
        }
      } else
#line 1148
      if (mpl->token == 244) {
        {
#line 1151
        _glp_mpl_get_token(mpl);
#line 1152
        tmp___8 = _glp_mpl_is_literal(mpl, (char *)"tr");
        }
#line 1152
        if (! tmp___8) {
          err3: 
          {
#line 1153
          _glp_mpl_error(mpl, (char *)"transpose indicator (tr) incomplete");
          }
        }
#line 1154
        if (par->dim == 0) {
#line 1154
          goto err1;
        }
        {
#line 1155
        tmp___9 = _glp_mpl_slice_arity(mpl, slice);
        }
#line 1155
        if (tmp___9 != 2) {
#line 1155
          goto err2;
        }
        {
#line 1156
        _glp_mpl_get_token(mpl);
        }
#line 1157
        if (mpl->token != 245) {
#line 1157
          goto err3;
        }
        {
#line 1158
        _glp_mpl_get_token(mpl);
        }
#line 1160
        if (mpl->token == 240) {
          {
#line 1160
          _glp_mpl_get_token(mpl);
          }
        }
        {
#line 1162
        tr = 1;
#line 1164
        _glp_mpl_tabular_format(mpl, par, slice, tr);
        }
      } else
#line 1166
      if (mpl->token == 241) {
        {
#line 1168
        _glp_mpl_get_token(mpl);
        }
#line 1169
        goto while_break;
      } else {
        {
#line 1172
        _glp_mpl_error(mpl, (char *)"syntax error in parameter data block");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1175
  _glp_mpl_delete_slice(mpl, slice);
  }
  done: 
#line 1176
  return;
}
}
#line 1192 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl02.c"
void _glp_mpl_data_section(MPL *mpl ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1193
    if (mpl->token == 201) {
#line 1193
      goto while_break;
    } else {
      {
#line 1193
      tmp___1 = _glp_mpl_is_literal(mpl, (char *)"end");
      }
#line 1193
      if (tmp___1) {
#line 1193
        goto while_break;
      }
    }
    {
#line 1194
    tmp___0 = _glp_mpl_is_literal(mpl, (char *)"set");
    }
#line 1194
    if (tmp___0) {
      {
#line 1195
      _glp_mpl_set_data(mpl);
      }
    } else {
      {
#line 1196
      tmp = _glp_mpl_is_literal(mpl, (char *)"param");
      }
#line 1196
      if (tmp) {
        {
#line 1197
        _glp_mpl_parameter_data(mpl);
        }
      } else {
        {
#line 1199
        _glp_mpl_error(mpl, (char *)"syntax error in data section");
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1201
  return;
}
}
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 93 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.h"
void _glp_avl_set_node_type(AVLNODE *node , int type ) ;
#line 113
void _glp_avl_delete_node(AVL *tree , AVLNODE *node ) ;
#line 331 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl.h"
void _glp_mpl_enter_context(MPL *mpl ) ;
#line 343
void _glp_mpl_append_char(MPL *mpl ) ;
#line 359
int _glp_mpl_is_reserved(MPL *mpl ) ;
#line 363
CODE *_glp_mpl_make_code(MPL *mpl , int op , OPERANDS *arg , int type , int dim ) ;
#line 367
CODE *_glp_mpl_make_unary(MPL *mpl , int op , CODE *x , int type , int dim ) ;
#line 371
CODE *_glp_mpl_make_binary(MPL *mpl , int op , CODE *x , CODE *y , int type , int dim ) ;
#line 376
CODE *_glp_mpl_make_ternary(MPL *mpl , int op , CODE *x , CODE *y , CODE *z , int type ,
                            int dim ) ;
#line 381
CODE *_glp_mpl_numeric_literal(MPL *mpl ) ;
#line 385
CODE *_glp_mpl_string_literal(MPL *mpl ) ;
#line 389
ARG_LIST *_glp_mpl_create_arg_list(MPL *mpl ) ;
#line 393
ARG_LIST *_glp_mpl_expand_arg_list(MPL *mpl , ARG_LIST *list , CODE *x ) ;
#line 397
int _glp_mpl_arg_list_len(MPL *mpl , ARG_LIST *list ) ;
#line 401
ARG_LIST *_glp_mpl_subscript_list(MPL *mpl ) ;
#line 405
CODE *_glp_mpl_object_reference(MPL *mpl ) ;
#line 409
CODE *_glp_mpl_numeric_argument(MPL *mpl , char *func___0 ) ;
#line 413
CODE *_glp_mpl_symbolic_argument(MPL *mpl , char *func___0 ) ;
#line 416
CODE *_glp_mpl_elemset_argument(MPL *mpl , char *func___0 ) ;
#line 419
CODE *_glp_mpl_function_reference(MPL *mpl ) ;
#line 423
DOMAIN1 *_glp_mpl_create_domain(MPL *mpl ) ;
#line 427
DOMAIN_BLOCK *_glp_mpl_create_block(MPL *mpl ) ;
#line 431
void _glp_mpl_append_block(MPL *mpl , DOMAIN1 *domain , DOMAIN_BLOCK *block ) ;
#line 435
DOMAIN_SLOT *_glp_mpl_append_slot(MPL *mpl , DOMAIN_BLOCK *block , char *name , CODE *code ) ;
#line 440
CODE *_glp_mpl_expression_list(MPL *mpl ) ;
#line 444
CODE *_glp_mpl_literal_set(MPL *mpl , CODE *code ) ;
#line 448
DOMAIN1 *_glp_mpl_indexing_expression(MPL *mpl ) ;
#line 452
void _glp_mpl_close_scope(MPL *mpl , DOMAIN1 *domain ) ;
#line 456
CODE *_glp_mpl_iterated_expression(MPL *mpl ) ;
#line 460
int _glp_mpl_domain_arity(MPL *mpl , DOMAIN1 *domain ) ;
#line 464
CODE *_glp_mpl_set_expression(MPL *mpl ) ;
#line 468
CODE *_glp_mpl_branched_expression(MPL *mpl ) ;
#line 472
CODE *_glp_mpl_primary_expression(MPL *mpl ) ;
#line 476
void _glp_mpl_error_preceding(MPL *mpl , char *opstr ) ;
#line 480
void _glp_mpl_error_following(MPL *mpl , char *opstr ) ;
#line 484
void _glp_mpl_error_dimension(MPL *mpl , char *opstr , int dim1 , int dim2 ) ;
#line 488
CODE *_glp_mpl_expression_0(MPL *mpl ) ;
#line 492
CODE *_glp_mpl_expression_1(MPL *mpl ) ;
#line 496
CODE *_glp_mpl_expression_2(MPL *mpl ) ;
#line 500
CODE *_glp_mpl_expression_3(MPL *mpl ) ;
#line 504
CODE *_glp_mpl_expression_4(MPL *mpl ) ;
#line 508
CODE *_glp_mpl_expression_5(MPL *mpl ) ;
#line 512
CODE *_glp_mpl_expression_6(MPL *mpl ) ;
#line 516
CODE *_glp_mpl_expression_7(MPL *mpl ) ;
#line 520
CODE *_glp_mpl_expression_8(MPL *mpl ) ;
#line 524
CODE *_glp_mpl_expression_9(MPL *mpl ) ;
#line 528
CODE *_glp_mpl_expression_10(MPL *mpl ) ;
#line 532
CODE *_glp_mpl_expression_11(MPL *mpl ) ;
#line 536
CODE *_glp_mpl_expression_12(MPL *mpl ) ;
#line 540
CODE *_glp_mpl_expression_13(MPL *mpl ) ;
#line 544
SET *_glp_mpl_set_statement(MPL *mpl ) ;
#line 548
PARAMETER *_glp_mpl_parameter_statement(MPL *mpl ) ;
#line 552
VARIABLE *_glp_mpl_variable_statement(MPL *mpl ) ;
#line 556
CONSTRAINT *_glp_mpl_constraint_statement(MPL *mpl ) ;
#line 560
CONSTRAINT *_glp_mpl_objective_statement(MPL *mpl ) ;
#line 564
TABLE *_glp_mpl_table_statement(MPL *mpl ) ;
#line 568
void *_glp_mpl_solve_statement(MPL *mpl ) ;
#line 572
CHECK *_glp_mpl_check_statement(MPL *mpl ) ;
#line 576
DISPLAY *_glp_mpl_display_statement(MPL *mpl ) ;
#line 580
PRINTF *_glp_mpl_printf_statement(MPL *mpl ) ;
#line 584
FOR *_glp_mpl_for_statement(MPL *mpl ) ;
#line 592
STATEMENT *_glp_mpl_simple_statement(MPL *mpl , int spec ) ;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_enter_context(MPL *mpl ) 
{ 
  char *image ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 39
  if (mpl->token == 201) {
#line 40
    image = (char *)"_|_";
  } else
#line 41
  if (mpl->token == 205) {
#line 42
    image = (char *)"\'...\'";
  } else {
#line 44
    image = mpl->image;
  }
#line 45
  if (0 <= mpl->c_ptr) {
#line 45
    if (mpl->c_ptr < 60) {
#line 45
      tmp = 1;
    } else {
      {
#line 45
      _glp_lib_xassert("0 <= mpl->c_ptr && mpl->c_ptr < CONTEXT_SIZE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       45);
#line 45
      tmp = 1;
      }
    }
  } else {
    {
#line 45
    _glp_lib_xassert("0 <= mpl->c_ptr && mpl->c_ptr < CONTEXT_SIZE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     45);
#line 45
    tmp = 1;
    }
  }
#line 46
  tmp___0 = mpl->c_ptr;
#line 46
  (mpl->c_ptr) ++;
#line 46
  *(mpl->context + tmp___0) = (char )' ';
#line 47
  if (mpl->c_ptr == 60) {
#line 47
    mpl->c_ptr = 0;
  }
#line 48
  s = image;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! ((int )*s != 0)) {
#line 48
      goto while_break;
    }
#line 49
    tmp___1 = mpl->c_ptr;
#line 49
    (mpl->c_ptr) ++;
#line 49
    *(mpl->context + tmp___1) = *s;
#line 50
    if (mpl->c_ptr == 60) {
#line 50
      mpl->c_ptr = 0;
    }
#line 48
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 60 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_print_context(MPL *mpl ) 
{ 
  int c ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (mpl->c_ptr > 0)) {
#line 62
      goto while_break;
    }
    {
#line 63
    (mpl->c_ptr) --;
#line 64
    c = (int )*(mpl->context + 0);
#line 65
    memmove((void *)mpl->context, (void const   *)(mpl->context + 1), (size_t )59);
#line 66
    *(mpl->context + 59) = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if ((int )*(mpl->context + 0) == 32) {
#line 68
    tmp = "";
  } else {
#line 68
    tmp = "...";
  }
  {
#line 68
  _glp_lib_xprintf("Context: %s%.*s\n", tmp, 60, mpl->context);
  }
#line 70
  return;
}
}
#line 79 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_get_char(MPL *mpl ) 
{ 
  int c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 81
  if (mpl->c == -1) {
#line 81
    goto done;
  }
#line 82
  if (mpl->c == 10) {
#line 82
    (mpl->line) ++;
  }
  {
#line 83
  c = _glp_mpl_read_char(mpl);
  }
#line 84
  if (c == -1) {
#line 85
    if (mpl->c == 10) {
#line 86
      (mpl->line) --;
    } else {
      {
#line 88
      _glp_mpl_warning(mpl, (char *)"final NL missing before end of file");
      }
    }
  } else
#line 90
  if (! (c == 10)) {
    {
#line 92
    tmp___0 = __ctype_b_loc();
    }
#line 92
    if ((int const   )*(*tmp___0 + c) & 8192) {
#line 93
      c = ' ';
    } else {
      {
#line 94
      tmp = __ctype_b_loc();
      }
#line 94
      if ((int const   )*(*tmp + c) & 2) {
        {
#line 95
        _glp_mpl_enter_context(mpl);
#line 96
        _glp_mpl_error(mpl, (char *)"control character 0x%02X not allowed", c);
        }
      }
    }
  }
#line 98
  mpl->c = c;
  done: 
#line 99
  return;
}
}
#line 108 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_append_char(MPL *mpl ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 109
  if (0 <= mpl->imlen) {
#line 109
    if (mpl->imlen <= 100) {
#line 109
      tmp = 1;
    } else {
      {
#line 109
      _glp_lib_xassert("0 <= mpl->imlen && mpl->imlen <= MAX_LENGTH", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       109);
#line 109
      tmp = 1;
      }
    }
  } else {
    {
#line 109
    _glp_lib_xassert("0 <= mpl->imlen && mpl->imlen <= MAX_LENGTH", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     109);
#line 109
    tmp = 1;
    }
  }
#line 110
  if (mpl->imlen == 100) {
    {
#line 112
    if (mpl->token == 202) {
#line 112
      goto case_202;
    }
#line 115
    if (mpl->token == 203) {
#line 115
      goto case_203;
    }
#line 118
    if (mpl->token == 204) {
#line 118
      goto case_204;
    }
#line 121
    if (mpl->token == 205) {
#line 121
      goto case_205;
    }
#line 124
    goto switch_default;
    case_202: /* CIL Label */ 
    {
#line 113
    _glp_mpl_enter_context(mpl);
#line 114
    _glp_mpl_error(mpl, (char *)"symbolic name %s... too long", mpl->image);
    }
    case_203: /* CIL Label */ 
    {
#line 116
    _glp_mpl_enter_context(mpl);
#line 117
    _glp_mpl_error(mpl, (char *)"symbol %s... too long", mpl->image);
    }
    case_204: /* CIL Label */ 
    {
#line 119
    _glp_mpl_enter_context(mpl);
#line 120
    _glp_mpl_error(mpl, (char *)"numeric literal %s... too long", mpl->image);
    }
    case_205: /* CIL Label */ 
    {
#line 122
    _glp_mpl_enter_context(mpl);
#line 123
    _glp_mpl_error(mpl, (char *)"string literal too long");
    }
    switch_default: /* CIL Label */ 
#line 125
    if ((unsigned long )mpl != (unsigned long )mpl) {
#line 125
      tmp___0 = 1;
    } else {
      {
#line 125
      _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       125);
#line 125
      tmp___0 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 128
  tmp___1 = mpl->imlen;
#line 128
  (mpl->imlen) ++;
#line 128
  *(mpl->image + tmp___1) = (char )mpl->c;
#line 129
  *(mpl->image + mpl->imlen) = (char )'\000';
#line 130
  _glp_mpl_get_char(mpl);
  }
#line 131
  return;
}
}
#line 140 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_get_token(MPL *mpl ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  unsigned short const   **tmp___22 ;
  unsigned short const   **tmp___23 ;
  int tmp___24 ;
  int quote ;
  unsigned short const   **tmp___25 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  unsigned short const   **tmp___31 ;
  char *tmp___32 ;
  unsigned short const   **tmp___33 ;
  unsigned short const   **tmp___34 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
#line 142
  mpl->b_token = mpl->token;
#line 143
  mpl->b_imlen = mpl->imlen;
#line 144
  strcpy((char */* __restrict  */)mpl->b_image, (char const   */* __restrict  */)mpl->image);
#line 145
  mpl->b_value = mpl->value;
  }
#line 147
  if (mpl->f_scan) {
    {
#line 148
    mpl->f_scan = 0;
#line 149
    mpl->token = mpl->f_token;
#line 150
    mpl->imlen = mpl->f_imlen;
#line 151
    strcpy((char */* __restrict  */)mpl->image, (char const   */* __restrict  */)mpl->f_image);
#line 152
    mpl->value = mpl->f_value;
    }
#line 153
    goto done;
  }
  loop: 
#line 156
  mpl->token = 0;
#line 157
  mpl->imlen = 0;
#line 158
  *(mpl->image + 0) = (char )'\000';
#line 159
  mpl->value = 0.0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (mpl->c == 32)) {
#line 161
      if (! (mpl->c == 10)) {
#line 161
        goto while_break;
      }
    }
    {
#line 161
    _glp_mpl_get_char(mpl);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if (mpl->c == -1) {
#line 165
    mpl->token = 201;
  } else
#line 167
  if (mpl->c == 35) {
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (mpl->c != 10) {
#line 169
        if (! (mpl->c != -1)) {
#line 169
          goto while_break___0;
        }
      } else {
#line 169
        goto while_break___0;
      }
      {
#line 169
      _glp_mpl_get_char(mpl);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 170
    goto loop;
  } else
#line 172
  if (! mpl->flag_d) {
    {
#line 172
    tmp___34 = __ctype_b_loc();
    }
#line 172
    if ((int const   )*(*tmp___34 + mpl->c) & 1024) {
#line 172
      goto _L___8;
    } else
#line 172
    if (mpl->c == 95) {
      _L___8: /* CIL Label */ 
#line 174
      mpl->token = 202;
      {
#line 175
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 175
        tmp = __ctype_b_loc();
        }
#line 175
        if (! ((int const   )*(*tmp + mpl->c) & 8)) {
#line 175
          if (! (mpl->c == 95)) {
#line 175
            goto while_break___1;
          }
        }
        {
#line 175
        _glp_mpl_append_char(mpl);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 176
      tmp___18 = strcmp((char const   *)mpl->image, "and");
      }
#line 176
      if (tmp___18 == 0) {
#line 177
        mpl->token = 206;
      } else {
        {
#line 178
        tmp___17 = strcmp((char const   *)mpl->image, "by");
        }
#line 178
        if (tmp___17 == 0) {
#line 179
          mpl->token = 207;
        } else {
          {
#line 180
          tmp___16 = strcmp((char const   *)mpl->image, "cross");
          }
#line 180
          if (tmp___16 == 0) {
#line 181
            mpl->token = 208;
          } else {
            {
#line 182
            tmp___15 = strcmp((char const   *)mpl->image, "diff");
            }
#line 182
            if (tmp___15 == 0) {
#line 183
              mpl->token = 209;
            } else {
              {
#line 184
              tmp___14 = strcmp((char const   *)mpl->image, "div");
              }
#line 184
              if (tmp___14 == 0) {
#line 185
                mpl->token = 210;
              } else {
                {
#line 186
                tmp___13 = strcmp((char const   *)mpl->image, "else");
                }
#line 186
                if (tmp___13 == 0) {
#line 187
                  mpl->token = 211;
                } else {
                  {
#line 188
                  tmp___12 = strcmp((char const   *)mpl->image, "if");
                  }
#line 188
                  if (tmp___12 == 0) {
#line 189
                    mpl->token = 212;
                  } else {
                    {
#line 190
                    tmp___11 = strcmp((char const   *)mpl->image, "in");
                    }
#line 190
                    if (tmp___11 == 0) {
#line 191
                      mpl->token = 213;
                    } else {
                      {
#line 193
                      tmp___10 = strcmp((char const   *)mpl->image, "Infinity");
                      }
#line 193
                      if (tmp___10 == 0) {
#line 194
                        mpl->token = 214;
                      } else {
                        {
#line 196
                        tmp___9 = strcmp((char const   *)mpl->image, "inter");
                        }
#line 196
                        if (tmp___9 == 0) {
#line 197
                          mpl->token = 215;
                        } else {
                          {
#line 198
                          tmp___8 = strcmp((char const   *)mpl->image, "less");
                          }
#line 198
                          if (tmp___8 == 0) {
#line 199
                            mpl->token = 216;
                          } else {
                            {
#line 200
                            tmp___7 = strcmp((char const   *)mpl->image, "mod");
                            }
#line 200
                            if (tmp___7 == 0) {
#line 201
                              mpl->token = 217;
                            } else {
                              {
#line 202
                              tmp___6 = strcmp((char const   *)mpl->image, "not");
                              }
#line 202
                              if (tmp___6 == 0) {
#line 203
                                mpl->token = 218;
                              } else {
                                {
#line 204
                                tmp___5 = strcmp((char const   *)mpl->image, "or");
                                }
#line 204
                                if (tmp___5 == 0) {
#line 205
                                  mpl->token = 219;
                                } else {
                                  {
#line 206
                                  tmp___4 = strcmp((char const   *)mpl->image, "s");
                                  }
#line 206
                                  if (tmp___4 == 0) {
#line 206
                                    if (mpl->c == 46) {
                                      {
#line 207
                                      mpl->token = 220;
#line 208
                                      _glp_mpl_append_char(mpl);
                                      }
#line 209
                                      if (mpl->c != 116) {
                                        sptp: 
                                        {
#line 210
                                        _glp_mpl_enter_context(mpl);
#line 211
                                        _glp_mpl_error(mpl, (char *)"keyword s.t. incomplete");
                                        }
                                      }
                                      {
#line 213
                                      _glp_mpl_append_char(mpl);
                                      }
#line 214
                                      if (mpl->c != 46) {
#line 214
                                        goto sptp;
                                      }
                                      {
#line 215
                                      _glp_mpl_append_char(mpl);
                                      }
                                    } else {
#line 206
                                      goto _L;
                                    }
                                  } else {
                                    _L: /* CIL Label */ 
                                    {
#line 217
                                    tmp___3 = strcmp((char const   *)mpl->image, "symdiff");
                                    }
#line 217
                                    if (tmp___3 == 0) {
#line 218
                                      mpl->token = 221;
                                    } else {
                                      {
#line 219
                                      tmp___2 = strcmp((char const   *)mpl->image,
                                                       "then");
                                      }
#line 219
                                      if (tmp___2 == 0) {
#line 220
                                        mpl->token = 222;
                                      } else {
                                        {
#line 221
                                        tmp___1 = strcmp((char const   *)mpl->image,
                                                         "union");
                                        }
#line 221
                                        if (tmp___1 == 0) {
#line 222
                                          mpl->token = 223;
                                        } else {
                                          {
#line 223
                                          tmp___0 = strcmp((char const   *)mpl->image,
                                                           "within");
                                          }
#line 223
                                          if (tmp___0 == 0) {
#line 224
                                            mpl->token = 224;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
#line 172
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 226
  if (! mpl->flag_d) {
    {
#line 226
    tmp___33 = __ctype_b_loc();
    }
#line 226
    if ((int const   )*(*tmp___33 + mpl->c) & 2048) {
#line 228
      mpl->token = 204;
      {
#line 230
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 230
        tmp___19 = __ctype_b_loc();
        }
#line 230
        if (! ((int const   )*(*tmp___19 + mpl->c) & 2048)) {
#line 230
          goto while_break___2;
        }
        {
#line 230
        _glp_mpl_append_char(mpl);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 232
      if (mpl->c == 46) {
        {
#line 233
        _glp_mpl_append_char(mpl);
        }
#line 234
        if (mpl->c == 46) {
#line 237
          (mpl->imlen) --;
#line 238
          *(mpl->image + mpl->imlen) = (char )'\000';
#line 239
          mpl->f_dots = 1;
#line 240
          goto conv;
        }
        frac: 
        {
#line 242
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 242
          tmp___20 = __ctype_b_loc();
          }
#line 242
          if (! ((int const   )*(*tmp___20 + mpl->c) & 2048)) {
#line 242
            goto while_break___3;
          }
          {
#line 242
          _glp_mpl_append_char(mpl);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 245
      if (mpl->c == 101) {
#line 245
        goto _L___0;
      } else
#line 245
      if (mpl->c == 69) {
        _L___0: /* CIL Label */ 
        {
#line 246
        _glp_mpl_append_char(mpl);
        }
#line 247
        if (mpl->c == 43) {
          {
#line 247
          _glp_mpl_append_char(mpl);
          }
        } else
#line 247
        if (mpl->c == 45) {
          {
#line 247
          _glp_mpl_append_char(mpl);
          }
        }
        {
#line 248
        tmp___21 = __ctype_b_loc();
        }
#line 248
        if (! ((int const   )*(*tmp___21 + mpl->c) & 2048)) {
          {
#line 249
          _glp_mpl_enter_context(mpl);
#line 250
          _glp_mpl_error(mpl, (char *)"numeric literal %s incomplete", mpl->image);
          }
        }
        {
#line 252
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 252
          tmp___22 = __ctype_b_loc();
          }
#line 252
          if (! ((int const   )*(*tmp___22 + mpl->c) & 2048)) {
#line 252
            goto while_break___4;
          }
          {
#line 252
          _glp_mpl_append_char(mpl);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 255
      tmp___23 = __ctype_b_loc();
      }
#line 255
      if ((int const   )*(*tmp___23 + mpl->c) & 1024) {
        {
#line 256
        _glp_mpl_enter_context(mpl);
#line 257
        _glp_mpl_error(mpl, (char *)"symbol %s%c... should be enclosed in quotes",
                       mpl->image, mpl->c);
        }
      } else
#line 255
      if (mpl->c == 95) {
        {
#line 256
        _glp_mpl_enter_context(mpl);
#line 257
        _glp_mpl_error(mpl, (char *)"symbol %s%c... should be enclosed in quotes",
                       mpl->image, mpl->c);
        }
      }
      conv: 
      {
#line 261
      tmp___24 = _glp_lib_str2num((char const   *)mpl->image, & mpl->value);
      }
#line 261
      if (tmp___24) {
        err: 
        {
#line 262
        _glp_mpl_enter_context(mpl);
#line 263
        _glp_mpl_error(mpl, (char *)"cannot convert numeric literal %s to floating-point number",
                       mpl->image);
        }
      }
    } else {
#line 226
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 267
  if (mpl->c == 39) {
#line 267
    goto _L___5;
  } else
#line 267
  if (mpl->c == 34) {
    _L___5: /* CIL Label */ 
    {
#line 269
    quote = mpl->c;
#line 270
    mpl->token = 205;
#line 271
    _glp_mpl_get_char(mpl);
    }
    {
#line 272
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 273
      if (mpl->c == 10) {
        {
#line 274
        _glp_mpl_enter_context(mpl);
#line 275
        _glp_mpl_error(mpl, (char *)"unexpected end of line; string literal incomplete");
        }
      } else
#line 273
      if (mpl->c == -1) {
        {
#line 274
        _glp_mpl_enter_context(mpl);
#line 275
        _glp_mpl_error(mpl, (char *)"unexpected end of line; string literal incomplete");
        }
      }
#line 278
      if (mpl->c == quote) {
        {
#line 279
        _glp_mpl_get_char(mpl);
        }
#line 280
        if (mpl->c != quote) {
#line 280
          goto while_break___5;
        }
      }
      {
#line 282
      _glp_mpl_append_char(mpl);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 285
  if (! mpl->flag_d) {
#line 285
    if (mpl->c == 43) {
      {
#line 286
      mpl->token = 225;
#line 286
      _glp_mpl_append_char(mpl);
      }
    } else {
#line 285
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 287
  if (! mpl->flag_d) {
#line 287
    if (mpl->c == 45) {
      {
#line 288
      mpl->token = 226;
#line 288
      _glp_mpl_append_char(mpl);
      }
    } else {
#line 287
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 289
  if (mpl->c == 42) {
    {
#line 290
    mpl->token = 227;
#line 290
    _glp_mpl_append_char(mpl);
    }
#line 291
    if (mpl->c == 42) {
      {
#line 292
      mpl->token = 229;
#line 292
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 294
  if (mpl->c == 47) {
    {
#line 295
    mpl->token = 228;
#line 295
    _glp_mpl_append_char(mpl);
    }
#line 296
    if (mpl->c == 42) {
      {
#line 298
      _glp_mpl_get_char(mpl);
      }
      {
#line 299
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 300
        if (mpl->c == -1) {
          {
#line 302
          _glp_mpl_error(mpl, (char *)"unexpected end of file; comment sequence incomplete");
          }
        } else
#line 305
        if (mpl->c == 42) {
          {
#line 306
          _glp_mpl_get_char(mpl);
          }
#line 307
          if (mpl->c == 47) {
#line 307
            goto while_break___6;
          }
        } else {
          {
#line 310
          _glp_mpl_get_char(mpl);
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 312
      _glp_mpl_get_char(mpl);
      }
#line 313
      goto loop;
    }
  } else
#line 316
  if (mpl->c == 94) {
    {
#line 317
    mpl->token = 229;
#line 317
    _glp_mpl_append_char(mpl);
    }
  } else
#line 318
  if (mpl->c == 60) {
    {
#line 319
    mpl->token = 230;
#line 319
    _glp_mpl_append_char(mpl);
    }
#line 320
    if (mpl->c == 61) {
      {
#line 321
      mpl->token = 231;
#line 321
      _glp_mpl_append_char(mpl);
      }
    } else
#line 322
    if (mpl->c == 62) {
      {
#line 323
      mpl->token = 235;
#line 323
      _glp_mpl_append_char(mpl);
      }
    } else
#line 325
    if (mpl->c == 45) {
      {
#line 326
      mpl->token = 252;
#line 326
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 329
  if (mpl->c == 61) {
    {
#line 330
    mpl->token = 232;
#line 330
    _glp_mpl_append_char(mpl);
    }
#line 331
    if (mpl->c == 61) {
      {
#line 331
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 333
  if (mpl->c == 62) {
    {
#line 334
    mpl->token = 234;
#line 334
    _glp_mpl_append_char(mpl);
    }
#line 335
    if (mpl->c == 61) {
      {
#line 336
      mpl->token = 233;
#line 336
      _glp_mpl_append_char(mpl);
      }
    } else
#line 338
    if (mpl->c == 62) {
      {
#line 339
      mpl->token = 250;
#line 339
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 342
  if (mpl->c == 33) {
    {
#line 343
    mpl->token = 218;
#line 343
    _glp_mpl_append_char(mpl);
    }
#line 344
    if (mpl->c == 61) {
      {
#line 345
      mpl->token = 235;
#line 345
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 347
  if (mpl->c == 38) {
    {
#line 348
    mpl->token = 236;
#line 348
    _glp_mpl_append_char(mpl);
    }
#line 349
    if (mpl->c == 38) {
      {
#line 350
      mpl->token = 206;
#line 350
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 352
  if (mpl->c == 124) {
    {
#line 353
    mpl->token = 237;
#line 353
    _glp_mpl_append_char(mpl);
    }
#line 354
    if (mpl->c == 124) {
      {
#line 355
      mpl->token = 219;
#line 355
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 357
  if (! mpl->flag_d) {
#line 357
    if (mpl->c == 46) {
      {
#line 358
      mpl->token = 238;
#line 358
      _glp_mpl_append_char(mpl);
      }
#line 359
      if (mpl->f_dots) {
        {
#line 362
        mpl->token = 243;
#line 363
        mpl->imlen = 2;
#line 364
        strcpy((char */* __restrict  */)mpl->image, (char const   */* __restrict  */)"..");
#line 365
        mpl->f_dots = 0;
        }
      } else
#line 367
      if (mpl->c == 46) {
        {
#line 368
        mpl->token = 243;
#line 368
        _glp_mpl_append_char(mpl);
        }
      } else {
        {
#line 369
        tmp___25 = __ctype_b_loc();
        }
#line 369
        if ((int const   )*(*tmp___25 + mpl->c) & 2048) {
          {
#line 371
          mpl->token = 204;
#line 371
          _glp_mpl_append_char(mpl);
          }
#line 372
          goto frac;
        }
      }
    } else {
#line 357
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 375
  if (mpl->c == 44) {
    {
#line 376
    mpl->token = 239;
#line 376
    _glp_mpl_append_char(mpl);
    }
  } else
#line 377
  if (mpl->c == 58) {
    {
#line 378
    mpl->token = 240;
#line 378
    _glp_mpl_append_char(mpl);
    }
#line 379
    if (mpl->c == 61) {
      {
#line 380
      mpl->token = 242;
#line 380
      _glp_mpl_append_char(mpl);
      }
    }
  } else
#line 382
  if (mpl->c == 59) {
    {
#line 383
    mpl->token = 241;
#line 383
    _glp_mpl_append_char(mpl);
    }
  } else
#line 384
  if (mpl->c == 40) {
    {
#line 385
    mpl->token = 244;
#line 385
    _glp_mpl_append_char(mpl);
    }
  } else
#line 386
  if (mpl->c == 41) {
    {
#line 387
    mpl->token = 245;
#line 387
    _glp_mpl_append_char(mpl);
    }
  } else
#line 388
  if (mpl->c == 91) {
    {
#line 389
    mpl->token = 246;
#line 389
    _glp_mpl_append_char(mpl);
    }
  } else
#line 390
  if (mpl->c == 93) {
    {
#line 391
    mpl->token = 247;
#line 391
    _glp_mpl_append_char(mpl);
    }
  } else
#line 392
  if (mpl->c == 123) {
    {
#line 393
    mpl->token = 248;
#line 393
    _glp_mpl_append_char(mpl);
    }
  } else
#line 394
  if (mpl->c == 125) {
    {
#line 395
    mpl->token = 249;
#line 395
    _glp_mpl_append_char(mpl);
    }
  } else
#line 397
  if (mpl->c == 126) {
    {
#line 398
    mpl->token = 251;
#line 398
    _glp_mpl_append_char(mpl);
    }
  } else {
    {
#line 400
    tmp___31 = __ctype_b_loc();
    }
#line 400
    if ((int const   )*(*tmp___31 + mpl->c) & 8) {
#line 400
      goto _L___1;
    } else {
      {
#line 400
      tmp___32 = strchr("+-._", mpl->c);
      }
#line 400
      if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
        _L___1: /* CIL Label */ 
#line 402
        if (mpl->flag_d) {
#line 402
          tmp___26 = 1;
        } else {
          {
#line 402
          _glp_lib_xassert("mpl->flag_d", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           402);
#line 402
          tmp___26 = 1;
          }
        }
#line 403
        mpl->token = 203;
        {
#line 404
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 404
          tmp___27 = __ctype_b_loc();
          }
#line 404
          if (! ((int const   )*(*tmp___27 + mpl->c) & 8)) {
            {
#line 404
            tmp___28 = strchr("+-._", mpl->c);
            }
#line 404
            if (! ((unsigned long )tmp___28 != (unsigned long )((void *)0))) {
#line 404
              goto while_break___7;
            }
          }
          {
#line 405
          _glp_mpl_append_char(mpl);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 406
        tmp___29 = _glp_lib_str2num((char const   *)mpl->image, & mpl->value);
        }
        {
#line 407
        if (tmp___29 == 0) {
#line 407
          goto case_0;
        }
#line 410
        if (tmp___29 == 1) {
#line 410
          goto case_1;
        }
#line 412
        if (tmp___29 == 2) {
#line 412
          goto case_2;
        }
#line 414
        goto switch_default;
        case_0: /* CIL Label */ 
#line 408
        mpl->token = 204;
#line 409
        goto switch_break;
        case_1: /* CIL Label */ 
#line 411
        goto err;
        case_2: /* CIL Label */ 
#line 413
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 415
        if ((unsigned long )mpl != (unsigned long )mpl) {
#line 415
          tmp___30 = 1;
        } else {
          {
#line 415
          _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           415);
#line 415
          tmp___30 = 1;
          }
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 419
        _glp_mpl_enter_context(mpl);
#line 420
        _glp_mpl_error(mpl, (char *)"character %c not allowed", mpl->c);
        }
      }
    }
  }
  {
#line 423
  _glp_mpl_enter_context(mpl);
#line 426
  mpl->flag_x = 0;
  }
  done: 
#line 427
  return;
}
}
#line 436 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_unget_token(MPL *mpl ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 438
  if (! mpl->f_scan) {
#line 438
    tmp = 1;
  } else {
    {
#line 438
    _glp_lib_xassert("!mpl->f_scan", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     438);
#line 438
    tmp = 1;
    }
  }
  {
#line 439
  mpl->f_scan = 1;
#line 440
  mpl->f_token = mpl->token;
#line 441
  mpl->f_imlen = mpl->imlen;
#line 442
  strcpy((char */* __restrict  */)mpl->f_image, (char const   */* __restrict  */)mpl->image);
#line 443
  mpl->f_value = mpl->value;
#line 445
  mpl->token = mpl->b_token;
#line 446
  mpl->imlen = mpl->b_imlen;
#line 447
  strcpy((char */* __restrict  */)mpl->image, (char const   */* __restrict  */)mpl->b_image);
#line 448
  mpl->value = mpl->b_value;
  }
#line 449
  return;
}
}
#line 458 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
int _glp_mpl_is_keyword(MPL *mpl , char *keyword ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 459
  if (mpl->token == 202) {
    {
#line 459
    tmp = strcmp((char const   *)mpl->image, (char const   *)keyword);
    }
#line 459
    if (tmp == 0) {
#line 459
      tmp___0 = 1;
    } else {
#line 459
      tmp___0 = 0;
    }
  } else {
#line 459
    tmp___0 = 0;
  }
#line 459
  return (tmp___0);
}
}
#line 469 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
int _glp_mpl_is_reserved(MPL *mpl ) 
{ 
  int tmp ;

  {
#line 470
  if (mpl->token == 206) {
#line 470
    if ((int )*(mpl->image + 0) == 97) {
#line 470
      tmp = 1;
    } else {
#line 470
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 470
  if (mpl->token == 207) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 208) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 209) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 210) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 211) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 212) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 213) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 215) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 216) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 217) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 218) {
#line 470
    if ((int )*(mpl->image + 0) == 110) {
#line 470
      tmp = 1;
    } else {
#line 470
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 470
  if (mpl->token == 219) {
#line 470
    if ((int )*(mpl->image + 0) == 111) {
#line 470
      tmp = 1;
    } else {
#line 470
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 470
  if (mpl->token == 221) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 222) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 223) {
#line 470
    tmp = 1;
  } else
#line 470
  if (mpl->token == 224) {
#line 470
    tmp = 1;
  } else {
#line 470
    tmp = 0;
  }
#line 470
  return (tmp);
}
}
#line 496 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_make_code(MPL *mpl , int op , OPERANDS *arg , int type , int dim ) 
{ 
  CODE *code ;
  DOMAIN1 *domain ;
  DOMAIN_BLOCK *block ;
  ARG_LIST *e ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;

  {
  {
#line 502
  tmp = _glp_dmp_get_atom(mpl->pool, (int )sizeof(CODE ));
#line 502
  code = (CODE *)tmp;
#line 503
  code->op = op;
#line 504
  code->vflag = 0;
#line 508
  memset((void *)(& code->arg), '?', (size_t )sizeof(OPERANDS ));
  }
  {
#line 510
  if (op == 301) {
#line 510
    goto case_301;
  }
#line 513
  if (op == 302) {
#line 513
    goto case_302;
  }
#line 516
  if (op == 303) {
#line 516
    goto case_303;
  }
#line 521
  if (op == 305) {
#line 521
    goto case_305;
  }
#line 521
  if (op == 304) {
#line 521
    goto case_305;
  }
#line 531
  if (op == 306) {
#line 531
    goto case_306;
  }
#line 541
  if (op == 307) {
#line 541
    goto case_307;
  }
#line 552
  if (op == 309) {
#line 552
    goto case_309;
  }
#line 552
  if (op == 308) {
#line 552
    goto case_309;
  }
#line 561
  if (op == 310) {
#line 561
    goto case_310;
  }
#line 568
  if (op == 314) {
#line 568
    goto case_314;
  }
#line 568
  if (op == 313) {
#line 568
    goto case_314;
  }
#line 568
  if (op == 312) {
#line 568
    goto case_314;
  }
#line 568
  if (op == 311) {
#line 568
    goto case_314;
  }
#line 592
  if (op == 336) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 335) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 334) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 333) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 332) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 331) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 330) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 329) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 328) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 327) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 326) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 325) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 324) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 323) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 322) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 321) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 320) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 319) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 318) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 317) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 316) {
#line 592
    goto case_336;
  }
#line 592
  if (op == 315) {
#line 592
    goto case_336;
  }
#line 611
  if (op == 348) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 347) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 346) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 345) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 344) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 343) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 342) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 341) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 340) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 339) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 338) {
#line 611
    goto case_348;
  }
#line 611
  if (op == 337) {
#line 611
    goto case_348;
  }
#line 613
  if (op == 349) {
#line 613
    goto case_349;
  }
#line 635
  if (op == 370) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 369) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 368) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 367) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 366) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 365) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 364) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 363) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 362) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 361) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 360) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 359) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 358) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 357) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 356) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 355) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 354) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 353) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 352) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 351) {
#line 635
    goto case_370;
  }
#line 635
  if (op == 350) {
#line 635
    goto case_370;
  }
#line 650
  if (op == 373) {
#line 650
    goto case_373;
  }
#line 650
  if (op == 372) {
#line 650
    goto case_373;
  }
#line 650
  if (op == 371) {
#line 650
    goto case_373;
  }
#line 670
  if (op == 375) {
#line 670
    goto case_375;
  }
#line 670
  if (op == 374) {
#line 670
    goto case_375;
  }
#line 687
  if (op == 383) {
#line 687
    goto case_383;
  }
#line 687
  if (op == 382) {
#line 687
    goto case_383;
  }
#line 687
  if (op == 381) {
#line 687
    goto case_383;
  }
#line 687
  if (op == 380) {
#line 687
    goto case_383;
  }
#line 687
  if (op == 379) {
#line 687
    goto case_383;
  }
#line 687
  if (op == 378) {
#line 687
    goto case_383;
  }
#line 687
  if (op == 377) {
#line 687
    goto case_383;
  }
#line 687
  if (op == 376) {
#line 687
    goto case_383;
  }
#line 711
  goto switch_default;
  case_301: /* CIL Label */ 
#line 511
  code->arg.num = arg->num;
#line 512
  goto switch_break;
  case_302: /* CIL Label */ 
#line 514
  code->arg.str = arg->str;
#line 515
  goto switch_break;
  case_303: /* CIL Label */ 
#line 517
  code->arg.index.slot = arg->index.slot;
#line 518
  code->arg.index.next = arg->index.next;
#line 519
  goto switch_break;
  case_305: /* CIL Label */ 
  case_304: /* CIL Label */ 
#line 522
  e = arg->par.list;
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 522
      goto while_break;
    }
#line 523
    if ((unsigned long )e->x != (unsigned long )((void *)0)) {
#line 523
      tmp___0 = 1;
    } else {
      {
#line 523
      _glp_lib_xassert("e->x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       523);
#line 523
      tmp___0 = 1;
      }
    }
#line 524
    if ((unsigned long )(e->x)->up == (unsigned long )((void *)0)) {
#line 524
      tmp___1 = 1;
    } else {
      {
#line 524
      _glp_lib_xassert("e->x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       524);
#line 524
      tmp___1 = 1;
      }
    }
#line 525
    (e->x)->up = code;
#line 526
    code->vflag |= (e->x)->vflag;
#line 522
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  code->arg.par.par = arg->par.par;
#line 529
  code->arg.par.list = arg->par.list;
#line 530
  goto switch_break;
  case_306: /* CIL Label */ 
#line 532
  e = arg->set.list;
  {
#line 532
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 532
      goto while_break___0;
    }
#line 533
    if ((unsigned long )e->x != (unsigned long )((void *)0)) {
#line 533
      tmp___2 = 1;
    } else {
      {
#line 533
      _glp_lib_xassert("e->x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       533);
#line 533
      tmp___2 = 1;
      }
    }
#line 534
    if ((unsigned long )(e->x)->up == (unsigned long )((void *)0)) {
#line 534
      tmp___3 = 1;
    } else {
      {
#line 534
      _glp_lib_xassert("e->x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       534);
#line 534
      tmp___3 = 1;
      }
    }
#line 535
    (e->x)->up = code;
#line 536
    code->vflag |= (e->x)->vflag;
#line 532
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 538
  code->arg.set.set = arg->set.set;
#line 539
  code->arg.set.list = arg->set.list;
#line 540
  goto switch_break;
  case_307: /* CIL Label */ 
#line 542
  e = arg->var.list;
  {
#line 542
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 542
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 542
      goto while_break___1;
    }
#line 543
    if ((unsigned long )e->x != (unsigned long )((void *)0)) {
#line 543
      tmp___4 = 1;
    } else {
      {
#line 543
      _glp_lib_xassert("e->x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       543);
#line 543
      tmp___4 = 1;
      }
    }
#line 544
    if ((unsigned long )(e->x)->up == (unsigned long )((void *)0)) {
#line 544
      tmp___5 = 1;
    } else {
      {
#line 544
      _glp_lib_xassert("e->x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       544);
#line 544
      tmp___5 = 1;
      }
    }
#line 545
    (e->x)->up = code;
#line 546
    code->vflag |= (e->x)->vflag;
#line 542
    e = e->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 548
  code->arg.var.var = arg->var.var;
#line 549
  code->arg.var.list = arg->var.list;
#line 550
  goto switch_break;
  case_309: /* CIL Label */ 
  case_308: /* CIL Label */ 
#line 553
  e = arg->list;
  {
#line 553
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 553
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 553
      goto while_break___2;
    }
#line 554
    if ((unsigned long )e->x != (unsigned long )((void *)0)) {
#line 554
      tmp___6 = 1;
    } else {
      {
#line 554
      _glp_lib_xassert("e->x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       554);
#line 554
      tmp___6 = 1;
      }
    }
#line 555
    if ((unsigned long )(e->x)->up == (unsigned long )((void *)0)) {
#line 555
      tmp___7 = 1;
    } else {
      {
#line 555
      _glp_lib_xassert("e->x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       555);
#line 555
      tmp___7 = 1;
      }
    }
#line 556
    (e->x)->up = code;
#line 557
    code->vflag |= (e->x)->vflag;
#line 553
    e = e->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 559
  code->arg.list = arg->list;
#line 560
  goto switch_break;
  case_310: /* CIL Label */ 
#line 562
  if ((unsigned long )arg->slice != (unsigned long )((void *)0)) {
#line 562
    tmp___8 = 1;
  } else {
    {
#line 562
    _glp_lib_xassert("arg->slice != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     562);
#line 562
    tmp___8 = 1;
    }
  }
#line 563
  code->arg.slice = arg->slice;
#line 564
  goto switch_break;
  case_314: /* CIL Label */ 
  case_313: /* CIL Label */ 
  case_312: /* CIL Label */ 
  case_311: /* CIL Label */ 
#line 569
  code->vflag = 1;
#line 570
  goto switch_break;
  case_336: /* CIL Label */ 
  case_335: /* CIL Label */ 
  case_334: /* CIL Label */ 
  case_333: /* CIL Label */ 
  case_332: /* CIL Label */ 
  case_331: /* CIL Label */ 
  case_330: /* CIL Label */ 
  case_329: /* CIL Label */ 
  case_328: /* CIL Label */ 
  case_327: /* CIL Label */ 
  case_326: /* CIL Label */ 
  case_325: /* CIL Label */ 
  case_324: /* CIL Label */ 
  case_323: /* CIL Label */ 
  case_322: /* CIL Label */ 
  case_321: /* CIL Label */ 
  case_320: /* CIL Label */ 
  case_319: /* CIL Label */ 
  case_318: /* CIL Label */ 
  case_317: /* CIL Label */ 
  case_316: /* CIL Label */ 
  case_315: /* CIL Label */ 
#line 594
  if ((unsigned long )arg->arg.x != (unsigned long )((void *)0)) {
#line 594
    tmp___9 = 1;
  } else {
    {
#line 594
    _glp_lib_xassert("arg->arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     594);
#line 594
    tmp___9 = 1;
    }
  }
#line 595
  if ((unsigned long )(arg->arg.x)->up == (unsigned long )((void *)0)) {
#line 595
    tmp___10 = 1;
  } else {
    {
#line 595
    _glp_lib_xassert("arg->arg.x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     595);
#line 595
    tmp___10 = 1;
    }
  }
#line 596
  (arg->arg.x)->up = code;
#line 597
  code->vflag |= (arg->arg.x)->vflag;
#line 598
  code->arg.arg.x = arg->arg.x;
#line 599
  goto switch_break;
  case_348: /* CIL Label */ 
  case_347: /* CIL Label */ 
  case_346: /* CIL Label */ 
  case_345: /* CIL Label */ 
  case_344: /* CIL Label */ 
  case_343: /* CIL Label */ 
  case_342: /* CIL Label */ 
  case_341: /* CIL Label */ 
  case_340: /* CIL Label */ 
  case_339: /* CIL Label */ 
  case_338: /* CIL Label */ 
  case_337: /* CIL Label */ 
#line 612
  if (op == 348) {
#line 612
    code->vflag = 1;
  }
  case_349: /* CIL Label */ 
#line 614
  if (op == 349) {
#line 614
    code->vflag = 1;
  }
  case_370: /* CIL Label */ 
  case_369: /* CIL Label */ 
  case_368: /* CIL Label */ 
  case_367: /* CIL Label */ 
  case_366: /* CIL Label */ 
  case_365: /* CIL Label */ 
  case_364: /* CIL Label */ 
  case_363: /* CIL Label */ 
  case_362: /* CIL Label */ 
  case_361: /* CIL Label */ 
  case_360: /* CIL Label */ 
  case_359: /* CIL Label */ 
  case_358: /* CIL Label */ 
  case_357: /* CIL Label */ 
  case_356: /* CIL Label */ 
  case_355: /* CIL Label */ 
  case_354: /* CIL Label */ 
  case_353: /* CIL Label */ 
  case_352: /* CIL Label */ 
  case_351: /* CIL Label */ 
  case_350: /* CIL Label */ 
#line 637
  if ((unsigned long )arg->arg.x != (unsigned long )((void *)0)) {
#line 637
    tmp___11 = 1;
  } else {
    {
#line 637
    _glp_lib_xassert("arg->arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     637);
#line 637
    tmp___11 = 1;
    }
  }
#line 638
  if ((unsigned long )(arg->arg.x)->up == (unsigned long )((void *)0)) {
#line 638
    tmp___12 = 1;
  } else {
    {
#line 638
    _glp_lib_xassert("arg->arg.x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     638);
#line 638
    tmp___12 = 1;
    }
  }
#line 639
  (arg->arg.x)->up = code;
#line 640
  code->vflag |= (arg->arg.x)->vflag;
#line 641
  if ((unsigned long )arg->arg.y != (unsigned long )((void *)0)) {
#line 641
    tmp___13 = 1;
  } else {
    {
#line 641
    _glp_lib_xassert("arg->arg.y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     641);
#line 641
    tmp___13 = 1;
    }
  }
#line 642
  if ((unsigned long )(arg->arg.y)->up == (unsigned long )((void *)0)) {
#line 642
    tmp___14 = 1;
  } else {
    {
#line 642
    _glp_lib_xassert("arg->arg.y->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     642);
#line 642
    tmp___14 = 1;
    }
  }
#line 643
  (arg->arg.y)->up = code;
#line 644
  code->vflag |= (arg->arg.y)->vflag;
#line 645
  code->arg.arg.x = arg->arg.x;
#line 646
  code->arg.arg.y = arg->arg.y;
#line 647
  goto switch_break;
  case_373: /* CIL Label */ 
  case_372: /* CIL Label */ 
  case_371: /* CIL Label */ 
#line 652
  if ((unsigned long )arg->arg.x != (unsigned long )((void *)0)) {
#line 652
    tmp___15 = 1;
  } else {
    {
#line 652
    _glp_lib_xassert("arg->arg.x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     652);
#line 652
    tmp___15 = 1;
    }
  }
#line 653
  if ((unsigned long )(arg->arg.x)->up == (unsigned long )((void *)0)) {
#line 653
    tmp___16 = 1;
  } else {
    {
#line 653
    _glp_lib_xassert("arg->arg.x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     653);
#line 653
    tmp___16 = 1;
    }
  }
#line 654
  (arg->arg.x)->up = code;
#line 655
  code->vflag |= (arg->arg.x)->vflag;
#line 656
  if ((unsigned long )arg->arg.y != (unsigned long )((void *)0)) {
#line 656
    tmp___17 = 1;
  } else {
    {
#line 656
    _glp_lib_xassert("arg->arg.y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     656);
#line 656
    tmp___17 = 1;
    }
  }
#line 657
  if ((unsigned long )(arg->arg.y)->up == (unsigned long )((void *)0)) {
#line 657
    tmp___18 = 1;
  } else {
    {
#line 657
    _glp_lib_xassert("arg->arg.y->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     657);
#line 657
    tmp___18 = 1;
    }
  }
#line 658
  (arg->arg.y)->up = code;
#line 659
  code->vflag |= (arg->arg.y)->vflag;
#line 660
  if ((unsigned long )arg->arg.z != (unsigned long )((void *)0)) {
#line 661
    if ((unsigned long )(arg->arg.z)->up == (unsigned long )((void *)0)) {
#line 661
      tmp___19 = 1;
    } else {
      {
#line 661
      _glp_lib_xassert("arg->arg.z->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       661);
#line 661
      tmp___19 = 1;
      }
    }
#line 662
    (arg->arg.z)->up = code;
#line 663
    code->vflag |= (arg->arg.z)->vflag;
  }
#line 665
  code->arg.arg.x = arg->arg.x;
#line 666
  code->arg.arg.y = arg->arg.y;
#line 667
  code->arg.arg.z = arg->arg.z;
#line 668
  goto switch_break;
  case_375: /* CIL Label */ 
  case_374: /* CIL Label */ 
#line 672
  e = arg->list;
  {
#line 672
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 672
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 672
      goto while_break___3;
    }
#line 673
    if ((unsigned long )e->x != (unsigned long )((void *)0)) {
#line 673
      tmp___20 = 1;
    } else {
      {
#line 673
      _glp_lib_xassert("e->x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       673);
#line 673
      tmp___20 = 1;
      }
    }
#line 674
    if ((unsigned long )(e->x)->up == (unsigned long )((void *)0)) {
#line 674
      tmp___21 = 1;
    } else {
      {
#line 674
      _glp_lib_xassert("e->x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       674);
#line 674
      tmp___21 = 1;
      }
    }
#line 675
    (e->x)->up = code;
#line 676
    code->vflag |= (e->x)->vflag;
#line 672
    e = e->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 678
  code->arg.list = arg->list;
#line 679
  goto switch_break;
  case_383: /* CIL Label */ 
  case_382: /* CIL Label */ 
  case_381: /* CIL Label */ 
  case_380: /* CIL Label */ 
  case_379: /* CIL Label */ 
  case_378: /* CIL Label */ 
  case_377: /* CIL Label */ 
  case_376: /* CIL Label */ 
#line 689
  domain = arg->loop.domain;
#line 690
  if ((unsigned long )domain != (unsigned long )((void *)0)) {
#line 690
    tmp___22 = 1;
  } else {
    {
#line 690
    _glp_lib_xassert("domain != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     690);
#line 690
    tmp___22 = 1;
    }
  }
#line 691
  if ((unsigned long )domain->code != (unsigned long )((void *)0)) {
#line 692
    if ((unsigned long )(domain->code)->up == (unsigned long )((void *)0)) {
#line 692
      tmp___23 = 1;
    } else {
      {
#line 692
      _glp_lib_xassert("domain->code->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       692);
#line 692
      tmp___23 = 1;
      }
    }
#line 693
    (domain->code)->up = code;
#line 694
    code->vflag |= (domain->code)->vflag;
  }
#line 696
  block = domain->list;
  {
#line 696
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 696
    if (! ((unsigned long )block != (unsigned long )((void *)0))) {
#line 696
      goto while_break___4;
    }
#line 698
    if ((unsigned long )block->code != (unsigned long )((void *)0)) {
#line 698
      tmp___24 = 1;
    } else {
      {
#line 698
      _glp_lib_xassert("block->code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       698);
#line 698
      tmp___24 = 1;
      }
    }
#line 699
    if ((unsigned long )(block->code)->up == (unsigned long )((void *)0)) {
#line 699
      tmp___25 = 1;
    } else {
      {
#line 699
      _glp_lib_xassert("block->code->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       699);
#line 699
      tmp___25 = 1;
      }
    }
#line 700
    (block->code)->up = code;
#line 701
    code->vflag |= (block->code)->vflag;
#line 696
    block = block->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 703
  if ((unsigned long )arg->loop.x != (unsigned long )((void *)0)) {
#line 704
    if ((unsigned long )(arg->loop.x)->up == (unsigned long )((void *)0)) {
#line 704
      tmp___26 = 1;
    } else {
      {
#line 704
      _glp_lib_xassert("arg->loop.x->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       704);
#line 704
      tmp___26 = 1;
      }
    }
#line 705
    (arg->loop.x)->up = code;
#line 706
    code->vflag |= (arg->loop.x)->vflag;
  }
#line 708
  code->arg.loop.domain = arg->loop.domain;
#line 709
  code->arg.loop.x = arg->loop.x;
#line 710
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 712
  if (op != op) {
#line 712
    tmp___27 = 1;
  } else {
    {
#line 712
    _glp_lib_xassert("op != op", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     712);
#line 712
    tmp___27 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 715
  code->type = type;
#line 716
  code->dim = dim;
#line 717
  code->up = (CODE *)((void *)0);
#line 718
  code->valid = 0;
#line 719
  memset((void *)(& code->value), '?', (size_t )sizeof(VALUE ));
  }
#line 720
  return (code);
}
}
#line 728 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_make_unary(MPL *mpl , int op , CODE *x , int type , int dim ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 731
  if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 731
    tmp = 1;
  } else {
    {
#line 731
    _glp_lib_xassert("x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     731);
#line 731
    tmp = 1;
    }
  }
  {
#line 732
  arg.arg.x = x;
#line 733
  code = _glp_mpl_make_code(mpl, op, & arg, type, dim);
  }
#line 734
  return (code);
}
}
#line 742 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_make_binary(MPL *mpl , int op , CODE *x , CODE *y , int type , int dim ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 746
  if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 746
    tmp = 1;
  } else {
    {
#line 746
    _glp_lib_xassert("x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     746);
#line 746
    tmp = 1;
    }
  }
#line 747
  if ((unsigned long )y != (unsigned long )((void *)0)) {
#line 747
    tmp___0 = 1;
  } else {
    {
#line 747
    _glp_lib_xassert("y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     747);
#line 747
    tmp___0 = 1;
    }
  }
  {
#line 748
  arg.arg.x = x;
#line 749
  arg.arg.y = y;
#line 750
  code = _glp_mpl_make_code(mpl, op, & arg, type, dim);
  }
#line 751
  return (code);
}
}
#line 759 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_make_ternary(MPL *mpl , int op , CODE *x , CODE *y , CODE *z , int type ,
                            int dim ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 763
  if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 763
    tmp = 1;
  } else {
    {
#line 763
    _glp_lib_xassert("x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     763);
#line 763
    tmp = 1;
    }
  }
#line 764
  if ((unsigned long )y != (unsigned long )((void *)0)) {
#line 764
    tmp___0 = 1;
  } else {
    {
#line 764
    _glp_lib_xassert("y != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     764);
#line 764
    tmp___0 = 1;
    }
  }
  {
#line 766
  arg.arg.x = x;
#line 767
  arg.arg.y = y;
#line 768
  arg.arg.z = z;
#line 769
  code = _glp_mpl_make_code(mpl, op, & arg, type, dim);
  }
#line 770
  return (code);
}
}
#line 780 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_numeric_literal(MPL *mpl ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 783
  if (mpl->token == 204) {
#line 783
    tmp = 1;
  } else {
    {
#line 783
    _glp_lib_xassert("mpl->token == T_NUMBER", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     783);
#line 783
    tmp = 1;
    }
  }
  {
#line 784
  arg.num = mpl->value;
#line 785
  code = _glp_mpl_make_code(mpl, 301, & arg, 118, 0);
#line 786
  _glp_mpl_get_token(mpl);
  }
#line 787
  return (code);
}
}
#line 797 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_string_literal(MPL *mpl ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 800
  if (mpl->token == 205) {
#line 800
    tmp = 1;
  } else {
    {
#line 800
    _glp_lib_xassert("mpl->token == T_STRING", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     800);
#line 800
    tmp = 1;
    }
  }
  {
#line 801
  tmp___0 = strlen((char const   *)mpl->image);
#line 801
  tmp___1 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___0 + 1U));
#line 801
  arg.str = (char *)tmp___1;
#line 802
  strcpy((char */* __restrict  */)arg.str, (char const   */* __restrict  */)mpl->image);
#line 803
  code = _glp_mpl_make_code(mpl, 302, & arg, 124, 0);
#line 804
  _glp_mpl_get_token(mpl);
  }
#line 805
  return (code);
}
}
#line 813 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
ARG_LIST *_glp_mpl_create_arg_list(MPL *mpl ) 
{ 
  ARG_LIST *list ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 815
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 815
    tmp = 1;
  } else {
    {
#line 815
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     815);
#line 815
    tmp = 1;
    }
  }
#line 816
  list = (ARG_LIST *)((void *)0);
#line 817
  return (list);
}
}
#line 825 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
ARG_LIST *_glp_mpl_expand_arg_list(MPL *mpl , ARG_LIST *list , CODE *x ) 
{ 
  ARG_LIST *tail ;
  ARG_LIST *temp ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 827
  if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 827
    tmp = 1;
  } else {
    {
#line 827
    _glp_lib_xassert("x != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     827);
#line 827
    tmp = 1;
    }
  }
  {
#line 829
  tmp___0 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(ARG_LIST ));
#line 829
  tail = (ARG_LIST *)tmp___0;
#line 830
  tail->x = x;
#line 831
  tail->next = (ARG_LIST *)((void *)0);
  }
#line 833
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 834
    list = tail;
  } else {
#line 836
    temp = list;
    {
#line 836
    while (1) {
      while_continue: /* CIL Label */ ;
#line 836
      if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 836
        goto while_break;
      }
#line 836
      temp = temp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 837
    temp->next = tail;
  }
#line 839
  return (list);
}
}
#line 847 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
int _glp_mpl_arg_list_len(MPL *mpl , ARG_LIST *list ) 
{ 
  ARG_LIST *temp ;
  int len ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 850
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 850
    tmp = 1;
  } else {
    {
#line 850
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     850);
#line 850
    tmp = 1;
    }
  }
#line 851
  len = 0;
#line 852
  temp = list;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 852
      goto while_break;
    }
#line 852
    len ++;
#line 852
    temp = temp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  return (len);
}
}
#line 865 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
ARG_LIST *_glp_mpl_subscript_list(MPL *mpl ) 
{ 
  ARG_LIST *list ;
  CODE *x ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 868
  list = _glp_mpl_create_arg_list(mpl);
  }
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 871
    x = _glp_mpl_expression_5(mpl);
    }
#line 873
    if (x->type == 118) {
      {
#line 874
      x = _glp_mpl_make_unary(mpl, 316, x, 124, 0);
      }
    }
#line 876
    if (x->type != 124) {
      {
#line 877
      _glp_mpl_error(mpl, (char *)"subscript expression has invalid type");
      }
    }
#line 878
    if (x->dim == 0) {
#line 878
      tmp = 1;
    } else {
      {
#line 878
      _glp_lib_xassert("x->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       878);
#line 878
      tmp = 1;
      }
    }
    {
#line 880
    list = _glp_mpl_expand_arg_list(mpl, list, x);
    }
#line 882
    if (mpl->token == 239) {
      {
#line 883
      _glp_mpl_get_token(mpl);
      }
    } else
#line 884
    if (mpl->token == 247) {
#line 885
      goto while_break;
    } else {
      {
#line 887
      _glp_mpl_error(mpl, (char *)"syntax error in subscript list");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 889
  return (list);
}
}
#line 909 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_object_reference(MPL *mpl ) 
{ 
  AVLNODE *node ;
  DOMAIN_SLOT *slot ;
  SET *set___0 ;
  PARAMETER *par ;
  VARIABLE *var ;
  CONSTRAINT *con ;
  ARG_LIST *list ;
  OPERANDS arg ;
  CODE *code ;
  char *name ;
  int dim ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 922
  if (mpl->token == 202) {
#line 922
    tmp = 1;
  } else {
    {
#line 922
    _glp_lib_xassert("mpl->token == T_NAME", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     922);
#line 922
    tmp = 1;
    }
  }
  {
#line 923
  node = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
  }
#line 924
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 925
    _glp_mpl_error(mpl, (char *)"%s not defined", mpl->image);
    }
  }
  {
#line 927
  tmp___0 = _glp_avl_get_node_type(node);
  }
  {
#line 928
  if (tmp___0 == 111) {
#line 928
    goto case_111;
  }
#line 934
  if (tmp___0 == 122) {
#line 934
    goto case_122;
  }
#line 944
  if (tmp___0 == 120) {
#line 944
    goto case_120;
  }
#line 950
  if (tmp___0 == 127) {
#line 950
    goto case_127;
  }
#line 956
  if (tmp___0 == 103) {
#line 956
    goto case_103;
  }
#line 962
  goto switch_default;
  case_111: /* CIL Label */ 
  {
#line 930
  tmp___1 = _glp_avl_get_node_link(node);
#line 930
  slot = (DOMAIN_SLOT *)tmp___1;
#line 931
  name = slot->name;
#line 932
  dim = 0;
  }
#line 933
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 936
  tmp___2 = _glp_avl_get_node_link(node);
#line 936
  set___0 = (SET *)tmp___2;
#line 937
  name = set___0->name;
#line 938
  dim = set___0->dim;
  }
#line 942
  if (set___0->dimen == 0) {
#line 942
    set___0->dimen = 1;
  }
#line 943
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 946
  tmp___3 = _glp_avl_get_node_link(node);
#line 946
  par = (PARAMETER *)tmp___3;
#line 947
  name = par->name;
#line 948
  dim = par->dim;
  }
#line 949
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 952
  tmp___4 = _glp_avl_get_node_link(node);
#line 952
  var = (VARIABLE *)tmp___4;
#line 953
  name = var->name;
#line 954
  dim = var->dim;
  }
#line 955
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 958
  tmp___5 = _glp_avl_get_node_link(node);
#line 958
  con = (CONSTRAINT *)tmp___5;
  }
#line 959
  if (con->type == 103) {
#line 959
    tmp___6 = "constraint";
  } else {
#line 959
    tmp___6 = "objective";
  }
  {
#line 959
  _glp_mpl_error(mpl, (char *)"invalid reference to %s %s", tmp___6, mpl->image);
  }
  switch_default: /* CIL Label */ 
#line 963
  if ((unsigned long )node != (unsigned long )node) {
#line 963
    tmp___7 = 1;
  } else {
    {
#line 963
    _glp_lib_xassert("node != node", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     963);
#line 963
    tmp___7 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 965
  _glp_mpl_get_token(mpl);
  }
#line 967
  if (mpl->token == 246) {
#line 969
    if (dim == 0) {
      {
#line 970
      _glp_mpl_error(mpl, (char *)"%s cannot be subscripted", name);
      }
    }
    {
#line 971
    _glp_mpl_get_token(mpl);
#line 972
    list = _glp_mpl_subscript_list(mpl);
#line 973
    tmp___10 = _glp_mpl_arg_list_len(mpl, list);
    }
#line 973
    if (dim != tmp___10) {
      {
#line 974
      tmp___8 = _glp_mpl_arg_list_len(mpl, list);
      }
#line 974
      if (dim == 1) {
#line 974
        tmp___9 = "";
      } else {
#line 974
        tmp___9 = "s";
      }
      {
#line 974
      _glp_mpl_error(mpl, (char *)"%s must have %d subscript%s rather than %d", name,
                     dim, tmp___9, tmp___8);
      }
    }
#line 976
    if (mpl->token == 247) {
#line 976
      tmp___11 = 1;
    } else {
      {
#line 976
      _glp_lib_xassert("mpl->token == T_RBRACKET", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       976);
#line 976
      tmp___11 = 1;
      }
    }
    {
#line 977
    _glp_mpl_get_token(mpl);
    }
  } else {
#line 981
    if (dim != 0) {
      {
#line 982
      _glp_mpl_error(mpl, (char *)"%s must be subscripted", name);
      }
    }
    {
#line 983
    list = _glp_mpl_create_arg_list(mpl);
    }
  }
  {
#line 986
  tmp___12 = _glp_avl_get_node_type(node);
  }
  {
#line 987
  if (tmp___12 == 111) {
#line 987
    goto case_111___0;
  }
#line 993
  if (tmp___12 == 122) {
#line 993
    goto case_122___0;
  }
#line 999
  if (tmp___12 == 120) {
#line 999
    goto case_120___0;
  }
#line 1007
  if (tmp___12 == 127) {
#line 1007
    goto case_127___0;
  }
#line 1023
  goto switch_default___0;
  case_111___0: /* CIL Label */ 
  {
#line 988
  arg.index.slot = slot;
#line 989
  arg.index.next = slot->list;
#line 990
  code = _glp_mpl_make_code(mpl, 303, & arg, 124, 0);
#line 991
  slot->list = code;
  }
#line 992
  goto switch_break___0;
  case_122___0: /* CIL Label */ 
  {
#line 994
  arg.set.set = set___0;
#line 995
  arg.set.list = list;
#line 996
  code = _glp_mpl_make_code(mpl, 306, & arg, 106, set___0->dimen);
  }
#line 998
  goto switch_break___0;
  case_120___0: /* CIL Label */ 
#line 1000
  arg.par.par = par;
#line 1001
  arg.par.list = list;
#line 1002
  if (par->type == 124) {
    {
#line 1003
    code = _glp_mpl_make_code(mpl, 305, & arg, 124, 0);
    }
  } else {
    {
#line 1005
    code = _glp_mpl_make_code(mpl, 304, & arg, 118, 0);
    }
  }
#line 1006
  goto switch_break___0;
  case_127___0: /* CIL Label */ 
#line 1008
  arg.var.var = var;
#line 1009
  arg.var.list = list;
#line 1013
  if (! mpl->flag_s) {
    {
#line 1015
    code = _glp_mpl_make_code(mpl, 307, & arg, 110, 0);
    }
  } else {
    {
#line 1019
    code = _glp_mpl_make_code(mpl, 307, & arg, 118, 0);
    }
  }
#line 1022
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1024
  if ((unsigned long )node != (unsigned long )node) {
#line 1024
    tmp___13 = 1;
  } else {
    {
#line 1024
    _glp_lib_xassert("node != node", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1024);
#line 1024
    tmp___13 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 1026
  return (code);
}
}
#line 1037 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_numeric_argument(MPL *mpl , char *func___0 ) 
{ 
  CODE *x ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1039
  x = _glp_mpl_expression_5(mpl);
  }
#line 1041
  if (x->type == 124) {
    {
#line 1042
    x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
    }
  }
#line 1044
  if (x->type != 118) {
    {
#line 1045
    _glp_mpl_error(mpl, (char *)"argument for %s has invalid type", func___0);
    }
  }
#line 1046
  if (x->dim == 0) {
#line 1046
    tmp = 1;
  } else {
    {
#line 1046
    _glp_lib_xassert("x->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1046);
#line 1046
    tmp = 1;
    }
  }
#line 1047
  return (x);
}
}
#line 1051 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_symbolic_argument(MPL *mpl , char *func___0 ) 
{ 
  CODE *x ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1053
  x = _glp_mpl_expression_5(mpl);
  }
#line 1055
  if (x->type == 118) {
    {
#line 1056
    x = _glp_mpl_make_unary(mpl, 316, x, 124, 0);
    }
  }
#line 1058
  if (x->type != 124) {
    {
#line 1059
    _glp_mpl_error(mpl, (char *)"argument for %s has invalid type", func___0);
    }
  }
#line 1060
  if (x->dim == 0) {
#line 1060
    tmp = 1;
  } else {
    {
#line 1060
    _glp_lib_xassert("x->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1060);
#line 1060
    tmp = 1;
    }
  }
#line 1061
  return (x);
}
}
#line 1066 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_elemset_argument(MPL *mpl , char *func___0 ) 
{ 
  CODE *x ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1068
  x = _glp_mpl_expression_9(mpl);
  }
#line 1069
  if (x->type != 106) {
    {
#line 1070
    _glp_mpl_error(mpl, (char *)"argument for %s has invalid type", func___0);
    }
  }
#line 1071
  if (x->dim > 0) {
#line 1071
    tmp = 1;
  } else {
    {
#line 1071
    _glp_lib_xassert("x->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1071);
#line 1071
    tmp = 1;
    }
  }
#line 1072
  return (x);
}
}
#line 1113 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_function_reference(MPL *mpl ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int op ;
  char func___0[16] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  CODE *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;

  {
#line 1119
  if (mpl->token == 202) {
#line 1119
    tmp = 1;
  } else {
    {
#line 1119
    _glp_lib_xassert("mpl->token == T_NAME", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1119);
#line 1119
    tmp = 1;
    }
  }
  {
#line 1120
  tmp___24 = strcmp((char const   *)mpl->image, "abs");
  }
#line 1120
  if (tmp___24 == 0) {
#line 1121
    op = 323;
  } else {
    {
#line 1122
    tmp___23 = strcmp((char const   *)mpl->image, "ceil");
    }
#line 1122
    if (tmp___23 == 0) {
#line 1123
      op = 324;
    } else {
      {
#line 1124
      tmp___22 = strcmp((char const   *)mpl->image, "floor");
      }
#line 1124
      if (tmp___22 == 0) {
#line 1125
        op = 325;
      } else {
        {
#line 1126
        tmp___21 = strcmp((char const   *)mpl->image, "exp");
        }
#line 1126
        if (tmp___21 == 0) {
#line 1127
          op = 326;
        } else {
          {
#line 1128
          tmp___20 = strcmp((char const   *)mpl->image, "log");
          }
#line 1128
          if (tmp___20 == 0) {
#line 1129
            op = 327;
          } else {
            {
#line 1130
            tmp___19 = strcmp((char const   *)mpl->image, "log10");
            }
#line 1130
            if (tmp___19 == 0) {
#line 1131
              op = 328;
            } else {
              {
#line 1132
              tmp___18 = strcmp((char const   *)mpl->image, "sqrt");
              }
#line 1132
              if (tmp___18 == 0) {
#line 1133
                op = 329;
              } else {
                {
#line 1134
                tmp___17 = strcmp((char const   *)mpl->image, "sin");
                }
#line 1134
                if (tmp___17 == 0) {
#line 1135
                  op = 330;
                } else {
                  {
#line 1136
                  tmp___16 = strcmp((char const   *)mpl->image, "cos");
                  }
#line 1136
                  if (tmp___16 == 0) {
#line 1137
                    op = 331;
                  } else {
                    {
#line 1138
                    tmp___15 = strcmp((char const   *)mpl->image, "atan");
                    }
#line 1138
                    if (tmp___15 == 0) {
#line 1139
                      op = 332;
                    } else {
                      {
#line 1140
                      tmp___14 = strcmp((char const   *)mpl->image, "min");
                      }
#line 1140
                      if (tmp___14 == 0) {
#line 1141
                        op = 374;
                      } else {
                        {
#line 1142
                        tmp___13 = strcmp((char const   *)mpl->image, "max");
                        }
#line 1142
                        if (tmp___13 == 0) {
#line 1143
                          op = 375;
                        } else {
                          {
#line 1144
                          tmp___12 = strcmp((char const   *)mpl->image, "round");
                          }
#line 1144
                          if (tmp___12 == 0) {
#line 1145
                            op = 333;
                          } else {
                            {
#line 1146
                            tmp___11 = strcmp((char const   *)mpl->image, "trunc");
                            }
#line 1146
                            if (tmp___11 == 0) {
#line 1147
                              op = 334;
                            } else {
                              {
#line 1148
                              tmp___10 = strcmp((char const   *)mpl->image, "Irand224");
                              }
#line 1148
                              if (tmp___10 == 0) {
#line 1149
                                op = 311;
                              } else {
                                {
#line 1150
                                tmp___9 = strcmp((char const   *)mpl->image, "Uniform01");
                                }
#line 1150
                                if (tmp___9 == 0) {
#line 1151
                                  op = 312;
                                } else {
                                  {
#line 1152
                                  tmp___8 = strcmp((char const   *)mpl->image, "Uniform");
                                  }
#line 1152
                                  if (tmp___8 == 0) {
#line 1153
                                    op = 348;
                                  } else {
                                    {
#line 1154
                                    tmp___7 = strcmp((char const   *)mpl->image, "Normal01");
                                    }
#line 1154
                                    if (tmp___7 == 0) {
#line 1155
                                      op = 313;
                                    } else {
                                      {
#line 1156
                                      tmp___6 = strcmp((char const   *)mpl->image,
                                                       "Normal");
                                      }
#line 1156
                                      if (tmp___6 == 0) {
#line 1157
                                        op = 349;
                                      } else {
                                        {
#line 1158
                                        tmp___5 = strcmp((char const   *)mpl->image,
                                                         "card");
                                        }
#line 1158
                                        if (tmp___5 == 0) {
#line 1159
                                          op = 335;
                                        } else {
                                          {
#line 1160
                                          tmp___4 = strcmp((char const   *)mpl->image,
                                                           "length");
                                          }
#line 1160
                                          if (tmp___4 == 0) {
#line 1161
                                            op = 336;
                                          } else {
                                            {
#line 1162
                                            tmp___3 = strcmp((char const   *)mpl->image,
                                                             "substr");
                                            }
#line 1162
                                            if (tmp___3 == 0) {
#line 1163
                                              op = 368;
                                            } else {
                                              {
#line 1164
                                              tmp___2 = strcmp((char const   *)mpl->image,
                                                               "str2time");
                                              }
#line 1164
                                              if (tmp___2 == 0) {
#line 1165
                                                op = 369;
                                              } else {
                                                {
#line 1166
                                                tmp___1 = strcmp((char const   *)mpl->image,
                                                                 "time2str");
                                                }
#line 1166
                                                if (tmp___1 == 0) {
#line 1167
                                                  op = 370;
                                                } else {
                                                  {
#line 1168
                                                  tmp___0 = strcmp((char const   *)mpl->image,
                                                                   "gmtime");
                                                  }
#line 1168
                                                  if (tmp___0 == 0) {
#line 1169
                                                    op = 314;
                                                  } else {
                                                    {
#line 1171
                                                    _glp_mpl_error(mpl, (char *)"function %s unknown",
                                                                   mpl->image);
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1173
  strcpy((char */* __restrict  */)(func___0), (char const   */* __restrict  */)mpl->image);
#line 1174
  tmp___25 = strlen((char const   *)(func___0));
  }
#line 1174
  if ((unsigned long )tmp___25 < sizeof(func___0)) {
#line 1174
    tmp___26 = 1;
  } else {
    {
#line 1174
    _glp_lib_xassert("strlen(func) < sizeof(func)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1174);
#line 1174
    tmp___26 = 1;
    }
  }
  {
#line 1175
  _glp_mpl_get_token(mpl);
  }
#line 1177
  if (mpl->token == 244) {
#line 1177
    tmp___27 = 1;
  } else {
    {
#line 1177
    _glp_lib_xassert("mpl->token == T_LEFT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1177);
#line 1177
    tmp___27 = 1;
    }
  }
  {
#line 1178
  _glp_mpl_get_token(mpl);
  }
#line 1180
  if (op == 374) {
#line 1180
    goto _L___2;
  } else
#line 1180
  if (op == 375) {
    _L___2: /* CIL Label */ 
    {
#line 1182
    arg.list = _glp_mpl_create_arg_list(mpl);
    }
    {
#line 1184
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1186
      tmp___28 = _glp_mpl_numeric_argument(mpl, func___0);
#line 1186
      arg.list = _glp_mpl_expand_arg_list(mpl, arg.list, tmp___28);
      }
#line 1189
      if (mpl->token == 239) {
        {
#line 1190
        _glp_mpl_get_token(mpl);
        }
      } else
#line 1191
      if (mpl->token == 245) {
#line 1192
        goto while_break;
      } else {
        {
#line 1194
        _glp_mpl_error(mpl, (char *)"syntax error in argument list for %s", func___0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1197
  if (op == 311) {
#line 1197
    goto _L___1;
  } else
#line 1197
  if (op == 312) {
#line 1197
    goto _L___1;
  } else
#line 1197
  if (op == 313) {
#line 1197
    goto _L___1;
  } else
#line 1197
  if (op == 314) {
    _L___1: /* CIL Label */ 
#line 1200
    if (mpl->token != 245) {
      {
#line 1201
      _glp_mpl_error(mpl, (char *)"%s needs no arguments", func___0);
      }
    }
  } else
#line 1203
  if (op == 348) {
#line 1203
    goto _L___0;
  } else
#line 1203
  if (op == 349) {
    _L___0: /* CIL Label */ 
    {
#line 1206
    arg.arg.x = _glp_mpl_numeric_argument(mpl, func___0);
    }
#line 1208
    if (! (mpl->token == 239)) {
#line 1210
      if (mpl->token == 245) {
        {
#line 1211
        _glp_mpl_error(mpl, (char *)"%s needs two arguments", func___0);
        }
      } else {
        {
#line 1213
        _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
        }
      }
    }
    {
#line 1214
    _glp_mpl_get_token(mpl);
#line 1216
    arg.arg.y = _glp_mpl_numeric_argument(mpl, func___0);
    }
#line 1218
    if (mpl->token == 239) {
      {
#line 1219
      _glp_mpl_error(mpl, (char *)"%s needs two argument", func___0);
      }
    } else
#line 1220
    if (! (mpl->token == 245)) {
      {
#line 1223
      _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
      }
    }
  } else
#line 1225
  if (op == 332) {
#line 1225
    goto _L;
  } else
#line 1225
  if (op == 333) {
#line 1225
    goto _L;
  } else
#line 1225
  if (op == 334) {
    _L: /* CIL Label */ 
    {
#line 1228
    arg.arg.x = _glp_mpl_numeric_argument(mpl, func___0);
    }
#line 1230
    if (mpl->token == 239) {
      {
#line 1232
      if (op == 332) {
#line 1232
        goto case_332;
      }
#line 1233
      if (op == 333) {
#line 1233
        goto case_333;
      }
#line 1234
      if (op == 334) {
#line 1234
        goto case_334;
      }
#line 1235
      goto switch_default;
      case_332: /* CIL Label */ 
#line 1232
      op = 345;
#line 1232
      goto switch_break;
      case_333: /* CIL Label */ 
#line 1233
      op = 346;
#line 1233
      goto switch_break;
      case_334: /* CIL Label */ 
#line 1234
      op = 347;
#line 1234
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1235
      if (op != op) {
#line 1235
        tmp___29 = 1;
      } else {
        {
#line 1235
        _glp_lib_xassert("op != op", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         1235);
#line 1235
        tmp___29 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 1237
      _glp_mpl_get_token(mpl);
#line 1238
      arg.arg.y = _glp_mpl_numeric_argument(mpl, func___0);
      }
    }
#line 1241
    if (mpl->token == 239) {
      {
#line 1242
      _glp_mpl_error(mpl, (char *)"%s needs one or two arguments", func___0);
      }
    } else
#line 1243
    if (! (mpl->token == 245)) {
      {
#line 1246
      _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
      }
    }
  } else
#line 1248
  if (op == 368) {
    {
#line 1251
    arg.arg.x = _glp_mpl_symbolic_argument(mpl, func___0);
    }
#line 1253
    if (! (mpl->token == 239)) {
#line 1255
      if (mpl->token == 245) {
        {
#line 1256
        _glp_mpl_error(mpl, (char *)"%s needs two or three arguments", func___0);
        }
      } else {
        {
#line 1258
        _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
        }
      }
    }
    {
#line 1259
    _glp_mpl_get_token(mpl);
#line 1261
    arg.arg.y = _glp_mpl_numeric_argument(mpl, func___0);
    }
#line 1263
    if (mpl->token == 239) {
      {
#line 1264
      op = 373;
#line 1265
      _glp_mpl_get_token(mpl);
#line 1266
      arg.arg.z = _glp_mpl_numeric_argument(mpl, func___0);
      }
    }
#line 1269
    if (mpl->token == 239) {
      {
#line 1270
      _glp_mpl_error(mpl, (char *)"%s needs two or three arguments", func___0);
      }
    } else
#line 1271
    if (! (mpl->token == 245)) {
      {
#line 1274
      _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
      }
    }
  } else
#line 1276
  if (op == 369) {
    {
#line 1279
    arg.arg.x = _glp_mpl_symbolic_argument(mpl, func___0);
    }
#line 1281
    if (! (mpl->token == 239)) {
#line 1283
      if (mpl->token == 245) {
        {
#line 1284
        _glp_mpl_error(mpl, (char *)"%s needs two arguments", func___0);
        }
      } else {
        {
#line 1286
        _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
        }
      }
    }
    {
#line 1287
    _glp_mpl_get_token(mpl);
#line 1289
    arg.arg.y = _glp_mpl_symbolic_argument(mpl, func___0);
    }
#line 1291
    if (mpl->token == 239) {
      {
#line 1292
      _glp_mpl_error(mpl, (char *)"%s needs two argument", func___0);
      }
    } else
#line 1293
    if (! (mpl->token == 245)) {
      {
#line 1296
      _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
      }
    }
  } else
#line 1298
  if (op == 370) {
    {
#line 1301
    arg.arg.x = _glp_mpl_numeric_argument(mpl, func___0);
    }
#line 1303
    if (! (mpl->token == 239)) {
#line 1305
      if (mpl->token == 245) {
        {
#line 1306
        _glp_mpl_error(mpl, (char *)"%s needs two arguments", func___0);
        }
      } else {
        {
#line 1308
        _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
        }
      }
    }
    {
#line 1309
    _glp_mpl_get_token(mpl);
#line 1311
    arg.arg.y = _glp_mpl_symbolic_argument(mpl, func___0);
    }
#line 1313
    if (mpl->token == 239) {
      {
#line 1314
      _glp_mpl_error(mpl, (char *)"%s needs two argument", func___0);
      }
    } else
#line 1315
    if (! (mpl->token == 245)) {
      {
#line 1318
      _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
      }
    }
  } else {
#line 1322
    if (op == 335) {
      {
#line 1323
      arg.arg.x = _glp_mpl_elemset_argument(mpl, func___0);
      }
    } else
#line 1324
    if (op == 336) {
      {
#line 1325
      arg.arg.x = _glp_mpl_symbolic_argument(mpl, func___0);
      }
    } else {
      {
#line 1327
      arg.arg.x = _glp_mpl_numeric_argument(mpl, func___0);
      }
    }
#line 1329
    if (mpl->token == 239) {
      {
#line 1330
      _glp_mpl_error(mpl, (char *)"%s needs one argument", func___0);
      }
    } else
#line 1331
    if (! (mpl->token == 245)) {
      {
#line 1334
      _glp_mpl_error(mpl, (char *)"syntax error in argument for %s", func___0);
      }
    }
  }
#line 1337
  if (op == 368) {
    {
#line 1338
    code = _glp_mpl_make_code(mpl, op, & arg, 124, 0);
    }
  } else
#line 1337
  if (op == 373) {
    {
#line 1338
    code = _glp_mpl_make_code(mpl, op, & arg, 124, 0);
    }
  } else
#line 1337
  if (op == 370) {
    {
#line 1338
    code = _glp_mpl_make_code(mpl, op, & arg, 124, 0);
    }
  } else {
    {
#line 1340
    code = _glp_mpl_make_code(mpl, op, & arg, 118, 0);
    }
  }
#line 1342
  if (mpl->token == 245) {
#line 1342
    tmp___30 = 1;
  } else {
    {
#line 1342
    _glp_lib_xassert("mpl->token == T_RIGHT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1342);
#line 1342
    tmp___30 = 1;
    }
  }
  {
#line 1343
  _glp_mpl_get_token(mpl);
  }
#line 1344
  return (code);
}
}
#line 1353 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
DOMAIN1 *_glp_mpl_create_domain(MPL *mpl ) 
{ 
  DOMAIN1 *domain ;
  void *tmp ;

  {
  {
#line 1355
  tmp = _glp_dmp_get_atom(mpl->pool, (int )sizeof(DOMAIN1 ));
#line 1355
  domain = (DOMAIN1 *)tmp;
#line 1356
  domain->list = (DOMAIN_BLOCK *)((void *)0);
#line 1357
  domain->code = (CODE *)((void *)0);
  }
#line 1358
  return (domain);
}
}
#line 1367 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
DOMAIN_BLOCK *_glp_mpl_create_block(MPL *mpl ) 
{ 
  DOMAIN_BLOCK *block ;
  void *tmp ;

  {
  {
#line 1369
  tmp = _glp_dmp_get_atom(mpl->pool, (int )sizeof(DOMAIN_BLOCK ));
#line 1369
  block = (DOMAIN_BLOCK *)tmp;
#line 1370
  block->list = (DOMAIN_SLOT *)((void *)0);
#line 1371
  block->code = (CODE *)((void *)0);
#line 1372
  block->backup = (TUPLE *)((void *)0);
#line 1373
  block->next = (DOMAIN_BLOCK *)((void *)0);
  }
#line 1374
  return (block);
}
}
#line 1383 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_append_block(MPL *mpl , DOMAIN1 *domain , DOMAIN_BLOCK *block ) 
{ 
  DOMAIN_BLOCK *temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1385
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 1385
    tmp = 1;
  } else {
    {
#line 1385
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1385);
#line 1385
    tmp = 1;
    }
  }
#line 1386
  if ((unsigned long )domain != (unsigned long )((void *)0)) {
#line 1386
    tmp___0 = 1;
  } else {
    {
#line 1386
    _glp_lib_xassert("domain != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1386);
#line 1386
    tmp___0 = 1;
    }
  }
#line 1387
  if ((unsigned long )block != (unsigned long )((void *)0)) {
#line 1387
    tmp___1 = 1;
  } else {
    {
#line 1387
    _glp_lib_xassert("block != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1387);
#line 1387
    tmp___1 = 1;
    }
  }
#line 1388
  if ((unsigned long )block->next == (unsigned long )((void *)0)) {
#line 1388
    tmp___2 = 1;
  } else {
    {
#line 1388
    _glp_lib_xassert("block->next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1388);
#line 1388
    tmp___2 = 1;
    }
  }
#line 1389
  if ((unsigned long )domain->list == (unsigned long )((void *)0)) {
#line 1390
    domain->list = block;
  } else {
#line 1392
    temp = domain->list;
    {
#line 1392
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1392
      if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 1392
        goto while_break;
      }
#line 1392
      temp = temp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1394
    temp->next = block;
  }
#line 1396
  return;
}
}
#line 1413 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
DOMAIN_SLOT *_glp_mpl_append_slot(MPL *mpl , DOMAIN_BLOCK *block , char *name , CODE *code ) 
{ 
  DOMAIN_SLOT *slot ;
  DOMAIN_SLOT *temp ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1416
  if ((unsigned long )block != (unsigned long )((void *)0)) {
#line 1416
    tmp = 1;
  } else {
    {
#line 1416
    _glp_lib_xassert("block != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1416);
#line 1416
    tmp = 1;
    }
  }
  {
#line 1417
  tmp___0 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(DOMAIN_SLOT ));
#line 1417
  slot = (DOMAIN_SLOT *)tmp___0;
#line 1418
  slot->name = name;
#line 1419
  slot->code = code;
#line 1420
  slot->value = (SYMBOL *)((void *)0);
#line 1421
  slot->list = (CODE *)((void *)0);
#line 1422
  slot->next = (DOMAIN_SLOT *)((void *)0);
  }
#line 1423
  if ((unsigned long )block->list == (unsigned long )((void *)0)) {
#line 1424
    block->list = slot;
  } else {
#line 1426
    temp = block->list;
    {
#line 1426
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1426
      if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 1426
        goto while_break;
      }
#line 1426
      temp = temp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1428
    temp->next = slot;
  }
#line 1430
  return (slot);
}
}
#line 1461 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_list(MPL *mpl ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  struct __anonstruct_list_39 list[21] ;
  int flag_x ;
  int next_token ;
  int dim ;
  int j ;
  int slice ;
  int tmp ;
  AVLNODE *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1465
  slice = 0;
#line 1466
  if (mpl->token == 244) {
#line 1466
    tmp = 1;
  } else {
    {
#line 1466
    _glp_lib_xassert("mpl->token == T_LEFT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1466);
#line 1466
    tmp = 1;
    }
  }
  {
#line 1470
  flag_x = mpl->flag_x;
#line 1471
  _glp_mpl_get_token(mpl);
#line 1473
  dim = 1;
  }
  {
#line 1473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1474
    if (dim > 20) {
      {
#line 1475
      _glp_mpl_error(mpl, (char *)"too many components within parentheses");
      }
    }
#line 1478
    if (mpl->token == 202) {
      {
#line 1483
      _glp_mpl_get_token(mpl);
#line 1484
      next_token = mpl->token;
#line 1485
      _glp_mpl_unget_token(mpl);
      }
#line 1486
      if (flag_x) {
#line 1486
        if (next_token == 239) {
#line 1486
          goto _L;
        } else
#line 1486
        if (next_token == 245) {
          _L: /* CIL Label */ 
          {
#line 1486
          tmp___0 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
          }
#line 1486
          if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 1490
            goto expr;
          }
        } else {
#line 1490
          goto expr;
        }
      } else {
#line 1490
        goto expr;
      }
#line 1494
      j = 1;
      {
#line 1494
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1494
        if (! (j < dim)) {
#line 1494
          goto while_break___0;
        }
#line 1495
        if ((unsigned long )list[j].name != (unsigned long )((void *)0)) {
          {
#line 1495
          tmp___1 = strcmp((char const   *)list[j].name, (char const   *)mpl->image);
          }
#line 1495
          if (tmp___1 == 0) {
            {
#line 1497
            _glp_mpl_error(mpl, (char *)"duplicate dummy index %s not allowed", mpl->image);
            }
          }
        }
#line 1494
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1501
      tmp___2 = strlen((char const   *)mpl->image);
#line 1501
      tmp___3 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___2 + 1U));
#line 1501
      list[dim].name = (char *)tmp___3;
#line 1503
      strcpy((char */* __restrict  */)list[dim].name, (char const   */* __restrict  */)mpl->image);
#line 1504
      list[dim].code = (CODE *)((void *)0);
#line 1505
      _glp_mpl_get_token(mpl);
#line 1508
      slice = 1;
      }
#line 1512
      if (dim == 1) {
#line 1512
        if (mpl->token == 245) {
          {
#line 1513
          _glp_mpl_error(mpl, (char *)"%s not defined", list[dim].name);
          }
        }
      }
    } else {
      expr: 
      {
#line 1517
      code = _glp_mpl_expression_13(mpl);
      }
#line 1522
      if (mpl->token == 239) {
#line 1522
        goto _L___0;
      } else
#line 1522
      if (dim > 1) {
        _L___0: /* CIL Label */ 
#line 1523
        if (code->type == 118) {
          {
#line 1524
          code = _glp_mpl_make_unary(mpl, 316, code, 124, 0);
          }
        }
#line 1526
        if (code->type != 124) {
          {
#line 1527
          _glp_mpl_error(mpl, (char *)"component expression has invalid type");
          }
        }
#line 1528
        if (code->dim == 0) {
#line 1528
          tmp___4 = 1;
        } else {
          {
#line 1528
          _glp_lib_xassert("code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           1528);
#line 1528
          tmp___4 = 1;
          }
        }
      }
#line 1530
      list[dim].name = (char *)((void *)0);
#line 1531
      list[dim].code = code;
    }
#line 1534
    if (mpl->token == 239) {
      {
#line 1535
      _glp_mpl_get_token(mpl);
      }
    } else
#line 1536
    if (mpl->token == 245) {
#line 1537
      goto while_break;
    } else {
      {
#line 1539
      _glp_mpl_error(mpl, (char *)"right parenthesis missing where expected");
      }
    }
#line 1473
    dim ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1542
  if (dim == 1) {
#line 1542
    if (! slice) {
#line 1544
      code = list[1].code;
    } else {
#line 1542
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1546
  if (! slice) {
    {
#line 1548
    arg.list = _glp_mpl_create_arg_list(mpl);
#line 1549
    j = 1;
    }
    {
#line 1549
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1549
      if (! (j <= dim)) {
#line 1549
        goto while_break___1;
      }
      {
#line 1550
      arg.list = _glp_mpl_expand_arg_list(mpl, arg.list, list[j].code);
#line 1549
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1551
    code = _glp_mpl_make_code(mpl, 308, & arg, 126, dim);
    }
  } else {
    {
#line 1555
    arg.slice = _glp_mpl_create_block(mpl);
#line 1556
    j = 1;
    }
    {
#line 1556
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1556
      if (! (j <= dim)) {
#line 1556
        goto while_break___2;
      }
      {
#line 1557
      _glp_mpl_append_slot(mpl, arg.slice, list[j].name, list[j].code);
#line 1556
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1560
    code = _glp_mpl_make_code(mpl, 310, & arg, 126, dim);
    }
  }
  {
#line 1562
  _glp_mpl_get_token(mpl);
  }
#line 1565
  if (slice) {
#line 1565
    if (mpl->token != 213) {
      {
#line 1566
      _glp_mpl_error(mpl, (char *)"keyword in missing where expected");
      }
    }
  }
#line 1569
  if (flag_x) {
#line 1569
    if (mpl->token == 213) {
#line 1569
      if (! slice) {
#line 1570
        if (dim == 1) {
          {
#line 1571
          _glp_mpl_error(mpl, (char *)"syntax error in indexing expression");
          }
        } else {
          {
#line 1573
          _glp_mpl_error(mpl, (char *)"0-ary slice not allowed");
          }
        }
      }
    }
  }
#line 1575
  return (code);
}
}
#line 1592 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_literal_set(MPL *mpl , CODE *code ) 
{ 
  OPERANDS arg ;
  int j ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1595
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 1595
    tmp = 1;
  } else {
    {
#line 1595
    _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1595);
#line 1595
    tmp = 1;
    }
  }
  {
#line 1596
  arg.list = _glp_mpl_create_arg_list(mpl);
#line 1598
  j = 1;
  }
  {
#line 1598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1601
    if (code->type == 118) {
      {
#line 1602
      code = _glp_mpl_make_unary(mpl, 316, code, 124, 0);
      }
    }
#line 1603
    if (code->type == 124) {
      {
#line 1604
      code = _glp_mpl_make_unary(mpl, 318, code, 126, 1);
      }
    }
#line 1606
    if (code->type != 126) {
      {
#line 1607
      _glp_mpl_error(mpl, (char *)"member expression has invalid type");
      }
    }
#line 1609
    if ((unsigned long )arg.list != (unsigned long )((void *)0)) {
#line 1609
      if (((arg.list)->x)->dim != code->dim) {
#line 1610
        if (code->dim == 1) {
#line 1610
          tmp___0 = "";
        } else {
#line 1610
          tmp___0 = "s";
        }
#line 1610
        if (((arg.list)->x)->dim == 1) {
#line 1610
          tmp___1 = "";
        } else {
#line 1610
          tmp___1 = "s";
        }
        {
#line 1610
        _glp_mpl_error(mpl, (char *)"member %d has %d component%s while member %d has %d component%s",
                       j - 1, ((arg.list)->x)->dim, tmp___1, j, code->dim, tmp___0);
        }
      }
    }
    {
#line 1615
    arg.list = _glp_mpl_expand_arg_list(mpl, arg.list, code);
    }
#line 1617
    if (mpl->token == 239) {
      {
#line 1618
      _glp_mpl_get_token(mpl);
      }
    } else
#line 1619
    if (mpl->token == 249) {
#line 1620
      goto while_break;
    } else {
      {
#line 1622
      _glp_mpl_error(mpl, (char *)"syntax error in literal set");
      }
    }
    {
#line 1624
    code = _glp_mpl_expression_5(mpl);
#line 1598
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1627
  code = _glp_mpl_make_code(mpl, 309, & arg, 106, ((arg.list)->x)->dim);
  }
#line 1628
  return (code);
}
}
#line 1653 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
DOMAIN1 *_glp_mpl_indexing_expression(MPL *mpl ) 
{ 
  DOMAIN1 *domain ;
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;
  CODE *code ;
  int tmp ;
  int next_token ;
  char *name ;
  AVLNODE *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int j ;
  int dim ;
  char const   *tmp___8 ;
  int tmp___9 ;
  AVLNODE *node ;
  AVLNODE *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 1658
  if (mpl->token == 248) {
#line 1658
    tmp = 1;
  } else {
    {
#line 1658
    _glp_lib_xassert("mpl->token == T_LBRACE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1658);
#line 1658
    tmp = 1;
    }
  }
  {
#line 1659
  _glp_mpl_get_token(mpl);
  }
#line 1660
  if (mpl->token == 249) {
    {
#line 1661
    _glp_mpl_error(mpl, (char *)"empty indexing expression not allowed");
    }
  }
  {
#line 1663
  domain = _glp_mpl_create_domain(mpl);
  }
  {
#line 1666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1668
    block = (DOMAIN_BLOCK *)((void *)0);
#line 1670
    code = (CODE *)((void *)0);
#line 1672
    if (mpl->token == 202) {
      {
#line 1678
      _glp_mpl_get_token(mpl);
#line 1679
      next_token = mpl->token;
#line 1680
      _glp_mpl_unget_token(mpl);
      }
#line 1681
      if (next_token == 213) {
        {
#line 1681
        tmp___0 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
        }
#line 1681
        if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
#line 1686
          goto expr;
        }
      } else {
#line 1686
        goto expr;
      }
      {
#line 1690
      block = _glp_mpl_create_block(mpl);
#line 1691
      tmp___1 = strlen((char const   *)mpl->image);
#line 1691
      tmp___2 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___1 + 1U));
#line 1691
      name = (char *)tmp___2;
#line 1692
      strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)mpl->image);
#line 1693
      _glp_mpl_append_slot(mpl, block, name, (CODE *)((void *)0));
#line 1694
      _glp_mpl_get_token(mpl);
      }
#line 1696
      if (mpl->token == 213) {
#line 1696
        tmp___3 = 1;
      } else {
        {
#line 1696
        _glp_lib_xassert("mpl->token == T_IN", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         1696);
#line 1696
        tmp___3 = 1;
        }
      }
      {
#line 1697
      _glp_mpl_get_token(mpl);
      }
    } else
#line 1701
    if (mpl->token == 244) {
      {
#line 1705
      mpl->flag_x = 1;
#line 1706
      code = _glp_mpl_expression_9(mpl);
      }
#line 1707
      if (code->op != 310) {
#line 1710
        goto expr;
      }
#line 1714
      block = code->arg.slice;
#line 1715
      code = (CODE *)((void *)0);
#line 1718
      if (mpl->token == 213) {
#line 1718
        tmp___4 = 1;
      } else {
        {
#line 1718
        _glp_lib_xassert("mpl->token == T_IN", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         1718);
#line 1718
        tmp___4 = 1;
        }
      }
      {
#line 1719
      _glp_mpl_get_token(mpl);
      }
    }
    expr: 
#line 1728
    if ((unsigned long )code == (unsigned long )((void *)0)) {
      {
#line 1728
      code = _glp_mpl_expression_9(mpl);
      }
    }
#line 1730
    if (code->type != 106) {
#line 1735
      if ((unsigned long )block != (unsigned long )((void *)0)) {
        {
#line 1736
        _glp_mpl_error(mpl, (char *)"domain expression has invalid type");
        }
      }
      {
#line 1741
      code = _glp_mpl_literal_set(mpl, code);
      }
    }
#line 1744
    if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 1744
      tmp___5 = 1;
    } else {
      {
#line 1744
      _glp_lib_xassert("code != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       1744);
#line 1744
      tmp___5 = 1;
      }
    }
#line 1745
    if (code->type == 106) {
#line 1745
      tmp___6 = 1;
    } else {
      {
#line 1745
      _glp_lib_xassert("code->type == A_ELEMSET", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       1745);
#line 1745
      tmp___6 = 1;
      }
    }
#line 1746
    if (code->dim > 0) {
#line 1746
      tmp___7 = 1;
    } else {
      {
#line 1746
      _glp_lib_xassert("code->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       1746);
#line 1746
      tmp___7 = 1;
      }
    }
#line 1750
    if ((unsigned long )block == (unsigned long )((void *)0)) {
      {
#line 1752
      block = _glp_mpl_create_block(mpl);
#line 1753
      j = 1;
      }
      {
#line 1753
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1753
        if (! (j <= code->dim)) {
#line 1753
          goto while_break___0;
        }
        {
#line 1754
        _glp_mpl_append_slot(mpl, block, (char *)((void *)0), (CODE *)((void *)0));
#line 1753
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1758
    dim = 0;
#line 1759
    slot = block->list;
    {
#line 1759
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1759
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1759
        goto while_break___1;
      }
#line 1760
      dim ++;
#line 1759
      slot = slot->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1761
    if (dim != code->dim) {
#line 1762
      if (dim == 1) {
#line 1762
        tmp___8 = "index";
      } else {
#line 1762
        tmp___8 = "indices";
      }
      {
#line 1762
      _glp_mpl_error(mpl, (char *)"%d %s specified for set of dimension %d", dim,
                     tmp___8, code->dim);
      }
    }
#line 1766
    if ((unsigned long )block->code == (unsigned long )((void *)0)) {
#line 1766
      tmp___9 = 1;
    } else {
      {
#line 1766
      _glp_lib_xassert("block->code == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       1766);
#line 1766
      tmp___9 = 1;
      }
    }
    {
#line 1767
    block->code = code;
#line 1769
    _glp_mpl_append_block(mpl, domain, block);
#line 1775
    slot = block->list;
    }
    {
#line 1775
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1775
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1775
        goto while_break___2;
      }
#line 1776
      if ((unsigned long )slot->name != (unsigned long )((void *)0)) {
        {
#line 1778
        tmp___10 = _glp_avl_find_node(mpl->tree, (void const   *)slot->name);
        }
#line 1778
        if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 1778
          tmp___11 = 1;
        } else {
          {
#line 1778
          _glp_lib_xassert("avl_find_node(mpl->tree, slot->name) == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           1778);
#line 1778
          tmp___11 = 1;
          }
        }
        {
#line 1779
        node = _glp_avl_insert_node(mpl->tree, (void const   *)slot->name);
#line 1780
        _glp_avl_set_node_type(node, 111);
#line 1781
        _glp_avl_set_node_link(node, (void *)slot);
        }
      }
#line 1775
      slot = slot->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1784
    if (mpl->token == 239) {
      {
#line 1785
      _glp_mpl_get_token(mpl);
      }
    } else
#line 1786
    if (mpl->token == 240) {
#line 1787
      goto while_break;
    } else
#line 1786
    if (mpl->token == 249) {
#line 1787
      goto while_break;
    } else {
      {
#line 1789
      _glp_mpl_error(mpl, (char *)"syntax error in indexing expression");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1792
  if (mpl->token == 240) {
    {
#line 1793
    _glp_mpl_get_token(mpl);
#line 1794
    code = _glp_mpl_expression_13(mpl);
    }
#line 1796
    if (code->type == 124) {
      {
#line 1797
      code = _glp_mpl_make_unary(mpl, 315, code, 118, 0);
      }
    }
#line 1798
    if (code->type == 118) {
      {
#line 1799
      code = _glp_mpl_make_unary(mpl, 317, code, 114, 0);
      }
    }
#line 1801
    if (code->type != 114) {
      {
#line 1802
      _glp_mpl_error(mpl, (char *)"expression following colon has invalid type");
      }
    }
#line 1803
    if (code->dim == 0) {
#line 1803
      tmp___12 = 1;
    } else {
      {
#line 1803
      _glp_lib_xassert("code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       1803);
#line 1803
      tmp___12 = 1;
      }
    }
#line 1804
    domain->code = code;
#line 1806
    if (mpl->token != 249) {
      {
#line 1807
      _glp_mpl_error(mpl, (char *)"syntax error in indexing expression");
      }
    }
  }
  {
#line 1809
  _glp_mpl_get_token(mpl);
  }
#line 1810
  return (domain);
}
}
#line 1820 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_close_scope(MPL *mpl , DOMAIN1 *domain ) 
{ 
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;
  AVLNODE *node ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1824
  if ((unsigned long )domain != (unsigned long )((void *)0)) {
#line 1824
    tmp = 1;
  } else {
    {
#line 1824
    _glp_lib_xassert("domain != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1824);
#line 1824
    tmp = 1;
    }
  }
#line 1826
  block = domain->list;
  {
#line 1826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1826
    if (! ((unsigned long )block != (unsigned long )((void *)0))) {
#line 1826
      goto while_break;
    }
#line 1827
    slot = block->list;
    {
#line 1827
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1827
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1827
        goto while_break___0;
      }
#line 1828
      if ((unsigned long )slot->name != (unsigned long )((void *)0)) {
        {
#line 1829
        node = _glp_avl_find_node(mpl->tree, (void const   *)slot->name);
        }
#line 1830
        if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 1830
          tmp___0 = 1;
        } else {
          {
#line 1830
          _glp_lib_xassert("node != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           1830);
#line 1830
          tmp___0 = 1;
          }
        }
        {
#line 1831
        tmp___1 = _glp_avl_get_node_type(node);
        }
#line 1831
        if (tmp___1 == 111) {
#line 1831
          tmp___2 = 1;
        } else {
          {
#line 1831
          _glp_lib_xassert("avl_get_node_type(node) == A_INDEX", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           1831);
#line 1831
          tmp___2 = 1;
          }
        }
        {
#line 1832
        _glp_avl_delete_node(mpl->tree, node);
        }
      }
#line 1827
      slot = slot->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1826
    block = block->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1836
  return;
}
}
#line 1858 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
static void link_up(CODE *code ) 
{ 
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1867
  block = (code->arg.loop.domain)->list;
  {
#line 1867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1867
    if (! ((unsigned long )block != (unsigned long )((void *)0))) {
#line 1867
      goto while_break;
    }
#line 1869
    slot = block->list;
    {
#line 1869
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1869
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1869
        goto while_break___0;
      }
#line 1870
      if ((unsigned long )slot->code != (unsigned long )((void *)0)) {
#line 1871
        if ((unsigned long )(slot->code)->up == (unsigned long )((void *)0)) {
#line 1871
          tmp = 1;
        } else {
          {
#line 1871
          _glp_lib_xassert("slot->code->up == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           1871);
#line 1871
          tmp = 1;
          }
        }
#line 1872
        (slot->code)->up = code;
      }
#line 1869
      slot = slot->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1867
    block = block->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1876
  return;
}
}
#line 1880 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_iterated_expression(MPL *mpl ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int op ;
  char opstr[8] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 1886
  if (mpl->token == 202) {
#line 1886
    tmp = 1;
  } else {
    {
#line 1886
    _glp_lib_xassert("mpl->token == T_NAME", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1886);
#line 1886
    tmp = 1;
    }
  }
  {
#line 1887
  tmp___6 = strcmp((char const   *)mpl->image, "sum");
  }
#line 1887
  if (tmp___6 == 0) {
#line 1888
    op = 376;
  } else {
    {
#line 1889
    tmp___5 = strcmp((char const   *)mpl->image, "prod");
    }
#line 1889
    if (tmp___5 == 0) {
#line 1890
      op = 377;
    } else {
      {
#line 1891
      tmp___4 = strcmp((char const   *)mpl->image, "min");
      }
#line 1891
      if (tmp___4 == 0) {
#line 1892
        op = 378;
      } else {
        {
#line 1893
        tmp___3 = strcmp((char const   *)mpl->image, "max");
        }
#line 1893
        if (tmp___3 == 0) {
#line 1894
          op = 379;
        } else {
          {
#line 1895
          tmp___2 = strcmp((char const   *)mpl->image, "forall");
          }
#line 1895
          if (tmp___2 == 0) {
#line 1896
            op = 380;
          } else {
            {
#line 1897
            tmp___1 = strcmp((char const   *)mpl->image, "exists");
            }
#line 1897
            if (tmp___1 == 0) {
#line 1898
              op = 381;
            } else {
              {
#line 1899
              tmp___0 = strcmp((char const   *)mpl->image, "setof");
              }
#line 1899
              if (tmp___0 == 0) {
#line 1900
                op = 382;
              } else {
                {
#line 1902
                _glp_mpl_error(mpl, (char *)"operator %s unknown", mpl->image);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1903
  strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 1904
  tmp___7 = strlen((char const   *)(opstr));
  }
#line 1904
  if ((unsigned long )tmp___7 < sizeof(opstr)) {
#line 1904
    tmp___8 = 1;
  } else {
    {
#line 1904
    _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1904);
#line 1904
    tmp___8 = 1;
    }
  }
  {
#line 1905
  _glp_mpl_get_token(mpl);
  }
#line 1907
  if (mpl->token == 248) {
#line 1907
    tmp___9 = 1;
  } else {
    {
#line 1907
    _glp_lib_xassert("mpl->token == T_LBRACE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1907);
#line 1907
    tmp___9 = 1;
    }
  }
  {
#line 1909
  arg.loop.domain = _glp_mpl_indexing_expression(mpl);
  }
  {
#line 1915
  if (op == 379) {
#line 1915
    goto case_379;
  }
#line 1915
  if (op == 378) {
#line 1915
    goto case_379;
  }
#line 1915
  if (op == 377) {
#line 1915
    goto case_379;
  }
#line 1915
  if (op == 376) {
#line 1915
    goto case_379;
  }
#line 1932
  if (op == 381) {
#line 1932
    goto case_381;
  }
#line 1932
  if (op == 380) {
#line 1932
    goto case_381;
  }
#line 1947
  if (op == 382) {
#line 1947
    goto case_382;
  }
#line 1962
  goto switch_default;
  case_379: /* CIL Label */ 
  case_378: /* CIL Label */ 
  case_377: /* CIL Label */ 
  case_376: /* CIL Label */ 
  {
#line 1916
  arg.loop.x = _glp_mpl_expression_3(mpl);
  }
#line 1918
  if ((arg.loop.x)->type == 124) {
    {
#line 1919
    arg.loop.x = _glp_mpl_make_unary(mpl, 315, arg.loop.x, 118, 0);
    }
  }
#line 1923
  if (! ((arg.loop.x)->type == 118)) {
#line 1923
    if (op == 376) {
#line 1923
      if (! ((arg.loop.x)->type == 110)) {
#line 1923
        goto err;
      }
    } else {
      err: 
      {
#line 1925
      _glp_mpl_error(mpl, (char *)"integrand following %s{...} has invalid type",
                     opstr);
      }
    }
  }
#line 1927
  if ((arg.loop.x)->dim == 0) {
#line 1927
    tmp___10 = 1;
  } else {
    {
#line 1927
    _glp_lib_xassert("arg.loop.x->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1927);
#line 1927
    tmp___10 = 1;
    }
  }
  {
#line 1929
  code = _glp_mpl_make_code(mpl, op, & arg, (arg.loop.x)->type, 0);
  }
#line 1930
  goto switch_break;
  case_381: /* CIL Label */ 
  case_380: /* CIL Label */ 
  {
#line 1933
  arg.loop.x = _glp_mpl_expression_12(mpl);
  }
#line 1935
  if ((arg.loop.x)->type == 124) {
    {
#line 1936
    arg.loop.x = _glp_mpl_make_unary(mpl, 315, arg.loop.x, 118, 0);
    }
  }
#line 1938
  if ((arg.loop.x)->type == 118) {
    {
#line 1939
    arg.loop.x = _glp_mpl_make_unary(mpl, 317, arg.loop.x, 114, 0);
    }
  }
#line 1942
  if ((arg.loop.x)->type != 114) {
#line 1942
    goto err;
  }
#line 1943
  if ((arg.loop.x)->dim == 0) {
#line 1943
    tmp___11 = 1;
  } else {
    {
#line 1943
    _glp_lib_xassert("arg.loop.x->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1943);
#line 1943
    tmp___11 = 1;
    }
  }
  {
#line 1945
  code = _glp_mpl_make_code(mpl, op, & arg, 114, 0);
  }
#line 1946
  goto switch_break;
  case_382: /* CIL Label */ 
  {
#line 1948
  arg.loop.x = _glp_mpl_expression_5(mpl);
  }
#line 1950
  if ((arg.loop.x)->type == 118) {
    {
#line 1951
    arg.loop.x = _glp_mpl_make_unary(mpl, 316, arg.loop.x, 124, 0);
    }
  }
#line 1953
  if ((arg.loop.x)->type == 124) {
    {
#line 1954
    arg.loop.x = _glp_mpl_make_unary(mpl, 318, arg.loop.x, 126, 1);
    }
  }
#line 1957
  if ((arg.loop.x)->type != 126) {
#line 1957
    goto err;
  }
#line 1958
  if ((arg.loop.x)->dim > 0) {
#line 1958
    tmp___12 = 1;
  } else {
    {
#line 1958
    _glp_lib_xassert("arg.loop.x->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1958);
#line 1958
    tmp___12 = 1;
    }
  }
  {
#line 1960
  code = _glp_mpl_make_code(mpl, op, & arg, 106, (arg.loop.x)->dim);
  }
#line 1961
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1963
  if (op != op) {
#line 1963
    tmp___13 = 1;
  } else {
    {
#line 1963
    _glp_lib_xassert("op != op", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1963);
#line 1963
    tmp___13 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1966
  _glp_mpl_close_scope(mpl, arg.loop.domain);
#line 1968
  link_up(code);
  }
#line 1970
  return (code);
}
}
#line 1979 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
int _glp_mpl_domain_arity(MPL *mpl , DOMAIN1 *domain ) 
{ 
  DOMAIN_BLOCK *block ;
  DOMAIN_SLOT *slot ;
  int arity ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1983
  if ((unsigned long )mpl == (unsigned long )mpl) {
#line 1983
    tmp = 1;
  } else {
    {
#line 1983
    _glp_lib_xassert("mpl == mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     1983);
#line 1983
    tmp = 1;
    }
  }
#line 1984
  arity = 0;
#line 1985
  block = domain->list;
  {
#line 1985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1985
    if (! ((unsigned long )block != (unsigned long )((void *)0))) {
#line 1985
      goto while_break;
    }
#line 1986
    slot = block->list;
    {
#line 1986
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1986
      if (! ((unsigned long )slot != (unsigned long )((void *)0))) {
#line 1986
        goto while_break___0;
      }
#line 1987
      if ((unsigned long )slot->code == (unsigned long )((void *)0)) {
#line 1987
        arity ++;
      }
#line 1986
      slot = slot->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1985
    block = block->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1988
  return (arity);
}
}
#line 1999 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_set_expression(MPL *mpl ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 2002
  if (mpl->token == 248) {
#line 2002
    tmp = 1;
  } else {
    {
#line 2002
    _glp_lib_xassert("mpl->token == T_LBRACE", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     2002);
#line 2002
    tmp = 1;
    }
  }
  {
#line 2003
  _glp_mpl_get_token(mpl);
  }
#line 2005
  if (mpl->token == 249) {
    {
#line 2008
    arg.list = (ARG_LIST *)((void *)0);
#line 2010
    code = _glp_mpl_make_code(mpl, 309, & arg, 106, 1);
#line 2011
    _glp_mpl_get_token(mpl);
    }
  } else {
    {
#line 2015
    _glp_mpl_unget_token(mpl);
#line 2016
    arg.loop.domain = _glp_mpl_indexing_expression(mpl);
#line 2017
    arg.loop.x = (CODE *)((void *)0);
#line 2019
    _glp_mpl_close_scope(mpl, arg.loop.domain);
#line 2021
    tmp___0 = _glp_mpl_domain_arity(mpl, arg.loop.domain);
#line 2021
    code = _glp_mpl_make_code(mpl, 383, & arg, 106, tmp___0);
#line 2024
    link_up(code);
    }
  }
#line 2027
  return (code);
}
}
#line 2041 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_branched_expression(MPL *mpl ) 
{ 
  CODE *code ;
  CODE *x ;
  CODE *y ;
  CODE *z ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 2043
  if (mpl->token == 212) {
#line 2043
    tmp = 1;
  } else {
    {
#line 2043
    _glp_lib_xassert("mpl->token == T_IF", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     2043);
#line 2043
    tmp = 1;
    }
  }
  {
#line 2044
  _glp_mpl_get_token(mpl);
#line 2046
  x = _glp_mpl_expression_13(mpl);
  }
#line 2048
  if (x->type == 124) {
    {
#line 2049
    x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
    }
  }
#line 2050
  if (x->type == 118) {
    {
#line 2051
    x = _glp_mpl_make_unary(mpl, 317, x, 114, 0);
    }
  }
#line 2053
  if (x->type != 114) {
    {
#line 2054
    _glp_mpl_error(mpl, (char *)"expression following if has invalid type");
    }
  }
#line 2055
  if (x->dim == 0) {
#line 2055
    tmp___0 = 1;
  } else {
    {
#line 2055
    _glp_lib_xassert("x->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     2055);
#line 2055
    tmp___0 = 1;
    }
  }
#line 2057
  if (mpl->token != 222) {
    {
#line 2058
    _glp_mpl_error(mpl, (char *)"keyword then missing where expected");
    }
  }
  {
#line 2059
  _glp_mpl_get_token(mpl);
#line 2061
  y = _glp_mpl_expression_9(mpl);
  }
#line 2062
  if (! (y->type == 118)) {
#line 2062
    if (! (y->type == 124)) {
#line 2062
      if (! (y->type == 106)) {
#line 2062
        if (! (y->type == 110)) {
          {
#line 2064
          _glp_mpl_error(mpl, (char *)"expression following then has invalid type");
          }
        }
      }
    }
  }
#line 2068
  if (mpl->token != 211) {
#line 2069
    if (y->type == 106) {
      {
#line 2070
      _glp_mpl_error(mpl, (char *)"keyword else missing where expected");
      }
    }
#line 2071
    z = (CODE *)((void *)0);
#line 2072
    goto skip;
  }
  {
#line 2074
  _glp_mpl_get_token(mpl);
#line 2076
  z = _glp_mpl_expression_9(mpl);
  }
#line 2077
  if (! (z->type == 118)) {
#line 2077
    if (! (z->type == 124)) {
#line 2077
      if (! (z->type == 106)) {
#line 2077
        if (! (z->type == 110)) {
          {
#line 2079
          _glp_mpl_error(mpl, (char *)"expression following else has invalid type");
          }
        }
      }
    }
  }
#line 2081
  if (y->type == 110) {
#line 2081
    goto _L;
  } else
#line 2081
  if (z->type == 110) {
    _L: /* CIL Label */ 
#line 2082
    if (y->type == 124) {
      {
#line 2083
      y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
      }
    }
#line 2084
    if (y->type == 118) {
      {
#line 2085
      y = _glp_mpl_make_unary(mpl, 319, y, 110, 0);
      }
    }
#line 2086
    if (z->type == 124) {
      {
#line 2087
      z = _glp_mpl_make_unary(mpl, 315, z, 118, 0);
      }
    }
#line 2088
    if (z->type == 118) {
      {
#line 2089
      z = _glp_mpl_make_unary(mpl, 319, z, 110, 0);
      }
    }
  }
#line 2091
  if (y->type == 124) {
#line 2091
    goto _L___0;
  } else
#line 2091
  if (z->type == 124) {
    _L___0: /* CIL Label */ 
#line 2092
    if (y->type == 118) {
      {
#line 2093
      y = _glp_mpl_make_unary(mpl, 316, y, 124, 0);
      }
    }
#line 2094
    if (z->type == 118) {
      {
#line 2095
      z = _glp_mpl_make_unary(mpl, 316, z, 124, 0);
      }
    }
  }
#line 2098
  if (y->type != z->type) {
    {
#line 2099
    _glp_mpl_error(mpl, (char *)"expressions following then and else have incompatible types");
    }
  }
#line 2102
  if (y->dim != z->dim) {
    {
#line 2103
    _glp_mpl_error(mpl, (char *)"expressions following then and else have different dimensions %d and %d, respectively",
                   y->dim, z->dim);
    }
  }
  skip: 
  {
#line 2106
  code = _glp_mpl_make_ternary(mpl, 372, x, y, z, y->type, y->dim);
  }
#line 2107
  return (code);
}
}
#line 2135 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_primary_expression(MPL *mpl ) 
{ 
  CODE *code ;
  OPERANDS arg ;
  int next_token ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 2137
  if (mpl->token == 204) {
    {
#line 2139
    code = _glp_mpl_numeric_literal(mpl);
    }
  } else
#line 2142
  if (mpl->token == 214) {
    {
#line 2145
    arg.num = 1.7976931348623157e+308;
#line 2146
    code = _glp_mpl_make_code(mpl, 301, & arg, 118, 0);
#line 2147
    _glp_mpl_get_token(mpl);
    }
  } else
#line 2150
  if (mpl->token == 205) {
    {
#line 2152
    code = _glp_mpl_string_literal(mpl);
    }
  } else
#line 2154
  if (mpl->token == 202) {
    {
#line 2156
    _glp_mpl_get_token(mpl);
#line 2157
    next_token = mpl->token;
#line 2158
    _glp_mpl_unget_token(mpl);
    }
    {
#line 2161
    if (next_token == 246) {
#line 2161
      goto case_246;
    }
#line 2165
    if (next_token == 244) {
#line 2165
      goto case_244;
    }
#line 2169
    if (next_token == 248) {
#line 2169
      goto case_248;
    }
#line 2173
    goto switch_default;
    case_246: /* CIL Label */ 
    {
#line 2163
    code = _glp_mpl_object_reference(mpl);
    }
#line 2164
    goto switch_break;
    case_244: /* CIL Label */ 
    {
#line 2167
    code = _glp_mpl_function_reference(mpl);
    }
#line 2168
    goto switch_break;
    case_248: /* CIL Label */ 
    {
#line 2171
    code = _glp_mpl_iterated_expression(mpl);
    }
#line 2172
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2175
    code = _glp_mpl_object_reference(mpl);
    }
#line 2176
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 2179
  if (mpl->token == 244) {
    {
#line 2181
    code = _glp_mpl_expression_list(mpl);
    }
  } else
#line 2183
  if (mpl->token == 248) {
    {
#line 2185
    code = _glp_mpl_set_expression(mpl);
    }
  } else
#line 2187
  if (mpl->token == 212) {
    {
#line 2189
    code = _glp_mpl_branched_expression(mpl);
    }
  } else {
    {
#line 2191
    tmp = _glp_mpl_is_reserved(mpl);
    }
#line 2191
    if (tmp) {
      {
#line 2193
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
      {
#line 2196
      _glp_mpl_error(mpl, (char *)"syntax error in expression");
      }
    }
  }
#line 2197
  return (code);
}
}
#line 2206 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_error_preceding(MPL *mpl , char *opstr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 2207
  _glp_mpl_error(mpl, (char *)"operand preceding %s has invalid type", opstr);
  }
#line 2209
  return;
}
}
#line 2217 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_error_following(MPL *mpl , char *opstr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 2218
  _glp_mpl_error(mpl, (char *)"operand following %s has invalid type", opstr);
  }
#line 2220
  return;
}
}
#line 2228 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_error_dimension(MPL *mpl , char *opstr , int dim1 , int dim2 ) 
{ 
  char *__cil_tmp5 ;

  {
  {
#line 2229
  _glp_mpl_error(mpl, (char *)"operands preceding and following %s have different dimensions %d and %d, respectively",
                 opstr, dim1, dim2);
  }
#line 2232
  return;
}
}
#line 2241 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_0(MPL *mpl ) 
{ 
  CODE *code ;

  {
  {
#line 2243
  code = _glp_mpl_primary_expression(mpl);
  }
#line 2244
  return (code);
}
}
#line 2257 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_1(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char opstr[8] ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2260
  x = _glp_mpl_expression_0(mpl);
  }
#line 2261
  if (mpl->token == 229) {
    {
#line 2262
    strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 2263
    tmp = strlen((char const   *)(opstr));
    }
#line 2263
    if ((unsigned long )tmp < sizeof(opstr)) {
#line 2263
      tmp___0 = 1;
    } else {
      {
#line 2263
      _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       2263);
#line 2263
      tmp___0 = 1;
      }
    }
#line 2264
    if (x->type == 124) {
      {
#line 2265
      x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
      }
    }
#line 2266
    if (x->type != 118) {
      {
#line 2267
      _glp_mpl_error_preceding(mpl, opstr);
      }
    }
    {
#line 2268
    _glp_mpl_get_token(mpl);
    }
#line 2269
    if (mpl->token == 225) {
      {
#line 2270
      y = _glp_mpl_expression_2(mpl);
      }
    } else
#line 2269
    if (mpl->token == 226) {
      {
#line 2270
      y = _glp_mpl_expression_2(mpl);
      }
    } else {
      {
#line 2272
      y = _glp_mpl_expression_1(mpl);
      }
    }
#line 2273
    if (y->type == 124) {
      {
#line 2274
      y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
      }
    }
#line 2275
    if (y->type != 118) {
      {
#line 2276
      _glp_mpl_error_following(mpl, opstr);
      }
    }
    {
#line 2277
    x = _glp_mpl_make_binary(mpl, 344, x, y, 118, 0);
    }
  }
#line 2279
  return (x);
}
}
#line 2291 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_2(MPL *mpl ) 
{ 
  CODE *x ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2293
  if (mpl->token == 225) {
    {
#line 2294
    _glp_mpl_get_token(mpl);
#line 2295
    x = _glp_mpl_expression_1(mpl);
    }
#line 2296
    if (x->type == 124) {
      {
#line 2297
      x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
      }
    }
#line 2298
    if (! (x->type == 118)) {
#line 2298
      if (! (x->type == 110)) {
        {
#line 2299
        _glp_mpl_error_following(mpl, (char *)"+");
        }
      }
    }
    {
#line 2300
    x = _glp_mpl_make_unary(mpl, 320, x, x->type, 0);
    }
  } else
#line 2302
  if (mpl->token == 226) {
    {
#line 2303
    _glp_mpl_get_token(mpl);
#line 2304
    x = _glp_mpl_expression_1(mpl);
    }
#line 2305
    if (x->type == 124) {
      {
#line 2306
      x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
      }
    }
#line 2307
    if (! (x->type == 118)) {
#line 2307
      if (! (x->type == 110)) {
        {
#line 2308
        _glp_mpl_error_following(mpl, (char *)"-");
        }
      }
    }
    {
#line 2309
    x = _glp_mpl_make_unary(mpl, 321, x, x->type, 0);
    }
  } else {
    {
#line 2312
    x = _glp_mpl_expression_1(mpl);
    }
  }
#line 2313
  return (x);
}
}
#line 2327 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_3(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 2329
  x = _glp_mpl_expression_2(mpl);
  }
  {
#line 2330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2331
    if (mpl->token == 227) {
#line 2332
      if (x->type == 124) {
        {
#line 2333
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2334
      if (! (x->type == 118)) {
#line 2334
        if (! (x->type == 110)) {
          {
#line 2335
          _glp_mpl_error_preceding(mpl, (char *)"*");
          }
        }
      }
      {
#line 2336
      _glp_mpl_get_token(mpl);
#line 2337
      y = _glp_mpl_expression_2(mpl);
      }
#line 2338
      if (y->type == 124) {
        {
#line 2339
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2340
      if (! (y->type == 118)) {
#line 2340
        if (! (y->type == 110)) {
          {
#line 2341
          _glp_mpl_error_following(mpl, (char *)"*");
          }
        }
      }
#line 2342
      if (x->type == 110) {
#line 2342
        if (y->type == 110) {
          {
#line 2343
          _glp_mpl_error(mpl, (char *)"multiplication of linear forms not allowed");
          }
        }
      }
#line 2344
      if (x->type == 118) {
#line 2344
        if (y->type == 118) {
          {
#line 2345
          x = _glp_mpl_make_binary(mpl, 340, x, y, 118, 0);
          }
        } else {
          {
#line 2347
          x = _glp_mpl_make_binary(mpl, 340, x, y, 110, 0);
          }
        }
      } else {
        {
#line 2347
        x = _glp_mpl_make_binary(mpl, 340, x, y, 110, 0);
        }
      }
    } else
#line 2349
    if (mpl->token == 228) {
#line 2350
      if (x->type == 124) {
        {
#line 2351
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2352
      if (! (x->type == 118)) {
#line 2352
        if (! (x->type == 110)) {
          {
#line 2353
          _glp_mpl_error_preceding(mpl, (char *)"/");
          }
        }
      }
      {
#line 2354
      _glp_mpl_get_token(mpl);
#line 2355
      y = _glp_mpl_expression_2(mpl);
      }
#line 2356
      if (y->type == 124) {
        {
#line 2357
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2358
      if (y->type != 118) {
        {
#line 2359
        _glp_mpl_error_following(mpl, (char *)"/");
        }
      }
#line 2360
      if (x->type == 118) {
        {
#line 2361
        x = _glp_mpl_make_binary(mpl, 341, x, y, 118, 0);
        }
      } else {
        {
#line 2363
        x = _glp_mpl_make_binary(mpl, 341, x, y, 110, 0);
        }
      }
    } else
#line 2365
    if (mpl->token == 210) {
#line 2366
      if (x->type == 124) {
        {
#line 2367
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2368
      if (x->type != 118) {
        {
#line 2369
        _glp_mpl_error_preceding(mpl, (char *)"div");
        }
      }
      {
#line 2370
      _glp_mpl_get_token(mpl);
#line 2371
      y = _glp_mpl_expression_2(mpl);
      }
#line 2372
      if (y->type == 124) {
        {
#line 2373
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2374
      if (y->type != 118) {
        {
#line 2375
        _glp_mpl_error_following(mpl, (char *)"div");
        }
      }
      {
#line 2376
      x = _glp_mpl_make_binary(mpl, 342, x, y, 118, 0);
      }
    } else
#line 2378
    if (mpl->token == 217) {
#line 2379
      if (x->type == 124) {
        {
#line 2380
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2381
      if (x->type != 118) {
        {
#line 2382
        _glp_mpl_error_preceding(mpl, (char *)"mod");
        }
      }
      {
#line 2383
      _glp_mpl_get_token(mpl);
#line 2384
      y = _glp_mpl_expression_2(mpl);
      }
#line 2385
      if (y->type == 124) {
        {
#line 2386
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2387
      if (y->type != 118) {
        {
#line 2388
        _glp_mpl_error_following(mpl, (char *)"mod");
        }
      }
      {
#line 2389
      x = _glp_mpl_make_binary(mpl, 343, x, y, 118, 0);
      }
    } else {
#line 2392
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2394
  return (x);
}
}
#line 2407 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_4(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2409
  x = _glp_mpl_expression_3(mpl);
  }
  {
#line 2410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2411
    if (mpl->token == 225) {
#line 2412
      if (x->type == 124) {
        {
#line 2413
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2414
      if (! (x->type == 118)) {
#line 2414
        if (! (x->type == 110)) {
          {
#line 2415
          _glp_mpl_error_preceding(mpl, (char *)"+");
          }
        }
      }
      {
#line 2416
      _glp_mpl_get_token(mpl);
#line 2417
      y = _glp_mpl_expression_3(mpl);
      }
#line 2418
      if (y->type == 124) {
        {
#line 2419
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2420
      if (! (y->type == 118)) {
#line 2420
        if (! (y->type == 110)) {
          {
#line 2421
          _glp_mpl_error_following(mpl, (char *)"+");
          }
        }
      }
#line 2422
      if (x->type == 118) {
#line 2422
        if (y->type == 110) {
          {
#line 2423
          x = _glp_mpl_make_unary(mpl, 319, x, 110, 0);
          }
        }
      }
#line 2424
      if (x->type == 110) {
#line 2424
        if (y->type == 118) {
          {
#line 2425
          y = _glp_mpl_make_unary(mpl, 319, y, 110, 0);
          }
        }
      }
      {
#line 2426
      x = _glp_mpl_make_binary(mpl, 337, x, y, x->type, 0);
      }
    } else
#line 2428
    if (mpl->token == 226) {
#line 2429
      if (x->type == 124) {
        {
#line 2430
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2431
      if (! (x->type == 118)) {
#line 2431
        if (! (x->type == 110)) {
          {
#line 2432
          _glp_mpl_error_preceding(mpl, (char *)"-");
          }
        }
      }
      {
#line 2433
      _glp_mpl_get_token(mpl);
#line 2434
      y = _glp_mpl_expression_3(mpl);
      }
#line 2435
      if (y->type == 124) {
        {
#line 2436
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2437
      if (! (y->type == 118)) {
#line 2437
        if (! (y->type == 110)) {
          {
#line 2438
          _glp_mpl_error_following(mpl, (char *)"-");
          }
        }
      }
#line 2439
      if (x->type == 118) {
#line 2439
        if (y->type == 110) {
          {
#line 2440
          x = _glp_mpl_make_unary(mpl, 319, x, 110, 0);
          }
        }
      }
#line 2441
      if (x->type == 110) {
#line 2441
        if (y->type == 118) {
          {
#line 2442
          y = _glp_mpl_make_unary(mpl, 319, y, 110, 0);
          }
        }
      }
      {
#line 2443
      x = _glp_mpl_make_binary(mpl, 338, x, y, x->type, 0);
      }
    } else
#line 2445
    if (mpl->token == 216) {
#line 2446
      if (x->type == 124) {
        {
#line 2447
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2448
      if (x->type != 118) {
        {
#line 2449
        _glp_mpl_error_preceding(mpl, (char *)"less");
        }
      }
      {
#line 2450
      _glp_mpl_get_token(mpl);
#line 2451
      y = _glp_mpl_expression_3(mpl);
      }
#line 2452
      if (y->type == 124) {
        {
#line 2453
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2454
      if (y->type != 118) {
        {
#line 2455
        _glp_mpl_error_following(mpl, (char *)"less");
        }
      }
      {
#line 2456
      x = _glp_mpl_make_binary(mpl, 339, x, y, 118, 0);
      }
    } else {
#line 2459
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2461
  return (x);
}
}
#line 2472 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_5(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2474
  x = _glp_mpl_expression_4(mpl);
  }
  {
#line 2475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2476
    if (mpl->token == 236) {
#line 2477
      if (x->type == 118) {
        {
#line 2478
        x = _glp_mpl_make_unary(mpl, 316, x, 124, 0);
        }
      }
#line 2479
      if (x->type != 124) {
        {
#line 2480
        _glp_mpl_error_preceding(mpl, (char *)"&");
        }
      }
      {
#line 2481
      _glp_mpl_get_token(mpl);
#line 2482
      y = _glp_mpl_expression_4(mpl);
      }
#line 2483
      if (y->type == 118) {
        {
#line 2484
        y = _glp_mpl_make_unary(mpl, 316, y, 124, 0);
        }
      }
#line 2485
      if (y->type != 124) {
        {
#line 2486
        _glp_mpl_error_following(mpl, (char *)"&");
        }
      }
      {
#line 2487
      x = _glp_mpl_make_binary(mpl, 350, x, y, 124, 0);
      }
    } else {
#line 2490
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2492
  return (x);
}
}
#line 2505 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_6(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  CODE *z ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 2507
  x = _glp_mpl_expression_5(mpl);
  }
#line 2508
  if (mpl->token == 243) {
#line 2509
    if (x->type == 124) {
      {
#line 2510
      x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
      }
    }
#line 2511
    if (x->type != 118) {
      {
#line 2512
      _glp_mpl_error_preceding(mpl, (char *)"..");
      }
    }
    {
#line 2513
    _glp_mpl_get_token(mpl);
#line 2514
    y = _glp_mpl_expression_5(mpl);
    }
#line 2515
    if (y->type == 124) {
      {
#line 2516
      y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
      }
    }
#line 2517
    if (y->type != 118) {
      {
#line 2518
      _glp_mpl_error_following(mpl, (char *)"..");
      }
    }
#line 2519
    if (mpl->token == 207) {
      {
#line 2520
      _glp_mpl_get_token(mpl);
#line 2521
      z = _glp_mpl_expression_5(mpl);
      }
#line 2522
      if (z->type == 124) {
        {
#line 2523
        z = _glp_mpl_make_unary(mpl, 315, z, 118, 0);
        }
      }
#line 2524
      if (z->type != 118) {
        {
#line 2525
        _glp_mpl_error_following(mpl, (char *)"by");
        }
      }
    } else {
#line 2528
      z = (CODE *)((void *)0);
    }
    {
#line 2529
    x = _glp_mpl_make_ternary(mpl, 371, x, y, z, 106, 1);
    }
  }
#line 2531
  return (x);
}
}
#line 2542 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_7(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2544
  x = _glp_mpl_expression_6(mpl);
  }
  {
#line 2545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2546
    if (mpl->token == 208) {
#line 2547
      if (x->type != 106) {
        {
#line 2548
        _glp_mpl_error_preceding(mpl, (char *)"cross");
        }
      }
      {
#line 2549
      _glp_mpl_get_token(mpl);
#line 2550
      y = _glp_mpl_expression_6(mpl);
      }
#line 2551
      if (y->type != 106) {
        {
#line 2552
        _glp_mpl_error_following(mpl, (char *)"cross");
        }
      }
      {
#line 2553
      x = _glp_mpl_make_binary(mpl, 363, x, y, 106, x->dim + y->dim);
      }
    } else {
#line 2557
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2559
  return (x);
}
}
#line 2570 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_8(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 2572
  x = _glp_mpl_expression_7(mpl);
  }
  {
#line 2573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2574
    if (mpl->token == 215) {
#line 2575
      if (x->type != 106) {
        {
#line 2576
        _glp_mpl_error_preceding(mpl, (char *)"inter");
        }
      }
      {
#line 2577
      _glp_mpl_get_token(mpl);
#line 2578
      y = _glp_mpl_expression_7(mpl);
      }
#line 2579
      if (y->type != 106) {
        {
#line 2580
        _glp_mpl_error_following(mpl, (char *)"inter");
        }
      }
#line 2581
      if (x->dim != y->dim) {
        {
#line 2582
        _glp_mpl_error_dimension(mpl, (char *)"inter", x->dim, y->dim);
        }
      }
      {
#line 2583
      x = _glp_mpl_make_binary(mpl, 362, x, y, 106, x->dim);
      }
    } else {
#line 2586
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2588
  return (x);
}
}
#line 2601 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_9(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 2603
  x = _glp_mpl_expression_8(mpl);
  }
  {
#line 2604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2605
    if (mpl->token == 223) {
#line 2606
      if (x->type != 106) {
        {
#line 2607
        _glp_mpl_error_preceding(mpl, (char *)"union");
        }
      }
      {
#line 2608
      _glp_mpl_get_token(mpl);
#line 2609
      y = _glp_mpl_expression_8(mpl);
      }
#line 2610
      if (y->type != 106) {
        {
#line 2611
        _glp_mpl_error_following(mpl, (char *)"union");
        }
      }
#line 2612
      if (x->dim != y->dim) {
        {
#line 2613
        _glp_mpl_error_dimension(mpl, (char *)"union", x->dim, y->dim);
        }
      }
      {
#line 2614
      x = _glp_mpl_make_binary(mpl, 359, x, y, 106, x->dim);
      }
    } else
#line 2616
    if (mpl->token == 209) {
#line 2617
      if (x->type != 106) {
        {
#line 2618
        _glp_mpl_error_preceding(mpl, (char *)"diff");
        }
      }
      {
#line 2619
      _glp_mpl_get_token(mpl);
#line 2620
      y = _glp_mpl_expression_8(mpl);
      }
#line 2621
      if (y->type != 106) {
        {
#line 2622
        _glp_mpl_error_following(mpl, (char *)"diff");
        }
      }
#line 2623
      if (x->dim != y->dim) {
        {
#line 2624
        _glp_mpl_error_dimension(mpl, (char *)"diff", x->dim, y->dim);
        }
      }
      {
#line 2625
      x = _glp_mpl_make_binary(mpl, 360, x, y, 106, x->dim);
      }
    } else
#line 2627
    if (mpl->token == 221) {
#line 2628
      if (x->type != 106) {
        {
#line 2629
        _glp_mpl_error_preceding(mpl, (char *)"symdiff");
        }
      }
      {
#line 2630
      _glp_mpl_get_token(mpl);
#line 2631
      y = _glp_mpl_expression_8(mpl);
      }
#line 2632
      if (y->type != 106) {
        {
#line 2633
        _glp_mpl_error_following(mpl, (char *)"symdiff");
        }
      }
#line 2634
      if (x->dim != y->dim) {
        {
#line 2635
        _glp_mpl_error_dimension(mpl, (char *)"symdiff", x->dim, y->dim);
        }
      }
      {
#line 2636
      x = _glp_mpl_make_binary(mpl, 361, x, y, 106, x->dim);
      }
    } else {
#line 2639
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2641
  return (x);
}
}
#line 2654 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_10(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  int op ;
  char opstr[16] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 2656
  op = -1;
#line 2658
  x = _glp_mpl_expression_9(mpl);
#line 2659
  strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)"");
  }
  {
#line 2661
  if (mpl->token == 230) {
#line 2661
    goto case_230;
  }
#line 2663
  if (mpl->token == 231) {
#line 2663
    goto case_231;
  }
#line 2665
  if (mpl->token == 232) {
#line 2665
    goto case_232;
  }
#line 2667
  if (mpl->token == 233) {
#line 2667
    goto case_233;
  }
#line 2669
  if (mpl->token == 234) {
#line 2669
    goto case_234;
  }
#line 2671
  if (mpl->token == 235) {
#line 2671
    goto case_235;
  }
#line 2673
  if (mpl->token == 213) {
#line 2673
    goto case_213;
  }
#line 2675
  if (mpl->token == 224) {
#line 2675
    goto case_224;
  }
#line 2677
  if (mpl->token == 218) {
#line 2677
    goto case_218;
  }
#line 2688
  goto switch_default;
  case_230: /* CIL Label */ 
#line 2662
  op = 351;
#line 2662
  goto switch_break;
  case_231: /* CIL Label */ 
#line 2664
  op = 352;
#line 2664
  goto switch_break;
  case_232: /* CIL Label */ 
#line 2666
  op = 353;
#line 2666
  goto switch_break;
  case_233: /* CIL Label */ 
#line 2668
  op = 354;
#line 2668
  goto switch_break;
  case_234: /* CIL Label */ 
#line 2670
  op = 355;
#line 2670
  goto switch_break;
  case_235: /* CIL Label */ 
#line 2672
  op = 356;
#line 2672
  goto switch_break;
  case_213: /* CIL Label */ 
#line 2674
  op = 364;
#line 2674
  goto switch_break;
  case_224: /* CIL Label */ 
#line 2676
  op = 366;
#line 2676
  goto switch_break;
  case_218: /* CIL Label */ 
  {
#line 2678
  strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 2679
  _glp_mpl_get_token(mpl);
  }
#line 2680
  if (mpl->token == 213) {
#line 2681
    op = 365;
  } else
#line 2682
  if (mpl->token == 224) {
#line 2683
    op = 367;
  } else {
    {
#line 2685
    _glp_mpl_error(mpl, (char *)"invalid use of %s", opstr);
    }
  }
  {
#line 2686
  strcat((char */* __restrict  */)(opstr), (char const   */* __restrict  */)" ");
  }
#line 2687
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2689
  goto done;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2691
  strcat((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 2692
  tmp = strlen((char const   *)(opstr));
  }
#line 2692
  if ((unsigned long )tmp < sizeof(opstr)) {
#line 2692
    tmp___0 = 1;
  } else {
    {
#line 2692
    _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     2692);
#line 2692
    tmp___0 = 1;
    }
  }
  {
#line 2700
  if (op == 354) {
#line 2700
    goto case_354;
  }
#line 2700
  if (op == 355) {
#line 2700
    goto case_354;
  }
#line 2700
  if (op == 352) {
#line 2700
    goto case_354;
  }
#line 2700
  if (op == 351) {
#line 2700
    goto case_354;
  }
#line 2700
  if (op == 356) {
#line 2700
    goto case_354;
  }
#line 2700
  if (op == 353) {
#line 2700
    goto case_354;
  }
#line 2733
  if (op == 365) {
#line 2733
    goto case_365;
  }
#line 2733
  if (op == 364) {
#line 2733
    goto case_365;
  }
#line 2749
  if (op == 367) {
#line 2749
    goto case_367;
  }
#line 2749
  if (op == 366) {
#line 2749
    goto case_367;
  }
#line 2760
  goto switch_default___0;
  case_354: /* CIL Label */ 
  case_355: /* CIL Label */ 
  case_352: /* CIL Label */ 
  case_351: /* CIL Label */ 
  case_356: /* CIL Label */ 
  case_353: /* CIL Label */ 
#line 2702
  if (! (x->type == 118)) {
#line 2702
    if (! (x->type == 124)) {
      {
#line 2703
      _glp_mpl_error_preceding(mpl, opstr);
      }
    }
  }
  {
#line 2704
  _glp_mpl_get_token(mpl);
#line 2705
  y = _glp_mpl_expression_9(mpl);
  }
#line 2706
  if (! (y->type == 118)) {
#line 2706
    if (! (y->type == 124)) {
      {
#line 2707
      _glp_mpl_error_following(mpl, opstr);
      }
    }
  }
#line 2708
  if (x->type == 118) {
#line 2708
    if (y->type == 124) {
      {
#line 2709
      x = _glp_mpl_make_unary(mpl, 316, x, 124, 0);
      }
    }
  }
#line 2710
  if (x->type == 124) {
#line 2710
    if (y->type == 118) {
      {
#line 2711
      y = _glp_mpl_make_unary(mpl, 316, y, 124, 0);
      }
    }
  }
  {
#line 2712
  x = _glp_mpl_make_binary(mpl, op, x, y, 114, 0);
  }
#line 2713
  goto switch_break___0;
  case_365: /* CIL Label */ 
  case_364: /* CIL Label */ 
#line 2734
  if (x->type == 118) {
    {
#line 2735
    x = _glp_mpl_make_unary(mpl, 316, x, 124, 0);
    }
  }
#line 2736
  if (x->type == 124) {
    {
#line 2737
    x = _glp_mpl_make_unary(mpl, 318, x, 126, 1);
    }
  }
#line 2738
  if (x->type != 126) {
    {
#line 2739
    _glp_mpl_error_preceding(mpl, opstr);
    }
  }
  {
#line 2740
  _glp_mpl_get_token(mpl);
#line 2741
  y = _glp_mpl_expression_9(mpl);
  }
#line 2742
  if (y->type != 106) {
    {
#line 2743
    _glp_mpl_error_following(mpl, opstr);
    }
  }
#line 2744
  if (x->dim != y->dim) {
    {
#line 2745
    _glp_mpl_error_dimension(mpl, opstr, x->dim, y->dim);
    }
  }
  {
#line 2746
  x = _glp_mpl_make_binary(mpl, op, x, y, 114, 0);
  }
#line 2747
  goto switch_break___0;
  case_367: /* CIL Label */ 
  case_366: /* CIL Label */ 
#line 2750
  if (x->type != 106) {
    {
#line 2751
    _glp_mpl_error_preceding(mpl, opstr);
    }
  }
  {
#line 2752
  _glp_mpl_get_token(mpl);
#line 2753
  y = _glp_mpl_expression_9(mpl);
  }
#line 2754
  if (y->type != 106) {
    {
#line 2755
    _glp_mpl_error_following(mpl, opstr);
    }
  }
#line 2756
  if (x->dim != y->dim) {
    {
#line 2757
    _glp_mpl_error_dimension(mpl, opstr, x->dim, y->dim);
    }
  }
  {
#line 2758
  x = _glp_mpl_make_binary(mpl, op, x, y, 114, 0);
  }
#line 2759
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2761
  if (op != op) {
#line 2761
    tmp___1 = 1;
  } else {
    {
#line 2761
    _glp_lib_xassert("op != op", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     2761);
#line 2761
    tmp___1 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  done: 
#line 2763
  return (x);
}
}
#line 2775 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_11(MPL *mpl ) 
{ 
  CODE *x ;
  char opstr[8] ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2778
  if (mpl->token == 218) {
    {
#line 2779
    strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 2780
    tmp = strlen((char const   *)(opstr));
    }
#line 2780
    if ((unsigned long )tmp < sizeof(opstr)) {
#line 2780
      tmp___0 = 1;
    } else {
      {
#line 2780
      _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       2780);
#line 2780
      tmp___0 = 1;
      }
    }
    {
#line 2781
    _glp_mpl_get_token(mpl);
#line 2782
    x = _glp_mpl_expression_10(mpl);
    }
#line 2783
    if (x->type == 124) {
      {
#line 2784
      x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
      }
    }
#line 2785
    if (x->type == 118) {
      {
#line 2786
      x = _glp_mpl_make_unary(mpl, 317, x, 114, 0);
      }
    }
#line 2787
    if (x->type != 114) {
      {
#line 2788
      _glp_mpl_error_following(mpl, opstr);
      }
    }
    {
#line 2789
    x = _glp_mpl_make_unary(mpl, 322, x, 114, 0);
    }
  } else {
    {
#line 2792
    x = _glp_mpl_expression_10(mpl);
    }
  }
#line 2793
  return (x);
}
}
#line 2805 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_12(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char opstr[8] ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2808
  x = _glp_mpl_expression_11(mpl);
  }
  {
#line 2809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2810
    if (mpl->token == 206) {
      {
#line 2811
      strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 2812
      tmp = strlen((char const   *)(opstr));
      }
#line 2812
      if ((unsigned long )tmp < sizeof(opstr)) {
#line 2812
        tmp___0 = 1;
      } else {
        {
#line 2812
        _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         2812);
#line 2812
        tmp___0 = 1;
        }
      }
#line 2813
      if (x->type == 124) {
        {
#line 2814
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2815
      if (x->type == 118) {
        {
#line 2816
        x = _glp_mpl_make_unary(mpl, 317, x, 114, 0);
        }
      }
#line 2817
      if (x->type != 114) {
        {
#line 2818
        _glp_mpl_error_preceding(mpl, opstr);
        }
      }
      {
#line 2819
      _glp_mpl_get_token(mpl);
#line 2820
      y = _glp_mpl_expression_11(mpl);
      }
#line 2821
      if (y->type == 124) {
        {
#line 2822
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2823
      if (y->type == 118) {
        {
#line 2824
        y = _glp_mpl_make_unary(mpl, 317, y, 114, 0);
        }
      }
#line 2825
      if (y->type != 114) {
        {
#line 2826
        _glp_mpl_error_following(mpl, opstr);
        }
      }
      {
#line 2827
      x = _glp_mpl_make_binary(mpl, 357, x, y, 114, 0);
      }
    } else {
#line 2830
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2832
  return (x);
}
}
#line 2844 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CODE *_glp_mpl_expression_13(MPL *mpl ) 
{ 
  CODE *x ;
  CODE *y ;
  char opstr[8] ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2847
  x = _glp_mpl_expression_12(mpl);
  }
  {
#line 2848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2849
    if (mpl->token == 219) {
      {
#line 2850
      strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 2851
      tmp = strlen((char const   *)(opstr));
      }
#line 2851
      if ((unsigned long )tmp < sizeof(opstr)) {
#line 2851
        tmp___0 = 1;
      } else {
        {
#line 2851
        _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         2851);
#line 2851
        tmp___0 = 1;
        }
      }
#line 2852
      if (x->type == 124) {
        {
#line 2853
        x = _glp_mpl_make_unary(mpl, 315, x, 118, 0);
        }
      }
#line 2854
      if (x->type == 118) {
        {
#line 2855
        x = _glp_mpl_make_unary(mpl, 317, x, 114, 0);
        }
      }
#line 2856
      if (x->type != 114) {
        {
#line 2857
        _glp_mpl_error_preceding(mpl, opstr);
        }
      }
      {
#line 2858
      _glp_mpl_get_token(mpl);
#line 2859
      y = _glp_mpl_expression_12(mpl);
      }
#line 2860
      if (y->type == 124) {
        {
#line 2861
        y = _glp_mpl_make_unary(mpl, 315, y, 118, 0);
        }
      }
#line 2862
      if (y->type == 118) {
        {
#line 2863
        y = _glp_mpl_make_unary(mpl, 317, y, 114, 0);
        }
      }
#line 2864
      if (y->type != 114) {
        {
#line 2865
        _glp_mpl_error_following(mpl, opstr);
        }
      }
      {
#line 2866
      x = _glp_mpl_make_binary(mpl, 358, x, y, 114, 0);
      }
    } else {
#line 2869
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2871
  return (x);
}
}
#line 2893 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
SET *_glp_mpl_set_statement(MPL *mpl ) 
{ 
  SET *set___0 ;
  int dimen_used ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  AVLNODE *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  AVLNODE *node ;
  int dimen ;
  double tmp___8 ;
  WITHIN *within ;
  WITHIN *temp ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  GADGET *gadget ;
  AVLNODE *node___0 ;
  int i ;
  int k ;
  int fff[20] ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
  {
#line 2895
  dimen_used = 0;
#line 2896
  tmp = _glp_mpl_is_keyword(mpl, (char *)"set");
  }
#line 2896
  if (tmp) {
#line 2896
    tmp___0 = 1;
  } else {
    {
#line 2896
    _glp_lib_xassert("is_keyword(mpl, \"set\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     2896);
#line 2896
    tmp___0 = 1;
    }
  }
  {
#line 2897
  _glp_mpl_get_token(mpl);
  }
#line 2899
  if (! (mpl->token == 202)) {
    {
#line 2901
    tmp___1 = _glp_mpl_is_reserved(mpl);
    }
#line 2901
    if (tmp___1) {
      {
#line 2902
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
      {
#line 2904
      _glp_mpl_error(mpl, (char *)"symbolic name missing where expected");
      }
    }
  }
  {
#line 2906
  tmp___2 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
  }
#line 2906
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 2907
    _glp_mpl_error(mpl, (char *)"%s multiply declared", mpl->image);
    }
  }
  {
#line 2909
  tmp___3 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(SET ));
#line 2909
  set___0 = (SET *)tmp___3;
#line 2910
  tmp___4 = strlen((char const   *)mpl->image);
#line 2910
  tmp___5 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___4 + 1U));
#line 2910
  set___0->name = (char *)tmp___5;
#line 2911
  strcpy((char */* __restrict  */)set___0->name, (char const   */* __restrict  */)mpl->image);
#line 2912
  set___0->alias = (char *)((void *)0);
#line 2913
  set___0->dim = 0;
#line 2914
  set___0->domain = (DOMAIN1 *)((void *)0);
#line 2915
  set___0->dimen = 0;
#line 2916
  set___0->within = (WITHIN *)((void *)0);
#line 2917
  set___0->assign = (CODE *)((void *)0);
#line 2918
  set___0->option = (CODE *)((void *)0);
#line 2919
  set___0->gadget = (GADGET *)((void *)0);
#line 2920
  set___0->data = 0;
#line 2921
  set___0->array = (ARRAY *)((void *)0);
#line 2922
  _glp_mpl_get_token(mpl);
  }
#line 2924
  if (mpl->token == 205) {
    {
#line 2925
    tmp___6 = strlen((char const   *)mpl->image);
#line 2925
    tmp___7 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___6 + 1U));
#line 2925
    set___0->alias = (char *)tmp___7;
#line 2926
    strcpy((char */* __restrict  */)set___0->alias, (char const   */* __restrict  */)mpl->image);
#line 2927
    _glp_mpl_get_token(mpl);
    }
  }
#line 2930
  if (mpl->token == 248) {
    {
#line 2931
    set___0->domain = _glp_mpl_indexing_expression(mpl);
#line 2932
    set___0->dim = _glp_mpl_domain_arity(mpl, set___0->domain);
    }
  }
  {
#line 2936
  node = _glp_avl_insert_node(mpl->tree, (void const   *)set___0->name);
#line 2937
  _glp_avl_set_node_type(node, 122);
#line 2938
  _glp_avl_set_node_link(node, (void *)set___0);
  }
  {
#line 2941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2942
    if (mpl->token == 239) {
      {
#line 2943
      _glp_mpl_get_token(mpl);
      }
    } else
#line 2944
    if (mpl->token == 241) {
#line 2945
      goto while_break;
    }
    {
#line 2946
    tmp___22 = _glp_mpl_is_keyword(mpl, (char *)"dimen");
    }
#line 2946
    if (tmp___22) {
      {
#line 2949
      _glp_mpl_get_token(mpl);
      }
#line 2950
      if (mpl->token == 204) {
#line 2950
        if (1.0 <= mpl->value) {
#line 2950
          if (mpl->value <= 20.0) {
            {
#line 2950
            tmp___8 = floor(mpl->value);
            }
#line 2950
            if (! (tmp___8 == mpl->value)) {
              {
#line 2953
              _glp_mpl_error(mpl, (char *)"dimension must be integer between 1 and 20");
              }
            }
          } else {
            {
#line 2953
            _glp_mpl_error(mpl, (char *)"dimension must be integer between 1 and 20");
            }
          }
        } else {
          {
#line 2953
          _glp_mpl_error(mpl, (char *)"dimension must be integer between 1 and 20");
          }
        }
      } else {
        {
#line 2953
        _glp_mpl_error(mpl, (char *)"dimension must be integer between 1 and 20");
        }
      }
#line 2954
      dimen = (int )(mpl->value + 0.5);
#line 2955
      if (dimen_used) {
        {
#line 2956
        _glp_mpl_error(mpl, (char *)"at most one dimension attribute allowed");
        }
      }
#line 2957
      if (set___0->dimen > 0) {
        {
#line 2958
        _glp_mpl_error(mpl, (char *)"dimension %d conflicts with dimension %d already determined",
                       dimen, set___0->dimen);
        }
      }
      {
#line 2960
      set___0->dimen = dimen;
#line 2961
      dimen_used = 1;
#line 2962
      _glp_mpl_get_token(mpl);
      }
    } else
#line 2964
    if (mpl->token == 224) {
#line 2964
      goto _L___1;
    } else
#line 2964
    if (mpl->token == 213) {
      _L___1: /* CIL Label */ 
#line 2967
      if (mpl->token == 213) {
#line 2967
        if (! mpl->as_within) {
          {
#line 2968
          _glp_mpl_warning(mpl, (char *)"keyword in understood as within");
#line 2969
          mpl->as_within = 1;
          }
        }
      }
      {
#line 2971
      _glp_mpl_get_token(mpl);
#line 2974
      tmp___9 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(WITHIN ));
#line 2974
      within = (WITHIN *)tmp___9;
#line 2975
      within->code = (CODE *)((void *)0);
#line 2976
      within->next = (WITHIN *)((void *)0);
      }
#line 2977
      if ((unsigned long )set___0->within == (unsigned long )((void *)0)) {
#line 2978
        set___0->within = within;
      } else {
#line 2980
        temp = set___0->within;
        {
#line 2980
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2980
          if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 2980
            goto while_break___0;
          }
#line 2980
          temp = temp->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2982
        temp->next = within;
      }
      {
#line 2985
      within->code = _glp_mpl_expression_9(mpl);
      }
#line 2986
      if ((within->code)->type != 106) {
        {
#line 2987
        _glp_mpl_error(mpl, (char *)"expression following within has invalid type");
        }
      }
#line 2989
      if ((within->code)->dim > 0) {
#line 2989
        tmp___10 = 1;
      } else {
        {
#line 2989
        _glp_lib_xassert("within->code->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         2989);
#line 2989
        tmp___10 = 1;
        }
      }
#line 2991
      if (set___0->dimen == 0) {
#line 2991
        set___0->dimen = (within->code)->dim;
      }
#line 2992
      if (set___0->dimen != (within->code)->dim) {
        {
#line 2993
        _glp_mpl_error(mpl, (char *)"set expression following within must have dimension %d rather than %d",
                       set___0->dimen, (within->code)->dim);
        }
      }
    } else
#line 2997
    if (mpl->token == 242) {
#line 2999
      if ((unsigned long )set___0->assign == (unsigned long )((void *)0)) {
#line 2999
        if ((unsigned long )set___0->option == (unsigned long )((void *)0)) {
#line 2999
          if (! ((unsigned long )set___0->gadget == (unsigned long )((void *)0))) {
#line 2999
            goto err;
          }
        } else {
#line 2999
          goto err;
        }
      } else {
        err: 
        {
#line 3001
        _glp_mpl_error(mpl, (char *)"at most one := or default/data allowed");
        }
      }
      {
#line 3002
      _glp_mpl_get_token(mpl);
#line 3004
      set___0->assign = _glp_mpl_expression_9(mpl);
      }
#line 3005
      if ((set___0->assign)->type != 106) {
        {
#line 3006
        _glp_mpl_error(mpl, (char *)"expression following := has invalid type");
        }
      }
#line 3007
      if ((set___0->assign)->dim > 0) {
#line 3007
        tmp___11 = 1;
      } else {
        {
#line 3007
        _glp_lib_xassert("set->assign->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         3007);
#line 3007
        tmp___11 = 1;
        }
      }
#line 3009
      if (set___0->dimen == 0) {
#line 3009
        set___0->dimen = (set___0->assign)->dim;
      }
#line 3010
      if (set___0->dimen != (set___0->assign)->dim) {
        {
#line 3011
        _glp_mpl_error(mpl, (char *)"set expression following := must have dimension %d rather than %d",
                       set___0->dimen, (set___0->assign)->dim);
        }
      }
    } else {
      {
#line 3015
      tmp___21 = _glp_mpl_is_keyword(mpl, (char *)"default");
      }
#line 3015
      if (tmp___21) {
#line 3017
        if ((unsigned long )set___0->assign == (unsigned long )((void *)0)) {
#line 3017
          if (! ((unsigned long )set___0->option == (unsigned long )((void *)0))) {
#line 3017
            goto err;
          }
        } else {
#line 3017
          goto err;
        }
        {
#line 3018
        _glp_mpl_get_token(mpl);
#line 3020
        set___0->option = _glp_mpl_expression_9(mpl);
        }
#line 3021
        if ((set___0->option)->type != 106) {
          {
#line 3022
          _glp_mpl_error(mpl, (char *)"expression following default has invalid type");
          }
        }
#line 3024
        if ((set___0->option)->dim > 0) {
#line 3024
          tmp___12 = 1;
        } else {
          {
#line 3024
          _glp_lib_xassert("set->option->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           3024);
#line 3024
          tmp___12 = 1;
          }
        }
#line 3026
        if (set___0->dimen == 0) {
#line 3026
          set___0->dimen = (set___0->option)->dim;
        }
#line 3027
        if (set___0->dimen != (set___0->option)->dim) {
          {
#line 3028
          _glp_mpl_error(mpl, (char *)"set expression following default must have dimension %d rather than %d",
                         set___0->dimen, (set___0->option)->dim);
          }
        }
      } else {
        {
#line 3033
        tmp___20 = _glp_mpl_is_keyword(mpl, (char *)"data");
        }
#line 3033
        if (tmp___20) {
#line 3038
          if ((unsigned long )set___0->assign == (unsigned long )((void *)0)) {
#line 3038
            if (! ((unsigned long )set___0->gadget == (unsigned long )((void *)0))) {
#line 3038
              goto err;
            }
          } else {
#line 3038
            goto err;
          }
          {
#line 3039
          _glp_mpl_get_token(mpl);
#line 3040
          tmp___13 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(GADGET ));
#line 3040
          gadget = (GADGET *)tmp___13;
#line 3040
          set___0->gadget = gadget;
          }
#line 3042
          if (! (mpl->token == 202)) {
            {
#line 3044
            tmp___14 = _glp_mpl_is_reserved(mpl);
            }
#line 3044
            if (tmp___14) {
              {
#line 3045
              _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
              }
            } else {
              {
#line 3048
              _glp_mpl_error(mpl, (char *)"set name missing where expected");
              }
            }
          }
          {
#line 3050
          node___0 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
          }
#line 3051
          if ((unsigned long )node___0 == (unsigned long )((void *)0)) {
            {
#line 3052
            _glp_mpl_error(mpl, (char *)"%s not defined", mpl->image);
            }
          }
          {
#line 3053
          tmp___15 = _glp_avl_get_node_type(node___0);
          }
#line 3053
          if (tmp___15 != 122) {
            err1: 
            {
#line 3054
            _glp_mpl_error(mpl, (char *)"%s not a plain set", mpl->image);
            }
          }
          {
#line 3055
          tmp___16 = _glp_avl_get_node_link(node___0);
#line 3055
          gadget->set = (SET *)tmp___16;
          }
#line 3056
          if ((gadget->set)->dim != 0) {
#line 3056
            goto err1;
          }
#line 3057
          if ((unsigned long )gadget->set == (unsigned long )set___0) {
            {
#line 3058
            _glp_mpl_error(mpl, (char *)"set cannot be initialized by itself");
            }
          }
#line 3060
          if (set___0->dim >= (gadget->set)->dimen) {
            err2: 
            {
#line 3061
            _glp_mpl_error(mpl, (char *)"dimension of %s too small", mpl->image);
            }
          }
#line 3062
          if (set___0->dimen == 0) {
#line 3063
            set___0->dimen = (gadget->set)->dimen - set___0->dim;
          }
#line 3064
          if (set___0->dim + set___0->dimen > (gadget->set)->dimen) {
#line 3065
            goto err2;
          } else
#line 3066
          if (set___0->dim + set___0->dimen < (gadget->set)->dimen) {
            {
#line 3067
            _glp_mpl_error(mpl, (char *)"dimension of %s too big", mpl->image);
            }
          }
          {
#line 3068
          _glp_mpl_get_token(mpl);
          }
#line 3070
          if (mpl->token == 244) {
            {
#line 3071
            _glp_mpl_get_token(mpl);
            }
          } else {
            {
#line 3073
            _glp_mpl_error(mpl, (char *)"left parenthesis missing where expected");
            }
          }
#line 3075
          k = 0;
          {
#line 3075
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3075
            if (! (k < (gadget->set)->dimen)) {
#line 3075
              goto while_break___1;
            }
#line 3075
            fff[k] = 0;
#line 3075
            k ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 3076
          k = 0;
          {
#line 3077
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3078
            if (mpl->token != 204) {
              {
#line 3079
              _glp_mpl_error(mpl, (char *)"component number missing where expected");
              }
            }
            {
#line 3080
            tmp___17 = _glp_lib_str2int((char const   *)mpl->image, & i);
            }
#line 3080
            if (tmp___17 != 0) {
              err3: 
              {
#line 3081
              _glp_mpl_error(mpl, (char *)"component number must be integer between 1 and %d",
                             (gadget->set)->dimen);
              }
            }
#line 3083
            if (1 <= i) {
#line 3083
              if (! (i <= (gadget->set)->dimen)) {
#line 3083
                goto err3;
              }
            } else {
#line 3083
              goto err3;
            }
#line 3084
            if (fff[i - 1] != 0) {
              {
#line 3085
              _glp_mpl_error(mpl, (char *)"component %d multiply specified", i);
              }
            }
#line 3086
            tmp___18 = k;
#line 3086
            k ++;
#line 3086
            gadget->ind[tmp___18] = i;
#line 3086
            fff[i - 1] = 1;
#line 3087
            if (k <= (gadget->set)->dimen) {
#line 3087
              tmp___19 = 1;
            } else {
              {
#line 3087
              _glp_lib_xassert("k <= gadget->set->dimen", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3087);
#line 3087
              tmp___19 = 1;
              }
            }
            {
#line 3088
            _glp_mpl_get_token(mpl);
            }
#line 3089
            if (mpl->token == 239) {
              {
#line 3090
              _glp_mpl_get_token(mpl);
              }
            } else
#line 3091
            if (mpl->token == 245) {
#line 3092
              goto while_break___2;
            } else {
              {
#line 3094
              _glp_mpl_error(mpl, (char *)"syntax error in data attribute");
              }
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 3096
          if (k < (gadget->set)->dimen) {
            {
#line 3097
            _glp_mpl_error(mpl, (char *)"there are must be %d components rather than %d",
                           (gadget->set)->dimen, k);
            }
          }
          {
#line 3099
          _glp_mpl_get_token(mpl);
          }
        } else {
          {
#line 3103
          _glp_mpl_error(mpl, (char *)"syntax error in set statement");
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3106
  if ((unsigned long )set___0->domain != (unsigned long )((void *)0)) {
    {
#line 3106
    _glp_mpl_close_scope(mpl, set___0->domain);
    }
  }
#line 3108
  if (set___0->dimen == 0) {
#line 3108
    set___0->dimen = 1;
  }
#line 3110
  if (mpl->token == 241) {
#line 3110
    tmp___23 = 1;
  } else {
    {
#line 3110
    _glp_lib_xassert("mpl->token == T_SEMICOLON", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3110);
#line 3110
    tmp___23 = 1;
    }
  }
  {
#line 3111
  _glp_mpl_get_token(mpl);
  }
#line 3112
  return (set___0);
}
}
#line 3138 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
PARAMETER *_glp_mpl_parameter_statement(MPL *mpl ) 
{ 
  PARAMETER *par ;
  int integer_used ;
  int binary_used ;
  int symbolic_used ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  AVLNODE *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  AVLNODE *node ;
  CONDITION *cond ;
  CONDITION *temp ;
  char opstr[8] ;
  void *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  WITHIN *in ;
  WITHIN *temp___0 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;

  {
  {
#line 3140
  integer_used = 0;
#line 3140
  binary_used = 0;
#line 3140
  symbolic_used = 0;
#line 3141
  tmp = _glp_mpl_is_keyword(mpl, (char *)"param");
  }
#line 3141
  if (tmp) {
#line 3141
    tmp___0 = 1;
  } else {
    {
#line 3141
    _glp_lib_xassert("is_keyword(mpl, \"param\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3141);
#line 3141
    tmp___0 = 1;
    }
  }
  {
#line 3142
  _glp_mpl_get_token(mpl);
  }
#line 3144
  if (! (mpl->token == 202)) {
    {
#line 3146
    tmp___1 = _glp_mpl_is_reserved(mpl);
    }
#line 3146
    if (tmp___1) {
      {
#line 3147
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
      {
#line 3149
      _glp_mpl_error(mpl, (char *)"symbolic name missing where expected");
      }
    }
  }
  {
#line 3151
  tmp___2 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
  }
#line 3151
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 3152
    _glp_mpl_error(mpl, (char *)"%s multiply declared", mpl->image);
    }
  }
  {
#line 3154
  tmp___3 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(PARAMETER ));
#line 3154
  par = (PARAMETER *)tmp___3;
#line 3155
  tmp___4 = strlen((char const   *)mpl->image);
#line 3155
  tmp___5 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___4 + 1U));
#line 3155
  par->name = (char *)tmp___5;
#line 3156
  strcpy((char */* __restrict  */)par->name, (char const   */* __restrict  */)mpl->image);
#line 3157
  par->alias = (char *)((void *)0);
#line 3158
  par->dim = 0;
#line 3159
  par->domain = (DOMAIN1 *)((void *)0);
#line 3160
  par->type = 118;
#line 3161
  par->cond = (CONDITION *)((void *)0);
#line 3162
  par->in = (WITHIN *)((void *)0);
#line 3163
  par->assign = (CODE *)((void *)0);
#line 3164
  par->option = (CODE *)((void *)0);
#line 3165
  par->data = 0;
#line 3166
  par->defval = (SYMBOL *)((void *)0);
#line 3167
  par->array = (ARRAY *)((void *)0);
#line 3168
  _glp_mpl_get_token(mpl);
  }
#line 3170
  if (mpl->token == 205) {
    {
#line 3171
    tmp___6 = strlen((char const   *)mpl->image);
#line 3171
    tmp___7 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___6 + 1U));
#line 3171
    par->alias = (char *)tmp___7;
#line 3172
    strcpy((char */* __restrict  */)par->alias, (char const   */* __restrict  */)mpl->image);
#line 3173
    _glp_mpl_get_token(mpl);
    }
  }
#line 3176
  if (mpl->token == 248) {
    {
#line 3177
    par->domain = _glp_mpl_indexing_expression(mpl);
#line 3178
    par->dim = _glp_mpl_domain_arity(mpl, par->domain);
    }
  }
  {
#line 3182
  node = _glp_avl_insert_node(mpl->tree, (void const   *)par->name);
#line 3183
  _glp_avl_set_node_type(node, 120);
#line 3184
  _glp_avl_set_node_link(node, (void *)par);
  }
  {
#line 3187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3188
    if (mpl->token == 239) {
      {
#line 3189
      _glp_mpl_get_token(mpl);
      }
    } else
#line 3190
    if (mpl->token == 241) {
#line 3191
      goto while_break;
    }
    {
#line 3192
    tmp___21 = _glp_mpl_is_keyword(mpl, (char *)"integer");
    }
#line 3192
    if (tmp___21) {
#line 3193
      if (integer_used) {
        {
#line 3194
        _glp_mpl_error(mpl, (char *)"at most one integer allowed");
        }
      }
#line 3195
      if (par->type == 124) {
        {
#line 3196
        _glp_mpl_error(mpl, (char *)"symbolic parameter cannot be integer");
        }
      }
#line 3197
      if (par->type != 101) {
#line 3197
        par->type = 113;
      }
      {
#line 3198
      integer_used = 1;
#line 3199
      _glp_mpl_get_token(mpl);
      }
    } else {
      {
#line 3201
      tmp___20 = _glp_mpl_is_keyword(mpl, (char *)"binary");
      }
#line 3201
      if (tmp___20) {
        bin: 
#line 3202
        if (binary_used) {
          {
#line 3203
          _glp_mpl_error(mpl, (char *)"at most one binary allowed");
          }
        }
#line 3204
        if (par->type == 124) {
          {
#line 3205
          _glp_mpl_error(mpl, (char *)"symbolic parameter cannot be binary");
          }
        }
        {
#line 3206
        par->type = 101;
#line 3207
        binary_used = 1;
#line 3208
        _glp_mpl_get_token(mpl);
        }
      } else {
        {
#line 3210
        tmp___19 = _glp_mpl_is_keyword(mpl, (char *)"logical");
        }
#line 3210
        if (tmp___19) {
#line 3211
          if (! mpl->as_binary) {
            {
#line 3212
            _glp_mpl_warning(mpl, (char *)"keyword logical understood as binary");
#line 3213
            mpl->as_binary = 1;
            }
          }
#line 3215
          goto bin;
        } else {
          {
#line 3217
          tmp___18 = _glp_mpl_is_keyword(mpl, (char *)"symbolic");
          }
#line 3217
          if (tmp___18) {
#line 3218
            if (symbolic_used) {
              {
#line 3219
              _glp_mpl_error(mpl, (char *)"at most one symbolic allowed");
              }
            }
#line 3220
            if (par->type != 118) {
              {
#line 3221
              _glp_mpl_error(mpl, (char *)"integer or binary parameter cannot be symbolic");
              }
            }
#line 3226
            if ((unsigned long )par->cond == (unsigned long )((void *)0)) {
#line 3226
              if ((unsigned long )par->in == (unsigned long )((void *)0)) {
#line 3226
                if ((unsigned long )par->assign == (unsigned long )((void *)0)) {
#line 3226
                  if (! ((unsigned long )par->option == (unsigned long )((void *)0))) {
                    {
#line 3228
                    _glp_mpl_error(mpl, (char *)"keyword symbolic must precede any other parameter attributes");
                    }
                  }
                } else {
                  {
#line 3228
                  _glp_mpl_error(mpl, (char *)"keyword symbolic must precede any other parameter attributes");
                  }
                }
              } else {
                {
#line 3228
                _glp_mpl_error(mpl, (char *)"keyword symbolic must precede any other parameter attributes");
                }
              }
            } else {
              {
#line 3228
              _glp_mpl_error(mpl, (char *)"keyword symbolic must precede any other parameter attributes");
              }
            }
            {
#line 3230
            par->type = 124;
#line 3231
            symbolic_used = 1;
#line 3232
            _glp_mpl_get_token(mpl);
            }
          } else
#line 3234
          if (mpl->token == 230) {
#line 3234
            goto _L___1;
          } else
#line 3234
          if (mpl->token == 231) {
#line 3234
            goto _L___1;
          } else
#line 3234
          if (mpl->token == 232) {
#line 3234
            goto _L___1;
          } else
#line 3234
          if (mpl->token == 233) {
#line 3234
            goto _L___1;
          } else
#line 3234
          if (mpl->token == 234) {
#line 3234
            goto _L___1;
          } else
#line 3234
          if (mpl->token == 235) {
            _L___1: /* CIL Label */ 
            {
#line 3242
            tmp___8 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(CONDITION ));
#line 3242
            cond = (CONDITION *)tmp___8;
            }
            {
#line 3244
            if (mpl->token == 230) {
#line 3244
              goto case_230;
            }
#line 3246
            if (mpl->token == 231) {
#line 3246
              goto case_231;
            }
#line 3248
            if (mpl->token == 232) {
#line 3248
              goto case_232;
            }
#line 3250
            if (mpl->token == 233) {
#line 3250
              goto case_233;
            }
#line 3252
            if (mpl->token == 234) {
#line 3252
              goto case_234;
            }
#line 3254
            if (mpl->token == 235) {
#line 3254
              goto case_235;
            }
#line 3256
            goto switch_default;
            case_230: /* CIL Label */ 
            {
#line 3245
            cond->rho = 351;
#line 3245
            strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
            }
#line 3245
            goto switch_break;
            case_231: /* CIL Label */ 
            {
#line 3247
            cond->rho = 352;
#line 3247
            strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
            }
#line 3247
            goto switch_break;
            case_232: /* CIL Label */ 
            {
#line 3249
            cond->rho = 353;
#line 3249
            strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
            }
#line 3249
            goto switch_break;
            case_233: /* CIL Label */ 
            {
#line 3251
            cond->rho = 354;
#line 3251
            strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
            }
#line 3251
            goto switch_break;
            case_234: /* CIL Label */ 
            {
#line 3253
            cond->rho = 355;
#line 3253
            strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
            }
#line 3253
            goto switch_break;
            case_235: /* CIL Label */ 
            {
#line 3255
            cond->rho = 356;
#line 3255
            strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
            }
#line 3255
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 3257
            if (mpl->token != mpl->token) {
#line 3257
              tmp___9 = 1;
            } else {
              {
#line 3257
              _glp_lib_xassert("mpl->token != mpl->token", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3257);
#line 3257
              tmp___9 = 1;
              }
            }
            switch_break: /* CIL Label */ ;
            }
            {
#line 3259
            tmp___10 = strlen((char const   *)(opstr));
            }
#line 3259
            if ((unsigned long )tmp___10 < sizeof(opstr)) {
#line 3259
              tmp___11 = 1;
            } else {
              {
#line 3259
              _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3259);
#line 3259
              tmp___11 = 1;
              }
            }
#line 3260
            cond->code = (CODE *)((void *)0);
#line 3261
            cond->next = (CONDITION *)((void *)0);
#line 3262
            if ((unsigned long )par->cond == (unsigned long )((void *)0)) {
#line 3263
              par->cond = cond;
            } else {
#line 3265
              temp = par->cond;
              {
#line 3265
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 3265
                if (! ((unsigned long )temp->next != (unsigned long )((void *)0))) {
#line 3265
                  goto while_break___0;
                }
#line 3265
                temp = temp->next;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 3267
              temp->next = cond;
            }
            {
#line 3274
            _glp_mpl_get_token(mpl);
#line 3276
            cond->code = _glp_mpl_expression_5(mpl);
            }
#line 3277
            if (! ((cond->code)->type == 118)) {
#line 3277
              if (! ((cond->code)->type == 124)) {
                {
#line 3279
                _glp_mpl_error(mpl, (char *)"expression following %s has invalid type",
                               opstr);
                }
              }
            }
#line 3281
            if ((cond->code)->dim == 0) {
#line 3281
              tmp___12 = 1;
            } else {
              {
#line 3281
              _glp_lib_xassert("cond->code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3281);
#line 3281
              tmp___12 = 1;
              }
            }
#line 3283
            if (par->type != 124) {
#line 3283
              if ((cond->code)->type == 124) {
                {
#line 3285
                cond->code = _glp_mpl_make_unary(mpl, 315, cond->code, 118, 0);
                }
              }
            }
#line 3287
            if (par->type == 124) {
#line 3287
              if ((cond->code)->type != 124) {
                {
#line 3289
                cond->code = _glp_mpl_make_unary(mpl, 316, cond->code, 124, 0);
                }
              }
            }
          } else
#line 3292
          if (mpl->token == 213) {
#line 3292
            goto _L___0;
          } else
#line 3292
          if (mpl->token == 224) {
            _L___0: /* CIL Label */ 
#line 3295
            if (mpl->token == 224) {
#line 3295
              if (! mpl->as_in) {
                {
#line 3296
                _glp_mpl_warning(mpl, (char *)"keyword within understood as in");
#line 3297
                mpl->as_in = 1;
                }
              }
            }
            {
#line 3299
            _glp_mpl_get_token(mpl);
#line 3302
            tmp___13 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(WITHIN ));
#line 3302
            in = (WITHIN *)tmp___13;
#line 3303
            in->code = (CODE *)((void *)0);
#line 3304
            in->next = (WITHIN *)((void *)0);
            }
#line 3305
            if ((unsigned long )par->in == (unsigned long )((void *)0)) {
#line 3306
              par->in = in;
            } else {
#line 3308
              temp___0 = par->in;
              {
#line 3308
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3308
                if (! ((unsigned long )temp___0->next != (unsigned long )((void *)0))) {
#line 3308
                  goto while_break___1;
                }
#line 3308
                temp___0 = temp___0->next;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3310
              temp___0->next = in;
            }
            {
#line 3313
            in->code = _glp_mpl_expression_9(mpl);
            }
#line 3314
            if ((in->code)->type != 106) {
              {
#line 3315
              _glp_mpl_error(mpl, (char *)"expression following in has invalid type");
              }
            }
#line 3316
            if ((in->code)->dim > 0) {
#line 3316
              tmp___14 = 1;
            } else {
              {
#line 3316
              _glp_lib_xassert("in->code->dim > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3316);
#line 3316
              tmp___14 = 1;
              }
            }
#line 3317
            if ((in->code)->dim != 1) {
              {
#line 3318
              _glp_mpl_error(mpl, (char *)"set expression following in must have dimension 1 rather than %d",
                             (in->code)->dim);
              }
            }
          } else
#line 3321
          if (mpl->token == 242) {
#line 3323
            if ((unsigned long )par->assign == (unsigned long )((void *)0)) {
#line 3323
              if (! ((unsigned long )par->option == (unsigned long )((void *)0))) {
#line 3323
                goto err;
              }
            } else {
              err: 
              {
#line 3324
              _glp_mpl_error(mpl, (char *)"at most one := or default allowed");
              }
            }
            {
#line 3325
            _glp_mpl_get_token(mpl);
#line 3327
            par->assign = _glp_mpl_expression_5(mpl);
            }
#line 3329
            if (! ((par->assign)->type == 118)) {
#line 3329
              if (! ((par->assign)->type == 124)) {
                {
#line 3331
                _glp_mpl_error(mpl, (char *)"expression following := has invalid type");
                }
              }
            }
#line 3332
            if ((par->assign)->dim == 0) {
#line 3332
              tmp___15 = 1;
            } else {
              {
#line 3332
              _glp_lib_xassert("par->assign->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3332);
#line 3332
              tmp___15 = 1;
              }
            }
#line 3334
            if (par->type != 124) {
#line 3334
              if ((par->assign)->type == 124) {
                {
#line 3336
                par->assign = _glp_mpl_make_unary(mpl, 315, par->assign, 118, 0);
                }
              }
            }
#line 3338
            if (par->type == 124) {
#line 3338
              if ((par->assign)->type != 124) {
                {
#line 3340
                par->assign = _glp_mpl_make_unary(mpl, 316, par->assign, 124, 0);
                }
              }
            }
          } else {
            {
#line 3343
            tmp___17 = _glp_mpl_is_keyword(mpl, (char *)"default");
            }
#line 3343
            if (tmp___17) {
#line 3345
              if ((unsigned long )par->assign == (unsigned long )((void *)0)) {
#line 3345
                if (! ((unsigned long )par->option == (unsigned long )((void *)0))) {
#line 3345
                  goto err;
                }
              } else {
#line 3345
                goto err;
              }
              {
#line 3346
              _glp_mpl_get_token(mpl);
#line 3348
              par->option = _glp_mpl_expression_5(mpl);
              }
#line 3349
              if (! ((par->option)->type == 118)) {
#line 3349
                if (! ((par->option)->type == 124)) {
                  {
#line 3351
                  _glp_mpl_error(mpl, (char *)"expression following default has invalid type");
                  }
                }
              }
#line 3353
              if ((par->option)->dim == 0) {
#line 3353
                tmp___16 = 1;
              } else {
                {
#line 3353
                _glp_lib_xassert("par->option->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                                 3353);
#line 3353
                tmp___16 = 1;
                }
              }
#line 3355
              if (par->type != 124) {
#line 3355
                if ((par->option)->type == 124) {
                  {
#line 3357
                  par->option = _glp_mpl_make_unary(mpl, 315, par->option, 118, 0);
                  }
                }
              }
#line 3359
              if (par->type == 124) {
#line 3359
                if ((par->option)->type != 124) {
                  {
#line 3361
                  par->option = _glp_mpl_make_unary(mpl, 316, par->option, 124, 0);
                  }
                }
              }
            } else {
              {
#line 3365
              _glp_mpl_error(mpl, (char *)"syntax error in parameter statement");
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3368
  if ((unsigned long )par->domain != (unsigned long )((void *)0)) {
    {
#line 3368
    _glp_mpl_close_scope(mpl, par->domain);
    }
  }
#line 3370
  if (mpl->token == 241) {
#line 3370
    tmp___22 = 1;
  } else {
    {
#line 3370
    _glp_lib_xassert("mpl->token == T_SEMICOLON", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3370);
#line 3370
    tmp___22 = 1;
    }
  }
  {
#line 3371
  _glp_mpl_get_token(mpl);
  }
#line 3372
  return (par);
}
}
#line 3394 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
VARIABLE *_glp_mpl_variable_statement(MPL *mpl ) 
{ 
  VARIABLE *var ;
  int integer_used ;
  int binary_used ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  AVLNODE *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  AVLNODE *node ;
  int tmp___8 ;
  int tmp___9 ;
  char opstr[8] ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
  {
#line 3396
  integer_used = 0;
#line 3396
  binary_used = 0;
#line 3397
  tmp = _glp_mpl_is_keyword(mpl, (char *)"var");
  }
#line 3397
  if (tmp) {
#line 3397
    tmp___0 = 1;
  } else {
    {
#line 3397
    _glp_lib_xassert("is_keyword(mpl, \"var\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3397);
#line 3397
    tmp___0 = 1;
    }
  }
#line 3398
  if (mpl->flag_s) {
    {
#line 3399
    _glp_mpl_error(mpl, (char *)"variable statement must precede solve statement");
    }
  }
  {
#line 3400
  _glp_mpl_get_token(mpl);
  }
#line 3402
  if (! (mpl->token == 202)) {
    {
#line 3404
    tmp___1 = _glp_mpl_is_reserved(mpl);
    }
#line 3404
    if (tmp___1) {
      {
#line 3405
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
      {
#line 3407
      _glp_mpl_error(mpl, (char *)"symbolic name missing where expected");
      }
    }
  }
  {
#line 3409
  tmp___2 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
  }
#line 3409
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 3410
    _glp_mpl_error(mpl, (char *)"%s multiply declared", mpl->image);
    }
  }
  {
#line 3412
  tmp___3 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(VARIABLE ));
#line 3412
  var = (VARIABLE *)tmp___3;
#line 3413
  tmp___4 = strlen((char const   *)mpl->image);
#line 3413
  tmp___5 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___4 + 1U));
#line 3413
  var->name = (char *)tmp___5;
#line 3414
  strcpy((char */* __restrict  */)var->name, (char const   */* __restrict  */)mpl->image);
#line 3415
  var->alias = (char *)((void *)0);
#line 3416
  var->dim = 0;
#line 3417
  var->domain = (DOMAIN1 *)((void *)0);
#line 3418
  var->type = 118;
#line 3419
  var->lbnd = (CODE *)((void *)0);
#line 3420
  var->ubnd = (CODE *)((void *)0);
#line 3421
  var->array = (ARRAY *)((void *)0);
#line 3422
  _glp_mpl_get_token(mpl);
  }
#line 3424
  if (mpl->token == 205) {
    {
#line 3425
    tmp___6 = strlen((char const   *)mpl->image);
#line 3425
    tmp___7 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___6 + 1U));
#line 3425
    var->alias = (char *)tmp___7;
#line 3426
    strcpy((char */* __restrict  */)var->alias, (char const   */* __restrict  */)mpl->image);
#line 3427
    _glp_mpl_get_token(mpl);
    }
  }
#line 3430
  if (mpl->token == 248) {
    {
#line 3431
    var->domain = _glp_mpl_indexing_expression(mpl);
#line 3432
    var->dim = _glp_mpl_domain_arity(mpl, var->domain);
    }
  }
  {
#line 3436
  node = _glp_avl_insert_node(mpl->tree, (void const   *)var->name);
#line 3437
  _glp_avl_set_node_type(node, 127);
#line 3438
  _glp_avl_set_node_link(node, (void *)var);
  }
  {
#line 3441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3442
    if (mpl->token == 239) {
      {
#line 3443
      _glp_mpl_get_token(mpl);
      }
    } else
#line 3444
    if (mpl->token == 241) {
#line 3445
      goto while_break;
    }
    {
#line 3446
    tmp___16 = _glp_mpl_is_keyword(mpl, (char *)"integer");
    }
#line 3446
    if (tmp___16) {
#line 3447
      if (integer_used) {
        {
#line 3448
        _glp_mpl_error(mpl, (char *)"at most one integer allowed");
        }
      }
#line 3449
      if (var->type != 101) {
#line 3449
        var->type = 113;
      }
      {
#line 3450
      integer_used = 1;
#line 3451
      _glp_mpl_get_token(mpl);
      }
    } else {
      {
#line 3453
      tmp___15 = _glp_mpl_is_keyword(mpl, (char *)"binary");
      }
#line 3453
      if (tmp___15) {
        bin: 
#line 3454
        if (binary_used) {
          {
#line 3455
          _glp_mpl_error(mpl, (char *)"at most one binary allowed");
          }
        }
        {
#line 3456
        var->type = 101;
#line 3457
        binary_used = 1;
#line 3458
        _glp_mpl_get_token(mpl);
        }
      } else {
        {
#line 3460
        tmp___14 = _glp_mpl_is_keyword(mpl, (char *)"logical");
        }
#line 3460
        if (tmp___14) {
#line 3461
          if (! mpl->as_binary) {
            {
#line 3462
            _glp_mpl_warning(mpl, (char *)"keyword logical understood as binary");
#line 3463
            mpl->as_binary = 1;
            }
          }
#line 3465
          goto bin;
        } else {
          {
#line 3467
          tmp___13 = _glp_mpl_is_keyword(mpl, (char *)"symbolic");
          }
#line 3467
          if (tmp___13) {
            {
#line 3468
            _glp_mpl_error(mpl, (char *)"variable cannot be symbolic");
            }
          } else
#line 3469
          if (mpl->token == 233) {
#line 3471
            if ((unsigned long )var->lbnd != (unsigned long )((void *)0)) {
#line 3472
              if ((unsigned long )var->lbnd == (unsigned long )var->ubnd) {
                {
#line 3473
                _glp_mpl_error(mpl, (char *)"both fixed value and lower bound not allowed");
                }
              } else {
                {
#line 3476
                _glp_mpl_error(mpl, (char *)"at most one lower bound allowed");
                }
              }
            }
            {
#line 3478
            _glp_mpl_get_token(mpl);
#line 3480
            var->lbnd = _glp_mpl_expression_5(mpl);
            }
#line 3481
            if ((var->lbnd)->type == 124) {
              {
#line 3482
              var->lbnd = _glp_mpl_make_unary(mpl, 315, var->lbnd, 118, 0);
              }
            }
#line 3484
            if ((var->lbnd)->type != 118) {
              {
#line 3485
              _glp_mpl_error(mpl, (char *)"expression following >= has invalid type");
              }
            }
#line 3486
            if ((var->lbnd)->dim == 0) {
#line 3486
              tmp___8 = 1;
            } else {
              {
#line 3486
              _glp_lib_xassert("var->lbnd->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3486);
#line 3486
              tmp___8 = 1;
              }
            }
          } else
#line 3488
          if (mpl->token == 231) {
#line 3490
            if ((unsigned long )var->ubnd != (unsigned long )((void *)0)) {
#line 3491
              if ((unsigned long )var->ubnd == (unsigned long )var->lbnd) {
                {
#line 3492
                _glp_mpl_error(mpl, (char *)"both fixed value and upper bound not allowed");
                }
              } else {
                {
#line 3495
                _glp_mpl_error(mpl, (char *)"at most one upper bound allowed");
                }
              }
            }
            {
#line 3497
            _glp_mpl_get_token(mpl);
#line 3499
            var->ubnd = _glp_mpl_expression_5(mpl);
            }
#line 3500
            if ((var->ubnd)->type == 124) {
              {
#line 3501
              var->ubnd = _glp_mpl_make_unary(mpl, 315, var->ubnd, 118, 0);
              }
            }
#line 3503
            if ((var->ubnd)->type != 118) {
              {
#line 3504
              _glp_mpl_error(mpl, (char *)"expression following <= has invalid type");
              }
            }
#line 3505
            if ((var->ubnd)->dim == 0) {
#line 3505
              tmp___9 = 1;
            } else {
              {
#line 3505
              _glp_lib_xassert("var->ubnd->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3505);
#line 3505
              tmp___9 = 1;
              }
            }
          } else
#line 3507
          if (mpl->token == 232) {
#line 3510
            if ((unsigned long )var->lbnd == (unsigned long )((void *)0)) {
#line 3510
              if (! ((unsigned long )var->ubnd == (unsigned long )((void *)0))) {
#line 3510
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 3511
            if ((unsigned long )var->lbnd == (unsigned long )var->ubnd) {
              {
#line 3512
              _glp_mpl_error(mpl, (char *)"at most one fixed value allowed");
              }
            } else
#line 3513
            if ((unsigned long )var->lbnd != (unsigned long )((void *)0)) {
              {
#line 3514
              _glp_mpl_error(mpl, (char *)"both lower bound and fixed value not allowed");
              }
            } else {
              {
#line 3517
              _glp_mpl_error(mpl, (char *)"both upper bound and fixed value not allowed");
              }
            }
            {
#line 3520
            strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 3521
            tmp___10 = strlen((char const   *)(opstr));
            }
#line 3521
            if ((unsigned long )tmp___10 < sizeof(opstr)) {
#line 3521
              tmp___11 = 1;
            } else {
              {
#line 3521
              _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3521);
#line 3521
              tmp___11 = 1;
              }
            }
            {
#line 3522
            _glp_mpl_get_token(mpl);
#line 3524
            var->lbnd = _glp_mpl_expression_5(mpl);
            }
#line 3525
            if ((var->lbnd)->type == 124) {
              {
#line 3526
              var->lbnd = _glp_mpl_make_unary(mpl, 315, var->lbnd, 118, 0);
              }
            }
#line 3528
            if ((var->lbnd)->type != 118) {
              {
#line 3529
              _glp_mpl_error(mpl, (char *)"expression following %s has invalid type",
                             opstr);
              }
            }
#line 3531
            if ((var->lbnd)->dim == 0) {
#line 3531
              tmp___12 = 1;
            } else {
              {
#line 3531
              _glp_lib_xassert("var->lbnd->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                               3531);
#line 3531
              tmp___12 = 1;
              }
            }
#line 3533
            var->ubnd = var->lbnd;
          } else
#line 3535
          if (mpl->token == 230) {
            {
#line 3537
            _glp_mpl_error(mpl, (char *)"strict bound not allowed");
            }
          } else
#line 3535
          if (mpl->token == 234) {
            {
#line 3537
            _glp_mpl_error(mpl, (char *)"strict bound not allowed");
            }
          } else
#line 3535
          if (mpl->token == 235) {
            {
#line 3537
            _glp_mpl_error(mpl, (char *)"strict bound not allowed");
            }
          } else {
            {
#line 3539
            _glp_mpl_error(mpl, (char *)"syntax error in variable statement");
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3542
  if ((unsigned long )var->domain != (unsigned long )((void *)0)) {
    {
#line 3542
    _glp_mpl_close_scope(mpl, var->domain);
    }
  }
#line 3544
  if (mpl->token == 241) {
#line 3544
    tmp___17 = 1;
  } else {
    {
#line 3544
    _glp_lib_xassert("mpl->token == T_SEMICOLON", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3544);
#line 3544
    tmp___17 = 1;
    }
  }
  {
#line 3545
  _glp_mpl_get_token(mpl);
  }
#line 3546
  return (var);
}
}
#line 3573 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CONSTRAINT *_glp_mpl_constraint_statement(MPL *mpl ) 
{ 
  CONSTRAINT *con ;
  CODE *first ;
  CODE *second ;
  CODE *third ;
  int rho ;
  char opstr[8] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  AVLNODE *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  AVLNODE *node ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
#line 3578
  if (mpl->flag_s) {
    {
#line 3579
    _glp_mpl_error(mpl, (char *)"constraint statement must precede solve statement");
    }
  }
  {
#line 3581
  tmp___2 = _glp_mpl_is_keyword(mpl, (char *)"subject");
  }
#line 3581
  if (tmp___2) {
    {
#line 3582
    _glp_mpl_get_token(mpl);
#line 3583
    tmp = _glp_mpl_is_keyword(mpl, (char *)"to");
    }
#line 3583
    if (! tmp) {
      {
#line 3584
      _glp_mpl_error(mpl, (char *)"keyword subject to incomplete");
      }
    }
    {
#line 3585
    _glp_mpl_get_token(mpl);
    }
  } else {
    {
#line 3587
    tmp___1 = _glp_mpl_is_keyword(mpl, (char *)"subj");
    }
#line 3587
    if (tmp___1) {
      {
#line 3588
      _glp_mpl_get_token(mpl);
#line 3589
      tmp___0 = _glp_mpl_is_keyword(mpl, (char *)"to");
      }
#line 3589
      if (! tmp___0) {
        {
#line 3590
        _glp_mpl_error(mpl, (char *)"keyword subj to incomplete");
        }
      }
      {
#line 3591
      _glp_mpl_get_token(mpl);
      }
    } else
#line 3593
    if (mpl->token == 220) {
      {
#line 3594
      _glp_mpl_get_token(mpl);
      }
    }
  }
#line 3596
  if (! (mpl->token == 202)) {
    {
#line 3598
    tmp___3 = _glp_mpl_is_reserved(mpl);
    }
#line 3598
    if (tmp___3) {
      {
#line 3599
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
      {
#line 3601
      _glp_mpl_error(mpl, (char *)"symbolic name missing where expected");
      }
    }
  }
  {
#line 3603
  tmp___4 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
  }
#line 3603
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 3604
    _glp_mpl_error(mpl, (char *)"%s multiply declared", mpl->image);
    }
  }
  {
#line 3606
  tmp___5 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(CONSTRAINT ));
#line 3606
  con = (CONSTRAINT *)tmp___5;
#line 3607
  tmp___6 = strlen((char const   *)mpl->image);
#line 3607
  tmp___7 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___6 + 1U));
#line 3607
  con->name = (char *)tmp___7;
#line 3608
  strcpy((char */* __restrict  */)con->name, (char const   */* __restrict  */)mpl->image);
#line 3609
  con->alias = (char *)((void *)0);
#line 3610
  con->dim = 0;
#line 3611
  con->domain = (DOMAIN1 *)((void *)0);
#line 3612
  con->type = 103;
#line 3613
  con->code = (CODE *)((void *)0);
#line 3614
  con->lbnd = (CODE *)((void *)0);
#line 3615
  con->ubnd = (CODE *)((void *)0);
#line 3616
  con->array = (ARRAY *)((void *)0);
#line 3617
  _glp_mpl_get_token(mpl);
  }
#line 3619
  if (mpl->token == 205) {
    {
#line 3620
    tmp___8 = strlen((char const   *)mpl->image);
#line 3620
    tmp___9 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___8 + 1U));
#line 3620
    con->alias = (char *)tmp___9;
#line 3621
    strcpy((char */* __restrict  */)con->alias, (char const   */* __restrict  */)mpl->image);
#line 3622
    _glp_mpl_get_token(mpl);
    }
  }
#line 3625
  if (mpl->token == 248) {
    {
#line 3626
    con->domain = _glp_mpl_indexing_expression(mpl);
#line 3627
    con->dim = _glp_mpl_domain_arity(mpl, con->domain);
    }
  }
  {
#line 3631
  node = _glp_avl_insert_node(mpl->tree, (void const   *)con->name);
#line 3632
  _glp_avl_set_node_type(node, 103);
#line 3633
  _glp_avl_set_node_link(node, (void *)con);
  }
#line 3636
  if (mpl->token != 240) {
    {
#line 3637
    _glp_mpl_error(mpl, (char *)"colon missing where expected");
    }
  }
  {
#line 3638
  _glp_mpl_get_token(mpl);
#line 3640
  first = _glp_mpl_expression_5(mpl);
  }
#line 3641
  if (first->type == 124) {
    {
#line 3642
    first = _glp_mpl_make_unary(mpl, 315, first, 118, 0);
    }
  }
#line 3643
  if (! (first->type == 118)) {
#line 3643
    if (! (first->type == 110)) {
      {
#line 3644
      _glp_mpl_error(mpl, (char *)"expression following colon has invalid type");
      }
    }
  }
#line 3645
  if (first->dim == 0) {
#line 3645
    tmp___10 = 1;
  } else {
    {
#line 3645
    _glp_lib_xassert("first->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3645);
#line 3645
    tmp___10 = 1;
    }
  }
#line 3647
  if (mpl->token == 239) {
    {
#line 3647
    _glp_mpl_get_token(mpl);
    }
  }
  {
#line 3651
  if (mpl->token == 232) {
#line 3651
    goto case_232;
  }
#line 3651
  if (mpl->token == 233) {
#line 3651
    goto case_232;
  }
#line 3651
  if (mpl->token == 231) {
#line 3651
    goto case_232;
  }
#line 3655
  if (mpl->token == 235) {
#line 3655
    goto case_235;
  }
#line 3655
  if (mpl->token == 234) {
#line 3655
    goto case_235;
  }
#line 3655
  if (mpl->token == 230) {
#line 3655
    goto case_235;
  }
#line 3657
  if (mpl->token == 241) {
#line 3657
    goto case_241;
  }
#line 3659
  goto switch_default;
  case_232: /* CIL Label */ 
  case_233: /* CIL Label */ 
  case_231: /* CIL Label */ 
#line 3652
  goto switch_break;
  case_235: /* CIL Label */ 
  case_234: /* CIL Label */ 
  case_230: /* CIL Label */ 
  {
#line 3656
  _glp_mpl_error(mpl, (char *)"strict inequality not allowed");
  }
  case_241: /* CIL Label */ 
  {
#line 3658
  _glp_mpl_error(mpl, (char *)"constraint must be equality or inequality");
  }
  switch_default: /* CIL Label */ 
#line 3660
  goto err;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3662
  rho = mpl->token;
#line 3663
  strcpy((char */* __restrict  */)(opstr), (char const   */* __restrict  */)mpl->image);
#line 3664
  tmp___11 = strlen((char const   *)(opstr));
  }
#line 3664
  if ((unsigned long )tmp___11 < sizeof(opstr)) {
#line 3664
    tmp___12 = 1;
  } else {
    {
#line 3664
    _glp_lib_xassert("strlen(opstr) < sizeof(opstr)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3664);
#line 3664
    tmp___12 = 1;
    }
  }
  {
#line 3665
  _glp_mpl_get_token(mpl);
#line 3667
  second = _glp_mpl_expression_5(mpl);
  }
#line 3668
  if (second->type == 124) {
    {
#line 3669
    second = _glp_mpl_make_unary(mpl, 315, second, 118, 0);
    }
  }
#line 3670
  if (! (second->type == 118)) {
#line 3670
    if (! (second->type == 110)) {
      {
#line 3671
      _glp_mpl_error(mpl, (char *)"expression following %s has invalid type", opstr);
      }
    }
  }
#line 3672
  if (second->dim == 0) {
#line 3672
    tmp___13 = 1;
  } else {
    {
#line 3672
    _glp_lib_xassert("second->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3672);
#line 3672
    tmp___13 = 1;
    }
  }
#line 3674
  if (mpl->token == 239) {
    {
#line 3675
    _glp_mpl_get_token(mpl);
    }
#line 3676
    if (mpl->token == 241) {
#line 3676
      goto err;
    }
  }
#line 3678
  if (mpl->token == 230) {
#line 3678
    goto _L;
  } else
#line 3678
  if (mpl->token == 231) {
#line 3678
    goto _L;
  } else
#line 3678
  if (mpl->token == 232) {
#line 3678
    goto _L;
  } else
#line 3678
  if (mpl->token == 233) {
#line 3678
    goto _L;
  } else
#line 3678
  if (mpl->token == 234) {
#line 3678
    goto _L;
  } else
#line 3678
  if (mpl->token == 235) {
    _L: /* CIL Label */ 
#line 3683
    if (rho == 232) {
      {
#line 3684
      _glp_mpl_error(mpl, (char *)"double inequality must be ... <= ... <= ... or ... >= ... >= ...");
      }
    } else
#line 3683
    if (mpl->token != rho) {
      {
#line 3684
      _glp_mpl_error(mpl, (char *)"double inequality must be ... <= ... <= ... or ... >= ... >= ...");
      }
    }
#line 3687
    if (first->type == 110) {
      {
#line 3688
      _glp_mpl_error(mpl, (char *)"leftmost expression in double inequality cannot be linear form");
      }
    }
    {
#line 3690
    _glp_mpl_get_token(mpl);
#line 3692
    third = _glp_mpl_expression_5(mpl);
    }
#line 3693
    if (third->type == 124) {
      {
#line 3694
      third = _glp_mpl_make_unary(mpl, 315, second, 118, 0);
      }
    }
#line 3695
    if (! (third->type == 118)) {
#line 3695
      if (! (third->type == 110)) {
        {
#line 3696
        _glp_mpl_error(mpl, (char *)"rightmost expression in double inequality constraint has invalid type");
        }
      }
    }
#line 3698
    if (third->dim == 0) {
#line 3698
      tmp___14 = 1;
    } else {
      {
#line 3698
      _glp_lib_xassert("third->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       3698);
#line 3698
      tmp___14 = 1;
      }
    }
#line 3700
    if (third->type == 110) {
      {
#line 3701
      _glp_mpl_error(mpl, (char *)"rightmost expression in double inequality cannot be linear form");
      }
    }
  } else {
#line 3706
    third = (CODE *)((void *)0);
  }
#line 3709
  if ((unsigned long )con->domain != (unsigned long )((void *)0)) {
    {
#line 3709
    _glp_mpl_close_scope(mpl, con->domain);
    }
  }
#line 3711
  if (first->type != 110) {
    {
#line 3712
    first = _glp_mpl_make_unary(mpl, 319, first, 110, 0);
    }
  }
#line 3713
  if (second->type != 110) {
    {
#line 3714
    second = _glp_mpl_make_unary(mpl, 319, second, 110, 0);
    }
  }
#line 3715
  if ((unsigned long )third != (unsigned long )((void *)0)) {
    {
#line 3716
    third = _glp_mpl_make_unary(mpl, 319, third, 110, 0);
    }
  }
#line 3718
  if ((unsigned long )third == (unsigned long )((void *)0)) {
    {
#line 3721
    if (rho == 231) {
#line 3721
      goto case_231___0;
    }
#line 3727
    if (rho == 233) {
#line 3727
      goto case_233___0;
    }
#line 3733
    if (rho == 232) {
#line 3733
      goto case_232___0;
    }
#line 3739
    goto switch_default___0;
    case_231___0: /* CIL Label */ 
#line 3723
    con->code = first;
#line 3724
    con->lbnd = (CODE *)((void *)0);
#line 3725
    con->ubnd = second;
#line 3726
    goto switch_break___0;
    case_233___0: /* CIL Label */ 
#line 3729
    con->code = first;
#line 3730
    con->lbnd = second;
#line 3731
    con->ubnd = (CODE *)((void *)0);
#line 3732
    goto switch_break___0;
    case_232___0: /* CIL Label */ 
#line 3735
    con->code = first;
#line 3736
    con->lbnd = second;
#line 3737
    con->ubnd = second;
#line 3738
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 3740
    if (rho != rho) {
#line 3740
      tmp___15 = 1;
    } else {
      {
#line 3740
      _glp_lib_xassert("rho != rho", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       3740);
#line 3740
      tmp___15 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 3746
    if (rho == 231) {
#line 3746
      goto case_231___1;
    }
#line 3752
    if (rho == 233) {
#line 3752
      goto case_233___1;
    }
#line 3758
    goto switch_default___1;
    case_231___1: /* CIL Label */ 
#line 3748
    con->code = second;
#line 3749
    con->lbnd = first;
#line 3750
    con->ubnd = third;
#line 3751
    goto switch_break___1;
    case_233___1: /* CIL Label */ 
#line 3754
    con->code = second;
#line 3755
    con->lbnd = third;
#line 3756
    con->ubnd = first;
#line 3757
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 3759
    if (rho != rho) {
#line 3759
      tmp___16 = 1;
    } else {
      {
#line 3759
      _glp_lib_xassert("rho != rho", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       3759);
#line 3759
      tmp___16 = 1;
      }
    }
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 3763
  if (mpl->token != 241) {
    err: 
    {
#line 3764
    _glp_mpl_error(mpl, (char *)"syntax error in constraint statement");
    }
  }
  {
#line 3765
  _glp_mpl_get_token(mpl);
  }
#line 3766
  return (con);
}
}
#line 3784 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CONSTRAINT *_glp_mpl_objective_statement(MPL *mpl ) 
{ 
  CONSTRAINT *obj ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  AVLNODE *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  AVLNODE *node ;
  int tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 3787
  tmp___1 = _glp_mpl_is_keyword(mpl, (char *)"minimize");
  }
#line 3787
  if (tmp___1) {
#line 3788
    type = 116;
  } else {
    {
#line 3789
    tmp___0 = _glp_mpl_is_keyword(mpl, (char *)"maximize");
    }
#line 3789
    if (tmp___0) {
#line 3790
      type = 115;
    } else
#line 3792
    if ((unsigned long )mpl != (unsigned long )mpl) {
#line 3792
      tmp = 1;
    } else {
      {
#line 3792
      _glp_lib_xassert("mpl != mpl", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                       3792);
#line 3792
      tmp = 1;
      }
    }
  }
#line 3793
  if (mpl->flag_s) {
    {
#line 3794
    _glp_mpl_error(mpl, (char *)"objective statement must precede solve statement");
    }
  }
  {
#line 3795
  _glp_mpl_get_token(mpl);
  }
#line 3797
  if (! (mpl->token == 202)) {
    {
#line 3799
    tmp___2 = _glp_mpl_is_reserved(mpl);
    }
#line 3799
    if (tmp___2) {
      {
#line 3800
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
      {
#line 3802
      _glp_mpl_error(mpl, (char *)"symbolic name missing where expected");
      }
    }
  }
  {
#line 3804
  tmp___3 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
  }
#line 3804
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
    {
#line 3805
    _glp_mpl_error(mpl, (char *)"%s multiply declared", mpl->image);
    }
  }
  {
#line 3807
  tmp___4 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(CONSTRAINT ));
#line 3807
  obj = (CONSTRAINT *)tmp___4;
#line 3808
  tmp___5 = strlen((char const   *)mpl->image);
#line 3808
  tmp___6 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___5 + 1U));
#line 3808
  obj->name = (char *)tmp___6;
#line 3809
  strcpy((char */* __restrict  */)obj->name, (char const   */* __restrict  */)mpl->image);
#line 3810
  obj->alias = (char *)((void *)0);
#line 3811
  obj->dim = 0;
#line 3812
  obj->domain = (DOMAIN1 *)((void *)0);
#line 3813
  obj->type = type;
#line 3814
  obj->code = (CODE *)((void *)0);
#line 3815
  obj->lbnd = (CODE *)((void *)0);
#line 3816
  obj->ubnd = (CODE *)((void *)0);
#line 3817
  obj->array = (ARRAY *)((void *)0);
#line 3818
  _glp_mpl_get_token(mpl);
  }
#line 3820
  if (mpl->token == 205) {
    {
#line 3821
    tmp___7 = strlen((char const   *)mpl->image);
#line 3821
    tmp___8 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___7 + 1U));
#line 3821
    obj->alias = (char *)tmp___8;
#line 3822
    strcpy((char */* __restrict  */)obj->alias, (char const   */* __restrict  */)mpl->image);
#line 3823
    _glp_mpl_get_token(mpl);
    }
  }
#line 3826
  if (mpl->token == 248) {
    {
#line 3827
    obj->domain = _glp_mpl_indexing_expression(mpl);
#line 3828
    obj->dim = _glp_mpl_domain_arity(mpl, obj->domain);
    }
  }
  {
#line 3832
  node = _glp_avl_insert_node(mpl->tree, (void const   *)obj->name);
#line 3833
  _glp_avl_set_node_type(node, 103);
#line 3834
  _glp_avl_set_node_link(node, (void *)obj);
  }
#line 3837
  if (mpl->token != 240) {
    {
#line 3838
    _glp_mpl_error(mpl, (char *)"colon missing where expected");
    }
  }
  {
#line 3839
  _glp_mpl_get_token(mpl);
#line 3841
  obj->code = _glp_mpl_expression_5(mpl);
  }
#line 3842
  if ((obj->code)->type == 124) {
    {
#line 3843
    obj->code = _glp_mpl_make_unary(mpl, 315, obj->code, 118, 0);
    }
  }
#line 3844
  if ((obj->code)->type == 118) {
    {
#line 3845
    obj->code = _glp_mpl_make_unary(mpl, 319, obj->code, 110, 0);
    }
  }
#line 3846
  if ((obj->code)->type != 110) {
    {
#line 3847
    _glp_mpl_error(mpl, (char *)"expression following colon has invalid type");
    }
  }
#line 3848
  if ((obj->code)->dim == 0) {
#line 3848
    tmp___9 = 1;
  } else {
    {
#line 3848
    _glp_lib_xassert("obj->code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3848);
#line 3848
    tmp___9 = 1;
    }
  }
#line 3850
  if ((unsigned long )obj->domain != (unsigned long )((void *)0)) {
    {
#line 3850
    _glp_mpl_close_scope(mpl, obj->domain);
    }
  }
#line 3852
  if (mpl->token != 241) {
    {
#line 3853
    _glp_mpl_error(mpl, (char *)"syntax error in objective statement");
    }
  }
  {
#line 3854
  _glp_mpl_get_token(mpl);
  }
#line 3855
  return (obj);
}
}
#line 3893 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
TABLE *_glp_mpl_table_statement(MPL *mpl ) 
{ 
  TABLE *tab ;
  TABARG *last_arg ;
  TABARG *arg ;
  TABFLD *last_fld ;
  TABFLD *fld ;
  TABIN *last_in ;
  TABIN *in ;
  TABOUT *last_out ;
  TABOUT *out ;
  AVLNODE *node ;
  int nflds ;
  char name[101] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  AVLNODE *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  char const   *tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  size_t tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;

  {
  {
#line 3902
  tmp = _glp_mpl_is_keyword(mpl, (char *)"table");
  }
#line 3902
  if (tmp) {
#line 3902
    tmp___0 = 1;
  } else {
    {
#line 3902
    _glp_lib_xassert("is_keyword(mpl, \"table\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3902);
#line 3902
    tmp___0 = 1;
    }
  }
  {
#line 3903
  _glp_mpl_get_token(mpl);
  }
#line 3905
  if (! (mpl->token == 202)) {
    {
#line 3907
    tmp___1 = _glp_mpl_is_reserved(mpl);
    }
#line 3907
    if (tmp___1) {
      {
#line 3908
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
      {
#line 3910
      _glp_mpl_error(mpl, (char *)"symbolic name missing where expected");
      }
    }
  }
  {
#line 3912
  tmp___2 = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
  }
#line 3912
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 3913
    _glp_mpl_error(mpl, (char *)"%s multiply declared", mpl->image);
    }
  }
  {
#line 3915
  tmp___3 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(TABLE ));
#line 3915
  tab = (TABLE *)tmp___3;
#line 3916
  tmp___4 = strlen((char const   *)mpl->image);
#line 3916
  tmp___5 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___4 + 1U));
#line 3916
  tab->name = (char *)tmp___5;
#line 3917
  strcpy((char */* __restrict  */)tab->name, (char const   */* __restrict  */)mpl->image);
#line 3918
  _glp_mpl_get_token(mpl);
  }
#line 3920
  if (mpl->token == 205) {
    {
#line 3921
    tmp___6 = strlen((char const   *)mpl->image);
#line 3921
    tmp___7 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___6 + 1U));
#line 3921
    tab->alias = (char *)tmp___7;
#line 3922
    strcpy((char */* __restrict  */)tab->alias, (char const   */* __restrict  */)mpl->image);
#line 3923
    _glp_mpl_get_token(mpl);
    }
  } else {
#line 3926
    tab->alias = (char *)((void *)0);
  }
#line 3928
  if (mpl->token == 248) {
    {
#line 3930
    tab->type = 119;
#line 3931
    tab->u.out.domain = _glp_mpl_indexing_expression(mpl);
#line 3932
    tmp___8 = _glp_mpl_is_keyword(mpl, (char *)"OUT");
    }
#line 3932
    if (! tmp___8) {
      {
#line 3933
      _glp_mpl_error(mpl, (char *)"keyword OUT missing where expected");
      }
    }
    {
#line 3934
    _glp_mpl_get_token(mpl);
    }
  } else {
    {
#line 3938
    tab->type = 112;
#line 3939
    tmp___9 = _glp_mpl_is_keyword(mpl, (char *)"IN");
    }
#line 3939
    if (! tmp___9) {
      {
#line 3940
      _glp_mpl_error(mpl, (char *)"keyword IN missing where expected");
      }
    }
    {
#line 3941
    _glp_mpl_get_token(mpl);
    }
  }
#line 3944
  last_arg = (TABARG *)((void *)0);
#line 3944
  tab->arg = last_arg;
  {
#line 3945
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3947
    tmp___10 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(TABARG ));
#line 3947
    arg = (TABARG *)tmp___10;
    }
#line 3949
    if (mpl->token == 239) {
      {
#line 3951
      _glp_mpl_error(mpl, (char *)"argument expression missing where expected");
      }
    } else
#line 3949
    if (mpl->token == 240) {
      {
#line 3951
      _glp_mpl_error(mpl, (char *)"argument expression missing where expected");
      }
    } else
#line 3949
    if (mpl->token == 241) {
      {
#line 3951
      _glp_mpl_error(mpl, (char *)"argument expression missing where expected");
      }
    }
    {
#line 3952
    arg->code = _glp_mpl_expression_5(mpl);
    }
#line 3954
    if ((arg->code)->type == 118) {
      {
#line 3955
      arg->code = _glp_mpl_make_unary(mpl, 316, arg->code, 124, 0);
      }
    }
#line 3958
    if ((arg->code)->type != 124) {
      {
#line 3959
      _glp_mpl_error(mpl, (char *)"argument expression has invalid type");
      }
    }
#line 3961
    arg->next = (TABARG *)((void *)0);
#line 3962
    if ((unsigned long )last_arg == (unsigned long )((void *)0)) {
#line 3963
      tab->arg = arg;
    } else {
#line 3965
      last_arg->next = arg;
    }
#line 3966
    last_arg = arg;
#line 3968
    if (mpl->token == 239) {
      {
#line 3969
      _glp_mpl_get_token(mpl);
      }
    } else
#line 3970
    if (mpl->token == 240) {
#line 3971
      goto while_break;
    } else
#line 3970
    if (mpl->token == 241) {
#line 3971
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3973
  if ((unsigned long )tab->arg != (unsigned long )((void *)0)) {
#line 3973
    tmp___11 = 1;
  } else {
    {
#line 3973
    _glp_lib_xassert("tab->arg != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3973);
#line 3973
    tmp___11 = 1;
    }
  }
#line 3975
  if (mpl->token == 240) {
    {
#line 3976
    _glp_mpl_get_token(mpl);
    }
  } else {
    {
#line 3978
    _glp_mpl_error(mpl, (char *)"colon missing where expected");
    }
  }
  {
#line 3981
  if (tab->type == 112) {
#line 3981
    goto case_112;
  }
#line 3982
  if (tab->type == 119) {
#line 3982
    goto case_119;
  }
#line 3983
  goto switch_default;
  case_112: /* CIL Label */ 
#line 3981
  goto input_table;
  case_119: /* CIL Label */ 
#line 3982
  goto output_table;
  switch_default: /* CIL Label */ 
#line 3983
  if ((unsigned long )tab != (unsigned long )tab) {
#line 3983
    tmp___12 = 1;
  } else {
    {
#line 3983
    _glp_lib_xassert("tab != tab", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     3983);
#line 3983
    tmp___12 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  input_table: 
#line 3987
  if (mpl->token == 202) {
    {
#line 3988
    node = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
    }
#line 3989
    if ((unsigned long )node == (unsigned long )((void *)0)) {
      {
#line 3990
      _glp_mpl_error(mpl, (char *)"%s not defined", mpl->image);
      }
    }
    {
#line 3991
    tmp___13 = _glp_avl_get_node_type(node);
    }
#line 3991
    if (tmp___13 != 122) {
      {
#line 3992
      _glp_mpl_error(mpl, (char *)"%s not a set", mpl->image);
      }
    }
    {
#line 3993
    tmp___14 = _glp_avl_get_node_link(node);
#line 3993
    tab->u.in.set = (SET *)tmp___14;
    }
#line 3994
    if ((unsigned long )(tab->u.in.set)->assign != (unsigned long )((void *)0)) {
      {
#line 3995
      _glp_mpl_error(mpl, (char *)"%s needs no data", mpl->image);
      }
    }
#line 3996
    if ((tab->u.in.set)->dim != 0) {
      {
#line 3997
      _glp_mpl_error(mpl, (char *)"%s must be a simple set", mpl->image);
      }
    }
    {
#line 3998
    _glp_mpl_get_token(mpl);
    }
#line 3999
    if (mpl->token == 252) {
      {
#line 4000
      _glp_mpl_get_token(mpl);
      }
    } else {
      {
#line 4002
      _glp_mpl_error(mpl, (char *)"delimiter <- missing where expected");
      }
    }
  } else {
    {
#line 4004
    tmp___15 = _glp_mpl_is_reserved(mpl);
    }
#line 4004
    if (tmp___15) {
      {
#line 4005
      _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
      }
    } else {
#line 4007
      tab->u.in.set = (SET *)((void *)0);
    }
  }
#line 4009
  last_fld = (TABFLD *)((void *)0);
#line 4009
  tab->u.in.fld = last_fld;
#line 4010
  nflds = 0;
#line 4011
  if (mpl->token == 246) {
    {
#line 4012
    _glp_mpl_get_token(mpl);
    }
  } else {
    {
#line 4014
    _glp_mpl_error(mpl, (char *)"field list missing where expected");
    }
  }
  {
#line 4015
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 4017
    tmp___16 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(TABFLD ));
#line 4017
    fld = (TABFLD *)tmp___16;
    }
#line 4019
    if (! (mpl->token == 202)) {
      {
#line 4021
      tmp___17 = _glp_mpl_is_reserved(mpl);
      }
#line 4021
      if (tmp___17) {
        {
#line 4022
        _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
        }
      } else {
        {
#line 4025
        _glp_mpl_error(mpl, (char *)"field name missing where expected");
        }
      }
    }
    {
#line 4026
    tmp___18 = strlen((char const   *)mpl->image);
#line 4026
    tmp___19 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___18 + 1U));
#line 4026
    fld->name = (char *)tmp___19;
#line 4027
    strcpy((char */* __restrict  */)fld->name, (char const   */* __restrict  */)mpl->image);
#line 4028
    _glp_mpl_get_token(mpl);
#line 4030
    fld->next = (TABFLD *)((void *)0);
    }
#line 4031
    if ((unsigned long )last_fld == (unsigned long )((void *)0)) {
#line 4032
      tab->u.in.fld = fld;
    } else {
#line 4034
      last_fld->next = fld;
    }
#line 4035
    last_fld = fld;
#line 4036
    nflds ++;
#line 4038
    if (mpl->token == 239) {
      {
#line 4039
      _glp_mpl_get_token(mpl);
      }
    } else
#line 4040
    if (mpl->token == 247) {
#line 4041
      goto while_break___0;
    } else {
      {
#line 4043
      _glp_mpl_error(mpl, (char *)"syntax error in field list");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4046
  if ((unsigned long )tab->u.in.set != (unsigned long )((void *)0)) {
#line 4046
    if ((tab->u.in.set)->dimen != nflds) {
#line 4047
      if ((tab->u.in.set)->dimen == 1) {
#line 4047
        tmp___20 = "";
      } else {
#line 4047
        tmp___20 = "s";
      }
      {
#line 4047
      _glp_mpl_error(mpl, (char *)"there must be %d field%s rather than %d", (tab->u.in.set)->dimen,
                     tmp___20, nflds);
      }
    }
  }
  {
#line 4050
  _glp_mpl_get_token(mpl);
#line 4052
  last_in = (TABIN *)((void *)0);
#line 4052
  tab->u.in.list = last_in;
  }
  {
#line 4053
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4053
    if (! (mpl->token == 239)) {
#line 4053
      goto while_break___1;
    }
    {
#line 4054
    _glp_mpl_get_token(mpl);
#line 4056
    tmp___21 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(TABIN ));
#line 4056
    in = (TABIN *)tmp___21;
    }
#line 4058
    if (! (mpl->token == 202)) {
      {
#line 4060
      tmp___22 = _glp_mpl_is_reserved(mpl);
      }
#line 4060
      if (tmp___22) {
        {
#line 4061
        _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
        }
      } else {
        {
#line 4064
        _glp_mpl_error(mpl, (char *)"parameter name missing where expected");
        }
      }
    }
    {
#line 4065
    node = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
    }
#line 4066
    if ((unsigned long )node == (unsigned long )((void *)0)) {
      {
#line 4067
      _glp_mpl_error(mpl, (char *)"%s not defined", mpl->image);
      }
    }
    {
#line 4068
    tmp___23 = _glp_avl_get_node_type(node);
    }
#line 4068
    if (tmp___23 != 120) {
      {
#line 4069
      _glp_mpl_error(mpl, (char *)"%s not a parameter", mpl->image);
      }
    }
    {
#line 4070
    tmp___24 = _glp_avl_get_node_link(node);
#line 4070
    in->par = (PARAMETER *)tmp___24;
    }
#line 4071
    if ((in->par)->dim != nflds) {
#line 4072
      if (nflds == 1) {
#line 4072
        tmp___25 = "";
      } else {
#line 4072
        tmp___25 = "s";
      }
      {
#line 4072
      _glp_mpl_error(mpl, (char *)"%s must have %d subscript%s rather than %d", mpl->image,
                     nflds, tmp___25, (in->par)->dim);
      }
    }
#line 4074
    if ((unsigned long )(in->par)->assign != (unsigned long )((void *)0)) {
      {
#line 4075
      _glp_mpl_error(mpl, (char *)"%s needs no data", mpl->image);
      }
    }
    {
#line 4076
    _glp_mpl_get_token(mpl);
    }
#line 4078
    if (mpl->token == 251) {
      {
#line 4079
      _glp_mpl_get_token(mpl);
      }
#line 4081
      if (! (mpl->token == 202)) {
        {
#line 4083
        tmp___26 = _glp_mpl_is_reserved(mpl);
        }
#line 4083
        if (tmp___26) {
          {
#line 4084
          _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
          }
        } else {
          {
#line 4087
          _glp_mpl_error(mpl, (char *)"field name missing where expected");
          }
        }
      }
      {
#line 4088
      tmp___27 = strlen((char const   *)mpl->image);
      }
#line 4088
      if ((unsigned long )tmp___27 < sizeof(name)) {
#line 4088
        tmp___28 = 1;
      } else {
        {
#line 4088
        _glp_lib_xassert("strlen(mpl->image) < sizeof(name)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         4088);
#line 4088
        tmp___28 = 1;
        }
      }
      {
#line 4089
      strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)mpl->image);
#line 4090
      _glp_mpl_get_token(mpl);
      }
    } else {
      {
#line 4094
      tmp___29 = strlen((char const   *)(in->par)->name);
      }
#line 4094
      if ((unsigned long )tmp___29 < sizeof(name)) {
#line 4094
        tmp___30 = 1;
      } else {
        {
#line 4094
        _glp_lib_xassert("strlen(in->par->name) < sizeof(name)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         4094);
#line 4094
        tmp___30 = 1;
        }
      }
      {
#line 4095
      strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(in->par)->name);
      }
    }
    {
#line 4098
    tmp___31 = strlen((char const   *)(name));
#line 4098
    tmp___32 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___31 + 1U));
#line 4098
    in->name = (char *)tmp___32;
#line 4099
    strcpy((char */* __restrict  */)in->name, (char const   */* __restrict  */)(name));
#line 4101
    in->next = (TABIN *)((void *)0);
    }
#line 4102
    if ((unsigned long )last_in == (unsigned long )((void *)0)) {
#line 4103
      tab->u.in.list = in;
    } else {
#line 4105
      last_in->next = in;
    }
#line 4106
    last_in = in;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4108
  goto end_of_table;
  output_table: 
#line 4111
  last_out = (TABOUT *)((void *)0);
#line 4111
  tab->u.out.list = last_out;
  {
#line 4112
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 4114
    tmp___33 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(TABOUT ));
#line 4114
    out = (TABOUT *)tmp___33;
    }
#line 4116
    if (mpl->token == 239) {
      {
#line 4117
      _glp_mpl_error(mpl, (char *)"expression missing where expected");
      }
    } else
#line 4116
    if (mpl->token == 241) {
      {
#line 4117
      _glp_mpl_error(mpl, (char *)"expression missing where expected");
      }
    }
#line 4118
    if (mpl->token == 202) {
      {
#line 4119
      tmp___34 = strlen((char const   *)mpl->image);
      }
#line 4119
      if ((unsigned long )tmp___34 < sizeof(name)) {
#line 4119
        tmp___35 = 1;
      } else {
        {
#line 4119
        _glp_lib_xassert("strlen(mpl->image) < sizeof(name)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         4119);
#line 4119
        tmp___35 = 1;
        }
      }
      {
#line 4120
      strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)mpl->image);
      }
    } else {
#line 4123
      name[0] = (char )'\000';
    }
    {
#line 4124
    out->code = _glp_mpl_expression_5(mpl);
    }
#line 4126
    if (mpl->token == 251) {
      {
#line 4127
      _glp_mpl_get_token(mpl);
      }
#line 4129
      if (! (mpl->token == 202)) {
        {
#line 4131
        tmp___36 = _glp_mpl_is_reserved(mpl);
        }
#line 4131
        if (tmp___36) {
          {
#line 4132
          _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s", mpl->image);
          }
        } else {
          {
#line 4135
          _glp_mpl_error(mpl, (char *)"field name missing where expected");
          }
        }
      }
      {
#line 4136
      tmp___37 = strlen((char const   *)mpl->image);
      }
#line 4136
      if ((unsigned long )tmp___37 < sizeof(name)) {
#line 4136
        tmp___38 = 1;
      } else {
        {
#line 4136
        _glp_lib_xassert("strlen(mpl->image) < sizeof(name)", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         4136);
#line 4136
        tmp___38 = 1;
        }
      }
      {
#line 4137
      strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)mpl->image);
#line 4138
      _glp_mpl_get_token(mpl);
      }
    }
#line 4141
    if ((int )name[0] == 0) {
      {
#line 4142
      _glp_mpl_error(mpl, (char *)"field name required");
      }
    }
    {
#line 4143
    tmp___39 = strlen((char const   *)(name));
#line 4143
    tmp___40 = _glp_dmp_get_atom(mpl->pool, (int )(tmp___39 + 1U));
#line 4143
    out->name = (char *)tmp___40;
#line 4144
    strcpy((char */* __restrict  */)out->name, (char const   */* __restrict  */)(name));
#line 4146
    out->next = (TABOUT *)((void *)0);
    }
#line 4147
    if ((unsigned long )last_out == (unsigned long )((void *)0)) {
#line 4148
      tab->u.out.list = out;
    } else {
#line 4150
      last_out->next = out;
    }
#line 4151
    last_out = out;
#line 4153
    if (mpl->token == 239) {
      {
#line 4154
      _glp_mpl_get_token(mpl);
      }
    } else
#line 4155
    if (mpl->token == 241) {
#line 4156
      goto while_break___2;
    } else {
      {
#line 4158
      _glp_mpl_error(mpl, (char *)"syntax error in output list");
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 4161
  _glp_mpl_close_scope(mpl, tab->u.out.domain);
  }
  end_of_table: 
#line 4164
  if (mpl->token != 241) {
    {
#line 4165
    _glp_mpl_error(mpl, (char *)"syntax error in table statement");
    }
  }
  {
#line 4166
  _glp_mpl_get_token(mpl);
  }
#line 4167
  return (tab);
}
}
#line 4180 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void *_glp_mpl_solve_statement(MPL *mpl ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 4181
  tmp = _glp_mpl_is_keyword(mpl, (char *)"solve");
  }
#line 4181
  if (tmp) {
#line 4181
    tmp___0 = 1;
  } else {
    {
#line 4181
    _glp_lib_xassert("is_keyword(mpl, \"solve\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4181);
#line 4181
    tmp___0 = 1;
    }
  }
#line 4182
  if (mpl->flag_s) {
    {
#line 4183
    _glp_mpl_error(mpl, (char *)"at most one solve statement allowed");
    }
  }
  {
#line 4184
  mpl->flag_s = 1;
#line 4185
  _glp_mpl_get_token(mpl);
  }
#line 4187
  if (mpl->token != 241) {
    {
#line 4188
    _glp_mpl_error(mpl, (char *)"syntax error in solve statement");
    }
  }
  {
#line 4189
  _glp_mpl_get_token(mpl);
  }
#line 4190
  return ((void *)0);
}
}
#line 4204 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
CHECK *_glp_mpl_check_statement(MPL *mpl ) 
{ 
  CHECK *chk ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 4206
  tmp = _glp_mpl_is_keyword(mpl, (char *)"check");
  }
#line 4206
  if (tmp) {
#line 4206
    tmp___0 = 1;
  } else {
    {
#line 4206
    _glp_lib_xassert("is_keyword(mpl, \"check\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4206);
#line 4206
    tmp___0 = 1;
    }
  }
  {
#line 4208
  tmp___1 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(CHECK ));
#line 4208
  chk = (CHECK *)tmp___1;
#line 4209
  chk->domain = (DOMAIN1 *)((void *)0);
#line 4210
  chk->code = (CODE *)((void *)0);
#line 4211
  _glp_mpl_get_token(mpl);
  }
#line 4213
  if (mpl->token == 248) {
    {
#line 4214
    chk->domain = _glp_mpl_indexing_expression(mpl);
    }
  }
#line 4221
  if (mpl->token == 240) {
    {
#line 4221
    _glp_mpl_get_token(mpl);
    }
  }
  {
#line 4223
  chk->code = _glp_mpl_expression_13(mpl);
  }
#line 4224
  if ((chk->code)->type != 114) {
    {
#line 4225
    _glp_mpl_error(mpl, (char *)"expression has invalid type");
    }
  }
#line 4226
  if ((chk->code)->dim == 0) {
#line 4226
    tmp___2 = 1;
  } else {
    {
#line 4226
    _glp_lib_xassert("chk->code->dim == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4226);
#line 4226
    tmp___2 = 1;
    }
  }
#line 4228
  if ((unsigned long )chk->domain != (unsigned long )((void *)0)) {
    {
#line 4228
    _glp_mpl_close_scope(mpl, chk->domain);
    }
  }
#line 4230
  if (mpl->token != 241) {
    {
#line 4231
    _glp_mpl_error(mpl, (char *)"syntax error in check statement");
    }
  }
  {
#line 4232
  _glp_mpl_get_token(mpl);
  }
#line 4233
  return (chk);
}
}
#line 4259 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
DISPLAY *_glp_mpl_display_statement(MPL *mpl ) 
{ 
  DISPLAY *dpy ;
  DISPLAY1 *entry ;
  DISPLAY1 *last_entry ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  AVLNODE *node ;
  int next_token ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  CONSTRAINT *con ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 4262
  tmp = _glp_mpl_is_keyword(mpl, (char *)"display");
  }
#line 4262
  if (tmp) {
#line 4262
    tmp___0 = 1;
  } else {
    {
#line 4262
    _glp_lib_xassert("is_keyword(mpl, \"display\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4262);
#line 4262
    tmp___0 = 1;
    }
  }
  {
#line 4264
  tmp___1 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(DISPLAY ));
#line 4264
  dpy = (DISPLAY *)tmp___1;
#line 4265
  dpy->domain = (DOMAIN1 *)((void *)0);
#line 4266
  last_entry = (DISPLAY1 *)((void *)0);
#line 4266
  dpy->list = last_entry;
#line 4267
  _glp_mpl_get_token(mpl);
  }
#line 4269
  if (mpl->token == 248) {
    {
#line 4270
    dpy->domain = _glp_mpl_indexing_expression(mpl);
    }
  }
#line 4277
  if (mpl->token == 240) {
    {
#line 4277
    _glp_mpl_get_token(mpl);
    }
  }
  {
#line 4279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4281
    tmp___2 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(DISPLAY1 ));
#line 4281
    entry = (DISPLAY1 *)tmp___2;
#line 4282
    entry->type = 0;
#line 4283
    entry->list = (ARG_LIST *)((void *)0);
#line 4284
    entry->next = (DISPLAY1 *)((void *)0);
    }
#line 4286
    if ((unsigned long )dpy->list == (unsigned long )((void *)0)) {
#line 4287
      dpy->list = entry;
    } else {
#line 4289
      last_entry->next = entry;
    }
#line 4290
    last_entry = entry;
#line 4292
    if (mpl->token == 202) {
      {
#line 4295
      _glp_mpl_get_token(mpl);
#line 4296
      next_token = mpl->token;
#line 4297
      _glp_mpl_unget_token(mpl);
      }
#line 4298
      if (! (next_token == 239)) {
#line 4298
        if (! (next_token == 241)) {
#line 4298
          if (! (next_token == 246)) {
#line 4301
            goto expr;
          }
        }
      }
      {
#line 4304
      node = _glp_avl_find_node(mpl->tree, (void const   *)mpl->image);
      }
#line 4305
      if ((unsigned long )node == (unsigned long )((void *)0)) {
        {
#line 4306
        _glp_mpl_error(mpl, (char *)"%s not defined", mpl->image);
        }
      }
#line 4307
      if (next_token == 246) {
        {
#line 4307
        tmp___3 = _glp_avl_get_node_type(node);
        }
#line 4307
        if (tmp___3 != 103) {
#line 4309
          goto expr;
        }
      }
      {
#line 4311
      entry->type = _glp_avl_get_node_type(node);
#line 4312
      tmp___4 = _glp_avl_get_node_type(node);
      }
      {
#line 4313
      if (tmp___4 == 111) {
#line 4313
        goto case_111;
      }
#line 4316
      if (tmp___4 == 122) {
#line 4316
        goto case_122;
      }
#line 4319
      if (tmp___4 == 120) {
#line 4319
        goto case_120;
      }
#line 4322
      if (tmp___4 == 127) {
#line 4322
        goto case_127;
      }
#line 4325
      if (tmp___4 == 103) {
#line 4325
        goto case_103;
      }
#line 4328
      goto switch_default;
      case_111: /* CIL Label */ 
      {
#line 4314
      tmp___5 = _glp_avl_get_node_link(node);
#line 4314
      entry->u.slot = (DOMAIN_SLOT *)tmp___5;
      }
#line 4315
      goto switch_break;
      case_122: /* CIL Label */ 
      {
#line 4317
      tmp___6 = _glp_avl_get_node_link(node);
#line 4317
      entry->u.set = (SET *)tmp___6;
      }
#line 4318
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 4320
      tmp___7 = _glp_avl_get_node_link(node);
#line 4320
      entry->u.par = (PARAMETER *)tmp___7;
      }
#line 4321
      goto switch_break;
      case_127: /* CIL Label */ 
      {
#line 4323
      tmp___8 = _glp_avl_get_node_link(node);
#line 4323
      entry->u.var = (VARIABLE *)tmp___8;
      }
#line 4324
      goto switch_break;
      case_103: /* CIL Label */ 
      {
#line 4326
      tmp___9 = _glp_avl_get_node_link(node);
#line 4326
      entry->u.con = (CONSTRAINT *)tmp___9;
      }
#line 4327
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4329
      if ((unsigned long )node != (unsigned long )node) {
#line 4329
        tmp___10 = 1;
      } else {
        {
#line 4329
        _glp_lib_xassert("node != node", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                         4329);
#line 4329
        tmp___10 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 4331
      _glp_mpl_get_token(mpl);
      }
#line 4333
      if (mpl->token == 246) {
#line 4335
        if (entry->type == 103) {
#line 4335
          tmp___11 = 1;
        } else {
          {
#line 4335
          _glp_lib_xassert("entry->type == A_CONSTRAINT", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           4335);
#line 4335
          tmp___11 = 1;
          }
        }
#line 4336
        con = entry->u.con;
#line 4337
        if (con->dim == 0) {
          {
#line 4338
          _glp_mpl_error(mpl, (char *)"%s cannot be subscripted", con->name);
          }
        }
        {
#line 4339
        _glp_mpl_get_token(mpl);
#line 4340
        entry->list = _glp_mpl_subscript_list(mpl);
#line 4341
        tmp___14 = _glp_mpl_arg_list_len(mpl, entry->list);
        }
#line 4341
        if (con->dim != tmp___14) {
          {
#line 4342
          tmp___12 = _glp_mpl_arg_list_len(mpl, entry->list);
          }
#line 4342
          if (con->dim == 1) {
#line 4342
            tmp___13 = "";
          } else {
#line 4342
            tmp___13 = "s";
          }
          {
#line 4342
          _glp_mpl_error(mpl, (char *)"%s must have %d subscript%s rather than %d",
                         con->name, con->dim, tmp___13, tmp___12);
          }
        }
#line 4346
        if (mpl->token == 247) {
#line 4346
          tmp___15 = 1;
        } else {
          {
#line 4346
          _glp_lib_xassert("mpl->token == T_RBRACKET", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                           4346);
#line 4346
          tmp___15 = 1;
          }
        }
        {
#line 4347
        _glp_mpl_get_token(mpl);
        }
      }
    } else {
      expr: 
      {
#line 4352
      entry->type = 108;
#line 4353
      entry->u.code = _glp_mpl_expression_13(mpl);
      }
    }
#line 4356
    if (mpl->token == 239) {
      {
#line 4357
      _glp_mpl_get_token(mpl);
      }
    } else {
#line 4359
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4362
  if ((unsigned long )dpy->domain != (unsigned long )((void *)0)) {
    {
#line 4362
    _glp_mpl_close_scope(mpl, dpy->domain);
    }
  }
#line 4364
  if (mpl->token != 241) {
    {
#line 4365
    _glp_mpl_error(mpl, (char *)"syntax error in display statement");
    }
  }
  {
#line 4366
  _glp_mpl_get_token(mpl);
  }
#line 4367
  return (dpy);
}
}
#line 4388 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
PRINTF *_glp_mpl_printf_statement(MPL *mpl ) 
{ 
  PRINTF *prt ;
  PRINTF1 *entry ;
  PRINTF1 *last_entry ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 4391
  tmp = _glp_mpl_is_keyword(mpl, (char *)"printf");
  }
#line 4391
  if (tmp) {
#line 4391
    tmp___0 = 1;
  } else {
    {
#line 4391
    _glp_lib_xassert("is_keyword(mpl, \"printf\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4391);
#line 4391
    tmp___0 = 1;
    }
  }
  {
#line 4393
  tmp___1 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(PRINTF ));
#line 4393
  prt = (PRINTF *)tmp___1;
#line 4394
  prt->domain = (DOMAIN1 *)((void *)0);
#line 4395
  prt->fmt = (CODE *)((void *)0);
#line 4396
  last_entry = (PRINTF1 *)((void *)0);
#line 4396
  prt->list = last_entry;
#line 4397
  _glp_mpl_get_token(mpl);
  }
#line 4399
  if (mpl->token == 248) {
    {
#line 4400
    prt->domain = _glp_mpl_indexing_expression(mpl);
    }
  }
#line 4407
  if (mpl->token == 240) {
    {
#line 4407
    _glp_mpl_get_token(mpl);
    }
  }
  {
#line 4409
  prt->fmt = _glp_mpl_expression_5(mpl);
  }
#line 4411
  if ((prt->fmt)->type == 118) {
    {
#line 4412
    prt->fmt = _glp_mpl_make_unary(mpl, 316, prt->fmt, 124, 0);
    }
  }
#line 4414
  if ((prt->fmt)->type != 124) {
    {
#line 4415
    _glp_mpl_error(mpl, (char *)"format expression has invalid type");
    }
  }
  {
#line 4417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4417
    if (! (mpl->token == 239)) {
#line 4417
      goto while_break;
    }
    {
#line 4418
    _glp_mpl_get_token(mpl);
#line 4420
    tmp___2 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(PRINTF1 ));
#line 4420
    entry = (PRINTF1 *)tmp___2;
#line 4421
    entry->code = (CODE *)((void *)0);
#line 4422
    entry->next = (PRINTF1 *)((void *)0);
    }
#line 4424
    if ((unsigned long )prt->list == (unsigned long )((void *)0)) {
#line 4425
      prt->list = entry;
    } else {
#line 4427
      last_entry->next = entry;
    }
    {
#line 4428
    last_entry = entry;
#line 4430
    entry->code = _glp_mpl_expression_9(mpl);
    }
#line 4431
    if (! ((entry->code)->type == 118)) {
#line 4431
      if (! ((entry->code)->type == 124)) {
#line 4431
        if (! ((entry->code)->type == 114)) {
          {
#line 4434
          _glp_mpl_error(mpl, (char *)"only numeric, symbolic, or logical expression allowed");
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4438
  if ((unsigned long )prt->domain != (unsigned long )((void *)0)) {
    {
#line 4438
    _glp_mpl_close_scope(mpl, prt->domain);
    }
  }
#line 4441
  prt->fname = (CODE *)((void *)0);
#line 4441
  prt->app = 0;
#line 4442
  if (mpl->token == 234) {
#line 4442
    goto _L;
  } else
#line 4442
  if (mpl->token == 250) {
    _L: /* CIL Label */ 
    {
#line 4443
    prt->app = mpl->token == 250;
#line 4444
    _glp_mpl_get_token(mpl);
#line 4446
    prt->fname = _glp_mpl_expression_5(mpl);
    }
#line 4448
    if ((prt->fname)->type == 118) {
      {
#line 4449
      prt->fname = _glp_mpl_make_unary(mpl, 316, prt->fname, 124, 0);
      }
    }
#line 4452
    if ((prt->fname)->type != 124) {
      {
#line 4453
      _glp_mpl_error(mpl, (char *)"file name expression has invalid type");
      }
    }
  }
#line 4457
  if (mpl->token != 241) {
    {
#line 4458
    _glp_mpl_error(mpl, (char *)"syntax error in printf statement");
    }
  }
  {
#line 4459
  _glp_mpl_get_token(mpl);
  }
#line 4460
  return (prt);
}
}
#line 4478 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
FOR *_glp_mpl_for_statement(MPL *mpl ) 
{ 
  FOR *fur ;
  STATEMENT *stmt ;
  STATEMENT *last_stmt ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 4481
  tmp = _glp_mpl_is_keyword(mpl, (char *)"for");
  }
#line 4481
  if (tmp) {
#line 4481
    tmp___0 = 1;
  } else {
    {
#line 4481
    _glp_lib_xassert("is_keyword(mpl, \"for\")", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4481);
#line 4481
    tmp___0 = 1;
    }
  }
  {
#line 4483
  tmp___1 = _glp_dmp_get_atom(mpl->pool, (int )sizeof(FOR ));
#line 4483
  fur = (FOR *)tmp___1;
#line 4484
  fur->domain = (DOMAIN1 *)((void *)0);
#line 4485
  last_stmt = (STATEMENT *)((void *)0);
#line 4485
  fur->list = last_stmt;
#line 4486
  _glp_mpl_get_token(mpl);
  }
#line 4488
  if (mpl->token != 248) {
    {
#line 4489
    _glp_mpl_error(mpl, (char *)"indexing expression missing where expected");
    }
  }
  {
#line 4490
  fur->domain = _glp_mpl_indexing_expression(mpl);
  }
#line 4492
  if (mpl->token == 240) {
    {
#line 4492
    _glp_mpl_get_token(mpl);
    }
  }
#line 4494
  if (mpl->token != 248) {
    {
#line 4496
    fur->list = _glp_mpl_simple_statement(mpl, 1);
    }
  } else {
    {
#line 4500
    _glp_mpl_get_token(mpl);
    }
    {
#line 4501
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4501
      if (! (mpl->token != 249)) {
#line 4501
        goto while_break;
      }
      {
#line 4503
      stmt = _glp_mpl_simple_statement(mpl, 1);
      }
#line 4505
      if ((unsigned long )last_stmt == (unsigned long )((void *)0)) {
#line 4506
        fur->list = stmt;
      } else {
#line 4508
        last_stmt->next = stmt;
      }
#line 4509
      last_stmt = stmt;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4511
    _glp_mpl_get_token(mpl);
    }
  }
#line 4514
  if ((unsigned long )fur->domain != (unsigned long )((void *)0)) {
#line 4514
    tmp___2 = 1;
  } else {
    {
#line 4514
    _glp_lib_xassert("fur->domain != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4514);
#line 4514
    tmp___2 = 1;
    }
  }
  {
#line 4515
  _glp_mpl_close_scope(mpl, fur->domain);
  }
#line 4517
  return (fur);
}
}
#line 4527 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_end_statement(MPL *mpl ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4528
  if (! mpl->flag_d) {
    {
#line 4528
    tmp = _glp_mpl_is_keyword(mpl, (char *)"end");
    }
#line 4528
    if (tmp) {
#line 4528
      goto _L;
    } else {
#line 4528
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 4528
  if (mpl->flag_d) {
    {
#line 4528
    tmp___0 = _glp_mpl_is_literal(mpl, (char *)"end");
    }
#line 4528
    if (tmp___0) {
      _L: /* CIL Label */ 
      {
#line 4530
      _glp_mpl_get_token(mpl);
      }
#line 4531
      if (mpl->token == 241) {
        {
#line 4532
        _glp_mpl_get_token(mpl);
        }
      } else {
        {
#line 4534
        _glp_mpl_warning(mpl, (char *)"no semicolon following end statement; missing semicolon inserted");
        }
      }
    } else {
      {
#line 4538
      _glp_mpl_warning(mpl, (char *)"unexpected end of file; missing end statement inserted");
      }
    }
  } else {
    {
#line 4538
    _glp_mpl_warning(mpl, (char *)"unexpected end of file; missing end statement inserted");
    }
  }
#line 4540
  if (mpl->token != 201) {
    {
#line 4541
    _glp_mpl_warning(mpl, (char *)"some text detected beyond end statement; text ignored");
    }
  }
#line 4543
  return;
}
}
#line 4564 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
STATEMENT *_glp_mpl_simple_statement(MPL *mpl , int spec ) 
{ 
  STATEMENT *stmt ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 4566
  tmp = _glp_dmp_get_atom(mpl->pool, (int )sizeof(STATEMENT ));
#line 4566
  stmt = (STATEMENT *)tmp;
#line 4567
  stmt->line = mpl->line;
#line 4568
  stmt->next = (STATEMENT *)((void *)0);
#line 4569
  tmp___13 = _glp_mpl_is_keyword(mpl, (char *)"set");
  }
#line 4569
  if (tmp___13) {
#line 4570
    if (spec) {
      {
#line 4571
      _glp_mpl_error(mpl, (char *)"set statement not allowed here");
      }
    }
    {
#line 4572
    stmt->type = 122;
#line 4573
    stmt->u.set = _glp_mpl_set_statement(mpl);
    }
  } else {
    {
#line 4575
    tmp___12 = _glp_mpl_is_keyword(mpl, (char *)"param");
    }
#line 4575
    if (tmp___12) {
#line 4576
      if (spec) {
        {
#line 4577
        _glp_mpl_error(mpl, (char *)"parameter statement not allowed here");
        }
      }
      {
#line 4578
      stmt->type = 120;
#line 4579
      stmt->u.par = _glp_mpl_parameter_statement(mpl);
      }
    } else {
      {
#line 4581
      tmp___11 = _glp_mpl_is_keyword(mpl, (char *)"var");
      }
#line 4581
      if (tmp___11) {
#line 4582
        if (spec) {
          {
#line 4583
          _glp_mpl_error(mpl, (char *)"variable statement not allowed here");
          }
        }
        {
#line 4584
        stmt->type = 127;
#line 4585
        stmt->u.var = _glp_mpl_variable_statement(mpl);
        }
      } else {
        {
#line 4587
        tmp___9 = _glp_mpl_is_keyword(mpl, (char *)"subject");
        }
#line 4587
        if (tmp___9) {
#line 4587
          goto _L___0;
        } else {
          {
#line 4587
          tmp___10 = _glp_mpl_is_keyword(mpl, (char *)"subj");
          }
#line 4587
          if (tmp___10) {
#line 4587
            goto _L___0;
          } else
#line 4587
          if (mpl->token == 220) {
            _L___0: /* CIL Label */ 
#line 4590
            if (spec) {
              {
#line 4591
              _glp_mpl_error(mpl, (char *)"constraint statement not allowed here");
              }
            }
            {
#line 4592
            stmt->type = 103;
#line 4593
            stmt->u.con = _glp_mpl_constraint_statement(mpl);
            }
          } else {
            {
#line 4595
            tmp___7 = _glp_mpl_is_keyword(mpl, (char *)"minimize");
            }
#line 4595
            if (tmp___7) {
#line 4595
              goto _L;
            } else {
              {
#line 4595
              tmp___8 = _glp_mpl_is_keyword(mpl, (char *)"maximize");
              }
#line 4595
              if (tmp___8) {
                _L: /* CIL Label */ 
#line 4597
                if (spec) {
                  {
#line 4598
                  _glp_mpl_error(mpl, (char *)"objective statement not allowed here");
                  }
                }
                {
#line 4599
                stmt->type = 103;
#line 4600
                stmt->u.con = _glp_mpl_objective_statement(mpl);
                }
              } else {
                {
#line 4603
                tmp___6 = _glp_mpl_is_keyword(mpl, (char *)"table");
                }
#line 4603
                if (tmp___6) {
#line 4604
                  if (spec) {
                    {
#line 4605
                    _glp_mpl_error(mpl, (char *)"table statement not allowed here");
                    }
                  }
                  {
#line 4606
                  stmt->type = 125;
#line 4607
                  stmt->u.tab = _glp_mpl_table_statement(mpl);
                  }
                } else {
                  {
#line 4610
                  tmp___5 = _glp_mpl_is_keyword(mpl, (char *)"solve");
                  }
#line 4610
                  if (tmp___5) {
#line 4611
                    if (spec) {
                      {
#line 4612
                      _glp_mpl_error(mpl, (char *)"solve statement not allowed here");
                      }
                    }
                    {
#line 4613
                    stmt->type = 123;
#line 4614
                    stmt->u.slv = _glp_mpl_solve_statement(mpl);
                    }
                  } else {
                    {
#line 4616
                    tmp___4 = _glp_mpl_is_keyword(mpl, (char *)"check");
                    }
#line 4616
                    if (tmp___4) {
                      {
#line 4617
                      stmt->type = 102;
#line 4618
                      stmt->u.chk = _glp_mpl_check_statement(mpl);
                      }
                    } else {
                      {
#line 4620
                      tmp___3 = _glp_mpl_is_keyword(mpl, (char *)"display");
                      }
#line 4620
                      if (tmp___3) {
                        {
#line 4621
                        stmt->type = 104;
#line 4622
                        stmt->u.dpy = _glp_mpl_display_statement(mpl);
                        }
                      } else {
                        {
#line 4624
                        tmp___2 = _glp_mpl_is_keyword(mpl, (char *)"printf");
                        }
#line 4624
                        if (tmp___2) {
                          {
#line 4625
                          stmt->type = 121;
#line 4626
                          stmt->u.prt = _glp_mpl_printf_statement(mpl);
                          }
                        } else {
                          {
#line 4628
                          tmp___1 = _glp_mpl_is_keyword(mpl, (char *)"for");
                          }
#line 4628
                          if (tmp___1) {
                            {
#line 4629
                            stmt->type = 109;
#line 4630
                            stmt->u.fur = _glp_mpl_for_statement(mpl);
                            }
                          } else
#line 4632
                          if (mpl->token == 202) {
#line 4633
                            if (spec) {
                              {
#line 4634
                              _glp_mpl_error(mpl, (char *)"constraint statement not allowed here");
                              }
                            }
                            {
#line 4635
                            stmt->type = 103;
#line 4636
                            stmt->u.con = _glp_mpl_constraint_statement(mpl);
                            }
                          } else {
                            {
#line 4638
                            tmp___0 = _glp_mpl_is_reserved(mpl);
                            }
#line 4638
                            if (tmp___0) {
                              {
#line 4639
                              _glp_mpl_error(mpl, (char *)"invalid use of reserved keyword %s",
                                             mpl->image);
                              }
                            } else {
                              {
#line 4641
                              _glp_mpl_error(mpl, (char *)"syntax error in model section");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 4642
  return (stmt);
}
}
#line 4656 "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c"
void _glp_mpl_model_section(MPL *mpl ) 
{ 
  STATEMENT *stmt ;
  STATEMENT *last_stmt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 4658
  if ((unsigned long )mpl->model == (unsigned long )((void *)0)) {
#line 4658
    tmp = 1;
  } else {
    {
#line 4658
    _glp_lib_xassert("mpl->model == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpmpl01.c",
                     4658);
#line 4658
    tmp = 1;
    }
  }
#line 4659
  last_stmt = (STATEMENT *)((void *)0);
  {
#line 4660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4660
    if (mpl->token == 201) {
#line 4660
      goto while_break;
    } else {
      {
#line 4660
      tmp___0 = _glp_mpl_is_keyword(mpl, (char *)"data");
      }
#line 4660
      if (tmp___0) {
#line 4660
        goto while_break;
      } else {
        {
#line 4660
        tmp___1 = _glp_mpl_is_keyword(mpl, (char *)"end");
        }
#line 4660
        if (tmp___1) {
#line 4660
          goto while_break;
        }
      }
    }
    {
#line 4663
    stmt = _glp_mpl_simple_statement(mpl, 0);
    }
#line 4665
    if ((unsigned long )last_stmt == (unsigned long )((void *)0)) {
#line 4666
      mpl->model = stmt;
    } else {
#line 4668
      last_stmt->next = stmt;
    }
#line 4669
    last_stmt = stmt;
  }
  while_break: /* CIL Label */ ;
  }
#line 4671
  return;
}
}
#line 140 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.h"
int _glp_mat_check_fvs(int n , int nnz , int *ind , double *vec ) ;
#line 144
int _glp_mat_check_pattern(int m , int n , int *A_ptr , int *A_ind ) ;
#line 148
void _glp_mat_transpose(int m , int n , int *A_ptr , int *A_ind , double *A_val ,
                        int *AT_ptr , int *AT_ind , double *AT_val ) ;
#line 153
int *_glp_mat_adat_symbolic(int m , int n , int *P_per , int *A_ptr , int *A_ind ,
                            int *S_ptr ) ;
#line 158
void _glp_mat_adat_numeric(int m , int n , int *P_per , int *A_ptr , int *A_ind ,
                           double *A_val , double *D_diag , int *S_ptr , int *S_ind ,
                           double *S_val , double *S_diag ) ;
#line 164
void _glp_mat_min_degree(int n , int *A_ptr , int *A_ind , int *P_per ) ;
#line 168
void _glp_mat_amd_order1(int n , int *A_ptr , int *A_ind , int *P_per ) ;
#line 172
void _glp_mat_symamd_ord(int n , int *A_ptr , int *A_ind , int *P_per ) ;
#line 176
int *_glp_mat_chol_symbolic(int n , int *A_ptr , int *A_ind , int *U_ptr ) ;
#line 180
int _glp_mat_chol_numeric(int n , int *A_ptr , int *A_ind , double *A_val , double *A_diag ,
                          int *U_ptr , int *U_ind , double *U_val , double *U_diag ) ;
#line 186
void _glp_mat_u_solve(int n , int *U_ptr , int *U_ind , double *U_val , double *U_diag ,
                      double *x ) ;
#line 191
void _glp_mat_ut_solve(int n , int *U_ptr , int *U_ind , double *U_val , double *U_diag ,
                       double *x ) ;
#line 54 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
int _glp_mat_check_fvs(int n , int nnz , int *ind , double *vec ) 
{ 
  int i ;
  int t ;
  int ret ;
  int *flag ;
  void *tmp ;

  {
#line 55
  flag = (int *)((void *)0);
#line 57
  if (n < 0) {
#line 58
    ret = 1;
#line 59
    goto done;
  }
#line 62
  if (nnz < 0) {
#line 63
    ret = 2;
#line 64
    goto done;
  }
  {
#line 67
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 67
  flag = (int *)tmp;
#line 68
  i = 1;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i <= n)) {
#line 68
      goto while_break;
    }
#line 68
    *(flag + i) = 0;
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  t = 1;
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (t <= nnz)) {
#line 69
      goto while_break___0;
    }
#line 70
    i = *(ind + t);
#line 71
    if (1 <= i) {
#line 71
      if (! (i <= n)) {
#line 72
        ret = 3;
#line 73
        goto done;
      }
    } else {
#line 72
      ret = 3;
#line 73
      goto done;
    }
#line 75
    if (*(flag + i)) {
#line 76
      ret = 4;
#line 77
      goto done;
    }
#line 79
    *(flag + i) = 1;
#line 69
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  i = 1;
  {
#line 82
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 82
    if (! (i <= n)) {
#line 82
      goto while_break___1;
    }
#line 83
    if (! *(flag + i)) {
#line 83
      if (*(vec + i) != 0.0) {
#line 84
        ret = 5;
#line 85
        goto done;
      }
    }
#line 82
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 89
  ret = 0;
  done: 
#line 90
  if ((unsigned long )flag != (unsigned long )((void *)0)) {
    {
#line 90
    _glp_lib_xfree((void *)flag);
    }
  }
#line 91
  return (ret);
}
}
#line 118 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
int _glp_mat_check_pattern(int m , int n , int *A_ptr , int *A_ind ) 
{ 
  int i ;
  int j ;
  int ptr ;
  int ret ;
  int *flag ;
  void *tmp ;

  {
#line 119
  flag = (int *)((void *)0);
#line 121
  if (m < 0) {
#line 122
    ret = 1;
#line 123
    goto done;
  }
#line 126
  if (n < 0) {
#line 127
    ret = 2;
#line 128
    goto done;
  }
#line 131
  if (*(A_ptr + 1) != 1) {
#line 132
    ret = 3;
#line 133
    goto done;
  }
  {
#line 136
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 136
  flag = (int *)tmp;
#line 137
  j = 1;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (j <= n)) {
#line 137
      goto while_break;
    }
#line 137
    *(flag + j) = 0;
#line 137
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  i = 1;
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if (! (i <= m)) {
#line 138
      goto while_break___0;
    }
#line 140
    ptr = *(A_ptr + i);
    {
#line 140
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 140
      if (! (ptr < *(A_ptr + (i + 1)))) {
#line 140
        goto while_break___1;
      }
#line 141
      j = *(A_ind + ptr);
#line 143
      if (1 <= j) {
#line 143
        if (! (j <= n)) {
#line 144
          ret = 4;
#line 145
          goto done;
        }
      } else {
#line 144
        ret = 4;
#line 145
        goto done;
      }
#line 148
      if (*(flag + j)) {
#line 149
        ret = 5;
#line 150
        goto done;
      }
#line 152
      *(flag + j) = 1;
#line 140
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 155
    ptr = *(A_ptr + i);
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (! (ptr < *(A_ptr + (i + 1)))) {
#line 155
        goto while_break___2;
      }
#line 156
      j = *(A_ind + ptr);
#line 157
      *(flag + j) = 0;
#line 155
      ptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 138
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 161
  ret = 0;
  done: 
#line 162
  if ((unsigned long )flag != (unsigned long )((void *)0)) {
    {
#line 162
    _glp_lib_xfree((void *)flag);
    }
  }
#line 163
  return (ret);
}
}
#line 193 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
void _glp_mat_transpose(int m , int n , int *A_ptr , int *A_ind , double *A_val ,
                        int *AT_ptr , int *AT_ind , double *AT_val ) 
{ 
  int i ;
  int j ;
  int t ;
  int beg ;
  int end ;
  int pos ;
  int len ;

  {
#line 197
  j = 1;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (j <= n)) {
#line 197
      goto while_break;
    }
#line 197
    *(AT_ptr + j) = 0;
#line 197
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  i = 1;
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! (i <= m)) {
#line 198
      goto while_break___0;
    }
#line 199
    beg = *(A_ptr + i);
#line 199
    end = *(A_ptr + (i + 1));
#line 200
    t = beg;
    {
#line 200
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 200
      if (! (t < end)) {
#line 200
        goto while_break___1;
      }
#line 200
      (*(AT_ptr + *(A_ind + t))) ++;
#line 200
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 198
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 203
  pos = 1;
#line 204
  j = 1;
  {
#line 204
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 204
    if (! (j <= n)) {
#line 204
      goto while_break___2;
    }
#line 205
    len = *(AT_ptr + j);
#line 205
    pos += len;
#line 205
    *(AT_ptr + j) = pos;
#line 204
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 206
  *(AT_ptr + (n + 1)) = pos;
#line 208
  i = m;
  {
#line 208
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 208
    if (! (i >= 1)) {
#line 208
      goto while_break___3;
    }
#line 209
    beg = *(A_ptr + i);
#line 209
    end = *(A_ptr + (i + 1));
#line 210
    t = beg;
    {
#line 210
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 210
      if (! (t < end)) {
#line 210
        goto while_break___4;
      }
#line 211
      (*(AT_ptr + *(A_ind + t))) --;
#line 211
      pos = *(AT_ptr + *(A_ind + t));
#line 212
      *(AT_ind + pos) = i;
#line 213
      if ((unsigned long )A_val != (unsigned long )((void *)0)) {
#line 213
        *(AT_val + pos) = *(A_val + t);
      }
#line 210
      t ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 208
    i --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 255 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
int *_glp_mat_adat_symbolic(int m , int n , int *P_per , int *A_ptr , int *A_ind ,
                            int *S_ptr ) 
{ 
  int i ;
  int j ;
  int t ;
  int ii ;
  int jj ;
  int tt ;
  int k ;
  int size ;
  int len ;
  int *S_ind ;
  int *AT_ptr ;
  int *AT_ind ;
  int *ind ;
  int *map ;
  int *temp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 261
  tmp = _glp_lib_xcalloc((1 + n) + 1, (int )sizeof(int ));
#line 261
  AT_ptr = (int *)tmp;
#line 262
  tmp___0 = _glp_lib_xcalloc(*(A_ptr + (m + 1)), (int )sizeof(int ));
#line 262
  AT_ind = (int *)tmp___0;
#line 263
  _glp_mat_transpose(m, n, A_ptr, A_ind, (double *)((void *)0), AT_ptr, AT_ind, (double *)((void *)0));
#line 265
  size = *(A_ptr + (m + 1)) - 1;
  }
#line 266
  if (size < m) {
#line 266
    size = m;
  }
  {
#line 267
  tmp___1 = _glp_lib_xcalloc(1 + size, (int )sizeof(int ));
#line 267
  S_ind = (int *)tmp___1;
#line 269
  tmp___2 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 269
  ind = (int *)tmp___2;
#line 270
  tmp___3 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 270
  map = (int *)tmp___3;
#line 271
  jj = 1;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (jj <= m)) {
#line 271
      goto while_break;
    }
#line 271
    *(map + jj) = 0;
#line 271
    jj ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  *(S_ptr + 1) = 1;
#line 275
  ii = 1;
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 275
    if (! (ii <= m)) {
#line 275
      goto while_break___0;
    }
#line 277
    len = 0;
#line 278
    i = *(P_per + ii);
#line 279
    t = *(A_ptr + i);
    {
#line 279
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 279
      if (! (t < *(A_ptr + (i + 1)))) {
#line 279
        goto while_break___1;
      }
#line 280
      k = *(A_ind + t);
#line 282
      tt = *(AT_ptr + k);
      {
#line 282
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 282
        if (! (tt < *(AT_ptr + (k + 1)))) {
#line 282
          goto while_break___2;
        }
#line 283
        j = *(AT_ind + tt);
#line 284
        jj = *(P_per + (m + j));
#line 286
        if (ii < jj) {
#line 286
          if (! *(map + jj)) {
#line 286
            len ++;
#line 286
            *(ind + len) = jj;
#line 286
            *(map + jj) = 1;
          }
        }
#line 282
        tt ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 279
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    *(S_ptr + (ii + 1)) = *(S_ptr + ii) + len;
#line 293
    if (*(S_ptr + (ii + 1)) - 1 > size) {
      {
#line 294
      temp = S_ind;
#line 295
      size += size;
#line 296
      tmp___4 = _glp_lib_xcalloc(1 + size, (int )sizeof(int ));
#line 296
      S_ind = (int *)tmp___4;
#line 297
      memcpy((void */* __restrict  */)(S_ind + 1), (void const   */* __restrict  */)(temp + 1),
             (size_t )((unsigned long )(*(S_ptr + ii) - 1) * sizeof(int )));
#line 298
      _glp_lib_xfree((void *)temp);
      }
    }
#line 300
    if (*(S_ptr + (ii + 1)) - 1 <= size) {
#line 300
      tmp___5 = 1;
    } else {
      {
#line 300
      _glp_lib_xassert("S_ptr[ii+1] - 1 <= size", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       300);
#line 300
      tmp___5 = 1;
      }
    }
    {
#line 302
    memcpy((void */* __restrict  */)(S_ind + *(S_ptr + ii)), (void const   */* __restrict  */)(ind + 1),
           (size_t )((unsigned long )len * sizeof(int )));
#line 304
    t = 1;
    }
    {
#line 304
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 304
      if (! (t <= len)) {
#line 304
        goto while_break___3;
      }
#line 304
      *(map + *(ind + t)) = 0;
#line 304
      t ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 275
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 307
  _glp_lib_xfree((void *)AT_ptr);
#line 308
  _glp_lib_xfree((void *)AT_ind);
#line 309
  _glp_lib_xfree((void *)ind);
#line 310
  _glp_lib_xfree((void *)map);
#line 312
  temp = S_ind;
#line 313
  size = *(S_ptr + (m + 1)) - 1;
#line 314
  tmp___6 = _glp_lib_xcalloc(1 + size, (int )sizeof(int ));
#line 314
  S_ind = (int *)tmp___6;
#line 315
  memcpy((void */* __restrict  */)(S_ind + 1), (void const   */* __restrict  */)(temp + 1),
         (size_t )((unsigned long )size * sizeof(int )));
#line 316
  _glp_lib_xfree((void *)temp);
  }
#line 317
  return (S_ind);
}
}
#line 358 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
void _glp_mat_adat_numeric(int m , int n , int *P_per , int *A_ptr , int *A_ind ,
                           double *A_val , double *D_diag , int *S_ptr , int *S_ind ,
                           double *S_val , double *S_diag ) 
{ 
  int i ;
  int j ;
  int t ;
  int ii ;
  int jj ;
  int tt ;
  int beg ;
  int end ;
  int beg1 ;
  int end1 ;
  int k ;
  double sum ;
  double *work ;
  void *tmp ;

  {
  {
#line 363
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 363
  work = (double *)tmp;
#line 364
  j = 1;
  }
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (j <= n)) {
#line 364
      goto while_break;
    }
#line 364
    *(work + j) = 0.0;
#line 364
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  ii = 1;
  {
#line 367
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 367
    if (! (ii <= m)) {
#line 367
      goto while_break___0;
    }
#line 368
    i = *(P_per + ii);
#line 370
    beg = *(A_ptr + i);
#line 370
    end = *(A_ptr + (i + 1));
#line 371
    t = beg;
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 371
      if (! (t < end)) {
#line 371
        goto while_break___1;
      }
#line 372
      *(work + *(A_ind + t)) = *(A_val + t);
#line 371
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 374
    beg = *(S_ptr + ii);
#line 374
    end = *(S_ptr + (ii + 1));
#line 375
    t = beg;
    {
#line 375
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 375
      if (! (t < end)) {
#line 375
        goto while_break___2;
      }
#line 376
      jj = *(S_ind + t);
#line 377
      j = *(P_per + jj);
#line 379
      sum = 0.0;
#line 380
      beg1 = *(A_ptr + j);
#line 380
      end1 = *(A_ptr + (j + 1));
#line 381
      tt = beg1;
      {
#line 381
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 381
        if (! (tt < end1)) {
#line 381
          goto while_break___3;
        }
#line 382
        k = *(A_ind + tt);
#line 383
        sum += (*(work + k) * *(D_diag + k)) * *(A_val + tt);
#line 381
        tt ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 385
      *(S_val + t) = sum;
#line 375
      t ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 388
    sum = 0.0;
#line 389
    beg = *(A_ptr + i);
#line 389
    end = *(A_ptr + (i + 1));
#line 390
    t = beg;
    {
#line 390
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 390
      if (! (t < end)) {
#line 390
        goto while_break___4;
      }
#line 391
      k = *(A_ind + t);
#line 392
      sum += (*(A_val + t) * *(D_diag + k)) * *(A_val + t);
#line 393
      *(work + k) = 0.0;
#line 390
      t ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 395
    *(S_diag + ii) = sum;
#line 367
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 397
  _glp_lib_xfree((void *)work);
  }
#line 398
  return;
}
}
#line 432 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
void _glp_mat_min_degree(int n , int *A_ptr , int *A_ind , int *P_per ) 
{ 
  int i ;
  int j ;
  int ne ;
  int t ;
  int pos ;
  int len ;
  int *xadj ;
  int *adjncy ;
  int *deg ;
  int *marker ;
  int *rchset ;
  int *nbrhd ;
  int *qsize ;
  int *qlink ;
  int nofsub ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 437
  ne = *(A_ptr + (n + 1)) - 1;
#line 438
  ne += ne;
#line 440
  tmp = _glp_lib_xcalloc((1 + n) + 1, (int )sizeof(int ));
#line 440
  xadj = (int *)tmp;
#line 441
  tmp___0 = _glp_lib_xcalloc(1 + ne, (int )sizeof(int ));
#line 441
  adjncy = (int *)tmp___0;
#line 442
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 442
  deg = (int *)tmp___1;
#line 443
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 443
  marker = (int *)tmp___2;
#line 444
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 444
  rchset = (int *)tmp___3;
#line 445
  tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 445
  nbrhd = (int *)tmp___4;
#line 446
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 446
  qsize = (int *)tmp___5;
#line 447
  tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 447
  qlink = (int *)tmp___6;
#line 449
  i = 1;
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (i <= n)) {
#line 449
      goto while_break;
    }
#line 449
    *(xadj + i) = 0;
#line 449
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  i = 1;
  {
#line 450
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 450
    if (! (i <= n)) {
#line 450
      goto while_break___0;
    }
#line 451
    t = *(A_ptr + i);
    {
#line 451
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 451
      if (! (t < *(A_ptr + (i + 1)))) {
#line 451
        goto while_break___1;
      }
#line 452
      j = *(A_ind + t);
#line 453
      if (i < j) {
#line 453
        if (j <= n) {
#line 453
          tmp___7 = 1;
        } else {
          {
#line 453
          _glp_lib_xassert("i < j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                           453);
#line 453
          tmp___7 = 1;
          }
        }
      } else {
        {
#line 453
        _glp_lib_xassert("i < j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                         453);
#line 453
        tmp___7 = 1;
        }
      }
#line 454
      (*(xadj + i)) ++;
#line 454
      (*(xadj + j)) ++;
#line 451
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 450
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 458
  pos = 1;
#line 459
  i = 1;
  {
#line 459
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 459
    if (! (i <= n)) {
#line 459
      goto while_break___2;
    }
#line 460
    len = *(xadj + i);
#line 460
    pos += len;
#line 460
    *(xadj + i) = pos;
#line 459
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 461
  *(xadj + (n + 1)) = pos;
#line 462
  if (pos - 1 == ne) {
#line 462
    tmp___8 = 1;
  } else {
    {
#line 462
    _glp_lib_xassert("pos - 1 == ne", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                     462);
#line 462
    tmp___8 = 1;
    }
  }
#line 464
  i = 1;
  {
#line 464
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 464
    if (! (i <= n)) {
#line 464
      goto while_break___3;
    }
#line 465
    t = *(A_ptr + i);
    {
#line 465
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 465
      if (! (t < *(A_ptr + (i + 1)))) {
#line 465
        goto while_break___4;
      }
#line 466
      j = *(A_ind + t);
#line 467
      (*(xadj + i)) --;
#line 467
      *(adjncy + *(xadj + i)) = j;
#line 467
      (*(xadj + j)) --;
#line 467
      *(adjncy + *(xadj + j)) = i;
#line 465
      t ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 464
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 471
  _glp_qmd_genqmd(& n, xadj, adjncy, P_per, P_per + n, deg, marker, rchset, nbrhd,
                  qsize, qlink, & nofsub);
#line 474
  i = 1;
  }
  {
#line 474
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 474
    if (! (i <= n)) {
#line 474
      goto while_break___5;
    }
#line 475
    j = *(P_per + i);
#line 476
    if (1 <= j) {
#line 476
      if (j <= n) {
#line 476
        tmp___9 = 1;
      } else {
        {
#line 476
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                         476);
#line 476
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 476
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       476);
#line 476
      tmp___9 = 1;
      }
    }
#line 477
    if (*(P_per + (n + j)) == i) {
#line 477
      tmp___10 = 1;
    } else {
      {
#line 477
      _glp_lib_xassert("P_per[n+j] == i", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       477);
#line 477
      tmp___10 = 1;
      }
    }
#line 474
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 480
  _glp_lib_xfree((void *)xadj);
#line 481
  _glp_lib_xfree((void *)adjncy);
#line 482
  _glp_lib_xfree((void *)deg);
#line 483
  _glp_lib_xfree((void *)marker);
#line 484
  _glp_lib_xfree((void *)rchset);
#line 485
  _glp_lib_xfree((void *)nbrhd);
#line 486
  _glp_lib_xfree((void *)qsize);
#line 487
  _glp_lib_xfree((void *)qlink);
  }
#line 488
  return;
}
}
#line 493 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
void _glp_mat_amd_order1(int n , int *A_ptr , int *A_ind , int *P_per ) 
{ 
  int k ;
  int ret ;
  double Control[5] ;
  double Info[20] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 498
  _glp_amd_defaults(Control);
#line 504
  k = 1;
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (k < *(A_ptr + (n + 1)))) {
#line 504
      goto while_break;
    }
#line 504
    (*(A_ind + k)) --;
#line 504
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  k = 1;
  {
#line 505
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 505
    if (! (k <= n + 1)) {
#line 505
      goto while_break___0;
    }
#line 505
    (*(A_ptr + k)) --;
#line 505
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 507
  ret = _glp_amd_order(n, (int const   *)(A_ptr + 1), (int const   *)(A_ind + 1),
                       P_per + 1, Control, Info);
  }
#line 512
  if (ret == 0) {
#line 512
    tmp = 1;
  } else
#line 512
  if (ret == 1) {
#line 512
    tmp = 1;
  } else {
    {
#line 512
    _glp_lib_xassert("ret == AMD_OK || ret == AMD_OK_BUT_JUMBLED", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                     512);
#line 512
    tmp = 1;
    }
  }
#line 514
  k = 1;
  {
#line 514
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 514
    if (! (k <= n + 1)) {
#line 514
      goto while_break___1;
    }
#line 514
    (*(A_ptr + k)) ++;
#line 514
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 515
  k = 1;
  {
#line 515
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 515
    if (! (k < *(A_ptr + (n + 1)))) {
#line 515
      goto while_break___2;
    }
#line 515
    (*(A_ind + k)) ++;
#line 515
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 517
  memset((void *)(P_per + (n + 1)), 0, (size_t )((unsigned long )n * sizeof(int )));
#line 518
  k = 1;
  }
  {
#line 518
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 518
    if (! (k <= n)) {
#line 518
      goto while_break___3;
    }
#line 519
    (*(P_per + k)) ++;
#line 520
    if (1 <= *(P_per + k)) {
#line 520
      if (*(P_per + k) <= n) {
#line 520
        tmp___0 = 1;
      } else {
        {
#line 520
        _glp_lib_xassert("1 <= P_per[k] && P_per[k] <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                         520);
#line 520
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 520
      _glp_lib_xassert("1 <= P_per[k] && P_per[k] <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       520);
#line 520
      tmp___0 = 1;
      }
    }
#line 521
    if (*(P_per + (n + *(P_per + k))) == 0) {
#line 521
      tmp___1 = 1;
    } else {
      {
#line 521
      _glp_lib_xassert("P_per[n+P_per[k]] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       521);
#line 521
      tmp___1 = 1;
      }
    }
#line 522
    *(P_per + (n + *(P_per + k))) = k;
#line 518
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 524
  return;
}
}
#line 529 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
static void *allocate(size_t n , size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 531
  ptr = _glp_lib_xcalloc((int )n, (int )size);
#line 532
  memset(ptr, 0, n * size);
  }
#line 533
  return (ptr);
}
}
#line 536 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
static void release(void *ptr ) 
{ 


  {
  {
#line 537
  _glp_lib_xfree(ptr);
  }
#line 538
  return;
}
}
#line 541 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
void _glp_mat_symamd_ord(int n , int *A_ptr , int *A_ind , int *P_per ) 
{ 
  int k ;
  int ok ;
  int stats[20] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 546
  k = 1;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! (k < *(A_ptr + (n + 1)))) {
#line 546
      goto while_break;
    }
#line 546
    (*(A_ind + k)) --;
#line 546
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  k = 1;
  {
#line 547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 547
    if (! (k <= n + 1)) {
#line 547
      goto while_break___0;
    }
#line 547
    (*(A_ptr + k)) --;
#line 547
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 549
  ok = _glp_symamd(n, A_ind + 1, A_ptr + 1, P_per + 1, (double *)((void *)0), (int *)(stats),
                   & allocate, & release);
  }
#line 554
  if (ok) {
#line 554
    tmp = 1;
  } else {
    {
#line 554
    _glp_lib_xassert("ok", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c", 554);
#line 554
    tmp = 1;
    }
  }
#line 556
  k = 1;
  {
#line 556
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 556
    if (! (k <= n + 1)) {
#line 556
      goto while_break___1;
    }
#line 556
    (*(A_ptr + k)) ++;
#line 556
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 557
  k = 1;
  {
#line 557
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 557
    if (! (k < *(A_ptr + (n + 1)))) {
#line 557
      goto while_break___2;
    }
#line 557
    (*(A_ind + k)) ++;
#line 557
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 559
  memset((void *)(P_per + (n + 1)), 0, (size_t )((unsigned long )n * sizeof(int )));
#line 560
  k = 1;
  }
  {
#line 560
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 560
    if (! (k <= n)) {
#line 560
      goto while_break___3;
    }
#line 561
    (*(P_per + k)) ++;
#line 562
    if (1 <= *(P_per + k)) {
#line 562
      if (*(P_per + k) <= n) {
#line 562
        tmp___0 = 1;
      } else {
        {
#line 562
        _glp_lib_xassert("1 <= P_per[k] && P_per[k] <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                         562);
#line 562
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 562
      _glp_lib_xassert("1 <= P_per[k] && P_per[k] <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       562);
#line 562
      tmp___0 = 1;
      }
    }
#line 563
    if (*(P_per + (n + *(P_per + k))) == 0) {
#line 563
      tmp___1 = 1;
    } else {
      {
#line 563
      _glp_lib_xassert("P_per[n+P_per[k]] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       563);
#line 563
      tmp___1 = 1;
      }
    }
#line 564
    *(P_per + (n + *(P_per + k))) = k;
#line 560
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 566
  return;
}
}
#line 633 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
int *_glp_mat_chol_symbolic(int n , int *A_ptr , int *A_ind , int *U_ptr ) 
{ 
  int i ;
  int j ;
  int k ;
  int t ;
  int len ;
  int size ;
  int beg ;
  int end ;
  int min_j ;
  int *U_ind ;
  int *head ;
  int *next ;
  int *ind ;
  int *map ;
  int *temp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 638
  size = *(A_ptr + (n + 1)) - 1;
#line 639
  if (size < n) {
#line 639
    size = n;
  }
  {
#line 640
  size += size;
#line 641
  tmp = _glp_lib_xcalloc(1 + size, (int )sizeof(int ));
#line 641
  U_ind = (int *)tmp;
#line 643
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 643
  head = (int *)tmp___0;
#line 644
  i = 1;
  }
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! (i <= n)) {
#line 644
      goto while_break;
    }
#line 644
    *(head + i) = 0;
#line 644
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 645
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 645
  next = (int *)tmp___1;
#line 646
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 646
  ind = (int *)tmp___2;
#line 647
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 647
  map = (int *)tmp___3;
#line 648
  j = 1;
  }
  {
#line 648
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 648
    if (! (j <= n)) {
#line 648
      goto while_break___0;
    }
#line 648
    *(map + j) = 0;
#line 648
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 650
  *(U_ptr + 1) = 1;
#line 651
  k = 1;
  {
#line 651
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 651
    if (! (k <= n)) {
#line 651
      goto while_break___1;
    }
    {
#line 656
    len = *(A_ptr + (k + 1)) - *(A_ptr + k);
#line 657
    memcpy((void */* __restrict  */)(ind + 1), (void const   */* __restrict  */)(A_ind + *(A_ptr + k)),
           (size_t )((unsigned long )len * sizeof(int )));
#line 658
    t = 1;
    }
    {
#line 658
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 658
      if (! (t <= len)) {
#line 658
        goto while_break___2;
      }
#line 659
      j = *(ind + t);
#line 660
      if (k < j) {
#line 660
        if (j <= n) {
#line 660
          tmp___4 = 1;
        } else {
          {
#line 660
          _glp_lib_xassert("k < j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                           660);
#line 660
          tmp___4 = 1;
          }
        }
      } else {
        {
#line 660
        _glp_lib_xassert("k < j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                         660);
#line 660
        tmp___4 = 1;
        }
      }
#line 661
      *(map + j) = 1;
#line 658
      t ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 665
    i = *(head + k);
    {
#line 665
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 665
      if (! (i != 0)) {
#line 665
        goto while_break___3;
      }
#line 667
      beg = *(U_ptr + i);
#line 667
      end = *(U_ptr + (i + 1));
#line 668
      t = beg;
      {
#line 668
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 668
        if (! (t < end)) {
#line 668
          goto while_break___4;
        }
#line 669
        j = *(U_ind + t);
#line 670
        if (j > k) {
#line 670
          if (! *(map + j)) {
#line 670
            len ++;
#line 670
            *(ind + len) = j;
#line 670
            *(map + j) = 1;
          }
        }
#line 668
        t ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 665
      i = *(next + i);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 674
    *(U_ptr + (k + 1)) = *(U_ptr + k) + len;
#line 677
    if (*(U_ptr + (k + 1)) - 1 > size) {
      {
#line 678
      temp = U_ind;
#line 679
      size += size;
#line 680
      tmp___5 = _glp_lib_xcalloc(1 + size, (int )sizeof(int ));
#line 680
      U_ind = (int *)tmp___5;
#line 681
      memcpy((void */* __restrict  */)(U_ind + 1), (void const   */* __restrict  */)(temp + 1),
             (size_t )((unsigned long )(*(U_ptr + k) - 1) * sizeof(int )));
#line 682
      _glp_lib_xfree((void *)temp);
      }
    }
#line 684
    if (*(U_ptr + (k + 1)) - 1 <= size) {
#line 684
      tmp___6 = 1;
    } else {
      {
#line 684
      _glp_lib_xassert("U_ptr[k+1] - 1 <= size", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       684);
#line 684
      tmp___6 = 1;
      }
    }
    {
#line 686
    memcpy((void */* __restrict  */)(U_ind + *(U_ptr + k)), (void const   */* __restrict  */)(ind + 1),
           (size_t )((unsigned long )len * sizeof(int )));
#line 689
    min_j = n + 1;
#line 690
    t = 1;
    }
    {
#line 690
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 690
      if (! (t <= len)) {
#line 690
        goto while_break___5;
      }
#line 691
      j = *(ind + t);
#line 691
      *(map + j) = 0;
#line 692
      if (min_j > j) {
#line 692
        min_j = j;
      }
#line 690
      t ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 695
    if (min_j <= n) {
#line 695
      *(next + k) = *(head + min_j);
#line 695
      *(head + min_j) = k;
    }
#line 651
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 698
  _glp_lib_xfree((void *)head);
#line 699
  _glp_lib_xfree((void *)next);
#line 700
  _glp_lib_xfree((void *)ind);
#line 701
  _glp_lib_xfree((void *)map);
#line 703
  temp = U_ind;
#line 704
  size = *(U_ptr + (n + 1)) - 1;
#line 705
  tmp___7 = _glp_lib_xcalloc(1 + size, (int )sizeof(int ));
#line 705
  U_ind = (int *)tmp___7;
#line 706
  memcpy((void */* __restrict  */)(U_ind + 1), (void const   */* __restrict  */)(temp + 1),
         (size_t )((unsigned long )size * sizeof(int )));
#line 707
  _glp_lib_xfree((void *)temp);
  }
#line 708
  return (U_ind);
}
}
#line 790 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
int _glp_mat_chol_numeric(int n , int *A_ptr , int *A_ind , double *A_val , double *A_diag ,
                          int *U_ptr , int *U_ind , double *U_val , double *U_diag ) 
{ 
  int i ;
  int j ;
  int k ;
  int t ;
  int t1 ;
  int beg ;
  int end ;
  int beg1 ;
  int end1 ;
  int count ;
  double ukk ;
  double uki ;
  double *work ;
  void *tmp ;
  double tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 793
  count = 0;
#line 795
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 795
  work = (double *)tmp;
#line 796
  j = 1;
  }
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    if (! (j <= n)) {
#line 796
      goto while_break;
    }
#line 796
    *(work + j) = 0.0;
#line 796
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  i = 1;
  {
#line 799
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 799
    if (! (i <= n)) {
#line 799
      goto while_break___0;
    }
#line 800
    beg = *(A_ptr + i);
#line 800
    end = *(A_ptr + (i + 1));
#line 801
    t = beg;
    {
#line 801
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 801
      if (! (t < end)) {
#line 801
        goto while_break___1;
      }
#line 802
      j = *(A_ind + t);
#line 802
      *(work + j) = *(A_val + t);
#line 801
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 803
    beg = *(U_ptr + i);
#line 803
    end = *(U_ptr + (i + 1));
#line 804
    t = beg;
    {
#line 804
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 804
      if (! (t < end)) {
#line 804
        goto while_break___2;
      }
#line 805
      j = *(U_ind + t);
#line 805
      *(U_val + t) = *(work + j);
#line 805
      *(work + j) = 0.0;
#line 804
      t ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 806
    *(U_diag + i) = *(A_diag + i);
#line 799
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 809
  k = 1;
  {
#line 809
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 809
    if (! (k <= n)) {
#line 809
      goto while_break___3;
    }
#line 811
    ukk = *(U_diag + k);
#line 812
    if (ukk > 0.0) {
      {
#line 813
      ukk = sqrt(ukk);
#line 813
      *(U_diag + k) = ukk;
      }
    } else {
#line 815
      ukk = 1.7976931348623157e+308;
#line 815
      *(U_diag + k) = ukk;
#line 815
      count ++;
    }
#line 817
    beg = *(U_ptr + k);
#line 817
    end = *(U_ptr + (k + 1));
#line 818
    t = beg;
    {
#line 818
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 818
      if (! (t < end)) {
#line 818
        goto while_break___4;
      }
#line 819
      tmp___0 = *(U_val + t) / ukk;
#line 819
      *(U_val + t) = tmp___0;
#line 819
      *(work + *(U_ind + t)) = tmp___0;
#line 818
      t ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 821
    t = beg;
    {
#line 821
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 821
      if (! (t < end)) {
#line 821
        goto while_break___5;
      }
#line 822
      i = *(U_ind + t);
#line 823
      if (i > k) {
#line 823
        tmp___1 = 1;
      } else {
        {
#line 823
        _glp_lib_xassert("i > k", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                         823);
#line 823
        tmp___1 = 1;
        }
      }
#line 825
      uki = *(work + i);
#line 826
      beg1 = *(U_ptr + i);
#line 826
      end1 = *(U_ptr + (i + 1));
#line 827
      t1 = beg1;
      {
#line 827
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 827
        if (! (t1 < end1)) {
#line 827
          goto while_break___6;
        }
#line 828
        *(U_val + t1) -= uki * *(work + *(U_ind + t1));
#line 827
        t1 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 829
      *(U_diag + i) -= uki * uki;
#line 821
      t ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 832
    t = beg;
    {
#line 832
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 832
      if (! (t < end)) {
#line 832
        goto while_break___7;
      }
#line 833
      *(work + *(U_ind + t)) = 0.0;
#line 832
      t ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 809
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 835
  _glp_lib_xfree((void *)work);
  }
#line 836
  return (count);
}
}
#line 866 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
void _glp_mat_u_solve(int n , int *U_ptr , int *U_ind , double *U_val , double *U_diag ,
                      double *x ) 
{ 
  int i ;
  int t ;
  int beg ;
  int end ;
  double temp ;
  int tmp ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 870
  i = n;
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! (i >= 1)) {
#line 870
      goto while_break;
    }
#line 871
    temp = *(x + i);
#line 872
    beg = *(U_ptr + i);
#line 872
    end = *(U_ptr + (i + 1));
#line 873
    t = beg;
    {
#line 873
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 873
      if (! (t < end)) {
#line 873
        goto while_break___0;
      }
#line 874
      temp -= *(U_val + t) * *(x + *(U_ind + t));
#line 873
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 875
    if (*(U_diag + i) != 0.0) {
#line 875
      tmp = 1;
    } else {
      {
#line 875
      _glp_lib_xassert("U_diag[i] != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       875);
#line 875
      tmp = 1;
      }
    }
#line 876
    *(x + i) = temp / *(U_diag + i);
#line 870
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 878
  return;
}
}
#line 908 "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c"
void _glp_mat_ut_solve(int n , int *U_ptr , int *U_ind , double *U_val , double *U_diag ,
                       double *x ) 
{ 
  int i ;
  int t ;
  int beg ;
  int end ;
  double temp ;
  int tmp ;
  double tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 912
  i = 1;
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    if (! (i <= n)) {
#line 912
      goto while_break;
    }
#line 913
    if (*(U_diag + i) != 0.0) {
#line 913
      tmp = 1;
    } else {
      {
#line 913
      _glp_lib_xassert("U_diag[i] != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpmat.c",
                       913);
#line 913
      tmp = 1;
      }
    }
#line 914
    tmp___0 = *(x + i) / *(U_diag + i);
#line 914
    *(x + i) = tmp___0;
#line 914
    temp = tmp___0;
#line 915
    if (temp == 0.0) {
#line 915
      goto __Cont;
    }
#line 916
    beg = *(U_ptr + i);
#line 916
    end = *(U_ptr + (i + 1));
#line 917
    t = beg;
    {
#line 917
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 917
      if (! (t < end)) {
#line 917
        goto while_break___0;
      }
#line 918
      *(x + *(U_ind + t)) -= *(U_val + t) * temp;
#line 917
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 912
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 199 "/home/wslee/benchmarks/glpk-4.38/src/glplux.h"
LUX *_glp_lux_create(int n ) ;
#line 202
int _glp_lux_decomp(LUX *lux , int (*col)(void *info , int j , int *ind , mpq_t *val ) ,
                    void *info ) ;
#line 206
void _glp_lux_f_solve(LUX *lux , int tr , mpq_t *x ) ;
#line 209
void _glp_lux_v_solve(LUX *lux , int tr , mpq_t *x ) ;
#line 212
void _glp_lux_solve(LUX *lux , int tr , mpq_t *x ) ;
#line 215
void _glp_lux_delete(LUX *lux ) ;
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
LUX *_glp_lux_create(int n ) 
{ 
  LUX *lux ;
  int k ;
  xerror_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  LUXELM *tmp___10 ;
  LUXELM *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 50
  if (n < 1) {
    {
#line 51
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c", 51);
#line 51
    (*tmp)("lux_create: n = %d; invalid parameter\n", n);
    }
  }
  {
#line 52
  tmp___0 = _glp_lib_xmalloc((int )sizeof(LUX ));
#line 52
  lux = (LUX *)tmp___0;
#line 53
  lux->n = n;
#line 54
  lux->pool = _glp_dmp_create_pool();
#line 55
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(LUXELM *));
#line 55
  lux->F_row = (LUXELM **)tmp___1;
#line 56
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(LUXELM *));
#line 56
  lux->F_col = (LUXELM **)tmp___2;
#line 57
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(mpq_t ));
#line 57
  lux->V_piv = (mpq_t *)tmp___3;
#line 58
  tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(LUXELM *));
#line 58
  lux->V_row = (LUXELM **)tmp___4;
#line 59
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(LUXELM *));
#line 59
  lux->V_col = (LUXELM **)tmp___5;
#line 60
  tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 60
  lux->P_row = (int *)tmp___6;
#line 61
  tmp___7 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 61
  lux->P_col = (int *)tmp___7;
#line 62
  tmp___8 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 62
  lux->Q_row = (int *)tmp___8;
#line 63
  tmp___9 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 63
  lux->Q_col = (int *)tmp___9;
#line 64
  k = 1;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (k <= n)) {
#line 64
      goto while_break;
    }
    {
#line 65
    tmp___10 = (LUXELM *)((void *)0);
#line 65
    *(lux->F_col + k) = tmp___10;
#line 65
    *(lux->F_row + k) = tmp___10;
#line 66
    *(lux->V_piv + k) = _glp_mpq_init();
#line 67
    _glp_mpq_set_si(*(lux->V_piv + k), 1, 1U);
#line 68
    tmp___11 = (LUXELM *)((void *)0);
#line 68
    *(lux->V_col + k) = tmp___11;
#line 68
    *(lux->V_row + k) = tmp___11;
#line 69
    tmp___12 = k;
#line 69
    *(lux->P_col + k) = tmp___12;
#line 69
    *(lux->P_row + k) = tmp___12;
#line 70
    tmp___13 = k;
#line 70
    *(lux->Q_col + k) = tmp___13;
#line 70
    *(lux->Q_row + k) = tmp___13;
#line 64
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  lux->rank = n;
#line 73
  return (lux);
}
}
#line 84 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
static void initialize(LUX *lux , int (*col)(void *info , int j , int *ind , mpq_t *val ) ,
                       void *info , LUXWKA *wka ) 
{ 
  int n ;
  DMP *pool ;
  LUXELM **F_row ;
  LUXELM **F_col ;
  mpq_t *V_piv ;
  LUXELM **V_row ;
  LUXELM **V_col ;
  int *P_row ;
  int *P_col ;
  int *Q_row ;
  int *Q_col ;
  int *R_len ;
  int *R_head ;
  int *R_prev ;
  int *R_next ;
  int *C_len ;
  int *C_head ;
  int *C_prev ;
  int *C_next ;
  LUXELM *fij ;
  LUXELM *vij ;
  int i ;
  int j ;
  int k ;
  int len ;
  int *ind ;
  mpq_t *val ;
  void *tmp ;
  void *tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  LUXELM *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 86
  n = lux->n;
#line 87
  pool = lux->pool;
#line 88
  F_row = lux->F_row;
#line 89
  F_col = lux->F_col;
#line 90
  V_piv = lux->V_piv;
#line 91
  V_row = lux->V_row;
#line 92
  V_col = lux->V_col;
#line 93
  P_row = lux->P_row;
#line 94
  P_col = lux->P_col;
#line 95
  Q_row = lux->Q_row;
#line 96
  Q_col = lux->Q_col;
#line 97
  R_len = wka->R_len;
#line 98
  R_head = wka->R_head;
#line 99
  R_prev = wka->R_prev;
#line 100
  R_next = wka->R_next;
#line 101
  C_len = wka->C_len;
#line 102
  C_head = wka->C_head;
#line 103
  C_prev = wka->C_prev;
#line 104
  C_next = wka->C_next;
#line 109
  i = 1;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i <= n)) {
#line 109
      goto while_break;
    }
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! ((unsigned long )*(F_row + i) != (unsigned long )((void *)0))) {
#line 110
        goto while_break___0;
      }
      {
#line 111
      fij = *(F_row + i);
#line 111
      *(F_row + i) = fij->r_next;
#line 112
      _glp_mpq_clear(fij->val);
#line 113
      _glp_dmp_free_atom(pool, (void *)fij, (int )sizeof(LUXELM ));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  j = 1;
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 116
    if (! (j <= n)) {
#line 116
      goto while_break___1;
    }
#line 116
    *(F_col + j) = (LUXELM *)((void *)0);
#line 116
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 118
  k = 1;
  {
#line 118
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 118
    if (! (k <= n)) {
#line 118
      goto while_break___2;
    }
    {
#line 118
    _glp_mpq_set_si(*(V_piv + k), 0, 1U);
#line 118
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 119
  i = 1;
  {
#line 119
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 119
    if (! (i <= n)) {
#line 119
      goto while_break___3;
    }
    {
#line 120
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 120
      if (! ((unsigned long )*(V_row + i) != (unsigned long )((void *)0))) {
#line 120
        goto while_break___4;
      }
      {
#line 121
      vij = *(V_row + i);
#line 121
      *(V_row + i) = vij->r_next;
#line 122
      _glp_mpq_clear(vij->val);
#line 123
      _glp_dmp_free_atom(pool, (void *)vij, (int )sizeof(LUXELM ));
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 119
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 126
  j = 1;
  {
#line 126
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 126
    if (! (j <= n)) {
#line 126
      goto while_break___5;
    }
#line 126
    *(V_col + j) = (LUXELM *)((void *)0);
#line 126
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 128
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 128
  ind = (int *)tmp;
#line 129
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(mpq_t ));
#line 129
  val = (mpq_t *)tmp___0;
#line 130
  k = 1;
  }
  {
#line 130
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 130
    if (! (k <= n)) {
#line 130
      goto while_break___6;
    }
    {
#line 130
    *(val + k) = _glp_mpq_init();
#line 130
    k ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 131
  j = 1;
  {
#line 131
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 131
    if (! (j <= n)) {
#line 131
      goto while_break___7;
    }
    {
#line 133
    len = (*col)(info, j, ind, val);
    }
#line 134
    if (0 <= len) {
#line 134
      if (! (len <= n)) {
        {
#line 135
        tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                                   135);
#line 135
        (*tmp___1)("lux_decomp: j = %d: len = %d; invalid column length\n", j, len);
        }
      }
    } else {
      {
#line 135
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                                 135);
#line 135
      (*tmp___1)("lux_decomp: j = %d: len = %d; invalid column length\n", j, len);
      }
    }
#line 138
    k = 1;
    {
#line 138
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 138
      if (! (k <= len)) {
#line 138
        goto while_break___8;
      }
#line 140
      i = *(ind + k);
#line 141
      if (1 <= i) {
#line 141
        if (! (i <= n)) {
          {
#line 142
          tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                                     142);
#line 142
          (*tmp___2)("lux_decomp: j = %d: i = %d; row index out of range\n", j, i);
          }
        }
      } else {
        {
#line 142
        tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                                   142);
#line 142
        (*tmp___2)("lux_decomp: j = %d: i = %d; row index out of range\n", j, i);
        }
      }
#line 145
      if ((unsigned long )*(V_row + i) != (unsigned long )((void *)0)) {
#line 145
        if ((*(V_row + i))->j == j) {
          {
#line 146
          tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                                     146);
#line 146
          (*tmp___3)("lux_decomp: j = %d: i = %d; duplicate row indices not allowed\n",
                     j, i);
          }
        }
      }
      {
#line 149
      tmp___5 = _glp_mpq_sgn(*(val + k));
      }
#line 149
      if (tmp___5 == 0) {
        {
#line 150
        tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                                   150);
#line 150
        (*tmp___4)("lux_decomp: j = %d: i = %d; zero elements not allowed\n", j, i);
        }
      }
      {
#line 153
      tmp___6 = _glp_dmp_get_atom(pool, (int )sizeof(LUXELM ));
#line 153
      vij = (LUXELM *)tmp___6;
#line 154
      vij->i = i;
#line 154
      vij->j = j;
#line 155
      vij->val = _glp_mpq_init();
#line 156
      _glp_mpq_set(vij->val, *(val + k));
#line 157
      vij->r_prev = (LUXELM *)((void *)0);
#line 158
      vij->r_next = *(V_row + i);
#line 159
      vij->c_prev = (LUXELM *)((void *)0);
#line 160
      vij->c_next = *(V_col + j);
      }
#line 161
      if ((unsigned long )vij->r_next != (unsigned long )((void *)0)) {
#line 161
        (vij->r_next)->r_prev = vij;
      }
#line 162
      if ((unsigned long )vij->c_next != (unsigned long )((void *)0)) {
#line 162
        (vij->c_next)->c_prev = vij;
      }
#line 163
      tmp___7 = vij;
#line 163
      *(V_col + j) = tmp___7;
#line 163
      *(V_row + i) = tmp___7;
#line 138
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 131
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 166
  _glp_lib_xfree((void *)ind);
#line 167
  k = 1;
  }
  {
#line 167
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 167
    if (! (k <= n)) {
#line 167
      goto while_break___9;
    }
    {
#line 167
    _glp_mpq_clear(*(val + k));
#line 167
    k ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 168
  _glp_lib_xfree((void *)val);
#line 170
  k = 1;
  }
  {
#line 170
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 170
    if (! (k <= n)) {
#line 170
      goto while_break___10;
    }
#line 171
    tmp___10 = k;
#line 171
    *(Q_col + k) = tmp___10;
#line 171
    tmp___9 = tmp___10;
#line 171
    *(Q_row + k) = tmp___9;
#line 171
    tmp___8 = tmp___9;
#line 171
    *(P_col + k) = tmp___8;
#line 171
    *(P_row + k) = tmp___8;
#line 170
    k ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 173
  lux->rank = -1;
#line 176
  i = 1;
  {
#line 176
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 176
    if (! (i <= n)) {
#line 176
      goto while_break___11;
    }
#line 177
    len = 0;
#line 178
    vij = *(V_row + i);
    {
#line 178
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 178
      if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 178
        goto while_break___12;
      }
#line 178
      len ++;
#line 178
      vij = vij->r_next;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 179
    *(R_len + i) = len;
#line 176
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 182
  len = 0;
  {
#line 182
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 182
    if (! (len <= n)) {
#line 182
      goto while_break___13;
    }
#line 182
    *(R_head + len) = 0;
#line 182
    len ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 183
  i = 1;
  {
#line 183
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 183
    if (! (i <= n)) {
#line 183
      goto while_break___14;
    }
#line 184
    len = *(R_len + i);
#line 185
    *(R_prev + i) = 0;
#line 186
    *(R_next + i) = *(R_head + len);
#line 187
    if (*(R_next + i) != 0) {
#line 187
      *(R_prev + *(R_next + i)) = i;
    }
#line 188
    *(R_head + len) = i;
#line 183
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 191
  j = 1;
  {
#line 191
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 191
    if (! (j <= n)) {
#line 191
      goto while_break___15;
    }
#line 192
    len = 0;
#line 193
    vij = *(V_col + j);
    {
#line 193
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 193
      if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 193
        goto while_break___16;
      }
#line 193
      len ++;
#line 193
      vij = vij->c_next;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 194
    *(C_len + j) = len;
#line 191
    j ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 197
  len = 0;
  {
#line 197
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 197
    if (! (len <= n)) {
#line 197
      goto while_break___17;
    }
#line 197
    *(C_head + len) = 0;
#line 197
    len ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 198
  j = 1;
  {
#line 198
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 198
    if (! (j <= n)) {
#line 198
      goto while_break___18;
    }
#line 199
    len = *(C_len + j);
#line 200
    *(C_prev + j) = 0;
#line 201
    *(C_next + j) = *(C_head + len);
#line 202
    if (*(C_next + j) != 0) {
#line 202
      *(C_prev + *(C_next + j)) = j;
    }
#line 203
    *(C_head + len) = j;
#line 198
    j ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 259 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
static LUXELM *find_pivot(LUX *lux , LUXWKA *wka ) 
{ 
  int n ;
  LUXELM **V_row ;
  LUXELM **V_col ;
  int *R_len ;
  int *R_head ;
  int *R_next ;
  int *C_len ;
  int *C_head ;
  int *C_next ;
  LUXELM *piv ;
  LUXELM *some ;
  LUXELM *vij ;
  int i ;
  int j ;
  int len ;
  int min_len ;
  int ncand ;
  int piv_lim ;
  double best ;
  double cost ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 260
  n = lux->n;
#line 261
  V_row = lux->V_row;
#line 262
  V_col = lux->V_col;
#line 263
  R_len = wka->R_len;
#line 264
  R_head = wka->R_head;
#line 265
  R_next = wka->R_next;
#line 266
  C_len = wka->C_len;
#line 267
  C_head = wka->C_head;
#line 268
  C_next = wka->C_next;
#line 270
  piv_lim = 5;
#line 273
  piv = (LUXELM *)((void *)0);
#line 273
  best = 1.7976931348623157e+308;
#line 273
  ncand = 0;
#line 276
  j = *(C_head + 1);
#line 277
  if (j != 0) {
#line 278
    if (*(C_len + j) == 1) {
#line 278
      tmp = 1;
    } else {
      {
#line 278
      _glp_lib_xassert("C_len[j] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                       278);
#line 278
      tmp = 1;
      }
    }
#line 279
    piv = *(V_col + j);
#line 280
    if ((unsigned long )piv != (unsigned long )((void *)0)) {
#line 280
      if ((unsigned long )piv->c_next == (unsigned long )((void *)0)) {
#line 280
        tmp___0 = 1;
      } else {
        {
#line 280
        _glp_lib_xassert("piv != NULL && piv->c_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                         280);
#line 280
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 280
      _glp_lib_xassert("piv != NULL && piv->c_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                       280);
#line 280
      tmp___0 = 1;
      }
    }
#line 281
    goto done;
  }
#line 285
  i = *(R_head + 1);
#line 286
  if (i != 0) {
#line 287
    if (*(R_len + i) == 1) {
#line 287
      tmp___1 = 1;
    } else {
      {
#line 287
      _glp_lib_xassert("R_len[i] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                       287);
#line 287
      tmp___1 = 1;
      }
    }
#line 288
    piv = *(V_row + i);
#line 289
    if ((unsigned long )piv != (unsigned long )((void *)0)) {
#line 289
      if ((unsigned long )piv->r_next == (unsigned long )((void *)0)) {
#line 289
        tmp___2 = 1;
      } else {
        {
#line 289
        _glp_lib_xassert("piv != NULL && piv->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                         289);
#line 289
        tmp___2 = 1;
        }
      }
    } else {
      {
#line 289
      _glp_lib_xassert("piv != NULL && piv->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                       289);
#line 289
      tmp___2 = 1;
      }
    }
#line 290
    goto done;
  }
#line 294
  len = 2;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (len <= n)) {
#line 294
      goto while_break;
    }
#line 296
    j = *(C_head + len);
    {
#line 296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 296
      if (! (j != 0)) {
#line 296
        goto while_break___0;
      }
#line 299
      some = (LUXELM *)((void *)0);
#line 299
      min_len = 2147483647;
#line 300
      vij = *(V_col + j);
      {
#line 300
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 300
        if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 300
          goto while_break___1;
        }
#line 301
        if (min_len > *(R_len + vij->i)) {
#line 302
          some = vij;
#line 302
          min_len = *(R_len + vij->i);
        }
#line 306
        if (min_len <= len) {
#line 307
          piv = some;
#line 308
          goto done;
        }
#line 300
        vij = vij->c_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 313
      if ((unsigned long )some != (unsigned long )((void *)0)) {
#line 313
        tmp___3 = 1;
      } else {
        {
#line 313
        _glp_lib_xassert("some != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                         313);
#line 313
        tmp___3 = 1;
        }
      }
#line 314
      ncand ++;
#line 316
      cost = (double )(min_len - 1) * (double )(len - 1);
#line 318
      if (cost < best) {
#line 318
        piv = some;
#line 318
        best = cost;
      }
#line 322
      if (ncand == piv_lim) {
#line 322
        goto done;
      }
#line 296
      j = *(C_next + j);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    i = *(R_head + len);
    {
#line 325
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 325
      if (! (i != 0)) {
#line 325
        goto while_break___2;
      }
#line 328
      some = (LUXELM *)((void *)0);
#line 328
      min_len = 2147483647;
#line 329
      vij = *(V_row + i);
      {
#line 329
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 329
        if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 329
          goto while_break___3;
        }
#line 330
        if (min_len > *(C_len + vij->j)) {
#line 331
          some = vij;
#line 331
          min_len = *(C_len + vij->j);
        }
#line 335
        if (min_len <= len) {
#line 336
          piv = some;
#line 337
          goto done;
        }
#line 329
        vij = vij->r_next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 342
      if ((unsigned long )some != (unsigned long )((void *)0)) {
#line 342
        tmp___4 = 1;
      } else {
        {
#line 342
        _glp_lib_xassert("some != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                         342);
#line 342
        tmp___4 = 1;
        }
      }
#line 343
      ncand ++;
#line 345
      cost = (double )(len - 1) * (double )(min_len - 1);
#line 347
      if (cost < best) {
#line 347
        piv = some;
#line 347
        best = cost;
      }
#line 351
      if (ncand == piv_lim) {
#line 351
        goto done;
      }
#line 325
      i = *(R_next + i);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 294
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 355
  return (piv);
}
}
#line 416 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
static void eliminate(LUX *lux , LUXWKA *wka , LUXELM *piv , int *flag , mpq_t *work ) 
{ 
  DMP *pool ;
  LUXELM **F_row ;
  LUXELM **F_col ;
  mpq_t *V_piv ;
  LUXELM **V_row ;
  LUXELM **V_col ;
  int *R_len ;
  int *R_head ;
  int *R_prev ;
  int *R_next ;
  int *C_len ;
  int *C_head ;
  int *C_prev ;
  int *C_next ;
  LUXELM *fip ;
  LUXELM *vij ;
  LUXELM *vpj ;
  LUXELM *viq ;
  LUXELM *next ;
  mpq_t temp ;
  int i ;
  int j ;
  int p ;
  int q ;
  int tmp ;
  void *tmp___0 ;
  LUXELM *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  LUXELM *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 418
  pool = lux->pool;
#line 419
  F_row = lux->F_row;
#line 420
  F_col = lux->F_col;
#line 421
  V_piv = lux->V_piv;
#line 422
  V_row = lux->V_row;
#line 423
  V_col = lux->V_col;
#line 424
  R_len = wka->R_len;
#line 425
  R_head = wka->R_head;
#line 426
  R_prev = wka->R_prev;
#line 427
  R_next = wka->R_next;
#line 428
  C_len = wka->C_len;
#line 429
  C_head = wka->C_head;
#line 430
  C_prev = wka->C_prev;
#line 431
  C_next = wka->C_next;
#line 435
  temp = _glp_mpq_init();
  }
#line 437
  if ((unsigned long )piv != (unsigned long )((void *)0)) {
#line 437
    tmp = 1;
  } else {
    {
#line 437
    _glp_lib_xassert("piv != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                     437);
#line 437
    tmp = 1;
    }
  }
#line 438
  p = piv->i;
#line 438
  q = piv->j;
#line 441
  if (*(R_prev + p) == 0) {
#line 442
    *(R_head + *(R_len + p)) = *(R_next + p);
  } else {
#line 444
    *(R_next + *(R_prev + p)) = *(R_next + p);
  }
#line 445
  if (! (*(R_next + p) == 0)) {
#line 448
    *(R_prev + *(R_next + p)) = *(R_prev + p);
  }
#line 451
  if (*(C_prev + q) == 0) {
#line 452
    *(C_head + *(C_len + q)) = *(C_next + q);
  } else {
#line 454
    *(C_next + *(C_prev + q)) = *(C_next + q);
  }
#line 455
  if (! (*(C_next + q) == 0)) {
#line 458
    *(C_prev + *(C_next + q)) = *(C_prev + q);
  }
  {
#line 460
  _glp_mpq_set(*(V_piv + p), piv->val);
  }
#line 462
  if ((unsigned long )piv->r_prev == (unsigned long )((void *)0)) {
#line 463
    *(V_row + p) = piv->r_next;
  } else {
#line 465
    (piv->r_prev)->r_next = piv->r_next;
  }
#line 466
  if (! ((unsigned long )piv->r_next == (unsigned long )((void *)0))) {
#line 469
    (piv->r_next)->r_prev = piv->r_prev;
  }
#line 470
  (*(R_len + p)) --;
#line 472
  if ((unsigned long )piv->c_prev == (unsigned long )((void *)0)) {
#line 473
    *(V_col + q) = piv->c_next;
  } else {
#line 475
    (piv->c_prev)->c_next = piv->c_next;
  }
#line 476
  if (! ((unsigned long )piv->c_next == (unsigned long )((void *)0))) {
#line 479
    (piv->c_next)->c_prev = piv->c_prev;
  }
  {
#line 480
  (*(C_len + q)) --;
#line 482
  _glp_mpq_clear(piv->val);
#line 483
  _glp_dmp_free_atom(pool, (void *)piv, (int )sizeof(LUXELM ));
#line 486
  vpj = *(V_row + p);
  }
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (! ((unsigned long )vpj != (unsigned long )((void *)0))) {
#line 486
      goto while_break;
    }
    {
#line 488
    j = vpj->j;
#line 490
    *(flag + j) = 1;
#line 491
    _glp_mpq_set(*(work + j), vpj->val);
    }
#line 494
    if (*(C_prev + j) == 0) {
#line 495
      *(C_head + *(C_len + j)) = *(C_next + j);
    } else {
#line 497
      *(C_next + *(C_prev + j)) = *(C_next + j);
    }
#line 498
    if (! (*(C_next + j) == 0)) {
#line 501
      *(C_prev + *(C_next + j)) = *(C_prev + j);
    }
#line 504
    if ((unsigned long )vpj->c_prev == (unsigned long )((void *)0)) {
#line 505
      *(V_col + j) = vpj->c_next;
    } else {
#line 507
      (vpj->c_prev)->c_next = vpj->c_next;
    }
#line 508
    if (! ((unsigned long )vpj->c_next == (unsigned long )((void *)0))) {
#line 511
      (vpj->c_next)->c_prev = vpj->c_prev;
    }
#line 512
    (*(C_len + j)) --;
#line 486
    vpj = vpj->r_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 516
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 516
    if (! ((unsigned long )*(V_col + q) != (unsigned long )((void *)0))) {
#line 516
      goto while_break___0;
    }
#line 518
    viq = *(V_col + q);
#line 520
    i = viq->i;
#line 523
    if (*(R_prev + i) == 0) {
#line 524
      *(R_head + *(R_len + i)) = *(R_next + i);
    } else {
#line 526
      *(R_next + *(R_prev + i)) = *(R_next + i);
    }
#line 527
    if (! (*(R_next + i) == 0)) {
#line 530
      *(R_prev + *(R_next + i)) = *(R_prev + i);
    }
    {
#line 533
    tmp___0 = _glp_dmp_get_atom(pool, (int )sizeof(LUXELM ));
#line 533
    fip = (LUXELM *)tmp___0;
#line 534
    fip->i = i;
#line 534
    fip->j = p;
#line 535
    fip->val = _glp_mpq_init();
#line 536
    _glp_mpq_div(fip->val, viq->val, *(V_piv + p));
#line 537
    fip->r_prev = (LUXELM *)((void *)0);
#line 538
    fip->r_next = *(F_row + i);
#line 539
    fip->c_prev = (LUXELM *)((void *)0);
#line 540
    fip->c_next = *(F_col + p);
    }
#line 541
    if ((unsigned long )fip->r_next != (unsigned long )((void *)0)) {
#line 541
      (fip->r_next)->r_prev = fip;
    }
#line 542
    if ((unsigned long )fip->c_next != (unsigned long )((void *)0)) {
#line 542
      (fip->c_next)->c_prev = fip;
    }
#line 543
    tmp___1 = fip;
#line 543
    *(F_col + p) = tmp___1;
#line 543
    *(F_row + i) = tmp___1;
#line 545
    if ((unsigned long )viq->r_prev == (unsigned long )((void *)0)) {
#line 546
      *(V_row + i) = viq->r_next;
    } else {
#line 548
      (viq->r_prev)->r_next = viq->r_next;
    }
#line 549
    if (! ((unsigned long )viq->r_next == (unsigned long )((void *)0))) {
#line 552
      (viq->r_next)->r_prev = viq->r_prev;
    }
    {
#line 553
    (*(R_len + i)) --;
#line 555
    *(V_col + q) = viq->c_next;
#line 556
    (*(C_len + q)) --;
#line 558
    _glp_mpq_clear(viq->val);
#line 559
    _glp_dmp_free_atom(pool, (void *)viq, (int )sizeof(LUXELM ));
#line 567
    vij = *(V_row + i);
    }
    {
#line 567
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 567
      if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 567
        goto while_break___1;
      }
#line 568
      next = vij->r_next;
#line 570
      j = vij->j;
#line 572
      if (*(flag + j)) {
        {
#line 574
        *(flag + j) = 0;
#line 575
        _glp_mpq_mul(temp, fip->val, *(work + j));
#line 576
        _glp_mpq_sub(vij->val, vij->val, temp);
#line 577
        tmp___2 = _glp_mpq_sgn(vij->val);
        }
#line 577
        if (tmp___2 == 0) {
#line 581
          if ((unsigned long )vij->r_prev == (unsigned long )((void *)0)) {
#line 582
            *(V_row + i) = vij->r_next;
          } else {
#line 584
            (vij->r_prev)->r_next = vij->r_next;
          }
#line 585
          if (! ((unsigned long )vij->r_next == (unsigned long )((void *)0))) {
#line 588
            (vij->r_next)->r_prev = vij->r_prev;
          }
#line 589
          (*(R_len + i)) --;
#line 591
          if ((unsigned long )vij->c_prev == (unsigned long )((void *)0)) {
#line 592
            *(V_col + j) = vij->c_next;
          } else {
#line 594
            (vij->c_prev)->c_next = vij->c_next;
          }
#line 595
          if (! ((unsigned long )vij->c_next == (unsigned long )((void *)0))) {
#line 598
            (vij->c_next)->c_prev = vij->c_prev;
          }
          {
#line 599
          (*(C_len + j)) --;
#line 601
          _glp_mpq_clear(vij->val);
#line 602
          _glp_dmp_free_atom(pool, (void *)vij, (int )sizeof(LUXELM ));
          }
        }
      }
#line 567
      vij = next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 609
    vpj = *(V_row + p);
    {
#line 609
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 609
      if (! ((unsigned long )vpj != (unsigned long )((void *)0))) {
#line 609
        goto while_break___2;
      }
#line 610
      j = vpj->j;
#line 611
      if (*(flag + j)) {
        {
#line 614
        tmp___3 = _glp_dmp_get_atom(pool, (int )sizeof(LUXELM ));
#line 614
        vij = (LUXELM *)tmp___3;
#line 615
        vij->i = i;
#line 615
        vij->j = j;
#line 616
        vij->val = _glp_mpq_init();
#line 617
        _glp_mpq_mul(vij->val, fip->val, *(work + j));
#line 618
        _glp_mpq_neg(vij->val, vij->val);
#line 619
        vij->r_prev = (LUXELM *)((void *)0);
#line 620
        vij->r_next = *(V_row + i);
#line 621
        vij->c_prev = (LUXELM *)((void *)0);
#line 622
        vij->c_next = *(V_col + j);
        }
#line 623
        if ((unsigned long )vij->r_next != (unsigned long )((void *)0)) {
#line 623
          (vij->r_next)->r_prev = vij;
        }
#line 624
        if ((unsigned long )vij->c_next != (unsigned long )((void *)0)) {
#line 624
          (vij->c_next)->c_prev = vij;
        }
#line 625
        tmp___4 = vij;
#line 625
        *(V_col + j) = tmp___4;
#line 625
        *(V_row + i) = tmp___4;
#line 626
        (*(R_len + i)) ++;
#line 626
        (*(C_len + j)) ++;
      } else {
#line 631
        *(flag + j) = 1;
      }
#line 609
      vpj = vpj->r_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 636
    *(R_prev + i) = 0;
#line 637
    *(R_next + i) = *(R_head + *(R_len + i));
#line 638
    if (*(R_next + i) != 0) {
#line 638
      *(R_prev + *(R_next + i)) = i;
    }
#line 639
    *(R_head + *(R_len + i)) = i;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 642
  if (*(C_len + q) == 0) {
#line 642
    tmp___5 = 1;
  } else {
    {
#line 642
    _glp_lib_xassert("C_len[q] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                     642);
#line 642
    tmp___5 = 1;
    }
  }
#line 644
  vpj = *(V_row + p);
  {
#line 644
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 644
    if (! ((unsigned long )vpj != (unsigned long )((void *)0))) {
#line 644
      goto while_break___3;
    }
    {
#line 646
    j = vpj->j;
#line 648
    *(flag + j) = 0;
#line 649
    _glp_mpq_set_si(*(work + j), 0, 1U);
#line 652
    *(C_prev + j) = 0;
#line 653
    *(C_next + j) = *(C_head + *(C_len + j));
    }
#line 654
    if (*(C_next + j) != 0) {
#line 654
      *(C_prev + *(C_next + j)) = j;
    }
#line 655
    *(C_head + *(C_len + j)) = j;
#line 644
    vpj = vpj->r_next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 657
  _glp_mpq_clear(temp);
  }
#line 659
  return;
}
}
#line 735 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
int _glp_lux_decomp(LUX *lux , int (*col)(void *info , int j , int *ind , mpq_t *val ) ,
                    void *info ) 
{ 
  int n ;
  LUXELM **V_row ;
  LUXELM **V_col ;
  int *P_row ;
  int *P_col ;
  int *Q_row ;
  int *Q_col ;
  LUXELM *piv ;
  LUXELM *vij ;
  LUXWKA *wka ;
  int i ;
  int j ;
  int k ;
  int p ;
  int q ;
  int t ;
  int *flag ;
  mpq_t *work ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 737
  n = lux->n;
#line 738
  V_row = lux->V_row;
#line 739
  V_col = lux->V_col;
#line 740
  P_row = lux->P_row;
#line 741
  P_col = lux->P_col;
#line 742
  Q_row = lux->Q_row;
#line 743
  Q_col = lux->Q_col;
#line 749
  tmp = _glp_lib_xmalloc((int )sizeof(LUXWKA ));
#line 749
  wka = (LUXWKA *)tmp;
#line 750
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 750
  wka->R_len = (int *)tmp___0;
#line 751
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 751
  wka->R_head = (int *)tmp___1;
#line 752
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 752
  wka->R_prev = (int *)tmp___2;
#line 753
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 753
  wka->R_next = (int *)tmp___3;
#line 754
  tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 754
  wka->C_len = (int *)tmp___4;
#line 755
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 755
  wka->C_head = (int *)tmp___5;
#line 756
  tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 756
  wka->C_prev = (int *)tmp___6;
#line 757
  tmp___7 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 757
  wka->C_next = (int *)tmp___7;
#line 759
  initialize(lux, col, info, wka);
#line 761
  tmp___8 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 761
  flag = (int *)tmp___8;
#line 762
  tmp___9 = _glp_lib_xcalloc(1 + n, (int )sizeof(mpq_t ));
#line 762
  work = (mpq_t *)tmp___9;
#line 763
  k = 1;
  }
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! (k <= n)) {
#line 763
      goto while_break;
    }
    {
#line 764
    *(flag + k) = 0;
#line 765
    *(work + k) = _glp_mpq_init();
#line 763
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 768
  k = 1;
  {
#line 768
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 768
    if (! (k <= n)) {
#line 768
      goto while_break___0;
    }
    {
#line 770
    piv = find_pivot(lux, wka);
    }
#line 771
    if ((unsigned long )piv == (unsigned long )((void *)0)) {
#line 774
      goto while_break___0;
    }
#line 777
    p = piv->i;
#line 777
    q = piv->j;
#line 781
    i = *(P_col + p);
#line 781
    j = *(Q_row + q);
#line 782
    if (k <= i) {
#line 782
      if (i <= n) {
#line 782
        if (k <= j) {
#line 782
          if (j <= n) {
#line 782
            tmp___10 = 1;
          } else {
            {
#line 782
            _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                             782);
#line 782
            tmp___10 = 1;
            }
          }
        } else {
          {
#line 782
          _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                           782);
#line 782
          tmp___10 = 1;
          }
        }
      } else {
        {
#line 782
        _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                         782);
#line 782
        tmp___10 = 1;
        }
      }
    } else {
      {
#line 782
      _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                       782);
#line 782
      tmp___10 = 1;
      }
    }
    {
#line 784
    t = *(P_row + k);
#line 785
    *(P_row + i) = t;
#line 785
    *(P_col + t) = i;
#line 786
    *(P_row + k) = p;
#line 786
    *(P_col + p) = k;
#line 788
    t = *(Q_col + k);
#line 789
    *(Q_col + j) = t;
#line 789
    *(Q_row + t) = j;
#line 790
    *(Q_col + k) = q;
#line 790
    *(Q_row + q) = k;
#line 793
    eliminate(lux, wka, piv, flag, work);
#line 768
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 796
  lux->rank = k - 1;
#line 798
  _glp_lib_xfree((void *)flag);
#line 799
  k = 1;
  }
  {
#line 799
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 799
    if (! (k <= n)) {
#line 799
      goto while_break___1;
    }
    {
#line 799
    _glp_mpq_clear(*(work + k));
#line 799
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 800
  _glp_lib_xfree((void *)work);
#line 802
  j = 1;
  }
  {
#line 802
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 802
    if (! (j <= n)) {
#line 802
      goto while_break___2;
    }
#line 803
    if ((unsigned long )*(V_col + j) == (unsigned long )((void *)0)) {
#line 803
      tmp___11 = 1;
    } else {
      {
#line 803
      _glp_lib_xassert("V_col[j] == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplux.c",
                       803);
#line 803
      tmp___11 = 1;
      }
    }
#line 802
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 804
  i = 1;
  {
#line 804
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 804
    if (! (i <= n)) {
#line 804
      goto while_break___3;
    }
#line 805
    vij = *(V_row + i);
    {
#line 805
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 805
      if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 805
        goto while_break___4;
      }
#line 806
      j = vij->j;
#line 807
      vij->c_prev = (LUXELM *)((void *)0);
#line 808
      vij->c_next = *(V_col + j);
#line 809
      if ((unsigned long )vij->c_next != (unsigned long )((void *)0)) {
#line 809
        (vij->c_next)->c_prev = vij;
      }
#line 810
      *(V_col + j) = vij;
#line 805
      vij = vij->r_next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 804
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 814
  _glp_lib_xfree((void *)wka->R_len);
#line 815
  _glp_lib_xfree((void *)wka->R_head);
#line 816
  _glp_lib_xfree((void *)wka->R_prev);
#line 817
  _glp_lib_xfree((void *)wka->R_next);
#line 818
  _glp_lib_xfree((void *)wka->C_len);
#line 819
  _glp_lib_xfree((void *)wka->C_head);
#line 820
  _glp_lib_xfree((void *)wka->C_prev);
#line 821
  _glp_lib_xfree((void *)wka->C_next);
#line 822
  _glp_lib_xfree((void *)wka);
  }
#line 824
  return (lux->rank < n);
}
}
#line 847 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
void _glp_lux_f_solve(LUX *lux , int tr , mpq_t *x ) 
{ 
  int n ;
  LUXELM **F_row ;
  LUXELM **F_col ;
  int *P_row ;
  LUXELM *fik ;
  LUXELM *fkj ;
  int i ;
  int j ;
  int k ;
  mpq_t temp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 848
  n = lux->n;
#line 849
  F_row = lux->F_row;
#line 850
  F_col = lux->F_col;
#line 851
  P_row = lux->P_row;
#line 855
  temp = _glp_mpq_init();
  }
#line 856
  if (! tr) {
#line 858
    j = 1;
    {
#line 858
    while (1) {
      while_continue: /* CIL Label */ ;
#line 858
      if (! (j <= n)) {
#line 858
        goto while_break;
      }
      {
#line 859
      k = *(P_row + j);
#line 860
      tmp = _glp_mpq_sgn(*(x + k));
      }
#line 860
      if (tmp != 0) {
#line 861
        fik = *(F_col + k);
        {
#line 861
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 861
          if (! ((unsigned long )fik != (unsigned long )((void *)0))) {
#line 861
            goto while_break___0;
          }
          {
#line 862
          _glp_mpq_mul(temp, fik->val, *(x + k));
#line 863
          _glp_mpq_sub(*(x + fik->i), *(x + fik->i), temp);
#line 861
          fik = fik->c_next;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 858
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 870
    i = n;
    {
#line 870
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 870
      if (! (i >= 1)) {
#line 870
        goto while_break___1;
      }
      {
#line 871
      k = *(P_row + i);
#line 872
      tmp___0 = _glp_mpq_sgn(*(x + k));
      }
#line 872
      if (tmp___0 != 0) {
#line 873
        fkj = *(F_row + k);
        {
#line 873
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 873
          if (! ((unsigned long )fkj != (unsigned long )((void *)0))) {
#line 873
            goto while_break___2;
          }
          {
#line 874
          _glp_mpq_mul(temp, fkj->val, *(x + k));
#line 875
          _glp_mpq_sub(*(x + fkj->j), *(x + fkj->j), temp);
#line 873
          fkj = fkj->r_next;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 870
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 880
  _glp_mpq_clear(temp);
  }
#line 881
  return;
}
}
#line 904 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
void _glp_lux_v_solve(LUX *lux , int tr , mpq_t *x ) 
{ 
  int n ;
  mpq_t *V_piv ;
  LUXELM **V_row ;
  LUXELM **V_col ;
  int *P_row ;
  int *Q_col ;
  LUXELM *vij ;
  int i ;
  int j ;
  int k ;
  mpq_t *b ;
  mpq_t temp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 905
  n = lux->n;
#line 906
  V_piv = lux->V_piv;
#line 907
  V_row = lux->V_row;
#line 908
  V_col = lux->V_col;
#line 909
  P_row = lux->P_row;
#line 910
  Q_col = lux->Q_col;
#line 914
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(mpq_t ));
#line 914
  b = (mpq_t *)tmp;
#line 915
  k = 1;
  }
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (! (k <= n)) {
#line 915
      goto while_break;
    }
    {
#line 916
    *(b + k) = _glp_mpq_init();
#line 916
    _glp_mpq_set(*(b + k), *(x + k));
#line 916
    _glp_mpq_set_si(*(x + k), 0, 1U);
#line 915
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 917
  temp = _glp_mpq_init();
  }
#line 918
  if (! tr) {
#line 920
    k = n;
    {
#line 920
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 920
      if (! (k >= 1)) {
#line 920
        goto while_break___0;
      }
      {
#line 921
      i = *(P_row + k);
#line 921
      j = *(Q_col + k);
#line 922
      tmp___0 = _glp_mpq_sgn(*(b + i));
      }
#line 922
      if (tmp___0 != 0) {
        {
#line 923
        _glp_mpq_set(*(x + j), *(b + i));
#line 924
        _glp_mpq_div(*(x + j), *(x + j), *(V_piv + i));
#line 925
        vij = *(V_col + j);
        }
        {
#line 925
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 925
          if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 925
            goto while_break___1;
          }
          {
#line 926
          _glp_mpq_mul(temp, vij->val, *(x + j));
#line 927
          _glp_mpq_sub(*(b + vij->i), *(b + vij->i), temp);
#line 925
          vij = vij->c_next;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 920
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 934
    k = 1;
    {
#line 934
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 934
      if (! (k <= n)) {
#line 934
        goto while_break___2;
      }
      {
#line 935
      i = *(P_row + k);
#line 935
      j = *(Q_col + k);
#line 936
      tmp___1 = _glp_mpq_sgn(*(b + j));
      }
#line 936
      if (tmp___1 != 0) {
        {
#line 937
        _glp_mpq_set(*(x + i), *(b + j));
#line 938
        _glp_mpq_div(*(x + i), *(x + i), *(V_piv + i));
#line 939
        vij = *(V_row + i);
        }
        {
#line 939
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 939
          if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 939
            goto while_break___3;
          }
          {
#line 940
          _glp_mpq_mul(temp, vij->val, *(x + i));
#line 941
          _glp_mpq_sub(*(b + vij->j), *(b + vij->j), temp);
#line 939
          vij = vij->r_next;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 934
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 946
  k = 1;
  {
#line 946
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 946
    if (! (k <= n)) {
#line 946
      goto while_break___4;
    }
    {
#line 946
    _glp_mpq_clear(*(b + k));
#line 946
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 947
  _glp_mpq_clear(temp);
#line 948
  _glp_lib_xfree((void *)b);
  }
#line 949
  return;
}
}
#line 972 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
void _glp_lux_solve(LUX *lux , int tr , mpq_t *x ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 973
  if (lux->rank < lux->n) {
    {
#line 974
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplux.c", 974);
#line 974
    (*tmp)("lux_solve: LU-factorization has incomplete rank\n");
    }
  }
#line 975
  if (! tr) {
    {
#line 977
    _glp_lux_f_solve(lux, 0, x);
#line 978
    _glp_lux_v_solve(lux, 0, x);
    }
  } else {
    {
#line 982
    _glp_lux_v_solve(lux, 1, x);
#line 983
    _glp_lux_f_solve(lux, 1, x);
    }
  }
#line 985
  return;
}
}
#line 1002 "/home/wslee/benchmarks/glpk-4.38/src/glplux.c"
void _glp_lux_delete(LUX *lux ) 
{ 
  int n ;
  LUXELM *fij ;
  LUXELM *vij ;
  int i ;

  {
#line 1003
  n = lux->n;
#line 1006
  i = 1;
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if (! (i <= n)) {
#line 1006
      goto while_break;
    }
#line 1007
    fij = *(lux->F_row + i);
    {
#line 1007
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1007
      if (! ((unsigned long )fij != (unsigned long )((void *)0))) {
#line 1007
        goto while_break___0;
      }
      {
#line 1008
      _glp_mpq_clear(fij->val);
#line 1007
      fij = fij->r_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1009
    _glp_mpq_clear(*(lux->V_piv + i));
#line 1010
    vij = *(lux->V_row + i);
    }
    {
#line 1010
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1010
      if (! ((unsigned long )vij != (unsigned long )((void *)0))) {
#line 1010
        goto while_break___1;
      }
      {
#line 1011
      _glp_mpq_clear(vij->val);
#line 1010
      vij = vij->r_next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1006
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1013
  _glp_dmp_delete_pool(lux->pool);
#line 1014
  _glp_lib_xfree((void *)lux->F_row);
#line 1015
  _glp_lib_xfree((void *)lux->F_col);
#line 1016
  _glp_lib_xfree((void *)lux->V_piv);
#line 1017
  _glp_lib_xfree((void *)lux->V_row);
#line 1018
  _glp_lib_xfree((void *)lux->V_col);
#line 1019
  _glp_lib_xfree((void *)lux->P_row);
#line 1020
  _glp_lib_xfree((void *)lux->P_col);
#line 1021
  _glp_lib_xfree((void *)lux->Q_row);
#line 1022
  _glp_lib_xfree((void *)lux->Q_col);
#line 1023
  _glp_lib_xfree((void *)lux);
  }
#line 1024
  return;
}
}
#line 287 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.h"
LUF *_glp_luf_create_it(void) ;
#line 291
void _glp_luf_defrag_sva(LUF *luf ) ;
#line 295
int _glp_luf_enlarge_row(LUF *luf , int i , int cap ) ;
#line 299
int _glp_luf_enlarge_col(LUF *luf , int j , int cap ) ;
#line 303
int _glp_luf_factorize(LUF *luf , int n , int (*col)(void *info , int j , int *ind ,
                                                     double *val ) , void *info ) ;
#line 308
void _glp_luf_f_solve(LUF *luf , int tr , double *x ) ;
#line 312
void _glp_luf_v_solve(LUF *luf , int tr , double *x ) ;
#line 316
void _glp_luf_a_solve(LUF *luf , int tr , double *x ) ;
#line 320
void _glp_luf_delete_it(LUF *luf ) ;
#line 52 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
LUF *_glp_luf_create_it(void) 
{ 
  LUF *luf ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;

  {
  {
#line 54
  tmp = _glp_lib_xmalloc((int )sizeof(LUF ));
#line 54
  luf = (LUF *)tmp;
#line 55
  tmp___0 = 0;
#line 55
  luf->n = tmp___0;
#line 55
  luf->n_max = tmp___0;
#line 56
  luf->valid = 0;
#line 57
  tmp___1 = (int *)((void *)0);
#line 57
  luf->fr_len = tmp___1;
#line 57
  luf->fr_ptr = tmp___1;
#line 58
  tmp___2 = (int *)((void *)0);
#line 58
  luf->fc_len = tmp___2;
#line 58
  luf->fc_ptr = tmp___2;
#line 59
  tmp___4 = (int *)((void *)0);
#line 59
  luf->vr_cap = tmp___4;
#line 59
  tmp___3 = tmp___4;
#line 59
  luf->vr_len = tmp___3;
#line 59
  luf->vr_ptr = tmp___3;
#line 60
  luf->vr_piv = (double *)((void *)0);
#line 61
  tmp___6 = (int *)((void *)0);
#line 61
  luf->vc_cap = tmp___6;
#line 61
  tmp___5 = tmp___6;
#line 61
  luf->vc_len = tmp___5;
#line 61
  luf->vc_ptr = tmp___5;
#line 62
  tmp___7 = (int *)((void *)0);
#line 62
  luf->pp_col = tmp___7;
#line 62
  luf->pp_row = tmp___7;
#line 63
  tmp___8 = (int *)((void *)0);
#line 63
  luf->qq_col = tmp___8;
#line 63
  luf->qq_row = tmp___8;
#line 64
  luf->sv_size = 0;
#line 65
  tmp___9 = 0;
#line 65
  luf->sv_end = tmp___9;
#line 65
  luf->sv_beg = tmp___9;
#line 66
  luf->sv_ind = (int *)((void *)0);
#line 67
  luf->sv_val = (double *)((void *)0);
#line 68
  tmp___10 = 0;
#line 68
  luf->sv_tail = tmp___10;
#line 68
  luf->sv_head = tmp___10;
#line 69
  tmp___11 = (int *)((void *)0);
#line 69
  luf->sv_next = tmp___11;
#line 69
  luf->sv_prev = tmp___11;
#line 70
  luf->vr_max = (double *)((void *)0);
#line 71
  tmp___13 = (int *)((void *)0);
#line 71
  luf->rs_next = tmp___13;
#line 71
  tmp___12 = tmp___13;
#line 71
  luf->rs_prev = tmp___12;
#line 71
  luf->rs_head = tmp___12;
#line 72
  tmp___15 = (int *)((void *)0);
#line 72
  luf->cs_next = tmp___15;
#line 72
  tmp___14 = tmp___15;
#line 72
  luf->cs_prev = tmp___14;
#line 72
  luf->cs_head = tmp___14;
#line 73
  luf->flag = (int *)((void *)0);
#line 74
  luf->work = (double *)((void *)0);
#line 75
  luf->new_sva = 0;
#line 76
  luf->piv_tol = 0.10;
#line 77
  luf->piv_lim = 4;
#line 78
  luf->suhl = 1;
#line 79
  luf->eps_tol = 1e-15;
#line 80
  luf->max_gro = 1e+10;
#line 81
  tmp___17 = 0;
#line 81
  luf->nnz_v = tmp___17;
#line 81
  tmp___16 = tmp___17;
#line 81
  luf->nnz_f = tmp___16;
#line 81
  luf->nnz_a = tmp___16;
#line 82
  tmp___18 = 0.0;
#line 82
  luf->big_v = tmp___18;
#line 82
  luf->max_a = tmp___18;
#line 83
  luf->rank = 0;
  }
#line 84
  return (luf);
}
}
#line 110 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
void _glp_luf_defrag_sva(LUF *luf ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ind ;
  double *sv_val ;
  int *sv_next ;
  int sv_beg ;
  int i ;
  int j ;
  int k ;

  {
#line 111
  n = luf->n;
#line 112
  vr_ptr = luf->vr_ptr;
#line 113
  vr_len = luf->vr_len;
#line 114
  vr_cap = luf->vr_cap;
#line 115
  vc_ptr = luf->vc_ptr;
#line 116
  vc_len = luf->vc_len;
#line 117
  vc_cap = luf->vc_cap;
#line 118
  sv_ind = luf->sv_ind;
#line 119
  sv_val = luf->sv_val;
#line 120
  sv_next = luf->sv_next;
#line 121
  sv_beg = 1;
#line 124
  k = luf->sv_head;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (k != 0)) {
#line 124
      goto while_break;
    }
#line 125
    if (k <= n) {
#line 127
      i = k;
#line 128
      if (*(vr_ptr + i) != sv_beg) {
#line 128
        goto while_break;
      }
#line 129
      *(vr_cap + i) = *(vr_len + i);
#line 130
      sv_beg += *(vr_cap + i);
    } else {
#line 134
      j = k - n;
#line 135
      if (*(vc_ptr + j) != sv_beg) {
#line 135
        goto while_break;
      }
#line 136
      *(vc_cap + j) = *(vc_len + j);
#line 137
      sv_beg += *(vc_cap + j);
    }
#line 124
    k = *(sv_next + k);
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  k = k;
  {
#line 142
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 142
    if (! (k != 0)) {
#line 142
      goto while_break___0;
    }
#line 143
    if (k <= n) {
      {
#line 145
      i = k;
#line 146
      memmove((void *)(sv_ind + sv_beg), (void const   *)(sv_ind + *(vr_ptr + i)),
              (size_t )((unsigned long )*(vr_len + i) * sizeof(int )));
#line 148
      memmove((void *)(sv_val + sv_beg), (void const   *)(sv_val + *(vr_ptr + i)),
              (size_t )((unsigned long )*(vr_len + i) * sizeof(double )));
#line 150
      *(vr_ptr + i) = sv_beg;
#line 151
      *(vr_cap + i) = *(vr_len + i);
#line 152
      sv_beg += *(vr_cap + i);
      }
    } else {
      {
#line 156
      j = k - n;
#line 157
      memmove((void *)(sv_ind + sv_beg), (void const   *)(sv_ind + *(vc_ptr + j)),
              (size_t )((unsigned long )*(vc_len + j) * sizeof(int )));
#line 159
      memmove((void *)(sv_val + sv_beg), (void const   *)(sv_val + *(vc_ptr + j)),
              (size_t )((unsigned long )*(vc_len + j) * sizeof(double )));
#line 161
      *(vc_ptr + j) = sv_beg;
#line 162
      *(vc_cap + j) = *(vc_len + j);
#line 163
      sv_beg += *(vc_cap + j);
      }
    }
#line 142
    k = *(sv_next + k);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  luf->sv_beg = sv_beg;
#line 168
  return;
}
}
#line 199 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
int _glp_luf_enlarge_row(LUF *luf , int i , int cap ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  int *vc_cap ;
  int *sv_ind ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int ret ;
  int cur ;
  int k ;
  int kk ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 200
  n = luf->n;
#line 201
  vr_ptr = luf->vr_ptr;
#line 202
  vr_len = luf->vr_len;
#line 203
  vr_cap = luf->vr_cap;
#line 204
  vc_cap = luf->vc_cap;
#line 205
  sv_ind = luf->sv_ind;
#line 206
  sv_val = luf->sv_val;
#line 207
  sv_prev = luf->sv_prev;
#line 208
  sv_next = luf->sv_next;
#line 209
  ret = 0;
#line 211
  if (1 <= i) {
#line 211
    if (i <= n) {
#line 211
      tmp = 1;
    } else {
      {
#line 211
      _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       211);
#line 211
      tmp = 1;
      }
    }
  } else {
    {
#line 211
    _glp_lib_xassert("1 <= i && i <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     211);
#line 211
    tmp = 1;
    }
  }
#line 212
  if (*(vr_cap + i) < cap) {
#line 212
    tmp___0 = 1;
  } else {
    {
#line 212
    _glp_lib_xassert("vr_cap[i] < cap", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     212);
#line 212
    tmp___0 = 1;
    }
  }
#line 214
  if (luf->sv_end - luf->sv_beg < cap) {
    {
#line 215
    _glp_luf_defrag_sva(luf);
    }
#line 216
    if (luf->sv_end - luf->sv_beg < cap) {
#line 217
      ret = 1;
#line 218
      goto done;
    }
  }
  {
#line 222
  cur = *(vr_cap + i);
#line 224
  memmove((void *)(sv_ind + luf->sv_beg), (void const   *)(sv_ind + *(vr_ptr + i)),
          (size_t )((unsigned long )*(vr_len + i) * sizeof(int )));
#line 226
  memmove((void *)(sv_val + luf->sv_beg), (void const   *)(sv_val + *(vr_ptr + i)),
          (size_t )((unsigned long )*(vr_len + i) * sizeof(double )));
#line 229
  *(vr_ptr + i) = luf->sv_beg;
#line 230
  *(vr_cap + i) = cap;
#line 232
  luf->sv_beg += cap;
#line 236
  k = i;
  }
#line 238
  if (*(sv_prev + k) == 0) {
#line 239
    luf->sv_head = *(sv_next + k);
  } else {
#line 243
    kk = *(sv_prev + k);
#line 244
    if (kk <= n) {
#line 244
      *(vr_cap + kk) += cur;
    } else {
#line 244
      *(vc_cap + (kk - n)) += cur;
    }
#line 245
    *(sv_next + *(sv_prev + k)) = *(sv_next + k);
  }
#line 247
  if (*(sv_next + k) == 0) {
#line 248
    luf->sv_tail = *(sv_prev + k);
  } else {
#line 250
    *(sv_prev + *(sv_next + k)) = *(sv_prev + k);
  }
#line 252
  *(sv_prev + k) = luf->sv_tail;
#line 253
  *(sv_next + k) = 0;
#line 254
  if (*(sv_prev + k) == 0) {
#line 255
    luf->sv_head = k;
  } else {
#line 257
    *(sv_next + *(sv_prev + k)) = k;
  }
#line 258
  luf->sv_tail = k;
  done: 
#line 259
  return (ret);
}
}
#line 291 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
int _glp_luf_enlarge_col(LUF *luf , int j , int cap ) 
{ 
  int n ;
  int *vr_cap ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ind ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int ret ;
  int cur ;
  int k ;
  int kk ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 292
  n = luf->n;
#line 293
  vr_cap = luf->vr_cap;
#line 294
  vc_ptr = luf->vc_ptr;
#line 295
  vc_len = luf->vc_len;
#line 296
  vc_cap = luf->vc_cap;
#line 297
  sv_ind = luf->sv_ind;
#line 298
  sv_val = luf->sv_val;
#line 299
  sv_prev = luf->sv_prev;
#line 300
  sv_next = luf->sv_next;
#line 301
  ret = 0;
#line 303
  if (1 <= j) {
#line 303
    if (j <= n) {
#line 303
      tmp = 1;
    } else {
      {
#line 303
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       303);
#line 303
      tmp = 1;
      }
    }
  } else {
    {
#line 303
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     303);
#line 303
    tmp = 1;
    }
  }
#line 304
  if (*(vc_cap + j) < cap) {
#line 304
    tmp___0 = 1;
  } else {
    {
#line 304
    _glp_lib_xassert("vc_cap[j] < cap", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     304);
#line 304
    tmp___0 = 1;
    }
  }
#line 306
  if (luf->sv_end - luf->sv_beg < cap) {
    {
#line 307
    _glp_luf_defrag_sva(luf);
    }
#line 308
    if (luf->sv_end - luf->sv_beg < cap) {
#line 309
      ret = 1;
#line 310
      goto done;
    }
  }
  {
#line 314
  cur = *(vc_cap + j);
#line 316
  memmove((void *)(sv_ind + luf->sv_beg), (void const   *)(sv_ind + *(vc_ptr + j)),
          (size_t )((unsigned long )*(vc_len + j) * sizeof(int )));
#line 318
  memmove((void *)(sv_val + luf->sv_beg), (void const   *)(sv_val + *(vc_ptr + j)),
          (size_t )((unsigned long )*(vc_len + j) * sizeof(double )));
#line 321
  *(vc_ptr + j) = luf->sv_beg;
#line 322
  *(vc_cap + j) = cap;
#line 324
  luf->sv_beg += cap;
#line 328
  k = n + j;
  }
#line 330
  if (*(sv_prev + k) == 0) {
#line 331
    luf->sv_head = *(sv_next + k);
  } else {
#line 335
    kk = *(sv_prev + k);
#line 336
    if (kk <= n) {
#line 336
      *(vr_cap + kk) += cur;
    } else {
#line 336
      *(vc_cap + (kk - n)) += cur;
    }
#line 337
    *(sv_next + *(sv_prev + k)) = *(sv_next + k);
  }
#line 339
  if (*(sv_next + k) == 0) {
#line 340
    luf->sv_tail = *(sv_prev + k);
  } else {
#line 342
    *(sv_prev + *(sv_next + k)) = *(sv_prev + k);
  }
#line 344
  *(sv_prev + k) = luf->sv_tail;
#line 345
  *(sv_next + k) = 0;
#line 346
  if (*(sv_prev + k) == 0) {
#line 347
    luf->sv_head = k;
  } else {
#line 349
    *(sv_next + *(sv_prev + k)) = k;
  }
#line 350
  luf->sv_tail = k;
  done: 
#line 351
  return (ret);
}
}
#line 360 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
static void reallocate(LUF *luf , int n ) 
{ 
  int n_max ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;

  {
#line 361
  n_max = luf->n_max;
#line 362
  luf->n = n;
#line 363
  if (n <= n_max) {
#line 363
    goto done;
  }
#line 364
  if ((unsigned long )luf->fr_ptr != (unsigned long )((void *)0)) {
    {
#line 364
    _glp_lib_xfree((void *)luf->fr_ptr);
    }
  }
#line 365
  if ((unsigned long )luf->fr_len != (unsigned long )((void *)0)) {
    {
#line 365
    _glp_lib_xfree((void *)luf->fr_len);
    }
  }
#line 366
  if ((unsigned long )luf->fc_ptr != (unsigned long )((void *)0)) {
    {
#line 366
    _glp_lib_xfree((void *)luf->fc_ptr);
    }
  }
#line 367
  if ((unsigned long )luf->fc_len != (unsigned long )((void *)0)) {
    {
#line 367
    _glp_lib_xfree((void *)luf->fc_len);
    }
  }
#line 368
  if ((unsigned long )luf->vr_ptr != (unsigned long )((void *)0)) {
    {
#line 368
    _glp_lib_xfree((void *)luf->vr_ptr);
    }
  }
#line 369
  if ((unsigned long )luf->vr_len != (unsigned long )((void *)0)) {
    {
#line 369
    _glp_lib_xfree((void *)luf->vr_len);
    }
  }
#line 370
  if ((unsigned long )luf->vr_cap != (unsigned long )((void *)0)) {
    {
#line 370
    _glp_lib_xfree((void *)luf->vr_cap);
    }
  }
#line 371
  if ((unsigned long )luf->vr_piv != (unsigned long )((void *)0)) {
    {
#line 371
    _glp_lib_xfree((void *)luf->vr_piv);
    }
  }
#line 372
  if ((unsigned long )luf->vc_ptr != (unsigned long )((void *)0)) {
    {
#line 372
    _glp_lib_xfree((void *)luf->vc_ptr);
    }
  }
#line 373
  if ((unsigned long )luf->vc_len != (unsigned long )((void *)0)) {
    {
#line 373
    _glp_lib_xfree((void *)luf->vc_len);
    }
  }
#line 374
  if ((unsigned long )luf->vc_cap != (unsigned long )((void *)0)) {
    {
#line 374
    _glp_lib_xfree((void *)luf->vc_cap);
    }
  }
#line 375
  if ((unsigned long )luf->pp_row != (unsigned long )((void *)0)) {
    {
#line 375
    _glp_lib_xfree((void *)luf->pp_row);
    }
  }
#line 376
  if ((unsigned long )luf->pp_col != (unsigned long )((void *)0)) {
    {
#line 376
    _glp_lib_xfree((void *)luf->pp_col);
    }
  }
#line 377
  if ((unsigned long )luf->qq_row != (unsigned long )((void *)0)) {
    {
#line 377
    _glp_lib_xfree((void *)luf->qq_row);
    }
  }
#line 378
  if ((unsigned long )luf->qq_col != (unsigned long )((void *)0)) {
    {
#line 378
    _glp_lib_xfree((void *)luf->qq_col);
    }
  }
#line 379
  if ((unsigned long )luf->sv_prev != (unsigned long )((void *)0)) {
    {
#line 379
    _glp_lib_xfree((void *)luf->sv_prev);
    }
  }
#line 380
  if ((unsigned long )luf->sv_next != (unsigned long )((void *)0)) {
    {
#line 380
    _glp_lib_xfree((void *)luf->sv_next);
    }
  }
#line 381
  if ((unsigned long )luf->vr_max != (unsigned long )((void *)0)) {
    {
#line 381
    _glp_lib_xfree((void *)luf->vr_max);
    }
  }
#line 382
  if ((unsigned long )luf->rs_head != (unsigned long )((void *)0)) {
    {
#line 382
    _glp_lib_xfree((void *)luf->rs_head);
    }
  }
#line 383
  if ((unsigned long )luf->rs_prev != (unsigned long )((void *)0)) {
    {
#line 383
    _glp_lib_xfree((void *)luf->rs_prev);
    }
  }
#line 384
  if ((unsigned long )luf->rs_next != (unsigned long )((void *)0)) {
    {
#line 384
    _glp_lib_xfree((void *)luf->rs_next);
    }
  }
#line 385
  if ((unsigned long )luf->cs_head != (unsigned long )((void *)0)) {
    {
#line 385
    _glp_lib_xfree((void *)luf->cs_head);
    }
  }
#line 386
  if ((unsigned long )luf->cs_prev != (unsigned long )((void *)0)) {
    {
#line 386
    _glp_lib_xfree((void *)luf->cs_prev);
    }
  }
#line 387
  if ((unsigned long )luf->cs_next != (unsigned long )((void *)0)) {
    {
#line 387
    _glp_lib_xfree((void *)luf->cs_next);
    }
  }
#line 388
  if ((unsigned long )luf->flag != (unsigned long )((void *)0)) {
    {
#line 388
    _glp_lib_xfree((void *)luf->flag);
    }
  }
#line 389
  if ((unsigned long )luf->work != (unsigned long )((void *)0)) {
    {
#line 389
    _glp_lib_xfree((void *)luf->work);
    }
  }
  {
#line 390
  n_max = n + 100;
#line 390
  luf->n_max = n_max;
#line 391
  tmp = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 391
  luf->fr_ptr = (int *)tmp;
#line 392
  tmp___0 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 392
  luf->fr_len = (int *)tmp___0;
#line 393
  tmp___1 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 393
  luf->fc_ptr = (int *)tmp___1;
#line 394
  tmp___2 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 394
  luf->fc_len = (int *)tmp___2;
#line 395
  tmp___3 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 395
  luf->vr_ptr = (int *)tmp___3;
#line 396
  tmp___4 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 396
  luf->vr_len = (int *)tmp___4;
#line 397
  tmp___5 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 397
  luf->vr_cap = (int *)tmp___5;
#line 398
  tmp___6 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(double ));
#line 398
  luf->vr_piv = (double *)tmp___6;
#line 399
  tmp___7 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 399
  luf->vc_ptr = (int *)tmp___7;
#line 400
  tmp___8 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 400
  luf->vc_len = (int *)tmp___8;
#line 401
  tmp___9 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 401
  luf->vc_cap = (int *)tmp___9;
#line 402
  tmp___10 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 402
  luf->pp_row = (int *)tmp___10;
#line 403
  tmp___11 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 403
  luf->pp_col = (int *)tmp___11;
#line 404
  tmp___12 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 404
  luf->qq_row = (int *)tmp___12;
#line 405
  tmp___13 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 405
  luf->qq_col = (int *)tmp___13;
#line 406
  tmp___14 = _glp_lib_xcalloc((1 + n_max) + n_max, (int )sizeof(int ));
#line 406
  luf->sv_prev = (int *)tmp___14;
#line 407
  tmp___15 = _glp_lib_xcalloc((1 + n_max) + n_max, (int )sizeof(int ));
#line 407
  luf->sv_next = (int *)tmp___15;
#line 408
  tmp___16 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(double ));
#line 408
  luf->vr_max = (double *)tmp___16;
#line 409
  tmp___17 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 409
  luf->rs_head = (int *)tmp___17;
#line 410
  tmp___18 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 410
  luf->rs_prev = (int *)tmp___18;
#line 411
  tmp___19 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 411
  luf->rs_next = (int *)tmp___19;
#line 412
  tmp___20 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 412
  luf->cs_head = (int *)tmp___20;
#line 413
  tmp___21 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 413
  luf->cs_prev = (int *)tmp___21;
#line 414
  tmp___22 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 414
  luf->cs_next = (int *)tmp___22;
#line 415
  tmp___23 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(int ));
#line 415
  luf->flag = (int *)tmp___23;
#line 416
  tmp___24 = _glp_lib_xcalloc(1 + n_max, (int )sizeof(double ));
#line 416
  luf->work = (double *)tmp___24;
  }
  done: 
#line 417
  return;
}
}
#line 432 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
static int initialize___0(LUF *luf , int (*col)(void *info , int j , int *rn , double *aj ) ,
                          void *info ) 
{ 
  int n ;
  int *fc_ptr ;
  int *fc_len ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *pp_row ;
  int *pp_col ;
  int *qq_row ;
  int *qq_col ;
  int *sv_ind ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  double *vr_max ;
  int *rs_head ;
  int *rs_prev ;
  int *rs_next ;
  int *cs_head ;
  int *cs_prev ;
  int *cs_next ;
  int *flag ;
  double *work ;
  int ret ;
  int i ;
  int i_ptr ;
  int j ;
  int j_beg ;
  int j_end ;
  int k ;
  int len ;
  int nnz ;
  int sv_beg ;
  int sv_end ;
  int ptr ;
  double big ;
  double val ;
  int tmp ;
  int *rn ;
  double *aj ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
#line 434
  n = luf->n;
#line 435
  fc_ptr = luf->fc_ptr;
#line 436
  fc_len = luf->fc_len;
#line 437
  vr_ptr = luf->vr_ptr;
#line 438
  vr_len = luf->vr_len;
#line 439
  vr_cap = luf->vr_cap;
#line 440
  vc_ptr = luf->vc_ptr;
#line 441
  vc_len = luf->vc_len;
#line 442
  vc_cap = luf->vc_cap;
#line 443
  pp_row = luf->pp_row;
#line 444
  pp_col = luf->pp_col;
#line 445
  qq_row = luf->qq_row;
#line 446
  qq_col = luf->qq_col;
#line 447
  sv_ind = luf->sv_ind;
#line 448
  sv_val = luf->sv_val;
#line 449
  sv_prev = luf->sv_prev;
#line 450
  sv_next = luf->sv_next;
#line 451
  vr_max = luf->vr_max;
#line 452
  rs_head = luf->rs_head;
#line 453
  rs_prev = luf->rs_prev;
#line 454
  rs_next = luf->rs_next;
#line 455
  cs_head = luf->cs_head;
#line 456
  cs_prev = luf->cs_prev;
#line 457
  cs_next = luf->cs_next;
#line 458
  flag = luf->flag;
#line 459
  work = luf->work;
#line 460
  ret = 0;
#line 464
  sv_beg = 1;
#line 465
  sv_end = luf->sv_size + 1;
#line 469
  j = 1;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! (j <= n)) {
#line 469
      goto while_break;
    }
#line 470
    *(fc_ptr + j) = sv_end;
#line 471
    *(fc_len + j) = 0;
#line 469
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  i = 1;
  {
#line 474
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 474
    if (! (i <= n)) {
#line 474
      goto while_break___0;
    }
#line 475
    tmp = 0;
#line 475
    *(vr_cap + i) = tmp;
#line 475
    *(vr_len + i) = tmp;
#line 475
    *(flag + i) = 0;
#line 474
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 479
  nnz = 0;
#line 480
  big = 0.0;
#line 481
  j = 1;
  {
#line 481
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 481
    if (! (j <= n)) {
#line 481
      goto while_break___1;
    }
    {
#line 482
    rn = pp_row;
#line 483
    aj = work;
#line 485
    len = (*col)(info, j, rn, aj);
    }
#line 486
    if (0 <= len) {
#line 486
      if (! (len <= n)) {
        {
#line 487
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                                   487);
#line 487
        (*tmp___0)("luf_factorize: j = %d; len = %d; invalid column length\n", j,
                   len);
        }
      }
    } else {
      {
#line 487
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                                 487);
#line 487
      (*tmp___0)("luf_factorize: j = %d; len = %d; invalid column length\n", j, len);
      }
    }
#line 490
    if (sv_end - sv_beg < len) {
#line 492
      ret = 1;
#line 493
      goto done;
    }
#line 496
    *(vc_ptr + j) = sv_beg;
#line 498
    tmp___1 = len;
#line 498
    *(vc_cap + j) = tmp___1;
#line 498
    *(vc_len + j) = tmp___1;
#line 500
    nnz += len;
#line 502
    ptr = 1;
    {
#line 502
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 502
      if (! (ptr <= len)) {
#line 502
        goto while_break___2;
      }
#line 504
      i = *(rn + ptr);
#line 505
      val = *(aj + ptr);
#line 506
      if (1 <= i) {
#line 506
        if (! (i <= n)) {
          {
#line 507
          tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                                     507);
#line 507
          (*tmp___2)("luf_factorize: i = %d; j = %d; invalid row index\n", i, j);
          }
        }
      } else {
        {
#line 507
        tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                                   507);
#line 507
        (*tmp___2)("luf_factorize: i = %d; j = %d; invalid row index\n", i, j);
        }
      }
#line 509
      if (*(flag + i)) {
        {
#line 510
        tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                                   510);
#line 510
        (*tmp___3)("luf_factorize: i = %d; j = %d; duplicate element not allowed\n",
                   i, j);
        }
      }
#line 512
      if (val == 0.0) {
        {
#line 513
        tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                                   513);
#line 513
        (*tmp___4)("luf_factorize: i = %d; j = %d; zero element not allowed\n", i,
                   j);
        }
      }
#line 516
      *(sv_ind + sv_beg) = i;
#line 517
      *(sv_val + sv_beg) = val;
#line 518
      sv_beg ++;
#line 520
      if (val < 0.0) {
#line 520
        val = - val;
      }
#line 521
      if (big < val) {
#line 521
        big = val;
      }
#line 523
      *(flag + i) = 1;
#line 525
      (*(vr_cap + i)) ++;
#line 502
      ptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 528
    ptr = 1;
    {
#line 528
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 528
      if (! (ptr <= len)) {
#line 528
        goto while_break___3;
      }
#line 528
      *(flag + *(rn + ptr)) = 0;
#line 528
      ptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 481
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 531
  i = 1;
  {
#line 531
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 531
    if (! (i <= n)) {
#line 531
      goto while_break___4;
    }
#line 533
    len = *(vr_cap + i);
#line 535
    if (sv_end - sv_beg < len) {
#line 537
      ret = 1;
#line 538
      goto done;
    }
#line 541
    *(vr_ptr + i) = sv_beg;
#line 543
    sv_beg += len;
#line 531
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 547
  j = 1;
  {
#line 547
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 547
    if (! (j <= n)) {
#line 547
      goto while_break___5;
    }
#line 549
    j_beg = *(vc_ptr + j);
#line 550
    j_end = (j_beg + *(vc_len + j)) - 1;
#line 551
    k = j_beg;
    {
#line 551
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 551
      if (! (k <= j_end)) {
#line 551
        goto while_break___6;
      }
#line 553
      i = *(sv_ind + k);
#line 554
      val = *(sv_val + k);
#line 556
      i_ptr = *(vr_ptr + i) + *(vr_len + i);
#line 557
      *(sv_ind + i_ptr) = j;
#line 558
      *(sv_val + i_ptr) = val;
#line 560
      (*(vr_len + i)) ++;
#line 551
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 547
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 564
  k = 1;
  {
#line 564
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 564
    if (! (k <= n)) {
#line 564
      goto while_break___7;
    }
#line 565
    tmp___7 = k;
#line 565
    *(qq_col + k) = tmp___7;
#line 565
    tmp___6 = tmp___7;
#line 565
    *(qq_row + k) = tmp___6;
#line 565
    tmp___5 = tmp___6;
#line 565
    *(pp_col + k) = tmp___5;
#line 565
    *(pp_row + k) = tmp___5;
#line 564
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 567
  luf->sv_beg = sv_beg;
#line 568
  luf->sv_end = sv_end;
#line 571
  luf->sv_head = n + 1;
#line 572
  luf->sv_tail = n;
#line 573
  i = 1;
  {
#line 573
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 573
    if (! (i <= n)) {
#line 573
      goto while_break___8;
    }
#line 574
    *(sv_prev + i) = i - 1;
#line 575
    *(sv_next + i) = i + 1;
#line 573
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 577
  *(sv_prev + 1) = n + n;
#line 578
  *(sv_next + n) = 0;
#line 579
  j = 1;
  {
#line 579
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 579
    if (! (j <= n)) {
#line 579
      goto while_break___9;
    }
#line 580
    *(sv_prev + (n + j)) = (n + j) - 1;
#line 581
    *(sv_next + (n + j)) = (n + j) + 1;
#line 579
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 583
  *(sv_prev + (n + 1)) = 0;
#line 584
  *(sv_next + (n + n)) = 1;
#line 586
  k = 1;
  {
#line 586
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 586
    if (! (k <= n)) {
#line 586
      goto while_break___10;
    }
#line 587
    *(flag + k) = 0;
#line 588
    *(work + k) = 0.0;
#line 586
    k ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 591
  luf->nnz_a = nnz;
#line 592
  luf->nnz_f = 0;
#line 593
  luf->nnz_v = nnz;
#line 594
  luf->max_a = big;
#line 595
  luf->big_v = big;
#line 596
  luf->rank = -1;
#line 600
  i = 1;
  {
#line 600
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 600
    if (! (i <= n)) {
#line 600
      goto while_break___11;
    }
#line 600
    *(vr_max + i) = - 1.0;
#line 600
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 602
  len = 0;
  {
#line 602
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 602
    if (! (len <= n)) {
#line 602
      goto while_break___12;
    }
#line 602
    *(rs_head + len) = 0;
#line 602
    len ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 603
  i = 1;
  {
#line 603
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 603
    if (! (i <= n)) {
#line 603
      goto while_break___13;
    }
#line 604
    len = *(vr_len + i);
#line 605
    *(rs_prev + i) = 0;
#line 606
    *(rs_next + i) = *(rs_head + len);
#line 607
    if (*(rs_next + i) != 0) {
#line 607
      *(rs_prev + *(rs_next + i)) = i;
    }
#line 608
    *(rs_head + len) = i;
#line 603
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 611
  len = 0;
  {
#line 611
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 611
    if (! (len <= n)) {
#line 611
      goto while_break___14;
    }
#line 611
    *(cs_head + len) = 0;
#line 611
    len ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 612
  j = 1;
  {
#line 612
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 612
    if (! (j <= n)) {
#line 612
      goto while_break___15;
    }
#line 613
    len = *(vc_len + j);
#line 614
    *(cs_prev + j) = 0;
#line 615
    *(cs_next + j) = *(cs_head + len);
#line 616
    if (*(cs_next + j) != 0) {
#line 616
      *(cs_prev + *(cs_next + j)) = j;
    }
#line 617
    *(cs_head + len) = j;
#line 612
    j ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  done: 
#line 620
  return (ret);
}
}
#line 683 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
static int find_pivot___0(LUF *luf , int *_p , int *_q ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vc_ptr ;
  int *vc_len ;
  int *sv_ind ;
  double *sv_val ;
  double *vr_max ;
  int *rs_head ;
  int *rs_next ;
  int *cs_head ;
  int *cs_prev ;
  int *cs_next ;
  double piv_tol ;
  int piv_lim ;
  int suhl ;
  int p ;
  int q ;
  int len ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int ncand ;
  int next_j ;
  int min_p ;
  int min_q ;
  int min_len ;
  double best ;
  double cost ;
  double big ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
#line 684
  n = luf->n;
#line 685
  vr_ptr = luf->vr_ptr;
#line 686
  vr_len = luf->vr_len;
#line 687
  vc_ptr = luf->vc_ptr;
#line 688
  vc_len = luf->vc_len;
#line 689
  sv_ind = luf->sv_ind;
#line 690
  sv_val = luf->sv_val;
#line 691
  vr_max = luf->vr_max;
#line 692
  rs_head = luf->rs_head;
#line 693
  rs_next = luf->rs_next;
#line 694
  cs_head = luf->cs_head;
#line 695
  cs_prev = luf->cs_prev;
#line 696
  cs_next = luf->cs_next;
#line 697
  piv_tol = luf->piv_tol;
#line 698
  piv_lim = luf->piv_lim;
#line 699
  suhl = luf->suhl;
#line 704
  q = 0;
#line 704
  p = q;
#line 704
  best = 1.7976931348623157e+308;
#line 704
  ncand = 0;
#line 707
  j = *(cs_head + 1);
#line 708
  if (j != 0) {
#line 709
    if (*(vc_len + j) == 1) {
#line 709
      tmp = 1;
    } else {
      {
#line 709
      _glp_lib_xassert("vc_len[j] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       709);
#line 709
      tmp = 1;
      }
    }
#line 710
    p = *(sv_ind + *(vc_ptr + j));
#line 710
    q = j;
#line 711
    goto done;
  }
#line 715
  i = *(rs_head + 1);
#line 716
  if (i != 0) {
#line 717
    if (*(vr_len + i) == 1) {
#line 717
      tmp___0 = 1;
    } else {
      {
#line 717
      _glp_lib_xassert("vr_len[i] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       717);
#line 717
      tmp___0 = 1;
      }
    }
#line 718
    p = i;
#line 718
    q = *(sv_ind + *(vr_ptr + i));
#line 719
    goto done;
  }
#line 723
  len = 2;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! (len <= n)) {
#line 723
      goto while_break;
    }
#line 725
    j = *(cs_head + len);
    {
#line 725
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 725
      if (! (j != 0)) {
#line 725
        goto while_break___0;
      }
#line 727
      j_beg = *(vc_ptr + j);
#line 728
      j_end = (j_beg + *(vc_len + j)) - 1;
#line 730
      next_j = *(cs_next + j);
#line 734
      min_q = 0;
#line 734
      min_p = min_q;
#line 734
      min_len = 2147483647;
#line 735
      j_ptr = j_beg;
      {
#line 735
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 735
        if (! (j_ptr <= j_end)) {
#line 735
          goto while_break___1;
        }
#line 737
        i = *(sv_ind + j_ptr);
#line 738
        i_beg = *(vr_ptr + i);
#line 739
        i_end = (i_beg + *(vr_len + i)) - 1;
#line 742
        if (*(vr_len + i) >= min_len) {
#line 742
          goto __Cont;
        }
#line 745
        big = *(vr_max + i);
#line 746
        if (big < 0.0) {
#line 748
          i_ptr = i_beg;
          {
#line 748
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 748
            if (! (i_ptr <= i_end)) {
#line 748
              goto while_break___2;
            }
#line 749
            temp = *(sv_val + i_ptr);
#line 750
            if (temp < 0.0) {
#line 750
              temp = - temp;
            }
#line 751
            if (big < temp) {
#line 751
              big = temp;
            }
#line 748
            i_ptr ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 753
          *(vr_max + i) = big;
        }
#line 756
        i_ptr = *(vr_ptr + i);
        {
#line 756
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 756
          if (! (*(sv_ind + i_ptr) != j)) {
#line 756
            goto while_break___3;
          }
#line 756
          i_ptr ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 757
        if (i_ptr <= i_end) {
#line 757
          tmp___1 = 1;
        } else {
          {
#line 757
          _glp_lib_xassert("i_ptr <= i_end", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                           757);
#line 757
          tmp___1 = 1;
          }
        }
#line 760
        temp = *(sv_val + i_ptr);
#line 761
        if (temp < 0.0) {
#line 761
          temp = - temp;
        }
#line 762
        if (temp < piv_tol * big) {
#line 762
          goto __Cont;
        }
#line 764
        min_p = i;
#line 764
        min_q = j;
#line 764
        min_len = *(vr_len + i);
#line 769
        if (min_len <= len) {
#line 770
          p = min_p;
#line 770
          q = min_q;
#line 771
          goto done;
        }
        __Cont: /* CIL Label */ 
#line 735
        j_ptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 775
      if (min_p != 0) {
#line 777
        ncand ++;
#line 779
        cost = (double )(min_len - 1) * (double )(len - 1);
#line 782
        if (cost < best) {
#line 782
          p = min_p;
#line 782
          q = min_q;
#line 782
          best = cost;
        }
#line 786
        if (ncand == piv_lim) {
#line 786
          goto done;
        }
      } else
#line 794
      if (suhl) {
#line 796
        if (*(cs_prev + j) == 0) {
#line 797
          *(cs_head + len) = *(cs_next + j);
        } else {
#line 799
          *(cs_next + *(cs_prev + j)) = *(cs_next + j);
        }
#line 800
        if (! (*(cs_next + j) == 0)) {
#line 803
          *(cs_prev + *(cs_next + j)) = *(cs_prev + j);
        }
#line 807
        tmp___2 = j;
#line 807
        *(cs_next + j) = tmp___2;
#line 807
        *(cs_prev + j) = tmp___2;
      }
#line 725
      j = next_j;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 812
    i = *(rs_head + len);
    {
#line 812
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 812
      if (! (i != 0)) {
#line 812
        goto while_break___4;
      }
#line 814
      i_beg = *(vr_ptr + i);
#line 815
      i_end = (i_beg + *(vr_len + i)) - 1;
#line 818
      big = *(vr_max + i);
#line 819
      if (big < 0.0) {
#line 821
        i_ptr = i_beg;
        {
#line 821
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 821
          if (! (i_ptr <= i_end)) {
#line 821
            goto while_break___5;
          }
#line 822
          temp = *(sv_val + i_ptr);
#line 823
          if (temp < 0.0) {
#line 823
            temp = - temp;
          }
#line 824
          if (big < temp) {
#line 824
            big = temp;
          }
#line 821
          i_ptr ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 826
        *(vr_max + i) = big;
      }
#line 831
      min_q = 0;
#line 831
      min_p = min_q;
#line 831
      min_len = 2147483647;
#line 832
      i_ptr = i_beg;
      {
#line 832
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 832
        if (! (i_ptr <= i_end)) {
#line 832
          goto while_break___6;
        }
#line 834
        j = *(sv_ind + i_ptr);
#line 837
        if (*(vc_len + j) >= min_len) {
#line 837
          goto __Cont___0;
        }
#line 840
        temp = *(sv_val + i_ptr);
#line 841
        if (temp < 0.0) {
#line 841
          temp = - temp;
        }
#line 842
        if (temp < piv_tol * big) {
#line 842
          goto __Cont___0;
        }
#line 844
        min_p = i;
#line 844
        min_q = j;
#line 844
        min_len = *(vc_len + j);
#line 849
        if (min_len <= len) {
#line 850
          p = min_p;
#line 850
          q = min_q;
#line 851
          goto done;
        }
        __Cont___0: /* CIL Label */ 
#line 832
        i_ptr ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 855
      if (min_p != 0) {
#line 857
        ncand ++;
#line 859
        cost = (double )(len - 1) * (double )(min_len - 1);
#line 862
        if (cost < best) {
#line 862
          p = min_p;
#line 862
          q = min_q;
#line 862
          best = cost;
        }
#line 866
        if (ncand == piv_lim) {
#line 866
          goto done;
        }
      } else
#line 870
      if (min_p != min_p) {
#line 870
        tmp___3 = 1;
      } else {
        {
#line 870
        _glp_lib_xassert("min_p != min_p", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                         870);
#line 870
        tmp___3 = 1;
        }
      }
#line 812
      i = *(rs_next + i);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 723
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 875
  *_p = p;
#line 875
  *_q = q;
#line 876
  return (p == 0);
}
}
#line 941 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
static int eliminate___0(LUF *luf , int p , int q ) 
{ 
  int n ;
  int *fc_ptr ;
  int *fc_len ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  double *vr_piv ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ind ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  double *vr_max ;
  int *rs_head ;
  int *rs_prev ;
  int *rs_next ;
  int *cs_head ;
  int *cs_prev ;
  int *cs_next ;
  int *flag ;
  double *work ;
  double eps_tol ;
  int *ndx ;
  int ret ;
  int len ;
  int fill ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int k ;
  int p_beg ;
  int p_end ;
  int p_ptr ;
  int q_beg ;
  int q_end ;
  int q_ptr ;
  double fip ;
  double val ;
  double vpq ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 942
  n = luf->n;
#line 943
  fc_ptr = luf->fc_ptr;
#line 944
  fc_len = luf->fc_len;
#line 945
  vr_ptr = luf->vr_ptr;
#line 946
  vr_len = luf->vr_len;
#line 947
  vr_cap = luf->vr_cap;
#line 948
  vr_piv = luf->vr_piv;
#line 949
  vc_ptr = luf->vc_ptr;
#line 950
  vc_len = luf->vc_len;
#line 951
  vc_cap = luf->vc_cap;
#line 952
  sv_ind = luf->sv_ind;
#line 953
  sv_val = luf->sv_val;
#line 954
  sv_prev = luf->sv_prev;
#line 955
  sv_next = luf->sv_next;
#line 956
  vr_max = luf->vr_max;
#line 957
  rs_head = luf->rs_head;
#line 958
  rs_prev = luf->rs_prev;
#line 959
  rs_next = luf->rs_next;
#line 960
  cs_head = luf->cs_head;
#line 961
  cs_prev = luf->cs_prev;
#line 962
  cs_next = luf->cs_next;
#line 963
  flag = luf->flag;
#line 964
  work = luf->work;
#line 965
  eps_tol = luf->eps_tol;
#line 968
  ndx = luf->fr_len;
#line 969
  ret = 0;
#line 973
  if (1 <= p) {
#line 973
    if (p <= n) {
#line 973
      tmp = 1;
    } else {
      {
#line 973
      _glp_lib_xassert("1 <= p && p <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       973);
#line 973
      tmp = 1;
      }
    }
  } else {
    {
#line 973
    _glp_lib_xassert("1 <= p && p <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     973);
#line 973
    tmp = 1;
    }
  }
#line 974
  if (1 <= q) {
#line 974
    if (q <= n) {
#line 974
      tmp___0 = 1;
    } else {
      {
#line 974
      _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       974);
#line 974
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 974
    _glp_lib_xassert("1 <= q && q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     974);
#line 974
    tmp___0 = 1;
    }
  }
#line 977
  if (*(rs_prev + p) == 0) {
#line 978
    *(rs_head + *(vr_len + p)) = *(rs_next + p);
  } else {
#line 980
    *(rs_next + *(rs_prev + p)) = *(rs_next + p);
  }
#line 981
  if (! (*(rs_next + p) == 0)) {
#line 984
    *(rs_prev + *(rs_next + p)) = *(rs_prev + p);
  }
#line 987
  if (*(cs_prev + q) == 0) {
#line 988
    *(cs_head + *(vc_len + q)) = *(cs_next + q);
  } else {
#line 990
    *(cs_next + *(cs_prev + q)) = *(cs_next + q);
  }
#line 991
  if (! (*(cs_next + q) == 0)) {
#line 994
    *(cs_prev + *(cs_next + q)) = *(cs_prev + q);
  }
#line 996
  p_beg = *(vr_ptr + p);
#line 997
  p_end = (p_beg + *(vr_len + p)) - 1;
#line 998
  p_ptr = p_beg;
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 998
    if (! (*(sv_ind + p_ptr) != q)) {
#line 998
      goto while_break;
    }
#line 998
    p_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  if (p_ptr <= p_end) {
#line 999
    tmp___1 = 1;
  } else {
    {
#line 999
    _glp_lib_xassert("p_ptr <= p_end", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     999);
#line 999
    tmp___1 = 1;
    }
  }
#line 1001
  tmp___2 = *(sv_val + p_ptr);
#line 1001
  *(vr_piv + p) = tmp___2;
#line 1001
  vpq = tmp___2;
#line 1003
  *(sv_ind + p_ptr) = *(sv_ind + p_end);
#line 1004
  *(sv_val + p_ptr) = *(sv_val + p_end);
#line 1005
  (*(vr_len + p)) --;
#line 1006
  p_end --;
#line 1008
  q_beg = *(vc_ptr + q);
#line 1009
  q_end = (q_beg + *(vc_len + q)) - 1;
#line 1010
  q_ptr = q_beg;
  {
#line 1010
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1010
    if (! (*(sv_ind + q_ptr) != p)) {
#line 1010
      goto while_break___0;
    }
#line 1010
    q_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1011
  if (q_ptr <= q_end) {
#line 1011
    tmp___3 = 1;
  } else {
    {
#line 1011
    _glp_lib_xassert("q_ptr <= q_end", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     1011);
#line 1011
    tmp___3 = 1;
    }
  }
#line 1013
  *(sv_ind + q_ptr) = *(sv_ind + q_end);
#line 1014
  (*(vc_len + q)) --;
#line 1015
  q_end --;
#line 1018
  p_ptr = p_beg;
  {
#line 1018
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1018
    if (! (p_ptr <= p_end)) {
#line 1018
      goto while_break___1;
    }
#line 1020
    j = *(sv_ind + p_ptr);
#line 1022
    *(flag + j) = 1;
#line 1023
    *(work + j) = *(sv_val + p_ptr);
#line 1026
    if (*(cs_prev + j) == 0) {
#line 1027
      *(cs_head + *(vc_len + j)) = *(cs_next + j);
    } else {
#line 1029
      *(cs_next + *(cs_prev + j)) = *(cs_next + j);
    }
#line 1030
    if (! (*(cs_next + j) == 0)) {
#line 1033
      *(cs_prev + *(cs_next + j)) = *(cs_prev + j);
    }
#line 1035
    j_beg = *(vc_ptr + j);
#line 1036
    j_end = (j_beg + *(vc_len + j)) - 1;
#line 1037
    j_ptr = j_beg;
    {
#line 1037
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1037
      if (! (*(sv_ind + j_ptr) != p)) {
#line 1037
        goto while_break___2;
      }
#line 1037
      j_ptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1038
    if (j_ptr <= j_end) {
#line 1038
      tmp___4 = 1;
    } else {
      {
#line 1038
      _glp_lib_xassert("j_ptr <= j_end", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       1038);
#line 1038
      tmp___4 = 1;
      }
    }
#line 1041
    *(sv_ind + j_ptr) = *(sv_ind + j_end);
#line 1042
    (*(vc_len + j)) --;
#line 1018
    p_ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1046
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1046
    if (! (q_beg <= q_end)) {
#line 1046
      goto while_break___3;
    }
#line 1049
    i = *(sv_ind + q_beg);
#line 1052
    if (*(rs_prev + i) == 0) {
#line 1053
      *(rs_head + *(vr_len + i)) = *(rs_next + i);
    } else {
#line 1055
      *(rs_next + *(rs_prev + i)) = *(rs_next + i);
    }
#line 1056
    if (! (*(rs_next + i) == 0)) {
#line 1059
      *(rs_prev + *(rs_next + i)) = *(rs_prev + i);
    }
#line 1061
    i_beg = *(vr_ptr + i);
#line 1062
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 1063
    i_ptr = i_beg;
    {
#line 1063
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1063
      if (! (*(sv_ind + i_ptr) != q)) {
#line 1063
        goto while_break___4;
      }
#line 1063
      i_ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1064
    if (i_ptr <= i_end) {
#line 1064
      tmp___5 = 1;
    } else {
      {
#line 1064
      _glp_lib_xassert("i_ptr <= i_end", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       1064);
#line 1064
      tmp___5 = 1;
      }
    }
#line 1066
    fip = *(sv_val + i_ptr) / vpq;
#line 1069
    *(sv_ind + i_ptr) = *(sv_ind + i_end);
#line 1070
    *(sv_val + i_ptr) = *(sv_val + i_end);
#line 1071
    (*(vr_len + i)) --;
#line 1072
    i_end --;
#line 1074
    *(sv_ind + q_beg) = *(sv_ind + q_end);
#line 1075
    (*(vc_len + q)) --;
#line 1076
    q_end --;
#line 1084
    fill = *(vr_len + p);
#line 1085
    i_ptr = i_beg;
    {
#line 1085
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1085
      if (! (i_ptr <= i_end)) {
#line 1085
        goto while_break___5;
      }
#line 1087
      j = *(sv_ind + i_ptr);
#line 1089
      if (*(flag + j)) {
#line 1091
        tmp___6 = *(sv_val + i_ptr) - fip * *(work + j);
#line 1091
        *(sv_val + i_ptr) = tmp___6;
#line 1091
        temp = tmp___6;
#line 1092
        if (temp < 0.0) {
#line 1092
          temp = - temp;
        }
#line 1093
        *(flag + j) = 0;
#line 1094
        fill --;
#line 1095
        if (temp == 0.0) {
#line 1095
          goto _L;
        } else
#line 1095
        if (temp < eps_tol) {
          _L: /* CIL Label */ 
#line 1099
          *(sv_ind + i_ptr) = *(sv_ind + i_end);
#line 1100
          *(sv_val + i_ptr) = *(sv_val + i_end);
#line 1101
          (*(vr_len + i)) --;
#line 1102
          i_ptr --;
#line 1103
          i_end --;
#line 1105
          j_beg = *(vc_ptr + j);
#line 1106
          j_end = (j_beg + *(vc_len + j)) - 1;
#line 1107
          j_ptr = j_beg;
          {
#line 1107
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1107
            if (! (*(sv_ind + j_ptr) != i)) {
#line 1107
              goto while_break___6;
            }
#line 1107
            j_ptr ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1108
          if (j_ptr <= j_end) {
#line 1108
            tmp___7 = 1;
          } else {
            {
#line 1108
            _glp_lib_xassert("j_ptr <= j_end", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                             1108);
#line 1108
            tmp___7 = 1;
            }
          }
#line 1110
          *(sv_ind + j_ptr) = *(sv_ind + j_end);
#line 1111
          (*(vc_len + j)) --;
        } else
#line 1115
        if (luf->big_v < temp) {
#line 1115
          luf->big_v = temp;
        }
      }
#line 1085
      i_ptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1122
    if (*(vr_len + i) + fill > *(vr_cap + i)) {
      {
#line 1124
      tmp___8 = _glp_luf_enlarge_row(luf, i, *(vr_len + i) + fill);
      }
#line 1124
      if (tmp___8) {
#line 1126
        ret = 1;
#line 1127
        goto done;
      }
#line 1131
      p_beg = *(vr_ptr + p);
#line 1132
      p_end = (p_beg + *(vr_len + p)) - 1;
#line 1133
      q_beg = *(vc_ptr + q);
#line 1134
      q_end = (q_beg + *(vc_len + q)) - 1;
    }
#line 1139
    len = 0;
#line 1140
    p_ptr = p_beg;
    {
#line 1140
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1140
      if (! (p_ptr <= p_end)) {
#line 1140
        goto while_break___7;
      }
#line 1142
      j = *(sv_ind + p_ptr);
#line 1143
      if (*(flag + j)) {
#line 1145
        val = - fip * *(work + j);
#line 1145
        temp = val;
#line 1146
        if (temp < 0.0) {
#line 1146
          temp = - temp;
        }
#line 1147
        if (! (temp == 0.0)) {
#line 1147
          if (! (temp < eps_tol)) {
#line 1151
            i_ptr = *(vr_ptr + i) + *(vr_len + i);
#line 1152
            *(sv_ind + i_ptr) = j;
#line 1153
            *(sv_val + i_ptr) = val;
#line 1154
            (*(vr_len + i)) ++;
#line 1156
            len ++;
#line 1156
            *(ndx + len) = j;
#line 1158
            if (luf->big_v < temp) {
#line 1158
              luf->big_v = temp;
            }
          }
        }
      } else {
#line 1165
        *(flag + j) = 1;
      }
#line 1140
      p_ptr ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1169
    k = 1;
    {
#line 1169
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1169
      if (! (k <= len)) {
#line 1169
        goto while_break___8;
      }
#line 1171
      j = *(ndx + k);
#line 1173
      if (*(vc_len + j) + 1 > *(vc_cap + j)) {
        {
#line 1175
        tmp___9 = _glp_luf_enlarge_col(luf, j, *(vc_len + j) + 10);
        }
#line 1175
        if (tmp___9) {
#line 1177
          ret = 1;
#line 1178
          goto done;
        }
#line 1182
        p_beg = *(vr_ptr + p);
#line 1183
        p_end = (p_beg + *(vr_len + p)) - 1;
#line 1184
        q_beg = *(vc_ptr + q);
#line 1185
        q_end = (q_beg + *(vc_len + q)) - 1;
      }
#line 1188
      j_ptr = *(vc_ptr + j) + *(vc_len + j);
#line 1189
      *(sv_ind + j_ptr) = i;
#line 1190
      (*(vc_len + j)) ++;
#line 1169
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1194
    *(rs_prev + i) = 0;
#line 1195
    *(rs_next + i) = *(rs_head + *(vr_len + i));
#line 1196
    if (*(rs_next + i) != 0) {
#line 1196
      *(rs_prev + *(rs_next + i)) = i;
    }
#line 1197
    *(rs_head + *(vr_len + i)) = i;
#line 1200
    *(vr_max + i) = - 1.0;
#line 1203
    if (luf->sv_end - luf->sv_beg < 1) {
      {
#line 1205
      _glp_luf_defrag_sva(luf);
      }
#line 1206
      if (luf->sv_end - luf->sv_beg < 1) {
#line 1208
        ret = 1;
#line 1209
        goto done;
      }
#line 1213
      p_beg = *(vr_ptr + p);
#line 1214
      p_end = (p_beg + *(vr_len + p)) - 1;
#line 1215
      q_beg = *(vc_ptr + q);
#line 1216
      q_end = (q_beg + *(vc_len + q)) - 1;
    }
#line 1220
    (luf->sv_end) --;
#line 1221
    *(sv_ind + luf->sv_end) = i;
#line 1222
    *(sv_val + luf->sv_end) = fip;
#line 1223
    (*(fc_len + p)) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1227
  if (*(vc_len + q) == 0) {
#line 1227
    tmp___10 = 1;
  } else {
    {
#line 1227
    _glp_lib_xassert("vc_len[q] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                     1227);
#line 1227
    tmp___10 = 1;
    }
  }
#line 1229
  *(vc_cap + q) = 0;
#line 1231
  k = n + q;
#line 1232
  if (*(sv_prev + k) == 0) {
#line 1233
    luf->sv_head = *(sv_next + k);
  } else {
#line 1235
    *(sv_next + *(sv_prev + k)) = *(sv_next + k);
  }
#line 1236
  if (*(sv_next + k) == 0) {
#line 1237
    luf->sv_tail = *(sv_prev + k);
  } else {
#line 1239
    *(sv_prev + *(sv_next + k)) = *(sv_prev + k);
  }
#line 1242
  *(fc_ptr + p) = luf->sv_end;
#line 1244
  p_ptr = p_beg;
  {
#line 1244
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1244
    if (! (p_ptr <= p_end)) {
#line 1244
      goto while_break___9;
    }
#line 1246
    j = *(sv_ind + p_ptr);
#line 1248
    *(flag + j) = 0;
#line 1249
    *(work + j) = 0.0;
#line 1257
    if (*(vc_len + j) != 1) {
#line 1257
      if (*(cs_prev + j) == j) {
#line 1257
        if (! (*(cs_next + j) == j)) {
#line 1257
          goto _L___1;
        }
      } else {
#line 1257
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1258
      *(cs_prev + j) = 0;
#line 1259
      *(cs_next + j) = *(cs_head + *(vc_len + j));
#line 1260
      if (*(cs_next + j) != 0) {
#line 1260
        *(cs_prev + *(cs_next + j)) = j;
      }
#line 1261
      *(cs_head + *(vc_len + j)) = j;
    }
#line 1244
    p_ptr ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  done: 
#line 1265
  return (ret);
}
}
#line 1277 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
static int build_v_cols(LUF *luf ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ind ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int ret ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j ;
  int j_ptr ;
  int k ;
  int nnz ;

  {
#line 1278
  n = luf->n;
#line 1279
  vr_ptr = luf->vr_ptr;
#line 1280
  vr_len = luf->vr_len;
#line 1281
  vc_ptr = luf->vc_ptr;
#line 1282
  vc_len = luf->vc_len;
#line 1283
  vc_cap = luf->vc_cap;
#line 1284
  sv_ind = luf->sv_ind;
#line 1285
  sv_val = luf->sv_val;
#line 1286
  sv_prev = luf->sv_prev;
#line 1287
  sv_next = luf->sv_next;
#line 1288
  ret = 0;
#line 1295
  nnz = 0;
#line 1296
  i = 1;
  {
#line 1296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1296
    if (! (i <= n)) {
#line 1296
      goto while_break;
    }
#line 1299
    i_beg = *(vr_ptr + i);
#line 1300
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 1301
    i_ptr = i_beg;
    {
#line 1301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1301
      if (! (i_ptr <= i_end)) {
#line 1301
        goto while_break___0;
      }
#line 1302
      (*(vc_cap + *(sv_ind + i_ptr))) ++;
#line 1301
      i_ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1304
    nnz += *(vr_len + i);
#line 1296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1307
  luf->nnz_v = nnz;
#line 1309
  if (luf->sv_end - luf->sv_beg < nnz) {
#line 1311
    ret = 1;
#line 1312
    goto done;
  }
#line 1315
  j = 1;
  {
#line 1315
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1315
    if (! (j <= n)) {
#line 1315
      goto while_break___1;
    }
#line 1317
    *(vc_ptr + j) = luf->sv_beg;
#line 1319
    luf->sv_beg += *(vc_cap + j);
#line 1315
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1323
  i = 1;
  {
#line 1323
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1323
    if (! (i <= n)) {
#line 1323
      goto while_break___2;
    }
#line 1325
    i_beg = *(vr_ptr + i);
#line 1326
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 1327
    i_ptr = i_beg;
    {
#line 1327
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1327
      if (! (i_ptr <= i_end)) {
#line 1327
        goto while_break___3;
      }
#line 1329
      j = *(sv_ind + i_ptr);
#line 1331
      j_ptr = *(vc_ptr + j) + *(vc_len + j);
#line 1332
      *(sv_ind + j_ptr) = i;
#line 1333
      *(sv_val + j_ptr) = *(sv_val + i_ptr);
#line 1335
      (*(vc_len + j)) ++;
#line 1327
      i_ptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1323
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1341
  k = n + 1;
  {
#line 1341
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1341
    if (! (k <= n + n)) {
#line 1341
      goto while_break___4;
    }
#line 1342
    *(sv_prev + k) = k - 1;
#line 1343
    *(sv_next + k) = k + 1;
#line 1341
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1345
  *(sv_prev + (n + 1)) = luf->sv_tail;
#line 1346
  *(sv_next + luf->sv_tail) = n + 1;
#line 1347
  *(sv_next + (n + n)) = 0;
#line 1348
  luf->sv_tail = n + n;
  done: 
#line 1350
  return (ret);
}
}
#line 1362 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
static int build_f_rows(LUF *luf ) 
{ 
  int n ;
  int *fr_ptr ;
  int *fr_len ;
  int *fc_ptr ;
  int *fc_len ;
  int *sv_ind ;
  double *sv_val ;
  int ret ;
  int i ;
  int j ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int ptr ;
  int nnz ;

  {
#line 1363
  n = luf->n;
#line 1364
  fr_ptr = luf->fr_ptr;
#line 1365
  fr_len = luf->fr_len;
#line 1366
  fc_ptr = luf->fc_ptr;
#line 1367
  fc_len = luf->fc_len;
#line 1368
  sv_ind = luf->sv_ind;
#line 1369
  sv_val = luf->sv_val;
#line 1370
  ret = 0;
#line 1373
  i = 1;
  {
#line 1373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1373
    if (! (i <= n)) {
#line 1373
      goto while_break;
    }
#line 1373
    *(fr_len + i) = 0;
#line 1373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1376
  nnz = 0;
#line 1377
  j = 1;
  {
#line 1377
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1377
    if (! (j <= n)) {
#line 1377
      goto while_break___0;
    }
#line 1380
    j_beg = *(fc_ptr + j);
#line 1381
    j_end = (j_beg + *(fc_len + j)) - 1;
#line 1382
    j_ptr = j_beg;
    {
#line 1382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1382
      if (! (j_ptr <= j_end)) {
#line 1382
        goto while_break___1;
      }
#line 1383
      (*(fr_len + *(sv_ind + j_ptr))) ++;
#line 1382
      j_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1385
    nnz += *(fc_len + j);
#line 1377
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1388
  luf->nnz_f = nnz;
#line 1390
  if (luf->sv_end - luf->sv_beg < nnz) {
#line 1392
    ret = 1;
#line 1393
    goto done;
  }
#line 1396
  i = 1;
  {
#line 1396
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1396
    if (! (i <= n)) {
#line 1396
      goto while_break___2;
    }
#line 1399
    *(fr_ptr + i) = luf->sv_end;
#line 1401
    luf->sv_end -= *(fr_len + i);
#line 1396
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1405
  j = 1;
  {
#line 1405
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1405
    if (! (j <= n)) {
#line 1405
      goto while_break___3;
    }
#line 1407
    j_beg = *(fc_ptr + j);
#line 1408
    j_end = (j_beg + *(fc_len + j)) - 1;
#line 1409
    j_ptr = j_beg;
    {
#line 1409
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1409
      if (! (j_ptr <= j_end)) {
#line 1409
        goto while_break___4;
      }
#line 1411
      i = *(sv_ind + j_ptr);
#line 1413
      (*(fr_ptr + i)) --;
#line 1413
      ptr = *(fr_ptr + i);
#line 1414
      *(sv_ind + ptr) = j;
#line 1415
      *(sv_val + ptr) = *(sv_val + j_ptr);
#line 1409
      j_ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1405
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 1419
  return (ret);
}
}
#line 1509 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
int _glp_luf_factorize(LUF *luf , int n , int (*col)(void *info , int j , int *ind ,
                                                     double *val ) , void *info ) 
{ 
  int *pp_row ;
  int *pp_col ;
  int *qq_row ;
  int *qq_col ;
  double max_gro ;
  int i ;
  int j ;
  int k ;
  int p ;
  int q ;
  int t ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 1512
  max_gro = luf->max_gro;
#line 1514
  if (n < 1) {
    {
#line 1515
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c", 1515);
#line 1515
    (*tmp)("luf_factorize: n = %d; invalid parameter\n", n);
    }
  }
#line 1516
  if (n > 100000000) {
    {
#line 1517
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c", 1517);
#line 1517
    (*tmp___0)("luf_factorize: n = %d; matrix too big\n", n);
    }
  }
  {
#line 1519
  luf->valid = 0;
#line 1521
  reallocate(luf, n);
#line 1522
  pp_row = luf->pp_row;
#line 1523
  pp_col = luf->pp_col;
#line 1524
  qq_row = luf->qq_row;
#line 1525
  qq_col = luf->qq_col;
  }
#line 1527
  if (luf->sv_size == 0) {
#line 1527
    if (luf->new_sva == 0) {
#line 1528
      luf->new_sva = 5 * (n + 10);
    }
  }
  more: 
#line 1530
  if (luf->new_sva > 0) {
#line 1531
    if ((unsigned long )luf->sv_ind != (unsigned long )((void *)0)) {
      {
#line 1531
      _glp_lib_xfree((void *)luf->sv_ind);
      }
    }
#line 1532
    if ((unsigned long )luf->sv_val != (unsigned long )((void *)0)) {
      {
#line 1532
      _glp_lib_xfree((void *)luf->sv_val);
      }
    }
    {
#line 1533
    luf->sv_size = luf->new_sva;
#line 1534
    tmp___1 = _glp_lib_xcalloc(1 + luf->sv_size, (int )sizeof(int ));
#line 1534
    luf->sv_ind = (int *)tmp___1;
#line 1535
    tmp___2 = _glp_lib_xcalloc(1 + luf->sv_size, (int )sizeof(double ));
#line 1535
    luf->sv_val = (double *)tmp___2;
#line 1536
    luf->new_sva = 0;
    }
  }
  {
#line 1539
  tmp___4 = initialize___0(luf, col, info);
  }
#line 1539
  if (tmp___4) {
#line 1541
    luf->new_sva = luf->sv_size + luf->sv_size;
#line 1542
    if (luf->new_sva > luf->sv_size) {
#line 1542
      tmp___3 = 1;
    } else {
      {
#line 1542
      _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       1542);
#line 1542
      tmp___3 = 1;
      }
    }
#line 1543
    goto more;
  }
#line 1546
  k = 1;
  {
#line 1546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1546
    if (! (k <= n)) {
#line 1546
      goto while_break;
    }
    {
#line 1548
    tmp___5 = find_pivot___0(luf, & p, & q);
    }
#line 1548
    if (tmp___5) {
#line 1551
      luf->rank = k - 1;
#line 1552
      ret = 1;
#line 1553
      goto done;
    }
#line 1558
    i = *(pp_col + p);
#line 1558
    j = *(qq_row + q);
#line 1559
    if (k <= i) {
#line 1559
      if (i <= n) {
#line 1559
        if (k <= j) {
#line 1559
          if (j <= n) {
#line 1559
            tmp___6 = 1;
          } else {
            {
#line 1559
            _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                             1559);
#line 1559
            tmp___6 = 1;
            }
          }
        } else {
          {
#line 1559
          _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                           1559);
#line 1559
          tmp___6 = 1;
          }
        }
      } else {
        {
#line 1559
        _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                         1559);
#line 1559
        tmp___6 = 1;
        }
      }
    } else {
      {
#line 1559
      _glp_lib_xassert("k <= i && i <= n && k <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       1559);
#line 1559
      tmp___6 = 1;
      }
    }
    {
#line 1561
    t = *(pp_row + k);
#line 1562
    *(pp_row + i) = t;
#line 1562
    *(pp_col + t) = i;
#line 1563
    *(pp_row + k) = p;
#line 1563
    *(pp_col + p) = k;
#line 1565
    t = *(qq_col + k);
#line 1566
    *(qq_col + j) = t;
#line 1566
    *(qq_row + t) = j;
#line 1567
    *(qq_col + k) = q;
#line 1567
    *(qq_row + q) = k;
#line 1570
    tmp___8 = eliminate___0(luf, p, q);
    }
#line 1570
    if (tmp___8) {
#line 1572
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 1573
      if (luf->new_sva > luf->sv_size) {
#line 1573
        tmp___7 = 1;
      } else {
        {
#line 1573
        _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                         1573);
#line 1573
        tmp___7 = 1;
        }
      }
#line 1574
      goto more;
    }
#line 1577
    if (luf->big_v > max_gro * luf->max_a) {
#line 1580
      luf->rank = k - 1;
#line 1581
      ret = 2;
#line 1582
      goto done;
    }
#line 1546
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1590
  _glp_luf_defrag_sva(luf);
#line 1592
  tmp___10 = build_v_cols(luf);
  }
#line 1592
  if (tmp___10) {
#line 1594
    luf->new_sva = luf->sv_size + luf->sv_size;
#line 1595
    if (luf->new_sva > luf->sv_size) {
#line 1595
      tmp___9 = 1;
    } else {
      {
#line 1595
      _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       1595);
#line 1595
      tmp___9 = 1;
      }
    }
#line 1596
    goto more;
  }
  {
#line 1599
  tmp___12 = build_f_rows(luf);
  }
#line 1599
  if (tmp___12) {
#line 1601
    luf->new_sva = luf->sv_size + luf->sv_size;
#line 1602
    if (luf->new_sva > luf->sv_size) {
#line 1602
      tmp___11 = 1;
    } else {
      {
#line 1602
      _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                       1602);
#line 1602
      tmp___11 = 1;
      }
    }
#line 1603
    goto more;
  }
#line 1606
  luf->valid = 1;
#line 1607
  luf->rank = n;
#line 1608
  ret = 0;
#line 1611
  t = 3 * (n + luf->nnz_v) + 2 * luf->nnz_f;
#line 1612
  if (luf->sv_size < t) {
#line 1613
    luf->new_sva = luf->sv_size;
    {
#line 1614
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1614
      if (! (luf->new_sva < t)) {
#line 1614
        goto while_break___0;
      }
#line 1615
      k = luf->new_sva;
#line 1616
      luf->new_sva = k + k;
#line 1617
      if (luf->new_sva > k) {
#line 1617
        tmp___13 = 1;
      } else {
        {
#line 1617
        _glp_lib_xassert("luf->new_sva > k", "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c",
                         1617);
#line 1617
        tmp___13 = 1;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  done: 
#line 1621
  return (ret);
}
}
#line 1646 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
void _glp_luf_f_solve(LUF *luf , int tr , double *x ) 
{ 
  int n ;
  int *fr_ptr ;
  int *fr_len ;
  int *fc_ptr ;
  int *fc_len ;
  int *pp_row ;
  int *sv_ind ;
  double *sv_val ;
  int i ;
  int j ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double xk ;
  xerror_t tmp ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1647
  n = luf->n;
#line 1648
  fr_ptr = luf->fr_ptr;
#line 1649
  fr_len = luf->fr_len;
#line 1650
  fc_ptr = luf->fc_ptr;
#line 1651
  fc_len = luf->fc_len;
#line 1652
  pp_row = luf->pp_row;
#line 1653
  sv_ind = luf->sv_ind;
#line 1654
  sv_val = luf->sv_val;
#line 1657
  if (! luf->valid) {
    {
#line 1658
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c", 1658);
#line 1658
    (*tmp)("luf_f_solve: LU-factorization is not valid\n");
    }
  }
#line 1659
  if (! tr) {
#line 1661
    j = 1;
    {
#line 1661
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1661
      if (! (j <= n)) {
#line 1661
        goto while_break;
      }
#line 1662
      k = *(pp_row + j);
#line 1663
      xk = *(x + k);
#line 1664
      if (xk != 0.0) {
#line 1665
        beg = *(fc_ptr + k);
#line 1666
        end = (beg + *(fc_len + k)) - 1;
#line 1667
        ptr = beg;
        {
#line 1667
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1667
          if (! (ptr <= end)) {
#line 1667
            goto while_break___0;
          }
#line 1668
          *(x + *(sv_ind + ptr)) -= *(sv_val + ptr) * xk;
#line 1667
          ptr ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1661
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1674
    i = n;
    {
#line 1674
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1674
      if (! (i >= 1)) {
#line 1674
        goto while_break___1;
      }
#line 1675
      k = *(pp_row + i);
#line 1676
      xk = *(x + k);
#line 1677
      if (xk != 0.0) {
#line 1678
        beg = *(fr_ptr + k);
#line 1679
        end = (beg + *(fr_len + k)) - 1;
#line 1680
        ptr = beg;
        {
#line 1680
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1680
          if (! (ptr <= end)) {
#line 1680
            goto while_break___2;
          }
#line 1681
          *(x + *(sv_ind + ptr)) -= *(sv_val + ptr) * xk;
#line 1680
          ptr ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1674
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1685
  return;
}
}
#line 1710 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
void _glp_luf_v_solve(LUF *luf , int tr , double *x ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  double *vr_piv ;
  int *vc_ptr ;
  int *vc_len ;
  int *pp_row ;
  int *qq_col ;
  int *sv_ind ;
  double *sv_val ;
  double *b ;
  int i ;
  int j ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;
  xerror_t tmp ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1711
  n = luf->n;
#line 1712
  vr_ptr = luf->vr_ptr;
#line 1713
  vr_len = luf->vr_len;
#line 1714
  vr_piv = luf->vr_piv;
#line 1715
  vc_ptr = luf->vc_ptr;
#line 1716
  vc_len = luf->vc_len;
#line 1717
  pp_row = luf->pp_row;
#line 1718
  qq_col = luf->qq_col;
#line 1719
  sv_ind = luf->sv_ind;
#line 1720
  sv_val = luf->sv_val;
#line 1721
  b = luf->work;
#line 1724
  if (! luf->valid) {
    {
#line 1725
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c", 1725);
#line 1725
    (*tmp)("luf_v_solve: LU-factorization is not valid\n");
    }
  }
#line 1726
  k = 1;
  {
#line 1726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1726
    if (! (k <= n)) {
#line 1726
      goto while_break;
    }
#line 1726
    *(b + k) = *(x + k);
#line 1726
    *(x + k) = 0.0;
#line 1726
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1727
  if (! tr) {
#line 1729
    k = n;
    {
#line 1729
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1729
      if (! (k >= 1)) {
#line 1729
        goto while_break___0;
      }
#line 1730
      i = *(pp_row + k);
#line 1730
      j = *(qq_col + k);
#line 1731
      temp = *(b + i);
#line 1732
      if (temp != 0.0) {
#line 1733
        temp /= *(vr_piv + i);
#line 1733
        *(x + j) = temp;
#line 1734
        beg = *(vc_ptr + j);
#line 1735
        end = (beg + *(vc_len + j)) - 1;
#line 1736
        ptr = beg;
        {
#line 1736
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1736
          if (! (ptr <= end)) {
#line 1736
            goto while_break___1;
          }
#line 1737
          *(b + *(sv_ind + ptr)) -= *(sv_val + ptr) * temp;
#line 1736
          ptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1729
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1743
    k = 1;
    {
#line 1743
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1743
      if (! (k <= n)) {
#line 1743
        goto while_break___2;
      }
#line 1744
      i = *(pp_row + k);
#line 1744
      j = *(qq_col + k);
#line 1745
      temp = *(b + j);
#line 1746
      if (temp != 0.0) {
#line 1747
        temp /= *(vr_piv + i);
#line 1747
        *(x + i) = temp;
#line 1748
        beg = *(vr_ptr + i);
#line 1749
        end = (beg + *(vr_len + i)) - 1;
#line 1750
        ptr = beg;
        {
#line 1750
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1750
          if (! (ptr <= end)) {
#line 1750
            goto while_break___3;
          }
#line 1751
          *(b + *(sv_ind + ptr)) -= *(sv_val + ptr) * temp;
#line 1750
          ptr ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1743
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1755
  return;
}
}
#line 1780 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
void _glp_luf_a_solve(LUF *luf , int tr , double *x ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1781
  if (! luf->valid) {
    {
#line 1782
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpluf.c", 1782);
#line 1782
    (*tmp)("luf_a_solve: LU-factorization is not valid\n");
    }
  }
#line 1783
  if (! tr) {
    {
#line 1785
    _glp_luf_f_solve(luf, 0, x);
#line 1786
    _glp_luf_v_solve(luf, 0, x);
    }
  } else {
    {
#line 1790
    _glp_luf_v_solve(luf, 1, x);
#line 1791
    _glp_luf_f_solve(luf, 1, x);
    }
  }
#line 1793
  return;
}
}
#line 1812 "/home/wslee/benchmarks/glpk-4.38/src/glpluf.c"
void _glp_luf_delete_it(LUF *luf ) 
{ 


  {
#line 1813
  if ((unsigned long )luf->fr_ptr != (unsigned long )((void *)0)) {
    {
#line 1813
    _glp_lib_xfree((void *)luf->fr_ptr);
    }
  }
#line 1814
  if ((unsigned long )luf->fr_len != (unsigned long )((void *)0)) {
    {
#line 1814
    _glp_lib_xfree((void *)luf->fr_len);
    }
  }
#line 1815
  if ((unsigned long )luf->fc_ptr != (unsigned long )((void *)0)) {
    {
#line 1815
    _glp_lib_xfree((void *)luf->fc_ptr);
    }
  }
#line 1816
  if ((unsigned long )luf->fc_len != (unsigned long )((void *)0)) {
    {
#line 1816
    _glp_lib_xfree((void *)luf->fc_len);
    }
  }
#line 1817
  if ((unsigned long )luf->vr_ptr != (unsigned long )((void *)0)) {
    {
#line 1817
    _glp_lib_xfree((void *)luf->vr_ptr);
    }
  }
#line 1818
  if ((unsigned long )luf->vr_len != (unsigned long )((void *)0)) {
    {
#line 1818
    _glp_lib_xfree((void *)luf->vr_len);
    }
  }
#line 1819
  if ((unsigned long )luf->vr_cap != (unsigned long )((void *)0)) {
    {
#line 1819
    _glp_lib_xfree((void *)luf->vr_cap);
    }
  }
#line 1820
  if ((unsigned long )luf->vr_piv != (unsigned long )((void *)0)) {
    {
#line 1820
    _glp_lib_xfree((void *)luf->vr_piv);
    }
  }
#line 1821
  if ((unsigned long )luf->vc_ptr != (unsigned long )((void *)0)) {
    {
#line 1821
    _glp_lib_xfree((void *)luf->vc_ptr);
    }
  }
#line 1822
  if ((unsigned long )luf->vc_len != (unsigned long )((void *)0)) {
    {
#line 1822
    _glp_lib_xfree((void *)luf->vc_len);
    }
  }
#line 1823
  if ((unsigned long )luf->vc_cap != (unsigned long )((void *)0)) {
    {
#line 1823
    _glp_lib_xfree((void *)luf->vc_cap);
    }
  }
#line 1824
  if ((unsigned long )luf->pp_row != (unsigned long )((void *)0)) {
    {
#line 1824
    _glp_lib_xfree((void *)luf->pp_row);
    }
  }
#line 1825
  if ((unsigned long )luf->pp_col != (unsigned long )((void *)0)) {
    {
#line 1825
    _glp_lib_xfree((void *)luf->pp_col);
    }
  }
#line 1826
  if ((unsigned long )luf->qq_row != (unsigned long )((void *)0)) {
    {
#line 1826
    _glp_lib_xfree((void *)luf->qq_row);
    }
  }
#line 1827
  if ((unsigned long )luf->qq_col != (unsigned long )((void *)0)) {
    {
#line 1827
    _glp_lib_xfree((void *)luf->qq_col);
    }
  }
#line 1828
  if ((unsigned long )luf->sv_ind != (unsigned long )((void *)0)) {
    {
#line 1828
    _glp_lib_xfree((void *)luf->sv_ind);
    }
  }
#line 1829
  if ((unsigned long )luf->sv_val != (unsigned long )((void *)0)) {
    {
#line 1829
    _glp_lib_xfree((void *)luf->sv_val);
    }
  }
#line 1830
  if ((unsigned long )luf->sv_prev != (unsigned long )((void *)0)) {
    {
#line 1830
    _glp_lib_xfree((void *)luf->sv_prev);
    }
  }
#line 1831
  if ((unsigned long )luf->sv_next != (unsigned long )((void *)0)) {
    {
#line 1831
    _glp_lib_xfree((void *)luf->sv_next);
    }
  }
#line 1832
  if ((unsigned long )luf->vr_max != (unsigned long )((void *)0)) {
    {
#line 1832
    _glp_lib_xfree((void *)luf->vr_max);
    }
  }
#line 1833
  if ((unsigned long )luf->rs_head != (unsigned long )((void *)0)) {
    {
#line 1833
    _glp_lib_xfree((void *)luf->rs_head);
    }
  }
#line 1834
  if ((unsigned long )luf->rs_prev != (unsigned long )((void *)0)) {
    {
#line 1834
    _glp_lib_xfree((void *)luf->rs_prev);
    }
  }
#line 1835
  if ((unsigned long )luf->rs_next != (unsigned long )((void *)0)) {
    {
#line 1835
    _glp_lib_xfree((void *)luf->rs_next);
    }
  }
#line 1836
  if ((unsigned long )luf->cs_head != (unsigned long )((void *)0)) {
    {
#line 1836
    _glp_lib_xfree((void *)luf->cs_head);
    }
  }
#line 1837
  if ((unsigned long )luf->cs_prev != (unsigned long )((void *)0)) {
    {
#line 1837
    _glp_lib_xfree((void *)luf->cs_prev);
    }
  }
#line 1838
  if ((unsigned long )luf->cs_next != (unsigned long )((void *)0)) {
    {
#line 1838
    _glp_lib_xfree((void *)luf->cs_next);
    }
  }
#line 1839
  if ((unsigned long )luf->flag != (unsigned long )((void *)0)) {
    {
#line 1839
    _glp_lib_xfree((void *)luf->flag);
    }
  }
#line 1840
  if ((unsigned long )luf->work != (unsigned long )((void *)0)) {
    {
#line 1840
    _glp_lib_xfree((void *)luf->work);
    }
  }
  {
#line 1841
  _glp_lib_xfree((void *)luf);
  }
#line 1842
  return;
}
}
#line 350 "./../include/glpk.h"
int glp_get_obj_dir(glp_prob *lp ) ;
#line 353
int glp_get_num_rows(glp_prob *lp ) ;
#line 356
int glp_get_num_cols(glp_prob *lp ) ;
#line 362
char const   *glp_get_col_name(glp_prob *lp , int j ) ;
#line 365
int glp_get_row_type(glp_prob *lp , int i ) ;
#line 368
double glp_get_row_lb(glp_prob *lp , int i ) ;
#line 371
double glp_get_row_ub(glp_prob *lp , int i ) ;
#line 383
double glp_get_obj_coef(glp_prob *lp , int j ) ;
#line 389
int glp_get_mat_row(glp_prob *lp , int i , int *ind , double *val ) ;
#line 1181
void _glp_lpx_delete_prob(glp_prob *lp ) ;
#line 1564
int _glp_lpx_write_pb(glp_prob *lp , char const   *fname , int normalized , int binarize ) ;
#line 229 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
IPP *_glp_ipp_create_wksp(void) ;
#line 263
void _glp_ipp_load_orig(IPP *ipp , glp_prob *orig ) ;
#line 269
glp_prob *_glp_ipp_build_prob(IPP *ipp ) ;
#line 278
void _glp_ipp_delete_wksp(IPP *ipp ) ;
#line 328
void _glp_ipp_binarize(IPP *ipp ) ;
#line 54 "/home/wslee/benchmarks/glpk-4.38/src/glplpx05.c"
int _glp_lpx_write_pb(glp_prob *lp , char const   *fname , int normalized , int binarize ) 
{ 
  FILE *fp ;
  int m ;
  int n ;
  int i ;
  int j ;
  int k ;
  int o ;
  int nonfree ;
  int obj_dir ;
  int dbl ;
  int *ndx ;
  int row_type ;
  int emptylhs ;
  double coeff ;
  double *val ;
  double bound ;
  double constant ;
  char *objconstname ;
  char *emptylhsname ;
  IPP *ipp ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  double tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
#line 58
  nonfree = 0;
#line 58
  emptylhs = 0;
#line 60
  objconstname = (char *)"dummy_one";
#line 61
  emptylhsname = (char *)"dummy_zero";
#line 65
  ipp = (IPP *)((void *)0);
#line 68
  if (binarize) {
    {
#line 70
    ipp = _glp_ipp_create_wksp();
#line 71
    _glp_ipp_load_orig(ipp, lp);
#line 72
    _glp_ipp_binarize(ipp);
#line 73
    lp = _glp_ipp_build_prob(ipp);
    }
  }
  {
#line 75
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 77
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 79
    if (normalized) {
#line 79
      tmp = "normalized ";
    } else {
#line 79
      tmp = "";
    }
    {
#line 79
    _glp_lib_xprintf("lpx_write_pb: writing problem in %sOPB format to `%s\'...\n",
                     tmp, fname);
#line 83
    m = glp_get_num_rows(lp);
#line 84
    n = glp_get_num_cols(lp);
#line 85
    i = 1;
    }
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
#line 85
      if (! (i <= m)) {
#line 85
        goto while_break;
      }
      {
#line 87
      tmp___0 = glp_get_row_type(lp, i);
      }
      {
#line 91
      if (tmp___0 == 5) {
#line 91
        goto case_5;
      }
#line 91
      if (tmp___0 == 3) {
#line 91
        goto case_5;
      }
#line 91
      if (tmp___0 == 2) {
#line 91
        goto case_5;
      }
#line 96
      if (tmp___0 == 4) {
#line 96
        goto case_4;
      }
#line 87
      goto switch_break;
      case_5: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 93
      nonfree ++;
#line 94
      goto switch_break;
      case_4: /* CIL Label */ 
#line 98
      nonfree += 2;
#line 99
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 85
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 103
    constant = glp_get_obj_coef(lp, 0);
    }
#line 104
    if (constant == (double )0) {
#line 104
      tmp___1 = 1;
    } else {
#line 104
      tmp___1 = 0;
    }
#line 104
    if (constant == (double )0) {
#line 104
      tmp___2 = 1;
    } else {
#line 104
      tmp___2 = 0;
    }
    {
#line 104
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"* #variables = %d #constraints = %d\n",
            n + tmp___2, nonfree + tmp___1);
#line 107
    obj_dir = glp_get_obj_dir(lp);
#line 108
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"min: ");
#line 109
    i = 1;
    }
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if (! (i <= n)) {
#line 109
        goto while_break___0;
      }
      {
#line 111
      coeff = glp_get_obj_coef(lp, i);
      }
#line 112
      if (coeff != 0.0) {
#line 114
        if (obj_dir == 2) {
#line 115
          coeff = - coeff;
        }
#line 116
        if (normalized) {
          {
#line 117
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d x%d",
                  (int )coeff, i);
          }
        } else {
          {
#line 119
          tmp___3 = glp_get_col_name(lp, i);
#line 119
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d*%s",
                  (int )coeff, tmp___3);
          }
        }
      }
#line 109
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    if (constant) {
#line 126
      if (normalized) {
        {
#line 127
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d x%d",
                (int )constant, n + 1);
        }
      } else {
        {
#line 129
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d*%s",
                (int )constant, objconstname);
        }
      }
    }
    {
#line 131
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)";\n");
    }
#line 133
    if (normalized) {
#line 133
      if (! binarize) {
        {
#line 135
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"* Variable name substitution:\n");
#line 136
        j = 1;
        }
        {
#line 136
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 136
          if (! (j <= n)) {
#line 136
            goto while_break___1;
          }
          {
#line 138
          tmp___4 = glp_get_col_name(lp, j);
#line 138
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"* x%d = %s\n",
                  j, tmp___4);
#line 136
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 140
        if (constant) {
          {
#line 141
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"* x%d = %s\n",
                  n + 1, objconstname);
          }
        }
      }
    }
    {
#line 144
    tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 144
    ndx = (int *)tmp___5;
#line 145
    tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 145
    val = (double *)tmp___6;
#line 148
    j = 1;
    }
    {
#line 148
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 148
      if (! (j <= m)) {
#line 148
        goto while_break___2;
      }
      {
#line 150
      row_type = glp_get_row_type(lp, j);
      }
#line 151
      if (row_type != 1) {
#line 153
        if (row_type == 4) {
#line 155
          dbl = 2;
#line 156
          row_type = 3;
        } else {
#line 160
          dbl = 1;
        }
        {
#line 162
        k = glp_get_mat_row(lp, j, ndx, val);
#line 163
        o = 1;
        }
        {
#line 163
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 163
          if (! (o <= dbl)) {
#line 163
            goto while_break___3;
          }
#line 165
          if (o == 2) {
#line 167
            row_type = 2;
          }
#line 169
          if (k == 0) {
#line 171
            emptylhs = 1;
#line 172
            if (normalized) {
              {
#line 174
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0 x%d ",
                      n + 2);
              }
            } else {
              {
#line 178
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0*%s ",
                      emptylhsname);
              }
            }
          }
#line 182
          i = 1;
          {
#line 182
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 182
            if (! (i <= k)) {
#line 182
              goto while_break___4;
            }
#line 184
            if (*(val + i) != 0.0) {
#line 187
              if (normalized) {
#line 189
                if (row_type == 3) {
#line 189
                  tmp___7 = - ((int )*(val + i));
                } else {
#line 189
                  tmp___7 = (int )*(val + i);
                }
                {
#line 189
                fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d x%d ",
                        tmp___7, *(ndx + i));
                }
              } else {
                {
#line 194
                tmp___8 = glp_get_col_name(lp, *(ndx + i));
#line 194
                fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d*%s ",
                        (int )*(val + i), tmp___8);
                }
              }
            }
#line 182
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 201
          if (row_type == 2) {
#line 201
            goto case_2___0;
          }
#line 207
          if (row_type == 3) {
#line 207
            goto case_3___0;
          }
#line 222
          if (row_type == 5) {
#line 222
            goto case_5___0;
          }
#line 199
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
          {
#line 203
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)">=");
#line 204
          bound = glp_get_row_lb(lp, j);
          }
#line 205
          goto switch_break___0;
          case_3___0: /* CIL Label */ 
#line 209
          if (normalized) {
            {
#line 211
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)">=");
#line 212
            tmp___9 = glp_get_row_ub(lp, j);
#line 212
            bound = - tmp___9;
            }
          } else {
            {
#line 216
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<=");
#line 217
            bound = glp_get_row_ub(lp, j);
            }
          }
#line 220
          goto switch_break___0;
          case_5___0: /* CIL Label */ 
          {
#line 224
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"=");
#line 225
          bound = glp_get_row_lb(lp, j);
          }
#line 226
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
          {
#line 229
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d;\n",
                  (int )bound);
#line 163
          o ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 148
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 233
    _glp_lib_xfree((void *)ndx);
#line 234
    _glp_lib_xfree((void *)val);
    }
#line 236
    if (constant) {
      {
#line 238
      _glp_lib_xprintf("lpx_write_pb: adding constant objective function variable\n");
      }
#line 241
      if (normalized) {
        {
#line 242
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"1 x%d = 1;\n",
                n + 1);
        }
      } else {
        {
#line 244
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"1*%s = 1;\n",
                objconstname);
        }
      }
    }
#line 246
    if (emptylhs) {
      {
#line 248
      _glp_lib_xprintf("lpx_write_pb: adding dummy variable for empty left-hand side constraint\n");
      }
#line 252
      if (normalized) {
        {
#line 253
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"1 x%d = 0;\n",
                n + 2);
        }
      } else {
        {
#line 255
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"1*%s = 0;\n",
                emptylhsname);
        }
      }
    }
  } else {
    {
#line 261
    _glp_lib_xprintf("Problems opening file for writing: %s\n", fname);
    }
#line 262
    return (1);
  }
  {
#line 264
  fflush(fp);
#line 265
  tmp___12 = ferror(fp);
  }
#line 265
  if (tmp___12) {
    {
#line 266
    tmp___10 = __errno_location();
#line 266
    tmp___11 = strerror(*tmp___10);
#line 266
    _glp_lib_xprintf("lpx_write_pb: can\'t write to `%s\' - %s\n", fname, tmp___11);
    }
#line 268
    goto fail;
  }
  {
#line 270
  fclose(fp);
  }
#line 273
  if (binarize) {
#line 276
    if ((unsigned long )lp != (unsigned long )((void *)0)) {
      {
#line 276
      _glp_lpx_delete_prob(lp);
      }
    }
#line 278
    if ((unsigned long )ipp != (unsigned long )((void *)0)) {
      {
#line 278
      _glp_ipp_delete_wksp(ipp);
      }
    }
  }
#line 281
  return (0);
  fail: 
#line 282
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 282
    fclose(fp);
    }
  }
#line 283
  return (1);
}
}
#line 1185 "./../include/glpk.h"
char const   *_glp_lpx_get_prob_name(glp_prob *lp ) ;
#line 1193
int _glp_lpx_get_obj_dir(glp_prob *lp ) ;
#line 1197
int _glp_lpx_get_num_rows(glp_prob *lp ) ;
#line 1201
int _glp_lpx_get_num_cols(glp_prob *lp ) ;
#line 1205
char const   *_glp_lpx_get_row_name(glp_prob *lp , int i ) ;
#line 1209
char const   *_glp_lpx_get_col_name(glp_prob *lp , int j ) ;
#line 1225
void _glp_lpx_get_row_bnds(glp_prob *lp , int i , int *typx , double *lb , double *ub ) ;
#line 1242
void _glp_lpx_get_col_bnds(glp_prob *lp , int j , int *typx , double *lb , double *ub ) ;
#line 1247
double _glp_lpx_get_obj_coef(glp_prob *lp , int j ) ;
#line 1251
int _glp_lpx_get_num_nz(glp_prob *lp ) ;
#line 1315
int _glp_lpx_get_status(glp_prob *lp ) ;
#line 1343
void _glp_lpx_get_row_info(glp_prob *lp , int i , int *tagx , double *vx , double *dx ) ;
#line 1360
void _glp_lpx_get_col_info(glp_prob *lp , int j , int *tagx , double *vx , double *dx ) ;
#line 1373
int _glp_lpx_warm_up(glp_prob *lp ) ;
#line 1377
int _glp_lpx_eval_tab_row(glp_prob *lp , int k , int *ind , double *val ) ;
#line 1381
int _glp_lpx_eval_tab_col(glp_prob *lp , int k , int *ind , double *val ) ;
#line 1393
int _glp_lpx_prim_ratio_test(glp_prob *lp , int len , int const   *ind , double const   *val ,
                             int how , double tol ) ;
#line 1487
void _glp_lpx_set_int_parm(glp_prob *lp , int parm , int val ) ;
#line 1491
int _glp_lpx_get_int_parm(glp_prob *lp , int parm ) ;
#line 1548
int _glp_lpx_print_sens_bnds(glp_prob *lp , char const   *fname ) ;
#line 1560
int _glp_lpx_is_b_avail(glp_prob *lp ) ;
#line 58 "/home/wslee/benchmarks/glpk-4.38/src/glplpx04.c"
int _glp_lpx_print_sens_bnds(glp_prob *lp , char const   *fname ) 
{ 
  FILE *fp ;
  int what ;
  int round___0 ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *name ;
  int nr ;
  int nc ;
  int nz ;
  int status ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int status___0 ;
  int i ;
  int j ;
  int k ;
  int m ;
  int n ;
  int dir ;
  double max_inc ;
  double max_dec ;
  int *index___0 ;
  double *val ;
  void *tmp___8 ;
  void *tmp___9 ;
  char const   *name___0 ;
  int typx ;
  int tagx ;
  double lb ;
  double ub ;
  double vx ;
  double dx ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  double tmp___16 ;
  int len ;
  int tagx2 ;
  double vx2 ;
  double dx2 ;
  double delta ;
  int ij ;
  int mn ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *name___1 ;
  int typx___0 ;
  int tagx___0 ;
  double lb___0 ;
  double ub___0 ;
  double vx___0 ;
  double dx___0 ;
  size_t tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  int at_lower ;
  int len___0 ;
  int tmp___25 ;
  int tagx2___0 ;
  int typx2 ;
  double vx2___0 ;
  double dx2___0 ;
  double lb2 ;
  double ub2 ;
  double alpha ;
  int l ;
  int tagx2___1 ;
  int typx2___0 ;
  double vx2___1 ;
  double dx2___1 ;
  double lb2___0 ;
  double ub2___0 ;
  double alpha___0 ;
  int l___0 ;
  int at_upper ;
  int len___1 ;
  int tmp___26 ;
  int tagx2___2 ;
  int typx2___1 ;
  double vx2___2 ;
  double dx2___2 ;
  double lb2___1 ;
  double ub2___1 ;
  double alpha___1 ;
  int l___1 ;
  int tagx2___3 ;
  int typx2___2 ;
  double vx2___3 ;
  double dx2___3 ;
  double lb2___2 ;
  double ub2___2 ;
  double alpha___2 ;
  int l___2 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;

  {
  {
#line 59
  fp = (FILE *)((void *)0);
#line 61
  _glp_lib_xprintf("lpx_print_sens_bnds: writing LP problem solution bounds to `%s\'...\n",
                   fname);
#line 70
  _glp_lpx_warm_up(lp);
#line 75
  tmp = _glp_lpx_is_b_avail(lp);
  }
#line 75
  if (! tmp) {
    {
#line 77
    _glp_lib_xprintf("lpx_print_sens_bnds: basis information not available (may be a presolve issue)\n");
    }
#line 79
    goto fail;
  }
  {
#line 81
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 82
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 83
    tmp___0 = __errno_location();
#line 83
    tmp___1 = strerror(*tmp___0);
#line 83
    _glp_lib_xprintf("lpx_print_sens_bnds: can\'t create `%s\' - %s\n", fname, tmp___1);
    }
#line 85
    goto fail;
  }
  {
#line 89
  name = _glp_lpx_get_prob_name(lp);
  }
#line 90
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 90
    name = "";
  }
  {
#line 91
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-12s%s\n",
          "Problem:", name);
#line 95
  nr = _glp_lpx_get_num_rows(lp);
#line 96
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-12s%d\n",
          "Rows:", nr);
#line 100
  nc = _glp_lpx_get_num_cols(lp);
#line 101
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-12s%d\n",
          "Columns:", nc);
#line 105
  nz = _glp_lpx_get_num_nz(lp);
#line 106
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-12s%d\n",
          "Non-zeros:", nz);
#line 110
  status = _glp_lpx_get_status(lp);
  }
#line 111
  if (status == 180) {
#line 111
    tmp___7 = "OPTIMAL";
  } else {
#line 111
    if (status == 181) {
#line 111
      tmp___6 = "FEASIBLE";
    } else {
#line 111
      if (status == 182) {
#line 111
        tmp___5 = "INFEASIBLE (INTERMEDIATE)";
      } else {
#line 111
        if (status == 183) {
#line 111
          tmp___4 = "INFEASIBLE (FINAL)";
        } else {
#line 111
          if (status == 184) {
#line 111
            tmp___3 = "UNBOUNDED";
          } else {
#line 111
            if (status == 185) {
#line 111
              tmp___2 = "UNDEFINED";
            } else {
#line 111
              tmp___2 = "???";
            }
#line 111
            tmp___3 = tmp___2;
          }
#line 111
          tmp___4 = tmp___3;
        }
#line 111
        tmp___5 = tmp___4;
      }
#line 111
      tmp___6 = tmp___5;
    }
#line 111
    tmp___7 = tmp___6;
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-12s%s\n",
          "Status:", tmp___7);
#line 120
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nExplanation:  This file presents amounts by which objective coefficients,\n");
#line 122
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"constraint bounds, and variable bounds may be changed in the original problem\n");
#line 124
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"while the optimal basis remains the same.  Note that the optimal solution\n");
#line 126
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"and objective value may change even though the basis remains the same.\n");
#line 128
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"These bounds assume that all parameters remain fixed except the one in\n");
#line 130
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"question.  If more than one parameter is changed, it is possible for the\n");
#line 132
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"optimal basis to change even though each parameter stays within its bounds.\n");
#line 134
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"For more details, consult a text on linear programming.\n");
#line 139
  status___0 = _glp_lpx_get_status(lp);
  }
#line 140
  if (status___0 == 180) {
    {
#line 146
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nObjective Coefficient Analysis\n");
#line 147
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"   No.  Column name St    Value       Max increase  Max decrease\n");
#line 149
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"------ ------------ -- ------------- ------------- ------------- \n");
#line 151
    n = _glp_lpx_get_num_cols(lp);
#line 152
    m = _glp_lpx_get_num_rows(lp);
#line 153
    dir = _glp_lpx_get_obj_dir(lp);
#line 155
    tmp___8 = _glp_lib_xcalloc((1 + n) + m, (int )sizeof(int ));
#line 155
    index___0 = (int *)tmp___8;
#line 156
    tmp___9 = _glp_lib_xcalloc((1 + n) + m, (int )sizeof(double ));
#line 156
    val = (double *)tmp___9;
#line 157
    j = 1;
    }
    {
#line 157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 157
      if (! (j <= n)) {
#line 157
        goto while_break;
      }
      {
#line 161
      name___0 = _glp_lpx_get_col_name(lp, j);
      }
#line 162
      if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 162
        name___0 = "";
      }
      {
#line 163
      _glp_lpx_get_col_bnds(lp, j, & typx, & lb, & ub);
#line 169
      round___0 = _glp_lpx_get_int_parm(lp, 308);
#line 170
      _glp_lpx_set_int_parm(lp, 308, 1);
#line 171
      _glp_lpx_get_col_info(lp, j, & tagx, & vx, & dx);
#line 172
      _glp_lpx_set_int_parm(lp, 308, round___0);
#line 175
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%6d ",
              j);
#line 177
      tmp___10 = strlen(name___0);
      }
#line 177
      if (tmp___10 <= 12U) {
        {
#line 178
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-12s ",
                name___0);
        }
      } else {
        {
#line 180
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n%20s",
                name___0, "");
        }
      }
#line 182
      if (tagx == 140) {
#line 182
        tmp___15 = "B ";
      } else {
#line 182
        if (tagx == 141) {
#line 182
          tmp___14 = "NL";
        } else {
#line 182
          if (tagx == 142) {
#line 182
            tmp___13 = "NU";
          } else {
#line 182
            if (tagx == 143) {
#line 182
              tmp___12 = "NF";
            } else {
#line 182
              if (tagx == 144) {
#line 182
                tmp___11 = "NS";
              } else {
#line 182
                tmp___11 = "??";
              }
#line 182
              tmp___12 = tmp___11;
            }
#line 182
            tmp___13 = tmp___12;
          }
#line 182
          tmp___14 = tmp___13;
        }
#line 182
        tmp___15 = tmp___14;
      }
      {
#line 182
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s ",
              tmp___15);
#line 189
      tmp___16 = _glp_lpx_get_obj_coef(lp, j);
#line 189
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
              tmp___16);
      }
#line 190
      if (tagx == 141) {
#line 191
        if (dir == 120) {
#line 193
          max_inc = 1.7976931348623157e+308;
#line 194
          max_dec = dx;
        } else {
#line 198
          max_inc = - dx;
#line 199
          max_dec = 1.7976931348623157e+308;
        }
      }
#line 202
      if (tagx == 142) {
#line 203
        if (dir == 120) {
#line 205
          max_inc = - dx;
#line 206
          max_dec = 1.7976931348623157e+308;
        } else {
#line 209
          max_inc = 1.7976931348623157e+308;
#line 210
          max_dec = dx;
        }
      }
#line 213
      if (tagx == 143) {
#line 215
        max_inc = 0.0;
#line 216
        max_dec = 0.0;
      }
#line 218
      if (tagx == 144) {
#line 220
        max_inc = 1.7976931348623157e+308;
#line 221
        max_dec = 1.7976931348623157e+308;
      }
#line 223
      if (tagx == 140) {
        {
#line 227
        len = _glp_lpx_eval_tab_row(lp, m + j, index___0, val);
#line 228
        max_inc = 1.7976931348623157e+308;
#line 229
        max_dec = 1.7976931348623157e+308;
#line 230
        i = 1;
        }
        {
#line 230
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 230
          if (! (i <= len)) {
#line 230
            goto while_break___0;
          }
#line 235
          if (*(index___0 + i) > m) {
            {
#line 236
            _glp_lpx_get_col_info(lp, *(index___0 + i) - m, & tagx2, & vx2, & dx2);
            }
          } else {
            {
#line 239
            _glp_lpx_get_row_info(lp, *(index___0 + i), & tagx2, & vx2, & dx2);
            }
          }
#line 241
          if (tagx2 == 141) {
#line 242
            if (*(val + i) != 0.0) {
#line 243
              delta = dx2 / *(val + i);
#line 244
              if (delta < (double )0) {
#line 244
                if (- delta < max_inc) {
#line 245
                  max_inc = - delta;
                } else {
#line 244
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 246
              if (delta > (double )0) {
#line 246
                if (delta < max_dec) {
#line 247
                  max_dec = delta;
                }
              }
            }
          }
#line 250
          if (tagx2 == 142) {
#line 251
            if (*(val + i) != 0.0) {
#line 252
              delta = dx2 / *(val + i);
#line 253
              if (delta < (double )0) {
#line 253
                if (- delta < max_inc) {
#line 254
                  max_inc = - delta;
                } else {
#line 253
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 255
              if (delta > (double )0) {
#line 255
                if (delta < max_dec) {
#line 256
                  max_dec = delta;
                }
              }
            }
          }
#line 259
          if (tagx2 == 143) {
#line 260
            if (*(val + i) != 0.0) {
#line 261
              max_inc = 0.0;
#line 262
              max_dec = 0.0;
            }
          }
#line 230
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 267
      if (max_inc == - 0.0) {
#line 267
        max_inc = 0.0;
      }
#line 268
      if (max_dec == - 0.0) {
#line 268
        max_dec = 0.0;
      }
#line 269
      if (max_inc == 1.7976931348623157e+308) {
        {
#line 270
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                "infinity");
        }
      } else
#line 271
      if (max_inc < 1.0e-12) {
#line 271
        if (max_inc > (double )0) {
          {
#line 272
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                  "< eps");
          }
        } else {
          {
#line 274
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                  max_inc);
          }
        }
      } else {
        {
#line 274
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                max_inc);
        }
      }
#line 275
      if (max_dec == 1.7976931348623157e+308) {
        {
#line 276
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                "infinity");
        }
      } else
#line 277
      if (max_dec < 1.0e-12) {
#line 277
        if (max_dec > (double )0) {
          {
#line 278
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                  "< eps");
          }
        } else {
          {
#line 280
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                  max_dec);
          }
        }
      } else {
        {
#line 280
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                max_dec);
        }
      }
      {
#line 281
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 157
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 283
    what = 1;
    {
#line 283
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 283
      if (! (what <= 2)) {
#line 283
        goto while_break___1;
      }
      {
#line 285
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
      }
#line 286
      if (what == 1) {
#line 286
        tmp___17 = "Constraint Bounds";
      } else {
#line 286
        tmp___17 = "Variable Bounds";
      }
      {
#line 286
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s Analysis\n",
              tmp___17);
      }
#line 288
      if (what == 1) {
#line 288
        tmp___18 = " Row name";
      } else {
#line 288
        tmp___18 = "Column name";
      }
      {
#line 288
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"   No. %12s St    Value       Max increase  Max decrease\n",
              tmp___18);
#line 291
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"------ ------------ -- ------------- ------------- ------------- \n");
      }
#line 293
      if (what == 1) {
#line 293
        mn = m;
      } else {
#line 293
        mn = n;
      }
#line 294
      ij = 1;
      {
#line 294
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 294
        if (! (ij <= mn)) {
#line 294
          goto while_break___2;
        }
#line 298
        if (what == 1) {
          {
#line 299
          name___1 = _glp_lpx_get_row_name(lp, ij);
          }
        } else {
          {
#line 301
          name___1 = _glp_lpx_get_col_name(lp, ij);
          }
        }
#line 302
        if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
#line 302
          name___1 = "";
        }
        {
#line 317
        round___0 = _glp_lpx_get_int_parm(lp, 308);
#line 318
        _glp_lpx_set_int_parm(lp, 308, 1);
        }
#line 319
        if (what == 1) {
          {
#line 320
          _glp_lpx_get_row_bnds(lp, ij, & typx___0, & lb___0, & ub___0);
#line 321
          _glp_lpx_get_row_info(lp, ij, & tagx___0, & vx___0, & dx___0);
          }
        } else {
          {
#line 324
          _glp_lpx_get_col_bnds(lp, ij, & typx___0, & lb___0, & ub___0);
#line 325
          _glp_lpx_get_col_info(lp, ij, & tagx___0, & vx___0, & dx___0);
          }
        }
        {
#line 327
        _glp_lpx_set_int_parm(lp, 308, round___0);
#line 330
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%6d ",
                ij);
#line 332
        tmp___19 = strlen(name___1);
        }
#line 332
        if (tmp___19 <= 12U) {
          {
#line 333
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-12s ",
                  name___1);
          }
        } else {
          {
#line 335
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n%20s",
                  name___1, "");
          }
        }
#line 337
        if (tagx___0 == 140) {
#line 337
          tmp___24 = "B ";
        } else {
#line 337
          if (tagx___0 == 141) {
#line 337
            tmp___23 = "NL";
          } else {
#line 337
            if (tagx___0 == 142) {
#line 337
              tmp___22 = "NU";
            } else {
#line 337
              if (tagx___0 == 143) {
#line 337
                tmp___21 = "NF";
              } else {
#line 337
                if (tagx___0 == 144) {
#line 337
                  tmp___20 = "NS";
                } else {
#line 337
                  tmp___20 = "??";
                }
#line 337
                tmp___21 = tmp___20;
              }
#line 337
              tmp___22 = tmp___21;
            }
#line 337
            tmp___23 = tmp___22;
          }
#line 337
          tmp___24 = tmp___23;
        }
        {
#line 337
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s ",
                tmp___24);
#line 343
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
        }
#line 345
        if (typx___0 == 111) {
#line 345
          goto _L___3;
        } else
#line 345
        if (typx___0 == 113) {
#line 345
          goto _L___3;
        } else
#line 345
        if (typx___0 == 114) {
          _L___3: /* CIL Label */ 
#line 348
          at_lower = 0;
#line 349
          if (tagx___0 == 140) {
#line 350
            max_inc = vx___0 - lb___0;
#line 351
            max_dec = 1.7976931348623157e+308;
          } else
#line 349
          if (tagx___0 == 142) {
#line 350
            max_inc = vx___0 - lb___0;
#line 351
            max_dec = 1.7976931348623157e+308;
          }
#line 353
          if (tagx___0 == 144) {
#line 354
            max_inc = 0.0;
#line 355
            max_dec = 0.0;
#line 356
            if (dir == 120) {
#line 356
              if (dx___0 > (double )0) {
#line 356
                at_lower = 1;
              }
            }
#line 357
            if (dir == 121) {
#line 357
              if (dx___0 < (double )0) {
#line 357
                at_lower = 1;
              }
            }
          }
#line 359
          if (tagx___0 == 141) {
#line 359
            goto _L___1;
          } else
#line 359
          if (at_lower == 1) {
            _L___1: /* CIL Label */ 
#line 363
            if (what == 1) {
#line 363
              tmp___25 = ij;
            } else {
#line 363
              tmp___25 = ij + m;
            }
            {
#line 363
            len___0 = _glp_lpx_eval_tab_col(lp, tmp___25, index___0, val);
#line 365
            k = _glp_lpx_prim_ratio_test(lp, len___0, (int const   *)index___0, (double const   *)val,
                                         1, 10e-7);
#line 367
            max_inc = 1.7976931348623157e+308;
            }
#line 368
            if (k != 0) {
#line 375
              l = 1;
              {
#line 375
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 375
                if (! (l <= len___0)) {
#line 375
                  goto while_break___3;
                }
#line 376
                if (*(index___0 + l) == k) {
#line 376
                  alpha = *(val + l);
                }
#line 375
                l ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 377
              if (k > m) {
                {
#line 378
                _glp_lpx_get_col_info(lp, k - m, & tagx2___0, & vx2___0, & dx2___0);
#line 380
                _glp_lpx_get_col_bnds(lp, k - m, & typx2, & lb2, & ub2);
                }
              } else {
                {
#line 384
                _glp_lpx_get_row_info(lp, k, & tagx2___0, & vx2___0, & dx2___0);
#line 386
                _glp_lpx_get_row_bnds(lp, k, & typx2, & lb2, & ub2);
                }
              }
#line 391
              if (alpha > (double )0) {
#line 392
                max_inc = (ub2 - vx2___0) / alpha;
              } else {
#line 394
                max_inc = (lb2 - vx2___0) / alpha;
              }
            }
            {
#line 397
            k = _glp_lpx_prim_ratio_test(lp, len___0, (int const   *)index___0, (double const   *)val,
                                         -1, 10e-7);
#line 399
            max_dec = 1.7976931348623157e+308;
            }
#line 400
            if (k != 0) {
#line 407
              l___0 = 1;
              {
#line 407
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 407
                if (! (l___0 <= len___0)) {
#line 407
                  goto while_break___4;
                }
#line 408
                if (*(index___0 + l___0) == k) {
#line 408
                  alpha___0 = *(val + l___0);
                }
#line 407
                l___0 ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 409
              if (k > m) {
                {
#line 410
                _glp_lpx_get_col_info(lp, k - m, & tagx2___1, & vx2___1, & dx2___1);
#line 412
                _glp_lpx_get_col_bnds(lp, k - m, & typx2___0, & lb2___0, & ub2___0);
                }
              } else {
                {
#line 416
                _glp_lpx_get_row_info(lp, k, & tagx2___1, & vx2___1, & dx2___1);
#line 418
                _glp_lpx_get_row_bnds(lp, k, & typx2___0, & lb2___0, & ub2___0);
                }
              }
#line 423
              if (alpha___0 > (double )0) {
#line 424
                max_dec = (vx2___1 - lb2___0) / alpha___0;
              } else {
#line 426
                max_dec = (vx2___1 - ub2___0) / alpha___0;
              }
            }
          }
#line 430
          if (typx___0 == 113) {
#line 430
            goto _L___2;
          } else
#line 430
          if (typx___0 == 114) {
            _L___2: /* CIL Label */ 
#line 431
            if (max_inc > ub___0 - lb___0) {
#line 432
              max_inc = ub___0 - lb___0;
            }
          }
          {
#line 434
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"         LOWER         %13.6g ",
                  lb___0);
          }
#line 435
          if (max_inc == - 0.0) {
#line 435
            max_inc = 0.0;
          }
#line 436
          if (max_dec == - 0.0) {
#line 436
            max_dec = 0.0;
          }
#line 437
          if (max_inc == 1.7976931348623157e+308) {
            {
#line 438
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                    "infinity");
            }
          } else
#line 439
          if (max_inc < 1.0e-12) {
#line 439
            if (max_inc > (double )0) {
              {
#line 440
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                      "< eps");
              }
            } else {
              {
#line 442
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                      max_inc);
              }
            }
          } else {
            {
#line 442
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                    max_inc);
            }
          }
#line 443
          if (max_dec == 1.7976931348623157e+308) {
            {
#line 444
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                    "infinity");
            }
          } else
#line 445
          if (max_dec < 1.0e-12) {
#line 445
            if (max_dec > (double )0) {
              {
#line 446
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                      "< eps");
              }
            } else {
              {
#line 448
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                      max_dec);
              }
            }
          } else {
            {
#line 448
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                    max_dec);
            }
          }
          {
#line 449
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
          }
        }
#line 452
        if (typx___0 == 112) {
#line 452
          goto _L___6;
        } else
#line 452
        if (typx___0 == 113) {
#line 452
          goto _L___6;
        } else
#line 452
        if (typx___0 == 114) {
          _L___6: /* CIL Label */ 
#line 455
          at_upper = 0;
#line 456
          if (tagx___0 == 140) {
#line 457
            max_inc = 1.7976931348623157e+308;
#line 458
            max_dec = ub___0 - vx___0;
          } else
#line 456
          if (tagx___0 == 141) {
#line 457
            max_inc = 1.7976931348623157e+308;
#line 458
            max_dec = ub___0 - vx___0;
          }
#line 460
          if (tagx___0 == 144) {
#line 461
            max_inc = 0.0;
#line 462
            max_dec = 0.0;
#line 463
            if (dir == 120) {
#line 463
              if (dx___0 < (double )0) {
#line 463
                at_upper = 1;
              }
            }
#line 464
            if (dir == 121) {
#line 464
              if (dx___0 > (double )0) {
#line 464
                at_upper = 1;
              }
            }
          }
#line 466
          if (tagx___0 == 142) {
#line 466
            goto _L___4;
          } else
#line 466
          if (at_upper == 1) {
            _L___4: /* CIL Label */ 
#line 470
            if (what == 1) {
#line 470
              tmp___26 = ij;
            } else {
#line 470
              tmp___26 = ij + m;
            }
            {
#line 470
            len___1 = _glp_lpx_eval_tab_col(lp, tmp___26, index___0, val);
#line 472
            k = _glp_lpx_prim_ratio_test(lp, len___1, (int const   *)index___0, (double const   *)val,
                                         1, 10e-7);
#line 474
            max_inc = 1.7976931348623157e+308;
            }
#line 475
            if (k != 0) {
#line 482
              l___1 = 1;
              {
#line 482
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 482
                if (! (l___1 <= len___1)) {
#line 482
                  goto while_break___5;
                }
#line 483
                if (*(index___0 + l___1) == k) {
#line 483
                  alpha___1 = *(val + l___1);
                }
#line 482
                l___1 ++;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 484
              if (k > m) {
                {
#line 485
                _glp_lpx_get_col_info(lp, k - m, & tagx2___2, & vx2___2, & dx2___2);
#line 487
                _glp_lpx_get_col_bnds(lp, k - m, & typx2___1, & lb2___1, & ub2___1);
                }
              } else {
                {
#line 491
                _glp_lpx_get_row_info(lp, k, & tagx2___2, & vx2___2, & dx2___2);
#line 493
                _glp_lpx_get_row_bnds(lp, k, & typx2___1, & lb2___1, & ub2___1);
                }
              }
#line 498
              if (alpha___1 > (double )0) {
#line 499
                max_inc = (ub2___1 - vx2___2) / alpha___1;
              } else {
#line 501
                max_inc = (lb2___1 - vx2___2) / alpha___1;
              }
            }
            {
#line 504
            k = _glp_lpx_prim_ratio_test(lp, len___1, (int const   *)index___0, (double const   *)val,
                                         -1, 10e-7);
#line 506
            max_dec = 1.7976931348623157e+308;
            }
#line 507
            if (k != 0) {
#line 514
              l___2 = 1;
              {
#line 514
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 514
                if (! (l___2 <= len___1)) {
#line 514
                  goto while_break___6;
                }
#line 515
                if (*(index___0 + l___2) == k) {
#line 515
                  alpha___2 = *(val + l___2);
                }
#line 514
                l___2 ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 516
              if (k > m) {
                {
#line 517
                _glp_lpx_get_col_info(lp, k - m, & tagx2___3, & vx2___3, & dx2___3);
#line 519
                _glp_lpx_get_col_bnds(lp, k - m, & typx2___2, & lb2___2, & ub2___2);
                }
              } else {
                {
#line 523
                _glp_lpx_get_row_info(lp, k, & tagx2___3, & vx2___3, & dx2___3);
#line 525
                _glp_lpx_get_row_bnds(lp, k, & typx2___2, & lb2___2, & ub2___2);
                }
              }
#line 530
              if (alpha___2 > (double )0) {
#line 531
                max_dec = (vx2___3 - lb2___2) / alpha___2;
              } else {
#line 533
                max_dec = (vx2___3 - ub2___2) / alpha___2;
              }
            }
          }
#line 536
          if (typx___0 == 113) {
#line 536
            goto _L___5;
          } else
#line 536
          if (typx___0 == 114) {
            _L___5: /* CIL Label */ 
#line 537
            if (max_dec > ub___0 - lb___0) {
#line 538
              max_dec = ub___0 - lb___0;
            }
          }
          {
#line 541
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"         UPPER         %13.6g ",
                  ub___0);
          }
#line 542
          if (max_inc == - 0.0) {
#line 542
            max_inc = 0.0;
          }
#line 543
          if (max_dec == - 0.0) {
#line 543
            max_dec = 0.0;
          }
#line 544
          if (max_inc == 1.7976931348623157e+308) {
            {
#line 545
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                    "infinity");
            }
          } else
#line 546
          if (max_inc < 1.0e-12) {
#line 546
            if (max_inc > (double )0) {
              {
#line 547
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                      "< eps");
              }
            } else {
              {
#line 549
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                      max_inc);
              }
            }
          } else {
            {
#line 549
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                    max_inc);
            }
          }
#line 550
          if (max_dec == 1.7976931348623157e+308) {
            {
#line 551
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                    "infinity");
            }
          } else
#line 552
          if (max_dec < 1.0e-12) {
#line 552
            if (max_dec > (double )0) {
              {
#line 553
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13s ",
                      "< eps");
              }
            } else {
              {
#line 555
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                      max_dec);
              }
            }
          } else {
            {
#line 555
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%13.6g ",
                    max_dec);
            }
          }
          {
#line 556
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
          }
        }
#line 294
        ij ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 283
      what ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 561
    _glp_lib_xfree((void *)index___0);
#line 562
    _glp_lib_xfree((void *)val);
    }
  } else {
    {
#line 564
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"No range information since solution is not optimal.\n");
    }
  }
  {
#line 567
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 568
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"End of output\n");
#line 569
  fflush(fp);
#line 570
  tmp___29 = ferror(fp);
  }
#line 570
  if (tmp___29) {
    {
#line 571
    tmp___27 = __errno_location();
#line 571
    tmp___28 = strerror(*tmp___27);
#line 571
    _glp_lib_xprintf("lpx_print_sens_bnds: can\'t write to `%s\' - %s\n", fname, tmp___28);
    }
#line 573
    goto fail;
  }
  {
#line 575
  fclose(fp);
  }
#line 576
  return (0);
  fail: 
#line 577
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 577
    fclose(fp);
    }
  }
#line 578
  return (1);
}
}
#line 566 "./../include/glpk.h"
extern int glp_factorize(glp_prob *P ) ;
#line 578
extern int glp_get_bhead(glp_prob *P , int k ) ;
#line 581
extern int glp_get_row_bind(glp_prob *P , int i ) ;
#line 584
extern int glp_get_col_bind(glp_prob *P , int j ) ;
#line 587
extern void glp_ftran(glp_prob *P , double *x ) ;
#line 590
extern void glp_btran(glp_prob *P , double *x ) ;
#line 1213
int _glp_lpx_get_row_type(glp_prob *lp , int i ) ;
#line 1217
double _glp_lpx_get_row_lb(glp_prob *lp , int i ) ;
#line 1221
double _glp_lpx_get_row_ub(glp_prob *lp , int i ) ;
#line 1230
int _glp_lpx_get_col_type(glp_prob *lp , int j ) ;
#line 1234
double _glp_lpx_get_col_lb(glp_prob *lp , int j ) ;
#line 1238
double _glp_lpx_get_col_ub(glp_prob *lp , int j ) ;
#line 1259
int _glp_lpx_get_mat_col(glp_prob *lp , int j , int *ind , double *val ) ;
#line 1319
int _glp_lpx_get_prim_stat(glp_prob *lp ) ;
#line 1323
int _glp_lpx_get_dual_stat(glp_prob *lp ) ;
#line 1331
int _glp_lpx_get_row_stat(glp_prob *lp , int i ) ;
#line 1335
double _glp_lpx_get_row_prim(glp_prob *lp , int i ) ;
#line 1339
double _glp_lpx_get_row_dual(glp_prob *lp , int i ) ;
#line 1348
int _glp_lpx_get_col_stat(glp_prob *lp , int j ) ;
#line 1352
double _glp_lpx_get_col_prim(glp_prob *lp , int j ) ;
#line 1356
double _glp_lpx_get_col_dual(glp_prob *lp , int j ) ;
#line 1385
int _glp_lpx_transform_row(glp_prob *lp , int len , int *ind , double *val ) ;
#line 1389
int _glp_lpx_transform_col(glp_prob *lp , int len , int *ind , double *val ) ;
#line 1398
int _glp_lpx_dual_ratio_test(glp_prob *lp , int len , int const   *ind , double const   *val ,
                             int how , double tol ) ;
#line 1499
double _glp_lpx_get_real_parm(glp_prob *lp , int parm ) ;
#line 431 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
void _glp_1px_put_solution(glp_prob *lp , int inval , int const   *p_stat , int const   *d_stat ,
                           double const   *obj_val , int const   *r_stat , double const   *r_prim ,
                           double const   *r_dual , int const   *c_stat , double const   *c_prim ,
                           double const   *c_dual ) ;
#line 443
void _glp_1px_eval_b_prim(glp_prob *lp , double *row_prim , double *col_prim ) ;
#line 447
void _glp_1px_eval_b_dual(glp_prob *lp , double *row_dual , double *col_dual ) ;
#line 65 "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c"
void _glp_1px_eval_b_prim(glp_prob *lp , double *row_prim , double *col_prim ) 
{ 
  int i ;
  int j ;
  int k ;
  int m ;
  int n ;
  int stat ;
  int len ;
  int *ind ;
  double xN ;
  double *NxN ;
  double *xB ;
  double *val ;
  xerror_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 68
  tmp___0 = _glp_lpx_is_b_avail(lp);
  }
#line 68
  if (! tmp___0) {
    {
#line 69
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c", 69);
#line 69
    (*tmp)("lpx_eval_b_prim: LP basis is not available\n");
    }
  }
  {
#line 70
  m = _glp_lpx_get_num_rows(lp);
#line 71
  n = _glp_lpx_get_num_cols(lp);
#line 74
  tmp___1 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 74
  NxN = (double *)tmp___1;
#line 75
  i = 1;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i <= m)) {
#line 75
      goto while_break;
    }
#line 75
    *(NxN + i) = 0.0;
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  i = 1;
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    if (! (i <= m)) {
#line 77
      goto while_break___0;
    }
    {
#line 79
    stat = _glp_lpx_get_row_stat(lp, i);
    }
#line 81
    if (stat == 140) {
#line 81
      goto __Cont;
    }
    {
#line 84
    if (stat == 141) {
#line 84
      goto case_141;
    }
#line 85
    if (stat == 142) {
#line 85
      goto case_142;
    }
#line 86
    if (stat == 143) {
#line 86
      goto case_143;
    }
#line 87
    if (stat == 144) {
#line 87
      goto case_144;
    }
#line 88
    goto switch_default;
    case_141: /* CIL Label */ 
    {
#line 84
    xN = _glp_lpx_get_row_lb(lp, i);
    }
#line 84
    goto switch_break;
    case_142: /* CIL Label */ 
    {
#line 85
    xN = _glp_lpx_get_row_ub(lp, i);
    }
#line 85
    goto switch_break;
    case_143: /* CIL Label */ 
#line 86
    xN = 0.0;
#line 86
    goto switch_break;
    case_144: /* CIL Label */ 
    {
#line 87
    xN = _glp_lpx_get_row_lb(lp, i);
    }
#line 87
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 88
    if ((unsigned long )lp != (unsigned long )lp) {
#line 88
      tmp___2 = 1;
    } else {
      {
#line 88
      _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       88);
#line 88
      tmp___2 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 91
    *(row_prim + i) = xN;
#line 93
    *(NxN + i) -= xN;
    __Cont: /* CIL Label */ 
#line 77
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 96
  tmp___3 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 96
  ind = (int *)tmp___3;
#line 97
  tmp___4 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 97
  val = (double *)tmp___4;
#line 98
  j = 1;
  }
  {
#line 98
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 98
    if (! (j <= n)) {
#line 98
      goto while_break___1;
    }
    {
#line 100
    stat = _glp_lpx_get_col_stat(lp, j);
    }
#line 102
    if (stat == 140) {
#line 102
      goto __Cont___0;
    }
    {
#line 105
    if (stat == 141) {
#line 105
      goto case_141___0;
    }
#line 106
    if (stat == 142) {
#line 106
      goto case_142___0;
    }
#line 107
    if (stat == 143) {
#line 107
      goto case_143___0;
    }
#line 108
    if (stat == 144) {
#line 108
      goto case_144___0;
    }
#line 109
    goto switch_default___0;
    case_141___0: /* CIL Label */ 
    {
#line 105
    xN = _glp_lpx_get_col_lb(lp, j);
    }
#line 105
    goto switch_break___0;
    case_142___0: /* CIL Label */ 
    {
#line 106
    xN = _glp_lpx_get_col_ub(lp, j);
    }
#line 106
    goto switch_break___0;
    case_143___0: /* CIL Label */ 
#line 107
    xN = 0.0;
#line 107
    goto switch_break___0;
    case_144___0: /* CIL Label */ 
    {
#line 108
    xN = _glp_lpx_get_col_lb(lp, j);
    }
#line 108
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 109
    if ((unsigned long )lp != (unsigned long )lp) {
#line 109
      tmp___5 = 1;
    } else {
      {
#line 109
      _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       109);
#line 109
      tmp___5 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 112
    *(col_prim + j) = xN;
#line 114
    if (xN != 0.0) {
      {
#line 115
      len = _glp_lpx_get_mat_col(lp, j, ind, val);
#line 116
      k = 1;
      }
      {
#line 116
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 116
        if (! (k <= len)) {
#line 116
          goto while_break___2;
        }
#line 116
        *(NxN + *(ind + k)) += *(val + k) * xN;
#line 116
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 98
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 119
  _glp_lib_xfree((void *)ind);
#line 120
  _glp_lib_xfree((void *)val);
#line 122
  xB = NxN;
#line 122
  glp_ftran(lp, xB);
#line 124
  i = 1;
  }
  {
#line 124
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 124
    if (! (i <= m)) {
#line 124
      goto while_break___3;
    }
    {
#line 125
    k = glp_get_bhead(lp, i);
    }
#line 126
    if (1 <= k) {
#line 126
      if (k <= m + n) {
#line 126
        tmp___6 = 1;
      } else {
        {
#line 126
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                         126);
#line 126
        tmp___6 = 1;
        }
      }
    } else {
      {
#line 126
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       126);
#line 126
      tmp___6 = 1;
      }
    }
#line 127
    if (k <= m) {
#line 128
      *(row_prim + k) = *(xB + i);
    } else {
#line 130
      *(col_prim + (k - m)) = *(xB + i);
    }
#line 124
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 132
  _glp_lib_xfree((void *)NxN);
  }
#line 133
  return;
}
}
#line 198 "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c"
void _glp_1px_eval_b_dual(glp_prob *lp , double *row_dual , double *col_dual ) 
{ 
  int i ;
  int j ;
  int k ;
  int m ;
  int n ;
  int len ;
  int *ind ;
  double dj ;
  double *cB ;
  double *pi ;
  double *val ;
  xerror_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 201
  tmp___0 = _glp_lpx_is_b_avail(lp);
  }
#line 201
  if (! tmp___0) {
    {
#line 202
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c", 202);
#line 202
    (*tmp)("lpx_eval_b_dual: LP basis is not available\n");
    }
  }
  {
#line 203
  m = _glp_lpx_get_num_rows(lp);
#line 204
  n = _glp_lpx_get_num_cols(lp);
#line 208
  tmp___1 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 208
  cB = (double *)tmp___1;
#line 209
  i = 1;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i <= m)) {
#line 209
      goto while_break;
    }
    {
#line 210
    k = glp_get_bhead(lp, i);
    }
#line 212
    if (1 <= k) {
#line 212
      if (k <= m + n) {
#line 212
        tmp___2 = 1;
      } else {
        {
#line 212
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                         212);
#line 212
        tmp___2 = 1;
        }
      }
    } else {
      {
#line 212
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       212);
#line 212
      tmp___2 = 1;
      }
    }
#line 213
    if (k <= m) {
#line 214
      *(row_dual + k) = 0.0;
#line 215
      *(cB + i) = 0.0;
    } else {
      {
#line 218
      *(col_dual + (k - m)) = 0.0;
#line 219
      *(cB + i) = _glp_lpx_get_obj_coef(lp, k - m);
      }
    }
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  pi = cB;
#line 223
  glp_btran(lp, pi);
#line 225
  i = 1;
  }
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 225
    if (! (i <= m)) {
#line 225
      goto while_break___0;
    }
    {
#line 226
    tmp___3 = _glp_lpx_get_row_stat(lp, i);
    }
#line 226
    if (tmp___3 != 140) {
#line 227
      *(row_dual + i) = - *(pi + i);
    }
#line 225
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 230
  tmp___4 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 230
  ind = (int *)tmp___4;
#line 231
  tmp___5 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 231
  val = (double *)tmp___5;
#line 232
  j = 1;
  }
  {
#line 232
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 232
    if (! (j <= n)) {
#line 232
      goto while_break___1;
    }
    {
#line 233
    tmp___6 = _glp_lpx_get_col_stat(lp, j);
    }
#line 233
    if (tmp___6 != 140) {
      {
#line 234
      dj = _glp_lpx_get_obj_coef(lp, j);
#line 235
      len = _glp_lpx_get_mat_col(lp, j, ind, val);
#line 236
      k = 1;
      }
      {
#line 236
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 236
        if (! (k <= len)) {
#line 236
          goto while_break___2;
        }
#line 236
        dj += *(val + k) * *(pi + *(ind + k));
#line 236
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 237
      *(col_dual + j) = dj;
    }
#line 232
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 240
  _glp_lib_xfree((void *)ind);
#line 241
  _glp_lib_xfree((void *)val);
#line 242
  _glp_lib_xfree((void *)cB);
  }
#line 243
  return;
}
}
#line 277 "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c"
int _glp_lpx_warm_up(glp_prob *lp ) 
{ 
  int m ;
  int n ;
  int j ;
  int k ;
  int ret ;
  int type ;
  int stat ;
  int p_stat ;
  int d_stat ;
  double lb ;
  double ub ;
  double prim ;
  double dual ;
  double tol_bnd ;
  double tol_dj ;
  double dir ;
  double *row_prim ;
  double *row_dual ;
  double *col_prim ;
  double *col_dual ;
  double sum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  int tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 281
  m = _glp_lpx_get_num_rows(lp);
#line 282
  n = _glp_lpx_get_num_cols(lp);
#line 284
  tmp___1 = _glp_lpx_is_b_avail(lp);
  }
#line 284
  if (tmp___1) {
#line 285
    ret = 200;
  } else {
#line 287
    if (m == 0) {
#line 288
      ret = 201;
#line 289
      goto done;
    } else
#line 287
    if (n == 0) {
#line 288
      ret = 201;
#line 289
      goto done;
    }
    {
#line 308
    tmp = glp_factorize(lp);
    }
    {
#line 309
    if (tmp == 0) {
#line 309
      goto case_0;
    }
#line 312
    if (tmp == 1) {
#line 312
      goto case_1;
    }
#line 316
    if (tmp == 3) {
#line 316
      goto case_3;
    }
#line 316
    if (tmp == 2) {
#line 316
      goto case_3;
    }
#line 319
    goto switch_default;
    case_0: /* CIL Label */ 
#line 310
    ret = 200;
#line 311
    goto switch_break;
    case_1: /* CIL Label */ 
#line 313
    ret = 202;
#line 314
    goto done;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 317
    ret = 211;
#line 318
    goto done;
    switch_default: /* CIL Label */ 
#line 320
    if ((unsigned long )lp != (unsigned long )lp) {
#line 320
      tmp___0 = 1;
    } else {
      {
#line 320
      _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       320);
#line 320
      tmp___0 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 325
  tmp___2 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 325
  row_prim = (double *)tmp___2;
#line 326
  tmp___3 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 326
  row_dual = (double *)tmp___3;
#line 327
  tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 327
  col_prim = (double *)tmp___4;
#line 328
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 328
  col_dual = (double *)tmp___5;
#line 330
  _glp_1px_eval_b_prim(lp, row_prim, col_prim);
#line 332
  tmp___6 = _glp_lpx_get_real_parm(lp, 305);
#line 332
  tol_bnd = 3.0 * tmp___6;
#line 333
  p_stat = 133;
#line 334
  k = 1;
  }
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (k <= m + n)) {
#line 334
      goto while_break;
    }
#line 335
    if (k <= m) {
      {
#line 336
      type = _glp_lpx_get_row_type(lp, k);
#line 337
      lb = _glp_lpx_get_row_lb(lp, k);
#line 338
      ub = _glp_lpx_get_row_ub(lp, k);
#line 339
      prim = *(row_prim + k);
      }
    } else {
      {
#line 342
      type = _glp_lpx_get_col_type(lp, k - m);
#line 343
      lb = _glp_lpx_get_col_lb(lp, k - m);
#line 344
      ub = _glp_lpx_get_col_ub(lp, k - m);
#line 345
      prim = *(col_prim + (k - m));
      }
    }
#line 347
    if (type == 111) {
#line 347
      goto _L;
    } else
#line 347
    if (type == 113) {
#line 347
      goto _L;
    } else
#line 347
    if (type == 114) {
      _L: /* CIL Label */ 
      {
#line 349
      tmp___7 = fabs(lb);
      }
#line 349
      if (prim < lb - tol_bnd * (1.0 + tmp___7)) {
#line 350
        p_stat = 134;
#line 351
        goto while_break;
      }
    }
#line 354
    if (type == 112) {
#line 354
      goto _L___0;
    } else
#line 354
    if (type == 113) {
#line 354
      goto _L___0;
    } else
#line 354
    if (type == 114) {
      _L___0: /* CIL Label */ 
      {
#line 356
      tmp___8 = fabs(ub);
      }
#line 356
      if (prim > ub + tol_bnd * (1.0 + tmp___8)) {
#line 357
        p_stat = 134;
#line 358
        goto while_break;
      }
    }
#line 334
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  _glp_1px_eval_b_dual(lp, row_dual, col_dual);
#line 365
  tmp___9 = _glp_lpx_get_real_parm(lp, 306);
#line 365
  tol_dj = 3.0 * tmp___9;
#line 366
  tmp___11 = _glp_lpx_get_obj_dir(lp);
  }
#line 366
  if (tmp___11 == 120) {
#line 366
    dir = 1.0;
  } else {
#line 366
    dir = - 1.0;
  }
#line 367
  d_stat = 137;
#line 368
  k = 1;
  {
#line 368
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 368
    if (! (k <= m + n)) {
#line 368
      goto while_break___0;
    }
#line 369
    if (k <= m) {
      {
#line 370
      stat = _glp_lpx_get_row_stat(lp, k);
#line 371
      dual = *(row_dual + k);
      }
    } else {
      {
#line 374
      stat = _glp_lpx_get_col_stat(lp, k - m);
#line 375
      dual = *(col_dual + (k - m));
      }
    }
#line 377
    if (stat == 140) {
#line 377
      goto _L___1;
    } else
#line 377
    if (stat == 141) {
#line 377
      goto _L___1;
    } else
#line 377
    if (stat == 143) {
      _L___1: /* CIL Label */ 
#line 380
      if (dir * dual < - tol_dj) {
#line 381
        d_stat = 138;
#line 382
        goto while_break___0;
      }
    }
#line 385
    if (stat == 140) {
#line 385
      goto _L___2;
    } else
#line 385
    if (stat == 142) {
#line 385
      goto _L___2;
    } else
#line 385
    if (stat == 143) {
      _L___2: /* CIL Label */ 
#line 388
      if (dir * dual > tol_dj) {
#line 389
        d_stat = 138;
#line 390
        goto while_break___0;
      }
    }
#line 368
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 395
  p_stat = (p_stat - 132) + 1;
#line 396
  d_stat = (d_stat - 136) + 1;
#line 397
  sum = _glp_lpx_get_obj_coef(lp, 0);
#line 398
  j = 1;
  }
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if (! (j <= n)) {
#line 398
      goto while_break___1;
    }
    {
#line 399
    tmp___12 = _glp_lpx_get_obj_coef(lp, j);
#line 399
    sum += tmp___12 * *(col_prim + j);
#line 398
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 400
  _glp_1px_put_solution(lp, 0, (int const   *)(& p_stat), (int const   *)(& d_stat),
                        (double const   *)(& sum), (int const   *)((void *)0), (double const   *)row_prim,
                        (double const   *)row_dual, (int const   *)((void *)0), (double const   *)col_prim,
                        (double const   *)col_dual);
#line 402
  tmp___13 = _glp_lpx_is_b_avail(lp);
  }
#line 402
  if (tmp___13) {
#line 402
    tmp___14 = 1;
  } else {
    {
#line 402
    _glp_lib_xassert("lpx_is_b_avail(lp)", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                     402);
#line 402
    tmp___14 = 1;
    }
  }
  {
#line 404
  _glp_lib_xfree((void *)row_prim);
#line 405
  _glp_lib_xfree((void *)row_dual);
#line 406
  _glp_lib_xfree((void *)col_prim);
#line 407
  _glp_lib_xfree((void *)col_dual);
  }
  done: 
#line 409
  return (ret);
}
}
#line 493 "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c"
int _glp_lpx_transform_row(glp_prob *lp , int len , int *ind , double *val ) 
{ 
  int i ;
  int j ;
  int k ;
  int m ;
  int n ;
  int t ;
  int lll ;
  int *iii ;
  double alfa ;
  double *a ;
  double *aB ;
  double *rho ;
  double *vvv ;
  xerror_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
  {
#line 496
  tmp___0 = _glp_lpx_is_b_avail(lp);
  }
#line 496
  if (! tmp___0) {
    {
#line 497
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c", 497);
#line 497
    (*tmp)("lpx_transform_row: LP basis is not available\n");
    }
  }
  {
#line 498
  m = _glp_lpx_get_num_rows(lp);
#line 499
  n = _glp_lpx_get_num_cols(lp);
#line 501
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 501
  a = (double *)tmp___1;
#line 502
  j = 1;
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (j <= n)) {
#line 502
      goto while_break;
    }
#line 502
    *(a + j) = 0.0;
#line 502
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  if (0 <= len) {
#line 503
    if (! (len <= n)) {
      {
#line 504
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 504);
#line 504
      (*tmp___2)("lpx_transform_row: len = %d; invalid row length\n", len);
      }
    }
  } else {
    {
#line 504
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                               504);
#line 504
    (*tmp___2)("lpx_transform_row: len = %d; invalid row length\n", len);
    }
  }
#line 506
  t = 1;
  {
#line 506
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 506
    if (! (t <= len)) {
#line 506
      goto while_break___0;
    }
#line 507
    j = *(ind + t);
#line 508
    if (1 <= j) {
#line 508
      if (! (j <= n)) {
        {
#line 509
        tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                   509);
#line 509
        (*tmp___3)("lpx_transform_row: ind[%d] = %d; column index out of range\n",
                   t, j);
        }
      }
    } else {
      {
#line 509
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 509);
#line 509
      (*tmp___3)("lpx_transform_row: ind[%d] = %d; column index out of range\n", t,
                 j);
      }
    }
#line 511
    if (*(val + t) == 0.0) {
      {
#line 512
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 512);
#line 512
      (*tmp___4)("lpx_transform_row: val[%d] = 0; zero coefficient not allowed\n",
                 t);
      }
    }
#line 514
    if (*(a + j) != 0.0) {
      {
#line 515
      tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 515);
#line 515
      (*tmp___5)("lpx_transform_row: ind[%d] = %d; duplicate column indices not allowed\n",
                 t, j);
      }
    }
#line 517
    *(a + j) = *(val + t);
#line 506
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 520
  tmp___6 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 520
  aB = (double *)tmp___6;
#line 521
  i = 1;
  }
  {
#line 521
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 521
    if (! (i <= m)) {
#line 521
      goto while_break___1;
    }
    {
#line 522
    k = glp_get_bhead(lp, i);
    }
#line 524
    if (1 <= k) {
#line 524
      if (k <= m + n) {
#line 524
        tmp___7 = 1;
      } else {
        {
#line 524
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                         524);
#line 524
        tmp___7 = 1;
        }
      }
    } else {
      {
#line 524
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       524);
#line 524
      tmp___7 = 1;
      }
    }
#line 525
    if (k <= m) {
#line 525
      *(aB + i) = 0.0;
    } else {
#line 525
      *(aB + i) = *(a + (k - m));
    }
#line 521
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 528
  rho = aB;
#line 528
  glp_btran(lp, rho);
#line 530
  len = 0;
#line 531
  i = 1;
  }
  {
#line 531
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 531
    if (! (i <= m)) {
#line 531
      goto while_break___2;
    }
    {
#line 532
    tmp___8 = _glp_lpx_get_row_stat(lp, i);
    }
#line 532
    if (tmp___8 != 140) {
#line 533
      alfa = - *(rho + i);
#line 534
      if (alfa != 0.0) {
#line 535
        len ++;
#line 536
        *(ind + len) = i;
#line 537
        *(val + len) = alfa;
      }
    }
#line 531
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 542
  tmp___9 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 542
  iii = (int *)tmp___9;
#line 543
  tmp___10 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 543
  vvv = (double *)tmp___10;
#line 544
  j = 1;
  }
  {
#line 544
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 544
    if (! (j <= n)) {
#line 544
      goto while_break___3;
    }
    {
#line 545
    tmp___11 = _glp_lpx_get_col_stat(lp, j);
    }
#line 545
    if (tmp___11 != 140) {
      {
#line 546
      alfa = *(a + j);
#line 547
      lll = _glp_lpx_get_mat_col(lp, j, iii, vvv);
#line 548
      t = 1;
      }
      {
#line 548
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 548
        if (! (t <= lll)) {
#line 548
          goto while_break___4;
        }
#line 548
        alfa += *(vvv + t) * *(rho + *(iii + t));
#line 548
        t ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 549
      if (alfa != 0.0) {
#line 550
        len ++;
#line 551
        *(ind + len) = m + j;
#line 552
        *(val + len) = alfa;
      }
    }
#line 544
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 556
  if (len <= n) {
#line 556
    tmp___12 = 1;
  } else {
    {
#line 556
    _glp_lib_xassert("len <= n", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                     556);
#line 556
    tmp___12 = 1;
    }
  }
  {
#line 557
  _glp_lib_xfree((void *)iii);
#line 558
  _glp_lib_xfree((void *)vvv);
#line 559
  _glp_lib_xfree((void *)aB);
#line 560
  _glp_lib_xfree((void *)a);
  }
#line 561
  return (len);
}
}
#line 631 "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c"
int _glp_lpx_transform_col(glp_prob *lp , int len , int *ind , double *val ) 
{ 
  int i ;
  int m ;
  int t ;
  double *a ;
  double *alfa ;
  xerror_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 634
  tmp___0 = _glp_lpx_is_b_avail(lp);
  }
#line 634
  if (! tmp___0) {
    {
#line 635
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c", 635);
#line 635
    (*tmp)("lpx_transform_col: LP basis is not available\n");
    }
  }
  {
#line 636
  m = _glp_lpx_get_num_rows(lp);
#line 638
  tmp___1 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 638
  a = (double *)tmp___1;
#line 639
  i = 1;
  }
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (i <= m)) {
#line 639
      goto while_break;
    }
#line 639
    *(a + i) = 0.0;
#line 639
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  if (0 <= len) {
#line 640
    if (! (len <= m)) {
      {
#line 641
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 641);
#line 641
      (*tmp___2)("lpx_transform_col: len = %d; invalid column length\n", len);
      }
    }
  } else {
    {
#line 641
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                               641);
#line 641
    (*tmp___2)("lpx_transform_col: len = %d; invalid column length\n", len);
    }
  }
#line 643
  t = 1;
  {
#line 643
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 643
    if (! (t <= len)) {
#line 643
      goto while_break___0;
    }
#line 644
    i = *(ind + t);
#line 645
    if (1 <= i) {
#line 645
      if (! (i <= m)) {
        {
#line 646
        tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                   646);
#line 646
        (*tmp___3)("lpx_transform_col: ind[%d] = %d; row index out of range\n", t,
                   i);
        }
      }
    } else {
      {
#line 646
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 646);
#line 646
      (*tmp___3)("lpx_transform_col: ind[%d] = %d; row index out of range\n", t, i);
      }
    }
#line 648
    if (*(val + t) == 0.0) {
      {
#line 649
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 649);
#line 649
      (*tmp___4)("lpx_transform_col: val[%d] = 0; zero coefficient not allowed\n",
                 t);
      }
    }
#line 651
    if (*(a + i) != 0.0) {
      {
#line 652
      tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 652);
#line 652
      (*tmp___5)("lpx_transform_col: ind[%d] = %d; duplicate row indices not allowed\n",
                 t, i);
      }
    }
#line 654
    *(a + i) = *(val + t);
#line 643
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 657
  alfa = a;
#line 657
  glp_ftran(lp, alfa);
#line 659
  len = 0;
#line 660
  i = 1;
  }
  {
#line 660
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 660
    if (! (i <= m)) {
#line 660
      goto while_break___1;
    }
#line 661
    if (*(alfa + i) != 0.0) {
      {
#line 662
      len ++;
#line 663
      *(ind + len) = glp_get_bhead(lp, i);
#line 664
      *(val + len) = *(alfa + i);
      }
    }
#line 660
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 667
  _glp_lib_xfree((void *)a);
  }
#line 668
  return (len);
}
}
#line 733 "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c"
int _glp_lpx_prim_ratio_test(glp_prob *lp , int len , int const   *ind , double const   *val ,
                             int how , double tol ) 
{ 
  int i ;
  int k ;
  int m ;
  int n ;
  int p ;
  int t ;
  int typx ;
  int tagx ;
  double alfa_i ;
  double abs_alfa_i ;
  double big ;
  double eps ;
  double bbar_i ;
  double lb_i ;
  double ub_i ;
  double temp ;
  double teta ;
  xerror_t tmp ;
  int tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  xerror_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 738
  tmp___0 = _glp_lpx_is_b_avail(lp);
  }
#line 738
  if (! tmp___0) {
    {
#line 739
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c", 739);
#line 739
    (*tmp)("lpx_prim_ratio_test: LP basis is not available\n");
    }
  }
  {
#line 740
  tmp___2 = _glp_lpx_get_prim_stat(lp);
  }
#line 740
  if (tmp___2 != 133) {
    {
#line 741
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                               741);
#line 741
    (*tmp___1)("lpx_prim_ratio_test: current basic solution is not primal feasible\n");
    }
  }
#line 743
  if (! (how == 1)) {
#line 743
    if (! (how == -1)) {
      {
#line 744
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 744);
#line 744
      (*tmp___3)("lpx_prim_ratio_test: how = %d; invalid parameter\n", how);
      }
    }
  }
  {
#line 746
  m = _glp_lpx_get_num_rows(lp);
#line 747
  n = _glp_lpx_get_num_cols(lp);
#line 750
  big = 0.0;
#line 751
  t = 1;
  }
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (t <= len)) {
#line 751
      goto while_break;
    }
#line 752
    temp = (double )*(val + t);
#line 753
    if (temp < 0.0) {
#line 753
      temp = - temp;
    }
#line 754
    if (big < temp) {
#line 754
      big = temp;
    }
#line 751
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 758
  if (0.0 < tol) {
#line 758
    if (! (tol < 1.0)) {
      {
#line 759
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 759);
#line 759
      (*tmp___4)("lpx_prim_ratio_test: tol = %g; invalid tolerance\n", tol);
      }
    }
  } else {
    {
#line 759
    tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                               759);
#line 759
    (*tmp___4)("lpx_prim_ratio_test: tol = %g; invalid tolerance\n", tol);
    }
  }
#line 761
  eps = tol * (1.0 + big);
#line 763
  p = 0;
#line 763
  teta = 1.7976931348623157e+308;
#line 763
  big = 0.0;
#line 765
  t = 1;
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (t <= len)) {
#line 765
      goto while_break___0;
    }
#line 767
    k = (int )*(ind + t);
#line 768
    if (1 <= k) {
#line 768
      if (! (k <= m + n)) {
        {
#line 769
        tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                   769);
#line 769
        (*tmp___5)("lpx_prim_ratio_test: ind[%d] = %d; variable number out of range\n",
                   t, k);
        }
      }
    } else {
      {
#line 769
      tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 769);
#line 769
      (*tmp___5)("lpx_prim_ratio_test: ind[%d] = %d; variable number out of range\n",
                 t, k);
      }
    }
#line 771
    if (k <= m) {
      {
#line 772
      tagx = _glp_lpx_get_row_stat(lp, k);
      }
    } else {
      {
#line 774
      tagx = _glp_lpx_get_col_stat(lp, k - m);
      }
    }
#line 775
    if (tagx != 140) {
      {
#line 776
      tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 776);
#line 776
      (*tmp___6)("lpx_prim_ratio_test: ind[%d] = %d; non-basic variable not allowed\n",
                 t, k);
      }
    }
#line 779
    if (k <= m) {
      {
#line 780
      i = glp_get_row_bind(lp, k);
      }
    } else {
      {
#line 782
      i = glp_get_col_bind(lp, k - m);
      }
    }
#line 783
    if (1 <= i) {
#line 783
      if (i <= m) {
#line 783
        tmp___7 = 1;
      } else {
        {
#line 783
        _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                         783);
#line 783
        tmp___7 = 1;
        }
      }
    } else {
      {
#line 783
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       783);
#line 783
      tmp___7 = 1;
      }
    }
#line 786
    if (k <= m) {
      {
#line 787
      typx = _glp_lpx_get_row_type(lp, k);
#line 788
      lb_i = _glp_lpx_get_row_lb(lp, k);
#line 789
      ub_i = _glp_lpx_get_row_ub(lp, k);
#line 790
      bbar_i = _glp_lpx_get_row_prim(lp, k);
      }
    } else {
      {
#line 793
      typx = _glp_lpx_get_col_type(lp, k - m);
#line 794
      lb_i = _glp_lpx_get_col_lb(lp, k - m);
#line 795
      ub_i = _glp_lpx_get_col_ub(lp, k - m);
#line 796
      bbar_i = _glp_lpx_get_col_prim(lp, k - m);
      }
    }
#line 802
    if (how > 0) {
#line 802
      alfa_i = (double )*(val + t);
    } else {
#line 802
      alfa_i = (double )(- *(val + t));
    }
#line 803
    if (alfa_i > 0.0) {
#line 803
      abs_alfa_i = alfa_i;
    } else {
#line 803
      abs_alfa_i = - alfa_i;
    }
    {
#line 806
    if (typx == 110) {
#line 806
      goto case_110;
    }
#line 809
    if (typx == 111) {
#line 809
      goto lo;
    }
#line 814
    if (typx == 112) {
#line 814
      goto up;
    }
#line 819
    if (typx == 113) {
#line 819
      goto case_113;
    }
#line 822
    if (typx == 114) {
#line 822
      goto case_114;
    }
#line 827
    goto switch_default;
    case_110: /* CIL Label */ 
#line 808
    goto __Cont;
    lo: 
    case_111: /* CIL Label */ 
#line 811
    if (alfa_i > - eps) {
#line 811
      goto __Cont;
    }
#line 812
    temp = (lb_i - bbar_i) / alfa_i;
#line 813
    goto switch_break;
    up: 
    case_112: /* CIL Label */ 
#line 816
    if (alfa_i < eps) {
#line 816
      goto __Cont;
    }
#line 817
    temp = (ub_i - bbar_i) / alfa_i;
#line 818
    goto switch_break;
    case_113: /* CIL Label */ 
#line 821
    if (alfa_i < 0.0) {
#line 821
      goto lo;
    } else {
#line 821
      goto up;
    }
    case_114: /* CIL Label */ 
#line 824
    if (abs_alfa_i < eps) {
#line 824
      goto __Cont;
    }
#line 825
    temp = 0.0;
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 828
    if (typx != typx) {
#line 828
      tmp___8 = 1;
    } else {
      {
#line 828
      _glp_lib_xassert("typx != typx", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       828);
#line 828
      tmp___8 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 835
    if (temp < 0.0) {
#line 835
      temp = 0.0;
    }
#line 837
    if (teta > temp) {
#line 838
      p = k;
#line 838
      teta = temp;
#line 838
      big = abs_alfa_i;
    } else
#line 837
    if (teta == temp) {
#line 837
      if (big < abs_alfa_i) {
#line 838
        p = k;
#line 838
        teta = temp;
#line 838
        big = abs_alfa_i;
      }
    }
    __Cont: /* CIL Label */ 
#line 765
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 841
  return (p);
}
}
#line 902 "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c"
int _glp_lpx_dual_ratio_test(glp_prob *lp , int len , int const   *ind , double const   *val ,
                             int how , double tol ) 
{ 
  int k ;
  int m ;
  int n ;
  int t ;
  int q ;
  int tagx ;
  double dir ;
  double alfa_j ;
  double abs_alfa_j ;
  double big ;
  double eps ;
  double cbar_j ;
  double temp ;
  double teta ;
  xerror_t tmp ;
  int tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  xerror_t tmp___3 ;
  int tmp___5 ;
  xerror_t tmp___6 ;
  xerror_t tmp___7 ;
  xerror_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 906
  tmp___0 = _glp_lpx_is_b_avail(lp);
  }
#line 906
  if (! tmp___0) {
    {
#line 907
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c", 907);
#line 907
    (*tmp)("lpx_dual_ratio_test: LP basis is not available\n");
    }
  }
  {
#line 908
  tmp___2 = _glp_lpx_get_dual_stat(lp);
  }
#line 908
  if (tmp___2 != 137) {
    {
#line 909
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                               909);
#line 909
    (*tmp___1)("lpx_dual_ratio_test: current basic solution is not dual feasible\n");
    }
  }
#line 911
  if (! (how == 1)) {
#line 911
    if (! (how == -1)) {
      {
#line 912
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 912);
#line 912
      (*tmp___3)("lpx_dual_ratio_test: how = %d; invalid parameter\n", how);
      }
    }
  }
  {
#line 914
  m = _glp_lpx_get_num_rows(lp);
#line 915
  n = _glp_lpx_get_num_cols(lp);
#line 916
  tmp___5 = _glp_lpx_get_obj_dir(lp);
  }
#line 916
  if (tmp___5 == 120) {
#line 916
    dir = 1.0;
  } else {
#line 916
    dir = - 1.0;
  }
#line 919
  big = 0.0;
#line 920
  t = 1;
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 920
    if (! (t <= len)) {
#line 920
      goto while_break;
    }
#line 921
    temp = (double )*(val + t);
#line 922
    if (temp < 0.0) {
#line 922
      temp = - temp;
    }
#line 923
    if (big < temp) {
#line 923
      big = temp;
    }
#line 920
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 927
  if (0.0 < tol) {
#line 927
    if (! (tol < 1.0)) {
      {
#line 928
      tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 928);
#line 928
      (*tmp___6)("lpx_dual_ratio_test: tol = %g; invalid tolerance\n", tol);
      }
    }
  } else {
    {
#line 928
    tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                               928);
#line 928
    (*tmp___6)("lpx_dual_ratio_test: tol = %g; invalid tolerance\n", tol);
    }
  }
#line 930
  eps = tol * (1.0 + big);
#line 932
  q = 0;
#line 932
  teta = 1.7976931348623157e+308;
#line 932
  big = 0.0;
#line 934
  t = 1;
  {
#line 934
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 934
    if (! (t <= len)) {
#line 934
      goto while_break___0;
    }
#line 936
    k = (int )*(ind + t);
#line 937
    if (1 <= k) {
#line 937
      if (! (k <= m + n)) {
        {
#line 938
        tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                   938);
#line 938
        (*tmp___7)("lpx_dual_ratio_test: ind[%d] = %d; variable number out of range\n",
                   t, k);
        }
      }
    } else {
      {
#line 938
      tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 938);
#line 938
      (*tmp___7)("lpx_dual_ratio_test: ind[%d] = %d; variable number out of range\n",
                 t, k);
      }
    }
#line 940
    if (k <= m) {
      {
#line 941
      tagx = _glp_lpx_get_row_stat(lp, k);
      }
    } else {
      {
#line 943
      tagx = _glp_lpx_get_col_stat(lp, k - m);
      }
    }
#line 944
    if (tagx == 140) {
      {
#line 945
      tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                                 945);
#line 945
      (*tmp___8)("lpx_dual_ratio_test: ind[%d] = %d; basic variable not allowed\n",
                 t, k);
      }
    }
#line 949
    if (k <= m) {
      {
#line 950
      cbar_j = _glp_lpx_get_row_dual(lp, k);
      }
    } else {
      {
#line 952
      cbar_j = _glp_lpx_get_col_dual(lp, k - m);
      }
    }
#line 957
    if (how > 0) {
#line 957
      alfa_j = (double )*(val + t);
    } else {
#line 957
      alfa_j = (double )(- *(val + t));
    }
#line 958
    if (alfa_j > 0.0) {
#line 958
      abs_alfa_j = alfa_j;
    } else {
#line 958
      abs_alfa_j = - alfa_j;
    }
    {
#line 961
    if (tagx == 141) {
#line 961
      goto case_141;
    }
#line 966
    if (tagx == 142) {
#line 966
      goto case_142;
    }
#line 971
    if (tagx == 143) {
#line 971
      goto case_143;
    }
#line 976
    if (tagx == 144) {
#line 976
      goto case_144;
    }
#line 979
    goto switch_default;
    case_141: /* CIL Label */ 
#line 963
    if (alfa_j < eps) {
#line 963
      goto __Cont;
    }
#line 964
    temp = (dir * cbar_j) / alfa_j;
#line 965
    goto switch_break;
    case_142: /* CIL Label */ 
#line 968
    if (alfa_j > - eps) {
#line 968
      goto __Cont;
    }
#line 969
    temp = (dir * cbar_j) / alfa_j;
#line 970
    goto switch_break;
    case_143: /* CIL Label */ 
#line 973
    if (abs_alfa_j < eps) {
#line 973
      goto __Cont;
    }
#line 974
    temp = 0.0;
#line 975
    goto switch_break;
    case_144: /* CIL Label */ 
#line 978
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 980
    if (tagx != tagx) {
#line 980
      tmp___9 = 1;
    } else {
      {
#line 980
      _glp_lib_xassert("tagx != tagx", "/home/wslee/benchmarks/glpk-4.38/src/glplpx03.c",
                       980);
#line 980
      tmp___9 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 987
    if (temp < 0.0) {
#line 987
      temp = 0.0;
    }
#line 989
    if (teta > temp) {
#line 990
      q = k;
#line 990
      teta = temp;
#line 990
      big = abs_alfa_j;
    } else
#line 989
    if (teta == temp) {
#line 989
      if (big < abs_alfa_j) {
#line 990
        q = k;
#line 990
        teta = temp;
#line 990
        big = abs_alfa_j;
      }
    }
    __Cont: /* CIL Label */ 
#line 934
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 993
  return (q);
}
}
#line 438 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
void _glp_1px_put_mip_soln(glp_prob *lp , int i_stat , double *row_mipx , double *col_mipx ) ;
#line 45 "/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c"
void _glp_1px_order_matrix(glp_prob *lp ) 
{ 
  GLPAIJ *aij ;
  int i ;
  int j ;

  {
#line 49
  i = lp->m;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i >= 1)) {
#line 49
      goto while_break;
    }
#line 50
    (*(lp->row + i))->ptr = (GLPAIJ *)((void *)0);
#line 49
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  j = lp->n;
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 51
    if (! (j >= 1)) {
#line 51
      goto while_break___0;
    }
#line 52
    aij = (*(lp->col + j))->ptr;
    {
#line 52
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 52
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 52
        goto while_break___1;
      }
#line 53
      i = (aij->row)->i;
#line 54
      aij->r_prev = (GLPAIJ *)((void *)0);
#line 55
      aij->r_next = (*(lp->row + i))->ptr;
#line 56
      if ((unsigned long )aij->r_next != (unsigned long )((void *)0)) {
#line 56
        (aij->r_next)->r_prev = aij;
      }
#line 57
      (*(lp->row + i))->ptr = aij;
#line 52
      aij = aij->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 51
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 61
  j = lp->n;
  {
#line 61
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 61
    if (! (j >= 1)) {
#line 61
      goto while_break___2;
    }
#line 62
    (*(lp->col + j))->ptr = (GLPAIJ *)((void *)0);
#line 61
    j --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 63
  i = lp->m;
  {
#line 63
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 63
    if (! (i >= 1)) {
#line 63
      goto while_break___3;
    }
#line 64
    aij = (*(lp->row + i))->ptr;
    {
#line 64
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 64
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 64
        goto while_break___4;
      }
#line 65
      j = (aij->col)->j;
#line 66
      aij->c_prev = (GLPAIJ *)((void *)0);
#line 67
      aij->c_next = (*(lp->col + j))->ptr;
#line 68
      if ((unsigned long )aij->c_next != (unsigned long )((void *)0)) {
#line 68
        (aij->c_next)->c_prev = aij;
      }
#line 69
      (*(lp->col + j))->ptr = aij;
#line 64
      aij = aij->r_next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 63
    i --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 169 "/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c"
void _glp_1px_put_solution(glp_prob *lp , int inval , int const   *p_stat , int const   *d_stat ,
                           double const   *obj_val , int const   *r_stat , double const   *r_prim ,
                           double const   *r_dual , int const   *c_stat , double const   *c_prim ,
                           double const   *c_dual ) 
{ 
  GLPROW *row ;
  GLPCOL *col ;
  int i ;
  int j ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 177
  if (inval) {
#line 177
    lp->valid = 0;
  }
#line 179
  if ((unsigned long )p_stat != (unsigned long )((void *)0)) {
#line 180
    if (! (*p_stat == 1)) {
#line 180
      if (! (*p_stat == 2)) {
#line 180
        if (! (*p_stat == 3)) {
#line 180
          if (! (*p_stat == 4)) {
            {
#line 182
            tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c",
                                   182);
#line 182
            (*tmp)("lpx_put_solution: p_stat = %d; invalid primal status\n", *p_stat);
            }
          }
        }
      }
    }
#line 184
    lp->pbs_stat = (int )*p_stat;
  }
#line 187
  if ((unsigned long )d_stat != (unsigned long )((void *)0)) {
#line 188
    if (! (*d_stat == 1)) {
#line 188
      if (! (*d_stat == 2)) {
#line 188
        if (! (*d_stat == 3)) {
#line 188
          if (! (*d_stat == 4)) {
            {
#line 190
            tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c",
                                       190);
#line 190
            (*tmp___0)("lpx_put_solution: d_stat = %d; invalid dual status \n", *d_stat);
            }
          }
        }
      }
    }
#line 192
    lp->dbs_stat = (int )*d_stat;
  }
#line 195
  if ((unsigned long )obj_val != (unsigned long )((void *)0)) {
#line 195
    lp->obj_val = (double )*obj_val;
  }
#line 197
  i = 1;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i <= lp->m)) {
#line 197
      goto while_break;
    }
#line 198
    row = *(lp->row + i);
#line 199
    if ((unsigned long )r_stat != (unsigned long )((void *)0)) {
#line 200
      if (! (*(r_stat + i) == 1)) {
#line 200
        if (row->type == 1) {
#line 200
          if (! (*(r_stat + i) == 4)) {
#line 200
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 200
        if (row->type == 2) {
#line 200
          if (! (*(r_stat + i) == 2)) {
#line 200
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 200
        if (row->type == 3) {
#line 200
          if (! (*(r_stat + i) == 3)) {
#line 200
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 200
        if (row->type == 4) {
#line 200
          if (! (*(r_stat + i) == 2)) {
#line 200
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 200
        if (row->type == 4) {
#line 200
          if (! (*(r_stat + i) == 3)) {
#line 200
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 200
        if (row->type == 5) {
#line 200
          if (! (*(r_stat + i) == 5)) {
            {
#line 207
            tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c",
                                       207);
#line 207
            (*tmp___1)("lpx_put_solution: r_stat[%d] = %d; invalid row status\n",
                       i, *(r_stat + i));
            }
          }
        } else {
          {
#line 207
          tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c",
                                     207);
#line 207
          (*tmp___1)("lpx_put_solution: r_stat[%d] = %d; invalid row status\n", i,
                     *(r_stat + i));
          }
        }
      }
#line 209
      row->stat = (int )*(r_stat + i);
    }
#line 211
    if ((unsigned long )r_prim != (unsigned long )((void *)0)) {
#line 211
      row->prim = (double )*(r_prim + i);
    }
#line 212
    if ((unsigned long )r_dual != (unsigned long )((void *)0)) {
#line 212
      row->dual = (double )*(r_dual + i);
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  j = 1;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (j <= lp->n)) {
#line 215
      goto while_break___0;
    }
#line 216
    col = *(lp->col + j);
#line 217
    if ((unsigned long )c_stat != (unsigned long )((void *)0)) {
#line 218
      if (! (*(c_stat + j) == 1)) {
#line 218
        if (col->type == 1) {
#line 218
          if (! (*(c_stat + j) == 4)) {
#line 218
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 218
        if (col->type == 2) {
#line 218
          if (! (*(c_stat + j) == 2)) {
#line 218
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 218
        if (col->type == 3) {
#line 218
          if (! (*(c_stat + j) == 3)) {
#line 218
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 218
        if (col->type == 4) {
#line 218
          if (! (*(c_stat + j) == 2)) {
#line 218
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 218
        if (col->type == 4) {
#line 218
          if (! (*(c_stat + j) == 3)) {
#line 218
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 218
        if (col->type == 5) {
#line 218
          if (! (*(c_stat + j) == 5)) {
            {
#line 225
            tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c",
                                       225);
#line 225
            (*tmp___2)("lpx_put_solution: c_stat[%d] = %d; invalid column status\n",
                       j, *(c_stat + j));
            }
          }
        } else {
          {
#line 225
          tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c",
                                     225);
#line 225
          (*tmp___2)("lpx_put_solution: c_stat[%d] = %d; invalid column status\n",
                     j, *(c_stat + j));
          }
        }
      }
#line 227
      col->stat = (int )*(c_stat + j);
    }
#line 229
    if ((unsigned long )c_prim != (unsigned long )((void *)0)) {
#line 229
      col->prim = (double )*(c_prim + j);
    }
#line 230
    if ((unsigned long )c_dual != (unsigned long )((void *)0)) {
#line 230
      col->dual = (double )*(c_dual + j);
    }
#line 215
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  return;
}
}
#line 251 "/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c"
void _glp_1px_put_mip_soln(glp_prob *lp , int i_stat , double *row_mipx , double *col_mipx ) 
{ 
  GLPROW *row ;
  GLPCOL *col ;
  int i ;
  int j ;
  double sum ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 266
  if (i_stat == 170) {
#line 266
    goto case_170;
  }
#line 268
  if (i_stat == 171) {
#line 268
    goto case_171;
  }
#line 270
  if (i_stat == 172) {
#line 270
    goto case_172;
  }
#line 272
  if (i_stat == 173) {
#line 272
    goto case_173;
  }
#line 274
  goto switch_default;
  case_170: /* CIL Label */ 
#line 267
  lp->mip_stat = 1;
#line 267
  goto switch_break;
  case_171: /* CIL Label */ 
#line 269
  lp->mip_stat = 5;
#line 269
  goto switch_break;
  case_172: /* CIL Label */ 
#line 271
  lp->mip_stat = 2;
#line 271
  goto switch_break;
  case_173: /* CIL Label */ 
#line 273
  lp->mip_stat = 4;
#line 273
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 275
  tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c", 275);
#line 275
  (*tmp)("lpx_put_mip_soln: i_stat = %d; invalid mixed integer status\n", i_stat);
  }
  switch_break: /* CIL Label */ ;
  }
#line 280
  if ((unsigned long )row_mipx != (unsigned long )((void *)0)) {
#line 281
    i = 1;
    {
#line 281
    while (1) {
      while_continue: /* CIL Label */ ;
#line 281
      if (! (i <= lp->m)) {
#line 281
        goto while_break;
      }
#line 282
      row = *(lp->row + i);
#line 283
      row->mipx = *(row_mipx + i);
#line 281
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 287
  if ((unsigned long )col_mipx != (unsigned long )((void *)0)) {
#line 288
    j = 1;
    {
#line 288
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 288
      if (! (j <= lp->n)) {
#line 288
        goto while_break___0;
      }
#line 289
      col = *(lp->col + j);
#line 290
      col->mipx = *(col_mipx + j);
#line 288
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 294
  if (lp->mip_stat == 5) {
#line 294
    goto _L;
  } else
#line 294
  if (lp->mip_stat == 2) {
    _L: /* CIL Label */ 
#line 295
    j = 1;
    {
#line 295
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 295
      if (! (j <= lp->n)) {
#line 295
        goto while_break___1;
      }
#line 296
      col = *(lp->col + j);
#line 297
      if (col->kind == 2) {
        {
#line 297
        tmp___1 = floor(col->mipx);
        }
#line 297
        if (col->mipx != tmp___1) {
          {
#line 298
          tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx02.c",
                                     298);
#line 298
          (*tmp___0)("lpx_put_mip_soln: col_mipx[%d] = %.*g; must be integral\n",
                     j, 15, col->mipx);
          }
        }
      }
#line 295
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 303
  sum = lp->c0;
#line 304
  j = 1;
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 304
    if (! (j <= lp->n)) {
#line 304
      goto while_break___2;
    }
#line 305
    col = *(lp->col + j);
#line 306
    sum += col->coef * col->mipx;
#line 304
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 308
  lp->mip_obj = sum;
#line 309
  return;
}
}
#line 282 "./../include/glpk.h"
glp_prob *glp_create_prob(void) ;
#line 317
void glp_set_mat_row(glp_prob *lp , int i , int len , int const   *ind , double const   *val ) ;
#line 325
void glp_load_matrix(glp_prob *lp , int ne , int const   *ia , int const   *ja , double const   *ar ) ;
#line 329
void glp_del_rows(glp_prob *lp , int nrs , int const   *num ) ;
#line 332
void glp_del_cols(glp_prob *lp , int ncs , int const   *num ) ;
#line 341
void glp_delete_prob(glp_prob *lp ) ;
#line 344
char const   *glp_get_prob_name(glp_prob *lp ) ;
#line 347
char const   *glp_get_obj_name(glp_prob *lp ) ;
#line 359
char const   *glp_get_row_name(glp_prob *lp , int i ) ;
#line 374
int glp_get_col_type(glp_prob *lp , int j ) ;
#line 377
double glp_get_col_lb(glp_prob *lp , int j ) ;
#line 380
double glp_get_col_ub(glp_prob *lp , int j ) ;
#line 386
int glp_get_num_nz(glp_prob *lp ) ;
#line 392
extern int glp_get_mat_col(glp_prob *P , int j , int *ind , double *val ) ;
#line 419
void glp_scale_prob(glp_prob *lp , int flags ) ;
#line 425
void glp_set_row_stat(glp_prob *lp , int i , int stat ) ;
#line 428
void glp_set_col_stat(glp_prob *lp , int j , int stat ) ;
#line 431
void glp_std_basis(glp_prob *lp ) ;
#line 434
void glp_adv_basis(glp_prob *lp , int flags ) ;
#line 437
void glp_cpx_basis(glp_prob *lp ) ;
#line 440
int glp_simplex(glp_prob *lp , glp_smcp const   *parm ) ;
#line 443
int glp_exact(glp_prob *lp , glp_smcp const   *parm ) ;
#line 446
void glp_init_smcp(glp_smcp *parm ) ;
#line 449
int glp_get_status(glp_prob *lp ) ;
#line 452
int glp_get_prim_stat(glp_prob *lp ) ;
#line 455
int glp_get_dual_stat(glp_prob *lp ) ;
#line 458
double glp_get_obj_val(glp_prob *lp ) ;
#line 461
extern int glp_get_row_stat(glp_prob *P , int i ) ;
#line 464
double glp_get_row_prim(glp_prob *lp , int i ) ;
#line 467
double glp_get_row_dual(glp_prob *lp , int i ) ;
#line 470
extern int glp_get_col_stat(glp_prob *P , int j ) ;
#line 473
double glp_get_col_prim(glp_prob *lp , int j ) ;
#line 476
double glp_get_col_dual(glp_prob *lp , int j ) ;
#line 479
int glp_get_unbnd_ray(glp_prob *lp ) ;
#line 482
int glp_interior(glp_prob *P , glp_iptcp const   *parm ) ;
#line 488
int glp_ipt_status(glp_prob *lp ) ;
#line 491
double glp_ipt_obj_val(glp_prob *lp ) ;
#line 494
double glp_ipt_row_prim(glp_prob *lp , int i ) ;
#line 497
double glp_ipt_row_dual(glp_prob *lp , int i ) ;
#line 500
double glp_ipt_col_prim(glp_prob *lp , int j ) ;
#line 503
double glp_ipt_col_dual(glp_prob *lp , int j ) ;
#line 509
int glp_get_col_kind(glp_prob *mip , int j ) ;
#line 518
extern int glp_intopt(glp_prob *P , glp_iocp const   *parm ) ;
#line 521
extern void glp_init_iocp(glp_iocp *parm ) ;
#line 524
int glp_mip_status(glp_prob *mip ) ;
#line 527
double glp_mip_obj_val(glp_prob *mip ) ;
#line 530
double glp_mip_row_val(glp_prob *mip , int i ) ;
#line 533
double glp_mip_col_val(glp_prob *mip , int j ) ;
#line 536
int glp_print_sol(glp_prob *P , char const   *fname ) ;
#line 545
int glp_print_ipt(glp_prob *P , char const   *fname ) ;
#line 554
int glp_print_mip(glp_prob *P , char const   *fname ) ;
#line 563
extern int glp_bf_exists(glp_prob *P ) ;
#line 572
extern void glp_get_bfcp(glp_prob *P , glp_bfcp *parm ) ;
#line 575
extern void glp_set_bfcp(glp_prob *P , glp_bfcp const   *parm ) ;
#line 593
extern int glp_eval_tab_row(glp_prob *P , int k , int *ind , double *val ) ;
#line 596
extern int glp_eval_tab_col(glp_prob *P , int k , int *ind , double *val ) ;
#line 679
int glp_read_lp(glp_prob *lp , void const   *parm , char const   *fname ) ;
#line 682
int glp_write_lp(glp_prob *lp , void const   *parm , char const   *fname ) ;
#line 685
extern glp_tran *glp_mpl_alloc_wksp(void) ;
#line 688
extern int glp_mpl_read_model(glp_tran *tran , char const   *fname , int skip ) ;
#line 691
extern int glp_mpl_read_data(glp_tran *tran , char const   *fname ) ;
#line 694
extern int glp_mpl_generate(glp_tran *tran , char const   *fname ) ;
#line 697
extern void glp_mpl_build_prob(glp_tran *tran , glp_prob *prob ) ;
#line 703
extern void glp_mpl_free_wksp(glp_tran *tran ) ;
#line 706
int glp_main(int argc , char const   **argv ) ;
#line 1114
glp_prob *_glp_lpx_create_prob(void) ;
#line 1118
void _glp_lpx_set_prob_name(glp_prob *lp , char const   *name ) ;
#line 1122
void _glp_lpx_set_obj_name(glp_prob *lp , char const   *name ) ;
#line 1126
void _glp_lpx_set_obj_dir(glp_prob *lp , int dir ) ;
#line 1130
int _glp_lpx_add_rows(glp_prob *lp , int nrs ) ;
#line 1134
int _glp_lpx_add_cols(glp_prob *lp , int ncs ) ;
#line 1138
void _glp_lpx_set_row_name(glp_prob *lp , int i , char const   *name ) ;
#line 1142
void _glp_lpx_set_col_name(glp_prob *lp , int j , char const   *name ) ;
#line 1146
void _glp_lpx_set_row_bnds(glp_prob *lp , int i , int type , double lb , double ub ) ;
#line 1150
void _glp_lpx_set_col_bnds(glp_prob *lp , int j , int type , double lb , double ub ) ;
#line 1154
void _glp_lpx_set_obj_coef(glp_prob *lp , int j , double coef ) ;
#line 1158
void _glp_lpx_set_mat_row(glp_prob *lp , int i , int len , int const   *ind , double const   *val ) ;
#line 1163
void _glp_lpx_set_mat_col(glp_prob *lp , int j , int len , int const   *ind , double const   *val ) ;
#line 1168
void _glp_lpx_load_matrix(glp_prob *lp , int ne , int const   *ia , int const   *ja ,
                          double const   *ar ) ;
#line 1173
void _glp_lpx_del_rows(glp_prob *lp , int nrs , int const   *num ) ;
#line 1177
void _glp_lpx_del_cols(glp_prob *lp , int ncs , int const   *num ) ;
#line 1189
char const   *_glp_lpx_get_obj_name(glp_prob *lp ) ;
#line 1255
int _glp_lpx_get_mat_row(glp_prob *lp , int i , int *ind , double *val ) ;
#line 1263
void _glp_lpx_create_index(glp_prob *lp ) ;
#line 1267
int _glp_lpx_find_row(glp_prob *lp , char const   *name ) ;
#line 1271
int _glp_lpx_find_col(glp_prob *lp , char const   *name ) ;
#line 1275
void _glp_lpx_delete_index(glp_prob *lp ) ;
#line 1279
void _glp_lpx_scale_prob(glp_prob *lp ) ;
#line 1283
void _glp_lpx_unscale_prob(glp_prob *lp ) ;
#line 1287
void _glp_lpx_set_row_stat(glp_prob *lp , int i , int stat ) ;
#line 1291
void _glp_lpx_set_col_stat(glp_prob *lp , int j , int stat ) ;
#line 1295
void _glp_lpx_std_basis(glp_prob *lp ) ;
#line 1299
void _glp_lpx_adv_basis(glp_prob *lp ) ;
#line 1303
void _glp_lpx_cpx_basis(glp_prob *lp ) ;
#line 1307
int _glp_lpx_simplex(glp_prob *lp ) ;
#line 1311
int _glp_lpx_exact(glp_prob *lp ) ;
#line 1327
double _glp_lpx_get_obj_val(glp_prob *lp ) ;
#line 1365
int _glp_lpx_get_ray_info(glp_prob *lp ) ;
#line 1369
void _glp_lpx_check_kkt(glp_prob *lp , int scaled , LPXKKT *kkt ) ;
#line 1403
int _glp_lpx_interior(glp_prob *lp ) ;
#line 1407
int _glp_lpx_ipt_status(glp_prob *lp ) ;
#line 1411
double _glp_lpx_ipt_obj_val(glp_prob *lp ) ;
#line 1415
double _glp_lpx_ipt_row_prim(glp_prob *lp , int i ) ;
#line 1419
double _glp_lpx_ipt_row_dual(glp_prob *lp , int i ) ;
#line 1423
double _glp_lpx_ipt_col_prim(glp_prob *lp , int j ) ;
#line 1427
double _glp_lpx_ipt_col_dual(glp_prob *lp , int j ) ;
#line 1431
void _glp_lpx_set_class(glp_prob *lp , int klass ) ;
#line 1435
int _glp_lpx_get_class(glp_prob *lp ) ;
#line 1439
void _glp_lpx_set_col_kind(glp_prob *lp , int j , int kind ) ;
#line 1443
int _glp_lpx_get_col_kind(glp_prob *lp , int j ) ;
#line 1447
int _glp_lpx_get_num_int(glp_prob *lp ) ;
#line 1451
int _glp_lpx_get_num_bin(glp_prob *lp ) ;
#line 1455
int _glp_lpx_integer(glp_prob *lp ) ;
#line 1459
int _glp_lpx_intopt(glp_prob *lp ) ;
#line 1463
int _glp_lpx_mip_status(glp_prob *lp ) ;
#line 1467
double _glp_lpx_mip_obj_val(glp_prob *lp ) ;
#line 1471
double _glp_lpx_mip_row_val(glp_prob *lp , int i ) ;
#line 1475
double _glp_lpx_mip_col_val(glp_prob *lp , int j ) ;
#line 1479
void _glp_lpx_check_int(glp_prob *lp , LPXKKT *kkt ) ;
#line 1483
void _glp_lpx_reset_parms(glp_prob *lp ) ;
#line 1495
void _glp_lpx_set_real_parm(glp_prob *lp , int parm , double val ) ;
#line 1503
glp_prob *_glp_lpx_read_mps(char const   *fname ) ;
#line 1507
int _glp_lpx_write_mps(glp_prob *lp , char const   *fname ) ;
#line 1511
int _glp_lpx_read_bas(glp_prob *lp , char const   *fname ) ;
#line 1515
int _glp_lpx_write_bas(glp_prob *lp , char const   *fname ) ;
#line 1519
glp_prob *_glp_lpx_read_freemps(char const   *fname ) ;
#line 1523
int _glp_lpx_write_freemps(glp_prob *lp , char const   *fname ) ;
#line 1527
glp_prob *_glp_lpx_read_cpxlp(char const   *fname ) ;
#line 1531
int _glp_lpx_write_cpxlp(glp_prob *lp , char const   *fname ) ;
#line 1535
glp_prob *_glp_lpx_read_model(char const   *model , char const   *data , char const   *output___0 ) ;
#line 1540
int _glp_lpx_print_prob(glp_prob *lp , char const   *fname ) ;
#line 1544
int _glp_lpx_print_sol(glp_prob *lp , char const   *fname ) ;
#line 1552
int _glp_lpx_print_ips(glp_prob *lp , char const   *fname ) ;
#line 1556
int _glp_lpx_print_mip(glp_prob *lp , char const   *fname ) ;
#line 1569
int _glp_lpx_main(int argc , char const   **argv ) ;
#line 422 "/home/wslee/benchmarks/glpk-4.38/src/glpapi.h"
void _glp_check_kkt(glp_prob *P , int sol , int cond , double *_ae_max , int *_ae_ind ,
                    double *_re_max , int *_re_ind ) ;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
glp_prob *_glp_lpx_create_prob(void) 
{ 
  glp_prob *tmp ;

  {
  {
#line 32
  tmp = glp_create_prob();
  }
#line 32
  return (tmp);
}
}
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_prob_name(glp_prob *lp , char const   *name ) 
{ 


  {
  {
#line 37
  glp_set_prob_name(lp, name);
  }
#line 38
  return;
}
}
#line 41 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_obj_name(glp_prob *lp , char const   *name ) 
{ 


  {
  {
#line 43
  glp_set_obj_name(lp, name);
  }
#line 44
  return;
}
}
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_obj_dir(glp_prob *lp , int dir ) 
{ 


  {
  {
#line 49
  glp_set_obj_dir(lp, (dir - 120) + 1);
  }
#line 50
  return;
}
}
#line 53 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_add_rows(glp_prob *lp , int nrs ) 
{ 
  int tmp ;

  {
  {
#line 55
  tmp = glp_add_rows(lp, nrs);
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_add_cols(glp_prob *lp , int ncs ) 
{ 
  int tmp ;

  {
  {
#line 60
  tmp = glp_add_cols(lp, ncs);
  }
#line 60
  return (tmp);
}
}
#line 63 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_row_name(glp_prob *lp , int i , char const   *name ) 
{ 


  {
  {
#line 65
  glp_set_row_name(lp, i, name);
  }
#line 66
  return;
}
}
#line 69 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_col_name(glp_prob *lp , int j , char const   *name ) 
{ 


  {
  {
#line 71
  glp_set_col_name(lp, j, name);
  }
#line 72
  return;
}
}
#line 75 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_row_bnds(glp_prob *lp , int i , int type , double lb , double ub ) 
{ 


  {
  {
#line 77
  glp_set_row_bnds(lp, i, (type - 110) + 1, lb, ub);
  }
#line 78
  return;
}
}
#line 81 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_col_bnds(glp_prob *lp , int j , int type , double lb , double ub ) 
{ 


  {
  {
#line 83
  glp_set_col_bnds(lp, j, (type - 110) + 1, lb, ub);
  }
#line 84
  return;
}
}
#line 87 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_obj_coef(glp_prob *lp , int j , double coef ) 
{ 


  {
  {
#line 89
  glp_set_obj_coef(lp, j, coef);
  }
#line 90
  return;
}
}
#line 93 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_mat_row(glp_prob *lp , int i , int len , int const   *ind , double const   *val ) 
{ 


  {
  {
#line 96
  glp_set_mat_row(lp, i, len, ind, val);
  }
#line 97
  return;
}
}
#line 100 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_mat_col(glp_prob *lp , int j , int len , int const   *ind , double const   *val ) 
{ 


  {
  {
#line 103
  glp_set_mat_col(lp, j, len, ind, val);
  }
#line 104
  return;
}
}
#line 107 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_load_matrix(glp_prob *lp , int ne , int const   *ia , int const   *ja ,
                          double const   *ar ) 
{ 


  {
  {
#line 110
  glp_load_matrix(lp, ne, ia, ja, ar);
  }
#line 111
  return;
}
}
#line 114 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_del_rows(glp_prob *lp , int nrs , int const   *num ) 
{ 


  {
  {
#line 116
  glp_del_rows(lp, nrs, num);
  }
#line 117
  return;
}
}
#line 120 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_del_cols(glp_prob *lp , int ncs , int const   *num ) 
{ 


  {
  {
#line 122
  glp_del_cols(lp, ncs, num);
  }
#line 123
  return;
}
}
#line 126 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_delete_prob(glp_prob *lp ) 
{ 


  {
  {
#line 128
  glp_delete_prob(lp);
  }
#line 129
  return;
}
}
#line 132 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
char const   *_glp_lpx_get_prob_name(glp_prob *lp ) 
{ 
  char const   *tmp ;

  {
  {
#line 134
  tmp = glp_get_prob_name(lp);
  }
#line 134
  return (tmp);
}
}
#line 137 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
char const   *_glp_lpx_get_obj_name(glp_prob *lp ) 
{ 
  char const   *tmp ;

  {
  {
#line 139
  tmp = glp_get_obj_name(lp);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_obj_dir(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 144
  tmp = glp_get_obj_dir(lp);
  }
#line 144
  return ((tmp - 1) + 120);
}
}
#line 147 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_num_rows(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 149
  tmp = glp_get_num_rows(lp);
  }
#line 149
  return (tmp);
}
}
#line 152 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_num_cols(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 154
  tmp = glp_get_num_cols(lp);
  }
#line 154
  return (tmp);
}
}
#line 157 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
char const   *_glp_lpx_get_row_name(glp_prob *lp , int i ) 
{ 
  char const   *tmp ;

  {
  {
#line 159
  tmp = glp_get_row_name(lp, i);
  }
#line 159
  return (tmp);
}
}
#line 162 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
char const   *_glp_lpx_get_col_name(glp_prob *lp , int j ) 
{ 
  char const   *tmp ;

  {
  {
#line 164
  tmp = glp_get_col_name(lp, j);
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_row_type(glp_prob *lp , int i ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = glp_get_row_type(lp, i);
  }
#line 169
  return ((tmp - 1) + 110);
}
}
#line 172 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_row_lb(glp_prob *lp , int i ) 
{ 
  double lb ;

  {
  {
#line 175
  lb = glp_get_row_lb(lp, i);
  }
#line 176
  if (lb == - 1.7976931348623157e+308) {
#line 176
    lb = 0.0;
  }
#line 177
  return (lb);
}
}
#line 180 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_row_ub(glp_prob *lp , int i ) 
{ 
  double ub ;

  {
  {
#line 183
  ub = glp_get_row_ub(lp, i);
  }
#line 184
  if (ub == 1.7976931348623157e+308) {
#line 184
    ub = 0.0;
  }
#line 185
  return (ub);
}
}
#line 188 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_get_row_bnds(glp_prob *lp , int i , int *typx , double *lb , double *ub ) 
{ 


  {
#line 191
  if ((unsigned long )typx != (unsigned long )((void *)0)) {
    {
#line 191
    *typx = _glp_lpx_get_row_type(lp, i);
    }
  }
#line 192
  if ((unsigned long )lb != (unsigned long )((void *)0)) {
    {
#line 192
    *lb = _glp_lpx_get_row_lb(lp, i);
    }
  }
#line 193
  if ((unsigned long )ub != (unsigned long )((void *)0)) {
    {
#line 193
    *ub = _glp_lpx_get_row_ub(lp, i);
    }
  }
#line 194
  return;
}
}
#line 197 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_col_type(glp_prob *lp , int j ) 
{ 
  int tmp ;

  {
  {
#line 199
  tmp = glp_get_col_type(lp, j);
  }
#line 199
  return ((tmp - 1) + 110);
}
}
#line 202 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_col_lb(glp_prob *lp , int j ) 
{ 
  double lb ;

  {
  {
#line 205
  lb = glp_get_col_lb(lp, j);
  }
#line 206
  if (lb == - 1.7976931348623157e+308) {
#line 206
    lb = 0.0;
  }
#line 207
  return (lb);
}
}
#line 210 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_col_ub(glp_prob *lp , int j ) 
{ 
  double ub ;

  {
  {
#line 213
  ub = glp_get_col_ub(lp, j);
  }
#line 214
  if (ub == 1.7976931348623157e+308) {
#line 214
    ub = 0.0;
  }
#line 215
  return (ub);
}
}
#line 218 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_get_col_bnds(glp_prob *lp , int j , int *typx , double *lb , double *ub ) 
{ 


  {
#line 221
  if ((unsigned long )typx != (unsigned long )((void *)0)) {
    {
#line 221
    *typx = _glp_lpx_get_col_type(lp, j);
    }
  }
#line 222
  if ((unsigned long )lb != (unsigned long )((void *)0)) {
    {
#line 222
    *lb = _glp_lpx_get_col_lb(lp, j);
    }
  }
#line 223
  if ((unsigned long )ub != (unsigned long )((void *)0)) {
    {
#line 223
    *ub = _glp_lpx_get_col_ub(lp, j);
    }
  }
#line 224
  return;
}
}
#line 227 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_obj_coef(glp_prob *lp , int j ) 
{ 
  double tmp ;

  {
  {
#line 229
  tmp = glp_get_obj_coef(lp, j);
  }
#line 229
  return (tmp);
}
}
#line 232 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_num_nz(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 234
  tmp = glp_get_num_nz(lp);
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_mat_row(glp_prob *lp , int i , int *ind , double *val ) 
{ 
  int tmp ;

  {
  {
#line 239
  tmp = glp_get_mat_row(lp, i, ind, val);
  }
#line 239
  return (tmp);
}
}
#line 242 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_mat_col(glp_prob *lp , int j , int *ind , double *val ) 
{ 
  int tmp ;

  {
  {
#line 244
  tmp = glp_get_mat_col(lp, j, ind, val);
  }
#line 244
  return (tmp);
}
}
#line 247 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_create_index(glp_prob *lp ) 
{ 


  {
  {
#line 249
  glp_create_index(lp);
  }
#line 250
  return;
}
}
#line 253 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_find_row(glp_prob *lp , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 255
  tmp = glp_find_row(lp, name);
  }
#line 255
  return (tmp);
}
}
#line 258 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_find_col(glp_prob *lp , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 260
  tmp = glp_find_col(lp, name);
  }
#line 260
  return (tmp);
}
}
#line 263 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_delete_index(glp_prob *lp ) 
{ 


  {
  {
#line 265
  glp_delete_index(lp);
  }
#line 266
  return;
}
}
#line 269 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_scale_prob(glp_prob *lp ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 271
  tmp = _glp_lpx_get_int_parm(lp, 301);
  }
  {
#line 272
  if (tmp == 0) {
#line 272
    goto case_0;
  }
#line 276
  if (tmp == 1) {
#line 276
    goto case_1;
  }
#line 280
  if (tmp == 2) {
#line 280
    goto case_2;
  }
#line 284
  if (tmp == 3) {
#line 284
    goto case_3;
  }
#line 288
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 274
  glp_unscale_prob(lp);
  }
#line 275
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 278
  glp_scale_prob(lp, 16);
  }
#line 279
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 282
  glp_scale_prob(lp, 1);
  }
#line 283
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 286
  glp_scale_prob(lp, 17);
  }
#line 287
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 289
  if ((unsigned long )lp != (unsigned long )lp) {
#line 289
    tmp___0 = 1;
  } else {
    {
#line 289
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     289);
#line 289
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 294 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_unscale_prob(glp_prob *lp ) 
{ 


  {
  {
#line 296
  glp_unscale_prob(lp);
  }
#line 297
  return;
}
}
#line 300 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_row_stat(glp_prob *lp , int i , int stat ) 
{ 


  {
  {
#line 302
  glp_set_row_stat(lp, i, (stat - 140) + 1);
  }
#line 303
  return;
}
}
#line 306 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_col_stat(glp_prob *lp , int j , int stat ) 
{ 


  {
  {
#line 308
  glp_set_col_stat(lp, j, (stat - 140) + 1);
  }
#line 309
  return;
}
}
#line 312 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_std_basis(glp_prob *lp ) 
{ 


  {
  {
#line 314
  glp_std_basis(lp);
  }
#line 315
  return;
}
}
#line 318 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_adv_basis(glp_prob *lp ) 
{ 


  {
  {
#line 320
  glp_adv_basis(lp, 0);
  }
#line 321
  return;
}
}
#line 324 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_cpx_basis(glp_prob *lp ) 
{ 


  {
  {
#line 326
  glp_cpx_basis(lp);
  }
#line 327
  return;
}
}
#line 330 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
static void fill_smcp(glp_prob *lp , glp_smcp *parm ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 331
  glp_init_smcp(parm);
#line 332
  tmp = _glp_lpx_get_int_parm(lp, 300);
  }
  {
#line 333
  if (tmp == 0) {
#line 333
    goto case_0;
  }
#line 334
  if (tmp == 1) {
#line 334
    goto case_1;
  }
#line 335
  if (tmp == 2) {
#line 335
    goto case_2;
  }
#line 336
  if (tmp == 3) {
#line 336
    goto case_3;
  }
#line 337
  goto switch_default;
  case_0: /* CIL Label */ 
#line 333
  parm->msg_lev = 0;
#line 333
  goto switch_break;
  case_1: /* CIL Label */ 
#line 334
  parm->msg_lev = 1;
#line 334
  goto switch_break;
  case_2: /* CIL Label */ 
#line 335
  parm->msg_lev = 2;
#line 335
  goto switch_break;
  case_3: /* CIL Label */ 
#line 336
  parm->msg_lev = 3;
#line 336
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 337
  if ((unsigned long )lp != (unsigned long )lp) {
#line 337
    tmp___0 = 1;
  } else {
    {
#line 337
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     337);
#line 337
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 339
  tmp___1 = _glp_lpx_get_int_parm(lp, 302);
  }
  {
#line 340
  if (tmp___1 == 0) {
#line 340
    goto case_0___0;
  }
#line 341
  if (tmp___1 == 1) {
#line 341
    goto case_1___0;
  }
#line 342
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 340
  parm->meth = 1;
#line 340
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 341
  parm->meth = 3;
#line 341
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 342
  if ((unsigned long )lp != (unsigned long )lp) {
#line 342
    tmp___2 = 1;
  } else {
    {
#line 342
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     342);
#line 342
    tmp___2 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 344
  tmp___3 = _glp_lpx_get_int_parm(lp, 303);
  }
  {
#line 345
  if (tmp___3 == 0) {
#line 345
    goto case_0___1;
  }
#line 346
  if (tmp___3 == 1) {
#line 346
    goto case_1___1;
  }
#line 347
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 345
  parm->pricing = 17;
#line 345
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 346
  parm->pricing = 34;
#line 346
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 347
  if ((unsigned long )lp != (unsigned long )lp) {
#line 347
    tmp___4 = 1;
  } else {
    {
#line 347
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     347);
#line 347
    tmp___4 = 1;
    }
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 349
  tmp___5 = _glp_lpx_get_real_parm(lp, 304);
  }
#line 349
  if (tmp___5 == 0.0) {
#line 350
    parm->r_test = 17;
  } else {
#line 352
    parm->r_test = 34;
  }
  {
#line 353
  parm->tol_bnd = _glp_lpx_get_real_parm(lp, 305);
#line 354
  parm->tol_dj = _glp_lpx_get_real_parm(lp, 306);
#line 355
  parm->tol_piv = _glp_lpx_get_real_parm(lp, 307);
#line 356
  parm->obj_ll = _glp_lpx_get_real_parm(lp, 309);
#line 357
  parm->obj_ul = _glp_lpx_get_real_parm(lp, 310);
#line 358
  tmp___6 = _glp_lpx_get_int_parm(lp, 311);
  }
#line 358
  if (tmp___6 < 0) {
#line 359
    parm->it_lim = 2147483647;
  } else {
    {
#line 361
    parm->it_lim = _glp_lpx_get_int_parm(lp, 311);
    }
  }
  {
#line 362
  tmp___8 = _glp_lpx_get_real_parm(lp, 313);
  }
#line 362
  if (tmp___8 < 0.0) {
#line 363
    parm->tm_lim = 2147483647;
  } else {
    {
#line 365
    tmp___7 = _glp_lpx_get_real_parm(lp, 313);
#line 365
    parm->tm_lim = (int )(1000.0 * tmp___7);
    }
  }
  {
#line 367
  parm->out_frq = _glp_lpx_get_int_parm(lp, 314);
#line 368
  tmp___9 = _glp_lpx_get_real_parm(lp, 315);
#line 368
  parm->out_dly = (int )(1000.0 * tmp___9);
#line 370
  tmp___10 = _glp_lpx_get_int_parm(lp, 327);
  }
  {
#line 371
  if (tmp___10 == 0) {
#line 371
    goto case_0___2;
  }
#line 372
  if (tmp___10 == 1) {
#line 372
    goto case_1___2;
  }
#line 373
  goto switch_default___2;
  case_0___2: /* CIL Label */ 
#line 371
  parm->presolve = 0;
#line 371
  goto switch_break___2;
  case_1___2: /* CIL Label */ 
#line 372
  parm->presolve = 1;
#line 372
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 373
  if ((unsigned long )lp != (unsigned long )lp) {
#line 373
    tmp___11 = 1;
  } else {
    {
#line 373
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     373);
#line 373
    tmp___11 = 1;
    }
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 375
  return;
}
}
#line 378 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_simplex(glp_prob *lp ) 
{ 
  glp_smcp parm ;
  int ret ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 382
  fill_smcp(lp, & parm);
#line 383
  ret = glp_simplex(lp, (glp_smcp const   *)(& parm));
  }
  {
#line 385
  if (ret == 0) {
#line 385
    goto case_0;
  }
#line 389
  if (ret == 4) {
#line 389
    goto case_4;
  }
#line 389
  if (ret == 3) {
#line 389
    goto case_4;
  }
#line 389
  if (ret == 2) {
#line 389
    goto case_4;
  }
#line 389
  if (ret == 1) {
#line 389
    goto case_4;
  }
#line 390
  if (ret == 5) {
#line 390
    goto case_5;
  }
#line 391
  if (ret == 6) {
#line 391
    goto case_6;
  }
#line 392
  if (ret == 7) {
#line 392
    goto case_7;
  }
#line 393
  if (ret == 8) {
#line 393
    goto case_8;
  }
#line 394
  if (ret == 9) {
#line 394
    goto case_9;
  }
#line 395
  if (ret == 10) {
#line 395
    goto case_10;
  }
#line 396
  if (ret == 11) {
#line 396
    goto case_11;
  }
#line 397
  goto switch_default;
  case_0: /* CIL Label */ 
#line 385
  ret = 200;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 389
  ret = 204;
#line 389
  goto switch_break;
  case_5: /* CIL Label */ 
#line 390
  ret = 211;
#line 390
  goto switch_break;
  case_6: /* CIL Label */ 
#line 391
  ret = 205;
#line 391
  goto switch_break;
  case_7: /* CIL Label */ 
#line 392
  ret = 206;
#line 392
  goto switch_break;
  case_8: /* CIL Label */ 
#line 393
  ret = 207;
#line 393
  goto switch_break;
  case_9: /* CIL Label */ 
#line 394
  ret = 208;
#line 394
  goto switch_break;
  case_10: /* CIL Label */ 
#line 395
  ret = 213;
#line 395
  goto switch_break;
  case_11: /* CIL Label */ 
#line 396
  ret = 214;
#line 396
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 397
  if (ret != ret) {
#line 397
    tmp = 1;
  } else {
    {
#line 397
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     397);
#line 397
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 399
  return (ret);
}
}
#line 402 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_exact(glp_prob *lp ) 
{ 
  glp_smcp parm ;
  int ret ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 406
  fill_smcp(lp, & parm);
#line 407
  ret = glp_exact(lp, (glp_smcp const   *)(& parm));
  }
  {
#line 409
  if (ret == 0) {
#line 409
    goto case_0;
  }
#line 413
  if (ret == 5) {
#line 413
    goto case_5;
  }
#line 413
  if (ret == 4) {
#line 413
    goto case_5;
  }
#line 413
  if (ret == 2) {
#line 413
    goto case_5;
  }
#line 413
  if (ret == 1) {
#line 413
    goto case_5;
  }
#line 414
  if (ret == 8) {
#line 414
    goto case_8;
  }
#line 415
  if (ret == 9) {
#line 415
    goto case_9;
  }
#line 416
  goto switch_default;
  case_0: /* CIL Label */ 
#line 409
  ret = 200;
#line 409
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 413
  ret = 204;
#line 413
  goto switch_break;
  case_8: /* CIL Label */ 
#line 414
  ret = 207;
#line 414
  goto switch_break;
  case_9: /* CIL Label */ 
#line 415
  ret = 208;
#line 415
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 416
  if (ret != ret) {
#line 416
    tmp = 1;
  } else {
    {
#line 416
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     416);
#line 416
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 418
  return (ret);
}
}
#line 421 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_status(glp_prob *lp ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 424
  tmp = glp_get_status(lp);
  }
  {
#line 425
  if (tmp == 5) {
#line 425
    goto case_5;
  }
#line 426
  if (tmp == 2) {
#line 426
    goto case_2;
  }
#line 427
  if (tmp == 3) {
#line 427
    goto case_3;
  }
#line 428
  if (tmp == 4) {
#line 428
    goto case_4;
  }
#line 429
  if (tmp == 6) {
#line 429
    goto case_6;
  }
#line 430
  if (tmp == 1) {
#line 430
    goto case_1;
  }
#line 431
  goto switch_default;
  case_5: /* CIL Label */ 
#line 425
  status = 180;
#line 425
  goto switch_break;
  case_2: /* CIL Label */ 
#line 426
  status = 181;
#line 426
  goto switch_break;
  case_3: /* CIL Label */ 
#line 427
  status = 182;
#line 427
  goto switch_break;
  case_4: /* CIL Label */ 
#line 428
  status = 183;
#line 428
  goto switch_break;
  case_6: /* CIL Label */ 
#line 429
  status = 184;
#line 429
  goto switch_break;
  case_1: /* CIL Label */ 
#line 430
  status = 185;
#line 430
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 431
  if ((unsigned long )lp != (unsigned long )lp) {
#line 431
    tmp___0 = 1;
  } else {
    {
#line 431
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     431);
#line 431
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 433
  return (status);
}
}
#line 436 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_prim_stat(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 438
  tmp = glp_get_prim_stat(lp);
  }
#line 438
  return ((tmp - 1) + 132);
}
}
#line 441 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_dual_stat(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 443
  tmp = glp_get_dual_stat(lp);
  }
#line 443
  return ((tmp - 1) + 136);
}
}
#line 446 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_obj_val(glp_prob *lp ) 
{ 
  double tmp ;

  {
  {
#line 448
  tmp = glp_get_obj_val(lp);
  }
#line 448
  return (tmp);
}
}
#line 451 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_row_stat(glp_prob *lp , int i ) 
{ 
  int tmp ;

  {
  {
#line 453
  tmp = glp_get_row_stat(lp, i);
  }
#line 453
  return ((tmp - 1) + 140);
}
}
#line 456 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_row_prim(glp_prob *lp , int i ) 
{ 
  double tmp ;

  {
  {
#line 458
  tmp = glp_get_row_prim(lp, i);
  }
#line 458
  return (tmp);
}
}
#line 461 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_row_dual(glp_prob *lp , int i ) 
{ 
  double tmp ;

  {
  {
#line 463
  tmp = glp_get_row_dual(lp, i);
  }
#line 463
  return (tmp);
}
}
#line 466 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_get_row_info(glp_prob *lp , int i , int *tagx , double *vx , double *dx ) 
{ 


  {
#line 469
  if ((unsigned long )tagx != (unsigned long )((void *)0)) {
    {
#line 469
    *tagx = _glp_lpx_get_row_stat(lp, i);
    }
  }
#line 470
  if ((unsigned long )vx != (unsigned long )((void *)0)) {
    {
#line 470
    *vx = _glp_lpx_get_row_prim(lp, i);
    }
  }
#line 471
  if ((unsigned long )dx != (unsigned long )((void *)0)) {
    {
#line 471
    *dx = _glp_lpx_get_row_dual(lp, i);
    }
  }
#line 472
  return;
}
}
#line 475 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_col_stat(glp_prob *lp , int j ) 
{ 
  int tmp ;

  {
  {
#line 477
  tmp = glp_get_col_stat(lp, j);
  }
#line 477
  return ((tmp - 1) + 140);
}
}
#line 480 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_col_prim(glp_prob *lp , int j ) 
{ 
  double tmp ;

  {
  {
#line 482
  tmp = glp_get_col_prim(lp, j);
  }
#line 482
  return (tmp);
}
}
#line 485 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_col_dual(glp_prob *lp , int j ) 
{ 
  double tmp ;

  {
  {
#line 487
  tmp = glp_get_col_dual(lp, j);
  }
#line 487
  return (tmp);
}
}
#line 490 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_get_col_info(glp_prob *lp , int j , int *tagx , double *vx , double *dx ) 
{ 


  {
#line 493
  if ((unsigned long )tagx != (unsigned long )((void *)0)) {
    {
#line 493
    *tagx = _glp_lpx_get_col_stat(lp, j);
    }
  }
#line 494
  if ((unsigned long )vx != (unsigned long )((void *)0)) {
    {
#line 494
    *vx = _glp_lpx_get_col_prim(lp, j);
    }
  }
#line 495
  if ((unsigned long )dx != (unsigned long )((void *)0)) {
    {
#line 495
    *dx = _glp_lpx_get_col_dual(lp, j);
    }
  }
#line 496
  return;
}
}
#line 499 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_ray_info(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 501
  tmp = glp_get_unbnd_ray(lp);
  }
#line 501
  return (tmp);
}
}
#line 504 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_check_kkt(glp_prob *lp , int scaled , LPXKKT *kkt ) 
{ 
  int ae_ind ;
  int re_ind ;
  double ae_max ;
  double re_max ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 508
  if (scaled == scaled) {
#line 508
    tmp = 1;
  } else {
    {
#line 508
    _glp_lib_xassert("scaled == scaled", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     508);
#line 508
    tmp = 1;
    }
  }
  {
#line 509
  _glp_check_kkt(lp, 1, 1, & ae_max, & ae_ind, & re_max, & re_ind);
#line 511
  kkt->pe_ae_max = ae_max;
#line 512
  kkt->pe_ae_row = ae_ind;
#line 513
  kkt->pe_re_max = re_max;
#line 514
  kkt->pe_re_row = re_ind;
  }
#line 515
  if (re_max <= 1e-9) {
#line 516
    kkt->pe_quality = 'H';
  } else
#line 517
  if (re_max <= 1e-6) {
#line 518
    kkt->pe_quality = 'M';
  } else
#line 519
  if (re_max <= 1e-3) {
#line 520
    kkt->pe_quality = 'L';
  } else {
#line 522
    kkt->pe_quality = '?';
  }
  {
#line 523
  _glp_check_kkt(lp, 1, 2, & ae_max, & ae_ind, & re_max, & re_ind);
#line 525
  kkt->pb_ae_max = ae_max;
#line 526
  kkt->pb_ae_ind = ae_ind;
#line 527
  kkt->pb_re_max = re_max;
#line 528
  kkt->pb_re_ind = re_ind;
  }
#line 529
  if (re_max <= 1e-9) {
#line 530
    kkt->pb_quality = 'H';
  } else
#line 531
  if (re_max <= 1e-6) {
#line 532
    kkt->pb_quality = 'M';
  } else
#line 533
  if (re_max <= 1e-3) {
#line 534
    kkt->pb_quality = 'L';
  } else {
#line 536
    kkt->pb_quality = '?';
  }
  {
#line 537
  _glp_check_kkt(lp, 1, 3, & ae_max, & ae_ind, & re_max, & re_ind);
#line 539
  kkt->de_ae_max = ae_max;
  }
#line 540
  if (ae_ind == 0) {
#line 541
    kkt->de_ae_col = 0;
  } else {
#line 543
    kkt->de_ae_col = ae_ind - lp->m;
  }
#line 544
  kkt->de_re_max = re_max;
#line 545
  if (re_ind == 0) {
#line 546
    kkt->de_re_col = 0;
  } else {
#line 548
    kkt->de_re_col = ae_ind - lp->m;
  }
#line 549
  if (re_max <= 1e-9) {
#line 550
    kkt->de_quality = 'H';
  } else
#line 551
  if (re_max <= 1e-6) {
#line 552
    kkt->de_quality = 'M';
  } else
#line 553
  if (re_max <= 1e-3) {
#line 554
    kkt->de_quality = 'L';
  } else {
#line 556
    kkt->de_quality = '?';
  }
  {
#line 557
  _glp_check_kkt(lp, 1, 4, & ae_max, & ae_ind, & re_max, & re_ind);
#line 559
  kkt->db_ae_max = ae_max;
#line 560
  kkt->db_ae_ind = ae_ind;
#line 561
  kkt->db_re_max = re_max;
#line 562
  kkt->db_re_ind = re_ind;
  }
#line 563
  if (re_max <= 1e-9) {
#line 564
    kkt->db_quality = 'H';
  } else
#line 565
  if (re_max <= 1e-6) {
#line 566
    kkt->db_quality = 'M';
  } else
#line 567
  if (re_max <= 1e-3) {
#line 568
    kkt->db_quality = 'L';
  } else {
#line 570
    kkt->db_quality = '?';
  }
#line 571
  kkt->cs_ae_max = 0.0;
#line 571
  kkt->cs_ae_ind = 0;
#line 572
  kkt->cs_re_max = 0.0;
#line 572
  kkt->cs_re_ind = 0;
#line 573
  kkt->cs_quality = 'H';
#line 574
  return;
}
}
#line 577 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_eval_tab_row(glp_prob *lp , int k , int *ind , double *val ) 
{ 
  int tmp ;

  {
  {
#line 579
  tmp = glp_eval_tab_row(lp, k, ind, val);
  }
#line 579
  return (tmp);
}
}
#line 582 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_eval_tab_col(glp_prob *lp , int k , int *ind , double *val ) 
{ 
  int tmp ;

  {
  {
#line 584
  tmp = glp_eval_tab_col(lp, k, ind, val);
  }
#line 584
  return (tmp);
}
}
#line 587 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_interior(glp_prob *lp ) 
{ 
  int ret ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 590
  ret = glp_interior(lp, (glp_iptcp const   *)((void *)0));
  }
  {
#line 592
  if (ret == 0) {
#line 592
    goto case_0;
  }
#line 593
  if (ret == 5) {
#line 593
    goto case_5;
  }
#line 594
  if (ret == 15) {
#line 594
    goto case_15;
  }
#line 595
  if (ret == 16) {
#line 595
    goto case_16;
  }
#line 596
  if (ret == 8) {
#line 596
    goto case_8;
  }
#line 597
  if (ret == 17) {
#line 597
    goto case_17;
  }
#line 598
  goto switch_default;
  case_0: /* CIL Label */ 
#line 592
  ret = 200;
#line 592
  goto switch_break;
  case_5: /* CIL Label */ 
#line 593
  ret = 204;
#line 593
  goto switch_break;
  case_15: /* CIL Label */ 
#line 594
  ret = 209;
#line 594
  goto switch_break;
  case_16: /* CIL Label */ 
#line 595
  ret = 212;
#line 595
  goto switch_break;
  case_8: /* CIL Label */ 
#line 596
  ret = 207;
#line 596
  goto switch_break;
  case_17: /* CIL Label */ 
#line 597
  ret = 210;
#line 597
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 598
  if (ret != ret) {
#line 598
    tmp = 1;
  } else {
    {
#line 598
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     598);
#line 598
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 600
  return (ret);
}
}
#line 603 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_ipt_status(glp_prob *lp ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 606
  tmp = glp_ipt_status(lp);
  }
  {
#line 607
  if (tmp == 1) {
#line 607
    goto case_1;
  }
#line 608
  if (tmp == 5) {
#line 608
    goto case_5;
  }
#line 609
  goto switch_default;
  case_1: /* CIL Label */ 
#line 607
  status = 150;
#line 607
  goto switch_break;
  case_5: /* CIL Label */ 
#line 608
  status = 151;
#line 608
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 609
  if ((unsigned long )lp != (unsigned long )lp) {
#line 609
    tmp___0 = 1;
  } else {
    {
#line 609
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     609);
#line 609
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 611
  return (status);
}
}
#line 614 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_ipt_obj_val(glp_prob *lp ) 
{ 
  double tmp ;

  {
  {
#line 616
  tmp = glp_ipt_obj_val(lp);
  }
#line 616
  return (tmp);
}
}
#line 619 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_ipt_row_prim(glp_prob *lp , int i ) 
{ 
  double tmp ;

  {
  {
#line 621
  tmp = glp_ipt_row_prim(lp, i);
  }
#line 621
  return (tmp);
}
}
#line 624 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_ipt_row_dual(glp_prob *lp , int i ) 
{ 
  double tmp ;

  {
  {
#line 626
  tmp = glp_ipt_row_dual(lp, i);
  }
#line 626
  return (tmp);
}
}
#line 629 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_ipt_col_prim(glp_prob *lp , int j ) 
{ 
  double tmp ;

  {
  {
#line 631
  tmp = glp_ipt_col_prim(lp, j);
  }
#line 631
  return (tmp);
}
}
#line 634 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_ipt_col_dual(glp_prob *lp , int j ) 
{ 
  double tmp ;

  {
  {
#line 636
  tmp = glp_ipt_col_dual(lp, j);
  }
#line 636
  return (tmp);
}
}
#line 639 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_class(glp_prob *lp , int klass ) 
{ 
  int tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 641
  if ((unsigned long )lp == (unsigned long )lp) {
#line 641
    tmp = 1;
  } else {
    {
#line 641
    _glp_lib_xassert("lp == lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     641);
#line 641
    tmp = 1;
    }
  }
#line 642
  if (! (klass == 100)) {
#line 642
    if (! (klass == 101)) {
      {
#line 643
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 643);
#line 643
      (*tmp___0)("lpx_set_class: invalid problem class\n");
      }
    }
  }
#line 644
  return;
}
}
#line 647 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_class(glp_prob *lp ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 649
  tmp___1 = glp_get_num_int(lp);
  }
#line 649
  if (tmp___1 == 0) {
#line 649
    tmp___0 = 100;
  } else {
#line 649
    tmp___0 = 101;
  }
#line 649
  return (tmp___0);
}
}
#line 652 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_col_kind(glp_prob *lp , int j , int kind ) 
{ 


  {
  {
#line 654
  glp_set_col_kind(lp, j, (kind - 160) + 1);
  }
#line 655
  return;
}
}
#line 658 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_col_kind(glp_prob *lp , int j ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 660
  tmp___1 = glp_get_col_kind(lp, j);
  }
#line 660
  if (tmp___1 == 1) {
#line 660
    tmp___0 = 160;
  } else {
#line 660
    tmp___0 = 161;
  }
#line 660
  return (tmp___0);
}
}
#line 663 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_num_int(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 665
  tmp = glp_get_num_int(lp);
  }
#line 665
  return (tmp);
}
}
#line 668 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_num_bin(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 670
  tmp = glp_get_num_bin(lp);
  }
#line 670
  return (tmp);
}
}
#line 673 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
static int solve_mip(glp_prob *lp , int presolve ) 
{ 
  glp_iocp parm ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 676
  glp_init_iocp(& parm);
#line 677
  tmp = _glp_lpx_get_int_parm(lp, 300);
  }
  {
#line 678
  if (tmp == 0) {
#line 678
    goto case_0;
  }
#line 679
  if (tmp == 1) {
#line 679
    goto case_1;
  }
#line 680
  if (tmp == 2) {
#line 680
    goto case_2;
  }
#line 681
  if (tmp == 3) {
#line 681
    goto case_3;
  }
#line 682
  goto switch_default;
  case_0: /* CIL Label */ 
#line 678
  parm.msg_lev = 0;
#line 678
  goto switch_break;
  case_1: /* CIL Label */ 
#line 679
  parm.msg_lev = 1;
#line 679
  goto switch_break;
  case_2: /* CIL Label */ 
#line 680
  parm.msg_lev = 2;
#line 680
  goto switch_break;
  case_3: /* CIL Label */ 
#line 681
  parm.msg_lev = 3;
#line 681
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 682
  if ((unsigned long )lp != (unsigned long )lp) {
#line 682
    tmp___0 = 1;
  } else {
    {
#line 682
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     682);
#line 682
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 684
  tmp___1 = _glp_lpx_get_int_parm(lp, 316);
  }
  {
#line 685
  if (tmp___1 == 0) {
#line 685
    goto case_0___0;
  }
#line 686
  if (tmp___1 == 1) {
#line 686
    goto case_1___0;
  }
#line 687
  if (tmp___1 == 2) {
#line 687
    goto case_2___0;
  }
#line 688
  if (tmp___1 == 3) {
#line 688
    goto case_3___0;
  }
#line 689
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 685
  parm.br_tech = 1;
#line 685
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 686
  parm.br_tech = 2;
#line 686
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 687
  parm.br_tech = 4;
#line 687
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 688
  parm.br_tech = 3;
#line 688
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 689
  if ((unsigned long )lp != (unsigned long )lp) {
#line 689
    tmp___2 = 1;
  } else {
    {
#line 689
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     689);
#line 689
    tmp___2 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 691
  tmp___3 = _glp_lpx_get_int_parm(lp, 317);
  }
  {
#line 692
  if (tmp___3 == 0) {
#line 692
    goto case_0___1;
  }
#line 693
  if (tmp___3 == 1) {
#line 693
    goto case_1___1;
  }
#line 694
  if (tmp___3 == 2) {
#line 694
    goto case_2___1;
  }
#line 695
  if (tmp___3 == 3) {
#line 695
    goto case_3___1;
  }
#line 696
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 692
  parm.bt_tech = 1;
#line 692
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 693
  parm.bt_tech = 2;
#line 693
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 694
  parm.bt_tech = 4;
#line 694
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 695
  parm.bt_tech = 3;
#line 695
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 696
  if ((unsigned long )lp != (unsigned long )lp) {
#line 696
    tmp___4 = 1;
  } else {
    {
#line 696
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     696);
#line 696
    tmp___4 = 1;
    }
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 698
  parm.tol_int = _glp_lpx_get_real_parm(lp, 318);
#line 699
  parm.tol_obj = _glp_lpx_get_real_parm(lp, 319);
#line 700
  tmp___6 = _glp_lpx_get_real_parm(lp, 313);
  }
#line 700
  if (tmp___6 < 0.0) {
#line 702
    parm.tm_lim = 2147483647;
  } else {
    {
#line 700
    tmp___7 = _glp_lpx_get_real_parm(lp, 313);
    }
#line 700
    if (tmp___7 > 1e6) {
#line 702
      parm.tm_lim = 2147483647;
    } else {
      {
#line 704
      tmp___5 = _glp_lpx_get_real_parm(lp, 313);
#line 704
      parm.tm_lim = (int )(1000.0 * tmp___5);
      }
    }
  }
  {
#line 706
  parm.mip_gap = _glp_lpx_get_real_parm(lp, 331);
#line 707
  tmp___8 = _glp_lpx_get_int_parm(lp, 329);
  }
#line 707
  if (tmp___8 & 4) {
#line 708
    parm.gmi_cuts = 1;
  } else {
#line 710
    parm.gmi_cuts = 0;
  }
  {
#line 711
  tmp___9 = _glp_lpx_get_int_parm(lp, 329);
  }
#line 711
  if (tmp___9 & 8) {
#line 712
    parm.mir_cuts = 1;
  } else {
#line 714
    parm.mir_cuts = 0;
  }
  {
#line 715
  tmp___10 = _glp_lpx_get_int_parm(lp, 329);
  }
#line 715
  if (tmp___10 & 1) {
#line 716
    parm.cov_cuts = 1;
  } else {
#line 718
    parm.cov_cuts = 0;
  }
  {
#line 719
  tmp___11 = _glp_lpx_get_int_parm(lp, 329);
  }
#line 719
  if (tmp___11 & 2) {
#line 720
    parm.clq_cuts = 1;
  } else {
#line 722
    parm.clq_cuts = 0;
  }
  {
#line 723
  parm.presolve = presolve;
#line 724
  tmp___12 = _glp_lpx_get_int_parm(lp, 328);
  }
#line 724
  if (tmp___12) {
#line 725
    parm.binarize = 1;
  }
  {
#line 726
  ret = glp_intopt(lp, (glp_iocp const   *)(& parm));
  }
  {
#line 728
  if (ret == 0) {
#line 728
    goto case_0___2;
  }
#line 729
  if (ret == 10) {
#line 729
    goto case_10;
  }
#line 730
  if (ret == 11) {
#line 730
    goto case_11;
  }
#line 732
  if (ret == 12) {
#line 732
    goto case_12;
  }
#line 732
  if (ret == 4) {
#line 732
    goto case_12;
  }
#line 733
  if (ret == 5) {
#line 733
    goto case_5;
  }
#line 734
  if (ret == 14) {
#line 734
    goto case_14;
  }
#line 735
  if (ret == 9) {
#line 735
    goto case_9;
  }
#line 736
  goto switch_default___2;
  case_0___2: /* CIL Label */ 
#line 728
  ret = 200;
#line 728
  goto switch_break___2;
  case_10: /* CIL Label */ 
#line 729
  ret = 213;
#line 729
  goto switch_break___2;
  case_11: /* CIL Label */ 
#line 730
  ret = 214;
#line 730
  goto switch_break___2;
  case_12: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 732
  ret = 204;
#line 732
  goto switch_break___2;
  case_5: /* CIL Label */ 
#line 733
  ret = 211;
#line 733
  goto switch_break___2;
  case_14: /* CIL Label */ 
#line 734
  ret = 215;
#line 734
  goto switch_break___2;
  case_9: /* CIL Label */ 
#line 735
  ret = 208;
#line 735
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 736
  if (ret != ret) {
#line 736
    tmp___13 = 1;
  } else {
    {
#line 736
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     736);
#line 736
    tmp___13 = 1;
    }
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 738
  return (ret);
}
}
#line 741 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_integer(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 743
  tmp = solve_mip(lp, 0);
  }
#line 743
  return (tmp);
}
}
#line 746 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_intopt(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 748
  tmp = solve_mip(lp, 1);
  }
#line 748
  return (tmp);
}
}
#line 751 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_mip_status(glp_prob *lp ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 754
  tmp = glp_mip_status(lp);
  }
  {
#line 755
  if (tmp == 1) {
#line 755
    goto case_1;
  }
#line 756
  if (tmp == 5) {
#line 756
    goto case_5;
  }
#line 757
  if (tmp == 2) {
#line 757
    goto case_2;
  }
#line 758
  if (tmp == 4) {
#line 758
    goto case_4;
  }
#line 759
  goto switch_default;
  case_1: /* CIL Label */ 
#line 755
  status = 170;
#line 755
  goto switch_break;
  case_5: /* CIL Label */ 
#line 756
  status = 171;
#line 756
  goto switch_break;
  case_2: /* CIL Label */ 
#line 757
  status = 172;
#line 757
  goto switch_break;
  case_4: /* CIL Label */ 
#line 758
  status = 173;
#line 758
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 759
  if ((unsigned long )lp != (unsigned long )lp) {
#line 759
    tmp___0 = 1;
  } else {
    {
#line 759
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     759);
#line 759
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 761
  return (status);
}
}
#line 764 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_mip_obj_val(glp_prob *lp ) 
{ 
  double tmp ;

  {
  {
#line 766
  tmp = glp_mip_obj_val(lp);
  }
#line 766
  return (tmp);
}
}
#line 769 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_mip_row_val(glp_prob *lp , int i ) 
{ 
  double tmp ;

  {
  {
#line 771
  tmp = glp_mip_row_val(lp, i);
  }
#line 771
  return (tmp);
}
}
#line 774 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_mip_col_val(glp_prob *lp , int j ) 
{ 
  double tmp ;

  {
  {
#line 776
  tmp = glp_mip_col_val(lp, j);
  }
#line 776
  return (tmp);
}
}
#line 779 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_check_int(glp_prob *lp , LPXKKT *kkt ) 
{ 
  int ae_ind ;
  int re_ind ;
  double ae_max ;
  double re_max ;

  {
  {
#line 783
  _glp_check_kkt(lp, 3, 1, & ae_max, & ae_ind, & re_max, & re_ind);
#line 785
  kkt->pe_ae_max = ae_max;
#line 786
  kkt->pe_ae_row = ae_ind;
#line 787
  kkt->pe_re_max = re_max;
#line 788
  kkt->pe_re_row = re_ind;
  }
#line 789
  if (re_max <= 1e-9) {
#line 790
    kkt->pe_quality = 'H';
  } else
#line 791
  if (re_max <= 1e-6) {
#line 792
    kkt->pe_quality = 'M';
  } else
#line 793
  if (re_max <= 1e-3) {
#line 794
    kkt->pe_quality = 'L';
  } else {
#line 796
    kkt->pe_quality = '?';
  }
  {
#line 797
  _glp_check_kkt(lp, 3, 2, & ae_max, & ae_ind, & re_max, & re_ind);
#line 799
  kkt->pb_ae_max = ae_max;
#line 800
  kkt->pb_ae_ind = ae_ind;
#line 801
  kkt->pb_re_max = re_max;
#line 802
  kkt->pb_re_ind = re_ind;
  }
#line 803
  if (re_max <= 1e-9) {
#line 804
    kkt->pb_quality = 'H';
  } else
#line 805
  if (re_max <= 1e-6) {
#line 806
    kkt->pb_quality = 'M';
  } else
#line 807
  if (re_max <= 1e-3) {
#line 808
    kkt->pb_quality = 'L';
  } else {
#line 810
    kkt->pb_quality = '?';
  }
#line 811
  return;
}
}
#line 814 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_reset_parms(glp_prob *lp ) 
{ 
  struct LPXCPS *cps ;

  {
#line 816
  cps = (struct LPXCPS *)lp->cps;
#line 817
  cps->msg_lev = 3;
#line 818
  cps->scale = 1;
#line 819
  cps->dual = 0;
#line 820
  cps->price = 1;
#line 821
  cps->relax = 0.07;
#line 822
  cps->tol_bnd = 1e-7;
#line 823
  cps->tol_dj = 1e-7;
#line 824
  cps->tol_piv = 1e-9;
#line 825
  cps->round = 0;
#line 826
  cps->obj_ll = - 1.7976931348623157e+308;
#line 827
  cps->obj_ul = 1.7976931348623157e+308;
#line 828
  cps->it_lim = -1;
#line 829
  lp->it_cnt = 0;
#line 830
  cps->tm_lim = - 1.0;
#line 831
  cps->out_frq = 200;
#line 832
  cps->out_dly = 0.0;
#line 833
  cps->branch = 2;
#line 834
  cps->btrack = 3;
#line 835
  cps->tol_int = 1e-5;
#line 836
  cps->tol_obj = 1e-7;
#line 837
  cps->mps_info = 1;
#line 838
  cps->mps_obj = 2;
#line 839
  cps->mps_orig = 0;
#line 840
  cps->mps_wide = 1;
#line 841
  cps->mps_free = 0;
#line 842
  cps->mps_skip = 0;
#line 843
  cps->lpt_orig = 0;
#line 844
  cps->presol = 0;
#line 845
  cps->binarize = 0;
#line 846
  cps->use_cuts = 0;
#line 847
  cps->mip_gap = 0.0;
#line 848
  return;
}
}
#line 851 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_int_parm(glp_prob *lp , int parm , int val ) 
{ 
  struct LPXCPS *cps ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  xerror_t tmp___6 ;
  xerror_t tmp___7 ;
  xerror_t tmp___8 ;
  xerror_t tmp___9 ;
  xerror_t tmp___10 ;
  xerror_t tmp___11 ;
  xerror_t tmp___12 ;
  xerror_t tmp___13 ;
  xerror_t tmp___14 ;
  xerror_t tmp___15 ;
  xerror_t tmp___16 ;
  glp_bfcp parm___0 ;
  xerror_t tmp___17 ;
  xerror_t tmp___18 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
#line 853
  cps = (struct LPXCPS *)lp->cps;
  {
#line 855
  if (parm == 300) {
#line 855
    goto case_300;
  }
#line 861
  if (parm == 301) {
#line 861
    goto case_301;
  }
#line 867
  if (parm == 302) {
#line 867
    goto case_302;
  }
#line 873
  if (parm == 303) {
#line 873
    goto case_303;
  }
#line 879
  if (parm == 308) {
#line 879
    goto case_308;
  }
#line 885
  if (parm == 311) {
#line 885
    goto case_311;
  }
#line 888
  if (parm == 312) {
#line 888
    goto case_312;
  }
#line 891
  if (parm == 314) {
#line 891
    goto case_314;
  }
#line 897
  if (parm == 316) {
#line 897
    goto case_316;
  }
#line 903
  if (parm == 317) {
#line 903
    goto case_317;
  }
#line 909
  if (parm == 320) {
#line 909
    goto case_320;
  }
#line 915
  if (parm == 321) {
#line 915
    goto case_321;
  }
#line 921
  if (parm == 322) {
#line 921
    goto case_322;
  }
#line 927
  if (parm == 323) {
#line 927
    goto case_323;
  }
#line 933
  if (parm == 324) {
#line 933
    goto case_324;
  }
#line 939
  if (parm == 325) {
#line 939
    goto case_325;
  }
#line 945
  if (parm == 326) {
#line 945
    goto case_326;
  }
#line 951
  if (parm == 327) {
#line 951
    goto case_327;
  }
#line 957
  if (parm == 328) {
#line 957
    goto case_328;
  }
#line 963
  if (parm == 329) {
#line 963
    goto case_329;
  }
#line 969
  if (parm == 330) {
#line 969
    goto case_330;
  }
#line 993
  goto switch_default___0;
  case_300: /* CIL Label */ 
#line 856
  if (0 <= val) {
#line 856
    if (! (val <= 3)) {
      {
#line 857
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 857);
#line 857
      (*tmp)("lpx_set_int_parm: MSGLEV = %d; invalid value\n", val);
      }
    }
  } else {
    {
#line 857
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 857);
#line 857
    (*tmp)("lpx_set_int_parm: MSGLEV = %d; invalid value\n", val);
    }
  }
#line 859
  cps->msg_lev = val;
#line 860
  goto switch_break;
  case_301: /* CIL Label */ 
#line 862
  if (0 <= val) {
#line 862
    if (! (val <= 3)) {
      {
#line 863
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 863);
#line 863
      (*tmp___0)("lpx_set_int_parm: SCALE = %d; invalid value\n", val);
      }
    }
  } else {
    {
#line 863
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               863);
#line 863
    (*tmp___0)("lpx_set_int_parm: SCALE = %d; invalid value\n", val);
    }
  }
#line 865
  cps->scale = val;
#line 866
  goto switch_break;
  case_302: /* CIL Label */ 
#line 868
  if (! (val == 0)) {
#line 868
    if (! (val == 1)) {
      {
#line 869
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 869);
#line 869
      (*tmp___1)("lpx_set_int_parm: DUAL = %d; invalid value\n", val);
      }
    }
  }
#line 871
  cps->dual = val;
#line 872
  goto switch_break;
  case_303: /* CIL Label */ 
#line 874
  if (! (val == 0)) {
#line 874
    if (! (val == 1)) {
      {
#line 875
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 875);
#line 875
      (*tmp___2)("lpx_set_int_parm: PRICE = %d; invalid value\n", val);
      }
    }
  }
#line 877
  cps->price = val;
#line 878
  goto switch_break;
  case_308: /* CIL Label */ 
#line 880
  if (! (val == 0)) {
#line 880
    if (! (val == 1)) {
      {
#line 881
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 881);
#line 881
      (*tmp___3)("lpx_set_int_parm: ROUND = %d; invalid value\n", val);
      }
    }
  }
#line 883
  cps->round = val;
#line 884
  goto switch_break;
  case_311: /* CIL Label */ 
#line 886
  cps->it_lim = val;
#line 887
  goto switch_break;
  case_312: /* CIL Label */ 
#line 889
  lp->it_cnt = val;
#line 890
  goto switch_break;
  case_314: /* CIL Label */ 
#line 892
  if (! (val > 0)) {
    {
#line 893
    tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               893);
#line 893
    (*tmp___4)("lpx_set_int_parm: OUTFRQ = %d; invalid value\n", val);
    }
  }
#line 895
  cps->out_frq = val;
#line 896
  goto switch_break;
  case_316: /* CIL Label */ 
#line 898
  if (! (val == 0)) {
#line 898
    if (! (val == 1)) {
#line 898
      if (! (val == 2)) {
#line 898
        if (! (val == 3)) {
          {
#line 899
          tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                     899);
#line 899
          (*tmp___5)("lpx_set_int_parm: BRANCH = %d; invalid value\n", val);
          }
        }
      }
    }
  }
#line 901
  cps->branch = val;
#line 902
  goto switch_break;
  case_317: /* CIL Label */ 
#line 904
  if (! (val == 0)) {
#line 904
    if (! (val == 1)) {
#line 904
      if (! (val == 2)) {
#line 904
        if (! (val == 3)) {
          {
#line 905
          tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                     905);
#line 905
          (*tmp___6)("lpx_set_int_parm: BTRACK = %d; invalid value\n", val);
          }
        }
      }
    }
  }
#line 907
  cps->btrack = val;
#line 908
  goto switch_break;
  case_320: /* CIL Label */ 
#line 910
  if (! (val == 0)) {
#line 910
    if (! (val == 1)) {
      {
#line 911
      tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 911);
#line 911
      (*tmp___7)("lpx_set_int_parm: MPSINFO = %d; invalid value\n", val);
      }
    }
  }
#line 913
  cps->mps_info = val;
#line 914
  goto switch_break;
  case_321: /* CIL Label */ 
#line 916
  if (! (val == 0)) {
#line 916
    if (! (val == 1)) {
#line 916
      if (! (val == 2)) {
        {
#line 917
        tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                   917);
#line 917
        (*tmp___8)("lpx_set_int_parm: MPSOBJ = %d; invalid value\n", val);
        }
      }
    }
  }
#line 919
  cps->mps_obj = val;
#line 920
  goto switch_break;
  case_322: /* CIL Label */ 
#line 922
  if (! (val == 0)) {
#line 922
    if (! (val == 1)) {
      {
#line 923
      tmp___9 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 923);
#line 923
      (*tmp___9)("lpx_set_int_parm: MPSORIG = %d; invalid value\n", val);
      }
    }
  }
#line 925
  cps->mps_orig = val;
#line 926
  goto switch_break;
  case_323: /* CIL Label */ 
#line 928
  if (! (val == 0)) {
#line 928
    if (! (val == 1)) {
      {
#line 929
      tmp___10 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                  929);
#line 929
      (*tmp___10)("lpx_set_int_parm: MPSWIDE = %d; invalid value\n", val);
      }
    }
  }
#line 931
  cps->mps_wide = val;
#line 932
  goto switch_break;
  case_324: /* CIL Label */ 
#line 934
  if (! (val == 0)) {
#line 934
    if (! (val == 1)) {
      {
#line 935
      tmp___11 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                  935);
#line 935
      (*tmp___11)("lpx_set_int_parm: MPSFREE = %d; invalid value\n", val);
      }
    }
  }
#line 937
  cps->mps_free = val;
#line 938
  goto switch_break;
  case_325: /* CIL Label */ 
#line 940
  if (! (val == 0)) {
#line 940
    if (! (val == 1)) {
      {
#line 941
      tmp___12 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                  941);
#line 941
      (*tmp___12)("lpx_set_int_parm: MPSSKIP = %d; invalid value\n", val);
      }
    }
  }
#line 943
  cps->mps_skip = val;
#line 944
  goto switch_break;
  case_326: /* CIL Label */ 
#line 946
  if (! (val == 0)) {
#line 946
    if (! (val == 1)) {
      {
#line 947
      tmp___13 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                  947);
#line 947
      (*tmp___13)("lpx_set_int_parm: LPTORIG = %d; invalid value\n", val);
      }
    }
  }
#line 949
  cps->lpt_orig = val;
#line 950
  goto switch_break;
  case_327: /* CIL Label */ 
#line 952
  if (! (val == 0)) {
#line 952
    if (! (val == 1)) {
      {
#line 953
      tmp___14 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                  953);
#line 953
      (*tmp___14)("lpx_set_int_parm: PRESOL = %d; invalid value\n", val);
      }
    }
  }
#line 955
  cps->presol = val;
#line 956
  goto switch_break;
  case_328: /* CIL Label */ 
#line 958
  if (! (val == 0)) {
#line 958
    if (! (val == 1)) {
      {
#line 959
      tmp___15 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                  959);
#line 959
      (*tmp___15)("lpx_set_int_parm: BINARIZE = %d; invalid value\n", val);
      }
    }
  }
#line 961
  cps->binarize = val;
#line 962
  goto switch_break;
  case_329: /* CIL Label */ 
#line 964
  if (val & -256) {
    {
#line 965
    tmp___16 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                965);
#line 965
    (*tmp___16)("lpx_set_int_parm: USECUTS = 0x%X; invalid value\n", val);
    }
  }
#line 967
  cps->use_cuts = val;
#line 968
  goto switch_break;
  case_330: /* CIL Label */ 
  {
#line 977
  glp_get_bfcp(lp, & parm___0);
  }
  {
#line 979
  if (val == 1) {
#line 979
    goto case_1;
  }
#line 981
  if (val == 2) {
#line 981
    goto case_2;
  }
#line 983
  if (val == 3) {
#line 983
    goto case_3;
  }
#line 985
  goto switch_default;
  case_1: /* CIL Label */ 
#line 980
  parm___0.type = 1;
#line 980
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 982
  parm___0.type = 2;
#line 982
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 984
  parm___0.type = 3;
#line 984
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 986
  tmp___17 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 986);
#line 986
  (*tmp___17)("lpx_set_int_parm: BFTYPE = %d; invalid value\n", val);
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 989
  glp_set_bfcp(lp, (glp_bfcp const   *)(& parm___0));
  }
#line 992
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 994
  tmp___18 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 994);
#line 994
  (*tmp___18)("lpx_set_int_parm: parm = %d; invalid parameter\n", parm);
  }
  switch_break: /* CIL Label */ ;
  }
#line 997
  return;
}
}
#line 1000 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_get_int_parm(glp_prob *lp , int parm ) 
{ 
  struct LPXCPS *cps ;
  int val ;
  glp_bfcp parm___0 ;
  int tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1002
  cps = (struct LPXCPS *)lp->cps;
#line 1003
  val = 0;
  {
#line 1005
  if (parm == 300) {
#line 1005
    goto case_300;
  }
#line 1007
  if (parm == 301) {
#line 1007
    goto case_301;
  }
#line 1009
  if (parm == 302) {
#line 1009
    goto case_302;
  }
#line 1011
  if (parm == 303) {
#line 1011
    goto case_303;
  }
#line 1013
  if (parm == 308) {
#line 1013
    goto case_308;
  }
#line 1015
  if (parm == 311) {
#line 1015
    goto case_311;
  }
#line 1017
  if (parm == 312) {
#line 1017
    goto case_312;
  }
#line 1019
  if (parm == 314) {
#line 1019
    goto case_314;
  }
#line 1021
  if (parm == 316) {
#line 1021
    goto case_316;
  }
#line 1023
  if (parm == 317) {
#line 1023
    goto case_317;
  }
#line 1025
  if (parm == 320) {
#line 1025
    goto case_320;
  }
#line 1027
  if (parm == 321) {
#line 1027
    goto case_321;
  }
#line 1029
  if (parm == 322) {
#line 1029
    goto case_322;
  }
#line 1031
  if (parm == 323) {
#line 1031
    goto case_323;
  }
#line 1033
  if (parm == 324) {
#line 1033
    goto case_324;
  }
#line 1035
  if (parm == 325) {
#line 1035
    goto case_325;
  }
#line 1037
  if (parm == 326) {
#line 1037
    goto case_326;
  }
#line 1039
  if (parm == 327) {
#line 1039
    goto case_327;
  }
#line 1041
  if (parm == 328) {
#line 1041
    goto case_328;
  }
#line 1043
  if (parm == 329) {
#line 1043
    goto case_329;
  }
#line 1045
  if (parm == 330) {
#line 1045
    goto case_330;
  }
#line 1064
  goto switch_default___0;
  case_300: /* CIL Label */ 
#line 1006
  val = cps->msg_lev;
#line 1006
  goto switch_break;
  case_301: /* CIL Label */ 
#line 1008
  val = cps->scale;
#line 1008
  goto switch_break;
  case_302: /* CIL Label */ 
#line 1010
  val = cps->dual;
#line 1010
  goto switch_break;
  case_303: /* CIL Label */ 
#line 1012
  val = cps->price;
#line 1012
  goto switch_break;
  case_308: /* CIL Label */ 
#line 1014
  val = cps->round;
#line 1014
  goto switch_break;
  case_311: /* CIL Label */ 
#line 1016
  val = cps->it_lim;
#line 1016
  goto switch_break;
  case_312: /* CIL Label */ 
#line 1018
  val = lp->it_cnt;
#line 1018
  goto switch_break;
  case_314: /* CIL Label */ 
#line 1020
  val = cps->out_frq;
#line 1020
  goto switch_break;
  case_316: /* CIL Label */ 
#line 1022
  val = cps->branch;
#line 1022
  goto switch_break;
  case_317: /* CIL Label */ 
#line 1024
  val = cps->btrack;
#line 1024
  goto switch_break;
  case_320: /* CIL Label */ 
#line 1026
  val = cps->mps_info;
#line 1026
  goto switch_break;
  case_321: /* CIL Label */ 
#line 1028
  val = cps->mps_obj;
#line 1028
  goto switch_break;
  case_322: /* CIL Label */ 
#line 1030
  val = cps->mps_orig;
#line 1030
  goto switch_break;
  case_323: /* CIL Label */ 
#line 1032
  val = cps->mps_wide;
#line 1032
  goto switch_break;
  case_324: /* CIL Label */ 
#line 1034
  val = cps->mps_free;
#line 1034
  goto switch_break;
  case_325: /* CIL Label */ 
#line 1036
  val = cps->mps_skip;
#line 1036
  goto switch_break;
  case_326: /* CIL Label */ 
#line 1038
  val = cps->lpt_orig;
#line 1038
  goto switch_break;
  case_327: /* CIL Label */ 
#line 1040
  val = cps->presol;
#line 1040
  goto switch_break;
  case_328: /* CIL Label */ 
#line 1042
  val = cps->binarize;
#line 1042
  goto switch_break;
  case_329: /* CIL Label */ 
#line 1044
  val = cps->use_cuts;
#line 1044
  goto switch_break;
  case_330: /* CIL Label */ 
  {
#line 1050
  glp_get_bfcp(lp, & parm___0);
  }
  {
#line 1052
  if (parm___0.type == 1) {
#line 1052
    goto case_1;
  }
#line 1054
  if (parm___0.type == 2) {
#line 1054
    goto case_2;
  }
#line 1056
  if (parm___0.type == 3) {
#line 1056
    goto case_3;
  }
#line 1058
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1053
  val = 1;
#line 1053
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 1055
  val = 2;
#line 1055
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 1057
  val = 3;
#line 1057
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1059
  if ((unsigned long )lp != (unsigned long )lp) {
#line 1059
    tmp = 1;
  } else {
    {
#line 1059
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     1059);
#line 1059
    tmp = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 1062
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 1065
  tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 1065);
#line 1065
  (*tmp___0)("lpx_get_int_parm: parm = %d; invalid parameter\n", parm);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1068
  return (val);
}
}
#line 1071 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
void _glp_lpx_set_real_parm(glp_prob *lp , int parm , double val ) 
{ 
  struct LPXCPS *cps ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  xerror_t tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 1073
  cps = (struct LPXCPS *)lp->cps;
  {
#line 1075
  if (parm == 304) {
#line 1075
    goto case_304;
  }
#line 1081
  if (parm == 305) {
#line 1081
    goto case_305;
  }
#line 1094
  if (parm == 306) {
#line 1094
    goto case_306;
  }
#line 1107
  if (parm == 307) {
#line 1107
    goto case_307;
  }
#line 1113
  if (parm == 309) {
#line 1113
    goto case_309;
  }
#line 1116
  if (parm == 310) {
#line 1116
    goto case_310;
  }
#line 1119
  if (parm == 313) {
#line 1119
    goto case_313;
  }
#line 1122
  if (parm == 315) {
#line 1122
    goto case_315;
  }
#line 1125
  if (parm == 318) {
#line 1125
    goto case_318;
  }
#line 1131
  if (parm == 319) {
#line 1131
    goto case_319;
  }
#line 1137
  if (parm == 331) {
#line 1137
    goto case_331;
  }
#line 1143
  goto switch_default;
  case_304: /* CIL Label */ 
#line 1076
  if (0.0 <= val) {
#line 1076
    if (! (val <= 1.0)) {
      {
#line 1077
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 1077);
#line 1077
      (*tmp)("lpx_set_real_parm: RELAX = %g; invalid value\n", val);
      }
    }
  } else {
    {
#line 1077
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 1077);
#line 1077
    (*tmp)("lpx_set_real_parm: RELAX = %g; invalid value\n", val);
    }
  }
#line 1079
  cps->relax = val;
#line 1080
  goto switch_break;
  case_305: /* CIL Label */ 
#line 1082
  if (2.2204460492503131e-16 <= val) {
#line 1082
    if (! (val <= 0.001)) {
      {
#line 1083
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 1083);
#line 1083
      (*tmp___0)("lpx_set_real_parm: TOLBND = %g; invalid value\n", val);
      }
    }
  } else {
    {
#line 1083
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               1083);
#line 1083
    (*tmp___0)("lpx_set_real_parm: TOLBND = %g; invalid value\n", val);
    }
  }
#line 1092
  cps->tol_bnd = val;
#line 1093
  goto switch_break;
  case_306: /* CIL Label */ 
#line 1095
  if (2.2204460492503131e-16 <= val) {
#line 1095
    if (! (val <= 0.001)) {
      {
#line 1096
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 1096);
#line 1096
      (*tmp___1)("lpx_set_real_parm: TOLDJ = %g; invalid value\n", val);
      }
    }
  } else {
    {
#line 1096
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               1096);
#line 1096
    (*tmp___1)("lpx_set_real_parm: TOLDJ = %g; invalid value\n", val);
    }
  }
#line 1105
  cps->tol_dj = val;
#line 1106
  goto switch_break;
  case_307: /* CIL Label */ 
#line 1108
  if (2.2204460492503131e-16 <= val) {
#line 1108
    if (! (val <= 0.001)) {
      {
#line 1109
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 1109);
#line 1109
      (*tmp___2)("lpx_set_real_parm: TOLPIV = %g; invalid value\n", val);
      }
    }
  } else {
    {
#line 1109
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               1109);
#line 1109
    (*tmp___2)("lpx_set_real_parm: TOLPIV = %g; invalid value\n", val);
    }
  }
#line 1111
  cps->tol_piv = val;
#line 1112
  goto switch_break;
  case_309: /* CIL Label */ 
#line 1114
  cps->obj_ll = val;
#line 1115
  goto switch_break;
  case_310: /* CIL Label */ 
#line 1117
  cps->obj_ul = val;
#line 1118
  goto switch_break;
  case_313: /* CIL Label */ 
#line 1120
  cps->tm_lim = val;
#line 1121
  goto switch_break;
  case_315: /* CIL Label */ 
#line 1123
  cps->out_dly = val;
#line 1124
  goto switch_break;
  case_318: /* CIL Label */ 
#line 1126
  if (2.2204460492503131e-16 <= val) {
#line 1126
    if (! (val <= 0.001)) {
      {
#line 1127
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 1127);
#line 1127
      (*tmp___3)("lpx_set_real_parm: TOLINT = %g; invalid value\n", val);
      }
    }
  } else {
    {
#line 1127
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               1127);
#line 1127
    (*tmp___3)("lpx_set_real_parm: TOLINT = %g; invalid value\n", val);
    }
  }
#line 1129
  cps->tol_int = val;
#line 1130
  goto switch_break;
  case_319: /* CIL Label */ 
#line 1132
  if (2.2204460492503131e-16 <= val) {
#line 1132
    if (! (val <= 0.001)) {
      {
#line 1133
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                                 1133);
#line 1133
      (*tmp___4)("lpx_set_real_parm: TOLOBJ = %g; invalid value\n", val);
      }
    }
  } else {
    {
#line 1133
    tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               1133);
#line 1133
    (*tmp___4)("lpx_set_real_parm: TOLOBJ = %g; invalid value\n", val);
    }
  }
#line 1135
  cps->tol_obj = val;
#line 1136
  goto switch_break;
  case_331: /* CIL Label */ 
#line 1138
  if (val < 0.0) {
    {
#line 1139
    tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                               1139);
#line 1139
    (*tmp___5)("lpx_set_real_parm: MIPGAP = %g; invalid value\n", val);
    }
  }
#line 1141
  cps->mip_gap = val;
#line 1142
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1144
  tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 1144);
#line 1144
  (*tmp___6)("lpx_set_real_parm: parm = %d; invalid parameter\n", parm);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1147
  return;
}
}
#line 1150 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
double _glp_lpx_get_real_parm(glp_prob *lp , int parm ) 
{ 
  struct LPXCPS *cps ;
  double val ;
  xerror_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1152
  cps = (struct LPXCPS *)lp->cps;
#line 1153
  val = 0.0;
  {
#line 1155
  if (parm == 304) {
#line 1155
    goto case_304;
  }
#line 1158
  if (parm == 305) {
#line 1158
    goto case_305;
  }
#line 1161
  if (parm == 306) {
#line 1161
    goto case_306;
  }
#line 1164
  if (parm == 307) {
#line 1164
    goto case_307;
  }
#line 1167
  if (parm == 309) {
#line 1167
    goto case_309;
  }
#line 1170
  if (parm == 310) {
#line 1170
    goto case_310;
  }
#line 1173
  if (parm == 313) {
#line 1173
    goto case_313;
  }
#line 1176
  if (parm == 315) {
#line 1176
    goto case_315;
  }
#line 1179
  if (parm == 318) {
#line 1179
    goto case_318;
  }
#line 1182
  if (parm == 319) {
#line 1182
    goto case_319;
  }
#line 1185
  if (parm == 331) {
#line 1185
    goto case_331;
  }
#line 1188
  goto switch_default;
  case_304: /* CIL Label */ 
#line 1156
  val = cps->relax;
#line 1157
  goto switch_break;
  case_305: /* CIL Label */ 
#line 1159
  val = cps->tol_bnd;
#line 1160
  goto switch_break;
  case_306: /* CIL Label */ 
#line 1162
  val = cps->tol_dj;
#line 1163
  goto switch_break;
  case_307: /* CIL Label */ 
#line 1165
  val = cps->tol_piv;
#line 1166
  goto switch_break;
  case_309: /* CIL Label */ 
#line 1168
  val = cps->obj_ll;
#line 1169
  goto switch_break;
  case_310: /* CIL Label */ 
#line 1171
  val = cps->obj_ul;
#line 1172
  goto switch_break;
  case_313: /* CIL Label */ 
#line 1174
  val = cps->tm_lim;
#line 1175
  goto switch_break;
  case_315: /* CIL Label */ 
#line 1177
  val = cps->out_dly;
#line 1178
  goto switch_break;
  case_318: /* CIL Label */ 
#line 1180
  val = cps->tol_int;
#line 1181
  goto switch_break;
  case_319: /* CIL Label */ 
#line 1183
  val = cps->tol_obj;
#line 1184
  goto switch_break;
  case_331: /* CIL Label */ 
#line 1186
  val = cps->mip_gap;
#line 1187
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1189
  tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 1189);
#line 1189
  (*tmp)("lpx_get_real_parm: parm = %d; invalid parameter\n", parm);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1192
  return (val);
}
}
#line 1195 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
glp_prob *_glp_lpx_read_mps(char const   *fname ) 
{ 
  glp_prob *lp ;
  glp_prob *tmp ;
  int tmp___0 ;

  {
  {
#line 1197
  tmp = _glp_lpx_create_prob();
#line 1197
  lp = tmp;
#line 1198
  tmp___0 = glp_read_mps(lp, 1, (glp_mpscp const   *)((void *)0), fname);
  }
#line 1198
  if (tmp___0) {
    {
#line 1199
    _glp_lpx_delete_prob(lp);
#line 1199
    lp = (glp_prob *)((void *)0);
    }
  }
#line 1200
  return (lp);
}
}
#line 1203 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_write_mps(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 1205
  tmp = glp_write_mps(lp, 1, (glp_mpscp const   *)((void *)0), fname);
  }
#line 1205
  return (tmp);
}
}
#line 1208 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_read_bas(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;
  int tmp___0 ;
  xerror_t tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1213
  if ((unsigned long )lp == (unsigned long )lp) {
#line 1213
    tmp = 1;
  } else {
    {
#line 1213
    _glp_lib_xassert("lp == lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     1213);
#line 1213
    tmp = 1;
    }
  }
#line 1214
  if ((unsigned long )fname == (unsigned long )fname) {
#line 1214
    tmp___0 = 1;
  } else {
    {
#line 1214
    _glp_lib_xassert("fname == fname", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     1214);
#line 1214
    tmp___0 = 1;
    }
  }
  {
#line 1215
  tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 1215);
#line 1215
  (*tmp___1)("lpx_read_bas: operation not supported\n");
  }
#line 1216
  return (0);
}
}
#line 1220 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_write_bas(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;
  int tmp___0 ;
  xerror_t tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1225
  if ((unsigned long )lp == (unsigned long )lp) {
#line 1225
    tmp = 1;
  } else {
    {
#line 1225
    _glp_lib_xassert("lp == lp", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     1225);
#line 1225
    tmp = 1;
    }
  }
#line 1226
  if ((unsigned long )fname == (unsigned long )fname) {
#line 1226
    tmp___0 = 1;
  } else {
    {
#line 1226
    _glp_lib_xassert("fname == fname", "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c",
                     1226);
#line 1226
    tmp___0 = 1;
    }
  }
  {
#line 1227
  tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c", 1227);
#line 1227
  (*tmp___1)("lpx_write_bas: operation not supported\n");
  }
#line 1228
  return (0);
}
}
#line 1232 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
glp_prob *_glp_lpx_read_freemps(char const   *fname ) 
{ 
  glp_prob *lp ;
  glp_prob *tmp ;
  int tmp___0 ;

  {
  {
#line 1234
  tmp = _glp_lpx_create_prob();
#line 1234
  lp = tmp;
#line 1235
  tmp___0 = glp_read_mps(lp, 2, (glp_mpscp const   *)((void *)0), fname);
  }
#line 1235
  if (tmp___0) {
    {
#line 1236
    _glp_lpx_delete_prob(lp);
#line 1236
    lp = (glp_prob *)((void *)0);
    }
  }
#line 1237
  return (lp);
}
}
#line 1240 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_write_freemps(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 1242
  tmp = glp_write_mps(lp, 2, (glp_mpscp const   *)((void *)0), fname);
  }
#line 1242
  return (tmp);
}
}
#line 1245 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
glp_prob *_glp_lpx_read_cpxlp(char const   *fname ) 
{ 
  glp_prob *lp ;
  int tmp ;

  {
  {
#line 1248
  lp = _glp_lpx_create_prob();
#line 1249
  tmp = glp_read_lp(lp, (void const   *)((void *)0), fname);
  }
#line 1249
  if (tmp) {
    {
#line 1250
    _glp_lpx_delete_prob(lp);
#line 1250
    lp = (glp_prob *)((void *)0);
    }
  }
#line 1251
  return (lp);
}
}
#line 1254 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_write_cpxlp(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 1256
  tmp = glp_write_lp(lp, (void const   *)((void *)0), fname);
  }
#line 1256
  return (tmp);
}
}
#line 1259 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
glp_prob *_glp_lpx_read_model(char const   *model , char const   *data , char const   *output___0 ) 
{ 
  glp_prob *lp ;
  glp_tran *tran ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1262
  lp = (glp_prob *)((void *)0);
#line 1265
  tran = glp_mpl_alloc_wksp();
#line 1267
  tmp = glp_mpl_read_model(tran, model, (unsigned long )data != (unsigned long )((void *)0));
  }
#line 1267
  if (tmp) {
#line 1267
    goto done;
  }
#line 1269
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 1270
    tmp___0 = glp_mpl_read_data(tran, data);
    }
#line 1270
    if (tmp___0) {
#line 1270
      goto done;
    }
  }
  {
#line 1272
  tmp___1 = glp_mpl_generate(tran, output___0);
  }
#line 1272
  if (tmp___1) {
#line 1272
    goto done;
  }
  {
#line 1274
  lp = glp_create_prob();
#line 1275
  glp_mpl_build_prob(tran, lp);
  }
  done: 
  {
#line 1277
  glp_mpl_free_wksp(tran);
  }
#line 1279
  return (lp);
}
}
#line 1282 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_print_prob(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 1284
  tmp = glp_write_lp(lp, (void const   *)((void *)0), fname);
  }
#line 1284
  return (tmp);
}
}
#line 1287 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_print_sol(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 1289
  tmp = glp_print_sol(lp, fname);
  }
#line 1289
  return (tmp);
}
}
#line 1292 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_print_ips(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 1294
  tmp = glp_print_ipt(lp, fname);
  }
#line 1294
  return (tmp);
}
}
#line 1297 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_print_mip(glp_prob *lp , char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 1299
  tmp = glp_print_mip(lp, fname);
  }
#line 1299
  return (tmp);
}
}
#line 1302 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_is_b_avail(glp_prob *lp ) 
{ 
  int tmp ;

  {
  {
#line 1304
  tmp = glp_bf_exists(lp);
  }
#line 1304
  return (tmp);
}
}
#line 1307 "/home/wslee/benchmarks/glpk-4.38/src/glplpx01.c"
int _glp_lpx_main(int argc , char const   **argv ) 
{ 
  int tmp ;

  {
  {
#line 1309
  tmp = glp_main(argc, argv);
  }
#line 1309
  return (tmp);
}
}
#line 287 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
void _glp_lpp_remove_row(LPP *lpp , LPPROW *row ) ;
#line 290
void _glp_lpp_remove_col(LPP *lpp , LPPCOL *col ) ;
#line 293
void _glp_lpp_enque_row(LPP *lpp , LPPROW *row ) ;
#line 296
void _glp_lpp_deque_row(LPP *lpp , LPPROW *row ) ;
#line 302
void _glp_lpp_deque_col(LPP *lpp , LPPCOL *col ) ;
#line 308
void *_glp_lpp_append_tqe(LPP *lpp , int type , int size ) ;
#line 326
int _glp_lpp_presolve(LPP *lpp ) ;
#line 329
void _glp_lpp_postsolve(LPP *lpp ) ;
#line 55 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static int process_empty_row(LPP *lpp , LPPROW *row ) 
{ 
  EMPTY_ROW *info ;
  double eps ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 59
  if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
#line 59
    tmp = 1;
  } else {
    {
#line 59
    _glp_lib_xassert("row->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     59);
#line 59
    tmp = 1;
    }
  }
#line 61
  eps = 1e-5;
#line 62
  if (row->lb > eps) {
#line 62
    return (1);
  } else
#line 62
  if (row->ub < - eps) {
#line 62
    return (1);
  }
  {
#line 64
  tmp___0 = _glp_lpp_append_tqe(lpp, 1, (int )sizeof(EMPTY_ROW ));
#line 64
  info = (EMPTY_ROW *)tmp___0;
#line 65
  info->p = row->i;
#line 67
  _glp_lpp_remove_row(lpp, row);
  }
#line 68
  return (0);
}
}
#line 71 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_empty_row(LPP *lpp , EMPTY_ROW *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 72
  if (1 <= info->p) {
#line 72
    if (info->p <= lpp->nrows) {
#line 72
      tmp = 1;
    } else {
      {
#line 72
      _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       72);
#line 72
      tmp = 1;
      }
    }
  } else {
    {
#line 72
    _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     72);
#line 72
    tmp = 1;
    }
  }
#line 73
  if (*(lpp->row_stat + info->p) == 0) {
#line 73
    tmp___0 = 1;
  } else {
    {
#line 73
    _glp_lib_xassert("lpp->row_stat[info->p] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     73);
#line 73
    tmp___0 = 1;
    }
  }
#line 75
  *(lpp->row_stat + info->p) = 140;
#line 77
  *(lpp->row_prim + info->p) = 0.0;
#line 78
  *(lpp->row_dual + info->p) = 0.0;
#line 79
  return;
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static int process_empty_col(LPP *lpp , LPPCOL *col ) 
{ 
  EMPTY_COL *info ;
  double eps ;
  int tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 128
  if ((unsigned long )col->ptr == (unsigned long )((void *)0)) {
#line 128
    tmp = 1;
  } else {
    {
#line 128
    _glp_lib_xassert("col->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     128);
#line 128
    tmp = 1;
    }
  }
#line 130
  eps = 1e-5;
#line 131
  if (col->c > eps) {
#line 131
    if (col->lb == - 1.7976931348623157e+308) {
#line 132
      return (1);
    } else {
#line 131
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 131
  if (col->c < - eps) {
#line 131
    if (col->ub == 1.7976931348623157e+308) {
#line 132
      return (1);
    }
  }
  {
#line 134
  tmp___0 = _glp_lpp_append_tqe(lpp, 2, (int )sizeof(EMPTY_COL ));
#line 134
  info = (EMPTY_COL *)tmp___0;
#line 135
  info->q = col->j;
  }
#line 136
  if (col->lb == - 1.7976931348623157e+308) {
#line 136
    if (col->ub == 1.7976931348623157e+308) {
#line 138
      info->stat = 143;
#line 139
      info->prim = 0.0;
    } else {
#line 136
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 141
  if (col->ub == 1.7976931348623157e+308) {
    lo: 
#line 143
    info->stat = 141;
#line 144
    info->prim = col->lb;
  } else
#line 146
  if (col->lb == - 1.7976931348623157e+308) {
    up: 
#line 148
    info->stat = 142;
#line 149
    info->prim = col->ub;
  } else
#line 151
  if (col->lb != col->ub) {
#line 153
    if (col->c > 0.0) {
#line 153
      goto lo;
    }
#line 154
    if (col->c < 0.0) {
#line 154
      goto up;
    }
    {
#line 155
    tmp___1 = fabs(col->lb);
#line 155
    tmp___2 = fabs(col->ub);
    }
#line 155
    if (tmp___1 <= tmp___2) {
#line 155
      goto lo;
    } else {
#line 155
      goto up;
    }
  } else {
#line 159
    info->stat = 144;
#line 160
    info->prim = col->lb;
  }
  {
#line 162
  info->dual = col->c;
#line 164
  lpp->c0 += col->c * info->prim;
#line 166
  _glp_lpp_remove_col(lpp, col);
  }
#line 167
  return (0);
}
}
#line 170 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_empty_col(LPP *lpp , EMPTY_COL *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 171
  if (1 <= info->q) {
#line 171
    if (info->q <= lpp->ncols) {
#line 171
      tmp = 1;
    } else {
      {
#line 171
      _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       171);
#line 171
      tmp = 1;
      }
    }
  } else {
    {
#line 171
    _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     171);
#line 171
    tmp = 1;
    }
  }
#line 172
  if (*(lpp->col_stat + info->q) == 0) {
#line 172
    tmp___0 = 1;
  } else {
    {
#line 172
    _glp_lib_xassert("lpp->col_stat[info->q] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     172);
#line 172
    tmp___0 = 1;
    }
  }
#line 173
  *(lpp->col_stat + info->q) = info->stat;
#line 174
  *(lpp->col_prim + info->q) = info->prim;
#line 175
  *(lpp->col_dual + info->q) = info->dual;
#line 176
  return;
}
}
#line 207 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void process_free_row(LPP *lpp , LPPROW *row ) 
{ 
  FREE_ROW *info ;
  LPPCOL *col ;
  LPPAIJ *aij ;
  LPPLFE *lfe ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 213
  if (row->lb == - 1.7976931348623157e+308) {
#line 213
    if (row->ub == 1.7976931348623157e+308) {
#line 213
      tmp = 1;
    } else {
      {
#line 213
      _glp_lib_xassert("row->lb == -DBL_MAX && row->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       213);
#line 213
      tmp = 1;
      }
    }
  } else {
    {
#line 213
    _glp_lib_xassert("row->lb == -DBL_MAX && row->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     213);
#line 213
    tmp = 1;
    }
  }
  {
#line 215
  tmp___0 = _glp_lpp_append_tqe(lpp, 3, (int )sizeof(FREE_ROW ));
#line 215
  info = (FREE_ROW *)tmp___0;
#line 216
  info->p = row->i;
#line 217
  info->ptr = (LPPLFE *)((void *)0);
#line 219
  aij = row->ptr;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 219
      goto while_break;
    }
    {
#line 220
    col = aij->col;
#line 221
    tmp___1 = _glp_dmp_get_atom(lpp->tqe_pool, (int )sizeof(LPPLFE ));
#line 221
    lfe = (LPPLFE *)tmp___1;
#line 222
    lfe->ref = col->j;
#line 223
    lfe->val = aij->val;
#line 224
    lfe->next = info->ptr;
#line 225
    info->ptr = lfe;
#line 219
    aij = aij->r_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  _glp_lpp_remove_row(lpp, row);
  }
#line 229
  return;
}
}
#line 232 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_free_row(LPP *lpp , FREE_ROW *info ) 
{ 
  LPPLFE *lfe ;
  double sum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 235
  if (1 <= info->p) {
#line 235
    if (info->p <= lpp->nrows) {
#line 235
      tmp = 1;
    } else {
      {
#line 235
      _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       235);
#line 235
      tmp = 1;
      }
    }
  } else {
    {
#line 235
    _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     235);
#line 235
    tmp = 1;
    }
  }
#line 236
  if (*(lpp->row_stat + info->p) == 0) {
#line 236
    tmp___0 = 1;
  } else {
    {
#line 236
    _glp_lib_xassert("lpp->row_stat[info->p] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     236);
#line 236
    tmp___0 = 1;
    }
  }
#line 238
  *(lpp->row_stat + info->p) = 140;
#line 240
  sum = 0.0;
#line 241
  lfe = info->ptr;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 241
      goto while_break;
    }
#line 242
    if (1 <= lfe->ref) {
#line 242
      if (lfe->ref <= lpp->ncols) {
#line 242
        tmp___1 = 1;
      } else {
        {
#line 242
        _glp_lib_xassert("1 <= lfe->ref && lfe->ref <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                         242);
#line 242
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 242
      _glp_lib_xassert("1 <= lfe->ref && lfe->ref <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       242);
#line 242
      tmp___1 = 1;
      }
    }
#line 243
    if (*(lpp->col_stat + lfe->ref) != 0) {
#line 243
      tmp___2 = 1;
    } else {
      {
#line 243
      _glp_lib_xassert("lpp->col_stat[lfe->ref] != 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       243);
#line 243
      tmp___2 = 1;
      }
    }
#line 244
    sum += lfe->val * *(lpp->col_prim + lfe->ref);
#line 241
    lfe = lfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  *(lpp->row_prim + info->p) = sum;
#line 248
  *(lpp->row_dual + info->p) = 0.0;
#line 249
  return;
}
}
#line 321 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void process_fixed_col(LPP *lpp , LPPCOL *col ) 
{ 
  FIXED_COL *info ;
  LPPROW *row ;
  LPPAIJ *aij ;
  LPPLFE *lfe ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 327
  if (col->lb == col->ub) {
#line 327
    tmp = 1;
  } else {
    {
#line 327
    _glp_lib_xassert("col->lb == col->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     327);
#line 327
    tmp = 1;
    }
  }
  {
#line 329
  tmp___0 = _glp_lpp_append_tqe(lpp, 4, (int )sizeof(FIXED_COL ));
#line 329
  info = (FIXED_COL *)tmp___0;
#line 330
  info->q = col->j;
#line 331
  info->val = col->lb;
#line 332
  info->c = col->c;
#line 333
  info->ptr = (LPPLFE *)((void *)0);
#line 335
  aij = col->ptr;
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 335
      goto while_break;
    }
    {
#line 336
    row = aij->row;
#line 337
    tmp___1 = _glp_dmp_get_atom(lpp->tqe_pool, (int )sizeof(LPPLFE ));
#line 337
    lfe = (LPPLFE *)tmp___1;
#line 338
    lfe->ref = row->i;
#line 339
    lfe->val = aij->val;
#line 340
    lfe->next = info->ptr;
#line 341
    info->ptr = lfe;
    }
#line 343
    if (row->lb == row->ub) {
#line 344
      tmp___2 = row->lb - aij->val * col->lb;
#line 344
      row->lb = tmp___2;
#line 344
      row->ub = tmp___2;
    } else {
#line 346
      if (row->lb != - 1.7976931348623157e+308) {
#line 346
        row->lb -= aij->val * col->lb;
      }
#line 347
      if (row->ub != 1.7976931348623157e+308) {
#line 347
        row->ub -= aij->val * col->lb;
      }
    }
#line 335
    aij = aij->c_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 351
  lpp->c0 += col->c * col->lb;
#line 353
  _glp_lpp_remove_col(lpp, col);
  }
#line 354
  return;
}
}
#line 357 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_fixed_col(LPP *lpp , FIXED_COL *info ) 
{ 
  LPPLFE *lfe ;
  double dual ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 360
  if (1 <= info->q) {
#line 360
    if (info->q <= lpp->ncols) {
#line 360
      tmp = 1;
    } else {
      {
#line 360
      _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       360);
#line 360
      tmp = 1;
      }
    }
  } else {
    {
#line 360
    _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     360);
#line 360
    tmp = 1;
    }
  }
#line 361
  if (*(lpp->col_stat + info->q) == 0) {
#line 361
    tmp___0 = 1;
  } else {
    {
#line 361
    _glp_lib_xassert("lpp->col_stat[info->q] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     361);
#line 361
    tmp___0 = 1;
    }
  }
#line 363
  *(lpp->col_stat + info->q) = 144;
#line 365
  *(lpp->col_prim + info->q) = info->val;
#line 368
  dual = info->c;
#line 369
  lfe = info->ptr;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 369
      goto while_break;
    }
#line 370
    if (1 <= lfe->ref) {
#line 370
      if (lfe->ref <= lpp->nrows) {
#line 370
        tmp___1 = 1;
      } else {
        {
#line 370
        _glp_lib_xassert("1 <= lfe->ref && lfe->ref <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                         370);
#line 370
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 370
      _glp_lib_xassert("1 <= lfe->ref && lfe->ref <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       370);
#line 370
      tmp___1 = 1;
      }
    }
#line 371
    if (*(lpp->row_stat + lfe->ref) != 0) {
#line 371
      tmp___2 = 1;
    } else {
      {
#line 371
      _glp_lib_xassert("lpp->row_stat[lfe->ref] != 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       371);
#line 371
      tmp___2 = 1;
      }
    }
#line 372
    dual -= lfe->val * *(lpp->row_dual + lfe->ref);
#line 373
    *(lpp->row_prim + lfe->ref) += lfe->val * info->val;
#line 369
    lfe = lfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  *(lpp->col_dual + info->q) = dual;
#line 376
  return;
}
}
#line 426 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static int process_row_sngton1(LPP *lpp , LPPROW *row ) 
{ 
  ROW_SNGTON1 *info ;
  LPPCOL *col ;
  LPPAIJ *aij ;
  double val ;
  double eps ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 433
  if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 433
    if ((unsigned long )(row->ptr)->r_next == (unsigned long )((void *)0)) {
#line 433
      tmp = 1;
    } else {
      {
#line 433
      _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       433);
#line 433
      tmp = 1;
      }
    }
  } else {
    {
#line 433
    _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     433);
#line 433
    tmp = 1;
    }
  }
#line 434
  if (row->lb == row->ub) {
#line 434
    tmp___0 = 1;
  } else {
    {
#line 434
    _glp_lib_xassert("row->lb == row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     434);
#line 434
    tmp___0 = 1;
    }
  }
#line 436
  aij = row->ptr;
#line 437
  val = row->lb / aij->val;
#line 439
  col = aij->col;
#line 440
  if (col->lb != - 1.7976931348623157e+308) {
    {
#line 441
    tmp___1 = fabs(col->lb);
#line 441
    eps = 1e-5 * (1.0 + tmp___1);
    }
#line 442
    if (val < col->lb - eps) {
#line 442
      return (1);
    }
  }
#line 444
  if (col->ub != 1.7976931348623157e+308) {
    {
#line 445
    tmp___2 = fabs(col->ub);
#line 445
    eps = 1e-5 * (1.0 + tmp___2);
    }
#line 446
    if (val > col->ub + eps) {
#line 446
      return (1);
    }
  }
  {
#line 449
  tmp___3 = _glp_lpp_append_tqe(lpp, 5, (int )sizeof(ROW_SNGTON1 ));
#line 449
  info = (ROW_SNGTON1 *)tmp___3;
#line 450
  info->p = row->i;
#line 451
  info->q = col->j;
#line 452
  info->apq = aij->val;
#line 454
  _glp_lpp_remove_row(lpp, row);
#line 456
  tmp___4 = val;
#line 456
  col->ub = tmp___4;
#line 456
  col->lb = tmp___4;
#line 458
  process_fixed_col(lpp, col);
  }
#line 459
  return (0);
}
}
#line 462 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_row_sngton1(LPP *lpp , ROW_SNGTON1 *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 464
  if (1 <= info->p) {
#line 464
    if (info->p <= lpp->nrows) {
#line 464
      tmp = 1;
    } else {
      {
#line 464
      _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       464);
#line 464
      tmp = 1;
      }
    }
  } else {
    {
#line 464
    _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     464);
#line 464
    tmp = 1;
    }
  }
#line 465
  if (*(lpp->row_stat + info->p) == 0) {
#line 465
    tmp___0 = 1;
  } else {
    {
#line 465
    _glp_lib_xassert("lpp->row_stat[info->p] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     465);
#line 465
    tmp___0 = 1;
    }
  }
#line 468
  if (1 <= info->q) {
#line 468
    if (info->q <= lpp->ncols) {
#line 468
      tmp___1 = 1;
    } else {
      {
#line 468
      _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       468);
#line 468
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 468
    _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     468);
#line 468
    tmp___1 = 1;
    }
  }
#line 469
  if (*(lpp->col_stat + info->q) == 144) {
#line 469
    tmp___2 = 1;
  } else {
    {
#line 469
    _glp_lib_xassert("lpp->col_stat[info->q] == LPX_NS", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     469);
#line 469
    tmp___2 = 1;
    }
  }
#line 471
  *(lpp->row_stat + info->p) = 144;
#line 473
  *(lpp->row_prim + info->p) = info->apq * *(lpp->col_prim + info->q);
#line 475
  *(lpp->row_dual + info->p) = *(lpp->col_dual + info->q) / info->apq;
#line 477
  *(lpp->col_stat + info->q) = 140;
#line 478
  *(lpp->col_dual + info->q) = 0.0;
#line 479
  return;
}
}
#line 556 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static int process_row_sngton2(LPP *lpp , LPPROW *row ) 
{ 
  ROW_SNGTON2 *info ;
  LPPCOL *col ;
  LPPAIJ *aij ;
  double lb ;
  double ub ;
  double eps ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 563
  if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 563
    if ((unsigned long )(row->ptr)->r_next == (unsigned long )((void *)0)) {
#line 563
      tmp = 1;
    } else {
      {
#line 563
      _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       563);
#line 563
      tmp = 1;
      }
    }
  } else {
    {
#line 563
    _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     563);
#line 563
    tmp = 1;
    }
  }
#line 564
  if (row->lb != row->ub) {
#line 564
    tmp___0 = 1;
  } else {
    {
#line 564
    _glp_lib_xassert("row->lb != row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     564);
#line 564
    tmp___0 = 1;
    }
  }
#line 566
  if (row->lb == - 1.7976931348623157e+308) {
#line 566
    if (row->ub == 1.7976931348623157e+308) {
      {
#line 567
      process_free_row(lpp, row);
      }
#line 568
      goto done;
    }
  }
#line 571
  aij = row->ptr;
#line 572
  if (aij->val > 0.0) {
#line 573
    if (row->lb == - 1.7976931348623157e+308) {
#line 573
      lb = - 1.7976931348623157e+308;
    } else {
#line 573
      lb = row->lb / aij->val;
    }
#line 574
    if (row->ub == 1.7976931348623157e+308) {
#line 574
      ub = 1.7976931348623157e+308;
    } else {
#line 574
      ub = row->ub / aij->val;
    }
  } else {
#line 577
    if (row->ub == 1.7976931348623157e+308) {
#line 577
      lb = - 1.7976931348623157e+308;
    } else {
#line 577
      lb = row->ub / aij->val;
    }
#line 578
    if (row->lb == - 1.7976931348623157e+308) {
#line 578
      ub = 1.7976931348623157e+308;
    } else {
#line 578
      ub = row->lb / aij->val;
    }
  }
#line 581
  col = aij->col;
#line 582
  if (col->lb != - 1.7976931348623157e+308) {
    {
#line 583
    tmp___1 = fabs(col->lb);
#line 583
    eps = 1e-5 * (1.0 + tmp___1);
    }
#line 584
    if (ub < col->lb - eps) {
#line 584
      return (1);
    }
  }
#line 586
  if (col->ub != 1.7976931348623157e+308) {
    {
#line 587
    tmp___2 = fabs(col->ub);
#line 587
    eps = 1e-5 * (1.0 + tmp___2);
    }
#line 588
    if (lb > col->ub + eps) {
#line 588
      return (1);
    }
  }
#line 593
  if (col->lb == col->ub) {
    {
#line 595
    process_fixed_col(lpp, col);
    }
#line 597
    if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
#line 597
      tmp___3 = 1;
    } else {
      {
#line 597
      _glp_lib_xassert("row->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       597);
#line 597
      tmp___3 = 1;
      }
    }
    {
#line 599
    row->lb = - 1.7976931348623157e+308;
#line 599
    row->ub = 1.7976931348623157e+308;
#line 600
    tmp___4 = process_empty_row(lpp, row);
    }
#line 600
    if (tmp___4 == 0) {
#line 600
      tmp___5 = 1;
    } else {
      {
#line 600
      _glp_lib_xassert("process_empty_row(lpp, row) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       600);
#line 600
      tmp___5 = 1;
      }
    }
#line 601
    goto done;
  }
  {
#line 604
  tmp___6 = _glp_lpp_append_tqe(lpp, 6, (int )sizeof(ROW_SNGTON2 ));
#line 604
  info = (ROW_SNGTON2 *)tmp___6;
#line 605
  info->p = row->i;
#line 606
  info->q = col->j;
#line 607
  info->apq = aij->val;
  }
#line 608
  if (lb != - 1.7976931348623157e+308) {
#line 608
    if (lb > col->lb) {
#line 608
      tmp___7 = 1;
    } else {
#line 608
      tmp___7 = 0;
    }
  } else {
#line 608
    tmp___7 = 0;
  }
#line 608
  info->lb_changed = tmp___7;
#line 609
  if (ub != 1.7976931348623157e+308) {
#line 609
    if (ub < col->ub) {
#line 609
      tmp___8 = 1;
    } else {
#line 609
      tmp___8 = 0;
    }
  } else {
#line 609
    tmp___8 = 0;
  }
#line 609
  info->ub_changed = tmp___8;
#line 611
  if (info->lb_changed) {
#line 611
    col->lb = lb;
  }
#line 612
  if (info->ub_changed) {
#line 612
    col->ub = ub;
  }
  {
#line 614
  _glp_lpp_remove_row(lpp, row);
  }
#line 617
  if (col->lb != - 1.7976931348623157e+308) {
#line 617
    if (col->ub != 1.7976931348623157e+308) {
      {
#line 618
      tmp___9 = fabs(col->lb);
#line 618
      eps = 1e-7 * (1.0 + tmp___9);
#line 619
      tmp___12 = fabs(col->lb - col->ub);
      }
#line 619
      if (tmp___12 <= eps) {
        {
#line 620
        tmp___10 = fabs(col->lb);
#line 620
        tmp___11 = fabs(col->ub);
        }
#line 620
        if (tmp___10 <= tmp___11) {
#line 621
          col->ub = col->lb;
        } else {
#line 623
          col->lb = col->ub;
        }
        {
#line 624
        process_fixed_col(lpp, col);
        }
      }
    }
  }
  done: 
#line 627
  return (0);
}
}
#line 630 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_row_sngton2(LPP *lpp , ROW_SNGTON2 *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 632
  if (1 <= info->p) {
#line 632
    if (info->p <= lpp->nrows) {
#line 632
      tmp = 1;
    } else {
      {
#line 632
      _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       632);
#line 632
      tmp = 1;
      }
    }
  } else {
    {
#line 632
    _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     632);
#line 632
    tmp = 1;
    }
  }
#line 633
  if (*(lpp->row_stat + info->p) == 0) {
#line 633
    tmp___0 = 1;
  } else {
    {
#line 633
    _glp_lib_xassert("lpp->row_stat[info->p] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     633);
#line 633
    tmp___0 = 1;
    }
  }
#line 635
  if (1 <= info->q) {
#line 635
    if (info->q <= lpp->ncols) {
#line 635
      tmp___1 = 1;
    } else {
      {
#line 635
      _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       635);
#line 635
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 635
    _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     635);
#line 635
    tmp___1 = 1;
    }
  }
#line 636
  if (*(lpp->col_stat + info->q) != 0) {
#line 636
    tmp___2 = 1;
  } else {
    {
#line 636
    _glp_lib_xassert("lpp->col_stat[info->q] != 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     636);
#line 636
    tmp___2 = 1;
    }
  }
  {
#line 639
  if (*(lpp->col_stat + info->q) == 140) {
#line 639
    goto case_140;
  }
#line 646
  if (*(lpp->col_stat + info->q) == 141) {
#line 646
    goto nl;
  }
#line 671
  if (*(lpp->col_stat + info->q) == 142) {
#line 671
    goto nu;
  }
#line 696
  if (*(lpp->col_stat + info->q) == 143) {
#line 696
    goto case_143;
  }
#line 701
  if (*(lpp->col_stat + info->q) == 144) {
#line 701
    goto case_144;
  }
#line 719
  goto switch_default;
  case_140: /* CIL Label */ 
#line 641
  *(lpp->row_stat + info->p) = 140;
#line 642
  *(lpp->row_prim + info->p) = info->apq * *(lpp->col_prim + info->q);
#line 644
  *(lpp->row_dual + info->p) = 0.0;
#line 645
  goto switch_break;
  nl: 
  case_141: /* CIL Label */ 
#line 648
  if (info->lb_changed) {
#line 651
    if (info->apq > 0.0) {
#line 652
      *(lpp->row_stat + info->p) = 141;
    } else {
#line 654
      *(lpp->row_stat + info->p) = 142;
    }
#line 655
    *(lpp->row_prim + info->p) = info->apq * *(lpp->col_prim + info->q);
#line 657
    *(lpp->row_dual + info->p) = *(lpp->col_dual + info->q) / info->apq;
#line 660
    *(lpp->col_stat + info->q) = 140;
#line 661
    *(lpp->col_dual + info->q) = 0.0;
  } else {
#line 665
    *(lpp->row_stat + info->p) = 140;
#line 666
    *(lpp->row_prim + info->p) = info->apq * *(lpp->col_prim + info->q);
#line 668
    *(lpp->row_dual + info->p) = 0.0;
  }
#line 670
  goto switch_break;
  nu: 
  case_142: /* CIL Label */ 
#line 673
  if (info->ub_changed) {
#line 676
    if (info->apq > 0.0) {
#line 677
      *(lpp->row_stat + info->p) = 142;
    } else {
#line 679
      *(lpp->row_stat + info->p) = 141;
    }
#line 680
    *(lpp->row_prim + info->p) = info->apq * *(lpp->col_prim + info->q);
#line 682
    *(lpp->row_dual + info->p) = *(lpp->col_dual + info->q) / info->apq;
#line 685
    *(lpp->col_stat + info->q) = 140;
#line 686
    *(lpp->col_dual + info->q) = 0.0;
  } else {
#line 690
    *(lpp->row_stat + info->p) = 140;
#line 691
    *(lpp->row_prim + info->p) = info->apq * *(lpp->col_prim + info->q);
#line 693
    *(lpp->row_dual + info->p) = 0.0;
  }
#line 695
  goto switch_break;
  case_143: /* CIL Label */ 
#line 699
  if ((unsigned long )lpp != (unsigned long )lpp) {
#line 699
    tmp___3 = 1;
  } else {
    {
#line 699
    _glp_lib_xassert("lpp != lpp", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     699);
#line 699
    tmp___3 = 1;
    }
  }
  case_144: /* CIL Label */ 
#line 708
  if (*(lpp->col_dual + info->q) >= 0.0) {
#line 710
    *(lpp->col_stat + info->q) = 141;
#line 711
    goto nl;
  } else {
#line 715
    *(lpp->col_stat + info->q) = 142;
#line 716
    goto nu;
  }
  switch_default: /* CIL Label */ 
  {
#line 720
  _glp_lib_xassert("0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c", 720);
  }
  switch_break: /* CIL Label */ ;
  }
#line 722
  return;
}
}
#line 842 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void process_col_sngton1(LPP *lpp , LPPCOL *col ) 
{ 
  COL_SNGTON1 *info ;
  LPPROW *row ;
  LPPAIJ *aij ;
  double lb ;
  double ub ;
  double eps ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 849
  if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 849
    if ((unsigned long )(col->ptr)->c_next == (unsigned long )((void *)0)) {
#line 849
      tmp = 1;
    } else {
      {
#line 849
      _glp_lib_xassert("col->ptr != NULL && col->ptr->c_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       849);
#line 849
      tmp = 1;
      }
    }
  } else {
    {
#line 849
    _glp_lib_xassert("col->ptr != NULL && col->ptr->c_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     849);
#line 849
    tmp = 1;
    }
  }
#line 851
  aij = col->ptr;
#line 852
  row = aij->row;
#line 853
  if (row->lb == row->ub) {
#line 853
    tmp___0 = 1;
  } else {
    {
#line 853
    _glp_lib_xassert("row->lb == row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     853);
#line 853
    tmp___0 = 1;
    }
  }
#line 856
  if (col->lb == col->ub) {
    {
#line 857
    process_fixed_col(lpp, col);
    }
#line 858
    goto done;
  }
  {
#line 861
  tmp___1 = _glp_lpp_append_tqe(lpp, 7, (int )sizeof(COL_SNGTON1 ));
#line 861
  info = (COL_SNGTON1 *)tmp___1;
#line 862
  info->p = row->i;
#line 863
  info->q = col->j;
#line 864
  info->rhs = row->lb;
#line 865
  info->c = col->c;
#line 866
  info->apq = aij->val;
  }
#line 868
  if (info->apq > 0.0) {
#line 869
    if (col->ub == 1.7976931348623157e+308) {
#line 869
      lb = - 1.7976931348623157e+308;
    } else {
#line 869
      lb = info->rhs - info->apq * col->ub;
    }
#line 871
    if (col->lb == - 1.7976931348623157e+308) {
#line 871
      ub = 1.7976931348623157e+308;
    } else {
#line 871
      ub = info->rhs - info->apq * col->lb;
    }
  } else {
#line 875
    if (col->lb == - 1.7976931348623157e+308) {
#line 875
      lb = - 1.7976931348623157e+308;
    } else {
#line 875
      lb = info->rhs - info->apq * col->lb;
    }
#line 877
    if (col->ub == 1.7976931348623157e+308) {
#line 877
      ub = 1.7976931348623157e+308;
    } else {
#line 877
      ub = info->rhs - info->apq * col->ub;
    }
  }
#line 880
  row->lb = lb;
#line 881
  row->ub = ub;
#line 884
  if (row->lb != - 1.7976931348623157e+308) {
#line 884
    if (row->ub != 1.7976931348623157e+308) {
      {
#line 885
      tmp___2 = fabs(row->lb);
#line 885
      eps = 1e-7 * (1.0 + tmp___2);
#line 886
      tmp___5 = fabs(row->lb - row->ub);
      }
#line 886
      if (tmp___5 <= eps) {
        {
#line 887
        tmp___3 = fabs(row->lb);
#line 887
        tmp___4 = fabs(row->ub);
        }
#line 887
        if (tmp___3 <= tmp___4) {
#line 888
          row->ub = row->lb;
        } else {
#line 890
          row->lb = row->ub;
        }
      }
    }
  }
  {
#line 894
  _glp_lpp_remove_col(lpp, col);
#line 896
  aij = row->ptr;
  }
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 896
      goto while_break;
    }
#line 897
    (aij->col)->c -= info->c * (aij->val / info->apq);
#line 896
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  lpp->c0 += info->c * (info->rhs / info->apq);
  done: 
#line 899
  return;
}
}
#line 902 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_col_sngton1(LPP *lpp , COL_SNGTON1 *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 904
  if (1 <= info->p) {
#line 904
    if (info->p <= lpp->nrows) {
#line 904
      tmp = 1;
    } else {
      {
#line 904
      _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       904);
#line 904
      tmp = 1;
      }
    }
  } else {
    {
#line 904
    _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     904);
#line 904
    tmp = 1;
    }
  }
#line 905
  if (*(lpp->row_stat + info->p) != 0) {
#line 905
    tmp___0 = 1;
  } else {
    {
#line 905
    _glp_lib_xassert("lpp->row_stat[info->p] != 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     905);
#line 905
    tmp___0 = 1;
    }
  }
#line 907
  if (1 <= info->q) {
#line 907
    if (info->q <= lpp->ncols) {
#line 907
      tmp___1 = 1;
    } else {
      {
#line 907
      _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       907);
#line 907
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 907
    _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     907);
#line 907
    tmp___1 = 1;
    }
  }
#line 908
  if (*(lpp->col_stat + info->q) == 0) {
#line 908
    tmp___2 = 1;
  } else {
    {
#line 908
    _glp_lib_xassert("lpp->col_stat[info->q] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     908);
#line 908
    tmp___2 = 1;
    }
  }
  {
#line 911
  if (*(lpp->row_stat + info->p) == 140) {
#line 911
    goto case_140;
  }
#line 915
  if (*(lpp->row_stat + info->p) == 141) {
#line 915
    goto nl;
  }
#line 920
  if (*(lpp->row_stat + info->p) == 142) {
#line 920
    goto nu;
  }
#line 925
  if (*(lpp->row_stat + info->p) == 143) {
#line 925
    goto case_143;
  }
#line 930
  if (*(lpp->row_stat + info->p) == 144) {
#line 930
    goto case_144;
  }
#line 942
  goto switch_default;
  case_140: /* CIL Label */ 
#line 913
  *(lpp->col_stat + info->q) = 140;
#line 914
  goto switch_break;
  nl: 
  case_141: /* CIL Label */ 
#line 917
  if (info->apq > 0.0) {
#line 917
    *(lpp->col_stat + info->q) = 142;
  } else {
#line 917
    *(lpp->col_stat + info->q) = 141;
  }
#line 919
  goto switch_break;
  nu: 
  case_142: /* CIL Label */ 
#line 922
  if (info->apq > 0.0) {
#line 922
    *(lpp->col_stat + info->q) = 141;
  } else {
#line 922
    *(lpp->col_stat + info->q) = 142;
  }
#line 924
  goto switch_break;
  case_143: /* CIL Label */ 
#line 927
  if ((unsigned long )lpp != (unsigned long )lpp) {
#line 927
    tmp___3 = 1;
  } else {
    {
#line 927
    _glp_lib_xassert("lpp != lpp", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     927);
#line 927
    tmp___3 = 1;
    }
  }
#line 928
  *(lpp->col_stat + info->q) = 143;
#line 929
  goto switch_break;
  case_144: /* CIL Label */ 
#line 940
  if (*(lpp->row_dual + info->p) >= 0.0) {
#line 940
    goto nl;
  } else {
#line 940
    goto nu;
  }
  switch_default: /* CIL Label */ 
#line 943
  if ((unsigned long )lpp != (unsigned long )lpp) {
#line 943
    tmp___4 = 1;
  } else {
    {
#line 943
    _glp_lib_xassert("lpp != lpp", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     943);
#line 943
    tmp___4 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 946
  *(lpp->col_prim + info->q) = (info->rhs - *(lpp->row_prim + info->p)) / info->apq;
#line 949
  *(lpp->col_dual + info->q) = - info->apq * *(lpp->row_dual + info->p);
#line 951
  *(lpp->row_stat + info->p) = 144;
#line 953
  *(lpp->row_prim + info->p) = info->rhs;
#line 955
  *(lpp->row_dual + info->p) = (info->c - *(lpp->col_dual + info->q)) / info->apq;
#line 957
  return;
}
}
#line 1030 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static int process_col_sngton2(LPP *lpp , LPPCOL *col ) 
{ 
  COL_SNGTON2 *info ;
  LPPROW *row ;
  LPPAIJ *apq ;
  LPPAIJ *aij ;
  double lb ;
  double ub ;
  double eps ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1037
  if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 1037
    if ((unsigned long )(col->ptr)->c_next == (unsigned long )((void *)0)) {
#line 1037
      tmp = 1;
    } else {
      {
#line 1037
      _glp_lib_xassert("col->ptr != NULL && col->ptr->c_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1037);
#line 1037
      tmp = 1;
      }
    }
  } else {
    {
#line 1037
    _glp_lib_xassert("col->ptr != NULL && col->ptr->c_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1037);
#line 1037
    tmp = 1;
    }
  }
#line 1039
  apq = col->ptr;
#line 1040
  row = apq->row;
#line 1041
  if (row->lb != row->ub) {
#line 1041
    tmp___0 = 1;
  } else {
    {
#line 1041
    _glp_lib_xassert("row->lb != row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1041);
#line 1041
    tmp___0 = 1;
    }
  }
#line 1044
  if (col->lb == col->ub) {
    {
#line 1045
    process_fixed_col(lpp, col);
    }
#line 1046
    goto done;
  }
#line 1049
  if (row->lb == - 1.7976931348623157e+308) {
#line 1049
    if (row->ub == 1.7976931348623157e+308) {
      {
#line 1050
      process_free_row(lpp, row);
      }
#line 1051
      goto done;
    }
  }
#line 1054
  temp = 1.0 / apq->val;
#line 1055
  if (temp > 0.0) {
#line 1056
    if (row->lb == - 1.7976931348623157e+308) {
#line 1056
      lb = - 1.7976931348623157e+308;
    } else {
#line 1056
      lb = temp * row->lb;
    }
  } else
#line 1058
  if (row->ub == 1.7976931348623157e+308) {
#line 1058
    lb = - 1.7976931348623157e+308;
  } else {
#line 1058
    lb = temp * row->ub;
  }
#line 1059
  aij = row->ptr;
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1059
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1059
      goto while_break;
    }
#line 1060
    if (lb == - 1.7976931348623157e+308) {
#line 1060
      goto while_break;
    }
#line 1061
    if ((unsigned long )aij == (unsigned long )apq) {
#line 1061
      goto __Cont;
    }
#line 1062
    temp = - aij->val / apq->val;
#line 1063
    if (temp > 0.0) {
#line 1064
      if ((aij->col)->lb == - 1.7976931348623157e+308) {
#line 1065
        lb = - 1.7976931348623157e+308;
      } else {
#line 1067
        lb += temp * (aij->col)->lb;
      }
    } else
#line 1070
    if ((aij->col)->ub == 1.7976931348623157e+308) {
#line 1071
      lb = - 1.7976931348623157e+308;
    } else {
#line 1073
      lb += temp * (aij->col)->ub;
    }
    __Cont: /* CIL Label */ 
#line 1059
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  temp = 1.0 / apq->val;
#line 1078
  if (temp > 0.0) {
#line 1079
    if (row->ub == 1.7976931348623157e+308) {
#line 1079
      ub = 1.7976931348623157e+308;
    } else {
#line 1079
      ub = temp * row->ub;
    }
  } else
#line 1081
  if (row->lb == - 1.7976931348623157e+308) {
#line 1081
    ub = 1.7976931348623157e+308;
  } else {
#line 1081
    ub = temp * row->lb;
  }
#line 1082
  aij = row->ptr;
  {
#line 1082
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1082
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1082
      goto while_break___0;
    }
#line 1083
    if (ub == 1.7976931348623157e+308) {
#line 1083
      goto while_break___0;
    }
#line 1084
    if ((unsigned long )aij == (unsigned long )apq) {
#line 1084
      goto __Cont___0;
    }
#line 1085
    temp = - aij->val / apq->val;
#line 1086
    if (temp > 0.0) {
#line 1087
      if ((aij->col)->ub == 1.7976931348623157e+308) {
#line 1088
        ub = 1.7976931348623157e+308;
      } else {
#line 1090
        ub += temp * (aij->col)->ub;
      }
    } else
#line 1093
    if ((aij->col)->lb == - 1.7976931348623157e+308) {
#line 1094
      ub = 1.7976931348623157e+308;
    } else {
#line 1096
      ub += temp * (aij->col)->lb;
    }
    __Cont___0: /* CIL Label */ 
#line 1082
    aij = aij->r_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1100
  if (col->lb != - 1.7976931348623157e+308) {
    {
#line 1101
    tmp___1 = fabs(col->lb);
#line 1101
    eps = 1e-7 * (1.0 + tmp___1);
    }
#line 1102
    if (lb < col->lb - eps) {
#line 1102
      goto done;
    }
  }
#line 1105
  if (col->ub != 1.7976931348623157e+308) {
    {
#line 1106
    tmp___2 = fabs(col->ub);
#line 1106
    eps = 1e-7 * (1.0 * tmp___2);
    }
#line 1107
    if (ub > col->ub + eps) {
#line 1107
      goto done;
    }
  }
  {
#line 1110
  tmp___3 = _glp_lpp_append_tqe(lpp, 8, (int )sizeof(COL_SNGTON2 ));
#line 1110
  info = (COL_SNGTON2 *)tmp___3;
#line 1111
  info->p = row->i;
#line 1112
  info->q = col->j;
#line 1113
  info->stat = 0;
#line 1115
  col->lb = - 1.7976931348623157e+308;
#line 1115
  col->ub = 1.7976931348623157e+308;
#line 1118
  temp = col->c / apq->val;
  }
#line 1120
  if (temp > 0.0) {
#line 1122
    if (row->lb == - 1.7976931348623157e+308) {
#line 1122
      return (1);
    }
#line 1123
    info->stat = 141;
#line 1124
    row->ub = row->lb;
  } else
#line 1126
  if (temp < 0.0) {
#line 1128
    if (row->ub == 1.7976931348623157e+308) {
#line 1128
      return (1);
    }
#line 1129
    info->stat = 142;
#line 1130
    row->lb = row->ub;
  } else
#line 1134
  if (row->lb != - 1.7976931348623157e+308) {
#line 1135
    info->stat = 141;
#line 1136
    row->ub = row->lb;
  } else {
#line 1139
    if (row->ub != 1.7976931348623157e+308) {
#line 1139
      tmp___4 = 1;
    } else {
      {
#line 1139
      _glp_lib_xassert("row->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1139);
#line 1139
      tmp___4 = 1;
      }
    }
#line 1140
    info->stat = 142;
#line 1141
    row->lb = row->ub;
  }
  {
#line 1145
  process_col_sngton1(lpp, col);
  }
  done: 
#line 1146
  return (0);
}
}
#line 1149 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_col_sngton2(LPP *lpp , COL_SNGTON2 *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1152
  if (1 <= info->p) {
#line 1152
    if (info->p <= lpp->nrows) {
#line 1152
      tmp = 1;
    } else {
      {
#line 1152
      _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1152);
#line 1152
      tmp = 1;
      }
    }
  } else {
    {
#line 1152
    _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1152);
#line 1152
    tmp = 1;
    }
  }
#line 1153
  if (*(lpp->row_stat + info->p) == 144) {
#line 1153
    tmp___0 = 1;
  } else {
    {
#line 1153
    _glp_lib_xassert("lpp->row_stat[info->p] == LPX_NS", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1153);
#line 1153
    tmp___0 = 1;
    }
  }
#line 1156
  if (1 <= info->q) {
#line 1156
    if (info->q <= lpp->ncols) {
#line 1156
      tmp___1 = 1;
    } else {
      {
#line 1156
      _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1156);
#line 1156
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 1156
    _glp_lib_xassert("1 <= info->q && info->q <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1156);
#line 1156
    tmp___1 = 1;
    }
  }
#line 1157
  if (*(lpp->col_stat + info->q) == 140) {
#line 1157
    tmp___2 = 1;
  } else {
    {
#line 1157
    _glp_lib_xassert("lpp->col_stat[info->q] == LPX_BS", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1157);
#line 1157
    tmp___2 = 1;
    }
  }
#line 1159
  *(lpp->row_stat + info->p) = info->stat;
#line 1160
  return;
}
}
#line 1256 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void process_forcing_row(LPP *lpp , LPPROW *row , int at ) 
{ 
  FORCING_ROW *info ;
  LPPCOL *col ;
  LPPAIJ *aij ;
  LPPAIJ *next_aij ;
  LPPLFX *lfx ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1263
  aij = row->ptr;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1263
      goto while_break;
    }
#line 1264
    col = aij->col;
#line 1265
    next_aij = aij->r_next;
#line 1266
    if (col->lb == col->ub) {
      {
#line 1266
      process_fixed_col(lpp, col);
      }
    }
#line 1263
    aij = next_aij;
  }
  while_break: /* CIL Label */ ;
  }
#line 1270
  if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
    {
#line 1271
    row->lb = - 1.7976931348623157e+308;
#line 1271
    row->ub = 1.7976931348623157e+308;
#line 1272
    tmp = process_empty_row(lpp, row);
    }
#line 1272
    if (tmp == 0) {
#line 1272
      tmp___0 = 1;
    } else {
      {
#line 1272
      _glp_lib_xassert("process_empty_row(lpp, row) == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1272);
#line 1272
      tmp___0 = 1;
      }
    }
#line 1273
    goto done;
  }
  {
#line 1276
  tmp___1 = _glp_lpp_append_tqe(lpp, 9, (int )sizeof(FORCING_ROW ));
#line 1276
  info = (FORCING_ROW *)tmp___1;
#line 1277
  info->p = row->i;
  }
#line 1278
  if (row->lb == row->ub) {
#line 1280
    info->stat = 144;
#line 1281
    info->bnd = row->lb;
  } else
#line 1283
  if (at == 0) {
#line 1285
    info->stat = 141;
#line 1286
    if (row->lb != - 1.7976931348623157e+308) {
#line 1286
      tmp___2 = 1;
    } else {
      {
#line 1286
      _glp_lib_xassert("row->lb != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1286);
#line 1286
      tmp___2 = 1;
      }
    }
#line 1287
    info->bnd = row->lb;
  } else {
#line 1291
    info->stat = 142;
#line 1292
    if (row->ub != 1.7976931348623157e+308) {
#line 1292
      tmp___3 = 1;
    } else {
      {
#line 1292
      _glp_lib_xassert("row->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1292);
#line 1292
      tmp___3 = 1;
      }
    }
#line 1293
    info->bnd = row->ub;
  }
#line 1295
  info->ptr = (LPPLFX *)((void *)0);
#line 1302
  aij = row->ptr;
  {
#line 1302
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1302
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1302
      goto while_break___0;
    }
    {
#line 1303
    col = aij->col;
#line 1305
    tmp___4 = _glp_dmp_get_atom(lpp->tqe_pool, (int )sizeof(LPPLFX ));
#line 1305
    lfx = (LPPLFX *)tmp___4;
#line 1306
    lfx->ref = col->j;
#line 1307
    lfx->flag = 0;
#line 1308
    lfx->val = aij->val;
#line 1309
    lfx->next = info->ptr;
#line 1310
    info->ptr = lfx;
    }
#line 1312
    if (col->lb != col->ub) {
#line 1312
      tmp___5 = 1;
    } else {
      {
#line 1312
      _glp_lib_xassert("col->lb != col->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1312);
#line 1312
      tmp___5 = 1;
      }
    }
#line 1314
    if (at == 0) {
#line 1314
      if (aij->val < 0.0) {
#line 1314
        goto _L;
      } else {
#line 1314
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1314
    if (at != 0) {
#line 1314
      if (aij->val > 0.0) {
        _L: /* CIL Label */ 
#line 1316
        lfx->flag = 141;
#line 1317
        if (col->lb != - 1.7976931348623157e+308) {
#line 1317
          tmp___6 = 1;
        } else {
          {
#line 1317
          _glp_lib_xassert("col->lb != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                           1317);
#line 1317
          tmp___6 = 1;
          }
        }
#line 1318
        col->ub = col->lb;
      } else {
#line 1314
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1322
      lfx->flag = 142;
#line 1323
      if (col->ub != 1.7976931348623157e+308) {
#line 1323
        tmp___7 = 1;
      } else {
        {
#line 1323
        _glp_lib_xassert("col->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                         1323);
#line 1323
        tmp___7 = 1;
        }
      }
#line 1324
      col->lb = col->ub;
    }
#line 1329
    if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 1330
      (aij->col)->ptr = aij->c_next;
    } else {
#line 1332
      (aij->c_prev)->c_next = aij->c_next;
    }
#line 1333
    if (! ((unsigned long )aij->c_next == (unsigned long )((void *)0))) {
#line 1336
      (aij->c_next)->c_prev = aij->c_prev;
    }
    {
#line 1338
    process_fixed_col(lpp, col);
#line 1302
    aij = aij->r_next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1341
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1341
    if (! ((unsigned long )row->ptr != (unsigned long )((void *)0))) {
#line 1341
      goto while_break___1;
    }
    {
#line 1343
    aij = row->ptr;
#line 1345
    row->ptr = aij->r_next;
#line 1347
    _glp_dmp_free_atom(lpp->aij_pool, (void *)aij, (int )sizeof(LPPAIJ ));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1350
  _glp_lpp_remove_row(lpp, row);
  }
  done: 
#line 1351
  return;
}
}
#line 1354 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static void recover_forcing_row(LPP *lpp , FORCING_ROW *info ) 
{ 
  LPPLFX *lfx ;
  LPPLFX *that ;
  double big ;
  double lambda ;
  double pi ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 1358
  if (1 <= info->p) {
#line 1358
    if (info->p <= lpp->nrows) {
#line 1358
      tmp = 1;
    } else {
      {
#line 1358
      _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1358);
#line 1358
      tmp = 1;
      }
    }
  } else {
    {
#line 1358
    _glp_lib_xassert("1 <= info->p && info->p <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1358);
#line 1358
    tmp = 1;
    }
  }
#line 1359
  if (*(lpp->row_stat + info->p) == 0) {
#line 1359
    tmp___0 = 1;
  } else {
    {
#line 1359
    _glp_lib_xassert("lpp->row_stat[info->p] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                     1359);
#line 1359
    tmp___0 = 1;
    }
  }
#line 1362
  lfx = info->ptr;
  {
#line 1362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1362
    if (! ((unsigned long )lfx != (unsigned long )((void *)0))) {
#line 1362
      goto while_break;
    }
#line 1363
    if (1 <= lfx->ref) {
#line 1363
      if (lfx->ref <= lpp->ncols) {
#line 1363
        tmp___1 = 1;
      } else {
        {
#line 1363
        _glp_lib_xassert("1 <= lfx->ref && lfx->ref <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                         1363);
#line 1363
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 1363
      _glp_lib_xassert("1 <= lfx->ref && lfx->ref <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1363);
#line 1363
      tmp___1 = 1;
      }
    }
#line 1364
    if (*(lpp->col_stat + lfx->ref) == 144) {
#line 1364
      tmp___2 = 1;
    } else {
      {
#line 1364
      _glp_lib_xassert("lpp->col_stat[lfx->ref] == LPX_NS", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1364);
#line 1364
      tmp___2 = 1;
      }
    }
#line 1362
    lfx = lfx->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1368
  that = (LPPLFX *)((void *)0);
#line 1368
  big = 0.0;
#line 1369
  lfx = info->ptr;
  {
#line 1369
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1369
    if (! ((unsigned long )lfx != (unsigned long )((void *)0))) {
#line 1369
      goto while_break___0;
    }
    {
#line 1370
    lambda = *(lpp->col_dual + lfx->ref);
#line 1371
    temp = fabs(lambda / lfx->val);
    }
    {
#line 1373
    if (lfx->flag == 141) {
#line 1373
      goto case_141;
    }
#line 1377
    if (lfx->flag == 142) {
#line 1377
      goto case_142;
    }
#line 1381
    goto switch_default;
    case_141: /* CIL Label */ 
#line 1375
    if (lambda < 0.0) {
#line 1375
      if (big < temp) {
#line 1375
        that = lfx;
#line 1375
        big = temp;
      }
    }
#line 1376
    goto switch_break;
    case_142: /* CIL Label */ 
#line 1379
    if (lambda > 0.0) {
#line 1379
      if (big < temp) {
#line 1379
        that = lfx;
#line 1379
        big = temp;
      }
    }
#line 1380
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1382
    if ((unsigned long )lfx != (unsigned long )lfx) {
#line 1382
      tmp___3 = 1;
    } else {
      {
#line 1382
      _glp_lib_xassert("lfx != lfx", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1382);
#line 1382
      tmp___3 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 1369
    lfx = lfx->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1386
  if ((unsigned long )that == (unsigned long )((void *)0)) {
#line 1388
    *(lpp->row_stat + info->p) = 140;
#line 1389
    *(lpp->row_prim + info->p) = info->bnd;
#line 1390
    *(lpp->row_dual + info->p) = 0.0;
#line 1391
    lfx = info->ptr;
    {
#line 1391
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1391
      if (! ((unsigned long )lfx != (unsigned long )((void *)0))) {
#line 1391
        goto while_break___1;
      }
#line 1392
      *(lpp->col_stat + lfx->ref) = lfx->flag;
#line 1391
      lfx = lfx->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 1398
    pi = *(lpp->col_dual + that->ref) / that->val;
#line 1400
    *(lpp->row_stat + info->p) = info->stat;
#line 1401
    *(lpp->row_prim + info->p) = info->bnd;
#line 1402
    *(lpp->row_dual + info->p) = pi;
#line 1404
    lfx = info->ptr;
    {
#line 1404
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1404
      if (! ((unsigned long )lfx != (unsigned long )((void *)0))) {
#line 1404
        goto while_break___2;
      }
#line 1405
      if ((unsigned long )lfx == (unsigned long )that) {
#line 1407
        *(lpp->col_stat + lfx->ref) = 140;
#line 1408
        *(lpp->col_dual + lfx->ref) = 0.0;
      } else {
#line 1412
        *(lpp->col_stat + lfx->ref) = lfx->flag;
#line 1413
        *(lpp->col_dual + lfx->ref) -= lfx->val * pi;
      }
#line 1404
      lfx = lfx->next;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1417
  return;
}
}
#line 1466 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
static int analyze_row(LPP *lpp , LPPROW *row ) 
{ 
  LPPCOL *col ;
  LPPAIJ *aij ;
  double lb ;
  double ub ;
  double eps ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1471
  lb = 0.0;
#line 1472
  aij = row->ptr;
  {
#line 1472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1472
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1472
      goto while_break;
    }
#line 1473
    if (lb == - 1.7976931348623157e+308) {
#line 1473
      goto while_break;
    }
#line 1474
    col = aij->col;
#line 1475
    if (aij->val > 0.0) {
#line 1476
      if (col->lb == - 1.7976931348623157e+308) {
#line 1477
        lb = - 1.7976931348623157e+308;
      } else {
#line 1479
        lb += aij->val * col->lb;
      }
    } else
#line 1482
    if (col->ub == 1.7976931348623157e+308) {
#line 1483
      lb = - 1.7976931348623157e+308;
    } else {
#line 1485
      lb += aij->val * col->ub;
    }
#line 1472
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1489
  ub = 0.0;
#line 1490
  aij = row->ptr;
  {
#line 1490
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1490
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1490
      goto while_break___0;
    }
#line 1491
    if (ub == 1.7976931348623157e+308) {
#line 1491
      goto while_break___0;
    }
#line 1492
    col = aij->col;
#line 1493
    if (aij->val > 0.0) {
#line 1494
      if (col->ub == 1.7976931348623157e+308) {
#line 1495
        ub = 1.7976931348623157e+308;
      } else {
#line 1497
        ub += aij->val * col->ub;
      }
    } else
#line 1500
    if (col->lb == - 1.7976931348623157e+308) {
#line 1501
      ub = 1.7976931348623157e+308;
    } else {
#line 1503
      ub += aij->val * col->lb;
    }
#line 1490
    aij = aij->r_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1507
  if (row->lb != - 1.7976931348623157e+308) {
    {
#line 1508
    tmp = fabs(row->lb);
#line 1508
    eps = 1e-5 * (1.0 + tmp);
    }
#line 1509
    if (ub < row->lb - eps) {
#line 1509
      return (1);
    }
  }
#line 1511
  if (row->ub != 1.7976931348623157e+308) {
    {
#line 1512
    tmp___0 = fabs(row->ub);
#line 1512
    eps = 1e-5 * (1.0 + tmp___0);
    }
#line 1513
    if (lb > row->ub + eps) {
#line 1513
      return (1);
    }
  }
#line 1516
  if (row->lb != - 1.7976931348623157e+308) {
    {
#line 1517
    tmp___1 = fabs(row->lb);
#line 1517
    eps = 1e-7 * (1.0 + tmp___1);
    }
#line 1518
    if (ub <= row->lb + eps) {
      {
#line 1519
      process_forcing_row(lpp, row, 0);
      }
#line 1520
      goto done;
    }
  }
#line 1524
  if (row->ub != 1.7976931348623157e+308) {
    {
#line 1525
    tmp___2 = fabs(row->ub);
#line 1525
    eps = 1e-7 * (1.0 + tmp___2);
    }
#line 1526
    if (lb >= row->ub - eps) {
      {
#line 1527
      process_forcing_row(lpp, row, 1);
      }
#line 1528
      goto done;
    }
  }
#line 1532
  if (row->lb != - 1.7976931348623157e+308) {
    {
#line 1533
    tmp___3 = fabs(row->lb);
#line 1533
    eps = 1.001e-7 * (1.0 + tmp___3);
    }
#line 1534
    if (lb >= row->lb - eps) {
#line 1539
      if (row->lb != row->ub) {
#line 1539
        tmp___4 = 1;
      } else {
        {
#line 1539
        _glp_lib_xassert("row->lb != row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                         1539);
#line 1539
        tmp___4 = 1;
        }
      }
      {
#line 1540
      row->lb = - 1.7976931348623157e+308;
#line 1541
      _glp_lpp_enque_row(lpp, row);
      }
    }
  }
#line 1545
  if (row->ub != 1.7976931348623157e+308) {
    {
#line 1546
    tmp___5 = fabs(row->ub);
#line 1546
    eps = 1.001e-7 * (1.0 + tmp___5);
    }
#line 1547
    if (ub <= row->ub + eps) {
#line 1552
      if (row->lb != row->ub) {
#line 1552
        tmp___6 = 1;
      } else {
        {
#line 1552
        _glp_lib_xassert("row->lb != row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                         1552);
#line 1552
        tmp___6 = 1;
        }
      }
      {
#line 1553
      row->ub = 1.7976931348623157e+308;
#line 1554
      _glp_lpp_enque_row(lpp, row);
      }
    }
  }
  done: 
#line 1557
  return (0);
}
}
#line 1583 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
int _glp_lpp_presolve(LPP *lpp ) 
{ 
  LPPROW *row ;
  LPPCOL *col ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1594
    if (! ((unsigned long )lpp->row_que != (unsigned long )((void *)0))) {
#line 1594
      if (! ((unsigned long )lpp->col_que != (unsigned long )((void *)0))) {
#line 1594
        goto while_break;
      }
    }
    {
#line 1596
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1596
      if (! ((unsigned long )lpp->row_que != (unsigned long )((void *)0))) {
#line 1596
        goto while_break___0;
      }
      {
#line 1598
      row = lpp->row_que;
#line 1600
      _glp_lpp_deque_row(lpp, row);
      }
#line 1602
      if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
        {
#line 1604
        tmp = process_empty_row(lpp, row);
        }
#line 1604
        if (tmp) {
#line 1604
          return (1);
        }
      } else
#line 1606
      if (row->lb == - 1.7976931348623157e+308) {
#line 1606
        if (row->ub == 1.7976931348623157e+308) {
          {
#line 1608
          process_free_row(lpp, row);
          }
        } else {
#line 1606
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1610
      if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 1610
        if ((unsigned long )(row->ptr)->r_next == (unsigned long )((void *)0)) {
#line 1610
          if (row->lb == row->ub) {
            {
#line 1613
            tmp___0 = process_row_sngton1(lpp, row);
            }
#line 1613
            if (tmp___0) {
#line 1613
              return (1);
            }
          } else {
#line 1610
            goto _L___2;
          }
        } else {
#line 1610
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 1615
      if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 1615
        if ((unsigned long )(row->ptr)->r_next == (unsigned long )((void *)0)) {
#line 1615
          if (row->lb != row->ub) {
            {
#line 1618
            tmp___1 = process_row_sngton2(lpp, row);
            }
#line 1618
            if (tmp___1) {
#line 1618
              return (1);
            }
          } else {
#line 1615
            goto _L___0;
          }
        } else {
#line 1615
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1622
        tmp___2 = analyze_row(lpp, row);
        }
#line 1622
        if (tmp___2) {
#line 1622
          return (1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1626
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1626
      if (! ((unsigned long )lpp->col_que != (unsigned long )((void *)0))) {
#line 1626
        goto while_break___1;
      }
      {
#line 1628
      col = lpp->col_que;
#line 1630
      _glp_lpp_deque_col(lpp, col);
      }
#line 1632
      if ((unsigned long )col->ptr == (unsigned long )((void *)0)) {
        {
#line 1634
        tmp___3 = process_empty_col(lpp, col);
        }
#line 1634
        if (tmp___3) {
#line 1634
          return (2);
        }
      } else
#line 1636
      if (col->lb == col->ub) {
        {
#line 1638
        process_fixed_col(lpp, col);
        }
      } else
#line 1640
      if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 1640
        if ((unsigned long )(col->ptr)->c_next == (unsigned long )((void *)0)) {
#line 1640
          if (((col->ptr)->row)->lb == ((col->ptr)->row)->ub) {
            {
#line 1643
            process_col_sngton1(lpp, col);
            }
          } else {
#line 1640
            goto _L___5;
          }
        } else {
#line 1640
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 1645
      if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 1645
        if ((unsigned long )(col->ptr)->c_next == (unsigned long )((void *)0)) {
#line 1645
          if (((col->ptr)->row)->lb != ((col->ptr)->row)->ub) {
            {
#line 1648
            tmp___4 = process_col_sngton2(lpp, col);
            }
#line 1648
            if (tmp___4) {
#line 1648
              return (2);
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1656
  return (0);
}
}
#line 1673 "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c"
void _glp_lpp_postsolve(LPP *lpp ) 
{ 
  LPPTQE *tqe ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1675
  tqe = lpp->tqe_list;
  {
#line 1675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1675
    if (! ((unsigned long )tqe != (unsigned long )((void *)0))) {
#line 1675
      goto while_break;
    }
    {
#line 1677
    if (tqe->type == 1) {
#line 1677
      goto case_1;
    }
#line 1680
    if (tqe->type == 2) {
#line 1680
      goto case_2;
    }
#line 1683
    if (tqe->type == 3) {
#line 1683
      goto case_3;
    }
#line 1686
    if (tqe->type == 4) {
#line 1686
      goto case_4;
    }
#line 1689
    if (tqe->type == 5) {
#line 1689
      goto case_5;
    }
#line 1692
    if (tqe->type == 6) {
#line 1692
      goto case_6;
    }
#line 1695
    if (tqe->type == 7) {
#line 1695
      goto case_7;
    }
#line 1698
    if (tqe->type == 8) {
#line 1698
      goto case_8;
    }
#line 1701
    if (tqe->type == 9) {
#line 1701
      goto case_9;
    }
#line 1704
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1678
    recover_empty_row(lpp, (EMPTY_ROW *)tqe->info);
    }
#line 1679
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1681
    recover_empty_col(lpp, (EMPTY_COL *)tqe->info);
    }
#line 1682
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1684
    recover_free_row(lpp, (FREE_ROW *)tqe->info);
    }
#line 1685
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1687
    recover_fixed_col(lpp, (FIXED_COL *)tqe->info);
    }
#line 1688
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1690
    recover_row_sngton1(lpp, (ROW_SNGTON1 *)tqe->info);
    }
#line 1691
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1693
    recover_row_sngton2(lpp, (ROW_SNGTON2 *)tqe->info);
    }
#line 1694
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1696
    recover_col_sngton1(lpp, (COL_SNGTON1 *)tqe->info);
    }
#line 1697
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1699
    recover_col_sngton2(lpp, (COL_SNGTON2 *)tqe->info);
    }
#line 1700
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 1702
    recover_forcing_row(lpp, (FORCING_ROW *)tqe->info);
    }
#line 1703
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1705
    if (tqe->type != tqe->type) {
#line 1705
      tmp = 1;
    } else {
      {
#line 1705
      _glp_lib_xassert("tqe->type != tqe->type", "/home/wslee/benchmarks/glpk-4.38/src/glplpp02.c",
                       1705);
#line 1705
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 1675
    tqe = tqe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1708
  return;
}
}
#line 275 "/home/wslee/benchmarks/glpk-4.38/src/glplpp.h"
LPP *_glp_lpp_create_wksp(void) ;
#line 278
LPPROW *_glp_lpp_add_row(LPP *lpp , double lb , double ub ) ;
#line 281
LPPCOL *_glp_lpp_add_col(LPP *lpp , double lb , double ub , double c ) ;
#line 284
LPPAIJ *_glp_lpp_add_aij(LPP *lpp , LPPROW *row , LPPCOL *col , double val ) ;
#line 299
void _glp_lpp_enque_col(LPP *lpp , LPPCOL *col ) ;
#line 305
void _glp_lpp_load_orig(LPP *lpp , glp_prob *orig ) ;
#line 311
glp_prob *_glp_lpp_build_prob(LPP *lpp ) ;
#line 314
void _glp_lpp_alloc_sol(LPP *lpp ) ;
#line 317
void _glp_lpp_load_sol(LPP *lpp , glp_prob *prob ) ;
#line 320
void _glp_lpp_unload_sol(LPP *lpp , glp_prob *orig ) ;
#line 323
void _glp_lpp_delete_wksp(LPP *lpp ) ;
#line 46 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
LPP *_glp_lpp_create_wksp(void) 
{ 
  LPP *lpp ;
  void *tmp ;

  {
  {
#line 48
  tmp = _glp_lib_xmalloc((int )sizeof(LPP ));
#line 48
  lpp = (LPP *)tmp;
#line 49
  lpp->orig_m = 0;
#line 50
  lpp->orig_n = 0;
#line 51
  lpp->orig_nnz = 0;
#line 52
  lpp->orig_dir = 120;
#line 53
  lpp->nrows = 0;
#line 54
  lpp->ncols = 0;
#line 55
  lpp->row_pool = _glp_dmp_create_pool();
#line 56
  lpp->col_pool = _glp_dmp_create_pool();
#line 57
  lpp->aij_pool = _glp_dmp_create_pool();
#line 58
  lpp->row_ptr = (LPPROW *)((void *)0);
#line 59
  lpp->col_ptr = (LPPCOL *)((void *)0);
#line 60
  lpp->row_que = (LPPROW *)((void *)0);
#line 61
  lpp->col_que = (LPPCOL *)((void *)0);
#line 62
  lpp->c0 = 0.0;
#line 63
  lpp->tqe_pool = _glp_dmp_create_pool();
#line 64
  lpp->tqe_list = (LPPTQE *)((void *)0);
#line 65
  lpp->m = 0;
#line 66
  lpp->n = 0;
#line 67
  lpp->nnz = 0;
#line 68
  lpp->row_ref = (int *)((void *)0);
#line 69
  lpp->col_ref = (int *)((void *)0);
#line 70
  lpp->row_stat = (int *)((void *)0);
#line 71
  lpp->row_prim = (double *)((void *)0);
#line 72
  lpp->row_dual = (double *)((void *)0);
#line 73
  lpp->col_stat = (int *)((void *)0);
#line 74
  lpp->col_prim = (double *)((void *)0);
#line 75
  lpp->col_dual = (double *)((void *)0);
  }
#line 76
  return (lpp);
}
}
#line 102 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
LPPROW *_glp_lpp_add_row(LPP *lpp , double lb , double ub ) 
{ 
  LPPROW *row ;
  void *tmp ;
  LPPROW *tmp___0 ;

  {
  {
#line 104
  tmp = _glp_dmp_get_atom(lpp->row_pool, (int )sizeof(LPPROW ));
#line 104
  row = (LPPROW *)tmp;
#line 105
  (lpp->nrows) ++;
#line 105
  row->i = lpp->nrows;
#line 106
  row->lb = lb;
#line 107
  row->ub = ub;
#line 108
  row->ptr = (LPPAIJ *)((void *)0);
#line 109
  row->temp = 0;
#line 110
  row->prev = (LPPROW *)((void *)0);
#line 111
  row->next = lpp->row_ptr;
#line 112
  row->q_flag = 0;
#line 113
  tmp___0 = (LPPROW *)((void *)0);
#line 113
  row->q_next = tmp___0;
#line 113
  row->q_prev = tmp___0;
  }
#line 114
  if ((unsigned long )lpp->row_ptr != (unsigned long )((void *)0)) {
#line 114
    (lpp->row_ptr)->prev = row;
  }
  {
#line 115
  lpp->row_ptr = row;
#line 116
  _glp_lpp_enque_row(lpp, row);
  }
#line 117
  return (row);
}
}
#line 145 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
LPPCOL *_glp_lpp_add_col(LPP *lpp , double lb , double ub , double c ) 
{ 
  LPPCOL *col ;
  void *tmp ;
  LPPCOL *tmp___0 ;

  {
  {
#line 147
  tmp = _glp_dmp_get_atom(lpp->col_pool, (int )sizeof(LPPCOL ));
#line 147
  col = (LPPCOL *)tmp;
#line 148
  (lpp->ncols) ++;
#line 148
  col->j = lpp->ncols;
#line 149
  col->lb = lb;
#line 150
  col->ub = ub;
#line 151
  col->c = c;
#line 152
  col->ptr = (LPPAIJ *)((void *)0);
#line 153
  col->prev = (LPPCOL *)((void *)0);
#line 154
  col->next = lpp->col_ptr;
#line 155
  col->q_flag = 0;
#line 156
  tmp___0 = (LPPCOL *)((void *)0);
#line 156
  col->q_next = tmp___0;
#line 156
  col->q_prev = tmp___0;
  }
#line 157
  if ((unsigned long )lpp->col_ptr != (unsigned long )((void *)0)) {
#line 157
    (lpp->col_ptr)->prev = col;
  }
  {
#line 158
  lpp->col_ptr = col;
#line 159
  _glp_lpp_enque_col(lpp, col);
  }
#line 160
  return (col);
}
}
#line 188 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
LPPAIJ *_glp_lpp_add_aij(LPP *lpp , LPPROW *row , LPPCOL *col , double val ) 
{ 
  LPPAIJ *aij ;
  int tmp ;
  void *tmp___0 ;
  LPPAIJ *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 190
  if (val != 0.0) {
#line 190
    tmp = 1;
  } else {
    {
#line 190
    _glp_lib_xassert("val != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     190);
#line 190
    tmp = 1;
    }
  }
  {
#line 191
  tmp___0 = _glp_dmp_get_atom(lpp->aij_pool, (int )sizeof(LPPAIJ ));
#line 191
  aij = (LPPAIJ *)tmp___0;
#line 192
  aij->row = row;
#line 193
  aij->col = col;
#line 194
  aij->val = val;
#line 195
  aij->r_prev = (LPPAIJ *)((void *)0);
#line 196
  aij->r_next = row->ptr;
#line 197
  aij->c_prev = (LPPAIJ *)((void *)0);
#line 198
  aij->c_next = col->ptr;
  }
#line 199
  if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 199
    (row->ptr)->r_prev = aij;
  }
#line 200
  if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 200
    (col->ptr)->c_prev = aij;
  }
#line 201
  tmp___1 = aij;
#line 201
  col->ptr = tmp___1;
#line 201
  row->ptr = tmp___1;
#line 202
  return (aij);
}
}
#line 218 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_remove_row(LPP *lpp , LPPROW *row ) 
{ 
  LPPAIJ *aij ;

  {
  {
#line 221
  _glp_lpp_deque_row(lpp, row);
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )row->ptr != (unsigned long )((void *)0))) {
#line 223
      goto while_break;
    }
    {
#line 225
    aij = row->ptr;
#line 227
    _glp_lpp_enque_col(lpp, aij->col);
#line 229
    row->ptr = aij->r_next;
    }
#line 231
    if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 232
      (aij->col)->ptr = aij->c_next;
    } else {
#line 234
      (aij->c_prev)->c_next = aij->c_next;
    }
#line 235
    if (! ((unsigned long )aij->c_next == (unsigned long )((void *)0))) {
#line 238
      (aij->c_next)->c_prev = aij->c_prev;
    }
    {
#line 240
    _glp_dmp_free_atom(lpp->aij_pool, (void *)aij, (int )sizeof(LPPAIJ ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  if ((unsigned long )row->prev == (unsigned long )((void *)0)) {
#line 244
    lpp->row_ptr = row->next;
  } else {
#line 246
    (row->prev)->next = row->next;
  }
#line 247
  if (! ((unsigned long )row->next == (unsigned long )((void *)0))) {
#line 250
    (row->next)->prev = row->prev;
  }
  {
#line 252
  _glp_dmp_free_atom(lpp->row_pool, (void *)row, (int )sizeof(LPPROW ));
  }
#line 253
  return;
}
}
#line 269 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_remove_col(LPP *lpp , LPPCOL *col ) 
{ 
  LPPAIJ *aij ;

  {
  {
#line 272
  _glp_lpp_deque_col(lpp, col);
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! ((unsigned long )col->ptr != (unsigned long )((void *)0))) {
#line 274
      goto while_break;
    }
    {
#line 276
    aij = col->ptr;
#line 278
    _glp_lpp_enque_row(lpp, aij->row);
#line 280
    col->ptr = aij->c_next;
    }
#line 282
    if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 283
      (aij->row)->ptr = aij->r_next;
    } else {
#line 285
      (aij->r_prev)->r_next = aij->r_next;
    }
#line 286
    if (! ((unsigned long )aij->r_next == (unsigned long )((void *)0))) {
#line 289
      (aij->r_next)->r_prev = aij->r_prev;
    }
    {
#line 291
    _glp_dmp_free_atom(lpp->aij_pool, (void *)aij, (int )sizeof(LPPAIJ ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if ((unsigned long )col->prev == (unsigned long )((void *)0)) {
#line 295
    lpp->col_ptr = col->next;
  } else {
#line 297
    (col->prev)->next = col->next;
  }
#line 298
  if (! ((unsigned long )col->next == (unsigned long )((void *)0))) {
#line 301
    (col->next)->prev = col->prev;
  }
  {
#line 303
  _glp_dmp_free_atom(lpp->col_pool, (void *)col, (int )sizeof(LPPCOL ));
  }
#line 304
  return;
}
}
#line 320 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_enque_row(LPP *lpp , LPPROW *row ) 
{ 


  {
#line 321
  if (! row->q_flag) {
#line 322
    row->q_flag = 1;
#line 323
    row->q_prev = (LPPROW *)((void *)0);
#line 324
    row->q_next = lpp->row_que;
#line 325
    if ((unsigned long )lpp->row_que != (unsigned long )((void *)0)) {
#line 325
      (lpp->row_que)->q_prev = row;
    }
#line 326
    lpp->row_que = row;
  }
#line 328
  return;
}
}
#line 344 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_deque_row(LPP *lpp , LPPROW *row ) 
{ 


  {
#line 345
  if (row->q_flag) {
#line 346
    row->q_flag = 0;
#line 347
    if ((unsigned long )row->q_prev == (unsigned long )((void *)0)) {
#line 348
      lpp->row_que = row->q_next;
    } else {
#line 350
      (row->q_prev)->q_next = row->q_next;
    }
#line 351
    if (! ((unsigned long )row->q_next == (unsigned long )((void *)0))) {
#line 354
      (row->q_next)->q_prev = row->q_prev;
    }
  }
#line 356
  return;
}
}
#line 372 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_enque_col(LPP *lpp , LPPCOL *col ) 
{ 


  {
#line 373
  if (! col->q_flag) {
#line 374
    col->q_flag = 1;
#line 375
    col->q_prev = (LPPCOL *)((void *)0);
#line 376
    col->q_next = lpp->col_que;
#line 377
    if ((unsigned long )lpp->col_que != (unsigned long )((void *)0)) {
#line 377
      (lpp->col_que)->q_prev = col;
    }
#line 378
    lpp->col_que = col;
  }
#line 380
  return;
}
}
#line 396 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_deque_col(LPP *lpp , LPPCOL *col ) 
{ 


  {
#line 397
  if (col->q_flag) {
#line 398
    col->q_flag = 0;
#line 399
    if ((unsigned long )col->q_prev == (unsigned long )((void *)0)) {
#line 400
      lpp->col_que = col->q_next;
    } else {
#line 402
      (col->q_prev)->q_next = col->q_next;
    }
#line 403
    if (! ((unsigned long )col->q_next == (unsigned long )((void *)0))) {
#line 406
      (col->q_next)->q_prev = col->q_prev;
    }
  }
#line 408
  return;
}
}
#line 427 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_load_orig(LPP *lpp , glp_prob *orig ) 
{ 
  LPPROW *row ;
  LPPCOL *col ;
  LPPCOL **map ;
  int i ;
  int j ;
  int t ;
  int len ;
  int typx ;
  int *ndx ;
  double lb ;
  double ub ;
  double temp ;
  double *c ;
  double *val ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 433
  lpp->orig_m = _glp_lpx_get_num_rows(orig);
#line 434
  lpp->orig_n = _glp_lpx_get_num_cols(orig);
#line 435
  lpp->orig_nnz = _glp_lpx_get_num_nz(orig);
#line 436
  lpp->orig_dir = _glp_lpx_get_obj_dir(orig);
#line 438
  tmp = _glp_lib_xcalloc(1 + lpp->orig_n, (int )sizeof(double ));
#line 438
  c = (double *)tmp;
#line 439
  tmp___0 = _glp_lib_xcalloc(1 + lpp->orig_n, (int )sizeof(int ));
#line 439
  ndx = (int *)tmp___0;
#line 440
  tmp___1 = _glp_lib_xcalloc(1 + lpp->orig_n, (int )sizeof(double ));
#line 440
  val = (double *)tmp___1;
#line 447
  j = 1;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! (j <= lpp->orig_n)) {
#line 447
      goto while_break;
    }
    {
#line 448
    *(c + j) = _glp_lpx_get_obj_coef(orig, j);
#line 447
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  i = 1;
  {
#line 449
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 449
    if (! (i <= lpp->orig_m)) {
#line 449
      goto while_break___0;
    }
#line 454
    temp = 0.0;
#line 457
    if (temp != 0.0) {
      {
#line 458
      len = _glp_lpx_get_mat_row(orig, i, ndx, val);
#line 459
      t = 1;
      }
      {
#line 459
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 459
        if (! (t <= len)) {
#line 459
          goto while_break___1;
        }
#line 459
        *(c + *(ndx + t)) += *(val + t) * temp;
#line 459
        t ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 449
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 465
  i = 1;
  {
#line 465
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 465
    if (! (i <= lpp->orig_m)) {
#line 465
      goto while_break___2;
    }
    {
#line 466
    _glp_lpx_get_row_bnds(orig, i, & typx, & lb, & ub);
    }
#line 467
    if (typx == 110) {
#line 467
      lb = - 1.7976931348623157e+308;
    } else
#line 467
    if (typx == 112) {
#line 467
      lb = - 1.7976931348623157e+308;
    }
#line 468
    if (typx == 110) {
#line 468
      ub = 1.7976931348623157e+308;
    } else
#line 468
    if (typx == 111) {
#line 468
      ub = 1.7976931348623157e+308;
    }
#line 469
    if (typx == 114) {
#line 469
      ub = lb;
    }
    {
#line 470
    _glp_lpp_add_row(lpp, lb, ub);
#line 465
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 475
  j = 1;
  {
#line 475
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 475
    if (! (j <= lpp->orig_n)) {
#line 475
      goto while_break___3;
    }
    {
#line 476
    _glp_lpx_get_col_bnds(orig, j, & typx, & lb, & ub);
    }
#line 477
    if (typx == 110) {
#line 477
      lb = - 1.7976931348623157e+308;
    } else
#line 477
    if (typx == 112) {
#line 477
      lb = - 1.7976931348623157e+308;
    }
#line 478
    if (typx == 110) {
#line 478
      ub = 1.7976931348623157e+308;
    } else
#line 478
    if (typx == 111) {
#line 478
      ub = 1.7976931348623157e+308;
    }
#line 479
    if (typx == 114) {
#line 479
      ub = lb;
    }
    {
#line 480
    _glp_lpp_add_col(lpp, lb, ub, *(c + j));
#line 475
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 483
  lpp->c0 = _glp_lpx_get_obj_coef(orig, 0);
  }
#line 487
  if (lpp->orig_dir == 121) {
#line 488
    col = lpp->col_ptr;
    {
#line 488
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 488
      if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 488
        goto while_break___4;
      }
#line 489
      col->c = - col->c;
#line 488
      col = col->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 490
    lpp->c0 = - lpp->c0;
  }
#line 494
  if (sizeof(LPPCOL *) <= sizeof(double )) {
#line 494
    tmp___2 = 1;
  } else {
    {
#line 494
    _glp_lib_xassert("sizeof(LPPCOL *) <= sizeof(double)", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     494);
#line 494
    tmp___2 = 1;
    }
  }
#line 495
  map = (LPPCOL **)c;
#line 496
  col = lpp->col_ptr;
  {
#line 496
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 496
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 496
      goto while_break___5;
    }
#line 497
    *(map + col->j) = col;
#line 496
    col = col->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 499
  row = lpp->row_ptr;
  {
#line 499
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 499
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 499
      goto while_break___6;
    }
    {
#line 501
    len = _glp_lpx_get_mat_row(orig, row->i, ndx, val);
#line 502
    t = 1;
    }
    {
#line 502
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 502
      if (! (t <= len)) {
#line 502
        goto while_break___7;
      }
      {
#line 503
      _glp_lpp_add_aij(lpp, row, *(map + *(ndx + t)), *(val + t));
#line 502
      t ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 499
    row = row->next;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 519
  _glp_lib_xfree((void *)c);
#line 520
  _glp_lib_xfree((void *)ndx);
#line 521
  _glp_lib_xfree((void *)val);
  }
#line 522
  return;
}
}
#line 547 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void *_glp_lpp_append_tqe(LPP *lpp , int type , int size ) 
{ 
  LPPTQE *tqe ;
  void *tmp ;

  {
  {
#line 549
  tmp = _glp_dmp_get_atom(lpp->tqe_pool, (int )sizeof(LPPTQE ));
#line 549
  tqe = (LPPTQE *)tmp;
#line 550
  tqe->type = type;
#line 551
  tqe->info = _glp_dmp_get_atom(lpp->tqe_pool, size);
#line 552
  tqe->next = lpp->tqe_list;
#line 553
  lpp->tqe_list = tqe;
  }
#line 554
  return (tqe->info);
}
}
#line 575 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
glp_prob *_glp_lpp_build_prob(LPP *lpp ) 
{ 
  glp_prob *prob ;
  LPPROW *row ;
  LPPCOL *col ;
  int i ;
  int j ;
  int typx ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  LPPAIJ *aij ;
  int len ;
  int *ind ;
  double *val ;
  void *tmp___8 ;
  void *tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 581
  tmp = 0;
#line 581
  lpp->n = tmp;
#line 581
  lpp->m = tmp;
#line 582
  row = lpp->row_ptr;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 582
      goto while_break;
    }
#line 582
    (lpp->m) ++;
#line 582
    row = row->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  col = lpp->col_ptr;
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 583
      goto while_break___0;
    }
#line 583
    (lpp->n) ++;
#line 583
    col = col->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 586
  tmp___0 = _glp_lib_xcalloc(1 + lpp->m, (int )sizeof(int ));
#line 586
  lpp->row_ref = (int *)tmp___0;
#line 587
  tmp___1 = _glp_lib_xcalloc(1 + lpp->n, (int )sizeof(int ));
#line 587
  lpp->col_ref = (int *)tmp___1;
#line 589
  prob = _glp_lpx_create_prob();
#line 592
  _glp_lpx_set_obj_dir(prob, lpp->orig_dir);
  }
#line 594
  if (lpp->orig_dir == 120) {
#line 594
    tmp___2 = lpp->c0;
  } else {
#line 594
    tmp___2 = - lpp->c0;
  }
  {
#line 594
  _glp_lpx_set_obj_coef(prob, 0, tmp___2);
  }
#line 600
  if (lpp->m > 0) {
    {
#line 601
    _glp_lpx_add_rows(prob, lpp->m);
    }
  }
#line 602
  i = 1;
#line 602
  row = lpp->row_ptr;
  {
#line 602
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 602
    if (! (i <= lpp->m)) {
#line 602
      goto while_break___1;
    }
#line 603
    if ((unsigned long )row != (unsigned long )((void *)0)) {
#line 603
      tmp___3 = 1;
    } else {
      {
#line 603
      _glp_lib_xassert("row != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                       603);
#line 603
      tmp___3 = 1;
      }
    }
#line 604
    *(lpp->row_ref + i) = row->i;
#line 605
    row->i = i;
#line 606
    if (row->lb == - 1.7976931348623157e+308) {
#line 606
      if (row->ub == 1.7976931348623157e+308) {
#line 607
        typx = 110;
      } else {
#line 606
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 608
    if (row->ub == 1.7976931348623157e+308) {
#line 609
      typx = 111;
    } else
#line 610
    if (row->lb == - 1.7976931348623157e+308) {
#line 611
      typx = 112;
    } else
#line 612
    if (row->lb != row->ub) {
#line 613
      typx = 113;
    } else {
#line 615
      typx = 114;
    }
    {
#line 616
    _glp_lpx_set_row_bnds(prob, i, typx, row->lb, row->ub);
#line 602
    i ++;
#line 602
    row = row->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 618
  if ((unsigned long )row == (unsigned long )((void *)0)) {
#line 618
    tmp___4 = 1;
  } else {
    {
#line 618
    _glp_lib_xassert("row == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     618);
#line 618
    tmp___4 = 1;
    }
  }
#line 623
  if (lpp->n > 0) {
    {
#line 624
    _glp_lpx_add_cols(prob, lpp->n);
    }
  }
#line 625
  j = 1;
#line 625
  col = lpp->col_ptr;
  {
#line 625
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 625
    if (! (j <= lpp->n)) {
#line 625
      goto while_break___2;
    }
#line 626
    if ((unsigned long )col != (unsigned long )((void *)0)) {
#line 626
      tmp___5 = 1;
    } else {
      {
#line 626
      _glp_lib_xassert("col != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                       626);
#line 626
      tmp___5 = 1;
      }
    }
#line 627
    *(lpp->col_ref + j) = col->j;
#line 628
    col->j = j;
#line 629
    if (col->lb == - 1.7976931348623157e+308) {
#line 629
      if (col->ub == 1.7976931348623157e+308) {
#line 630
        typx = 110;
      } else {
#line 629
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 631
    if (col->ub == 1.7976931348623157e+308) {
#line 632
      typx = 111;
    } else
#line 633
    if (col->lb == - 1.7976931348623157e+308) {
#line 634
      typx = 112;
    } else
#line 635
    if (col->lb != col->ub) {
#line 636
      typx = 113;
    } else {
#line 638
      typx = 114;
    }
    {
#line 639
    _glp_lpx_set_col_bnds(prob, j, typx, col->lb, col->ub);
    }
#line 640
    if (lpp->orig_dir == 120) {
#line 640
      tmp___6 = col->c;
    } else {
#line 640
      tmp___6 = - col->c;
    }
    {
#line 640
    _glp_lpx_set_obj_coef(prob, j, tmp___6);
#line 625
    j ++;
#line 625
    col = col->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 643
  if ((unsigned long )col == (unsigned long )((void *)0)) {
#line 643
    tmp___7 = 1;
  } else {
    {
#line 643
    _glp_lib_xassert("col == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     643);
#line 643
    tmp___7 = 1;
    }
  }
  {
#line 654
  tmp___8 = _glp_lib_xcalloc(1 + lpp->n, (int )sizeof(int ));
#line 654
  ind = (int *)tmp___8;
#line 655
  tmp___9 = _glp_lib_xcalloc(1 + lpp->n, (int )sizeof(double ));
#line 655
  val = (double *)tmp___9;
#line 656
  row = lpp->row_ptr;
  }
  {
#line 656
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 656
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 656
      goto while_break___3;
    }
#line 657
    len = 0;
#line 658
    aij = row->ptr;
    {
#line 658
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 658
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 658
        goto while_break___4;
      }
#line 659
      len ++;
#line 659
      *(ind + len) = (aij->col)->j;
#line 659
      *(val + len) = aij->val;
#line 658
      aij = aij->r_next;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 660
    _glp_lpx_set_mat_row(prob, row->i, len, (int const   *)ind, (double const   *)val);
#line 656
    row = row->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 662
  _glp_lib_xfree((void *)ind);
#line 663
  _glp_lib_xfree((void *)val);
#line 667
  lpp->nnz = _glp_lpx_get_num_nz(prob);
#line 670
  _glp_dmp_delete_pool(lpp->row_pool);
#line 670
  lpp->row_pool = (DMP *)((void *)0);
#line 671
  _glp_dmp_delete_pool(lpp->col_pool);
#line 671
  lpp->col_pool = (DMP *)((void *)0);
#line 672
  _glp_dmp_delete_pool(lpp->aij_pool);
#line 672
  lpp->aij_pool = (DMP *)((void *)0);
#line 673
  lpp->row_ptr = (LPPROW *)((void *)0);
#line 673
  lpp->col_ptr = (LPPCOL *)((void *)0);
#line 674
  lpp->row_que = (LPPROW *)((void *)0);
#line 674
  lpp->col_que = (LPPCOL *)((void *)0);
  }
#line 676
  return (prob);
}
}
#line 692 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_alloc_sol(LPP *lpp ) 
{ 
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 694
  tmp = _glp_lib_xcalloc(1 + lpp->nrows, (int )sizeof(int ));
#line 694
  lpp->row_stat = (int *)tmp;
#line 695
  tmp___0 = _glp_lib_xcalloc(1 + lpp->nrows, (int )sizeof(double ));
#line 695
  lpp->row_prim = (double *)tmp___0;
#line 696
  tmp___1 = _glp_lib_xcalloc(1 + lpp->nrows, (int )sizeof(double ));
#line 696
  lpp->row_dual = (double *)tmp___1;
#line 697
  tmp___2 = _glp_lib_xcalloc(1 + lpp->ncols, (int )sizeof(int ));
#line 697
  lpp->col_stat = (int *)tmp___2;
#line 698
  tmp___3 = _glp_lib_xcalloc(1 + lpp->ncols, (int )sizeof(double ));
#line 698
  lpp->col_prim = (double *)tmp___3;
#line 699
  tmp___4 = _glp_lib_xcalloc(1 + lpp->ncols, (int )sizeof(double ));
#line 699
  lpp->col_dual = (double *)tmp___4;
#line 700
  i = 1;
  }
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! (i <= lpp->nrows)) {
#line 700
      goto while_break;
    }
#line 700
    *(lpp->row_stat + i) = 0;
#line 700
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  j = 1;
  {
#line 701
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 701
    if (! (j <= lpp->ncols)) {
#line 701
      goto while_break___0;
    }
#line 701
    *(lpp->col_stat + j) = 0;
#line 701
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 702
  return;
}
}
#line 718 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_load_sol(LPP *lpp , glp_prob *prob ) 
{ 
  int i ;
  int j ;
  int ref ;
  int stat ;
  double prim ;
  double dual ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 721
  tmp = _glp_lpx_get_num_rows(prob);
  }
#line 721
  if (lpp->m == tmp) {
#line 721
    tmp___0 = 1;
  } else {
    {
#line 721
    _glp_lib_xassert("lpp->m == lpx_get_num_rows(prob)", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     721);
#line 721
    tmp___0 = 1;
    }
  }
  {
#line 722
  tmp___1 = _glp_lpx_get_num_cols(prob);
  }
#line 722
  if (lpp->n == tmp___1) {
#line 722
    tmp___2 = 1;
  } else {
    {
#line 722
    _glp_lib_xassert("lpp->n == lpx_get_num_cols(prob)", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     722);
#line 722
    tmp___2 = 1;
    }
  }
  {
#line 723
  tmp___3 = _glp_lpx_get_obj_dir(prob);
  }
#line 723
  if (lpp->orig_dir == tmp___3) {
#line 723
    tmp___4 = 1;
  } else {
    {
#line 723
    _glp_lib_xassert("lpp->orig_dir == lpx_get_obj_dir(prob)", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     723);
#line 723
    tmp___4 = 1;
    }
  }
  {
#line 724
  tmp___5 = _glp_lpx_get_status(prob);
  }
#line 724
  if (tmp___5 != 185) {
#line 724
    tmp___6 = 1;
  } else {
    {
#line 724
    _glp_lib_xassert("lpx_get_status(prob) != LPX_UNDEF", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     724);
#line 724
    tmp___6 = 1;
    }
  }
#line 725
  i = 1;
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (i <= lpp->m)) {
#line 725
      goto while_break;
    }
    {
#line 726
    _glp_lpx_get_row_info(prob, i, & stat, & prim, & dual);
#line 727
    ref = *(lpp->row_ref + i);
    }
#line 728
    if (1 <= ref) {
#line 728
      if (ref <= lpp->nrows) {
#line 728
        tmp___7 = 1;
      } else {
        {
#line 728
        _glp_lib_xassert("1 <= ref && ref <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         728);
#line 728
        tmp___7 = 1;
        }
      }
    } else {
      {
#line 728
      _glp_lib_xassert("1 <= ref && ref <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                       728);
#line 728
      tmp___7 = 1;
      }
    }
#line 729
    if (*(lpp->row_stat + ref) == 0) {
#line 729
      tmp___8 = 1;
    } else {
      {
#line 729
      _glp_lib_xassert("lpp->row_stat[ref] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                       729);
#line 729
      tmp___8 = 1;
      }
    }
#line 730
    *(lpp->row_stat + ref) = stat;
#line 731
    *(lpp->row_prim + ref) = prim;
#line 732
    if (lpp->orig_dir == 120) {
#line 732
      *(lpp->row_dual + ref) = dual;
    } else {
#line 732
      *(lpp->row_dual + ref) = - dual;
    }
#line 725
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  j = 1;
  {
#line 735
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 735
    if (! (j <= lpp->n)) {
#line 735
      goto while_break___0;
    }
    {
#line 736
    _glp_lpx_get_col_info(prob, j, & stat, & prim, & dual);
#line 737
    ref = *(lpp->col_ref + j);
    }
#line 738
    if (1 <= ref) {
#line 738
      if (ref <= lpp->ncols) {
#line 738
        tmp___9 = 1;
      } else {
        {
#line 738
        _glp_lib_xassert("1 <= ref && ref <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         738);
#line 738
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 738
      _glp_lib_xassert("1 <= ref && ref <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                       738);
#line 738
      tmp___9 = 1;
      }
    }
#line 739
    if (*(lpp->col_stat + ref) == 0) {
#line 739
      tmp___10 = 1;
    } else {
      {
#line 739
      _glp_lib_xassert("lpp->col_stat[ref] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                       739);
#line 739
      tmp___10 = 1;
      }
    }
#line 740
    *(lpp->col_stat + ref) = stat;
#line 741
    *(lpp->col_prim + ref) = prim;
#line 742
    if (lpp->orig_dir == 120) {
#line 742
      *(lpp->col_dual + ref) = dual;
    } else {
#line 742
      *(lpp->col_dual + ref) = - dual;
    }
#line 735
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 745
  _glp_lib_xfree((void *)lpp->row_ref);
#line 745
  lpp->row_ref = (int *)((void *)0);
#line 746
  _glp_lib_xfree((void *)lpp->col_ref);
#line 746
  lpp->col_ref = (int *)((void *)0);
  }
#line 747
  return;
}
}
#line 764 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_unload_sol(LPP *lpp , glp_prob *orig ) 
{ 
  int i ;
  int j ;
  int k ;
  int m ;
  int n ;
  int typx ;
  int tagx ;
  int p_stat ;
  int d_stat ;
  double sum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 767
  m = lpp->orig_m;
#line 768
  n = lpp->orig_n;
#line 769
  tmp = _glp_lpx_get_num_rows(orig);
  }
#line 769
  if (m == tmp) {
#line 769
    tmp___0 = 1;
  } else {
    {
#line 769
    _glp_lib_xassert("m == lpx_get_num_rows(orig)", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     769);
#line 769
    tmp___0 = 1;
    }
  }
  {
#line 770
  tmp___1 = _glp_lpx_get_num_cols(orig);
  }
#line 770
  if (n == tmp___1) {
#line 770
    tmp___2 = 1;
  } else {
    {
#line 770
    _glp_lib_xassert("n == lpx_get_num_cols(orig)", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     770);
#line 770
    tmp___2 = 1;
    }
  }
  {
#line 771
  tmp___3 = _glp_lpx_get_obj_dir(orig);
  }
#line 771
  if (lpp->orig_dir == tmp___3) {
#line 771
    tmp___4 = 1;
  } else {
    {
#line 771
    _glp_lib_xassert("lpp->orig_dir == lpx_get_obj_dir(orig)", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     771);
#line 771
    tmp___4 = 1;
    }
  }
#line 773
  if (m <= lpp->nrows) {
#line 773
    tmp___5 = 1;
  } else {
    {
#line 773
    _glp_lib_xassert("m <= lpp->nrows", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     773);
#line 773
    tmp___5 = 1;
    }
  }
#line 774
  if (n <= lpp->ncols) {
#line 774
    tmp___6 = 1;
  } else {
    {
#line 774
    _glp_lib_xassert("n <= lpp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                     774);
#line 774
    tmp___6 = 1;
    }
  }
#line 775
  k = 1;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! (k <= m + n)) {
#line 775
      goto while_break;
    }
#line 776
    if (k <= m) {
#line 776
      tagx = *(lpp->row_stat + k);
    } else {
#line 776
      tagx = *(lpp->col_stat + (k - m));
    }
#line 777
    if (tagx != 140) {
#line 778
      if (k <= m) {
        {
#line 779
        _glp_lpx_get_row_bnds(orig, k, & typx, (double *)((void *)0), (double *)((void *)0));
        }
      } else {
        {
#line 781
        _glp_lpx_get_col_bnds(orig, k - m, & typx, (double *)((void *)0), (double *)((void *)0));
        }
      }
      {
#line 783
      if (typx == 110) {
#line 783
        goto case_110;
      }
#line 786
      if (typx == 111) {
#line 786
        goto case_111;
      }
#line 789
      if (typx == 112) {
#line 789
        goto case_112;
      }
#line 792
      if (typx == 113) {
#line 792
        goto case_113;
      }
#line 795
      if (typx == 114) {
#line 795
        goto case_114;
      }
#line 798
      goto switch_default;
      case_110: /* CIL Label */ 
#line 784
      if (tagx == 143) {
#line 784
        tmp___7 = 1;
      } else {
        {
#line 784
        _glp_lib_xassert("tagx == LPX_NF", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         784);
#line 784
        tmp___7 = 1;
        }
      }
#line 785
      goto switch_break;
      case_111: /* CIL Label */ 
#line 787
      if (tagx == 141) {
#line 787
        tmp___8 = 1;
      } else {
        {
#line 787
        _glp_lib_xassert("tagx == LPX_NL", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         787);
#line 787
        tmp___8 = 1;
        }
      }
#line 788
      goto switch_break;
      case_112: /* CIL Label */ 
#line 790
      if (tagx == 142) {
#line 790
        tmp___9 = 1;
      } else {
        {
#line 790
        _glp_lib_xassert("tagx == LPX_NU", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         790);
#line 790
        tmp___9 = 1;
        }
      }
#line 791
      goto switch_break;
      case_113: /* CIL Label */ 
#line 793
      if (tagx == 141) {
#line 793
        tmp___10 = 1;
      } else
#line 793
      if (tagx == 142) {
#line 793
        tmp___10 = 1;
      } else {
        {
#line 793
        _glp_lib_xassert("tagx == LPX_NL || tagx == LPX_NU", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         793);
#line 793
        tmp___10 = 1;
        }
      }
#line 794
      goto switch_break;
      case_114: /* CIL Label */ 
#line 796
      if (tagx == 144) {
#line 796
        tmp___11 = 1;
      } else {
        {
#line 796
        _glp_lib_xassert("tagx == LPX_NS", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         796);
#line 796
        tmp___11 = 1;
        }
      }
#line 797
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 799
      if ((unsigned long )orig != (unsigned long )orig) {
#line 799
        tmp___12 = 1;
      } else {
        {
#line 799
        _glp_lib_xassert("orig != orig", "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c",
                         799);
#line 799
        tmp___12 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 775
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 805
  if (lpp->orig_dir == 121) {
#line 806
    i = 1;
    {
#line 806
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 806
      if (! (i <= m)) {
#line 806
        goto while_break___0;
      }
#line 806
      *(lpp->row_dual + i) = - *(lpp->row_dual + i);
#line 806
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 807
    j = 1;
    {
#line 807
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 807
      if (! (j <= n)) {
#line 807
        goto while_break___1;
      }
#line 807
      *(lpp->col_dual + j) = - *(lpp->col_dual + j);
#line 807
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 811
  d_stat = 2;
#line 811
  p_stat = d_stat;
#line 812
  i = 1;
  {
#line 812
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 812
    if (! (i <= m)) {
#line 812
      goto while_break___2;
    }
#line 813
    *(lpp->row_stat + i) = (*(lpp->row_stat + i) - 140) + 1;
#line 812
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 814
  j = 1;
  {
#line 814
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 814
    if (! (j <= n)) {
#line 814
      goto while_break___3;
    }
#line 815
    *(lpp->col_stat + j) = (*(lpp->col_stat + j) - 140) + 1;
#line 814
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 816
  sum = _glp_lpx_get_obj_coef(orig, 0);
#line 817
  j = 1;
  }
  {
#line 817
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 817
    if (! (j <= n)) {
#line 817
      goto while_break___4;
    }
    {
#line 818
    tmp___13 = _glp_lpx_get_obj_coef(orig, j);
#line 818
    sum += tmp___13 * *(lpp->col_prim + j);
#line 817
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 819
  _glp_1px_put_solution(orig, 1, (int const   *)(& p_stat), (int const   *)(& d_stat),
                        (double const   *)(& sum), (int const   *)lpp->row_stat, (double const   *)lpp->row_prim,
                        (double const   *)lpp->row_dual, (int const   *)lpp->col_stat,
                        (double const   *)lpp->col_prim, (double const   *)lpp->col_dual);
#line 822
  i = 1;
  }
  {
#line 822
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 822
    if (! (i <= m)) {
#line 822
      goto while_break___5;
    }
#line 823
    *(lpp->row_stat + i) = (*(lpp->row_stat + i) - 1) + 140;
#line 822
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 824
  j = 1;
  {
#line 824
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 824
    if (! (j <= n)) {
#line 824
      goto while_break___6;
    }
#line 825
    *(lpp->col_stat + j) = (*(lpp->col_stat + j) - 1) + 140;
#line 824
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 826
  return;
}
}
#line 843 "/home/wslee/benchmarks/glpk-4.38/src/glplpp01.c"
void _glp_lpp_delete_wksp(LPP *lpp ) 
{ 


  {
#line 844
  if ((unsigned long )lpp->row_pool != (unsigned long )((void *)0)) {
    {
#line 844
    _glp_dmp_delete_pool(lpp->row_pool);
    }
  }
#line 845
  if ((unsigned long )lpp->col_pool != (unsigned long )((void *)0)) {
    {
#line 845
    _glp_dmp_delete_pool(lpp->col_pool);
    }
  }
#line 846
  if ((unsigned long )lpp->aij_pool != (unsigned long )((void *)0)) {
    {
#line 846
    _glp_dmp_delete_pool(lpp->aij_pool);
    }
  }
#line 847
  if ((unsigned long )lpp->tqe_pool != (unsigned long )((void *)0)) {
    {
#line 847
    _glp_dmp_delete_pool(lpp->tqe_pool);
    }
  }
#line 848
  if ((unsigned long )lpp->row_ref != (unsigned long )((void *)0)) {
    {
#line 848
    _glp_lib_xfree((void *)lpp->row_ref);
    }
  }
#line 849
  if ((unsigned long )lpp->col_ref != (unsigned long )((void *)0)) {
    {
#line 849
    _glp_lib_xfree((void *)lpp->col_ref);
    }
  }
#line 850
  if ((unsigned long )lpp->row_stat != (unsigned long )((void *)0)) {
    {
#line 850
    _glp_lib_xfree((void *)lpp->row_stat);
    }
  }
#line 851
  if ((unsigned long )lpp->row_prim != (unsigned long )((void *)0)) {
    {
#line 851
    _glp_lib_xfree((void *)lpp->row_prim);
    }
  }
#line 852
  if ((unsigned long )lpp->row_dual != (unsigned long )((void *)0)) {
    {
#line 852
    _glp_lib_xfree((void *)lpp->row_dual);
    }
  }
#line 853
  if ((unsigned long )lpp->col_stat != (unsigned long )((void *)0)) {
    {
#line 853
    _glp_lib_xfree((void *)lpp->col_stat);
    }
  }
#line 854
  if ((unsigned long )lpp->col_prim != (unsigned long )((void *)0)) {
    {
#line 854
    _glp_lib_xfree((void *)lpp->col_prim);
    }
  }
#line 855
  if ((unsigned long )lpp->col_dual != (unsigned long )((void *)0)) {
    {
#line 855
    _glp_lib_xfree((void *)lpp->col_dual);
    }
  }
  {
#line 856
  _glp_lib_xfree((void *)lpp);
  }
#line 857
  return;
}
}
#line 166 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.h"
LPF *_glp_lpf_create_it(void) ;
#line 170
int _glp_lpf_factorize(LPF *lpf , int m , int const   *bh , int (*col)(void *info ,
                                                                       int j , int *ind ,
                                                                       double *val ) ,
                       void *info ) ;
#line 175
void _glp_lpf_ftran(LPF *lpf , double *x ) ;
#line 179
void _glp_lpf_btran(LPF *lpf , double *x ) ;
#line 183
int _glp_lpf_update_it(LPF *lpf , int j , int bh , int len , int const   *ind , double const   *val ) ;
#line 188
void _glp_lpf_delete_it(LPF *lpf ) ;
#line 54 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
LPF *_glp_lpf_create_it(void) 
{ 
  LPF *lpf ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  double *tmp___5 ;

  {
  {
#line 59
  tmp = _glp_lib_xmalloc((int )sizeof(LPF ));
#line 59
  lpf = (LPF *)tmp;
#line 60
  lpf->valid = 0;
#line 61
  tmp___0 = 0;
#line 61
  lpf->m0 = tmp___0;
#line 61
  lpf->m0_max = tmp___0;
#line 62
  lpf->luf = _glp_luf_create_it();
#line 63
  lpf->m = 0;
#line 64
  lpf->B = (double *)((void *)0);
#line 65
  lpf->n_max = 50;
#line 66
  lpf->n = 0;
#line 67
  tmp___1 = (int *)((void *)0);
#line 67
  lpf->R_len = tmp___1;
#line 67
  lpf->R_ptr = tmp___1;
#line 68
  tmp___2 = (int *)((void *)0);
#line 68
  lpf->S_len = tmp___2;
#line 68
  lpf->S_ptr = tmp___2;
#line 69
  lpf->scf = (SCF *)((void *)0);
#line 70
  tmp___3 = (int *)((void *)0);
#line 70
  lpf->P_col = tmp___3;
#line 70
  lpf->P_row = tmp___3;
#line 71
  tmp___4 = (int *)((void *)0);
#line 71
  lpf->Q_col = tmp___4;
#line 71
  lpf->Q_row = tmp___4;
#line 72
  lpf->v_size = 1000;
#line 73
  lpf->v_ptr = 0;
#line 74
  lpf->v_ind = (int *)((void *)0);
#line 75
  lpf->v_val = (double *)((void *)0);
#line 76
  tmp___5 = (double *)((void *)0);
#line 76
  lpf->work2 = tmp___5;
#line 76
  lpf->work1 = tmp___5;
  }
#line 77
  return (lpf);
}
}
#line 127 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
int _glp_lpf_factorize(LPF *lpf , int m , int const   *bh , int (*col)(void *info ,
                                                                       int j , int *ind ,
                                                                       double *val ) ,
                       void *info ) 
{ 
  int k ;
  int ret ;
  int tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 134
  if ((unsigned long )bh == (unsigned long )bh) {
#line 134
    tmp = 1;
  } else {
    {
#line 134
    _glp_lib_xassert("bh == bh", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     134);
#line 134
    tmp = 1;
    }
  }
#line 135
  if (m < 1) {
    {
#line 136
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c", 136);
#line 136
    (*tmp___0)("lpf_factorize: m = %d; invalid parameter\n", m);
    }
  }
#line 137
  if (m > 100000000) {
    {
#line 138
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c", 138);
#line 138
    (*tmp___1)("lpf_factorize: m = %d; matrix too big\n", m);
    }
  }
#line 139
  tmp___2 = m;
#line 139
  lpf->m = tmp___2;
#line 139
  lpf->m0 = tmp___2;
#line 141
  lpf->valid = 0;
#line 143
  if ((unsigned long )lpf->R_ptr == (unsigned long )((void *)0)) {
    {
#line 144
    tmp___3 = _glp_lib_xcalloc(1 + lpf->n_max, (int )sizeof(int ));
#line 144
    lpf->R_ptr = (int *)tmp___3;
    }
  }
#line 145
  if ((unsigned long )lpf->R_len == (unsigned long )((void *)0)) {
    {
#line 146
    tmp___4 = _glp_lib_xcalloc(1 + lpf->n_max, (int )sizeof(int ));
#line 146
    lpf->R_len = (int *)tmp___4;
    }
  }
#line 147
  if ((unsigned long )lpf->S_ptr == (unsigned long )((void *)0)) {
    {
#line 148
    tmp___5 = _glp_lib_xcalloc(1 + lpf->n_max, (int )sizeof(int ));
#line 148
    lpf->S_ptr = (int *)tmp___5;
    }
  }
#line 149
  if ((unsigned long )lpf->S_len == (unsigned long )((void *)0)) {
    {
#line 150
    tmp___6 = _glp_lib_xcalloc(1 + lpf->n_max, (int )sizeof(int ));
#line 150
    lpf->S_len = (int *)tmp___6;
    }
  }
#line 151
  if ((unsigned long )lpf->scf == (unsigned long )((void *)0)) {
    {
#line 152
    lpf->scf = _glp_scf_create_it(lpf->n_max);
    }
  }
#line 153
  if ((unsigned long )lpf->v_ind == (unsigned long )((void *)0)) {
    {
#line 154
    tmp___7 = _glp_lib_xcalloc(1 + lpf->v_size, (int )sizeof(int ));
#line 154
    lpf->v_ind = (int *)tmp___7;
    }
  }
#line 155
  if ((unsigned long )lpf->v_val == (unsigned long )((void *)0)) {
    {
#line 156
    tmp___8 = _glp_lib_xcalloc(1 + lpf->v_size, (int )sizeof(double ));
#line 156
    lpf->v_val = (double *)tmp___8;
    }
  }
#line 157
  if (lpf->m0_max < m) {
#line 158
    if ((unsigned long )lpf->P_row != (unsigned long )((void *)0)) {
      {
#line 158
      _glp_lib_xfree((void *)lpf->P_row);
      }
    }
#line 159
    if ((unsigned long )lpf->P_col != (unsigned long )((void *)0)) {
      {
#line 159
      _glp_lib_xfree((void *)lpf->P_col);
      }
    }
#line 160
    if ((unsigned long )lpf->Q_row != (unsigned long )((void *)0)) {
      {
#line 160
      _glp_lib_xfree((void *)lpf->Q_row);
      }
    }
#line 161
    if ((unsigned long )lpf->Q_col != (unsigned long )((void *)0)) {
      {
#line 161
      _glp_lib_xfree((void *)lpf->Q_col);
      }
    }
#line 162
    if ((unsigned long )lpf->work1 != (unsigned long )((void *)0)) {
      {
#line 162
      _glp_lib_xfree((void *)lpf->work1);
      }
    }
#line 163
    if ((unsigned long )lpf->work2 != (unsigned long )((void *)0)) {
      {
#line 163
      _glp_lib_xfree((void *)lpf->work2);
      }
    }
    {
#line 164
    lpf->m0_max = m + 100;
#line 165
    tmp___9 = _glp_lib_xcalloc((1 + lpf->m0_max) + lpf->n_max, (int )sizeof(int ));
#line 165
    lpf->P_row = (int *)tmp___9;
#line 166
    tmp___10 = _glp_lib_xcalloc((1 + lpf->m0_max) + lpf->n_max, (int )sizeof(int ));
#line 166
    lpf->P_col = (int *)tmp___10;
#line 167
    tmp___11 = _glp_lib_xcalloc((1 + lpf->m0_max) + lpf->n_max, (int )sizeof(int ));
#line 167
    lpf->Q_row = (int *)tmp___11;
#line 168
    tmp___12 = _glp_lib_xcalloc((1 + lpf->m0_max) + lpf->n_max, (int )sizeof(int ));
#line 168
    lpf->Q_col = (int *)tmp___12;
#line 169
    tmp___13 = _glp_lib_xcalloc((1 + lpf->m0_max) + lpf->n_max, (int )sizeof(double ));
#line 169
    lpf->work1 = (double *)tmp___13;
#line 170
    tmp___14 = _glp_lib_xcalloc((1 + lpf->m0_max) + lpf->n_max, (int )sizeof(double ));
#line 170
    lpf->work2 = (double *)tmp___14;
    }
  }
  {
#line 173
  tmp___15 = _glp_luf_factorize(lpf->luf, m, col, info);
  }
  {
#line 174
  if (tmp___15 == 0) {
#line 174
    goto case_0;
  }
#line 176
  if (tmp___15 == 1) {
#line 176
    goto case_1;
  }
#line 179
  if (tmp___15 == 2) {
#line 179
    goto case_2;
  }
#line 182
  goto switch_default;
  case_0: /* CIL Label */ 
#line 175
  goto switch_break;
  case_1: /* CIL Label */ 
#line 177
  ret = 1;
#line 178
  goto done;
  case_2: /* CIL Label */ 
#line 180
  ret = 2;
#line 181
  goto done;
  switch_default: /* CIL Label */ 
#line 183
  if ((unsigned long )lpf != (unsigned long )lpf) {
#line 183
    tmp___16 = 1;
  } else {
    {
#line 183
    _glp_lib_xassert("lpf != lpf", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     183);
#line 183
    tmp___16 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 186
  lpf->valid = 1;
#line 211
  lpf->n = 0;
#line 213
  _glp_scf_reset_it(lpf->scf);
#line 215
  k = 1;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (k <= m)) {
#line 215
      goto while_break;
    }
#line 216
    tmp___17 = k;
#line 216
    *(lpf->P_col + k) = tmp___17;
#line 216
    *(lpf->P_row + k) = tmp___17;
#line 217
    tmp___18 = k;
#line 217
    *(lpf->Q_col + k) = tmp___18;
#line 217
    *(lpf->Q_row + k) = tmp___18;
#line 215
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  lpf->v_ptr = 1;
#line 221
  ret = 0;
  done: 
#line 223
  return (ret);
}
}
#line 237 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
static void r_prod(LPF *lpf , double *y , double a , double const   *x ) 
{ 
  int n ;
  int *R_ptr ;
  int *R_len ;
  int *v_ind ;
  double *v_val ;
  int j ;
  int beg ;
  int end ;
  int ptr ;
  double t ;

  {
#line 238
  n = lpf->n;
#line 239
  R_ptr = lpf->R_ptr;
#line 240
  R_len = lpf->R_len;
#line 241
  v_ind = lpf->v_ind;
#line 242
  v_val = lpf->v_val;
#line 245
  j = 1;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (j <= n)) {
#line 245
      goto while_break;
    }
#line 246
    if (*(x + j) == (double const   )0.0) {
#line 246
      goto __Cont;
    }
#line 248
    t = a * (double )*(x + j);
#line 249
    beg = *(R_ptr + j);
#line 250
    end = beg + *(R_len + j);
#line 251
    ptr = beg;
    {
#line 251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      if (! (ptr < end)) {
#line 251
        goto while_break___0;
      }
#line 252
      *(y + *(v_ind + ptr)) += t * *(v_val + ptr);
#line 251
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 245
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 269 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
static void rt_prod(LPF *lpf , double *y , double a , double const   *x ) 
{ 
  int n ;
  int *R_ptr ;
  int *R_len ;
  int *v_ind ;
  double *v_val ;
  int j ;
  int beg ;
  int end ;
  int ptr ;
  double t ;

  {
#line 270
  n = lpf->n;
#line 271
  R_ptr = lpf->R_ptr;
#line 272
  R_len = lpf->R_len;
#line 273
  v_ind = lpf->v_ind;
#line 274
  v_val = lpf->v_val;
#line 277
  j = 1;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (j <= n)) {
#line 277
      goto while_break;
    }
#line 279
    t = 0.0;
#line 280
    beg = *(R_ptr + j);
#line 281
    end = beg + *(R_len + j);
#line 282
    ptr = beg;
    {
#line 282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 282
      if (! (ptr < end)) {
#line 282
        goto while_break___0;
      }
#line 283
      t += *(v_val + ptr) * (double )*(x + *(v_ind + ptr));
#line 282
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 285
    *(y + j) += a * t;
#line 277
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 301 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
static void s_prod(LPF *lpf , double *y , double a , double const   *x ) 
{ 
  int n ;
  int *S_ptr ;
  int *S_len ;
  int *v_ind ;
  double *v_val ;
  int i ;
  int beg ;
  int end ;
  int ptr ;
  double t ;

  {
#line 302
  n = lpf->n;
#line 303
  S_ptr = lpf->S_ptr;
#line 304
  S_len = lpf->S_len;
#line 305
  v_ind = lpf->v_ind;
#line 306
  v_val = lpf->v_val;
#line 309
  i = 1;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i <= n)) {
#line 309
      goto while_break;
    }
#line 311
    t = 0.0;
#line 312
    beg = *(S_ptr + i);
#line 313
    end = beg + *(S_len + i);
#line 314
    ptr = beg;
    {
#line 314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 314
      if (! (ptr < end)) {
#line 314
        goto while_break___0;
      }
#line 315
      t += *(v_val + ptr) * (double )*(x + *(v_ind + ptr));
#line 314
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 317
    *(y + i) += a * t;
#line 309
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 334 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
static void st_prod(LPF *lpf , double *y , double a , double const   *x ) 
{ 
  int n ;
  int *S_ptr ;
  int *S_len ;
  int *v_ind ;
  double *v_val ;
  int i ;
  int beg ;
  int end ;
  int ptr ;
  double t ;

  {
#line 335
  n = lpf->n;
#line 336
  S_ptr = lpf->S_ptr;
#line 337
  S_len = lpf->S_len;
#line 338
  v_ind = lpf->v_ind;
#line 339
  v_val = lpf->v_val;
#line 342
  i = 1;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! (i <= n)) {
#line 342
      goto while_break;
    }
#line 343
    if (*(x + i) == (double const   )0.0) {
#line 343
      goto __Cont;
    }
#line 345
    t = a * (double )*(x + i);
#line 346
    beg = *(S_ptr + i);
#line 347
    end = beg + *(S_len + i);
#line 348
    ptr = beg;
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 348
      if (! (ptr < end)) {
#line 348
        goto while_break___0;
      }
#line 349
      *(y + *(v_ind + ptr)) += t * *(v_val + ptr);
#line 348
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 342
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return;
}
}
#line 467 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
void _glp_lpf_ftran(LPF *lpf , double *x ) 
{ 
  int m0 ;
  int m ;
  int n ;
  int *P_col ;
  int *Q_col ;
  double *fg ;
  double *f ;
  double *g ;
  int i ;
  int ii ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 468
  m0 = lpf->m0;
#line 469
  m = lpf->m;
#line 470
  n = lpf->n;
#line 471
  P_col = lpf->P_col;
#line 472
  Q_col = lpf->Q_col;
#line 473
  fg = lpf->work1;
#line 474
  f = fg;
#line 475
  g = fg + m0;
#line 480
  if (! lpf->valid) {
    {
#line 481
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c", 481);
#line 481
    (*tmp)("lpf_ftran: the factorization is not valid\n");
    }
  }
#line 482
  if (0 <= m) {
#line 482
    if (m <= m0 + n) {
#line 482
      tmp___0 = 1;
    } else {
      {
#line 482
      _glp_lib_xassert("0 <= m && m <= m0 + n", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                       482);
#line 482
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 482
    _glp_lib_xassert("0 <= m && m <= m0 + n", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     482);
#line 482
    tmp___0 = 1;
    }
  }
#line 489
  i = 1;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (i <= m0 + n)) {
#line 489
      goto while_break;
    }
#line 490
    ii = *(P_col + i);
#line 490
    if (ii <= m) {
#line 490
      *(fg + i) = *(x + ii);
    } else {
#line 490
      *(fg + i) = 0.0;
    }
#line 489
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 492
  _glp_luf_f_solve(lpf->luf, 0, f);
#line 494
  s_prod(lpf, g, - 1.0, (double const   *)f);
#line 496
  _glp_scf_solve_it(lpf->scf, 0, g);
#line 498
  r_prod(lpf, f, - 1.0, (double const   *)g);
#line 499
  _glp_luf_v_solve(lpf->luf, 0, f);
#line 501
  i = 1;
  }
  {
#line 501
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 501
    if (! (i <= m)) {
#line 501
      goto while_break___0;
    }
#line 502
    *(x + i) = *(fg + *(Q_col + i));
#line 501
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  return;
}
}
#line 597 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
void _glp_lpf_btran(LPF *lpf , double *x ) 
{ 
  int m0 ;
  int m ;
  int n ;
  int *P_row ;
  int *Q_row ;
  double *fg ;
  double *f ;
  double *g ;
  int i ;
  int ii ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 598
  m0 = lpf->m0;
#line 599
  m = lpf->m;
#line 600
  n = lpf->n;
#line 601
  P_row = lpf->P_row;
#line 602
  Q_row = lpf->Q_row;
#line 603
  fg = lpf->work1;
#line 604
  f = fg;
#line 605
  g = fg + m0;
#line 610
  if (! lpf->valid) {
    {
#line 611
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c", 611);
#line 611
    (*tmp)("lpf_btran: the factorization is not valid\n");
    }
  }
#line 612
  if (0 <= m) {
#line 612
    if (m <= m0 + n) {
#line 612
      tmp___0 = 1;
    } else {
      {
#line 612
      _glp_lib_xassert("0 <= m && m <= m0 + n", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                       612);
#line 612
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 612
    _glp_lib_xassert("0 <= m && m <= m0 + n", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     612);
#line 612
    tmp___0 = 1;
    }
  }
#line 619
  i = 1;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    if (! (i <= m0 + n)) {
#line 619
      goto while_break;
    }
#line 620
    ii = *(Q_row + i);
#line 620
    if (ii <= m) {
#line 620
      *(fg + i) = *(x + ii);
    } else {
#line 620
      *(fg + i) = 0.0;
    }
#line 619
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  _glp_luf_v_solve(lpf->luf, 1, f);
#line 624
  rt_prod(lpf, g, - 1.0, (double const   *)f);
#line 625
  _glp_scf_solve_it(lpf->scf, 1, g);
#line 627
  g = g;
#line 629
  st_prod(lpf, f, - 1.0, (double const   *)g);
#line 630
  _glp_luf_f_solve(lpf->luf, 1, f);
#line 632
  i = 1;
  }
  {
#line 632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 632
    if (! (i <= m)) {
#line 632
      goto while_break___0;
    }
#line 633
    *(x + i) = *(fg + *(P_row + i));
#line 632
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 639
  return;
}
}
#line 646 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
static void enlarge_sva(LPF *lpf , int new_size ) 
{ 
  int v_size ;
  int used ;
  int *v_ind ;
  double *v_val ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 647
  v_size = lpf->v_size;
#line 648
  used = lpf->v_ptr - 1;
#line 649
  v_ind = lpf->v_ind;
#line 650
  v_val = lpf->v_val;
#line 651
  if (v_size < new_size) {
#line 651
    tmp = 1;
  } else {
    {
#line 651
    _glp_lib_xassert("v_size < new_size", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     651);
#line 651
    tmp = 1;
    }
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (v_size < new_size)) {
#line 652
      goto while_break;
    }
#line 652
    v_size += v_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 653
  lpf->v_size = v_size;
#line 654
  tmp___0 = _glp_lib_xcalloc(1 + v_size, (int )sizeof(int ));
#line 654
  lpf->v_ind = (int *)tmp___0;
#line 655
  tmp___1 = _glp_lib_xcalloc(1 + v_size, (int )sizeof(double ));
#line 655
  lpf->v_val = (double *)tmp___1;
  }
#line 656
  if (used >= 0) {
#line 656
    tmp___2 = 1;
  } else {
    {
#line 656
    _glp_lib_xassert("used >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     656);
#line 656
    tmp___2 = 1;
    }
  }
  {
#line 657
  memcpy((void */* __restrict  */)(lpf->v_ind + 1), (void const   */* __restrict  */)(v_ind + 1),
         (size_t )((unsigned long )used * sizeof(int )));
#line 658
  memcpy((void */* __restrict  */)(lpf->v_val + 1), (void const   */* __restrict  */)(v_val + 1),
         (size_t )((unsigned long )used * sizeof(double )));
#line 659
  _glp_lib_xfree((void *)v_ind);
#line 660
  _glp_lib_xfree((void *)v_val);
  }
#line 661
  return;
}
}
#line 809 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
int _glp_lpf_update_it(LPF *lpf , int j , int bh , int len , int const   *ind , double const   *val ) 
{ 
  int m0 ;
  int m ;
  int n ;
  int *R_ptr ;
  int *R_len ;
  int *S_ptr ;
  int *S_len ;
  int *P_row ;
  int *P_col ;
  int *Q_row ;
  int *Q_col ;
  int v_ptr ;
  int *v_ind ;
  double *v_val ;
  double *a ;
  double *fg ;
  double *f ;
  double *g ;
  double *vw ;
  double *v ;
  double *w ;
  double *x ;
  double *y ;
  double z ;
  int i ;
  int ii ;
  int k ;
  int ret ;
  int tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
#line 811
  m0 = lpf->m0;
#line 812
  m = lpf->m;
#line 816
  n = lpf->n;
#line 817
  R_ptr = lpf->R_ptr;
#line 818
  R_len = lpf->R_len;
#line 819
  S_ptr = lpf->S_ptr;
#line 820
  S_len = lpf->S_len;
#line 821
  P_row = lpf->P_row;
#line 822
  P_col = lpf->P_col;
#line 823
  Q_row = lpf->Q_row;
#line 824
  Q_col = lpf->Q_col;
#line 825
  v_ptr = lpf->v_ptr;
#line 826
  v_ind = lpf->v_ind;
#line 827
  v_val = lpf->v_val;
#line 828
  a = lpf->work2;
#line 829
  fg = lpf->work1;
#line 829
  f = fg;
#line 829
  g = fg + m0;
#line 830
  vw = lpf->work2;
#line 830
  v = vw;
#line 830
  w = vw + m0;
#line 831
  x = g;
#line 831
  y = w;
#line 833
  if (bh == bh) {
#line 833
    tmp = 1;
  } else {
    {
#line 833
    _glp_lib_xassert("bh == bh", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     833);
#line 833
    tmp = 1;
    }
  }
#line 834
  if (! lpf->valid) {
    {
#line 835
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c", 835);
#line 835
    (*tmp___0)("lpf_update_it: the factorization is not valid\n");
    }
  }
#line 836
  if (1 <= j) {
#line 836
    if (! (j <= m)) {
      {
#line 837
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                                 837);
#line 837
      (*tmp___1)("lpf_update_it: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 837
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c", 837);
#line 837
    (*tmp___1)("lpf_update_it: j = %d; column number out of range\n", j);
    }
  }
#line 839
  if (0 <= m) {
#line 839
    if (m <= m0 + n) {
#line 839
      tmp___2 = 1;
    } else {
      {
#line 839
      _glp_lib_xassert("0 <= m && m <= m0 + n", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                       839);
#line 839
      tmp___2 = 1;
      }
    }
  } else {
    {
#line 839
    _glp_lib_xassert("0 <= m && m <= m0 + n", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     839);
#line 839
    tmp___2 = 1;
    }
  }
#line 841
  if (n == lpf->n_max) {
#line 842
    lpf->valid = 0;
#line 843
    ret = 3;
#line 844
    goto done;
  }
#line 847
  i = 1;
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (! (i <= m)) {
#line 847
      goto while_break;
    }
#line 848
    *(a + i) = 0.0;
#line 847
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 849
  k = 1;
  {
#line 849
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 849
    if (! (k <= len)) {
#line 849
      goto while_break___0;
    }
#line 850
    i = (int )*(ind + k);
#line 851
    if (1 <= i) {
#line 851
      if (! (i <= m)) {
        {
#line 852
        tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                                   852);
#line 852
        (*tmp___3)("lpf_update_it: ind[%d] = %d; row number out of range\n", k, i);
        }
      }
    } else {
      {
#line 852
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                                 852);
#line 852
      (*tmp___3)("lpf_update_it: ind[%d] = %d; row number out of range\n", k, i);
      }
    }
#line 854
    if (*(a + i) != 0.0) {
      {
#line 855
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                                 855);
#line 855
      (*tmp___4)("lpf_update_it: ind[%d] = %d; duplicate row index not allowed\n",
                 k, i);
      }
    }
#line 857
    if (*(val + k) == (double const   )0.0) {
      {
#line 858
      tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                                 858);
#line 858
      (*tmp___5)("lpf_update_it: val[%d] = %g; zero element not allowed\n", k, *(val + k));
      }
    }
#line 860
    *(a + i) = (double )*(val + k);
#line 849
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 868
  i = 1;
  {
#line 868
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 868
    if (! (i <= m0 + n)) {
#line 868
      goto while_break___1;
    }
#line 869
    ii = *(P_col + i);
#line 869
    if (ii <= m) {
#line 869
      *(fg + i) = *(a + ii);
    } else {
#line 869
      *(fg + i) = 0.0;
    }
#line 868
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 871
  i = 1;
  {
#line 871
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 871
    if (! (i <= m0 + n)) {
#line 871
      goto while_break___2;
    }
#line 871
    *(vw + i) = 0.0;
#line 871
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 872
  *(vw + *(Q_col + j)) = 1.0;
#line 874
  _glp_luf_f_solve(lpf->luf, 0, f);
#line 876
  _glp_luf_v_solve(lpf->luf, 1, v);
  }
#line 879
  if (lpf->v_size < (v_ptr + m0) + m0) {
    {
#line 880
    enlarge_sva(lpf, (v_ptr + m0) + m0);
#line 881
    v_ind = lpf->v_ind;
#line 882
    v_val = lpf->v_val;
    }
  }
#line 885
  *(R_ptr + (n + 1)) = v_ptr;
#line 886
  i = 1;
  {
#line 886
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 886
    if (! (i <= m0)) {
#line 886
      goto while_break___3;
    }
#line 887
    if (*(f + i) != 0.0) {
#line 888
      *(v_ind + v_ptr) = i;
#line 888
      *(v_val + v_ptr) = *(f + i);
#line 888
      v_ptr ++;
    }
#line 886
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 890
  *(R_len + (n + 1)) = v_ptr - lpf->v_ptr;
#line 891
  lpf->v_ptr = v_ptr;
#line 893
  *(S_ptr + (n + 1)) = v_ptr;
#line 894
  i = 1;
  {
#line 894
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 894
    if (! (i <= m0)) {
#line 894
      goto while_break___4;
    }
#line 895
    if (*(v + i) != 0.0) {
#line 896
      *(v_ind + v_ptr) = i;
#line 896
      *(v_val + v_ptr) = *(v + i);
#line 896
      v_ptr ++;
    }
#line 894
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 898
  *(S_len + (n + 1)) = v_ptr - lpf->v_ptr;
#line 899
  lpf->v_ptr = v_ptr;
#line 901
  s_prod(lpf, x, - 1.0, (double const   *)f);
#line 903
  rt_prod(lpf, y, - 1.0, (double const   *)v);
#line 905
  z = 0.0;
#line 906
  i = 1;
  }
  {
#line 906
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 906
    if (! (i <= m0)) {
#line 906
      goto while_break___5;
    }
#line 906
    z -= *(v + i) * *(f + i);
#line 906
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 908
  tmp___6 = _glp_scf_update_exp(lpf->scf, (double const   *)x, (double const   *)y,
                                z);
  }
  {
#line 909
  if (tmp___6 == 0) {
#line 909
    goto case_0;
  }
#line 911
  if (tmp___6 == 1) {
#line 911
    goto case_1;
  }
#line 915
  if (tmp___6 == 2) {
#line 915
    goto case_2;
  }
#line 917
  goto switch_default;
  case_0: /* CIL Label */ 
#line 910
  goto switch_break;
  case_1: /* CIL Label */ 
#line 912
  lpf->valid = 0;
#line 913
  ret = 1;
#line 914
  goto done;
  case_2: /* CIL Label */ 
#line 916
  if ((unsigned long )lpf != (unsigned long )lpf) {
#line 916
    tmp___7 = 1;
  } else {
    {
#line 916
    _glp_lib_xassert("lpf != lpf", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     916);
#line 916
    tmp___7 = 1;
    }
  }
  switch_default: /* CIL Label */ 
#line 918
  if ((unsigned long )lpf != (unsigned long )lpf) {
#line 918
    tmp___8 = 1;
  } else {
    {
#line 918
    _glp_lib_xassert("lpf != lpf", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     918);
#line 918
    tmp___8 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 921
  tmp___9 = (m0 + n) + 1;
#line 921
  *(P_col + ((m0 + n) + 1)) = tmp___9;
#line 921
  *(P_row + ((m0 + n) + 1)) = tmp___9;
#line 923
  tmp___10 = (m0 + n) + 1;
#line 923
  *(Q_col + ((m0 + n) + 1)) = tmp___10;
#line 923
  *(Q_row + ((m0 + n) + 1)) = tmp___10;
#line 925
  i = *(Q_col + j);
#line 925
  ii = *(Q_col + ((m0 + n) + 1));
#line 926
  *(Q_row + i) = (m0 + n) + 1;
#line 926
  *(Q_col + ((m0 + n) + 1)) = i;
#line 927
  *(Q_row + ii) = j;
#line 927
  *(Q_col + j) = ii;
#line 929
  (lpf->n) ++;
#line 930
  if (lpf->n <= lpf->n_max) {
#line 930
    tmp___11 = 1;
  } else {
    {
#line 930
    _glp_lib_xassert("lpf->n <= lpf->n_max", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     930);
#line 930
    tmp___11 = 1;
    }
  }
#line 932
  ret = 0;
  done: 
#line 934
  return (ret);
}
}
#line 953 "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c"
void _glp_lpf_delete_it(LPF *lpf ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 954
  _glp_luf_delete_it(lpf->luf);
  }
#line 958
  if ((unsigned long )lpf->B == (unsigned long )((void *)0)) {
#line 958
    tmp = 1;
  } else {
    {
#line 958
    _glp_lib_xassert("lpf->B == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplpf.c",
                     958);
#line 958
    tmp = 1;
    }
  }
#line 960
  if ((unsigned long )lpf->R_ptr != (unsigned long )((void *)0)) {
    {
#line 960
    _glp_lib_xfree((void *)lpf->R_ptr);
    }
  }
#line 961
  if ((unsigned long )lpf->R_len != (unsigned long )((void *)0)) {
    {
#line 961
    _glp_lib_xfree((void *)lpf->R_len);
    }
  }
#line 962
  if ((unsigned long )lpf->S_ptr != (unsigned long )((void *)0)) {
    {
#line 962
    _glp_lib_xfree((void *)lpf->S_ptr);
    }
  }
#line 963
  if ((unsigned long )lpf->S_len != (unsigned long )((void *)0)) {
    {
#line 963
    _glp_lib_xfree((void *)lpf->S_len);
    }
  }
#line 964
  if ((unsigned long )lpf->scf != (unsigned long )((void *)0)) {
    {
#line 964
    _glp_scf_delete_it(lpf->scf);
    }
  }
#line 965
  if ((unsigned long )lpf->P_row != (unsigned long )((void *)0)) {
    {
#line 965
    _glp_lib_xfree((void *)lpf->P_row);
    }
  }
#line 966
  if ((unsigned long )lpf->P_col != (unsigned long )((void *)0)) {
    {
#line 966
    _glp_lib_xfree((void *)lpf->P_col);
    }
  }
#line 967
  if ((unsigned long )lpf->Q_row != (unsigned long )((void *)0)) {
    {
#line 967
    _glp_lib_xfree((void *)lpf->Q_row);
    }
  }
#line 968
  if ((unsigned long )lpf->Q_col != (unsigned long )((void *)0)) {
    {
#line 968
    _glp_lib_xfree((void *)lpf->Q_col);
    }
  }
#line 969
  if ((unsigned long )lpf->v_ind != (unsigned long )((void *)0)) {
    {
#line 969
    _glp_lib_xfree((void *)lpf->v_ind);
    }
  }
#line 970
  if ((unsigned long )lpf->v_val != (unsigned long )((void *)0)) {
    {
#line 970
    _glp_lib_xfree((void *)lpf->v_val);
    }
  }
#line 971
  if ((unsigned long )lpf->work1 != (unsigned long )((void *)0)) {
    {
#line 971
    _glp_lib_xfree((void *)lpf->work1);
    }
  }
#line 972
  if ((unsigned long )lpf->work2 != (unsigned long )((void *)0)) {
    {
#line 972
    _glp_lib_xfree((void *)lpf->work2);
    }
  }
  {
#line 973
  _glp_lib_xfree((void *)lpf);
  }
#line 974
  return;
}
}
#line 269 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
void _glp_lib_err_msg(char const   *msg ) ;
#line 383
void *_glp_xdlopen(char const   *module ) ;
#line 386
void *_glp_xdlsym(void *h , char const   *symbol ) ;
#line 389
void _glp_xdlclose(void *h ) ;
#line 140 "/home/wslee/benchmarks/glpk-4.38/src/glplib12.c"
void *_glp_xdlopen(char const   *module ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 141
  if ((unsigned long )module == (unsigned long )module) {
#line 141
    tmp = 1;
  } else {
    {
#line 141
    _glp_lib_xassert("module == module", "/home/wslee/benchmarks/glpk-4.38/src/glplib12.c",
                     141);
#line 141
    tmp = 1;
    }
  }
  {
#line 142
  _glp_lib_err_msg("Shared libraries not supported");
  }
#line 143
  return ((void *)0);
}
}
#line 146 "/home/wslee/benchmarks/glpk-4.38/src/glplib12.c"
void *_glp_xdlsym(void *h , char const   *symbol ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 147
  if ((unsigned long )h != (unsigned long )h) {
#line 147
    tmp = 1;
  } else {
    {
#line 147
    _glp_lib_xassert("h != h", "/home/wslee/benchmarks/glpk-4.38/src/glplib12.c",
                     147);
#line 147
    tmp = 1;
    }
  }
#line 148
  if ((unsigned long )symbol != (unsigned long )symbol) {
#line 148
    tmp___0 = 1;
  } else {
    {
#line 148
    _glp_lib_xassert("symbol != symbol", "/home/wslee/benchmarks/glpk-4.38/src/glplib12.c",
                     148);
#line 148
    tmp___0 = 1;
    }
  }
#line 149
  return ((void *)0);
}
}
#line 152 "/home/wslee/benchmarks/glpk-4.38/src/glplib12.c"
void _glp_xdlclose(void *h ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 153
  if ((unsigned long )h != (unsigned long )h) {
#line 153
    tmp = 1;
  } else {
    {
#line 153
    _glp_lib_xassert("h != h", "/home/wslee/benchmarks/glpk-4.38/src/glplib12.c",
                     153);
#line 153
    tmp = 1;
    }
  }
#line 154
  return;
}
}
#line 104 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 165 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 347 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
char *_glp_lib_strrev(char *s ) ;
#line 351
int _glp_lib_gcd(int x , int y ) ;
#line 355
int _glp_lib_gcdn(int n , int *x ) ;
#line 359
int _glp_lib_lcm(int x , int y ) ;
#line 363
int _glp_lib_lcmn(int n , int *x ) ;
#line 371
int _glp_lib_fp2rat(double x , double eps , double *p , double *q ) ;
#line 51 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_str2int(char const   *str , int *_val ) 
{ 
  int d___0 ;
  int k ;
  int s ;
  int val ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 52
  val = 0;
#line 54
  if ((int const   )*(str + 0) == 43) {
#line 55
    s = 1;
#line 55
    k = 1;
  } else
#line 56
  if ((int const   )*(str + 0) == 45) {
#line 57
    s = -1;
#line 57
    k = 1;
  } else {
#line 59
    s = 1;
#line 59
    k = 0;
  }
  {
#line 61
  tmp = __ctype_b_loc();
  }
#line 61
  if (! ((int const   )*(*tmp + (int )((unsigned char )*(str + k))) & 2048)) {
#line 61
    return (2);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    tmp___1 = __ctype_b_loc();
    }
#line 63
    if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*(str + k))) & 2048)) {
#line 63
      goto while_break;
    }
#line 64
    tmp___0 = k;
#line 64
    k ++;
#line 64
    d___0 = (int )((int const   )*(str + tmp___0) - 48);
#line 65
    if (s > 0) {
#line 66
      if (val > 214748364) {
#line 66
        return (1);
      }
#line 67
      val *= 10;
#line 68
      if (val > 2147483647 - d___0) {
#line 68
        return (1);
      }
#line 69
      val += d___0;
    } else {
#line 72
      if (val < -214748364) {
#line 72
        return (1);
      }
#line 73
      val *= 10;
#line 74
      if (val < (-0x7FFFFFFF-1) + d___0) {
#line 74
        return (1);
      }
#line 75
      val -= d___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if ((int const   )*(str + k) != 0) {
#line 79
    return (2);
  }
#line 81
  *_val = val;
#line 82
  return (0);
}
}
#line 110 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_str2num(char const   *str , double *_val ) 
{ 
  int k ;
  double val ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *endptr ;

  {
#line 114
  if ((int const   )*(str + 0) == 43) {
#line 114
    k = 1;
  } else
#line 114
  if ((int const   )*(str + 0) == 45) {
#line 114
    k = 1;
  } else {
#line 114
    k = 0;
  }
#line 116
  if ((int const   )*(str + k) == 46) {
    {
#line 117
    k ++;
#line 119
    tmp = __ctype_b_loc();
    }
#line 119
    if (! ((int const   )*(*tmp + (int )((unsigned char )*(str + k))) & 2048)) {
#line 119
      return (2);
    }
#line 120
    k ++;
#line 121
    goto frac;
  }
  {
#line 124
  tmp___0 = __ctype_b_loc();
  }
#line 124
  if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(str + k))) & 2048)) {
#line 124
    return (2);
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    tmp___1 = __ctype_b_loc();
    }
#line 126
    if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*(str + k))) & 2048)) {
#line 126
      goto while_break;
    }
#line 126
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((int const   )*(str + k) == 46) {
#line 128
    k ++;
  }
  frac: 
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 130
    tmp___2 = __ctype_b_loc();
    }
#line 130
    if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*(str + k))) & 2048)) {
#line 130
      goto while_break___0;
    }
#line 130
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 132
  if ((int const   )*(str + k) == 69) {
#line 132
    goto _L;
  } else
#line 132
  if ((int const   )*(str + k) == 101) {
    _L: /* CIL Label */ 
#line 133
    k ++;
#line 135
    if ((int const   )*(str + k) == 43) {
#line 135
      k ++;
    } else
#line 135
    if ((int const   )*(str + k) == 45) {
#line 135
      k ++;
    }
    {
#line 137
    tmp___3 = __ctype_b_loc();
    }
#line 137
    if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*(str + k))) & 2048)) {
#line 137
      return (2);
    }
  }
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 140
    tmp___4 = __ctype_b_loc();
    }
#line 140
    if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*(str + k))) & 2048)) {
#line 140
      goto while_break___1;
    }
#line 140
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 142
  if ((int const   )*(str + k) != 0) {
#line 142
    return (2);
  }
  {
#line 145
  val = strtod((char const   */* __restrict  */)str, (char **/* __restrict  */)(& endptr));
  }
#line 146
  if ((int )*endptr != 0) {
#line 146
    return (2);
  }
#line 149
  if (- 1.7976931348623157e+308 <= val) {
#line 149
    if (! (val <= 1.7976931348623157e+308)) {
#line 149
      return (1);
    }
  } else {
#line 149
    return (1);
  }
#line 151
  if (- 2.2250738585072014e-308 < val) {
#line 151
    if (val < 2.2250738585072014e-308) {
#line 151
      val = 0.0;
    }
  }
#line 153
  *_val = val;
#line 154
  return (0);
}
}
#line 181 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
char *_glp_lib_strspx(char *str ) 
{ 
  char *s ;
  char *t ;
  char *tmp ;

  {
#line 183
  t = str;
#line 183
  s = t;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! *s) {
#line 183
      goto while_break;
    }
#line 183
    if ((int )*s != 32) {
#line 183
      tmp = t;
#line 183
      t ++;
#line 183
      *tmp = *s;
    }
#line 183
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  *t = (char )'\000';
#line 185
  return (str);
}
}
#line 213 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
char *_glp_lib_strtrim(char *str ) 
{ 
  char *t ;
  char *tmp ;

  {
  {
#line 215
  tmp = strrchr((char const   *)str, '\000');
#line 215
  t = tmp - 1;
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((unsigned long )t >= (unsigned long )str)) {
#line 215
      goto while_break;
    }
#line 216
    if ((int )*t != 32) {
#line 216
      goto while_break;
    }
#line 217
    *t = (char )'\000';
#line 215
    t --;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return (str);
}
}
#line 247 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
char *_glp_lib_strrev(char *s ) 
{ 
  int i ;
  int j ;
  char t ;
  size_t tmp ;

  {
  {
#line 250
  i = 0;
#line 250
  tmp = strlen((char const   *)s);
#line 250
  j = (int )(tmp - 1U);
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < j)) {
#line 250
      goto while_break;
    }
#line 251
    t = *(s + i);
#line 251
    *(s + i) = *(s + j);
#line 251
    *(s + j) = t;
#line 250
    i ++;
#line 250
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return (s);
}
}
#line 280 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_gcd(int x , int y ) 
{ 
  int r ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 282
  if (x > 0) {
#line 282
    if (y > 0) {
#line 282
      tmp = 1;
    } else {
      {
#line 282
      _glp_lib_xassert("x > 0 && y > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c",
                       282);
#line 282
      tmp = 1;
      }
    }
  } else {
    {
#line 282
    _glp_lib_xassert("x > 0 && y > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c",
                     282);
#line 282
    tmp = 1;
    }
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (y > 0)) {
#line 283
      goto while_break;
    }
#line 284
    r = x % y;
#line 284
    x = y;
#line 284
    y = r;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  return (x);
}
}
#line 315 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_gcdn(int n , int *x ) 
{ 
  int d___0 ;
  int j ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 317
  if (n > 0) {
#line 317
    tmp = 1;
  } else {
    {
#line 317
    _glp_lib_xassert("n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c", 317);
#line 317
    tmp = 1;
    }
  }
#line 318
  j = 1;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (j <= n)) {
#line 318
      goto while_break;
    }
#line 319
    if (*(x + j) > 0) {
#line 319
      tmp___0 = 1;
    } else {
      {
#line 319
      _glp_lib_xassert("x[j] > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c",
                       319);
#line 319
      tmp___0 = 1;
      }
    }
#line 320
    if (j == 1) {
#line 321
      d___0 = *(x + 1);
    } else {
      {
#line 323
      d___0 = _glp_lib_gcd(d___0, *(x + j));
      }
    }
#line 324
    if (d___0 == 1) {
#line 324
      goto while_break;
    }
#line 318
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return (d___0);
}
}
#line 353 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_lcm(int x , int y ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 354
  if (x > 0) {
#line 354
    tmp = 1;
  } else {
    {
#line 354
    _glp_lib_xassert("x > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c", 354);
#line 354
    tmp = 1;
    }
  }
#line 355
  if (y > 0) {
#line 355
    tmp___0 = 1;
  } else {
    {
#line 355
    _glp_lib_xassert("y > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c", 355);
#line 355
    tmp___0 = 1;
    }
  }
  {
#line 356
  tmp___1 = _glp_lib_gcd(x, y);
#line 356
  y /= tmp___1;
  }
#line 357
  if (x > 2147483647 / y) {
#line 357
    return (0);
  }
#line 358
  return (x * y);
}
}
#line 385 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_lcmn(int n , int *x ) 
{ 
  int m ;
  int j ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 387
  if (n > 0) {
#line 387
    tmp = 1;
  } else {
    {
#line 387
    _glp_lib_xassert("n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c", 387);
#line 387
    tmp = 1;
    }
  }
#line 388
  j = 1;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (j <= n)) {
#line 388
      goto while_break;
    }
#line 389
    if (*(x + j) > 0) {
#line 389
      tmp___0 = 1;
    } else {
      {
#line 389
      _glp_lib_xassert("x[j] > 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c",
                       389);
#line 389
      tmp___0 = 1;
      }
    }
#line 390
    if (j == 1) {
#line 391
      m = *(x + 1);
    } else {
      {
#line 393
      m = _glp_lib_lcm(m, *(x + j));
      }
    }
#line 394
    if (m == 0) {
#line 394
      goto while_break;
    }
#line 388
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  return (m);
}
}
#line 428 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
double _glp_lib_round2n(double x ) 
{ 
  int e ;
  double f ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 431
  if (x > 0.0) {
#line 431
    tmp = 1;
  } else {
    {
#line 431
    _glp_lib_xassert("x > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c",
                     431);
#line 431
    tmp = 1;
    }
  }
  {
#line 432
  f = frexp(x, & e);
  }
#line 433
  if (f <= 0.75) {
#line 433
    tmp___0 = e - 1;
  } else {
#line 433
    tmp___0 = e;
  }
  {
#line 433
  tmp___1 = ldexp(1.0, tmp___0);
  }
#line 433
  return (tmp___1);
}
}
#line 525 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_fp2rat(double x , double eps , double *p , double *q ) 
{ 
  int k ;
  double xk ;
  double Akm1 ;
  double Ak ;
  double Bkm1 ;
  double Bk ;
  double ak ;
  double bk ;
  double fk ;
  double temp ;
  xerror_t tmp ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 528
  if (0.0 <= x) {
#line 528
    if (! (x < 1.0)) {
      {
#line 529
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib11.c", 529);
#line 529
      (*tmp)("fp2rat: x = %g; number out of range\n", x);
      }
    }
  } else {
    {
#line 529
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib11.c", 529);
#line 529
    (*tmp)("fp2rat: x = %g; number out of range\n", x);
    }
  }
#line 530
  k = 0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (k <= 100) {
#line 531
      tmp___0 = 1;
    } else {
      {
#line 531
      _glp_lib_xassert("k <= 100", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c",
                       531);
#line 531
      tmp___0 = 1;
      }
    }
#line 532
    if (k == 0) {
#line 534
      xk = x;
#line 536
      Akm1 = 1.0;
#line 538
      Ak = 0.0;
#line 540
      Bkm1 = 0.0;
#line 542
      Bk = 1.0;
    } else {
      {
#line 546
      tmp___1 = floor(xk);
#line 546
      temp = xk - tmp___1;
      }
#line 547
      if (temp != 0.0) {
#line 547
        tmp___2 = 1;
      } else {
        {
#line 547
        _glp_lib_xassert("temp != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c",
                         547);
#line 547
        tmp___2 = 1;
        }
      }
      {
#line 548
      xk = 1.0 / temp;
#line 550
      ak = 1.0;
#line 552
      bk = floor(xk);
#line 554
      temp = bk * Ak + ak * Akm1;
#line 555
      Akm1 = Ak;
#line 555
      Ak = temp;
#line 557
      temp = bk * Bk + ak * Bkm1;
#line 558
      Bkm1 = Bk;
#line 558
      Bk = temp;
      }
    }
    {
#line 561
    fk = Ak / Bk;
#line 566
    tmp___3 = fabs(x - fk);
    }
#line 566
    if (tmp___3 <= eps) {
#line 566
      goto while_break;
    }
#line 530
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  *p = Ak;
#line 569
  *q = Bk;
#line 570
  return (k);
}
}
#line 604 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_jday(int d___0 , int m , int y ) 
{ 
  int c ;
  int ya ;
  int j ;
  int dd ;

  {
#line 606
  if (1 <= d___0) {
#line 606
    if (d___0 <= 31) {
#line 606
      if (1 <= m) {
#line 606
        if (m <= 12) {
#line 606
          if (1 <= y) {
#line 606
            if (! (y <= 4000)) {
#line 608
              j = -1;
#line 609
              goto done;
            }
          } else {
#line 608
            j = -1;
#line 609
            goto done;
          }
        } else {
#line 608
          j = -1;
#line 609
          goto done;
        }
      } else {
#line 608
        j = -1;
#line 609
        goto done;
      }
    } else {
#line 608
      j = -1;
#line 609
      goto done;
    }
  } else {
#line 608
    j = -1;
#line 609
    goto done;
  }
#line 611
  if (m >= 3) {
#line 611
    m -= 3;
  } else {
#line 611
    m += 9;
#line 611
    y --;
  }
  {
#line 612
  c = y / 100;
#line 613
  ya = y - 100 * c;
#line 614
  j = ((((146097 * c) / 4 + (1461 * ya) / 4) + (153 * m + 2) / 5) + d___0) + 1721119;
#line 616
  _glp_lib_jdate(j, & dd, (int *)((void *)0), (int *)((void *)0));
  }
#line 617
  if (d___0 != dd) {
#line 617
    j = -1;
  }
  done: 
#line 618
  return (j);
}
}
#line 652 "/home/wslee/benchmarks/glpk-4.38/src/glplib11.c"
int _glp_lib_jdate(int j , int *_d , int *_m , int *_y ) 
{ 
  int d___0 ;
  int m ;
  int y ;
  int ret ;

  {
#line 653
  ret = 0;
#line 654
  if (1721426 <= j) {
#line 654
    if (! (j <= 3182395)) {
#line 655
      ret = 1;
#line 656
      goto done;
    }
  } else {
#line 655
    ret = 1;
#line 656
    goto done;
  }
#line 658
  j -= 1721119;
#line 659
  y = (4 * j - 1) / 146097;
#line 660
  j = (4 * j - 1) % 146097;
#line 661
  d___0 = j / 4;
#line 662
  j = (4 * d___0 + 3) / 1461;
#line 663
  d___0 = (4 * d___0 + 3) % 1461;
#line 664
  d___0 = (d___0 + 4) / 4;
#line 665
  m = (5 * d___0 - 3) / 153;
#line 666
  d___0 = (5 * d___0 - 3) % 153;
#line 667
  d___0 = (d___0 + 5) / 5;
#line 668
  y = 100 * y + j;
#line 669
  if (m <= 9) {
#line 669
    m += 3;
  } else {
#line 669
    m -= 9;
#line 669
    y ++;
  }
#line 670
  if ((unsigned long )_d != (unsigned long )((void *)0)) {
#line 670
    *_d = d___0;
  }
#line 671
  if ((unsigned long )_m != (unsigned long )((void *)0)) {
#line 671
    *_m = m;
  }
#line 672
  if ((unsigned long )_y != (unsigned long )((void *)0)) {
#line 672
    *_y = y;
  }
  done: 
#line 673
  return (ret);
}
}
#line 183 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 131 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
xlong_t _glp_lib_xlset(int x ) ;
#line 139
xlong_t _glp_lib_xladd(xlong_t x , xlong_t y ) ;
#line 143
xlong_t _glp_lib_xlsub(xlong_t x , xlong_t y ) ;
#line 147
int _glp_lib_xlcmp(xlong_t x , xlong_t y ) ;
#line 151
xlong_t _glp_lib_xlmul(xlong_t x , xlong_t y ) ;
#line 159
double _glp_lib_xltod(xlong_t x ) ;
#line 179
LIBENV *_glp_lib_link_env(void) ;
#line 67 "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c"
static xlong_t zeit(void) ;
#line 67 "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c"
static int const   epoch  =    (int const   )2440588;
#line 66 "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c"
static xlong_t zeit(void) 
{ 
  time_t timer ;
  struct tm *tm ;
  xlong_t t ;
  int j ;
  int tmp ;
  xlong_t tmp___0 ;
  xlong_t tmp___1 ;
  xlong_t tmp___2 ;
  xlong_t tmp___3 ;
  xlong_t tmp___4 ;
  xlong_t tmp___5 ;
  xlong_t tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 72
  timer = time((time_t *)((void *)0));
#line 73
  tm = gmtime((time_t const   *)(& timer));
#line 74
  j = _glp_lib_jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);
  }
#line 75
  if (j >= 0) {
#line 75
    tmp = 1;
  } else {
    {
#line 75
    _glp_lib_xassert("j >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c",
                     75);
#line 75
    tmp = 1;
    }
  }
  {
#line 76
  t = _glp_lib_xlset(j - (int )epoch);
#line 77
  tmp___0 = _glp_lib_xlset(24);
#line 77
  t = _glp_lib_xlmul(t, tmp___0);
#line 78
  tmp___1 = _glp_lib_xlset(tm->tm_hour);
#line 78
  t = _glp_lib_xladd(t, tmp___1);
#line 79
  tmp___2 = _glp_lib_xlset(60);
#line 79
  t = _glp_lib_xlmul(t, tmp___2);
#line 80
  tmp___3 = _glp_lib_xlset(tm->tm_min);
#line 80
  t = _glp_lib_xladd(t, tmp___3);
#line 81
  tmp___4 = _glp_lib_xlset(60);
#line 81
  t = _glp_lib_xlmul(t, tmp___4);
#line 82
  tmp___5 = _glp_lib_xlset(tm->tm_sec);
#line 82
  t = _glp_lib_xladd(t, tmp___5);
#line 83
  tmp___6 = _glp_lib_xlset(1000);
#line 83
  t = _glp_lib_xlmul(t, tmp___6);
  }
#line 84
  return (t);
}
}
#line 87 "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c"
xlong_t _glp_lib_xtime(void) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  xlong_t t ;
  clock_t c ;
  double secs ;
  int tmp___0 ;
  clock_t tmp___1 ;
  xlong_t tmp___2 ;
  xlong_t tmp___3 ;
  xlong_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 88
  tmp = _glp_lib_link_env();
#line 88
  env = tmp;
  }
#line 92
  if (sizeof(clock_t ) <= sizeof(env->c_init)) {
#line 92
    tmp___0 = 1;
  } else {
    {
#line 92
    _glp_lib_xassert("sizeof(clock_t) <= sizeof(env->c_init)", "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c",
                     92);
#line 92
    tmp___0 = 1;
    }
  }
  {
#line 93
  t = zeit();
#line 94
  tmp___3 = _glp_lib_xlset(600000);
#line 94
  tmp___4 = _glp_lib_xlsub(t, env->t_init);
#line 94
  tmp___5 = _glp_lib_xlcmp(tmp___4, tmp___3);
  }
#line 94
  if (tmp___5 <= 0) {
    {
#line 96
    memcpy((void */* __restrict  */)(& c), (void const   */* __restrict  */)(env->c_init),
           (size_t )sizeof(clock_t ));
#line 97
    tmp___1 = clock();
#line 97
    secs = (double )(tmp___1 - c) / (double )1000000L;
    }
#line 98
    if (0.0 <= secs) {
#line 98
      if (secs <= 1000.0) {
        {
#line 100
        tmp___2 = _glp_lib_xlset((int )(1000.0 * secs + 0.5));
#line 100
        t = _glp_lib_xladd(env->t_init, tmp___2);
        }
#line 101
        goto done;
      }
    }
  }
  {
#line 105
  tmp___6 = _glp_lib_xlcmp(t, env->t_last);
  }
#line 105
  if (tmp___6 < 0) {
#line 105
    t = env->t_last;
  }
  {
#line 106
  env->t_init = t;
#line 107
  c = clock();
#line 108
  memcpy((void */* __restrict  */)(env->c_init), (void const   */* __restrict  */)(& c),
         (size_t )sizeof(clock_t ));
  }
  done: 
  {
#line 109
  tmp___7 = _glp_lib_xlcmp(env->t_last, t);
  }
#line 109
  if (tmp___7 <= 0) {
#line 109
    tmp___8 = 1;
  } else {
    {
#line 109
    _glp_lib_xassert("xlcmp(env->t_last, t) <= 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c",
                     109);
#line 109
    tmp___8 = 1;
    }
  }
#line 110
  env->t_last = t;
#line 111
  return (t);
}
}
#line 115 "/home/wslee/benchmarks/glpk-4.38/src/glplib10.c"
double _glp_lib_xdifftime(xlong_t t1 , xlong_t t0 ) 
{ 
  xlong_t tmp ;
  double tmp___0 ;

  {
  {
#line 117
  tmp = _glp_lib_xlsub(t1, t0);
#line 117
  tmp___0 = _glp_lib_xltod(tmp);
  }
#line 117
  return (tmp___0 / 1000.0);
}
}
#line 367 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 287 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
int _glp_lib_xfputc(int c , XFILE *fp ) ;
#line 296
int _glp_lib_doprnt(int (*func___0)(void *info , int c ) , void *info , char const   *fmt___0 ,
                    va_list arg ) ;
#line 55 "/home/wslee/benchmarks/glpk-4.38/src/glplib09.c"
int _glp_lib_doprnt(int (*func___0)(void *info , int c ) , void *info , char const   *fmt___0 ,
                    va_list arg ) 
{ 
  int cnt ;
  int j ;
  char buf[4001] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 60
  cnt = vsnprintf((char */* __restrict  */)(buf), (size_t )sizeof(buf), (char const   */* __restrict  */)fmt___0,
                  arg);
  }
#line 64
  if (0 <= cnt) {
#line 64
    if ((unsigned long )cnt < sizeof(buf)) {
#line 64
      tmp = 1;
    } else {
      {
#line 64
      _glp_lib_xassert("0 <= cnt && cnt < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glplib09.c",
                       64);
#line 64
      tmp = 1;
      }
    }
  } else {
    {
#line 64
    _glp_lib_xassert("0 <= cnt && cnt < sizeof(buf)", "/home/wslee/benchmarks/glpk-4.38/src/glplib09.c",
                     64);
#line 64
    tmp = 1;
    }
  }
  {
#line 65
  tmp___0 = strlen((char const   *)(buf));
  }
#line 65
  if ((int )tmp___0 == cnt) {
#line 65
    tmp___1 = 1;
  } else {
    {
#line 65
    _glp_lib_xassert("(int)strlen(buf) == cnt", "/home/wslee/benchmarks/glpk-4.38/src/glplib09.c",
                     65);
#line 65
    tmp___1 = 1;
    }
  }
#line 66
  j = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (j < cnt)) {
#line 66
      goto while_break;
    }
    {
#line 67
    tmp___2 = (*func___0)(info, (int )((unsigned char )buf[j]));
    }
#line 67
    if (tmp___2 < 0) {
#line 68
      cnt = -1;
#line 69
      goto while_break;
    }
#line 66
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (cnt);
}
}
#line 77 "/home/wslee/benchmarks/glpk-4.38/src/glplib09.c"
static int my_put(void *file , int c ) 
{ 
  int tmp ;

  {
  {
#line 78
  tmp = _glp_lib_xfputc(c, (XFILE *)file);
  }
#line 78
  return (tmp);
}
}
#line 82 "/home/wslee/benchmarks/glpk-4.38/src/glplib09.c"
int _glp_lib_xfprintf(XFILE *file , char const   *fmt___0  , ...) 
{ 
  va_list arg ;
  int ret ;

  {
  {
#line 85
  __builtin_va_start(arg, fmt___0);
#line 89
  ret = _glp_lib_doprnt(& my_put, (void *)file, fmt___0, arg);
#line 91
  __builtin_va_end(arg);
  }
#line 92
  return (ret);
}
}
#line 281 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
int _glp_lib_xfeof(XFILE *fp ) ;
#line 56 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static void *c_fopen(char const   *fname , char const   *mode ) ;
#line 57
static void *z_fopen(char const   *fname , char const   *mode ) ;
#line 59 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int is_gz_file(char const   *fname ) 
{ 
  char *ext ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 60
  tmp = strrchr(fname, '.');
#line 60
  ext = tmp;
  }
#line 61
  if ((unsigned long )ext != (unsigned long )((void *)0)) {
    {
#line 61
    tmp___0 = strcmp((char const   *)ext, ".gz");
    }
#line 61
    if (tmp___0 == 0) {
#line 61
      tmp___1 = 1;
    } else {
#line 61
      tmp___1 = 0;
    }
  } else {
#line 61
    tmp___1 = 0;
  }
#line 61
  return (tmp___1);
}
}
#line 64 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
XFILE *_glp_lib_xfopen(char const   *fname , char const   *mode ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  XFILE *fp ;
  int type ;
  void *fh ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 65
  tmp = _glp_lib_link_env();
#line 65
  env = tmp;
#line 69
  tmp___0 = is_gz_file(fname);
  }
#line 69
  if (tmp___0) {
    {
#line 74
    type = 34;
#line 75
    fh = z_fopen(fname, mode);
    }
  } else {
    {
#line 70
    type = 17;
#line 71
    fh = c_fopen(fname, mode);
    }
  }
#line 77
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
#line 78
    fp = (XFILE *)((void *)0);
#line 79
    goto done;
  }
  {
#line 81
  tmp___1 = _glp_lib_xmalloc((int )sizeof(XFILE ));
#line 81
  fp = (XFILE *)tmp___1;
#line 82
  fp->type = type;
#line 83
  fp->fh = fh;
#line 84
  fp->prev = (XFILE *)((void *)0);
#line 85
  fp->next = env->file_ptr;
  }
#line 86
  if ((unsigned long )fp->next != (unsigned long )((void *)0)) {
#line 86
    (fp->next)->prev = fp;
  }
#line 87
  env->file_ptr = fp;
  done: 
#line 88
  return (fp);
}
}
#line 121
static int c_fgetc(void *_fh ) ;
#line 122
static int z_fgetc(void *fh ) ;
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
int _glp_lib_xfgetc(XFILE *fp ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 127
  if (fp->type == 17) {
#line 127
    goto case_17;
  }
#line 130
  if (fp->type == 34) {
#line 130
    goto case_34;
  }
#line 133
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 128
  c = c_fgetc(fp->fh);
  }
#line 129
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 131
  c = z_fgetc(fp->fh);
  }
#line 132
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 134
  if ((unsigned long )fp != (unsigned long )fp) {
#line 134
    tmp = 1;
  } else {
    {
#line 134
    _glp_lib_xassert("fp != fp", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     134);
#line 134
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 136
  return (c);
}
}
#line 162
static int c_fputc(int c , void *_fh ) ;
#line 163
static int z_fputc(int c , void *fh ) ;
#line 165 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
int _glp_lib_xfputc(int c , XFILE *fp ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 167
  if (fp->type == 17) {
#line 167
    goto case_17;
  }
#line 170
  if (fp->type == 34) {
#line 170
    goto case_34;
  }
#line 173
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 168
  c = c_fputc(c, fp->fh);
  }
#line 169
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 171
  c = z_fputc(c, fp->fh);
  }
#line 172
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 174
  if ((unsigned long )fp != (unsigned long )fp) {
#line 174
    tmp = 1;
  } else {
    {
#line 174
    _glp_lib_xassert("fp != fp", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     174);
#line 174
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 176
  return (c);
}
}
#line 199
static int c_ferror(void *_fh ) ;
#line 200
static int z_ferror(void *fh ) ;
#line 202 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
int _glp_lib_xferror(XFILE *fp ) 
{ 
  int ret ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 205
  if (fp->type == 17) {
#line 205
    goto case_17;
  }
#line 208
  if (fp->type == 34) {
#line 208
    goto case_34;
  }
#line 211
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 206
  ret = c_ferror(fp->fh);
  }
#line 207
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 209
  ret = z_ferror(fp->fh);
  }
#line 210
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 212
  if ((unsigned long )fp != (unsigned long )fp) {
#line 212
    tmp = 1;
  } else {
    {
#line 212
    _glp_lib_xassert("fp != fp", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     212);
#line 212
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 214
  return (ret);
}
}
#line 237
static int c_feof(void *_fh ) ;
#line 238
static int z_feof(void *fh ) ;
#line 240 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
int _glp_lib_xfeof(XFILE *fp ) 
{ 
  int ret ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 243
  if (fp->type == 17) {
#line 243
    goto case_17;
  }
#line 246
  if (fp->type == 34) {
#line 246
    goto case_34;
  }
#line 249
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 244
  ret = c_feof(fp->fh);
  }
#line 245
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 247
  ret = z_feof(fp->fh);
  }
#line 248
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 250
  if ((unsigned long )fp != (unsigned long )fp) {
#line 250
    tmp = 1;
  } else {
    {
#line 250
    _glp_lib_xassert("fp != fp", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     250);
#line 250
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 252
  return (ret);
}
}
#line 276
static int c_fflush(void *_fh ) ;
#line 277
static int z_fflush(void *fh ) ;
#line 279 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
int _glp_lib_xfflush(XFILE *fp ) 
{ 
  int ret ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 282
  if (fp->type == 17) {
#line 282
    goto case_17;
  }
#line 285
  if (fp->type == 34) {
#line 285
    goto case_34;
  }
#line 288
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 283
  ret = c_fflush(fp->fh);
  }
#line 284
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 286
  ret = z_fflush(fp->fh);
  }
#line 287
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 289
  if ((unsigned long )fp != (unsigned long )fp) {
#line 289
    tmp = 1;
  } else {
    {
#line 289
    _glp_lib_xassert("fp != fp", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     289);
#line 289
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 291
  return (ret);
}
}
#line 315
static int c_fclose(void *_fh ) ;
#line 316
static int z_fclose(void *fh ) ;
#line 318 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
int _glp_lib_xfclose(XFILE *fp ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  int ret ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 319
  tmp = _glp_lib_link_env();
#line 319
  env = tmp;
  }
  {
#line 322
  if (fp->type == 17) {
#line 322
    goto case_17;
  }
#line 325
  if (fp->type == 34) {
#line 325
    goto case_34;
  }
#line 328
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 323
  ret = c_fclose(fp->fh);
  }
#line 324
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 326
  ret = z_fclose(fp->fh);
  }
#line 327
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 329
  if ((unsigned long )fp != (unsigned long )fp) {
#line 329
    tmp___0 = 1;
  } else {
    {
#line 329
    _glp_lib_xassert("fp != fp", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     329);
#line 329
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 331
  fp->type = 15731629;
#line 332
  if ((unsigned long )fp->prev == (unsigned long )((void *)0)) {
#line 333
    env->file_ptr = fp->next;
  } else {
#line 335
    (fp->prev)->next = fp->next;
  }
#line 336
  if (! ((unsigned long )fp->next == (unsigned long )((void *)0))) {
#line 339
    (fp->next)->prev = fp->prev;
  }
  {
#line 340
  _glp_lib_xfree((void *)fp);
  }
#line 341
  return (ret);
}
}
#line 348 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static void *c_fopen(char const   *fname , char const   *mode ) 
{ 
  FILE *fh ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 350
  fh = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)mode);
  }
#line 351
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
    {
#line 352
    tmp = __errno_location();
#line 352
    tmp___0 = strerror(*tmp);
#line 352
    _glp_lib_err_msg((char const   *)tmp___0);
    }
  }
#line 353
  return ((void *)fh);
}
}
#line 356 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int c_fgetc(void *_fh ) 
{ 
  FILE *fh ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 357
  fh = (FILE *)_fh;
#line 359
  tmp = ferror(fh);
  }
#line 359
  if (tmp) {
#line 360
    c = -1;
#line 361
    goto done;
  } else {
    {
#line 359
    tmp___0 = feof(fh);
    }
#line 359
    if (tmp___0) {
#line 360
      c = -1;
#line 361
      goto done;
    }
  }
  {
#line 363
  c = fgetc(fh);
#line 364
  tmp___5 = ferror(fh);
  }
#line 364
  if (tmp___5) {
    {
#line 365
    tmp___1 = __errno_location();
#line 365
    tmp___2 = strerror(*tmp___1);
#line 365
    _glp_lib_err_msg((char const   *)tmp___2);
#line 366
    c = -1;
    }
  } else {
    {
#line 368
    tmp___4 = feof(fh);
    }
#line 368
    if (tmp___4) {
#line 369
      c = -1;
    } else
#line 371
    if (0 <= c) {
#line 371
      if (c <= 255) {
#line 371
        tmp___3 = 1;
      } else {
        {
#line 371
        _glp_lib_xassert("0x00 <= c && c <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                         371);
#line 371
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 371
      _glp_lib_xassert("0x00 <= c && c <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                       371);
#line 371
      tmp___3 = 1;
      }
    }
  }
  done: 
#line 372
  return (c);
}
}
#line 375 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int c_fputc(int c , void *_fh ) 
{ 
  FILE *fh ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 376
  fh = (FILE *)_fh;
#line 377
  tmp = ferror(fh);
  }
#line 377
  if (tmp) {
#line 378
    c = -1;
#line 379
    goto done;
  }
  {
#line 381
  c = (int )((unsigned char )c);
#line 382
  fputc(c, fh);
#line 383
  tmp___2 = ferror(fh);
  }
#line 383
  if (tmp___2) {
    {
#line 384
    tmp___0 = __errno_location();
#line 384
    tmp___1 = strerror(*tmp___0);
#line 384
    _glp_lib_err_msg((char const   *)tmp___1);
#line 385
    c = -1;
    }
  }
  done: 
#line 387
  return (c);
}
}
#line 390 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int c_ferror(void *_fh ) 
{ 
  FILE *fh ;
  int tmp ;

  {
  {
#line 391
  fh = (FILE *)_fh;
#line 392
  tmp = ferror(fh);
  }
#line 392
  return (tmp);
}
}
#line 395 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int c_feof(void *_fh ) 
{ 
  FILE *fh ;
  int tmp ;

  {
  {
#line 396
  fh = (FILE *)_fh;
#line 397
  tmp = feof(fh);
  }
#line 397
  return (tmp);
}
}
#line 400 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int c_fflush(void *_fh ) 
{ 
  FILE *fh ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 401
  fh = (FILE *)_fh;
#line 403
  ret = fflush(fh);
  }
#line 404
  if (ret != 0) {
    {
#line 405
    tmp = __errno_location();
#line 405
    tmp___0 = strerror(*tmp);
#line 405
    _glp_lib_err_msg((char const   *)tmp___0);
#line 406
    ret = -1;
    }
  }
#line 408
  return (ret);
}
}
#line 411 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int c_fclose(void *_fh ) 
{ 
  FILE *fh ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 412
  fh = (FILE *)_fh;
#line 414
  ret = fclose(fh);
  }
#line 415
  if (ret != 0) {
    {
#line 416
    tmp = __errno_location();
#line 416
    tmp___0 = strerror(*tmp);
#line 416
    _glp_lib_err_msg((char const   *)tmp___0);
#line 417
    ret = -1;
    }
  }
#line 419
  return (ret);
}
}
#line 428 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static void *z_fopen(char const   *fname , char const   *mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 429
  if ((unsigned long )fname == (unsigned long )fname) {
#line 429
    tmp = 1;
  } else {
    {
#line 429
    _glp_lib_xassert("fname == fname", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     429);
#line 429
    tmp = 1;
    }
  }
#line 430
  if ((unsigned long )mode == (unsigned long )mode) {
#line 430
    tmp___0 = 1;
  } else {
    {
#line 430
    _glp_lib_xassert("mode == mode", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     430);
#line 430
    tmp___0 = 1;
    }
  }
  {
#line 431
  _glp_lib_err_msg("Compressed files not supported");
  }
#line 432
  return ((void *)0);
}
}
#line 435 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int z_fgetc(void *fh ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 436
  if ((unsigned long )fh != (unsigned long )fh) {
#line 436
    tmp = 1;
  } else {
    {
#line 436
    _glp_lib_xassert("fh != fh", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     436);
#line 436
    tmp = 1;
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int z_fputc(int c , void *fh ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 441
  if (c != c) {
#line 441
    tmp = 1;
  } else {
    {
#line 441
    _glp_lib_xassert("c != c", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     441);
#line 441
    tmp = 1;
    }
  }
#line 442
  if ((unsigned long )fh != (unsigned long )fh) {
#line 442
    tmp___0 = 1;
  } else {
    {
#line 442
    _glp_lib_xassert("fh != fh", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     442);
#line 442
    tmp___0 = 1;
    }
  }
#line 443
  return (0);
}
}
#line 446 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int z_ferror(void *fh ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 447
  if ((unsigned long )fh != (unsigned long )fh) {
#line 447
    tmp = 1;
  } else {
    {
#line 447
    _glp_lib_xassert("fh != fh", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     447);
#line 447
    tmp = 1;
    }
  }
#line 448
  return (0);
}
}
#line 451 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int z_feof(void *fh ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 452
  if ((unsigned long )fh != (unsigned long )fh) {
#line 452
    tmp = 1;
  } else {
    {
#line 452
    _glp_lib_xassert("fh != fh", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     452);
#line 452
    tmp = 1;
    }
  }
#line 453
  return (0);
}
}
#line 456 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int z_fflush(void *fh ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 457
  if ((unsigned long )fh != (unsigned long )fh) {
#line 457
    tmp = 1;
  } else {
    {
#line 457
    _glp_lib_xassert("fh != fh", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     457);
#line 457
    tmp = 1;
    }
  }
#line 458
  return (0);
}
}
#line 461 "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c"
static int z_fclose(void *fh ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 462
  if ((unsigned long )fh != (unsigned long )fh) {
#line 462
    tmp = 1;
  } else {
    {
#line 462
    _glp_lib_xassert("fh != fh", "/home/wslee/benchmarks/glpk-4.38/src/glplib08.c",
                     462);
#line 462
    tmp = 1;
    }
  }
#line 463
  return (0);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 260 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
void _glp_lib_mem_limit(xlong_t limit ) ;
#line 264
void _glp_lib_mem_usage(int *count , int *cpeak , xlong_t *total , xlong_t *tpeak ) ;
#line 58 "/home/wslee/benchmarks/glpk-4.38/src/glplib07.c"
void *_glp_lib_xmalloc(int size ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  LIBMEM *desc ;
  int size_of_desc ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xlong_t tmp___2 ;
  xlong_t tmp___3 ;
  int tmp___4 ;
  xerror_t tmp___5 ;
  void *tmp___6 ;
  xerror_t tmp___7 ;
  xlong_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 59
  tmp = _glp_lib_link_env();
#line 59
  env = tmp;
#line 61
  size_of_desc = (int )(((sizeof(LIBMEM ) + 15UL) / 16UL) * 16UL);
  }
#line 62
  if (size < 1) {
    {
#line 63
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               63);
#line 63
    (*tmp___0)("xmalloc: size = %d; invalid parameter\n", size);
    }
  } else
#line 62
  if (size > 2147483647 - size_of_desc) {
    {
#line 63
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               63);
#line 63
    (*tmp___0)("xmalloc: size = %d; invalid parameter\n", size);
    }
  }
  {
#line 64
  size += size_of_desc;
#line 65
  tmp___2 = _glp_lib_xlsub(env->mem_limit, env->mem_total);
#line 65
  tmp___3 = _glp_lib_xlset(size);
#line 65
  tmp___4 = _glp_lib_xlcmp(tmp___3, tmp___2);
  }
#line 65
  if (tmp___4 > 0) {
    {
#line 67
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               67);
#line 67
    (*tmp___1)("xmalloc: memory limit exceeded\n");
    }
  }
#line 68
  if (env->mem_count == 2147483647) {
    {
#line 69
    tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               69);
#line 69
    (*tmp___5)("xmalloc: too many memory blocks allocated\n");
    }
  }
  {
#line 70
  tmp___6 = malloc((size_t )size);
#line 70
  desc = (LIBMEM *)tmp___6;
  }
#line 71
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
    {
#line 72
    tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               72);
#line 72
    (*tmp___7)("xmalloc: no memory available\n");
    }
  }
  {
#line 73
  memset((void *)desc, '?', (size_t )size);
#line 74
  desc->flag = 537925984;
#line 75
  desc->size = size;
#line 76
  desc->prev = (LIBMEM *)((void *)0);
#line 77
  desc->next = env->mem_ptr;
  }
#line 78
  if ((unsigned long )desc->next != (unsigned long )((void *)0)) {
#line 78
    (desc->next)->prev = desc;
  }
#line 79
  env->mem_ptr = desc;
#line 80
  (env->mem_count) ++;
#line 81
  if (env->mem_cpeak < env->mem_count) {
#line 82
    env->mem_cpeak = env->mem_count;
  }
  {
#line 83
  tmp___8 = _glp_lib_xlset(size);
#line 83
  env->mem_total = _glp_lib_xladd(env->mem_total, tmp___8);
#line 84
  tmp___9 = _glp_lib_xlcmp(env->mem_tpeak, env->mem_total);
  }
#line 84
  if (tmp___9 < 0) {
#line 85
    env->mem_tpeak = env->mem_total;
  }
#line 86
  return ((void *)((char *)desc + size_of_desc));
}
}
#line 111 "/home/wslee/benchmarks/glpk-4.38/src/glplib07.c"
void *_glp_lib_xcalloc(int n , int size ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 112
  if (n < 1) {
    {
#line 113
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c", 113);
#line 113
    (*tmp)("xcalloc: n = %d; invalid parameter\n", n);
    }
  }
#line 114
  if (size < 1) {
    {
#line 115
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               115);
#line 115
    (*tmp___0)("xcalloc: size = %d; invalid parameter\n", size);
    }
  }
#line 116
  if (n > 2147483647 / size) {
    {
#line 117
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               117);
#line 117
    (*tmp___1)("xcalloc: n = %d; size = %d; array too big\n", n, size);
    }
  }
  {
#line 118
  tmp___2 = _glp_lib_xmalloc(n * size);
  }
#line 118
  return (tmp___2);
}
}
#line 170 "/home/wslee/benchmarks/glpk-4.38/src/glplib07.c"
void _glp_lib_xfree(void *ptr ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  LIBMEM *desc ;
  int size_of_desc ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xlong_t tmp___3 ;
  int tmp___4 ;
  xlong_t tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 171
  tmp = _glp_lib_link_env();
#line 171
  env = tmp;
#line 173
  size_of_desc = (int )(((sizeof(LIBMEM ) + 15UL) / 16UL) * 16UL);
  }
#line 174
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 175
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               175);
#line 175
    (*tmp___0)("xfree: ptr = %p; null pointer\n", ptr);
    }
  }
#line 176
  desc = (LIBMEM *)((void *)((char *)ptr - size_of_desc));
#line 177
  if (desc->flag != 537925984) {
    {
#line 178
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               178);
#line 178
    (*tmp___1)("xfree: ptr = %p; invalid pointer\n", ptr);
    }
  }
#line 179
  if (env->mem_count == 0) {
    {
#line 181
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                               181);
#line 181
    (*tmp___2)("xfree: memory allocation error\n");
    }
  } else {
    {
#line 179
    tmp___3 = _glp_lib_xlset(desc->size);
#line 179
    tmp___4 = _glp_lib_xlcmp(env->mem_total, tmp___3);
    }
#line 179
    if (tmp___4 < 0) {
      {
#line 181
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib07.c",
                                 181);
#line 181
      (*tmp___2)("xfree: memory allocation error\n");
      }
    }
  }
#line 182
  if ((unsigned long )desc->prev == (unsigned long )((void *)0)) {
#line 183
    env->mem_ptr = desc->next;
  } else {
#line 185
    (desc->prev)->next = desc->next;
  }
#line 186
  if (! ((unsigned long )desc->next == (unsigned long )((void *)0))) {
#line 189
    (desc->next)->prev = desc->prev;
  }
  {
#line 190
  (env->mem_count) --;
#line 191
  tmp___5 = _glp_lib_xlset(desc->size);
#line 191
  env->mem_total = _glp_lib_xlsub(env->mem_total, tmp___5);
#line 192
  memset((void *)desc, '?', (size_t )size_of_desc);
#line 193
  free((void *)desc);
  }
#line 194
  return;
}
}
#line 212 "/home/wslee/benchmarks/glpk-4.38/src/glplib07.c"
void _glp_lib_mem_limit(xlong_t limit ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;

  {
  {
#line 213
  tmp = _glp_lib_link_env();
#line 213
  env = tmp;
#line 214
  env->mem_limit = limit;
  }
#line 215
  return;
}
}
#line 250 "/home/wslee/benchmarks/glpk-4.38/src/glplib07.c"
void _glp_lib_mem_usage(int *count , int *cpeak , xlong_t *total , xlong_t *tpeak ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;

  {
  {
#line 252
  tmp = _glp_lib_link_env();
#line 252
  env = tmp;
  }
#line 253
  if ((unsigned long )count != (unsigned long )((void *)0)) {
#line 253
    *count = env->mem_count;
  }
#line 254
  if ((unsigned long )cpeak != (unsigned long )((void *)0)) {
#line 254
    *cpeak = env->mem_cpeak;
  }
#line 255
  if ((unsigned long )total != (unsigned long )((void *)0)) {
#line 255
    *total = env->mem_total;
  }
#line 256
  if ((unsigned long )tpeak != (unsigned long )((void *)0)) {
#line 256
    *tpeak = env->mem_tpeak;
  }
#line 257
  return;
}
}
#line 123 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
void _glp_lib_bigmul(int n , int m , unsigned short *x , unsigned short *y ) ;
#line 127
void _glp_lib_bigdiv(int n , int m , unsigned short *x , unsigned short *y ) ;
#line 135
xlong_t _glp_lib_xlneg(xlong_t x ) ;
#line 155
xldiv_t _glp_lib_xldiv(xlong_t x , xlong_t y ) ;
#line 163
char *_glp_lib_xltoa(xlong_t x , char *s ) ;
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
xlong_t _glp_lib_xlset(int x ) 
{ 
  xlong_t t ;

  {
#line 42
  t.lo = x;
#line 42
  if (x >= 0) {
#line 42
    t.hi = 0;
  } else {
#line 42
    t.hi = -1;
  }
#line 43
  return (t);
}
}
#line 60 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
xlong_t _glp_lib_xlneg(xlong_t x ) 
{ 


  {
#line 61
  if (x.lo) {
#line 62
    x.lo = - x.lo;
#line 62
    x.hi = ~ x.hi;
  } else {
#line 64
    x.hi = - x.hi;
  }
#line 65
  return (x);
}
}
#line 82 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
xlong_t _glp_lib_xladd(xlong_t x , xlong_t y ) 
{ 


  {
#line 83
  if ((unsigned int )x.lo <= 4294967295U - (unsigned int )y.lo) {
#line 84
    x.lo += y.lo;
#line 84
    x.hi += y.hi;
  } else {
#line 86
    x.lo += y.lo;
#line 86
    x.hi += y.hi + 1;
  }
#line 87
  return (x);
}
}
#line 104 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
xlong_t _glp_lib_xlsub(xlong_t x , xlong_t y ) 
{ 
  xlong_t tmp ;
  xlong_t tmp___0 ;

  {
  {
#line 105
  tmp = _glp_lib_xlneg(y);
#line 105
  tmp___0 = _glp_lib_xladd(x, tmp);
  }
#line 105
  return (tmp___0);
}
}
#line 123 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
int _glp_lib_xlcmp(xlong_t x , xlong_t y ) 
{ 


  {
#line 124
  if (x.hi >= 0) {
#line 124
    if (y.hi < 0) {
#line 124
      return (1);
    }
  }
#line 125
  if (x.hi < 0) {
#line 125
    if (y.hi >= 0) {
#line 125
      return (-1);
    }
  }
#line 126
  if ((unsigned int )x.hi < (unsigned int )y.hi) {
#line 126
    return (-1);
  }
#line 127
  if ((unsigned int )x.hi > (unsigned int )y.hi) {
#line 127
    return (1);
  }
#line 128
  if ((unsigned int )x.lo < (unsigned int )y.lo) {
#line 128
    return (-1);
  }
#line 129
  if ((unsigned int )x.lo > (unsigned int )y.lo) {
#line 129
    return (1);
  }
#line 130
  return (0);
}
}
#line 147 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
xlong_t _glp_lib_xlmul(xlong_t x , xlong_t y ) 
{ 
  unsigned short xx[8] ;
  unsigned short yy[4] ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 149
  xx[4] = (unsigned short )x.lo;
#line 150
  xx[5] = (unsigned short )(x.lo >> 16);
#line 151
  xx[6] = (unsigned short )x.hi;
#line 152
  xx[7] = (unsigned short )(x.hi >> 16);
#line 153
  yy[0] = (unsigned short )y.lo;
#line 154
  yy[1] = (unsigned short )(y.lo >> 16);
#line 155
  yy[2] = (unsigned short )y.hi;
#line 156
  yy[3] = (unsigned short )(y.hi >> 16);
#line 157
  _glp_lib_bigmul(4, 4, xx, yy);
#line 158
  x.lo = (int )((unsigned int )xx[0] | ((unsigned int )xx[1] << 16));
#line 159
  x.hi = (int )((unsigned int )xx[2] | ((unsigned int )xx[3] << 16));
  }
#line 160
  return (x);
}
}
#line 179 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
xldiv_t _glp_lib_xldiv(xlong_t x , xlong_t y ) 
{ 
  xldiv_t t ;
  int m ;
  int sx ;
  int sy ;
  unsigned short xx[8] ;
  unsigned short yy[4] ;
  xerror_t tmp ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 184
  sx = x.hi < 0;
#line 186
  sy = y.hi < 0;
#line 188
  if (sx) {
    {
#line 188
    x = _glp_lib_xlneg(x);
    }
  }
#line 190
  if (sy) {
    {
#line 190
    y = _glp_lib_xlneg(y);
    }
  }
#line 192
  xx[0] = (unsigned short )x.lo;
#line 193
  xx[1] = (unsigned short )(x.lo >> 16);
#line 194
  xx[2] = (unsigned short )x.hi;
#line 195
  xx[3] = (unsigned short )(x.hi >> 16);
#line 196
  yy[0] = (unsigned short )y.lo;
#line 197
  yy[1] = (unsigned short )(y.lo >> 16);
#line 198
  yy[2] = (unsigned short )y.hi;
#line 199
  yy[3] = (unsigned short )(y.hi >> 16);
#line 200
  if (yy[3]) {
#line 201
    m = 4;
  } else
#line 202
  if (yy[2]) {
#line 203
    m = 3;
  } else
#line 204
  if (yy[1]) {
#line 205
    m = 2;
  } else
#line 206
  if (yy[0]) {
#line 207
    m = 1;
  } else {
    {
#line 209
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glplib06.c", 209);
#line 209
    (*tmp)("xldiv: divide by zero\n");
    }
  }
  {
#line 210
  _glp_lib_bigdiv(4 - m, m, xx, yy);
#line 212
  t.rem.lo = (int )((unsigned int )xx[0]);
#line 212
  t.rem.hi = 0;
  }
#line 213
  if (m >= 2) {
#line 213
    t.rem.lo = (int )((unsigned int )t.rem.lo | ((unsigned int )xx[1] << 16));
  }
#line 214
  if (m >= 3) {
#line 214
    t.rem.hi = (int )((unsigned int )xx[2]);
  }
#line 215
  if (m >= 4) {
#line 215
    t.rem.hi = (int )((unsigned int )t.rem.hi | ((unsigned int )xx[3] << 16));
  }
#line 216
  if (sx) {
    {
#line 216
    t.rem = _glp_lib_xlneg(t.rem);
    }
  }
#line 218
  t.quot.lo = (int )((unsigned int )xx[m]);
#line 218
  t.quot.hi = 0;
#line 219
  if (m <= 3) {
#line 219
    t.quot.lo = (int )((unsigned int )t.quot.lo | ((unsigned int )xx[m + 1] << 16));
  }
#line 220
  if (m <= 2) {
#line 220
    t.quot.hi = (int )((unsigned int )xx[m + 2]);
  }
#line 221
  if (m <= 1) {
#line 221
    t.quot.hi = (int )((unsigned int )t.quot.hi | ((unsigned int )xx[m + 3] << 16));
  }
#line 222
  if (sx ^ sy) {
    {
#line 222
    t.quot = _glp_lib_xlneg(t.quot);
    }
  }
#line 223
  return (t);
}
}
#line 240 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
double _glp_lib_xltod(xlong_t x ) 
{ 
  double s ;
  double z ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 242
  if (x.hi >= 0) {
#line 243
    s = 1.0;
  } else {
    {
#line 245
    s = - 1.0;
#line 245
    x = _glp_lib_xlneg(x);
    }
  }
#line 246
  if (x.hi >= 0) {
#line 247
    z = 4294967296.0 * (double )x.hi + (double )((unsigned int )x.lo);
  } else {
#line 249
    if ((unsigned int )x.hi == 2147483648U) {
#line 249
      if (x.lo == 0) {
#line 249
        tmp = 1;
      } else {
        {
#line 249
        _glp_lib_xassert("x.hi == 0x80000000 && x.lo == 0x00000000", "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c",
                         249);
#line 249
        tmp = 1;
        }
      }
    } else {
      {
#line 249
      _glp_lib_xassert("x.hi == 0x80000000 && x.lo == 0x00000000", "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c",
                       249);
#line 249
      tmp = 1;
      }
    }
#line 250
    z = 9223372036854775808.0;
  }
#line 252
  return (s * z);
}
}
#line 257 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
static char const   *d  =    "0123456789";
#line 255 "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c"
char *_glp_lib_xltoa(xlong_t x , char *s ) 
{ 
  xldiv_t t ;
  int neg ;
  int len ;
  xlong_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 260
  if (x.hi >= 0) {
#line 261
    neg = 0;
  } else {
    {
#line 263
    neg = 1;
#line 263
    x = _glp_lib_xlneg(x);
    }
  }
#line 264
  if (x.hi >= 0) {
#line 265
    len = 0;
    {
#line 266
    while (1) {
      while_continue: /* CIL Label */ ;
#line 266
      if (x.hi == 0) {
#line 266
        if (x.lo == 0) {
#line 266
          goto while_break;
        }
      }
      {
#line 267
      tmp = _glp_lib_xlset(10);
#line 267
      t = _glp_lib_xldiv(x, tmp);
      }
#line 268
      if (0 <= t.rem.lo) {
#line 268
        if (t.rem.lo <= 9) {
#line 268
          tmp___0 = 1;
        } else {
          {
#line 268
          _glp_lib_xassert("0 <= t.rem.lo && t.rem.lo <= 9", "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c",
                           268);
#line 268
          tmp___0 = 1;
          }
        }
      } else {
        {
#line 268
        _glp_lib_xassert("0 <= t.rem.lo && t.rem.lo <= 9", "/home/wslee/benchmarks/glpk-4.38/src/glplib06.c",
                         268);
#line 268
        tmp___0 = 1;
        }
      }
#line 269
      tmp___1 = len;
#line 269
      len ++;
#line 269
      *(s + tmp___1) = (char )*(d + t.rem.lo);
#line 270
      x = t.quot;
    }
    while_break: /* CIL Label */ ;
    }
#line 272
    if (len == 0) {
#line 272
      tmp___2 = len;
#line 272
      len ++;
#line 272
      *(s + tmp___2) = (char )*(d + 0);
    }
#line 273
    if (neg) {
#line 273
      tmp___3 = len;
#line 273
      len ++;
#line 273
      *(s + tmp___3) = (char )'-';
    }
    {
#line 274
    *(s + len) = (char )'\000';
#line 275
    _glp_lib_strrev(s);
    }
  } else {
    {
#line 278
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)"-9223372036854775808");
    }
  }
#line 279
  return (s);
}
}
#line 73 "/home/wslee/benchmarks/glpk-4.38/src/glplib05.c"
void _glp_lib_bigmul(int n , int m , unsigned short *x , unsigned short *y ) 
{ 
  int i ;
  int j ;
  unsigned int t ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 76
  if (n >= 1) {
#line 76
    tmp = 1;
  } else {
    {
#line 76
    _glp_lib_xassert("n >= 1", "/home/wslee/benchmarks/glpk-4.38/src/glplib05.c",
                     76);
#line 76
    tmp = 1;
    }
  }
#line 77
  if (m >= 1) {
#line 77
    tmp___0 = 1;
  } else {
    {
#line 77
    _glp_lib_xassert("m >= 1", "/home/wslee/benchmarks/glpk-4.38/src/glplib05.c",
                     77);
#line 77
    tmp___0 = 1;
    }
  }
#line 78
  j = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (j < m)) {
#line 78
      goto while_break;
    }
#line 78
    *(x + j) = (unsigned short)0;
#line 78
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break___0;
    }
#line 80
    if (*(x + (i + m))) {
#line 81
      t = 0U;
#line 82
      j = 0;
      {
#line 82
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 82
        if (! (j < m)) {
#line 82
          goto while_break___1;
        }
#line 83
        t += (unsigned int )*(x + (i + m)) * (unsigned int )*(y + j) + (unsigned int )*(x + (i + j));
#line 85
        *(x + (i + j)) = (unsigned short )t;
#line 86
        t >>= 16;
#line 82
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 88
      *(x + (i + m)) = (unsigned short )t;
    }
#line 79
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 130 "/home/wslee/benchmarks/glpk-4.38/src/glplib05.c"
void _glp_lib_bigdiv(int n , int m , unsigned short *x , unsigned short *y ) 
{ 
  int i ;
  int j ;
  unsigned int t ;
  unsigned short d___0 ;
  unsigned short q ;
  unsigned short r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 134
  if (n >= 0) {
#line 134
    tmp = 1;
  } else {
    {
#line 134
    _glp_lib_xassert("n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib05.c",
                     134);
#line 134
    tmp = 1;
    }
  }
#line 135
  if (m >= 1) {
#line 135
    tmp___0 = 1;
  } else {
    {
#line 135
    _glp_lib_xassert("m >= 1", "/home/wslee/benchmarks/glpk-4.38/src/glplib05.c",
                     135);
#line 135
    tmp___0 = 1;
    }
  }
#line 136
  if ((int )*(y + (m - 1)) != 0) {
#line 136
    tmp___1 = 1;
  } else {
    {
#line 136
    _glp_lib_xassert("y[m-1] != 0", "/home/wslee/benchmarks/glpk-4.38/src/glplib05.c",
                     136);
#line 136
    tmp___1 = 1;
    }
  }
#line 138
  if (m == 1) {
#line 139
    d___0 = (unsigned short)0;
#line 140
    i = n;
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! (i >= 0)) {
#line 140
        goto while_break;
      }
#line 141
      t = ((unsigned int )d___0 << 16) + (unsigned int )*(x + i);
#line 142
      *(x + (i + 1)) = (unsigned short )(t / (unsigned int )*(y + 0));
#line 143
      d___0 = (unsigned short )(t % (unsigned int )*(y + 0));
#line 140
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 145
    *(x + 0) = d___0;
#line 146
    goto done;
  }
#line 150
  d___0 = (unsigned short )(65536U / ((unsigned int )*(y + (m - 1)) + 1U));
#line 151
  if ((int )d___0 == 1) {
#line 152
    *(x + (n + m)) = (unsigned short)0;
  } else {
#line 154
    t = 0U;
#line 155
    i = 0;
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 155
      if (! (i < n + m)) {
#line 155
        goto while_break___0;
      }
#line 156
      t += (unsigned int )*(x + i) * (unsigned int )d___0;
#line 157
      *(x + i) = (unsigned short )t;
#line 158
      t >>= 16;
#line 155
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 160
    *(x + (n + m)) = (unsigned short )t;
#line 161
    t = 0U;
#line 162
    j = 0;
    {
#line 162
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 162
      if (! (j < m)) {
#line 162
        goto while_break___1;
      }
#line 163
      t += (unsigned int )*(y + j) * (unsigned int )d___0;
#line 164
      *(y + j) = (unsigned short )t;
#line 165
      t >>= 16;
#line 162
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 169
  i = n;
  {
#line 169
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 169
    if (! (i >= 0)) {
#line 169
      goto while_break___2;
    }
#line 171
    if ((int )*(x + (i + m)) < (int )*(y + (m - 1))) {
#line 172
      t = ((unsigned int )*(x + (i + m)) << 16) + (unsigned int )*(x + ((i + m) - 1));
#line 173
      q = (unsigned short )(t / (unsigned int )*(y + (m - 1)));
#line 174
      r = (unsigned short )(t % (unsigned int )*(y + (m - 1)));
#line 175
      if ((int )q == 0) {
#line 175
        goto putq;
      } else {
#line 175
        goto test;
      }
    }
#line 177
    q = (unsigned short)0;
#line 178
    r = *(x + ((i + m) - 1));
    decr: 
#line 179
    q = (unsigned short )((int )q - 1);
#line 180
    t = (unsigned int )r + (unsigned int )*(y + (m - 1));
#line 181
    r = (unsigned short )t;
#line 182
    if (t > 65535U) {
#line 182
      goto msub;
    }
    test: 
#line 183
    t = (unsigned int )*(y + (m - 2)) * (unsigned int )q;
#line 184
    if ((int )((unsigned short )(t >> 16)) > (int )r) {
#line 184
      goto decr;
    }
#line 185
    if ((int )((unsigned short )(t >> 16)) < (int )r) {
#line 185
      goto msub;
    }
#line 186
    if ((int )((unsigned short )t) > (int )*(x + ((i + m) - 2))) {
#line 186
      goto decr;
    }
    msub: 
#line 189
    if ((int )q == 0) {
#line 189
      goto putq;
    }
#line 190
    t = 0U;
#line 191
    j = 0;
    {
#line 191
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 191
      if (! (j < m)) {
#line 191
        goto while_break___3;
      }
#line 192
      t += (unsigned int )*(y + j) * (unsigned int )q;
#line 193
      if ((int )*(x + (i + j)) < (int )((unsigned short )t)) {
#line 193
        t += 65536U;
      }
#line 194
      *(x + (i + j)) = (unsigned short )((int )*(x + (i + j)) - (int )((unsigned short )t));
#line 195
      t >>= 16;
#line 191
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 197
    if ((int )*(x + (i + m)) >= (int )((unsigned short )t)) {
#line 197
      goto putq;
    }
#line 200
    q = (unsigned short )((int )q - 1);
#line 201
    t = 0U;
#line 202
    j = 0;
    {
#line 202
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 202
      if (! (j < m)) {
#line 202
        goto while_break___4;
      }
#line 203
      t += (unsigned int )*(x + (i + j)) + (unsigned int )*(y + j);
#line 204
      *(x + (i + j)) = (unsigned short )t;
#line 205
      t >>= 16;
#line 202
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    putq: 
#line 208
    *(x + (i + m)) = q;
#line 169
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 212
  if ((int )d___0 > 1) {
#line 213
    t = 0U;
#line 214
    i = m - 1;
    {
#line 214
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 214
      if (! (i >= 0)) {
#line 214
        goto while_break___5;
      }
#line 215
      t = (t << 16) + (unsigned int )*(x + i);
#line 216
      *(x + i) = (unsigned short )(t / (unsigned int )d___0);
#line 217
      t %= (unsigned int )d___0;
#line 214
      i --;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 219
    t = 0U;
#line 220
    j = m - 1;
    {
#line 220
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 220
      if (! (j >= 0)) {
#line 220
        goto while_break___6;
      }
#line 221
      t = (t << 16) + (unsigned int )*(y + j);
#line 222
      *(y + j) = (unsigned short )(t / (unsigned int )d___0);
#line 223
      t %= (unsigned int )d___0;
#line 220
      j --;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  done: 
#line 226
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 313
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
#line 191 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
int _glp_lib_xgetc(void) ;
#line 195
void _glp_lib_xputc(int c ) ;
#line 207
void _glp_lib_term_hook(int (*func___0)(void *info , char const   *s ) , void *info ) ;
#line 211
void _glp_lib_print_hook(int (*func___0)(void *info , char *buf ) , void *info ) ;
#line 304
int _glp_lib_open_log(char const   *fname ) ;
#line 308
int _glp_lib_close_log(void) ;
#line 27 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
int _glp_lib_xgetc(void) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 30
  c = fgetc(stdin);
  }
#line 31
  if (c == -1) {
#line 32
    c = -1;
  } else
#line 34
  if (0 <= c) {
#line 34
    if (c <= 255) {
#line 34
      tmp = 1;
    } else {
      {
#line 34
      _glp_lib_xassert("0x00 <= c && c <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c",
                       34);
#line 34
      tmp = 1;
      }
    }
  } else {
    {
#line 34
    _glp_lib_xassert("0x00 <= c && c <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c",
                     34);
#line 34
    tmp = 1;
    }
  }
#line 35
  return (c);
}
}
#line 52 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
void _glp_lib_xputc(int c ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  char s[2] ;
  int tmp___0 ;
  void *__cil_tmp6 ;

  {
  {
#line 53
  tmp = _glp_lib_link_env();
#line 53
  env = tmp;
  }
#line 55
  if (! env->term_out) {
#line 55
    goto skip;
  }
#line 57
  if ((unsigned long )env->term_hook != (unsigned long )((void *)0)) {
    {
#line 59
    s[0] = (char )c;
#line 59
    s[1] = (char )'\000';
#line 60
    tmp___0 = (*(env->term_hook))(env->term_info, (char const   *)(s));
    }
#line 60
    if (tmp___0 != 0) {
#line 60
      goto skip;
    }
  }
  {
#line 63
  fputc(c, stdout);
  }
#line 65
  if (c == 10) {
    {
#line 65
    fflush(stdout);
    }
  }
#line 68
  if ((unsigned long )env->log_file != (unsigned long )((void *)0)) {
    {
#line 68
    fputc(c, (FILE *)env->log_file);
    }
  }
  skip: 
#line 69
  return;
}
}
#line 87 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
void _glp_lib_xprintf(char const   *fmt___0  , ...) 
{ 
  va_list arg ;

  {
  {
#line 89
  __builtin_va_start(arg, fmt___0);
#line 90
  _glp_lib_xvprintf(fmt___0, arg);
#line 91
  __builtin_va_end(arg);
  }
#line 92
  return;
}
}
#line 108 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
static int func(void *info , int c ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 109
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 109
    tmp = 1;
  } else {
    {
#line 109
    _glp_lib_xassert("info == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c",
                     109);
#line 109
    tmp = 1;
    }
  }
#line 110
  if (0 <= c) {
#line 110
    if (c <= 255) {
#line 110
      tmp___0 = 1;
    } else {
      {
#line 110
      _glp_lib_xassert("0x00 <= c && c <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c",
                       110);
#line 110
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 110
    _glp_lib_xassert("0x00 <= c && c <= 0xFF", "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c",
                     110);
#line 110
    tmp___0 = 1;
    }
  }
  {
#line 111
  _glp_lib_xputc(c);
  }
#line 112
  return (c);
}
}
#line 115 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
void _glp_lib_xvprintf(char const   *fmt___0 , va_list arg ) 
{ 


  {
  {
#line 116
  _glp_lib_doprnt(& func, (void *)0, fmt___0, arg);
  }
#line 117
  return;
}
}
#line 153 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
void _glp_lib_term_hook(int (*func___0)(void *info , char const   *s ) , void *info ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;

  {
  {
#line 154
  tmp = _glp_lib_link_env();
#line 154
  env = tmp;
  }
#line 155
  if ((unsigned long )func___0 == (unsigned long )((void *)0)) {
#line 156
    env->term_hook = (int (*)(void *info , char const   *s ))((void *)0);
#line 157
    env->term_info = (void *)0;
  } else {
#line 160
    env->term_hook = func___0;
#line 161
    env->term_info = info;
  }
#line 163
  return;
}
}
#line 166 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
void _glp_lib_print_hook(int (*func___0)(void *info , char *buf ) , void *info ) 
{ 
  int (*hook)(void * , char const   * ) ;

  {
  {
#line 171
  hook = (int (*)(void * , char const   * ))func___0;
#line 174
  _glp_lib_term_hook(hook, info);
  }
#line 175
  return;
}
}
#line 180 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
int _glp_lib_open_log(char const   *fname ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  FILE *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 182
  tmp = _glp_lib_link_env();
#line 182
  env = tmp;
  }
#line 183
  if ((unsigned long )env->log_file != (unsigned long )((void *)0)) {
#line 185
    return (1);
  }
  {
#line 187
  tmp___0 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
#line 187
  env->log_file = (void *)tmp___0;
  }
#line 188
  if ((unsigned long )env->log_file == (unsigned long )((void *)0)) {
#line 190
    return (2);
  }
  {
#line 192
  setvbuf((FILE */* __restrict  */)env->log_file, (char */* __restrict  */)((void *)0),
          1, (size_t )8192);
  }
#line 193
  return (0);
}
}
#line 196 "/home/wslee/benchmarks/glpk-4.38/src/glplib04.c"
int _glp_lib_close_log(void) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;

  {
  {
#line 198
  tmp = _glp_lib_link_env();
#line 198
  env = tmp;
  }
#line 199
  if ((unsigned long )env->log_file == (unsigned long )((void *)0)) {
#line 201
    return (1);
  }
  {
#line 203
  fclose((FILE *)env->log_file);
#line 204
  env->log_file = (void *)0;
  }
#line 205
  return (0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 227 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
void _glp_lib_xerror2(char const   *fmt___0  , ...) ;
#line 231
void _glp_lib_fault_hook(int (*func___0)(void *info , char *buf ) , void *info ) ;
#line 44 "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c"
void _glp_lib_xassert(char const   *expr , char const   *file , int line ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 45
  tmp = _glp_lib_xerror1(file, line);
#line 45
  (*tmp)("Assertion failed: %s\n", expr);
  }
#line 47
  return;
}
}
#line 65 "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c"
xerror_t _glp_lib_xerror1(char const   *file , int line ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;

  {
  {
#line 66
  tmp = _glp_lib_link_env();
#line 66
  env = tmp;
#line 67
  env->err_file = file;
#line 68
  env->err_line = line;
  }
#line 69
  return (& _glp_lib_xerror2);
}
}
#line 72 "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c"
void _glp_lib_xerror2(char const   *fmt___0  , ...) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  va_list arg ;
  char *__cil_tmp5 ;

  {
  {
#line 73
  tmp = _glp_lib_link_env();
#line 73
  env = tmp;
#line 75
  __builtin_va_start(arg, fmt___0);
#line 76
  _glp_lib_xvprintf(fmt___0, arg);
#line 77
  __builtin_va_end(arg);
#line 78
  _glp_lib_xprintf("Error detected in file %s at line %d\n", env->err_file, env->err_line);
#line 80
  fflush(stdout);
#line 81
  fflush(stderr);
#line 82
  abort();
  }
}
}
#line 86 "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c"
void _glp_lib_fault_hook(int (*func___0)(void *info , char *buf ) , void *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 88
  if ((unsigned long )func___0 == (unsigned long )func___0) {
#line 88
    tmp = 1;
  } else {
    {
#line 88
    _glp_lib_xassert("func == func", "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c",
                     88);
#line 88
    tmp = 1;
    }
  }
#line 89
  if ((unsigned long )info == (unsigned long )info) {
#line 89
    tmp___0 = 1;
  } else {
    {
#line 89
    _glp_lib_xassert("info == info", "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c",
                     89);
#line 89
    tmp___0 = 1;
    }
  }
#line 90
  return;
}
}
#line 109 "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c"
void _glp_lib_err_msg(char const   *msg ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  int len ;
  size_t tmp___0 ;

  {
  {
#line 110
  tmp = _glp_lib_link_env();
#line 110
  env = tmp;
#line 111
  tmp___0 = strlen(msg);
#line 111
  len = (int )tmp___0;
  }
#line 112
  if ((unsigned long )len >= sizeof(env->err_msg)) {
#line 113
    len = (int )(sizeof(env->err_msg) - 1UL);
  }
  {
#line 114
  memcpy((void */* __restrict  */)(env->err_msg), (void const   */* __restrict  */)msg,
         (size_t )len);
  }
#line 115
  if (len > 0) {
#line 115
    if ((int )env->err_msg[len - 1] == 10) {
#line 115
      len --;
    }
  }
#line 116
  env->err_msg[len] = (char )'\000';
#line 117
  return;
}
}
#line 135 "/home/wslee/benchmarks/glpk-4.38/src/glplib03.c"
char const   *_glp_lib_xerrmsg(void) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;

  {
  {
#line 136
  tmp = _glp_lib_link_env();
#line 136
  env = tmp;
  }
#line 137
  return ((char const   *)(env->err_msg));
}
}
#line 167 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
void _glp_lib_set_ptr(void *ptr ) ;
#line 171
void *_glp_lib_get_ptr(void) ;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glplib02.c"
static void *tls  =    (void *)0;
#line 49 "/home/wslee/benchmarks/glpk-4.38/src/glplib02.c"
void _glp_lib_set_ptr(void *ptr ) 
{ 


  {
#line 50
  tls = ptr;
#line 51
  return;
}
}
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glplib02.c"
void *_glp_lib_get_ptr(void) 
{ 
  void *ptr ;

  {
#line 72
  ptr = tls;
#line 73
  return (ptr);
}
}
#line 175 "/home/wslee/benchmarks/glpk-4.38/src/glplib.h"
int _glp_lib_init_env(void) ;
#line 183
char const   *_glp_lib_version(void) ;
#line 187
int _glp_lib_free_env(void) ;
#line 55 "/home/wslee/benchmarks/glpk-4.38/src/glplib01.c"
int _glp_lib_init_env(void) 
{ 
  LIBENV *env ;
  int ok ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  xlong_t tmp___3 ;
  xlong_t tmp___4 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 59
  if (sizeof(char ) == 1UL) {
#line 59
    if (sizeof(short ) == 2UL) {
#line 59
      if (sizeof(int ) == 4UL) {
#line 59
        if (sizeof(void *) == 4UL) {
#line 59
          tmp = 1;
        } else
#line 59
        if (sizeof(void *) == 8UL) {
#line 59
          tmp = 1;
        } else {
#line 59
          tmp = 0;
        }
      } else {
#line 59
        tmp = 0;
      }
    } else {
#line 59
      tmp = 0;
    }
  } else {
#line 59
    tmp = 0;
  }
#line 59
  ok = tmp;
#line 62
  if (! ok) {
#line 62
    return (3);
  }
  {
#line 64
  tmp___0 = _glp_lib_get_ptr();
  }
#line 64
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 64
    return (1);
  }
  {
#line 66
  tmp___1 = malloc((size_t )sizeof(LIBENV ));
#line 66
  env = (LIBENV *)tmp___1;
  }
#line 67
  if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 67
    return (2);
  }
  {
#line 69
  sprintf((char */* __restrict  */)(env->version), (char const   */* __restrict  */)"%d.%d",
          4, 38);
#line 71
  env->mem_limit.hi = 2147483647;
#line 71
  env->mem_limit.lo = -1;
#line 72
  env->mem_ptr = (LIBMEM *)((void *)0);
#line 73
  tmp___2 = 0;
#line 73
  env->mem_cpeak = tmp___2;
#line 73
  env->mem_count = tmp___2;
#line 74
  tmp___3 = _glp_lib_xlset(0);
#line 74
  env->mem_tpeak = tmp___3;
#line 74
  env->mem_total = tmp___3;
#line 75
  env->term_out = 1;
#line 76
  env->term_hook = (int (*)(void *info , char const   *s ))((void *)0);
#line 77
  env->term_info = (void *)0;
#line 79
  strcpy((char */* __restrict  */)(env->err_msg), (char const   */* __restrict  */)"Error 0");
#line 85
  env->file_ptr = (XFILE *)((void *)0);
#line 86
  env->log_file = (void *)0;
#line 88
  env->err_file = "";
#line 89
  env->err_line = 0;
#line 90
  tmp___4 = _glp_lib_xlset(0);
#line 90
  env->t_last = tmp___4;
#line 90
  env->t_init = tmp___4;
#line 91
  memset((void *)(env->c_init), 0, (size_t )sizeof(env->c_init));
#line 94
  env->h_odbc = (void *)0;
#line 95
  env->h_mysql = (void *)0;
#line 98
  _glp_lib_set_ptr((void *)env);
  }
#line 100
  return (0);
}
}
#line 126 "/home/wslee/benchmarks/glpk-4.38/src/glplib01.c"
LIBENV *_glp_lib_link_env(void) 
{ 
  LIBENV *env ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
#line 127
  tmp = _glp_lib_get_ptr();
#line 127
  env = (LIBENV *)tmp;
  }
#line 129
  if ((unsigned long )env == (unsigned long )((void *)0)) {
    {
#line 131
    tmp___0 = _glp_lib_init_env();
    }
#line 131
    if (tmp___0 != 0) {
      {
#line 133
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GLPK library initialization failed.\n");
#line 134
      fflush(stderr);
#line 136
      abort();
      }
    }
    {
#line 139
    tmp___1 = _glp_lib_get_ptr();
#line 139
    env = (LIBENV *)tmp___1;
    }
  }
#line 141
  return (env);
}
}
#line 161 "/home/wslee/benchmarks/glpk-4.38/src/glplib01.c"
char const   *_glp_lib_version(void) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;

  {
  {
#line 162
  tmp = _glp_lib_link_env();
#line 162
  env = tmp;
  }
#line 163
  return ((char const   *)(env->version));
}
}
#line 187 "/home/wslee/benchmarks/glpk-4.38/src/glplib01.c"
int _glp_lib_free_env(void) 
{ 
  LIBENV *env ;
  void *tmp ;
  LIBMEM *desc ;

  {
  {
#line 188
  tmp = _glp_lib_get_ptr();
#line 188
  env = (LIBENV *)tmp;
  }
#line 191
  if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 191
    return (1);
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! ((unsigned long )env->file_ptr != (unsigned long )((void *)0))) {
#line 194
      goto while_break;
    }
    {
#line 195
    _glp_lib_xfclose(env->file_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )env->mem_ptr != (unsigned long )((void *)0))) {
#line 198
      goto while_break___0;
    }
    {
#line 199
    desc = env->mem_ptr;
#line 200
    env->mem_ptr = desc->next;
#line 201
    free((void *)desc);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  if ((unsigned long )env->h_odbc != (unsigned long )((void *)0)) {
    {
#line 209
    _glp_xdlclose(env->h_odbc);
    }
  }
#line 210
  if ((unsigned long )env->h_mysql != (unsigned long )((void *)0)) {
    {
#line 210
    _glp_xdlclose(env->h_mysql);
    }
  }
  {
#line 213
  free((void *)env);
#line 215
  _glp_lib_set_ptr((void *)0);
  }
#line 217
  return (0);
}
}
#line 232 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
IPPROW *_glp_ipp_add_row(IPP *ipp , double lb , double ub ) ;
#line 235
IPPCOL *_glp_ipp_add_col(IPP *ipp , int i_flag , double lb , double ub , double c ) ;
#line 239
IPPAIJ *_glp_ipp_add_aij(IPP *ipp , IPPROW *row , IPPCOL *col , double val ) ;
#line 242
void _glp_ipp_remove_row(IPP *ipp , IPPROW *row ) ;
#line 245
void _glp_ipp_remove_col(IPP *ipp , IPPCOL *col ) ;
#line 248
void _glp_ipp_enque_row(IPP *ipp , IPPROW *row ) ;
#line 251
void _glp_ipp_deque_row(IPP *ipp , IPPROW *row ) ;
#line 254
void _glp_ipp_enque_col(IPP *ipp , IPPCOL *col ) ;
#line 257
void _glp_ipp_deque_col(IPP *ipp , IPPCOL *col ) ;
#line 260
void *_glp_ipp_append_tqe(IPP *ipp , int type , int size ) ;
#line 266
int _glp_ipp_tight_bnds(IPP *ipp , IPPCOL *col , double lb , double ub ) ;
#line 281
void _glp_ipp_free_row(IPP *ipp , IPPROW *row ) ;
#line 284
void _glp_ipp_fixed_col(IPP *ipp , IPPCOL *col ) ;
#line 287
void _glp_ipp_fixed_col_r(IPP *ipp , void *_info ) ;
#line 290
int _glp_ipp_empty_row(IPP *ipp , IPPROW *row ) ;
#line 293
int _glp_ipp_empty_col(IPP *ipp , IPPCOL *col ) ;
#line 296
int _glp_ipp_row_sing(IPP *ipp , IPPROW *row ) ;
#line 299
int _glp_ipp_analyze_row(IPP *ipp , IPPROW *row ) ;
#line 307
int _glp_ipp_basic_tech(IPP *ipp ) ;
#line 310
int _glp_ipp_reduce_bnds(IPP *ipp ) ;
#line 313
void _glp_ipp_shift_col(IPP *ipp , IPPCOL *col ) ;
#line 316
void _glp_ipp_shift_col_r(IPP *ipp , void *_info ) ;
#line 319
int _glp_ipp_nonbin_col(IPP *ipp , IPPCOL *col ) ;
#line 322
void _glp_ipp_nonbin_col_r(IPP *ipp , void *_info ) ;
#line 325
void _glp_ipp_reduce_coef(IPP *ipp ) ;
#line 331
void _glp_ipp_reduction(IPP *ipp ) ;
#line 334
void _glp_ipp_postsolve(IPP *ipp ) ;
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_free_row(IPP *ipp , IPPROW *row ) 
{ 
  IPPAIJ *aij ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 44
  if (row->lb == - 1.7976931348623157e+308) {
#line 44
    if (row->ub == 1.7976931348623157e+308) {
#line 44
      tmp = 1;
    } else {
      {
#line 44
      _glp_lib_xassert("row->lb == -DBL_MAX && row->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       44);
#line 44
      tmp = 1;
      }
    }
  } else {
    {
#line 44
    _glp_lib_xassert("row->lb == -DBL_MAX && row->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     44);
#line 44
    tmp = 1;
    }
  }
#line 46
  aij = row->ptr;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 46
      goto while_break;
    }
    {
#line 47
    _glp_ipp_enque_col(ipp, aij->col);
#line 46
    aij = aij->r_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  _glp_ipp_remove_row(ipp, row);
  }
#line 50
  return;
}
}
#line 97 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_fixed_col(IPP *ipp , IPPCOL *col ) 
{ 
  struct fixed_col___0 *info ;
  IPPROW *row ;
  IPPAIJ *aij ;
  double temp ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 104
  if (col->lb == col->ub) {
#line 104
    tmp = 1;
  } else {
    {
#line 104
    _glp_lib_xassert("col->lb == col->ub", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     104);
#line 104
    tmp = 1;
    }
  }
  {
#line 106
  tmp___0 = _glp_ipp_append_tqe(ipp, 1, (int )sizeof(*info));
#line 106
  info = (struct fixed_col___0 *)tmp___0;
#line 107
  info->q = col->j;
#line 108
  info->s = col->lb;
#line 111
  aij = col->ptr;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 111
      goto while_break;
    }
#line 112
    row = aij->row;
#line 114
    temp = aij->val * info->s;
#line 115
    if (row->lb == row->ub) {
#line 116
      row->lb -= temp;
#line 117
      row->ub = row->lb;
    } else {
#line 120
      if (row->lb != - 1.7976931348623157e+308) {
#line 120
        row->lb -= temp;
      }
#line 121
      if (row->ub != 1.7976931348623157e+308) {
#line 121
        row->ub -= temp;
      }
    }
    {
#line 123
    _glp_ipp_enque_row(ipp, row);
#line 111
    aij = aij->c_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  ipp->c0 += col->c * info->s;
#line 128
  _glp_ipp_remove_col(ipp, col);
  }
#line 129
  return;
}
}
#line 132 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_fixed_col_r(IPP *ipp , void *_info ) 
{ 
  struct fixed_col___0 *info ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 134
  info = (struct fixed_col___0 *)_info;
#line 135
  if (1 <= info->q) {
#line 135
    if (info->q <= ipp->ncols) {
#line 135
      tmp = 1;
    } else {
      {
#line 135
      _glp_lib_xassert("1 <= info->q && info->q <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       135);
#line 135
      tmp = 1;
      }
    }
  } else {
    {
#line 135
    _glp_lib_xassert("1 <= info->q && info->q <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     135);
#line 135
    tmp = 1;
    }
  }
#line 136
  if (*(ipp->col_stat + info->q) == 0) {
#line 136
    tmp___0 = 1;
  } else {
    {
#line 136
    _glp_lib_xassert("ipp->col_stat[info->q] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     136);
#line 136
    tmp___0 = 1;
    }
  }
#line 137
  *(ipp->col_stat + info->q) = 1;
#line 138
  *(ipp->col_mipx + info->q) = info->s;
#line 139
  return;
}
}
#line 158 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
int _glp_ipp_empty_row(IPP *ipp , IPPROW *row ) 
{ 
  double eps ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 162
  if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
#line 162
    tmp = 1;
  } else {
    {
#line 162
    _glp_lib_xassert("row->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     162);
#line 162
    tmp = 1;
    }
  }
#line 164
  eps = 1e-5;
#line 165
  if (row->lb > eps) {
#line 165
    return (1);
  } else
#line 165
  if (row->ub < - eps) {
#line 165
    return (1);
  }
  {
#line 167
  row->lb = - 1.7976931348623157e+308;
#line 167
  row->ub = 1.7976931348623157e+308;
#line 169
  _glp_ipp_enque_row(ipp, row);
  }
#line 170
  return (0);
}
}
#line 193 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
int _glp_ipp_empty_col(IPP *ipp , IPPCOL *col ) 
{ 
  double eps ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 197
  if ((unsigned long )col->ptr == (unsigned long )((void *)0)) {
#line 197
    tmp = 1;
  } else {
    {
#line 197
    _glp_lib_xassert("col->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     197);
#line 197
    tmp = 1;
    }
  }
#line 199
  eps = 1e-5;
#line 200
  if (col->c > eps) {
#line 200
    if (col->lb == - 1.7976931348623157e+308) {
#line 201
      return (1);
    } else {
#line 200
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 200
  if (col->c < - eps) {
#line 200
    if (col->ub == 1.7976931348623157e+308) {
#line 201
      return (1);
    }
  }
#line 203
  if (col->lb == - 1.7976931348623157e+308) {
#line 203
    if (col->ub == 1.7976931348623157e+308) {
#line 205
      tmp___0 = 0.0;
#line 205
      col->ub = tmp___0;
#line 205
      col->lb = tmp___0;
    } else {
#line 203
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 207
  if (col->ub == 1.7976931348623157e+308) {
    lo: 
#line 209
    col->ub = col->lb;
  } else
#line 211
  if (col->lb == - 1.7976931348623157e+308) {
    up: 
#line 213
    col->lb = col->ub;
  } else
#line 215
  if (col->lb != col->ub) {
#line 217
    if (col->c > 0.0) {
#line 217
      goto lo;
    }
#line 218
    if (col->c < 0.0) {
#line 218
      goto up;
    }
    {
#line 219
    tmp___1 = fabs(col->lb);
#line 219
    tmp___2 = fabs(col->ub);
    }
#line 219
    if (tmp___1 <= tmp___2) {
#line 219
      goto lo;
    } else {
#line 219
      goto up;
    }
  }
  {
#line 226
  _glp_ipp_enque_col(ipp, col);
  }
#line 227
  return (0);
}
}
#line 261 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
int _glp_ipp_row_sing(IPP *ipp , IPPROW *row ) 
{ 
  IPPCOL *col ;
  IPPAIJ *aij ;
  double lb ;
  double ub ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 267
  if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 267
    if ((unsigned long )(row->ptr)->r_next == (unsigned long )((void *)0)) {
#line 267
      tmp = 1;
    } else {
      {
#line 267
      _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       267);
#line 267
      tmp = 1;
      }
    }
  } else {
    {
#line 267
    _glp_lib_xassert("row->ptr != NULL && row->ptr->r_next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     267);
#line 267
    tmp = 1;
    }
  }
#line 269
  aij = row->ptr;
#line 270
  if (aij->val > 0.0) {
#line 271
    if (row->lb == - 1.7976931348623157e+308) {
#line 271
      lb = - 1.7976931348623157e+308;
    } else {
#line 271
      lb = row->lb / aij->val;
    }
#line 272
    if (row->ub == 1.7976931348623157e+308) {
#line 272
      ub = 1.7976931348623157e+308;
    } else {
#line 272
      ub = row->ub / aij->val;
    }
  } else {
#line 275
    if (row->ub == 1.7976931348623157e+308) {
#line 275
      lb = - 1.7976931348623157e+308;
    } else {
#line 275
      lb = row->ub / aij->val;
    }
#line 276
    if (row->lb == - 1.7976931348623157e+308) {
#line 276
      ub = 1.7976931348623157e+308;
    } else {
#line 276
      ub = row->lb / aij->val;
    }
  }
  {
#line 279
  col = aij->col;
#line 280
  tmp___0 = _glp_ipp_tight_bnds(ipp, col, lb, ub);
  }
  {
#line 281
  if (tmp___0 == 0) {
#line 281
    goto case_0;
  }
#line 284
  if (tmp___0 == 1) {
#line 284
    goto case_1;
  }
#line 289
  if (tmp___0 == 2) {
#line 289
    goto case_2;
  }
#line 292
  goto switch_default;
  case_0: /* CIL Label */ 
#line 283
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 287
  _glp_ipp_enque_col(ipp, col);
  }
#line 288
  goto switch_break;
  case_2: /* CIL Label */ 
#line 291
  return (1);
  switch_default: /* CIL Label */ 
#line 293
  if ((unsigned long )ipp != (unsigned long )ipp) {
#line 293
    tmp___1 = 1;
  } else {
    {
#line 293
    _glp_lib_xassert("ipp != ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     293);
#line 293
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 296
  row->lb = - 1.7976931348623157e+308;
#line 296
  row->ub = 1.7976931348623157e+308;
#line 298
  _glp_ipp_enque_row(ipp, row);
  }
#line 299
  return (0);
}
}
#line 353 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
int _glp_ipp_analyze_row(IPP *ipp , IPPROW *row ) 
{ 
  IPPCOL *col ;
  IPPAIJ *aij ;
  double lb ;
  double ub ;
  double eps ;
  double s ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 358
  lb = 0.0;
#line 359
  aij = row->ptr;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 359
      goto while_break;
    }
#line 360
    if (lb == - 1.7976931348623157e+308) {
#line 360
      goto while_break;
    }
#line 361
    col = aij->col;
#line 362
    if (aij->val > 0.0) {
#line 363
      if (col->lb == - 1.7976931348623157e+308) {
#line 364
        lb = - 1.7976931348623157e+308;
      } else {
#line 366
        lb += aij->val * col->lb;
      }
    } else
#line 369
    if (col->ub == 1.7976931348623157e+308) {
#line 370
      lb = - 1.7976931348623157e+308;
    } else {
#line 372
      lb += aij->val * col->ub;
    }
#line 359
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  ub = 0.0;
#line 377
  aij = row->ptr;
  {
#line 377
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 377
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 377
      goto while_break___0;
    }
#line 378
    if (ub == 1.7976931348623157e+308) {
#line 378
      goto while_break___0;
    }
#line 379
    col = aij->col;
#line 380
    if (aij->val > 0.0) {
#line 381
      if (col->ub == 1.7976931348623157e+308) {
#line 382
        ub = 1.7976931348623157e+308;
      } else {
#line 384
        ub += aij->val * col->ub;
      }
    } else
#line 387
    if (col->lb == - 1.7976931348623157e+308) {
#line 388
      ub = 1.7976931348623157e+308;
    } else {
#line 390
      ub += aij->val * col->lb;
    }
#line 377
    aij = aij->r_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 394
  if (row->lb != - 1.7976931348623157e+308) {
    {
#line 395
    tmp = fabs(row->lb);
#line 395
    eps = 1e-5 * (1.0 + tmp);
    }
#line 396
    if (ub < row->lb - eps) {
#line 396
      return (1);
    }
  }
#line 398
  if (row->ub != 1.7976931348623157e+308) {
    {
#line 399
    tmp___0 = fabs(row->ub);
#line 399
    eps = 1e-5 * (1.0 + tmp___0);
    }
#line 400
    if (lb > row->ub + eps) {
#line 400
      return (1);
    }
  }
#line 403
  if (row->lb != - 1.7976931348623157e+308) {
    {
#line 404
    tmp___1 = fabs(row->lb);
#line 404
    eps = 1e-7 * (1.0 + tmp___1);
    }
#line 405
    if (ub <= row->lb + eps) {
#line 407
      aij = row->ptr;
      {
#line 407
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 407
        if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 407
          goto while_break___1;
        }
#line 408
        col = aij->col;
#line 409
        if (aij->val > 0.0) {
#line 409
          s = col->ub;
        } else {
#line 409
          s = col->lb;
        }
        {
#line 410
        tmp___2 = _glp_ipp_tight_bnds(ipp, col, s, s);
        }
        {
#line 411
        if (tmp___2 == 0) {
#line 411
          goto case_0;
        }
#line 414
        if (tmp___2 == 1) {
#line 414
          goto case_1;
        }
#line 419
        if (tmp___2 == 2) {
#line 419
          goto case_2;
        }
#line 422
        goto switch_default;
        case_0: /* CIL Label */ 
#line 413
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 417
        _glp_ipp_enque_col(ipp, col);
        }
#line 418
        goto switch_break;
        case_2: /* CIL Label */ 
#line 421
        return (1);
        switch_default: /* CIL Label */ 
#line 423
        if ((unsigned long )ipp != (unsigned long )ipp) {
#line 423
          tmp___3 = 1;
        } else {
          {
#line 423
          _glp_lib_xassert("ipp != ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                           423);
#line 423
          tmp___3 = 1;
          }
        }
        switch_break: /* CIL Label */ ;
        }
#line 407
        aij = aij->r_next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 427
      row->lb = - 1.7976931348623157e+308;
#line 427
      row->ub = 1.7976931348623157e+308;
#line 429
      _glp_ipp_enque_row(ipp, row);
      }
#line 430
      goto done;
    }
  }
#line 434
  if (row->ub != 1.7976931348623157e+308) {
    {
#line 435
    tmp___4 = fabs(row->ub);
#line 435
    eps = 1e-7 * (1.0 + tmp___4);
    }
#line 436
    if (lb >= row->ub - eps) {
#line 438
      aij = row->ptr;
      {
#line 438
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 438
        if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 438
          goto while_break___2;
        }
#line 439
        col = aij->col;
#line 440
        if (aij->val > 0.0) {
#line 440
          s = col->lb;
        } else {
#line 440
          s = col->ub;
        }
        {
#line 441
        tmp___5 = _glp_ipp_tight_bnds(ipp, col, s, s);
        }
        {
#line 442
        if (tmp___5 == 0) {
#line 442
          goto case_0___0;
        }
#line 445
        if (tmp___5 == 1) {
#line 445
          goto case_1___0;
        }
#line 450
        if (tmp___5 == 2) {
#line 450
          goto case_2___0;
        }
#line 453
        goto switch_default___0;
        case_0___0: /* CIL Label */ 
#line 444
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
        {
#line 448
        _glp_ipp_enque_col(ipp, col);
        }
#line 449
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
#line 452
        return (1);
        switch_default___0: /* CIL Label */ 
#line 454
        if ((unsigned long )ipp != (unsigned long )ipp) {
#line 454
          tmp___6 = 1;
        } else {
          {
#line 454
          _glp_lib_xassert("ipp != ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                           454);
#line 454
          tmp___6 = 1;
          }
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 438
        aij = aij->r_next;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 458
      row->lb = - 1.7976931348623157e+308;
#line 458
      row->ub = 1.7976931348623157e+308;
#line 460
      _glp_ipp_enque_row(ipp, row);
      }
#line 461
      goto done;
    }
  }
#line 465
  if (row->lb != - 1.7976931348623157e+308) {
    {
#line 466
    tmp___7 = fabs(row->lb);
#line 466
    eps = 1.001e-7 * (1.0 + tmp___7);
    }
#line 467
    if (lb >= row->lb - eps) {
#line 472
      if (row->lb != row->ub) {
#line 472
        tmp___8 = 1;
      } else {
        {
#line 472
        _glp_lib_xassert("row->lb != row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                         472);
#line 472
        tmp___8 = 1;
        }
      }
      {
#line 473
      row->lb = - 1.7976931348623157e+308;
#line 474
      _glp_ipp_enque_row(ipp, row);
      }
    }
  }
#line 478
  if (row->ub != 1.7976931348623157e+308) {
    {
#line 479
    tmp___9 = fabs(row->ub);
#line 479
    eps = 1.001e-7 * (1.0 + tmp___9);
    }
#line 480
    if (ub <= row->ub + eps) {
#line 485
      if (row->lb != row->ub) {
#line 485
        tmp___10 = 1;
      } else {
        {
#line 485
        _glp_lib_xassert("row->lb != row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                         485);
#line 485
        tmp___10 = 1;
        }
      }
      {
#line 486
      row->ub = 1.7976931348623157e+308;
#line 487
      _glp_ipp_enque_row(ipp, row);
      }
    }
  }
  done: 
#line 490
  return (0);
}
}
#line 591 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
int _glp_ipp_basic_tech(IPP *ipp ) 
{ 
  IPPROW *row ;
  IPPCOL *col ;
  int nrows ;
  int ncols ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 604
  nrows = 0;
#line 605
  row = ipp->row_ptr;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 605
      goto while_break;
    }
    {
#line 606
    _glp_ipp_enque_row(ipp, row);
#line 606
    nrows ++;
#line 605
    row = row->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  ncols = 0;
#line 608
  col = ipp->col_ptr;
  {
#line 608
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 608
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 608
      goto while_break___0;
    }
    {
#line 609
    _glp_ipp_enque_col(ipp, col);
#line 609
    ncols ++;
#line 608
    col = col->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 611
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 611
    if ((unsigned long )ipp->row_que == (unsigned long )((void *)0)) {
#line 611
      if ((unsigned long )ipp->col_que == (unsigned long )((void *)0)) {
#line 611
        goto while_break___1;
      }
    }
    {
#line 613
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 613
      if (! ((unsigned long )ipp->row_que != (unsigned long )((void *)0))) {
#line 613
        goto while_break___2;
      }
      {
#line 615
      row = ipp->row_que;
#line 617
      _glp_ipp_deque_row(ipp, row);
      }
#line 619
      if (row->lb == - 1.7976931348623157e+308) {
#line 619
        if (row->ub == 1.7976931348623157e+308) {
          {
#line 621
          _glp_ipp_free_row(ipp, row);
          }
        } else {
#line 619
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 623
      if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
        {
#line 625
        tmp = _glp_ipp_empty_row(ipp, row);
        }
#line 625
        if (tmp) {
#line 625
          return (1);
        }
      } else
#line 627
      if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 627
        if ((unsigned long )(row->ptr)->r_next == (unsigned long )((void *)0)) {
          {
#line 629
          tmp___0 = _glp_ipp_row_sing(ipp, row);
          }
#line 629
          if (tmp___0) {
#line 629
            return (1);
          }
        } else {
#line 627
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 633
        tmp___1 = _glp_ipp_analyze_row(ipp, row);
        }
#line 633
        if (tmp___1) {
#line 633
          return (1);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 637
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 637
      if (! ((unsigned long )ipp->col_que != (unsigned long )((void *)0))) {
#line 637
        goto while_break___3;
      }
      {
#line 639
      col = ipp->col_que;
#line 641
      _glp_ipp_deque_col(ipp, col);
      }
#line 643
      if (col->lb == col->ub) {
        {
#line 645
        _glp_ipp_fixed_col(ipp, col);
        }
      } else
#line 647
      if ((unsigned long )col->ptr == (unsigned long )((void *)0)) {
        {
#line 649
        tmp___2 = _glp_ipp_empty_col(ipp, col);
        }
#line 649
        if (tmp___2) {
#line 649
          return (2);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 659
  row = ipp->row_ptr;
  {
#line 659
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 659
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 659
      goto while_break___4;
    }
#line 659
    nrows --;
#line 659
    row = row->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 660
  col = ipp->col_ptr;
  {
#line 660
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 660
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 660
      goto while_break___5;
    }
#line 660
    ncols --;
#line 660
    col = col->next;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 661
  _glp_lib_xprintf("ipp_basic_tech:  %d row(s) and %d column(s) removed\n", nrows,
                   ncols);
  }
#line 663
  return (0);
}
}
#line 687 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
static int reduce_bounds(IPP *ipp , IPPROW *row ) 
{ 
  IPPCOL *col ;
  IPPCOL *c_min ;
  IPPCOL *c_max ;
  IPPAIJ *aij ;
  int flag ;
  double f_min ;
  double f_max ;
  double ff_min ;
  double ff_max ;
  double lb ;
  double ub ;
  double delta ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 693
  c_min = (IPPCOL *)((void *)0);
#line 693
  f_min = 0.0;
#line 694
  aij = row->ptr;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 694
      goto while_break;
    }
#line 695
    col = aij->col;
#line 696
    if (aij->val > 0.0) {
#line 696
      if (col->lb == - 1.7976931348623157e+308) {
#line 696
        goto _L;
      } else {
#line 696
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 696
    if (aij->val < 0.0) {
#line 696
      if (col->ub == 1.7976931348623157e+308) {
        _L: /* CIL Label */ 
#line 698
        if ((unsigned long )c_min == (unsigned long )((void *)0)) {
#line 699
          c_min = col;
        } else {
#line 701
          f_min = - 1.7976931348623157e+308;
#line 702
          goto while_break;
        }
      } else {
#line 696
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 706
      if (aij->val > 0.0) {
#line 706
        tmp = col->lb;
      } else {
#line 706
        tmp = col->ub;
      }
#line 706
      f_min += aij->val * tmp;
    }
#line 694
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  c_max = (IPPCOL *)((void *)0);
#line 709
  f_max = 0.0;
#line 710
  aij = row->ptr;
  {
#line 710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 710
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 710
      goto while_break___0;
    }
#line 711
    col = aij->col;
#line 712
    if (aij->val > 0.0) {
#line 712
      if (col->ub == 1.7976931348623157e+308) {
#line 712
        goto _L___2;
      } else {
#line 712
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 712
    if (aij->val < 0.0) {
#line 712
      if (col->lb == - 1.7976931348623157e+308) {
        _L___2: /* CIL Label */ 
#line 714
        if ((unsigned long )c_max == (unsigned long )((void *)0)) {
#line 715
          c_max = col;
        } else {
#line 717
          f_max = 1.7976931348623157e+308;
#line 718
          goto while_break___0;
        }
      } else {
#line 712
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 722
      if (aij->val > 0.0) {
#line 722
        tmp___0 = col->ub;
      } else {
#line 722
        tmp___0 = col->lb;
      }
#line 722
      f_max += aij->val * tmp___0;
    }
#line 710
    aij = aij->r_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 725
  aij = row->ptr;
  {
#line 725
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 725
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 725
      goto while_break___1;
    }
#line 726
    col = aij->col;
#line 728
    if (f_min == - 1.7976931348623157e+308) {
#line 729
      ff_min = - 1.7976931348623157e+308;
    } else
#line 730
    if ((unsigned long )c_min == (unsigned long )((void *)0)) {
#line 731
      if (aij->val > 0.0) {
#line 731
        tmp___1 = col->lb;
      } else {
#line 731
        tmp___1 = col->ub;
      }
#line 731
      ff_min = f_min - aij->val * tmp___1;
    } else
#line 733
    if ((unsigned long )c_min == (unsigned long )col) {
#line 734
      ff_min = f_min;
    } else {
#line 736
      ff_min = - 1.7976931348623157e+308;
    }
#line 738
    if (f_max == 1.7976931348623157e+308) {
#line 739
      ff_max = 1.7976931348623157e+308;
    } else
#line 740
    if ((unsigned long )c_max == (unsigned long )((void *)0)) {
#line 741
      if (aij->val > 0.0) {
#line 741
        tmp___2 = col->ub;
      } else {
#line 741
        tmp___2 = col->lb;
      }
#line 741
      ff_max = f_max - aij->val * tmp___2;
    } else
#line 743
    if ((unsigned long )c_max == (unsigned long )col) {
#line 744
      ff_max = f_max;
    } else {
#line 746
      ff_max = 1.7976931348623157e+308;
    }
    {
#line 753
    tmp___3 = fabs(aij->val);
    }
#line 753
    if (tmp___3 < 1e-6) {
#line 754
      lb = - 1.7976931348623157e+308;
#line 754
      ub = 1.7976931348623157e+308;
    } else
#line 756
    if (aij->val > 0.0) {
#line 757
      if (row->lb == - 1.7976931348623157e+308) {
#line 758
        lb = - 1.7976931348623157e+308;
      } else
#line 757
      if (ff_max == 1.7976931348623157e+308) {
#line 758
        lb = - 1.7976931348623157e+308;
      } else {
#line 760
        lb = (row->lb - ff_max) / aij->val;
      }
#line 761
      if (row->ub == 1.7976931348623157e+308) {
#line 762
        ub = 1.7976931348623157e+308;
      } else
#line 761
      if (ff_min == - 1.7976931348623157e+308) {
#line 762
        ub = 1.7976931348623157e+308;
      } else {
#line 764
        ub = (row->ub - ff_min) / aij->val;
      }
    } else {
#line 767
      if (row->ub == 1.7976931348623157e+308) {
#line 768
        lb = - 1.7976931348623157e+308;
      } else
#line 767
      if (ff_min == - 1.7976931348623157e+308) {
#line 768
        lb = - 1.7976931348623157e+308;
      } else {
#line 770
        lb = (row->ub - ff_min) / aij->val;
      }
#line 771
      if (row->lb == - 1.7976931348623157e+308) {
#line 772
        ub = 1.7976931348623157e+308;
      } else
#line 771
      if (ff_max == 1.7976931348623157e+308) {
#line 772
        ub = 1.7976931348623157e+308;
      } else {
#line 774
        ub = (row->lb - ff_max) / aij->val;
      }
    }
#line 779
    flag = 0;
#line 781
    if (lb != - 1.7976931348623157e+308) {
#line 782
      if (col->i_flag) {
#line 783
        delta = 0.001;
      } else {
        {
#line 785
        tmp___4 = fabs(lb);
#line 785
        delta = 0.10 * (1.0 + tmp___4);
        }
      }
#line 786
      if (lb - delta >= col->lb) {
#line 786
        flag = 1;
      }
    }
#line 789
    if (ub != 1.7976931348623157e+308) {
#line 790
      if (col->i_flag) {
#line 791
        delta = 0.001;
      } else {
        {
#line 793
        tmp___5 = fabs(ub);
#line 793
        delta = 0.10 * (1.0 + tmp___5);
        }
      }
#line 794
      if (ub + delta <= col->ub) {
#line 794
        flag = 1;
      }
    }
#line 800
    if (flag) {
#line 800
      if (lb < 1e15) {
#line 800
        if (ub > - 1e15) {
          {
#line 802
          tmp___6 = _glp_ipp_tight_bnds(ipp, col, lb, ub);
          }
          {
#line 803
          if (tmp___6 == 0) {
#line 803
            goto case_0;
          }
#line 811
          if (tmp___6 == 1) {
#line 811
            goto case_1;
          }
#line 816
          if (tmp___6 == 2) {
#line 816
            goto case_2;
          }
#line 819
          goto switch_default;
          case_0: /* CIL Label */ 
#line 809
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 814
          _glp_ipp_enque_col(ipp, col);
          }
#line 815
          goto switch_break;
          case_2: /* CIL Label */ 
#line 818
          return (1);
          switch_default: /* CIL Label */ 
#line 820
          if ((unsigned long )ipp != (unsigned long )ipp) {
#line 820
            tmp___7 = 1;
          } else {
            {
#line 820
            _glp_lib_xassert("ipp != ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                             820);
#line 820
            tmp___7 = 1;
            }
          }
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
#line 725
    aij = aij->r_next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 824
  return (0);
}
}
#line 849 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
int _glp_ipp_reduce_bnds(IPP *ipp ) 
{ 
  IPPROW *row ;
  IPPCOL *col ;
  IPPAIJ *aij ;
  int pass ;
  int total ;
  int count ;
  int tmp ;
  char *__cil_tmp9 ;

  {
#line 853
  pass = 0;
#line 853
  total = 0;
#line 855
  row = ipp->row_ptr;
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 855
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 855
      goto while_break;
    }
    {
#line 856
    _glp_ipp_enque_row(ipp, row);
#line 855
    row = row->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 858
  col = ipp->col_ptr;
  {
#line 858
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 858
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 858
      goto while_break___0;
    }
    {
#line 859
    _glp_ipp_deque_col(ipp, col);
#line 858
    col = col->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  loop: 
#line 861
  pass ++;
  {
#line 862
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 862
    if (! ((unsigned long )ipp->row_que != (unsigned long )((void *)0))) {
#line 862
      goto while_break___1;
    }
    {
#line 864
    row = ipp->row_que;
#line 866
    _glp_ipp_deque_row(ipp, row);
#line 868
    tmp = reduce_bounds(ipp, row);
    }
#line 868
    if (tmp) {
#line 868
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 872
  count = 0;
  {
#line 873
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 873
    if (! ((unsigned long )ipp->col_que != (unsigned long )((void *)0))) {
#line 873
      goto while_break___2;
    }
    {
#line 874
    count ++;
#line 876
    col = ipp->col_que;
#line 878
    _glp_ipp_deque_col(ipp, col);
#line 880
    aij = col->ptr;
    }
    {
#line 880
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 880
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 880
        goto while_break___3;
      }
      {
#line 881
      row = aij->row;
#line 882
      _glp_ipp_enque_row(ipp, row);
#line 880
      aij = aij->c_next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 885
  total += count;
#line 886
  if (count > 0) {
#line 886
    goto loop;
  }
  {
#line 887
  _glp_lib_xprintf("ipp_reduce_bnds: %d pass(es) made, %d bound(s) reduced\n", pass,
                   total);
  }
#line 890
  return (0);
}
}
#line 923 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_shift_col(IPP *ipp , IPPCOL *col ) 
{ 
  struct shift_col *info ;
  IPPROW *row ;
  IPPAIJ *aij ;
  double temp ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 930
  if (col->lb != - 1.7976931348623157e+308) {
#line 930
    if (col->lb != 0.0) {
#line 930
      tmp = 1;
    } else {
      {
#line 930
      _glp_lib_xassert("col->lb != -DBL_MAX && col->lb != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       930);
#line 930
      tmp = 1;
      }
    }
  } else {
    {
#line 930
    _glp_lib_xassert("col->lb != -DBL_MAX && col->lb != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     930);
#line 930
    tmp = 1;
    }
  }
  {
#line 932
  tmp___0 = _glp_ipp_append_tqe(ipp, 2, (int )sizeof(*info));
#line 932
  info = (struct shift_col *)tmp___0;
#line 933
  info->q = col->j;
#line 934
  info->s = col->lb;
#line 936
  aij = col->ptr;
  }
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 936
      goto while_break;
    }
#line 937
    row = aij->row;
#line 938
    temp = aij->val * info->s;
#line 939
    if (row->lb == row->ub) {
#line 940
      row->lb -= temp;
#line 941
      row->ub = row->lb;
    } else {
#line 944
      if (row->lb != - 1.7976931348623157e+308) {
#line 944
        row->lb -= temp;
      }
#line 945
      if (row->ub != 1.7976931348623157e+308) {
#line 945
        row->ub -= temp;
      }
    }
#line 936
    aij = aij->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  ipp->c0 += col->c * info->s;
#line 951
  col->lb = 0.0;
#line 952
  if (col->ub != 1.7976931348623157e+308) {
#line 952
    col->ub -= info->s;
  }
#line 953
  return;
}
}
#line 956 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_shift_col_r(IPP *ipp , void *_info ) 
{ 
  struct shift_col *info ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 958
  info = (struct shift_col *)_info;
#line 959
  if (1 <= info->q) {
#line 959
    if (info->q <= ipp->ncols) {
#line 959
      tmp = 1;
    } else {
      {
#line 959
      _glp_lib_xassert("1 <= info->q && info->q <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       959);
#line 959
      tmp = 1;
      }
    }
  } else {
    {
#line 959
    _glp_lib_xassert("1 <= info->q && info->q <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     959);
#line 959
    tmp = 1;
    }
  }
#line 960
  if (*(ipp->col_stat + info->q) == 1) {
#line 960
    tmp___0 = 1;
  } else {
    {
#line 960
    _glp_lib_xassert("ipp->col_stat[info->q] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     960);
#line 960
    tmp___0 = 1;
    }
  }
#line 961
  *(ipp->col_mipx + info->q) += info->s;
#line 962
  return;
}
}
#line 1001 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
int _glp_ipp_nonbin_col(IPP *ipp , IPPCOL *col ) 
{ 
  struct nonbin_col *info ;
  IPPROW *row ;
  IPPCOL *bin ;
  IPPAIJ *aij ;
  IPPLFE *lfe ;
  int u ;
  int t ;
  int two_t ;
  int k ;
  int two_k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 1010
  if (col->i_flag) {
#line 1010
    tmp = 1;
  } else {
    {
#line 1010
    _glp_lib_xassert("col->i_flag", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1010);
#line 1010
    tmp = 1;
    }
  }
#line 1012
  if (col->lb == 0.0) {
#line 1012
    tmp___0 = 1;
  } else {
    {
#line 1012
    _glp_lib_xassert("col->lb == 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1012);
#line 1012
    tmp___0 = 1;
    }
  }
#line 1014
  if (col->ub >= 2.0) {
#line 1014
    tmp___1 = 1;
  } else {
    {
#line 1014
    _glp_lib_xassert("col->ub >= 2.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1014);
#line 1014
    tmp___1 = 1;
    }
  }
#line 1017
  if (col->ub <= 32767.0) {
#line 1017
    tmp___2 = 1;
  } else {
    {
#line 1017
    _glp_lib_xassert("col->ub <= 32767.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1017);
#line 1017
    tmp___2 = 1;
    }
  }
  {
#line 1019
  tmp___3 = _glp_ipp_append_tqe(ipp, 3, (int )sizeof(*info));
#line 1019
  info = (struct nonbin_col *)tmp___3;
#line 1020
  info->q = col->j;
#line 1021
  info->ptr = (IPPLFE *)((void *)0);
#line 1024
  u = (int )col->ub;
  }
#line 1025
  if (col->ub == (double )u) {
#line 1025
    tmp___4 = 1;
  } else {
    {
#line 1025
    _glp_lib_xassert("col->ub == (double)u", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1025);
#line 1025
    tmp___4 = 1;
    }
  }
#line 1026
  t = 2;
#line 1026
  two_t = 4;
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1026
    if (! (t <= 15)) {
#line 1026
      goto while_break;
    }
#line 1027
    if (u <= two_t - 1) {
#line 1027
      goto while_break;
    }
#line 1026
    t ++;
#line 1026
    two_t += two_t;
  }
  while_break: /* CIL Label */ ;
  }
#line 1028
  if (t <= 15) {
#line 1028
    tmp___5 = 1;
  } else {
    {
#line 1028
    _glp_lib_xassert("t <= 15", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1028);
#line 1028
    tmp___5 = 1;
    }
  }
#line 1030
  if (u <= two_t - 2) {
    {
#line 1031
    row = _glp_ipp_add_row(ipp, - 1.7976931348623157e+308, (double )u);
    }
  }
#line 1033
  k = 0;
#line 1033
  two_k = 1;
  {
#line 1033
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1033
    if (! (k < t)) {
#line 1033
      goto while_break___0;
    }
    {
#line 1034
    bin = _glp_ipp_add_col(ipp, 1, 0.0, 1.0, 0.0);
#line 1035
    tmp___6 = _glp_dmp_get_atom(ipp->tqe_pool, (int )sizeof(IPPLFE ));
#line 1035
    lfe = (IPPLFE *)tmp___6;
#line 1036
    lfe->ref = bin->j;
#line 1037
    lfe->val = (double )two_k;
#line 1038
    lfe->next = info->ptr;
#line 1039
    info->ptr = lfe;
#line 1041
    aij = col->ptr;
    }
    {
#line 1041
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1041
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1041
        goto while_break___1;
      }
      {
#line 1042
      _glp_ipp_add_aij(ipp, aij->row, bin, aij->val * lfe->val);
#line 1041
      aij = aij->c_next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1044
    bin->c = col->c * lfe->val;
#line 1046
    if (u <= two_t - 2) {
      {
#line 1047
      _glp_ipp_add_aij(ipp, row, bin, lfe->val);
      }
    }
#line 1033
    k ++;
#line 1033
    two_k += two_k;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1050
  _glp_ipp_remove_col(ipp, col);
  }
#line 1051
  return (t);
}
}
#line 1054 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_nonbin_col_r(IPP *ipp , void *_info ) 
{ 
  struct nonbin_col *info ;
  IPPLFE *lfe ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1056
  info = (struct nonbin_col *)_info;
#line 1059
  if (1 <= info->q) {
#line 1059
    if (info->q <= ipp->ncols) {
#line 1059
      tmp = 1;
    } else {
      {
#line 1059
      _glp_lib_xassert("1 <= info->q && info->q <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       1059);
#line 1059
      tmp = 1;
      }
    }
  } else {
    {
#line 1059
    _glp_lib_xassert("1 <= info->q && info->q <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1059);
#line 1059
    tmp = 1;
    }
  }
#line 1060
  if (*(ipp->col_stat + info->q) == 0) {
#line 1060
    tmp___0 = 1;
  } else {
    {
#line 1060
    _glp_lib_xassert("ipp->col_stat[info->q] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1060);
#line 1060
    tmp___0 = 1;
    }
  }
#line 1061
  temp = 0.0;
#line 1062
  lfe = info->ptr;
  {
#line 1062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1062
    if (! ((unsigned long )lfe != (unsigned long )((void *)0))) {
#line 1062
      goto while_break;
    }
#line 1063
    if (1 <= lfe->ref) {
#line 1063
      if (lfe->ref <= ipp->ncols) {
#line 1063
        tmp___1 = 1;
      } else {
        {
#line 1063
        _glp_lib_xassert("1 <= lfe->ref && lfe->ref <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                         1063);
#line 1063
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 1063
      _glp_lib_xassert("1 <= lfe->ref && lfe->ref <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       1063);
#line 1063
      tmp___1 = 1;
      }
    }
#line 1064
    if (*(ipp->col_stat + lfe->ref) == 1) {
#line 1064
      tmp___2 = 1;
    } else {
      {
#line 1064
      _glp_lib_xassert("ipp->col_stat[lfe->ref] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       1064);
#line 1064
      tmp___2 = 1;
      }
    }
#line 1065
    temp += lfe->val * *(ipp->col_mipx + lfe->ref);
#line 1062
    lfe = lfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1067
  *(ipp->col_stat + info->q) = 1;
#line 1068
  *(ipp->col_mipx + info->q) = temp;
#line 1069
  return;
}
}
#line 1099 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
static void reduce_coef(IPP *ipp , IPPROW *row ) 
{ 
  IPPCOL *col ;
  IPPCOL *c_max ;
  IPPAIJ *aij ;
  double f_max ;
  double ff_max ;
  double eps ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1104
  if (row->lb == - 1.7976931348623157e+308) {
#line 1104
    if (row->ub != 1.7976931348623157e+308) {
#line 1104
      tmp = 1;
    } else {
      {
#line 1104
      _glp_lib_xassert("row->lb == -DBL_MAX && row->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       1104);
#line 1104
      tmp = 1;
      }
    }
  } else {
    {
#line 1104
    _glp_lib_xassert("row->lb == -DBL_MAX && row->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                     1104);
#line 1104
    tmp = 1;
    }
  }
#line 1106
  c_max = (IPPCOL *)((void *)0);
#line 1106
  f_max = 0.0;
#line 1107
  aij = row->ptr;
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1107
      goto while_break;
    }
#line 1108
    col = aij->col;
#line 1109
    if (aij->val > 0.0) {
#line 1109
      if (col->ub == 1.7976931348623157e+308) {
#line 1109
        goto _L;
      } else {
#line 1109
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1109
    if (aij->val < 0.0) {
#line 1109
      if (col->lb == - 1.7976931348623157e+308) {
        _L: /* CIL Label */ 
#line 1111
        if ((unsigned long )c_max == (unsigned long )((void *)0)) {
#line 1112
          c_max = col;
        } else {
#line 1114
          f_max = 1.7976931348623157e+308;
#line 1115
          goto while_break;
        }
      } else {
#line 1109
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1119
      if (aij->val > 0.0) {
#line 1119
        tmp___0 = col->ub;
      } else {
#line 1119
        tmp___0 = col->lb;
      }
#line 1119
      f_max += aij->val * tmp___0;
    }
#line 1107
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  aij = row->ptr;
  {
#line 1122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1122
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1122
      goto while_break___0;
    }
#line 1123
    col = aij->col;
#line 1125
    if (! col->i_flag) {
#line 1125
      goto __Cont;
    }
#line 1126
    if (col->lb == 0.0) {
#line 1126
      if (! (col->ub == 1.0)) {
#line 1126
        goto __Cont;
      }
    } else {
#line 1126
      goto __Cont;
    }
#line 1128
    if (f_max == 1.7976931348623157e+308) {
#line 1129
      ff_max = 1.7976931348623157e+308;
    } else
#line 1130
    if ((unsigned long )c_max == (unsigned long )((void *)0)) {
#line 1131
      if (aij->val > 0.0) {
#line 1131
        tmp___1 = col->ub;
      } else {
#line 1131
        tmp___1 = col->lb;
      }
#line 1131
      ff_max = f_max - aij->val * tmp___1;
    } else
#line 1133
    if ((unsigned long )c_max == (unsigned long )col) {
#line 1134
      ff_max = f_max;
    } else {
#line 1136
      ff_max = 1.7976931348623157e+308;
    }
#line 1138
    if (ff_max == 1.7976931348623157e+308) {
#line 1138
      goto __Cont;
    }
    {
#line 1139
    tmp___2 = fabs(ff_max);
#line 1139
    eps = 1e-5 * (1.0 + tmp___2);
    }
#line 1140
    if (aij->val > 0.0) {
#line 1142
      if ((row->ub - aij->val) + eps <= ff_max) {
#line 1142
        if (ff_max <= row->ub - eps) {
          {
#line 1144
          aij->val += ff_max - row->ub;
#line 1145
          row->ub = ff_max;
#line 1146
          _glp_ipp_enque_col(ipp, col);
          }
        }
      }
    } else
#line 1151
    if (row->ub + eps <= ff_max) {
#line 1151
      if (ff_max <= (row->ub - aij->val) - eps) {
        {
#line 1153
        aij->val = row->ub - ff_max;
#line 1154
        row->ub = row->ub;
#line 1155
        _glp_ipp_enque_col(ipp, col);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1122
    aij = aij->r_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1159
  return;
}
}
#line 1175 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_reduce_coef(IPP *ipp ) 
{ 
  IPPROW *row ;
  IPPCOL *col ;
  IPPAIJ *aij ;
  int pass ;
  int total ;
  int count ;
  char *__cil_tmp8 ;

  {
#line 1179
  pass = 0;
#line 1179
  total = 0;
#line 1181
  row = ipp->row_ptr;
  {
#line 1181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1181
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 1181
      goto while_break;
    }
#line 1182
    if (row->lb == - 1.7976931348623157e+308) {
#line 1182
      if (row->ub != 1.7976931348623157e+308) {
        {
#line 1183
        _glp_ipp_enque_row(ipp, row);
        }
      }
    }
#line 1181
    row = row->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1186
  col = ipp->col_ptr;
  {
#line 1186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1186
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 1186
      goto while_break___0;
    }
    {
#line 1187
    _glp_ipp_deque_col(ipp, col);
#line 1186
    col = col->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  loop: 
#line 1189
  pass ++;
  {
#line 1190
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1190
    if (! ((unsigned long )ipp->row_que != (unsigned long )((void *)0))) {
#line 1190
      goto while_break___1;
    }
    {
#line 1192
    row = ipp->row_que;
#line 1194
    _glp_ipp_deque_row(ipp, row);
#line 1196
    reduce_coef(ipp, row);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1200
  count = 0;
  {
#line 1201
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1201
    if (! ((unsigned long )ipp->col_que != (unsigned long )((void *)0))) {
#line 1201
      goto while_break___2;
    }
    {
#line 1202
    count ++;
#line 1204
    col = ipp->col_que;
#line 1206
    _glp_ipp_deque_col(ipp, col);
#line 1208
    aij = col->ptr;
    }
    {
#line 1208
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1208
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1208
        goto while_break___3;
      }
#line 1209
      row = aij->row;
#line 1210
      if (row->lb == - 1.7976931348623157e+308) {
#line 1210
        if (row->ub != 1.7976931348623157e+308) {
          {
#line 1211
          _glp_ipp_enque_row(ipp, row);
          }
        }
      }
#line 1208
      aij = aij->c_next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1214
  total += count;
#line 1215
  if (count > 0) {
#line 1215
    goto loop;
  }
  {
#line 1216
  _glp_lib_xprintf("ipp_reduce_coef: %d pass(es) made, %d coefficient(s) reduced\n",
                   pass, total);
  }
#line 1218
  return;
}
}
#line 1237 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_binarize(IPP *ipp ) 
{ 
  IPPCOL *col ;
  int ncols ;
  int nbins ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1241
  col = ipp->col_ptr;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 1241
      goto while_break;
    }
    {
#line 1242
    _glp_ipp_deque_col(ipp, col);
    }
#line 1243
    if (! col->i_flag) {
#line 1243
      goto __Cont;
    }
#line 1244
    if (col->lb == col->ub) {
#line 1244
      goto __Cont;
    }
#line 1245
    if (col->lb == 0.0) {
#line 1245
      if (col->ub == 1.0) {
#line 1245
        goto __Cont;
      }
    }
#line 1246
    if (col->lb != - 1.7976931348623157e+308) {
#line 1246
      tmp = 1;
    } else {
      {
#line 1246
      _glp_lib_xassert("col->lb != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       1246);
#line 1246
      tmp = 1;
      }
    }
#line 1247
    if (col->ub != 1.7976931348623157e+308) {
#line 1247
      tmp___0 = 1;
    } else {
      {
#line 1247
      _glp_lib_xassert("col->ub != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       1247);
#line 1247
      tmp___0 = 1;
      }
    }
#line 1248
    if (col->lb == - 1.7976931348623157e+308) {
      {
#line 1250
      _glp_lib_xprintf("WARNING: BINARIZATION IMPOSSIBLE\n");
      }
#line 1251
      goto done;
    } else
#line 1248
    if (col->ub == 1.7976931348623157e+308) {
      {
#line 1250
      _glp_lib_xprintf("WARNING: BINARIZATION IMPOSSIBLE\n");
      }
#line 1251
      goto done;
    } else
#line 1248
    if (col->ub - col->lb > 32767.0) {
      {
#line 1250
      _glp_lib_xprintf("WARNING: BINARIZATION IMPOSSIBLE\n");
      }
#line 1251
      goto done;
    }
    {
#line 1253
    _glp_ipp_enque_col(ipp, col);
    }
    __Cont: /* CIL Label */ 
#line 1241
    col = col->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  nbins = 0;
#line 1256
  ncols = nbins;
  {
#line 1257
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1257
    if (! ((unsigned long )ipp->col_que != (unsigned long )((void *)0))) {
#line 1257
      goto while_break___0;
    }
    {
#line 1259
    ncols ++;
#line 1260
    col = ipp->col_que;
#line 1262
    _glp_ipp_deque_col(ipp, col);
    }
#line 1264
    if (col->lb != 0.0) {
      {
#line 1264
      _glp_ipp_shift_col(ipp, col);
      }
    }
#line 1266
    if (col->ub == 1.0) {
#line 1266
      goto while_continue___0;
    }
    {
#line 1268
    tmp___1 = _glp_ipp_nonbin_col(ipp, col);
#line 1268
    nbins += tmp___1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1270
  if (ncols == 0) {
    {
#line 1271
    _glp_lib_xprintf("ipp_binarize: no general integer variables detected\n");
    }
  } else {
    {
#line 1274
    _glp_lib_xprintf("ipp_binarize: %d integer variable(s) replaced by %d binary ones\n",
                     ncols, nbins);
    }
  }
  done: 
#line 1276
  return;
}
}
#line 1295 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_reduction(IPP *ipp ) 
{ 
  IPPROW *row ;
  IPPROW *dup ;
  IPPCOL *col ;
  IPPAIJ *aij ;
  int nrows ;
  char *__cil_tmp7 ;

  {
#line 1302
  row = ipp->row_ptr;
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 1302
      goto while_break;
    }
    {
#line 1303
    _glp_ipp_deque_row(ipp, row);
    }
#line 1304
    if (row->lb == - 1.7976931348623157e+308) {
#line 1304
      goto __Cont;
    }
#line 1305
    if (row->ub == 1.7976931348623157e+308) {
#line 1305
      goto __Cont;
    }
#line 1306
    if (row->lb == row->ub) {
#line 1306
      goto __Cont;
    }
#line 1308
    aij = row->ptr;
    {
#line 1308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1308
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1308
        goto while_break___0;
      }
#line 1309
      col = aij->col;
#line 1310
      if (col->i_flag) {
#line 1310
        if (col->lb == 0.0) {
#line 1310
          if (! (col->ub == 1.0)) {
#line 1311
            goto while_break___0;
          }
        } else {
#line 1311
          goto while_break___0;
        }
      } else {
#line 1311
        goto while_break___0;
      }
#line 1308
      aij = aij->r_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1313
    if ((unsigned long )aij != (unsigned long )((void *)0)) {
#line 1313
      goto __Cont;
    }
    {
#line 1314
    _glp_ipp_enque_row(ipp, row);
    }
    __Cont: /* CIL Label */ 
#line 1302
    row = row->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1317
  nrows = 0;
  {
#line 1318
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1318
    if (! ((unsigned long )ipp->row_que != (unsigned long )((void *)0))) {
#line 1318
      goto while_break___1;
    }
    {
#line 1320
    nrows ++;
#line 1321
    row = ipp->row_que;
#line 1323
    _glp_ipp_deque_row(ipp, row);
#line 1325
    dup = _glp_ipp_add_row(ipp, - 1.7976931348623157e+308, row->ub);
#line 1326
    row->ub = 1.7976931348623157e+308;
#line 1327
    aij = row->ptr;
    }
    {
#line 1327
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1327
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1327
        goto while_break___2;
      }
      {
#line 1328
      _glp_ipp_add_aij(ipp, dup, aij->col, aij->val);
#line 1327
      aij = aij->r_next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1330
  if (nrows > 0) {
    {
#line 1331
    _glp_lib_xprintf("ipp_reduction: %d row(s) splitted into single inequalities\n",
                     nrows);
    }
  }
#line 1334
  row = ipp->row_ptr;
  {
#line 1334
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1334
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 1334
      goto while_break___3;
    }
#line 1335
    if (row->lb != - 1.7976931348623157e+308) {
#line 1335
      if (row->ub == 1.7976931348623157e+308) {
#line 1336
        row->ub = - row->lb;
#line 1337
        row->lb = - 1.7976931348623157e+308;
#line 1338
        aij = row->ptr;
        {
#line 1338
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1338
          if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1338
            goto while_break___4;
          }
#line 1339
          aij->val = - aij->val;
#line 1338
          aij = aij->r_next;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 1334
    row = row->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1343
  _glp_ipp_reduce_coef(ipp);
  }
#line 1344
  return;
}
}
#line 1361 "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c"
void _glp_ipp_postsolve(IPP *ipp ) 
{ 
  IPPTQE *tqe ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1363
  tqe = ipp->tqe_list;
  {
#line 1363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1363
    if (! ((unsigned long )tqe != (unsigned long )((void *)0))) {
#line 1363
      goto while_break;
    }
    {
#line 1365
    if (tqe->type == 1) {
#line 1365
      goto case_1;
    }
#line 1368
    if (tqe->type == 2) {
#line 1368
      goto case_2;
    }
#line 1371
    if (tqe->type == 3) {
#line 1371
      goto case_3;
    }
#line 1374
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1366
    _glp_ipp_fixed_col_r(ipp, tqe->info);
    }
#line 1367
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1369
    _glp_ipp_shift_col_r(ipp, tqe->info);
    }
#line 1370
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1372
    _glp_ipp_nonbin_col_r(ipp, tqe->info);
    }
#line 1373
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1375
    if ((unsigned long )tqe != (unsigned long )tqe) {
#line 1375
      tmp = 1;
    } else {
      {
#line 1375
      _glp_lib_xassert("tqe != tqe", "/home/wslee/benchmarks/glpk-4.38/src/glpipp02.c",
                       1375);
#line 1375
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 1363
    tqe = tqe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1378
  return;
}
}
#line 272 "/home/wslee/benchmarks/glpk-4.38/src/glpipp.h"
void _glp_ipp_load_sol(IPP *ipp , glp_prob *prob ) ;
#line 275
void _glp_ipp_unload_sol(IPP *ipp , glp_prob *orig , int i_stat ) ;
#line 45 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
IPP *_glp_ipp_create_wksp(void) 
{ 
  IPP *ipp ;
  void *tmp ;

  {
  {
#line 47
  tmp = _glp_lib_xmalloc((int )sizeof(IPP ));
#line 47
  ipp = (IPP *)tmp;
#line 48
  ipp->orig_m = 0;
#line 49
  ipp->orig_n = 0;
#line 50
  ipp->orig_nnz = 0;
#line 51
  ipp->orig_dir = 120;
#line 52
  ipp->ncols = 0;
#line 53
  ipp->row_pool = _glp_dmp_create_pool();
#line 54
  ipp->col_pool = _glp_dmp_create_pool();
#line 55
  ipp->aij_pool = _glp_dmp_create_pool();
#line 56
  ipp->row_ptr = (IPPROW *)((void *)0);
#line 57
  ipp->col_ptr = (IPPCOL *)((void *)0);
#line 58
  ipp->row_que = (IPPROW *)((void *)0);
#line 59
  ipp->col_que = (IPPCOL *)((void *)0);
#line 60
  ipp->c0 = 0.0;
#line 61
  ipp->tqe_pool = _glp_dmp_create_pool();
#line 62
  ipp->tqe_list = (IPPTQE *)((void *)0);
#line 63
  ipp->col_stat = (int *)((void *)0);
#line 64
  ipp->col_mipx = (double *)((void *)0);
  }
#line 65
  return (ipp);
}
}
#line 91 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
IPPROW *_glp_ipp_add_row(IPP *ipp , double lb , double ub ) 
{ 
  IPPROW *row ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 94
  if (lb <= ub) {
#line 94
    tmp = 1;
  } else {
    {
#line 94
    _glp_lib_xassert("lb <= ub", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     94);
#line 94
    tmp = 1;
    }
  }
  {
#line 96
  tmp___0 = _glp_dmp_get_atom(ipp->row_pool, (int )sizeof(IPPROW ));
#line 96
  row = (IPPROW *)tmp___0;
#line 97
  row->lb = lb;
#line 98
  row->ub = ub;
#line 99
  row->ptr = (IPPAIJ *)((void *)0);
#line 100
  row->temp = 0;
#line 101
  row->prev = (IPPROW *)((void *)0);
#line 102
  row->next = ipp->row_ptr;
#line 103
  row->q_flag = 0;
#line 104
  row->q_prev = (IPPROW *)((void *)0);
#line 105
  row->q_next = (IPPROW *)((void *)0);
  }
#line 107
  if ((unsigned long )row->next != (unsigned long )((void *)0)) {
#line 107
    (row->next)->prev = row;
  }
#line 108
  ipp->row_ptr = row;
#line 109
  return (row);
}
}
#line 141 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
IPPCOL *_glp_ipp_add_col(IPP *ipp , int i_flag , double lb , double ub , double c ) 
{ 
  IPPCOL *col ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 145
  if (lb <= ub) {
#line 145
    tmp = 1;
  } else {
    {
#line 145
    _glp_lib_xassert("lb <= ub", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     145);
#line 145
    tmp = 1;
    }
  }
#line 146
  if (i_flag) {
#line 147
    if (lb != - 1.7976931348623157e+308) {
      {
#line 147
      tmp___0 = floor(lb);
      }
#line 147
      if (lb == tmp___0) {
#line 147
        tmp___1 = 1;
      } else {
        {
#line 147
        _glp_lib_xassert("lb == floor(lb)", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                         147);
#line 147
        tmp___1 = 1;
        }
      }
    }
#line 148
    if (ub != 1.7976931348623157e+308) {
      {
#line 148
      tmp___2 = floor(ub);
      }
#line 148
      if (ub == tmp___2) {
#line 148
        tmp___3 = 1;
      } else {
        {
#line 148
        _glp_lib_xassert("ub == floor(ub)", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                         148);
#line 148
        tmp___3 = 1;
        }
      }
    }
  }
  {
#line 151
  tmp___4 = _glp_dmp_get_atom(ipp->col_pool, (int )sizeof(IPPCOL ));
#line 151
  col = (IPPCOL *)tmp___4;
#line 152
  (ipp->ncols) ++;
#line 152
  col->j = ipp->ncols;
#line 153
  col->i_flag = i_flag;
#line 154
  col->lb = lb;
#line 155
  col->ub = ub;
#line 156
  col->c = c;
#line 157
  col->ptr = (IPPAIJ *)((void *)0);
#line 158
  col->temp = 0;
#line 159
  col->prev = (IPPCOL *)((void *)0);
#line 160
  col->next = ipp->col_ptr;
#line 161
  col->q_flag = 0;
#line 162
  col->q_prev = (IPPCOL *)((void *)0);
#line 163
  col->q_next = (IPPCOL *)((void *)0);
  }
#line 165
  if ((unsigned long )col->next != (unsigned long )((void *)0)) {
#line 165
    (col->next)->prev = col;
  }
#line 166
  ipp->col_ptr = col;
#line 167
  return (col);
}
}
#line 195 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
IPPAIJ *_glp_ipp_add_aij(IPP *ipp , IPPROW *row , IPPCOL *col , double val ) 
{ 
  IPPAIJ *aij ;
  int tmp ;
  void *tmp___0 ;
  IPPAIJ *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 197
  if (val != 0.0) {
#line 197
    tmp = 1;
  } else {
    {
#line 197
    _glp_lib_xassert("val != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     197);
#line 197
    tmp = 1;
    }
  }
  {
#line 198
  tmp___0 = _glp_dmp_get_atom(ipp->aij_pool, (int )sizeof(IPPAIJ ));
#line 198
  aij = (IPPAIJ *)tmp___0;
#line 199
  aij->row = row;
#line 200
  aij->col = col;
#line 201
  aij->val = val;
#line 202
  aij->r_prev = (IPPAIJ *)((void *)0);
#line 203
  aij->r_next = row->ptr;
#line 204
  aij->c_prev = (IPPAIJ *)((void *)0);
#line 205
  aij->c_next = col->ptr;
  }
#line 206
  if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 206
    (row->ptr)->r_prev = aij;
  }
#line 207
  if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 207
    (col->ptr)->c_prev = aij;
  }
#line 208
  tmp___1 = aij;
#line 208
  col->ptr = tmp___1;
#line 208
  row->ptr = tmp___1;
#line 209
  return (aij);
}
}
#line 225 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_remove_row(IPP *ipp , IPPROW *row ) 
{ 
  IPPAIJ *aij ;

  {
  {
#line 228
  _glp_ipp_deque_row(ipp, row);
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! ((unsigned long )row->ptr != (unsigned long )((void *)0))) {
#line 230
      goto while_break;
    }
#line 232
    aij = row->ptr;
#line 234
    row->ptr = aij->r_next;
#line 236
    if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 237
      (aij->col)->ptr = aij->c_next;
    } else {
#line 239
      (aij->c_prev)->c_next = aij->c_next;
    }
#line 240
    if (! ((unsigned long )aij->c_next == (unsigned long )((void *)0))) {
#line 243
      (aij->c_next)->c_prev = aij->c_prev;
    }
    {
#line 245
    _glp_dmp_free_atom(ipp->aij_pool, (void *)aij, (int )sizeof(IPPAIJ ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if ((unsigned long )row->prev == (unsigned long )((void *)0)) {
#line 249
    ipp->row_ptr = row->next;
  } else {
#line 251
    (row->prev)->next = row->next;
  }
#line 252
  if (! ((unsigned long )row->next == (unsigned long )((void *)0))) {
#line 255
    (row->next)->prev = row->prev;
  }
  {
#line 257
  _glp_dmp_free_atom(ipp->row_pool, (void *)row, (int )sizeof(IPPROW ));
  }
#line 258
  return;
}
}
#line 274 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_remove_col(IPP *ipp , IPPCOL *col ) 
{ 
  IPPAIJ *aij ;

  {
  {
#line 277
  _glp_ipp_deque_col(ipp, col);
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! ((unsigned long )col->ptr != (unsigned long )((void *)0))) {
#line 279
      goto while_break;
    }
#line 281
    aij = col->ptr;
#line 283
    col->ptr = aij->c_next;
#line 285
    if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 286
      (aij->row)->ptr = aij->r_next;
    } else {
#line 288
      (aij->r_prev)->r_next = aij->r_next;
    }
#line 289
    if (! ((unsigned long )aij->r_next == (unsigned long )((void *)0))) {
#line 292
      (aij->r_next)->r_prev = aij->r_prev;
    }
    {
#line 294
    _glp_dmp_free_atom(ipp->aij_pool, (void *)aij, (int )sizeof(IPPAIJ ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if ((unsigned long )col->prev == (unsigned long )((void *)0)) {
#line 298
    ipp->col_ptr = col->next;
  } else {
#line 300
    (col->prev)->next = col->next;
  }
#line 301
  if (! ((unsigned long )col->next == (unsigned long )((void *)0))) {
#line 304
    (col->next)->prev = col->prev;
  }
  {
#line 306
  _glp_dmp_free_atom(ipp->col_pool, (void *)col, (int )sizeof(IPPCOL ));
  }
#line 307
  return;
}
}
#line 323 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_enque_row(IPP *ipp , IPPROW *row ) 
{ 


  {
#line 324
  if (! row->q_flag) {
#line 325
    row->q_flag = 1;
#line 326
    row->q_prev = (IPPROW *)((void *)0);
#line 327
    row->q_next = ipp->row_que;
#line 328
    if ((unsigned long )ipp->row_que != (unsigned long )((void *)0)) {
#line 328
      (ipp->row_que)->q_prev = row;
    }
#line 329
    ipp->row_que = row;
  }
#line 331
  return;
}
}
#line 347 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_deque_row(IPP *ipp , IPPROW *row ) 
{ 


  {
#line 348
  if (row->q_flag) {
#line 349
    row->q_flag = 0;
#line 350
    if ((unsigned long )row->q_prev == (unsigned long )((void *)0)) {
#line 351
      ipp->row_que = row->q_next;
    } else {
#line 353
      (row->q_prev)->q_next = row->q_next;
    }
#line 354
    if (! ((unsigned long )row->q_next == (unsigned long )((void *)0))) {
#line 357
      (row->q_next)->q_prev = row->q_prev;
    }
  }
#line 359
  return;
}
}
#line 375 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_enque_col(IPP *ipp , IPPCOL *col ) 
{ 


  {
#line 376
  if (! col->q_flag) {
#line 377
    col->q_flag = 1;
#line 378
    col->q_prev = (IPPCOL *)((void *)0);
#line 379
    col->q_next = ipp->col_que;
#line 380
    if ((unsigned long )ipp->col_que != (unsigned long )((void *)0)) {
#line 380
      (ipp->col_que)->q_prev = col;
    }
#line 381
    ipp->col_que = col;
  }
#line 383
  return;
}
}
#line 399 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_deque_col(IPP *ipp , IPPCOL *col ) 
{ 


  {
#line 400
  if (col->q_flag) {
#line 401
    col->q_flag = 0;
#line 402
    if ((unsigned long )col->q_prev == (unsigned long )((void *)0)) {
#line 403
      ipp->col_que = col->q_next;
    } else {
#line 405
      (col->q_prev)->q_next = col->q_next;
    }
#line 406
    if (! ((unsigned long )col->q_next == (unsigned long )((void *)0))) {
#line 409
      (col->q_next)->q_prev = col->q_prev;
    }
  }
#line 411
  return;
}
}
#line 436 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void *_glp_ipp_append_tqe(IPP *ipp , int type , int size ) 
{ 
  IPPTQE *tqe ;
  void *tmp ;

  {
  {
#line 438
  tmp = _glp_dmp_get_atom(ipp->tqe_pool, (int )sizeof(IPPTQE ));
#line 438
  tqe = (IPPTQE *)tmp;
#line 439
  tqe->type = type;
#line 440
  tqe->info = _glp_dmp_get_atom(ipp->tqe_pool, size);
#line 441
  tqe->next = ipp->tqe_list;
#line 442
  ipp->tqe_list = tqe;
  }
#line 443
  return (tqe->info);
}
}
#line 462 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_load_orig(IPP *ipp , glp_prob *orig ) 
{ 
  IPPROW **row ;
  IPPCOL *col ;
  int i ;
  int j ;
  int k ;
  int type ;
  int len ;
  int *ind ;
  double lb ;
  double ub ;
  double *val ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;

  {
  {
#line 468
  ipp->orig_m = _glp_lpx_get_num_rows(orig);
#line 469
  ipp->orig_n = _glp_lpx_get_num_cols(orig);
#line 470
  ipp->orig_nnz = _glp_lpx_get_num_nz(orig);
#line 471
  ipp->orig_dir = _glp_lpx_get_obj_dir(orig);
#line 473
  tmp = _glp_lib_xcalloc(1 + ipp->orig_m, (int )sizeof(IPPROW *));
#line 473
  row = (IPPROW **)tmp;
#line 474
  tmp___0 = _glp_lib_xcalloc(1 + ipp->orig_m, (int )sizeof(int ));
#line 474
  ind = (int *)tmp___0;
#line 475
  tmp___1 = _glp_lib_xcalloc(1 + ipp->orig_m, (int )sizeof(double ));
#line 475
  val = (double *)tmp___1;
#line 477
  i = 1;
  }
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    if (! (i <= ipp->orig_m)) {
#line 477
      goto while_break;
    }
    {
#line 478
    type = _glp_lpx_get_row_type(orig, i);
    }
#line 479
    if (type == 110) {
#line 480
      lb = - 1.7976931348623157e+308;
    } else
#line 479
    if (type == 112) {
#line 480
      lb = - 1.7976931348623157e+308;
    } else {
      {
#line 482
      lb = _glp_lpx_get_row_lb(orig, i);
      }
    }
#line 483
    if (type == 110) {
#line 484
      ub = 1.7976931348623157e+308;
    } else
#line 483
    if (type == 111) {
#line 484
      ub = 1.7976931348623157e+308;
    } else {
      {
#line 486
      ub = _glp_lpx_get_row_ub(orig, i);
      }
    }
    {
#line 487
    *(row + i) = _glp_ipp_add_row(ipp, lb, ub);
#line 477
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  j = 1;
  {
#line 492
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 492
    if (! (j <= ipp->orig_n)) {
#line 492
      goto while_break___0;
    }
    {
#line 493
    type = _glp_lpx_get_col_type(orig, j);
    }
#line 494
    if (type == 110) {
#line 495
      lb = - 1.7976931348623157e+308;
    } else
#line 494
    if (type == 112) {
#line 495
      lb = - 1.7976931348623157e+308;
    } else {
      {
#line 497
      lb = _glp_lpx_get_col_lb(orig, j);
      }
    }
#line 498
    if (type == 110) {
#line 499
      ub = 1.7976931348623157e+308;
    } else
#line 498
    if (type == 111) {
#line 499
      ub = 1.7976931348623157e+308;
    } else {
      {
#line 501
      ub = _glp_lpx_get_col_ub(orig, j);
      }
    }
    {
#line 502
    tmp___2 = _glp_lpx_get_obj_coef(orig, j);
#line 502
    tmp___3 = _glp_lpx_get_col_kind(orig, j);
#line 502
    col = _glp_ipp_add_col(ipp, tmp___3 == 161, lb, ub, tmp___2);
#line 504
    len = _glp_lpx_get_mat_col(orig, j, ind, val);
#line 505
    k = 1;
    }
    {
#line 505
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 505
      if (! (k <= len)) {
#line 505
        goto while_break___1;
      }
      {
#line 506
      _glp_ipp_add_aij(ipp, *(row + *(ind + k)), col, *(val + k));
#line 505
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 492
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 509
  ipp->c0 = _glp_lpx_get_obj_coef(orig, 0);
  }
#line 513
  if (ipp->orig_dir == 121) {
#line 514
    col = ipp->col_ptr;
    {
#line 514
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 514
      if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 514
        goto while_break___2;
      }
#line 515
      col->c = - col->c;
#line 514
      col = col->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 516
    ipp->c0 = - ipp->c0;
  }
  {
#line 519
  _glp_lib_xfree((void *)row);
#line 520
  _glp_lib_xfree((void *)ind);
#line 521
  _glp_lib_xfree((void *)val);
  }
#line 522
  return;
}
}
#line 552 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
int _glp_ipp_tight_bnds(IPP *ipp , IPPCOL *col , double lb , double ub ) 
{ 
  int ret ;
  double eps ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 553
  ret = 0;
#line 555
  if ((unsigned long )ipp == (unsigned long )ipp) {
#line 555
    tmp = 1;
  } else {
    {
#line 555
    _glp_lib_xassert("ipp == ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     555);
#line 555
    tmp = 1;
    }
  }
#line 557
  if (col->i_flag) {
    {
#line 558
    tmp___0 = fabs(lb);
#line 558
    eps = 1e-5 * (1.0 + tmp___0);
#line 559
    tmp___1 = floor(lb + 0.5);
#line 559
    tmp___2 = fabs(lb - tmp___1);
    }
#line 559
    if (tmp___2 <= eps) {
      {
#line 560
      lb = floor(lb + 0.5);
      }
    } else {
      {
#line 562
      lb = ceil(lb);
      }
    }
    {
#line 563
    tmp___3 = fabs(ub);
#line 563
    eps = 1e-5 * (1.0 + tmp___3);
#line 564
    tmp___4 = floor(ub + 0.5);
#line 564
    tmp___5 = fabs(ub - tmp___4);
    }
#line 564
    if (tmp___5 <= eps) {
      {
#line 565
      ub = floor(ub + 0.5);
      }
    } else {
      {
#line 567
      ub = floor(ub);
      }
    }
  }
#line 570
  if (col->lb != - 1.7976931348623157e+308) {
    {
#line 571
    tmp___6 = fabs(col->lb);
#line 571
    eps = 1e-5 * (1.0 + tmp___6);
    }
#line 572
    if (ub < col->lb - eps) {
#line 573
      ret = 2;
#line 574
      goto done;
    }
  }
#line 577
  if (col->ub != 1.7976931348623157e+308) {
    {
#line 578
    tmp___7 = fabs(col->ub);
#line 578
    eps = 1e-5 * (1.0 + tmp___7);
    }
#line 579
    if (lb > col->ub + eps) {
#line 580
      ret = 2;
#line 581
      goto done;
    }
  }
#line 585
  if (col->i_flag) {
#line 585
    if (lb > ub + 0.5) {
#line 587
      ret = 2;
#line 588
      goto done;
    }
  }
#line 592
  if (lb != - 1.7976931348623157e+308) {
    {
#line 593
    tmp___8 = fabs(lb);
#line 593
    eps = 1e-7 * (1.0 + tmp___8);
    }
#line 594
    if (col->lb < lb - eps) {
#line 595
      col->lb = lb;
#line 596
      ret = 1;
    }
  }
#line 599
  if (ub != 1.7976931348623157e+308) {
    {
#line 600
    tmp___9 = fabs(ub);
#line 600
    eps = 1e-7 * (1.0 + tmp___9);
    }
#line 601
    if (col->ub > ub + eps) {
#line 602
      col->ub = ub;
#line 603
      ret = 1;
    }
  }
#line 608
  if (ret == 1) {
#line 608
    if (col->lb != - 1.7976931348623157e+308) {
#line 608
      if (col->ub != 1.7976931348623157e+308) {
        {
#line 609
        tmp___10 = fabs(col->lb);
#line 609
        eps = 1e-7 * (1.0 + tmp___10);
        }
#line 610
        if (col->lb >= col->ub - eps) {
          {
#line 611
          tmp___11 = fabs(col->lb);
#line 611
          tmp___12 = fabs(col->ub);
          }
#line 611
          if (tmp___11 <= tmp___12) {
#line 612
            col->ub = col->lb;
          } else {
#line 614
            col->lb = col->ub;
          }
        }
      }
    }
  }
  done: 
#line 617
  if (col->lb <= col->ub) {
#line 617
    tmp___13 = 1;
  } else {
    {
#line 617
    _glp_lib_xassert("col->lb <= col->ub", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     617);
#line 617
    tmp___13 = 1;
    }
  }
#line 618
  return (ret);
}
}
#line 639 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
glp_prob *_glp_ipp_build_prob(IPP *ipp ) 
{ 
  glp_prob *prob ;
  IPPROW *row ;
  IPPCOL *col ;
  IPPAIJ *aij ;
  int i ;
  int j ;
  int type ;
  int len ;
  int *ind ;
  double *val ;
  double tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;

  {
  {
#line 647
  prob = _glp_lpx_create_prob();
#line 653
  _glp_lpx_set_obj_dir(prob, ipp->orig_dir);
  }
#line 655
  if (ipp->orig_dir == 120) {
#line 655
    tmp = ipp->c0;
  } else {
#line 655
    tmp = - ipp->c0;
  }
  {
#line 655
  _glp_lpx_set_obj_coef(prob, 0, tmp);
#line 658
  row = ipp->row_ptr;
  }
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 658
      goto while_break;
    }
    {
#line 659
    i = _glp_lpx_add_rows(prob, 1);
    }
#line 660
    if (row->lb == - 1.7976931348623157e+308) {
#line 660
      if (row->ub == 1.7976931348623157e+308) {
#line 661
        type = 110;
      } else {
#line 660
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 662
    if (row->ub == 1.7976931348623157e+308) {
#line 663
      type = 111;
    } else
#line 664
    if (row->lb == - 1.7976931348623157e+308) {
#line 665
      type = 112;
    } else
#line 666
    if (row->lb != row->ub) {
#line 667
      type = 113;
    } else {
#line 669
      type = 114;
    }
    {
#line 670
    _glp_lpx_set_row_bnds(prob, i, type, row->lb, row->ub);
#line 671
    row->temp = i;
#line 658
    row = row->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  tmp___0 = _glp_lpx_get_num_rows(prob);
#line 674
  tmp___1 = _glp_lib_xcalloc(1 + tmp___0, (int )sizeof(int ));
#line 674
  ind = (int *)tmp___1;
#line 675
  tmp___2 = _glp_lpx_get_num_rows(prob);
#line 675
  tmp___3 = _glp_lib_xcalloc(1 + tmp___2, (int )sizeof(double ));
#line 675
  val = (double *)tmp___3;
#line 676
  col = ipp->col_ptr;
  }
  {
#line 676
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 676
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 676
      goto while_break___0;
    }
    {
#line 677
    j = _glp_lpx_add_cols(prob, 1);
    }
#line 678
    if (col->i_flag) {
      {
#line 678
      _glp_lpx_set_col_kind(prob, j, 161);
      }
    }
#line 679
    if (col->lb == - 1.7976931348623157e+308) {
#line 679
      if (col->ub == 1.7976931348623157e+308) {
#line 680
        type = 110;
      } else {
#line 679
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 681
    if (col->ub == 1.7976931348623157e+308) {
#line 682
      type = 111;
    } else
#line 683
    if (col->lb == - 1.7976931348623157e+308) {
#line 684
      type = 112;
    } else
#line 685
    if (col->lb != col->ub) {
#line 686
      type = 113;
    } else {
#line 688
      type = 114;
    }
    {
#line 689
    _glp_lpx_set_col_bnds(prob, j, type, col->lb, col->ub);
    }
#line 690
    if (ipp->orig_dir == 120) {
#line 690
      tmp___4 = col->c;
    } else {
#line 690
      tmp___4 = - col->c;
    }
    {
#line 690
    _glp_lpx_set_obj_coef(prob, j, tmp___4);
#line 693
    len = 0;
#line 694
    aij = col->ptr;
    }
    {
#line 694
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 694
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 694
        goto while_break___1;
      }
#line 695
      len ++;
#line 696
      *(ind + len) = (aij->row)->temp;
#line 697
      *(val + len) = aij->val;
#line 694
      aij = aij->c_next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 699
    _glp_lpx_set_mat_col(prob, j, len, (int const   *)ind, (double const   *)val);
#line 676
    col = col->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 701
  _glp_lib_xfree((void *)ind);
#line 702
  _glp_lib_xfree((void *)val);
  }
#line 703
  return (prob);
}
}
#line 719 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_load_sol(IPP *ipp , glp_prob *prob ) 
{ 
  IPPCOL *col ;
  int j ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 722
  tmp = _glp_lpx_mip_status(prob);
  }
#line 722
  if (tmp != 170) {
#line 722
    tmp___0 = 1;
  } else {
    {
#line 722
    _glp_lib_xassert("lpx_mip_status(prob) != LPX_I_UNDEF", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     722);
#line 722
    tmp___0 = 1;
    }
  }
  {
#line 723
  tmp___1 = _glp_lib_xcalloc(1 + ipp->ncols, (int )sizeof(int ));
#line 723
  ipp->col_stat = (int *)tmp___1;
#line 724
  tmp___2 = _glp_lib_xcalloc(1 + ipp->ncols, (int )sizeof(double ));
#line 724
  ipp->col_mipx = (double *)tmp___2;
#line 725
  j = 1;
  }
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (j <= ipp->ncols)) {
#line 725
      goto while_break;
    }
#line 725
    *(ipp->col_stat + j) = 0;
#line 725
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  j = 0;
#line 729
  col = ipp->col_ptr;
  {
#line 729
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 729
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 729
      goto while_break___0;
    }
    {
#line 730
    j ++;
#line 731
    *(ipp->col_stat + col->j) = 1;
#line 732
    *(ipp->col_mipx + col->j) = _glp_lpx_mip_col_val(prob, j);
#line 729
    col = col->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 751 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_unload_sol(IPP *ipp , glp_prob *orig , int i_stat ) 
{ 
  int i ;
  int j ;
  int k ;
  int len ;
  int *ind ;
  double temp ;
  double *row_mipx ;
  double *val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 754
  tmp = _glp_lpx_get_num_rows(orig);
  }
#line 754
  if (ipp->orig_m == tmp) {
#line 754
    tmp___0 = 1;
  } else {
    {
#line 754
    _glp_lib_xassert("ipp->orig_m == lpx_get_num_rows(orig)", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     754);
#line 754
    tmp___0 = 1;
    }
  }
  {
#line 755
  tmp___1 = _glp_lpx_get_num_cols(orig);
  }
#line 755
  if (ipp->orig_n == tmp___1) {
#line 755
    tmp___2 = 1;
  } else {
    {
#line 755
    _glp_lib_xassert("ipp->orig_n == lpx_get_num_cols(orig)", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     755);
#line 755
    tmp___2 = 1;
    }
  }
  {
#line 756
  tmp___3 = _glp_lpx_get_obj_dir(orig);
  }
#line 756
  if (ipp->orig_dir == tmp___3) {
#line 756
    tmp___4 = 1;
  } else {
    {
#line 756
    _glp_lib_xassert("ipp->orig_dir == lpx_get_obj_dir(orig)", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     756);
#line 756
    tmp___4 = 1;
    }
  }
#line 758
  if (ipp->orig_n <= ipp->ncols) {
#line 758
    tmp___5 = 1;
  } else {
    {
#line 758
    _glp_lib_xassert("ipp->orig_n <= ipp->ncols", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                     758);
#line 758
    tmp___5 = 1;
    }
  }
#line 759
  j = 1;
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    if (! (j <= ipp->ncols)) {
#line 759
      goto while_break;
    }
#line 759
    if (*(ipp->col_stat + j)) {
#line 759
      tmp___6 = 1;
    } else {
      {
#line 759
      _glp_lib_xassert("ipp->col_stat[j]", "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c",
                       759);
#line 759
      tmp___6 = 1;
      }
    }
#line 759
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 762
  tmp___7 = _glp_lib_xcalloc(1 + ipp->orig_m, (int )sizeof(double ));
#line 762
  row_mipx = (double *)tmp___7;
#line 763
  tmp___8 = _glp_lib_xcalloc(1 + ipp->orig_n, (int )sizeof(int ));
#line 763
  ind = (int *)tmp___8;
#line 764
  tmp___9 = _glp_lib_xcalloc(1 + ipp->orig_n, (int )sizeof(double ));
#line 764
  val = (double *)tmp___9;
#line 765
  i = 1;
  }
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (! (i <= ipp->orig_m)) {
#line 765
      goto while_break___0;
    }
    {
#line 766
    len = _glp_lpx_get_mat_row(orig, i, ind, val);
#line 767
    temp = 0.0;
#line 768
    k = 1;
    }
    {
#line 768
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 768
      if (! (k <= len)) {
#line 768
        goto while_break___1;
      }
#line 769
      temp += *(val + k) * *(ipp->col_mipx + *(ind + k));
#line 768
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 770
    *(row_mipx + i) = temp;
#line 765
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 772
  _glp_lib_xfree((void *)ind);
#line 773
  _glp_lib_xfree((void *)val);
#line 775
  _glp_1px_put_mip_soln(orig, i_stat, row_mipx, ipp->col_mipx);
#line 776
  _glp_lib_xfree((void *)row_mipx);
  }
#line 777
  return;
}
}
#line 794 "/home/wslee/benchmarks/glpk-4.38/src/glpipp01.c"
void _glp_ipp_delete_wksp(IPP *ipp ) 
{ 


  {
#line 795
  if ((unsigned long )ipp->row_pool != (unsigned long )((void *)0)) {
    {
#line 795
    _glp_dmp_delete_pool(ipp->row_pool);
    }
  }
#line 796
  if ((unsigned long )ipp->col_pool != (unsigned long )((void *)0)) {
    {
#line 796
    _glp_dmp_delete_pool(ipp->col_pool);
    }
  }
#line 797
  if ((unsigned long )ipp->aij_pool != (unsigned long )((void *)0)) {
    {
#line 797
    _glp_dmp_delete_pool(ipp->aij_pool);
    }
  }
#line 798
  if ((unsigned long )ipp->tqe_pool != (unsigned long )((void *)0)) {
    {
#line 798
    _glp_dmp_delete_pool(ipp->tqe_pool);
    }
  }
#line 799
  if ((unsigned long )ipp->col_stat != (unsigned long )((void *)0)) {
    {
#line 799
    _glp_lib_xfree((void *)ipp->col_stat);
    }
  }
#line 800
  if ((unsigned long )ipp->col_mipx != (unsigned long )((void *)0)) {
    {
#line 800
    _glp_lib_xfree((void *)ipp->col_mipx);
    }
  }
  {
#line 801
  _glp_lib_xfree((void *)ipp);
  }
#line 802
  return;
}
}
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.h"
int _glp_ipm_solve(glp_prob *P , glp_iptcp const   *parm ) ;
#line 148 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static void initialize___1(struct csa___5 *csa ) 
{ 
  int m ;
  int n ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 149
  m = csa->m;
#line 150
  n = csa->n;
#line 152
  if ((csa->parm)->msg_lev >= 3) {
    {
#line 153
    _glp_lib_xprintf("Matrix A has %d non-zeros\n", *(csa->A_ptr + (m + 1)) - 1);
    }
  }
  {
#line 154
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 154
  csa->D = (double *)tmp;
#line 156
  tmp___0 = _glp_lib_xcalloc((1 + m) + m, (int )sizeof(int ));
#line 156
  csa->P = (int *)tmp___0;
#line 157
  i = 1;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i <= m)) {
#line 157
      goto while_break;
    }
#line 157
    tmp___1 = i;
#line 157
    *(csa->P + (m + i)) = tmp___1;
#line 157
    *(csa->P + i) = tmp___1;
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  tmp___2 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 159
  csa->S_ptr = (int *)tmp___2;
#line 160
  csa->S_ind = _glp_mat_adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind, csa->S_ptr);
  }
#line 162
  if ((csa->parm)->msg_lev >= 3) {
    {
#line 163
    _glp_lib_xprintf("Matrix S = A*A\' has %d non-zeros (upper triangle)\n", (*(csa->S_ptr + (m + 1)) - 1) + m);
    }
  }
#line 166
  if ((csa->parm)->ord_alg == 0) {
#line 167
    if ((csa->parm)->msg_lev >= 3) {
      {
#line 168
      _glp_lib_xprintf("Original ordering is being used\n");
      }
    }
#line 169
    i = 1;
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! (i <= m)) {
#line 169
        goto while_break___0;
      }
#line 170
      tmp___3 = i;
#line 170
      *(csa->P + (m + i)) = tmp___3;
#line 170
      *(csa->P + i) = tmp___3;
#line 169
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 172
  if ((csa->parm)->ord_alg == 1) {
#line 173
    if ((csa->parm)->msg_lev >= 3) {
      {
#line 174
      _glp_lib_xprintf("Minimum degree ordering (QMD)...\n");
      }
    }
    {
#line 175
    _glp_mat_min_degree(m, csa->S_ptr, csa->S_ind, csa->P);
    }
  } else
#line 177
  if ((csa->parm)->ord_alg == 2) {
#line 178
    if ((csa->parm)->msg_lev >= 3) {
      {
#line 179
      _glp_lib_xprintf("Approximate minimum degree ordering (AMD)...\n");
      }
    }
    {
#line 180
    _glp_mat_amd_order1(m, csa->S_ptr, csa->S_ind, csa->P);
    }
  } else
#line 182
  if ((csa->parm)->ord_alg == 3) {
#line 183
    if ((csa->parm)->msg_lev >= 3) {
      {
#line 184
      _glp_lib_xprintf("Approximate minimum degree ordering (SYMAMD)...\n");
      }
    }
    {
#line 186
    _glp_mat_symamd_ord(m, csa->S_ptr, csa->S_ind, csa->P);
    }
  } else
#line 189
  if ((unsigned long )csa != (unsigned long )csa) {
#line 189
    tmp___4 = 1;
  } else {
    {
#line 189
    _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                     189);
#line 189
    tmp___4 = 1;
    }
  }
  {
#line 191
  _glp_lib_xfree((void *)csa->S_ind);
#line 192
  csa->S_ind = _glp_mat_adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind, csa->S_ptr);
#line 194
  tmp___5 = _glp_lib_xcalloc(*(csa->S_ptr + (m + 1)), (int )sizeof(double ));
#line 194
  csa->S_val = (double *)tmp___5;
#line 195
  tmp___6 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 195
  csa->S_diag = (double *)tmp___6;
  }
#line 197
  if ((csa->parm)->msg_lev >= 3) {
    {
#line 198
    _glp_lib_xprintf("Computing Cholesky factorization S = L*L\'...\n");
    }
  }
  {
#line 199
  tmp___7 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 199
  csa->U_ptr = (int *)tmp___7;
#line 200
  csa->U_ind = _glp_mat_chol_symbolic(m, csa->S_ptr, csa->S_ind, csa->U_ptr);
  }
#line 201
  if ((csa->parm)->msg_lev >= 3) {
    {
#line 202
    _glp_lib_xprintf("Matrix L has %d non-zeros\n", (*(csa->U_ptr + (m + 1)) - 1) + m);
    }
  }
  {
#line 203
  tmp___8 = _glp_lib_xcalloc(*(csa->U_ptr + (m + 1)), (int )sizeof(double ));
#line 203
  csa->U_val = (double *)tmp___8;
#line 204
  tmp___9 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 204
  csa->U_diag = (double *)tmp___9;
#line 205
  csa->iter = 0;
#line 206
  csa->obj = 0.0;
#line 207
  csa->rpi = 0.0;
#line 208
  csa->rdi = 0.0;
#line 209
  csa->gap = 0.0;
#line 210
  csa->phi = 0.0;
#line 211
  csa->mu = 0.0;
#line 212
  csa->rmu = 0.0;
#line 213
  csa->rmu0 = 0.0;
#line 214
  tmp___10 = _glp_lib_xcalloc(101, (int )sizeof(double ));
#line 214
  csa->phi_min = (double *)tmp___10;
#line 215
  csa->best_iter = 0;
#line 216
  tmp___11 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 216
  csa->best_x = (double *)tmp___11;
#line 217
  tmp___12 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 217
  csa->best_y = (double *)tmp___12;
#line 218
  tmp___13 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 218
  csa->best_z = (double *)tmp___13;
#line 219
  csa->best_obj = 0.0;
#line 220
  tmp___14 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 220
  csa->dx_aff = (double *)tmp___14;
#line 221
  tmp___15 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 221
  csa->dy_aff = (double *)tmp___15;
#line 222
  tmp___16 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 222
  csa->dz_aff = (double *)tmp___16;
#line 223
  csa->alfa_aff_p = 0.0;
#line 224
  csa->alfa_aff_d = 0.0;
#line 225
  csa->mu_aff = 0.0;
#line 226
  csa->sigma = 0.0;
#line 227
  tmp___17 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 227
  csa->dx_cc = (double *)tmp___17;
#line 228
  tmp___18 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 228
  csa->dy_cc = (double *)tmp___18;
#line 229
  tmp___19 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 229
  csa->dz_cc = (double *)tmp___19;
#line 230
  csa->dx = csa->dx_aff;
#line 231
  csa->dy = csa->dy_aff;
#line 232
  csa->dz = csa->dz_aff;
#line 233
  csa->alfa_max_p = 0.0;
#line 234
  csa->alfa_max_d = 0.0;
  }
#line 235
  return;
}
}
#line 244 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static void A_by_vec(struct csa___5 *csa , double *x , double *y ) 
{ 
  int m ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int i ;
  int t ;
  int beg ;
  int end ;
  double temp ;

  {
#line 246
  m = csa->m;
#line 247
  A_ptr = csa->A_ptr;
#line 248
  A_ind = csa->A_ind;
#line 249
  A_val = csa->A_val;
#line 252
  i = 1;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i <= m)) {
#line 252
      goto while_break;
    }
#line 253
    temp = 0.0;
#line 254
    beg = *(A_ptr + i);
#line 254
    end = *(A_ptr + (i + 1));
#line 255
    t = beg;
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      if (! (t < end)) {
#line 255
        goto while_break___0;
      }
#line 255
      temp += *(A_val + t) * *(x + *(A_ind + t));
#line 255
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    *(y + i) = temp;
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 267 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static void AT_by_vec(struct csa___5 *csa , double *x , double *y ) 
{ 
  int m ;
  int n ;
  int *A_ptr ;
  int *A_ind ;
  double *A_val ;
  int i ;
  int j ;
  int t ;
  int beg ;
  int end ;
  double temp ;

  {
#line 269
  m = csa->m;
#line 270
  n = csa->n;
#line 271
  A_ptr = csa->A_ptr;
#line 272
  A_ind = csa->A_ind;
#line 273
  A_val = csa->A_val;
#line 276
  j = 1;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (j <= n)) {
#line 276
      goto while_break;
    }
#line 276
    *(y + j) = 0.0;
#line 276
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  i = 1;
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 277
    if (! (i <= m)) {
#line 277
      goto while_break___0;
    }
#line 278
    temp = *(x + i);
#line 279
    if (temp == 0.0) {
#line 279
      goto __Cont;
    }
#line 280
    beg = *(A_ptr + i);
#line 280
    end = *(A_ptr + (i + 1));
#line 281
    t = beg;
    {
#line 281
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 281
      if (! (t < end)) {
#line 281
        goto while_break___1;
      }
#line 281
      *(y + *(A_ind + t)) += *(A_val + t) * temp;
#line 281
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 277
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 283
  return;
}
}
#line 293 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static void decomp_NE(struct csa___5 *csa ) 
{ 


  {
  {
#line 294
  _glp_mat_adat_numeric(csa->m, csa->n, csa->P, csa->A_ptr, csa->A_ind, csa->A_val,
                        csa->D, csa->S_ptr, csa->S_ind, csa->S_val, csa->S_diag);
#line 297
  _glp_mat_chol_numeric(csa->m, csa->S_ptr, csa->S_ind, csa->S_val, csa->S_diag, csa->U_ptr,
                        csa->U_ind, csa->U_val, csa->U_diag);
  }
#line 299
  return;
}
}
#line 323 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static int solve_NE(struct csa___5 *csa , double *y ) 
{ 
  int m ;
  int n ;
  int *P ;
  int i ;
  int j ;
  int ret ;
  double *h ;
  double *r ;
  double *w ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  {
#line 324
  m = csa->m;
#line 325
  n = csa->n;
#line 326
  P = csa->P;
#line 327
  ret = 0;
#line 330
  tmp = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 330
  h = (double *)tmp;
#line 331
  i = 1;
  }
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i <= m)) {
#line 331
      goto while_break;
    }
#line 331
    *(h + i) = *(y + i);
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  tmp___0 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 336
  w = (double *)tmp___0;
#line 337
  i = 1;
  }
  {
#line 337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 337
    if (! (i <= m)) {
#line 337
      goto while_break___0;
    }
#line 337
    *(w + i) = *(y + *(P + i));
#line 337
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 339
  _glp_mat_ut_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);
#line 341
  _glp_mat_u_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);
#line 343
  i = 1;
  }
  {
#line 343
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 343
    if (! (i <= m)) {
#line 343
      goto while_break___1;
    }
#line 343
    *(y + i) = *(w + *(P + (m + i)));
#line 343
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 344
  _glp_lib_xfree((void *)w);
#line 346
  tmp___1 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 346
  r = (double *)tmp___1;
#line 348
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 348
  w = (double *)tmp___2;
#line 349
  AT_by_vec(csa, y, w);
#line 351
  j = 1;
  }
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (j <= n)) {
#line 351
      goto while_break___2;
    }
#line 351
    *(w + j) *= *(csa->D + j);
#line 351
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 353
  A_by_vec(csa, w, r);
#line 354
  _glp_lib_xfree((void *)w);
#line 356
  i = 1;
  }
  {
#line 356
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 356
    if (! (i <= m)) {
#line 356
      goto while_break___3;
    }
#line 356
    *(r + i) -= *(h + i);
#line 356
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 358
  i = 1;
  {
#line 358
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 358
    if (! (i <= m)) {
#line 358
      goto while_break___4;
    }
    {
#line 359
    tmp___3 = fabs(*(r + i));
#line 359
    tmp___4 = fabs(*(h + i));
    }
#line 359
    if (tmp___3 / (1.0 + tmp___4) > 1e-4) {
#line 360
      ret = 1;
#line 361
      goto while_break___4;
    }
#line 358
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 364
  _glp_lib_xfree((void *)h);
#line 365
  _glp_lib_xfree((void *)r);
  }
#line 366
  return (ret);
}
}
#line 398 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static int solve_NS(struct csa___5 *csa , double *p , double *q , double *r , double *dx ,
                    double *dy , double *dz ) 
{ 
  int m ;
  int n ;
  double *x ;
  double *z ;
  int i ;
  int j ;
  int ret ;
  double *w ;

  {
#line 400
  m = csa->m;
#line 401
  n = csa->n;
#line 402
  x = csa->x;
#line 403
  z = csa->z;
#line 405
  w = dx;
#line 408
  j = 1;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (j <= n)) {
#line 408
      goto while_break;
    }
#line 409
    *(w + j) = (*(x + j) * *(q + j) - *(r + j)) / *(z + j);
#line 408
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  A_by_vec(csa, w, dy);
#line 411
  i = 1;
  }
  {
#line 411
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 411
    if (! (i <= m)) {
#line 411
      goto while_break___0;
    }
#line 411
    *(dy + i) += *(p + i);
#line 411
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 413
  ret = solve_NE(csa, dy);
#line 415
  AT_by_vec(csa, dy, dx);
#line 416
  j = 1;
  }
  {
#line 416
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 416
    if (! (j <= n)) {
#line 416
      goto while_break___1;
    }
#line 417
    *(dx + j) = (*(x + j) * (*(dx + j) - *(q + j)) + *(r + j)) / *(z + j);
#line 418
    *(dz + j) = (*(r + j) - *(z + j) * *(dx + j)) / *(x + j);
#line 416
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 420
  return (ret);
}
}
#line 460 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static void initial_point(struct csa___5 *csa ) 
{ 
  int m ;
  int n ;
  double *b ;
  double *c ;
  double *x ;
  double *y ;
  double *z ;
  double *D ;
  int i ;
  int j ;
  double dp ;
  double dd ;
  double ex ;
  double ez ;
  double xz ;
  int tmp ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 461
  m = csa->m;
#line 462
  n = csa->n;
#line 463
  b = csa->b;
#line 464
  c = csa->c;
#line 465
  x = csa->x;
#line 466
  y = csa->y;
#line 467
  z = csa->z;
#line 468
  D = csa->D;
#line 472
  j = 1;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (j <= n)) {
#line 472
      goto while_break;
    }
#line 472
    *(D + j) = 1.0;
#line 472
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  decomp_NE(csa);
#line 475
  i = 1;
  }
  {
#line 475
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 475
    if (! (i <= m)) {
#line 475
      goto while_break___0;
    }
#line 475
    *(y + i) = *(b + i);
#line 475
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 476
  solve_NE(csa, y);
#line 477
  AT_by_vec(csa, y, x);
#line 479
  A_by_vec(csa, c, y);
#line 480
  solve_NE(csa, y);
#line 482
  AT_by_vec(csa, y, z);
#line 483
  j = 1;
  }
  {
#line 483
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 483
    if (! (j <= n)) {
#line 483
      goto while_break___1;
    }
#line 483
    *(z + j) = *(c + j) - *(z + j);
#line 483
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 486
  dd = 0.0;
#line 486
  dp = dd;
#line 487
  j = 1;
  {
#line 487
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 487
    if (! (j <= n)) {
#line 487
      goto while_break___2;
    }
#line 488
    if (dp < - 1.5 * *(x + j)) {
#line 488
      dp = - 1.5 * *(x + j);
    }
#line 489
    if (dd < - 1.5 * *(z + j)) {
#line 489
      dd = - 1.5 * *(z + j);
    }
#line 487
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 493
  if (dp == 0.0) {
#line 493
    dp = 1.5;
  }
#line 494
  if (dd == 0.0) {
#line 494
    dd = 1.5;
  }
#line 495
  xz = 0.0;
#line 495
  ez = xz;
#line 495
  ex = ez;
#line 496
  j = 1;
  {
#line 496
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 496
    if (! (j <= n)) {
#line 496
      goto while_break___3;
    }
#line 497
    ex += *(x + j) + dp;
#line 498
    ez += *(z + j) + dd;
#line 499
    xz += (*(x + j) + dp) * (*(z + j) + dd);
#line 496
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 501
  dp += 0.5 * (xz / ez);
#line 502
  dd += 0.5 * (xz / ex);
#line 503
  j = 1;
  {
#line 503
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 503
    if (! (j <= n)) {
#line 503
      goto while_break___4;
    }
#line 504
    *(x + j) += dp;
#line 505
    *(z + j) += dd;
#line 506
    if (*(x + j) > 0.0) {
#line 506
      if (*(z + j) > 0.0) {
#line 506
        tmp = 1;
      } else {
        {
#line 506
        _glp_lib_xassert("x[j] > 0.0 && z[j] > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                         506);
#line 506
        tmp = 1;
        }
      }
    } else {
      {
#line 506
      _glp_lib_xassert("x[j] > 0.0 && z[j] > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                       506);
#line 506
      tmp = 1;
      }
    }
#line 503
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 508
  return;
}
}
#line 549 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static void basic_info(struct csa___5 *csa ) 
{ 
  int m ;
  int n ;
  double *b ;
  double *c ;
  double *x ;
  double *y ;
  double *z ;
  int i ;
  int j ;
  double norm1 ;
  double bnorm ;
  double norm2 ;
  double cnorm ;
  double cx ;
  double by ;
  double *work ;
  double temp ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 550
  m = csa->m;
#line 551
  n = csa->n;
#line 552
  b = csa->b;
#line 553
  c = csa->c;
#line 554
  x = csa->x;
#line 555
  y = csa->y;
#line 556
  z = csa->z;
#line 560
  temp = *(c + 0);
#line 561
  j = 1;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! (j <= n)) {
#line 561
      goto while_break;
    }
#line 561
    temp += *(c + j) * *(x + j);
#line 561
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 562
  csa->obj = temp;
#line 564
  tmp = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 564
  work = (double *)tmp;
#line 565
  A_by_vec(csa, x, work);
#line 566
  norm1 = 0.0;
#line 567
  i = 1;
  }
  {
#line 567
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 567
    if (! (i <= m)) {
#line 567
      goto while_break___0;
    }
#line 568
    norm1 += (*(work + i) - *(b + i)) * (*(work + i) - *(b + i));
#line 567
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 569
  norm1 = sqrt(norm1);
#line 570
  _glp_lib_xfree((void *)work);
#line 572
  bnorm = 0.0;
#line 573
  i = 1;
  }
  {
#line 573
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 573
    if (! (i <= m)) {
#line 573
      goto while_break___1;
    }
#line 573
    bnorm += *(b + i) * *(b + i);
#line 573
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 574
  bnorm = sqrt(bnorm);
#line 576
  csa->rpi = norm1 / (1.0 + bnorm);
#line 578
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 578
  work = (double *)tmp___0;
#line 579
  AT_by_vec(csa, y, work);
#line 580
  norm2 = 0.0;
#line 581
  j = 1;
  }
  {
#line 581
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 581
    if (! (j <= n)) {
#line 581
      goto while_break___2;
    }
#line 582
    norm2 += ((*(work + j) + *(z + j)) - *(c + j)) * ((*(work + j) + *(z + j)) - *(c + j));
#line 581
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 583
  norm2 = sqrt(norm2);
#line 584
  _glp_lib_xfree((void *)work);
#line 586
  cnorm = 0.0;
#line 587
  j = 1;
  }
  {
#line 587
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 587
    if (! (j <= n)) {
#line 587
      goto while_break___3;
    }
#line 587
    cnorm += *(c + j) * *(c + j);
#line 587
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  cnorm = sqrt(cnorm);
#line 590
  csa->rdi = norm2 / (1.0 + cnorm);
#line 592
  by = 0.0;
#line 593
  i = 1;
  }
  {
#line 593
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 593
    if (! (i <= m)) {
#line 593
      goto while_break___4;
    }
#line 593
    by += *(b + i) * *(y + i);
#line 593
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 595
  cx = 0.0;
#line 596
  j = 1;
  {
#line 596
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 596
    if (! (j <= n)) {
#line 596
      goto while_break___5;
    }
#line 596
    cx += *(c + j) * *(x + j);
#line 596
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 598
  tmp___1 = fabs(cx - by);
#line 598
  tmp___2 = fabs(cx);
#line 598
  csa->gap = tmp___1 / (1.0 + tmp___2);
#line 600
  csa->phi = 0.0;
  }
#line 601
  if (bnorm > 1.0) {
#line 601
    tmp___3 = bnorm;
  } else {
#line 601
    tmp___3 = 1.0;
  }
#line 601
  csa->phi += norm1 / tmp___3;
#line 602
  if (cnorm > 1.0) {
#line 602
    tmp___4 = cnorm;
  } else {
#line 602
    tmp___4 = 1.0;
  }
#line 602
  csa->phi += norm2 / tmp___4;
#line 603
  temp = 1.0;
#line 604
  if (temp < bnorm) {
#line 604
    temp = bnorm;
  }
#line 605
  if (temp < cnorm) {
#line 605
    temp = cnorm;
  }
  {
#line 606
  tmp___5 = fabs(cx - by);
#line 606
  csa->phi += tmp___5 / temp;
#line 608
  temp = 0.0;
#line 609
  j = 1;
  }
  {
#line 609
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 609
    if (! (j <= n)) {
#line 609
      goto while_break___6;
    }
#line 609
    temp += *(x + j) * *(z + j);
#line 609
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 610
  csa->mu = temp / (double )n;
#line 612
  if (norm1 > norm2) {
#line 612
    tmp___6 = norm1;
  } else {
#line 612
    tmp___6 = norm2;
  }
#line 612
  csa->rmu = tmp___6 / csa->mu;
#line 613
  return;
}
}
#line 691 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static int make_step(struct csa___5 *csa ) 
{ 
  int m ;
  int n ;
  double *b ;
  double *c ;
  double *x ;
  double *y ;
  double *z ;
  double *dx_aff ;
  double *dy_aff ;
  double *dz_aff ;
  double *dx_cc ;
  double *dy_cc ;
  double *dz_cc ;
  double *dx ;
  double *dy ;
  double *dz ;
  int i ;
  int j ;
  int ret ;
  double temp ;
  double gamma_p ;
  double gamma_d ;
  double *p ;
  double *q ;
  double *r ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 692
  m = csa->m;
#line 693
  n = csa->n;
#line 694
  b = csa->b;
#line 695
  c = csa->c;
#line 696
  x = csa->x;
#line 697
  y = csa->y;
#line 698
  z = csa->z;
#line 699
  dx_aff = csa->dx_aff;
#line 700
  dy_aff = csa->dy_aff;
#line 701
  dz_aff = csa->dz_aff;
#line 702
  dx_cc = csa->dx_cc;
#line 703
  dy_cc = csa->dy_cc;
#line 704
  dz_cc = csa->dz_cc;
#line 705
  dx = csa->dx;
#line 706
  dy = csa->dy;
#line 707
  dz = csa->dz;
#line 708
  ret = 0;
#line 711
  tmp = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 711
  p = (double *)tmp;
#line 712
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 712
  q = (double *)tmp___0;
#line 713
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 713
  r = (double *)tmp___1;
#line 715
  A_by_vec(csa, x, p);
#line 716
  i = 1;
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (i <= m)) {
#line 716
      goto while_break;
    }
#line 716
    *(p + i) = *(b + i) - *(p + i);
#line 716
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 718
  AT_by_vec(csa, y, q);
#line 719
  j = 1;
  }
  {
#line 719
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 719
    if (! (j <= n)) {
#line 719
      goto while_break___0;
    }
#line 719
    *(q + j) = (*(c + j) - *(q + j)) - *(z + j);
#line 719
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 721
  j = 1;
  {
#line 721
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 721
    if (! (j <= n)) {
#line 721
      goto while_break___1;
    }
#line 721
    *(r + j) = - *(x + j) * *(z + j);
#line 721
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 723
  tmp___2 = solve_NS(csa, p, q, r, dx_aff, dy_aff, dz_aff);
  }
#line 723
  if (tmp___2) {
#line 724
    ret = 1;
#line 725
    goto done;
  }
#line 729
  tmp___3 = 1.0;
#line 729
  csa->alfa_aff_d = tmp___3;
#line 729
  csa->alfa_aff_p = tmp___3;
#line 730
  j = 1;
  {
#line 730
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 730
    if (! (j <= n)) {
#line 730
      goto while_break___2;
    }
#line 731
    if (*(dx_aff + j) < 0.0) {
#line 732
      temp = - *(x + j) / *(dx_aff + j);
#line 733
      if (csa->alfa_aff_p > temp) {
#line 733
        csa->alfa_aff_p = temp;
      }
    }
#line 735
    if (*(dz_aff + j) < 0.0) {
#line 736
      temp = - *(z + j) / *(dz_aff + j);
#line 737
      if (csa->alfa_aff_d > temp) {
#line 737
        csa->alfa_aff_d = temp;
      }
    }
#line 730
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 741
  temp = 0.0;
#line 742
  j = 1;
  {
#line 742
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 742
    if (! (j <= n)) {
#line 742
      goto while_break___3;
    }
#line 743
    temp += (*(x + j) + csa->alfa_aff_p * *(dx_aff + j)) * (*(z + j) + csa->alfa_aff_d * *(dz_aff + j));
#line 742
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 745
  csa->mu_aff = temp / (double )n;
#line 747
  temp = csa->mu_aff / csa->mu;
#line 748
  csa->sigma = (temp * temp) * temp;
#line 750
  i = 1;
  {
#line 750
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 750
    if (! (i <= m)) {
#line 750
      goto while_break___4;
    }
#line 750
    *(p + i) = 0.0;
#line 750
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 752
  j = 1;
  {
#line 752
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 752
    if (! (j <= n)) {
#line 752
      goto while_break___5;
    }
#line 752
    *(q + j) = 0.0;
#line 752
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 754
  j = 1;
  {
#line 754
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 754
    if (! (j <= n)) {
#line 754
      goto while_break___6;
    }
#line 755
    *(r + j) = csa->sigma * csa->mu - *(dx_aff + j) * *(dz_aff + j);
#line 754
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 758
  tmp___4 = solve_NS(csa, p, q, r, dx_cc, dy_cc, dz_cc);
  }
#line 758
  if (tmp___4) {
#line 759
    ret = 1;
#line 760
    goto done;
  }
#line 763
  j = 1;
  {
#line 763
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 763
    if (! (j <= n)) {
#line 763
      goto while_break___7;
    }
#line 763
    *(dx + j) = *(dx_aff + j) + *(dx_cc + j);
#line 763
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 764
  i = 1;
  {
#line 764
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 764
    if (! (i <= m)) {
#line 764
      goto while_break___8;
    }
#line 764
    *(dy + i) = *(dy_aff + i) + *(dy_cc + i);
#line 764
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 765
  j = 1;
  {
#line 765
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 765
    if (! (j <= n)) {
#line 765
      goto while_break___9;
    }
#line 765
    *(dz + j) = *(dz_aff + j) + *(dz_cc + j);
#line 765
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 768
  tmp___5 = 1.0;
#line 768
  csa->alfa_max_d = tmp___5;
#line 768
  csa->alfa_max_p = tmp___5;
#line 769
  j = 1;
  {
#line 769
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 769
    if (! (j <= n)) {
#line 769
      goto while_break___10;
    }
#line 770
    if (*(dx + j) < 0.0) {
#line 771
      temp = - *(x + j) / *(dx + j);
#line 772
      if (csa->alfa_max_p > temp) {
#line 772
        csa->alfa_max_p = temp;
      }
    }
#line 774
    if (*(dz + j) < 0.0) {
#line 775
      temp = - *(z + j) / *(dz + j);
#line 776
      if (csa->alfa_max_d > temp) {
#line 776
        csa->alfa_max_d = temp;
      }
    }
#line 769
    j ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 780
  gamma_p = 0.90;
#line 781
  gamma_d = 0.90;
#line 783
  j = 1;
  {
#line 783
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 783
    if (! (j <= n)) {
#line 783
      goto while_break___11;
    }
#line 784
    *(x + j) += (gamma_p * csa->alfa_max_p) * *(dx + j);
#line 785
    if (*(x + j) > 0.0) {
#line 785
      tmp___6 = 1;
    } else {
      {
#line 785
      _glp_lib_xassert("x[j] > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                       785);
#line 785
      tmp___6 = 1;
      }
    }
#line 783
    j ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 787
  i = 1;
  {
#line 787
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 787
    if (! (i <= m)) {
#line 787
      goto while_break___12;
    }
#line 788
    *(y + i) += (gamma_d * csa->alfa_max_d) * *(dy + i);
#line 787
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 789
  j = 1;
  {
#line 789
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 789
    if (! (j <= n)) {
#line 789
      goto while_break___13;
    }
#line 790
    *(z + j) += (gamma_d * csa->alfa_max_d) * *(dz + j);
#line 791
    if (*(z + j) > 0.0) {
#line 791
      tmp___7 = 1;
    } else {
      {
#line 791
      _glp_lib_xassert("z[j] > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                       791);
#line 791
      tmp___7 = 1;
      }
    }
#line 789
    j ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  done: 
  {
#line 794
  _glp_lib_xfree((void *)p);
#line 795
  _glp_lib_xfree((void *)q);
#line 796
  _glp_lib_xfree((void *)r);
  }
#line 797
  return (ret);
}
}
#line 806 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static void terminate(struct csa___5 *csa ) 
{ 


  {
  {
#line 807
  _glp_lib_xfree((void *)csa->D);
#line 808
  _glp_lib_xfree((void *)csa->P);
#line 809
  _glp_lib_xfree((void *)csa->S_ptr);
#line 810
  _glp_lib_xfree((void *)csa->S_ind);
#line 811
  _glp_lib_xfree((void *)csa->S_val);
#line 812
  _glp_lib_xfree((void *)csa->S_diag);
#line 813
  _glp_lib_xfree((void *)csa->U_ptr);
#line 814
  _glp_lib_xfree((void *)csa->U_ind);
#line 815
  _glp_lib_xfree((void *)csa->U_val);
#line 816
  _glp_lib_xfree((void *)csa->U_diag);
#line 817
  _glp_lib_xfree((void *)csa->phi_min);
#line 818
  _glp_lib_xfree((void *)csa->best_x);
#line 819
  _glp_lib_xfree((void *)csa->best_y);
#line 820
  _glp_lib_xfree((void *)csa->best_z);
#line 821
  _glp_lib_xfree((void *)csa->dx_aff);
#line 822
  _glp_lib_xfree((void *)csa->dy_aff);
#line 823
  _glp_lib_xfree((void *)csa->dz_aff);
#line 824
  _glp_lib_xfree((void *)csa->dx_cc);
#line 825
  _glp_lib_xfree((void *)csa->dy_cc);
#line 826
  _glp_lib_xfree((void *)csa->dz_cc);
  }
#line 827
  return;
}
}
#line 846 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
static int ipm_main(struct csa___5 *csa ) 
{ 
  int m ;
  int n ;
  int i ;
  int j ;
  int status ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 847
  m = csa->m;
#line 848
  n = csa->n;
#line 852
  if ((csa->parm)->msg_lev >= 3) {
    {
#line 853
    _glp_lib_xprintf("Guessing initial point...\n");
    }
  }
  {
#line 854
  initial_point(csa);
  }
#line 856
  if ((csa->parm)->msg_lev >= 3) {
    {
#line 857
    _glp_lib_xprintf("Optimization begins...\n");
    }
  }
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 860
    basic_info(csa);
    }
#line 862
    if (csa->iter == 0) {
#line 862
      csa->rmu0 = csa->rmu;
    }
#line 864
    if (csa->iter <= 100) {
#line 864
      tmp = 1;
    } else {
      {
#line 864
      _glp_lib_xassert("csa->iter <= ITER_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                       864);
#line 864
      tmp = 1;
      }
    }
#line 865
    if (csa->iter == 0) {
#line 865
      goto _L;
    } else
#line 865
    if (*(csa->phi_min + (csa->iter - 1)) > csa->phi) {
      _L: /* CIL Label */ 
#line 866
      *(csa->phi_min + csa->iter) = csa->phi;
#line 867
      csa->best_iter = csa->iter;
#line 868
      j = 1;
      {
#line 868
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 868
        if (! (j <= n)) {
#line 868
          goto while_break___0;
        }
#line 868
        *(csa->best_x + j) = *(csa->x + j);
#line 868
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 869
      i = 1;
      {
#line 869
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 869
        if (! (i <= m)) {
#line 869
          goto while_break___1;
        }
#line 869
        *(csa->best_y + i) = *(csa->y + i);
#line 869
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 870
      j = 1;
      {
#line 870
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 870
        if (! (j <= n)) {
#line 870
          goto while_break___2;
        }
#line 870
        *(csa->best_z + j) = *(csa->z + j);
#line 870
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 871
      csa->best_obj = csa->obj;
    } else {
#line 874
      *(csa->phi_min + csa->iter) = *(csa->phi_min + (csa->iter - 1));
    }
#line 876
    if ((csa->parm)->msg_lev >= 2) {
      {
#line 877
      _glp_lib_xprintf("%3d: obj = %17.9e; rpi = %8.1e; rdi = %8.1e; gap = %8.1e\n",
                       csa->iter, csa->obj, csa->rpi, csa->rdi, csa->gap);
      }
    }
#line 881
    if (csa->rpi < 1e-8) {
#line 881
      if (csa->rdi < 1e-8) {
#line 881
        if (csa->gap < 1e-8) {
#line 882
          if ((csa->parm)->msg_lev >= 3) {
            {
#line 883
            _glp_lib_xprintf("OPTIMAL SOLUTION FOUND\n");
            }
          }
#line 884
          status = 0;
#line 885
          goto while_break;
        }
      }
    }
#line 888
    temp = 1e5 * *(csa->phi_min + csa->iter);
#line 889
    if (temp < 1e-8) {
#line 889
      temp = 1e-8;
    }
#line 890
    if (csa->phi >= temp) {
#line 891
      if ((csa->parm)->msg_lev >= 3) {
        {
#line 892
        _glp_lib_xprintf("PROBLEM HAS NO FEASIBLE PRIMAL/DUAL SOLUTION\n");
        }
      }
#line 894
      status = 1;
#line 895
      goto while_break;
    }
#line 898
    if (csa->rpi >= 1e-8) {
#line 898
      goto _L___2;
    } else
#line 898
    if (csa->rdi >= 1e-8) {
      _L___2: /* CIL Label */ 
#line 898
      if (csa->rmu / csa->rmu0 >= 1e6) {
#line 898
        goto _L___0;
      } else {
#line 898
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 898
    if (csa->iter >= 30) {
#line 898
      if (*(csa->phi_min + csa->iter) >= 0.5 * *(csa->phi_min + (csa->iter - 30))) {
        _L___0: /* CIL Label */ 
#line 902
        if ((csa->parm)->msg_lev >= 3) {
          {
#line 903
          _glp_lib_xprintf("NO CONVERGENCE; SEARCH TERMINATED\n");
          }
        }
#line 904
        status = 2;
#line 905
        goto while_break;
      }
    }
#line 908
    if (csa->iter == 100) {
#line 909
      if ((csa->parm)->msg_lev >= 3) {
        {
#line 910
        _glp_lib_xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
        }
      }
#line 911
      status = 3;
#line 912
      goto while_break;
    }
#line 915
    (csa->iter) ++;
#line 917
    j = 1;
    {
#line 917
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 917
      if (! (j <= n)) {
#line 917
        goto while_break___3;
      }
#line 917
      *(csa->D + j) = *(csa->x + j) / *(csa->z + j);
#line 917
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 918
    decomp_NE(csa);
#line 921
    tmp___0 = make_step(csa);
    }
#line 921
    if (tmp___0) {
#line 922
      if ((csa->parm)->msg_lev >= 3) {
        {
#line 923
        _glp_lib_xprintf("NUMERIC INSTABILITY; SEARCH TERMINATED\n");
        }
      }
#line 924
      status = 4;
#line 925
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 929
  if (status != 0) {
#line 930
    j = 1;
    {
#line 930
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 930
      if (! (j <= n)) {
#line 930
        goto while_break___4;
      }
#line 930
      *(csa->x + j) = *(csa->best_x + j);
#line 930
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 931
    i = 1;
    {
#line 931
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 931
      if (! (i <= m)) {
#line 931
        goto while_break___5;
      }
#line 931
      *(csa->y + i) = *(csa->best_y + i);
#line 931
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 932
    j = 1;
    {
#line 932
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 932
      if (! (j <= n)) {
#line 932
        goto while_break___6;
      }
#line 932
      *(csa->z + j) = *(csa->best_z + j);
#line 932
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 933
    if ((csa->parm)->msg_lev >= 3) {
      {
#line 934
      _glp_lib_xprintf("Best point %17.9e was reached on iteration %d\n", csa->best_obj,
                       csa->best_iter);
      }
    }
  }
#line 938
  return (status);
}
}
#line 1022 "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c"
int _glp_ipm_solve(glp_prob *P , glp_iptcp const   *parm ) 
{ 
  struct csa___5 _dsa ;
  struct csa___5 *csa ;
  int m ;
  int n ;
  int nnz ;
  GLPROW *row ;
  GLPCOL *col ;
  GLPAIJ *aij ;
  int i ;
  int j ;
  int loc ;
  int ret ;
  int *A_ind ;
  int *A_ptr ;
  double dir ;
  double *A_val ;
  double *b ;
  double *c ;
  double *x ;
  double *y ;
  double *z ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 1023
  csa = & _dsa;
#line 1024
  m = P->m;
#line 1025
  n = P->n;
#line 1026
  nnz = P->nnz;
#line 1032
  if (m > 0) {
#line 1032
    tmp = 1;
  } else {
    {
#line 1032
    _glp_lib_xassert("m > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c", 1032);
#line 1032
    tmp = 1;
    }
  }
#line 1033
  if (n > 0) {
#line 1033
    tmp___0 = 1;
  } else {
    {
#line 1033
    _glp_lib_xassert("n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c", 1033);
#line 1033
    tmp___0 = 1;
    }
  }
  {
#line 1035
  tmp___1 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 1035
  A_ptr = (int *)tmp___1;
#line 1036
  tmp___2 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(int ));
#line 1036
  A_ind = (int *)tmp___2;
#line 1037
  tmp___3 = _glp_lib_xcalloc(1 + nnz, (int )sizeof(double ));
#line 1037
  A_val = (double *)tmp___3;
#line 1038
  tmp___4 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 1038
  b = (double *)tmp___4;
#line 1039
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 1039
  c = (double *)tmp___5;
#line 1040
  tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 1040
  x = (double *)tmp___6;
#line 1041
  tmp___7 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 1041
  y = (double *)tmp___7;
#line 1042
  tmp___8 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 1042
  z = (double *)tmp___8;
#line 1044
  loc = 1;
#line 1045
  i = 1;
  }
  {
#line 1045
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1045
    if (! (i <= m)) {
#line 1045
      goto while_break;
    }
#line 1046
    row = *(P->row + i);
#line 1047
    if (row->type == 5) {
#line 1047
      tmp___9 = 1;
    } else {
      {
#line 1047
      _glp_lib_xassert("row->type == GLP_FX", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                       1047);
#line 1047
      tmp___9 = 1;
      }
    }
#line 1048
    *(b + i) = row->lb * row->rii;
#line 1049
    *(A_ptr + i) = loc;
#line 1050
    aij = row->ptr;
    {
#line 1050
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1050
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1050
        goto while_break___0;
      }
#line 1051
      *(A_ind + loc) = (aij->col)->j;
#line 1052
      *(A_val + loc) = (row->rii * aij->val) * (aij->col)->sjj;
#line 1053
      loc ++;
#line 1050
      aij = aij->r_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1045
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1056
  *(A_ptr + (m + 1)) = loc;
#line 1057
  if (loc - 1 == nnz) {
#line 1057
    tmp___10 = 1;
  } else {
    {
#line 1057
    _glp_lib_xassert("loc-1 == nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                     1057);
#line 1057
    tmp___10 = 1;
    }
  }
#line 1059
  if (P->dir == 1) {
#line 1060
    dir = 1.0;
  } else
#line 1061
  if (P->dir == 2) {
#line 1062
    dir = - 1.0;
  } else
#line 1064
  if ((unsigned long )P != (unsigned long )P) {
#line 1064
    tmp___11 = 1;
  } else {
    {
#line 1064
    _glp_lib_xassert("P != P", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c", 1064);
#line 1064
    tmp___11 = 1;
    }
  }
#line 1065
  *(c + 0) = dir * P->c0;
#line 1066
  j = 1;
  {
#line 1066
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1066
    if (! (j <= n)) {
#line 1066
      goto while_break___1;
    }
#line 1067
    col = *(P->col + j);
#line 1068
    if (col->type == 2) {
#line 1068
      if (col->lb == 0.0) {
#line 1068
        tmp___12 = 1;
      } else {
        {
#line 1068
        _glp_lib_xassert("col->type == GLP_LO && col->lb == 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                         1068);
#line 1068
        tmp___12 = 1;
        }
      }
    } else {
      {
#line 1068
      _glp_lib_xassert("col->type == GLP_LO && col->lb == 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                       1068);
#line 1068
      tmp___12 = 1;
      }
    }
#line 1069
    *(c + j) = (dir * col->coef) * col->sjj;
#line 1066
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1072
  csa->m = m;
#line 1073
  csa->n = n;
#line 1074
  csa->A_ptr = A_ptr;
#line 1075
  csa->A_ind = A_ind;
#line 1076
  csa->A_val = A_val;
#line 1077
  csa->b = b;
#line 1078
  csa->c = c;
#line 1079
  csa->x = x;
#line 1080
  csa->y = y;
#line 1081
  csa->z = z;
#line 1082
  csa->parm = parm;
#line 1083
  initialize___1(csa);
#line 1085
  ret = ipm_main(csa);
#line 1087
  terminate(csa);
  }
#line 1089
  if (ret == 0) {
#line 1091
    P->ipt_stat = 5;
#line 1092
    ret = 0;
  } else
#line 1094
  if (ret == 1) {
#line 1096
    P->ipt_stat = 4;
#line 1097
    ret = 0;
  } else
#line 1099
  if (ret == 2) {
#line 1101
    P->ipt_stat = 3;
#line 1102
    ret = 16;
  } else
#line 1104
  if (ret == 3) {
#line 1106
    P->ipt_stat = 3;
#line 1107
    ret = 8;
  } else
#line 1109
  if (ret == 4) {
#line 1111
    P->ipt_stat = 3;
#line 1112
    ret = 17;
  } else
#line 1115
  if (ret != ret) {
#line 1115
    tmp___13 = 1;
  } else {
    {
#line 1115
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpipm.c",
                     1115);
#line 1115
    tmp___13 = 1;
    }
  }
#line 1117
  i = 1;
  {
#line 1117
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1117
    if (! (i <= m)) {
#line 1117
      goto while_break___2;
    }
#line 1118
    row = *(P->row + i);
#line 1119
    row->pval = row->lb;
#line 1120
    row->dval = (dir * *(y + i)) * row->rii;
#line 1117
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1123
  P->ipt_obj = P->c0;
#line 1124
  j = 1;
  {
#line 1124
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1124
    if (! (j <= n)) {
#line 1124
      goto while_break___3;
    }
#line 1125
    col = *(P->col + j);
#line 1126
    col->pval = *(x + j) * col->sjj;
#line 1127
    col->dval = (dir * *(z + j)) / col->sjj;
#line 1128
    P->ipt_obj += col->coef * col->pval;
#line 1124
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1131
  _glp_lib_xfree((void *)A_ptr);
#line 1132
  _glp_lib_xfree((void *)A_ind);
#line 1133
  _glp_lib_xfree((void *)A_val);
#line 1134
  _glp_lib_xfree((void *)b);
#line 1135
  _glp_lib_xfree((void *)c);
#line 1136
  _glp_lib_xfree((void *)x);
#line 1137
  _glp_lib_xfree((void *)y);
#line 1138
  _glp_lib_xfree((void *)z);
  }
#line 1139
  return (ret);
}
}
#line 756 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 335 "./../include/glpk.h"
void glp_copy_prob(glp_prob *dest , glp_prob *prob , int names ) ;
#line 662
int glp_ios_heur_sol(glp_tree___0 *tree , double const   *x ) ;
#line 464 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
int _glp_ios_is_hopeful(glp_tree___0 *tree , double bound ) ;
#line 616
void _glp_ios_feas_pump(glp_tree___0 *T ) ;
#line 57 "/home/wslee/benchmarks/glpk-4.38/src/glpios10.c"
static int fcmp(void const   *x , void const   *y ) 
{ 
  struct VAR  const  *vx ;
  struct VAR  const  *vy ;

  {
#line 59
  vx = (struct VAR  const  *)x;
#line 59
  vy = (struct VAR  const  *)y;
#line 60
  if (vx->d > vy->d) {
#line 61
    return (-1);
  } else
#line 62
  if (vx->d < vy->d) {
#line 63
    return (1);
  } else {
#line 65
    return (0);
  }
}
}
#line 68 "/home/wslee/benchmarks/glpk-4.38/src/glpios10.c"
void _glp_ios_feas_pump(glp_tree___0 *T ) 
{ 
  glp_prob *P ;
  int n ;
  glp_prob *lp ;
  struct VAR *var ;
  RNG *rand___0 ;
  GLPCOL *col ;
  glp_smcp parm ;
  int j ;
  int k ;
  int new_x ;
  int nfail ;
  int npass ;
  int nv ;
  int ret ;
  int stalling ;
  double dist ;
  double tol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int *ind ;
  double *val ;
  double bnd ;
  void *tmp___4 ;
  void *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double rho ;
  double temp ;
  xlong_t tmp___9 ;
  double tmp___10 ;
  double *x ;
  void *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
#line 69
  P = T->mip;
#line 70
  n = P->n;
#line 71
  lp = (glp_prob *)((void *)0);
#line 72
  var = (struct VAR *)((void *)0);
#line 73
  rand___0 = (RNG *)((void *)0);
#line 78
  tmp = glp_get_status(P);
  }
#line 78
  if (tmp == 5) {
#line 78
    tmp___0 = 1;
  } else {
    {
#line 78
    _glp_lib_xassert("glp_get_status(P) == GLP_OPT", "/home/wslee/benchmarks/glpk-4.38/src/glpios10.c",
                     78);
#line 78
    tmp___0 = 1;
    }
  }
#line 80
  if ((T->curr)->level == 0) {
#line 80
    if (! (T->solved == 1)) {
#line 80
      goto done;
    }
  } else {
#line 80
    goto done;
  }
#line 82
  nv = 0;
#line 83
  j = 1;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (j <= n)) {
#line 83
      goto while_break;
    }
#line 84
    col = *(P->col + j);
#line 86
    if (col->kind == 1) {
#line 86
      goto __Cont;
    }
#line 88
    if (col->type == 5) {
#line 88
      goto __Cont;
    }
#line 90
    if (col->kind == 2) {
#line 90
      tmp___1 = 1;
    } else {
      {
#line 90
      _glp_lib_xassert("col->kind == GLP_IV", "/home/wslee/benchmarks/glpk-4.38/src/glpios10.c",
                       90);
#line 90
      tmp___1 = 1;
      }
    }
#line 91
    if (col->type == 4) {
#line 91
      if (col->lb == 0.0) {
#line 91
        if (col->ub == 1.0) {
#line 93
          nv ++;
        } else {
#line 91
          goto _L___0;
        }
      } else {
#line 91
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 97
      if ((T->parm)->msg_lev >= 3) {
        {
#line 98
        _glp_lib_xprintf("FPUMP heuristic cannot be applied due to general integer variables\n");
        }
      }
#line 100
      goto done;
    }
    __Cont: /* CIL Label */ 
#line 83
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (nv == 0) {
#line 104
    goto done;
  }
#line 105
  if ((T->parm)->msg_lev >= 3) {
    {
#line 106
    _glp_lib_xprintf("Applying FPUMP heuristic...\n");
    }
  }
  {
#line 108
  tmp___2 = _glp_lib_xcalloc(1 + nv, (int )sizeof(struct VAR ));
#line 108
  var = (struct VAR *)tmp___2;
#line 109
  k = 0;
#line 110
  j = 1;
  }
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if (! (j <= n)) {
#line 110
      goto while_break___0;
    }
#line 111
    col = *(P->col + j);
#line 112
    if (col->kind == 2) {
#line 112
      if (col->type == 4) {
#line 113
        k ++;
#line 113
        (var + k)->j = j;
      }
    }
#line 110
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  if (k == nv) {
#line 115
    tmp___3 = 1;
  } else {
    {
#line 115
    _glp_lib_xassert("k == nv", "/home/wslee/benchmarks/glpk-4.38/src/glpios10.c",
                     115);
#line 115
    tmp___3 = 1;
    }
  }
  {
#line 117
  lp = glp_create_prob();
  }
  more: 
  {
#line 119
  glp_copy_prob(lp, P, 0);
  }
#line 122
  if (P->mip_stat == 2) {
    {
#line 126
    glp_add_rows(lp, 1);
#line 127
    tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 127
    ind = (int *)tmp___4;
#line 128
    tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 128
    val = (double *)tmp___5;
#line 129
    j = 1;
    }
    {
#line 129
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 129
      if (! (j <= n)) {
#line 129
        goto while_break___1;
      }
#line 130
      *(ind + j) = j;
#line 131
      *(val + j) = (*(P->col + j))->coef;
#line 129
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 133
    glp_set_mat_row(lp, lp->m, n, (int const   *)ind, (double const   *)val);
#line 134
    _glp_lib_xfree((void *)ind);
#line 135
    _glp_lib_xfree((void *)val);
    }
#line 140
    if (P->dir == 1) {
      {
#line 141
      tmp___6 = fabs(P->mip_obj);
#line 141
      bnd = P->mip_obj - 0.10 * (1.0 + tmp___6);
      }
#line 142
      if (bnd < P->obj_val) {
#line 142
        bnd = P->obj_val;
      }
      {
#line 143
      glp_set_row_bnds(lp, lp->m, 3, 0.0, bnd - P->c0);
      }
    } else
#line 145
    if (P->dir == 2) {
      {
#line 146
      tmp___7 = fabs(P->mip_obj);
#line 146
      bnd = P->mip_obj + 0.10 * (1.0 + tmp___7);
      }
#line 147
      if (bnd > P->obj_val) {
#line 147
        bnd = P->obj_val;
      }
      {
#line 148
      glp_set_row_bnds(lp, lp->m, 2, bnd - P->c0, 0.0);
      }
    } else
#line 151
    if ((unsigned long )P != (unsigned long )P) {
#line 151
      tmp___8 = 1;
    } else {
      {
#line 151
      _glp_lib_xassert("P != P", "/home/wslee/benchmarks/glpk-4.38/src/glpios10.c",
                       151);
#line 151
      tmp___8 = 1;
      }
    }
  }
#line 154
  npass = 0;
#line 156
  k = 1;
  {
#line 156
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 156
    if (! (k <= nv)) {
#line 156
      goto while_break___2;
    }
#line 157
    (var + k)->x = -1;
#line 156
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  pass: 
#line 159
  npass ++;
#line 160
  if ((T->parm)->msg_lev >= 3) {
    {
#line 161
    _glp_lib_xprintf("Pass %d\n", npass);
    }
  }
#line 164
  dist = 1.7976931348623157e+308;
#line 167
  nfail = 0;
#line 170
  if (npass > 1) {
#line 172
    if ((unsigned long )rand___0 == (unsigned long )((void *)0)) {
      {
#line 173
      rand___0 = _glp_rng_create_rand();
      }
    }
#line 174
    k = 1;
    {
#line 174
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 174
      if (! (k <= nv)) {
#line 174
        goto while_break___3;
      }
      {
#line 175
      j = (var + k)->j;
#line 176
      col = *(lp->col + j);
#line 177
      rho = _glp_rng_uniform(rand___0, - 0.3, 0.7);
      }
#line 178
      if (rho < 0.0) {
#line 178
        rho = 0.0;
      }
      {
#line 179
      temp = fabs((double )(var + k)->x - col->prim);
      }
#line 180
      if (temp + rho > 0.5) {
#line 180
        (var + k)->x = 1 - (var + k)->x;
      }
#line 174
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 182
    goto skip;
  }
  loop: 
#line 186
  stalling = 1;
#line 187
  k = 1;
  {
#line 187
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 187
    if (! (k <= nv)) {
#line 187
      goto while_break___4;
    }
#line 188
    col = *(lp->col + (var + k)->j);
#line 189
    if (col->prim < 0.5) {
#line 191
      new_x = 0;
    } else {
#line 195
      new_x = 1;
    }
#line 197
    if ((var + k)->x != new_x) {
#line 198
      stalling = 0;
#line 199
      (var + k)->x = new_x;
    }
#line 187
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 204
  if (stalling) {
#line 206
    k = 1;
    {
#line 206
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 206
      if (! (k <= nv)) {
#line 206
        goto while_break___5;
      }
      {
#line 207
      col = *(lp->col + (var + k)->j);
#line 208
      (var + k)->d = fabs(col->prim - (double )(var + k)->x);
#line 206
      k ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 211
    qsort((void *)(var + 1), (size_t )nv, (size_t )sizeof(struct VAR ), & fcmp);
#line 213
    k = 1;
    }
    {
#line 213
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 213
      if (! (k <= nv)) {
#line 213
        goto while_break___6;
      }
#line 214
      if (k >= 5) {
#line 214
        if ((var + k)->d < 0.35) {
#line 214
          goto while_break___6;
        } else {
#line 214
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 214
      if (k >= 10) {
#line 214
        goto while_break___6;
      }
#line 215
      (var + k)->x = 1 - (var + k)->x;
#line 213
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  skip: 
#line 219
  if ((T->parm)->tm_lim < 2147483647) {
    {
#line 219
    tmp___9 = _glp_lib_xtime();
#line 219
    tmp___10 = _glp_lib_xdifftime(tmp___9, T->tm_beg);
    }
#line 219
    if ((double )((T->parm)->tm_lim - 1) <= 1000.0 * tmp___10) {
#line 221
      goto done;
    }
  }
#line 224
  lp->dir = 1;
#line 225
  lp->c0 = 0.0;
#line 226
  j = 1;
  {
#line 226
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 226
    if (! (j <= n)) {
#line 226
      goto while_break___7;
    }
#line 227
    (*(lp->col + j))->coef = 0.0;
#line 226
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 228
  k = 1;
  {
#line 228
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 228
    if (! (k <= nv)) {
#line 228
      goto while_break___8;
    }
#line 229
    j = (var + k)->j;
#line 230
    if ((var + k)->x == 0) {
#line 231
      (*(lp->col + j))->coef = 1.0;
    } else {
#line 233
      (*(lp->col + j))->coef = - 1.0;
#line 234
      lp->c0 += 1.0;
    }
#line 228
    k ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 238
  glp_init_smcp(& parm);
  }
#line 239
  if ((T->parm)->msg_lev <= 1) {
#line 240
    parm.msg_lev = (int )(T->parm)->msg_lev;
  } else
#line 241
  if ((T->parm)->msg_lev <= 3) {
#line 242
    parm.msg_lev = 2;
#line 243
    parm.out_dly = 10000;
  }
  {
#line 245
  ret = glp_simplex(lp, (glp_smcp const   *)(& parm));
  }
#line 246
  if (ret != 0) {
#line 247
    if ((T->parm)->msg_lev >= 1) {
      {
#line 248
      _glp_lib_xprintf("Warning: glp_simplex returned %d\n", ret);
      }
    }
#line 249
    goto done;
  }
  {
#line 251
  ret = glp_get_status(lp);
  }
#line 252
  if (ret != 5) {
#line 253
    if ((T->parm)->msg_lev >= 1) {
      {
#line 254
      _glp_lib_xprintf("Warning: glp_get_status returned %d\n", ret);
      }
    }
#line 255
    goto done;
  }
#line 257
  if ((T->parm)->msg_lev >= 4) {
    {
#line 258
    _glp_lib_xprintf("delta = %g\n", lp->obj_val);
    }
  }
#line 261
  tol = 0.3 * (double )(T->parm)->tol_int;
#line 262
  k = 1;
  {
#line 262
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 262
    if (! (k <= nv)) {
#line 262
      goto while_break___9;
    }
#line 263
    col = *(lp->col + (var + k)->j);
#line 264
    if (tol < col->prim) {
#line 264
      if (col->prim < 1.0 - tol) {
#line 264
        goto while_break___9;
      }
    }
#line 262
    k ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 266
  if (k > nv) {
    {
#line 268
    tmp___11 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 268
    x = (double *)tmp___11;
#line 269
    j = 1;
    }
    {
#line 269
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 269
      if (! (j <= n)) {
#line 269
        goto while_break___10;
      }
#line 270
      *(x + j) = (*(lp->col + j))->prim;
#line 271
      if ((*(P->col + j))->kind == 2) {
        {
#line 271
        *(x + j) = floor(*(x + j) + 0.5);
        }
      }
#line 269
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 273
    ret = glp_ios_heur_sol(T, (double const   *)x);
#line 274
    _glp_lib_xfree((void *)x);
    }
#line 275
    if (ret == 0) {
      {
#line 277
      tmp___12 = _glp_ios_is_hopeful(T, (T->curr)->bound);
      }
#line 277
      if (tmp___12) {
#line 279
        goto more;
      } else {
#line 284
        goto done;
      }
    }
  }
#line 289
  if (dist == 1.7976931348623157e+308) {
#line 292
    nfail = 0;
#line 292
    dist = lp->obj_val;
  } else
#line 289
  if (lp->obj_val <= dist - 1e-6 * (1.0 + dist)) {
#line 292
    nfail = 0;
#line 292
    dist = lp->obj_val;
  } else {
#line 296
    nfail ++;
  }
#line 298
  if (nfail < 3) {
#line 298
    goto loop;
  }
#line 299
  if (npass < 5) {
#line 299
    goto pass;
  }
  done: 
#line 301
  if ((unsigned long )lp != (unsigned long )((void *)0)) {
    {
#line 301
    glp_delete_prob(lp);
    }
  }
#line 302
  if ((unsigned long )var != (unsigned long )((void *)0)) {
    {
#line 302
    _glp_lib_xfree((void *)var);
    }
  }
#line 303
  if ((unsigned long )rand___0 != (unsigned long )((void *)0)) {
    {
#line 303
    _glp_rng_delete_rand(rand___0);
    }
  }
#line 304
  return;
}
}
#line 608 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
void _glp_ios_pcost_branch(glp_tree___0 *tree ) ;
#line 612
void _glp_ios_pcost_free(glp_tree___0 *tree ) ;
#line 7 "/home/wslee/benchmarks/glpk-4.38/src/glpios09.c"
void _glp_ios_pcost_branch(glp_tree___0 *tree ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 9
  if ((unsigned long )tree != (unsigned long )tree) {
#line 9
    tmp = 1;
  } else {
    {
#line 9
    _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios09.c",
                     9);
#line 9
    tmp = 1;
    }
  }
#line 10
  return;
}
}
#line 13 "/home/wslee/benchmarks/glpk-4.38/src/glpios09.c"
void _glp_ios_pcost_free(glp_tree___0 *tree ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 15
  if ((unsigned long )tree != (unsigned long )tree) {
#line 15
    tmp = 1;
  } else {
    {
#line 15
    _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios09.c",
                     15);
#line 15
    tmp = 1;
    }
  }
#line 16
  return;
}
}
#line 642 "./../include/glpk.h"
int glp_ios_add_row(glp_tree___0 *tree , char const   *name , int klass , int flags ,
                    int len , int const   *ind , double const   *val , int type ,
                    double rhs ) ;
#line 596 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
void *_glp_ios_clq_init(glp_tree___0 *tree ) ;
#line 600
void _glp_ios_clq_gen(glp_tree___0 *tree , void *gen ) ;
#line 604
void _glp_ios_clq_term(void *gen ) ;
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static double get_row_lb(glp_prob *lp , int i ) 
{ 
  double lb ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 30
  tmp = _glp_lpx_get_row_type(lp, i);
  }
  {
#line 32
  if (tmp == 112) {
#line 32
    goto case_112;
  }
#line 32
  if (tmp == 110) {
#line 32
    goto case_112;
  }
#line 37
  if (tmp == 114) {
#line 37
    goto case_114;
  }
#line 37
  if (tmp == 113) {
#line 37
    goto case_114;
  }
#line 37
  if (tmp == 111) {
#line 37
    goto case_114;
  }
#line 40
  goto switch_default;
  case_112: /* CIL Label */ 
  case_110: /* CIL Label */ 
#line 33
  lb = - 1.7976931348623157e+308;
#line 34
  goto switch_break;
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_111: /* CIL Label */ 
  {
#line 38
  lb = _glp_lpx_get_row_lb(lp, i);
  }
#line 39
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 41
  if ((unsigned long )lp != (unsigned long )lp) {
#line 41
    tmp___0 = 1;
  } else {
    {
#line 41
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     41);
#line 41
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 43
  return (lb);
}
}
#line 46 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static double get_row_ub(glp_prob *lp , int i ) 
{ 
  double ub ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 50
  tmp = _glp_lpx_get_row_type(lp, i);
  }
  {
#line 52
  if (tmp == 111) {
#line 52
    goto case_111;
  }
#line 52
  if (tmp == 110) {
#line 52
    goto case_111;
  }
#line 57
  if (tmp == 114) {
#line 57
    goto case_114;
  }
#line 57
  if (tmp == 113) {
#line 57
    goto case_114;
  }
#line 57
  if (tmp == 112) {
#line 57
    goto case_114;
  }
#line 60
  goto switch_default;
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
#line 53
  ub = 1.7976931348623157e+308;
#line 54
  goto switch_break;
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  {
#line 58
  ub = _glp_lpx_get_row_ub(lp, i);
  }
#line 59
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 61
  if ((unsigned long )lp != (unsigned long )lp) {
#line 61
    tmp___0 = 1;
  } else {
    {
#line 61
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     61);
#line 61
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 63
  return (ub);
}
}
#line 66 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static double get_col_lb(glp_prob *lp , int j ) 
{ 
  double lb ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 70
  tmp = _glp_lpx_get_col_type(lp, j);
  }
  {
#line 72
  if (tmp == 112) {
#line 72
    goto case_112;
  }
#line 72
  if (tmp == 110) {
#line 72
    goto case_112;
  }
#line 77
  if (tmp == 114) {
#line 77
    goto case_114;
  }
#line 77
  if (tmp == 113) {
#line 77
    goto case_114;
  }
#line 77
  if (tmp == 111) {
#line 77
    goto case_114;
  }
#line 80
  goto switch_default;
  case_112: /* CIL Label */ 
  case_110: /* CIL Label */ 
#line 73
  lb = - 1.7976931348623157e+308;
#line 74
  goto switch_break;
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_111: /* CIL Label */ 
  {
#line 78
  lb = _glp_lpx_get_col_lb(lp, j);
  }
#line 79
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 81
  if ((unsigned long )lp != (unsigned long )lp) {
#line 81
    tmp___0 = 1;
  } else {
    {
#line 81
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     81);
#line 81
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 83
  return (lb);
}
}
#line 86 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static double get_col_ub(glp_prob *lp , int j ) 
{ 
  double ub ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 90
  tmp = _glp_lpx_get_col_type(lp, j);
  }
  {
#line 92
  if (tmp == 111) {
#line 92
    goto case_111;
  }
#line 92
  if (tmp == 110) {
#line 92
    goto case_111;
  }
#line 97
  if (tmp == 114) {
#line 97
    goto case_114;
  }
#line 97
  if (tmp == 113) {
#line 97
    goto case_114;
  }
#line 97
  if (tmp == 112) {
#line 97
    goto case_114;
  }
#line 100
  goto switch_default;
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
#line 93
  ub = 1.7976931348623157e+308;
#line 94
  goto switch_break;
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  {
#line 98
  ub = _glp_lpx_get_col_ub(lp, j);
  }
#line 99
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 101
  if ((unsigned long )lp != (unsigned long )lp) {
#line 101
    tmp___0 = 1;
  } else {
    {
#line 101
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     101);
#line 101
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 103
  return (ub);
}
}
#line 106 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static int is_binary(glp_prob *lp , int j ) 
{ 
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;

  {
  {
#line 108
  tmp = _glp_lpx_get_col_kind(lp, j);
  }
#line 108
  if (tmp == 161) {
    {
#line 108
    tmp___0 = _glp_lpx_get_col_type(lp, j);
    }
#line 108
    if (tmp___0 == 113) {
      {
#line 108
      tmp___1 = _glp_lpx_get_col_lb(lp, j);
      }
#line 108
      if (tmp___1 == 0.0) {
        {
#line 108
        tmp___2 = _glp_lpx_get_col_ub(lp, j);
        }
#line 108
        if (tmp___2 == 1.0) {
#line 108
          tmp___3 = 1;
        } else {
#line 108
          tmp___3 = 0;
        }
      } else {
#line 108
        tmp___3 = 0;
      }
    } else {
#line 108
      tmp___3 = 0;
    }
  } else {
#line 108
    tmp___3 = 0;
  }
#line 108
  return (tmp___3);
}
}
#line 114 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static double eval_lf_min(glp_prob *lp , int len , int *ind , double *val ) 
{ 
  int j ;
  int t ;
  double lb ;
  double ub ;
  double sum ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 129
  sum = 0.0;
#line 130
  t = 1;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (t <= len)) {
#line 130
      goto while_break;
    }
#line 131
    j = *(ind + t);
#line 132
    if (*(val + t) > 0.0) {
      {
#line 133
      lb = get_col_lb(lp, j);
      }
#line 134
      if (lb == - 1.7976931348623157e+308) {
#line 135
        sum = - 1.7976931348623157e+308;
#line 136
        goto while_break;
      }
#line 138
      sum += *(val + t) * lb;
    } else
#line 140
    if (*(val + t) < 0.0) {
      {
#line 141
      ub = get_col_ub(lp, j);
      }
#line 142
      if (ub == 1.7976931348623157e+308) {
#line 143
        sum = - 1.7976931348623157e+308;
#line 144
        goto while_break;
      }
#line 146
      sum += *(val + t) * ub;
    } else
#line 149
    if ((unsigned long )val != (unsigned long )val) {
#line 149
      tmp = 1;
    } else {
      {
#line 149
      _glp_lib_xassert("val != val", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       149);
#line 149
      tmp = 1;
      }
    }
#line 130
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (sum);
}
}
#line 154 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static double eval_lf_max(glp_prob *lp , int len , int *ind , double *val ) 
{ 
  int j ;
  int t ;
  double lb ;
  double ub ;
  double sum ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 169
  sum = 0.0;
#line 170
  t = 1;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (t <= len)) {
#line 170
      goto while_break;
    }
#line 171
    j = *(ind + t);
#line 172
    if (*(val + t) > 0.0) {
      {
#line 173
      ub = get_col_ub(lp, j);
      }
#line 174
      if (ub == 1.7976931348623157e+308) {
#line 175
        sum = 1.7976931348623157e+308;
#line 176
        goto while_break;
      }
#line 178
      sum += *(val + t) * ub;
    } else
#line 180
    if (*(val + t) < 0.0) {
      {
#line 181
      lb = get_col_lb(lp, j);
      }
#line 182
      if (lb == - 1.7976931348623157e+308) {
#line 183
        sum = 1.7976931348623157e+308;
#line 184
        goto while_break;
      }
#line 186
      sum += *(val + t) * lb;
    } else
#line 189
    if ((unsigned long )val != (unsigned long )val) {
#line 189
      tmp = 1;
    } else {
      {
#line 189
      _glp_lib_xassert("val != val", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       189);
#line 189
      tmp = 1;
      }
    }
#line 170
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (sum);
}
}
#line 265 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static int probing(int len , double *val , double L , double U , double lf_min , double lf_max ,
                   int p , int set___0 , int q ) 
{ 
  double temp ;
  int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 268
  if (1 <= p) {
#line 268
    if (p < q) {
#line 268
      if (q <= len) {
#line 268
        tmp = 1;
      } else {
        {
#line 268
        _glp_lib_xassert("1 <= p && p < q && q <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                         268);
#line 268
        tmp = 1;
        }
      }
    } else {
      {
#line 268
      _glp_lib_xassert("1 <= p && p < q && q <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       268);
#line 268
      tmp = 1;
      }
    }
  } else {
    {
#line 268
    _glp_lib_xassert("1 <= p && p < q && q <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     268);
#line 268
    tmp = 1;
    }
  }
#line 270
  if (L != - 1.7976931348623157e+308) {
#line 270
    if (set___0) {
#line 270
      L -= *(val + p);
    }
  }
#line 272
  if (U != 1.7976931348623157e+308) {
#line 272
    if (set___0) {
#line 272
      U -= *(val + p);
    }
  }
#line 274
  if (lf_min != - 1.7976931348623157e+308) {
#line 275
    if (*(val + p) < 0.0) {
#line 275
      lf_min -= *(val + p);
    }
#line 276
    if (*(val + q) < 0.0) {
#line 276
      lf_min -= *(val + q);
    }
  }
#line 279
  if (lf_max != 1.7976931348623157e+308) {
#line 280
    if (*(val + p) > 0.0) {
#line 280
      lf_max -= *(val + p);
    }
#line 281
    if (*(val + q) > 0.0) {
#line 281
      lf_max -= *(val + q);
    }
  }
#line 284
  if (*(val + q) > 0.0) {
#line 285
    if (L == - 1.7976931348623157e+308) {
#line 286
      temp = - 1.7976931348623157e+308;
    } else
#line 285
    if (lf_max == 1.7976931348623157e+308) {
#line 286
      temp = - 1.7976931348623157e+308;
    } else {
#line 288
      temp = (L - lf_max) / *(val + q);
    }
  } else
#line 291
  if (U == 1.7976931348623157e+308) {
#line 292
    temp = - 1.7976931348623157e+308;
  } else
#line 291
  if (lf_min == - 1.7976931348623157e+308) {
#line 292
    temp = - 1.7976931348623157e+308;
  } else {
#line 294
    temp = (U - lf_min) / *(val + q);
  }
#line 296
  if (temp > 0.001) {
#line 296
    return (2);
  }
#line 298
  if (*(val + q) > 0.0) {
#line 299
    if (U == 1.7976931348623157e+308) {
#line 300
      temp = 1.7976931348623157e+308;
    } else
#line 299
    if (lf_min == - 1.7976931348623157e+308) {
#line 300
      temp = 1.7976931348623157e+308;
    } else {
#line 302
      temp = (U - lf_min) / *(val + q);
    }
  } else
#line 305
  if (L == - 1.7976931348623157e+308) {
#line 306
    temp = 1.7976931348623157e+308;
  } else
#line 305
  if (lf_max == 1.7976931348623157e+308) {
#line 306
    temp = 1.7976931348623157e+308;
  } else {
#line 308
    temp = (L - lf_max) / *(val + q);
  }
#line 310
  if (temp < 0.999) {
#line 310
    return (1);
  }
#line 312
  return (0);
}
}
#line 363
static void lpx_add_cog_edge(void *_cog , int i , int j ) ;
#line 365 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static void *lpx_create_cog(glp_prob *lp ) 
{ 
  struct COG *cog ;
  int m ;
  int n ;
  int nb ;
  int i ;
  int j ;
  int p ;
  int q ;
  int len ;
  int *ind ;
  int *vert ;
  int *orig ;
  double L ;
  double U ;
  double lf_min ;
  double lf_max ;
  double *val ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 366
  cog = (struct COG *)((void *)0);
#line 369
  _glp_lib_xprintf("Creating the conflict graph...\n");
#line 370
  m = _glp_lpx_get_num_rows(lp);
#line 371
  n = _glp_lpx_get_num_cols(lp);
#line 374
  nb = 0;
#line 375
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 375
  vert = (int *)tmp;
#line 376
  j = 1;
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (j <= n)) {
#line 376
      goto while_break;
    }
#line 376
    *(vert + j) = 0;
#line 376
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 377
  orig = (int *)tmp___0;
#line 378
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 378
  ind = (int *)tmp___1;
#line 379
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 379
  val = (double *)tmp___2;
#line 380
  i = 1;
  }
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 380
    if (! (i <= m)) {
#line 380
      goto while_break___0;
    }
    {
#line 381
    L = get_row_lb(lp, i);
#line 382
    U = get_row_ub(lp, i);
    }
#line 383
    if (L == - 1.7976931348623157e+308) {
#line 383
      if (U == 1.7976931348623157e+308) {
#line 383
        goto __Cont;
      }
    }
    {
#line 384
    len = _glp_lpx_get_mat_row(lp, i, ind, val);
    }
#line 385
    if (len > 500) {
#line 385
      goto __Cont;
    }
    {
#line 386
    lf_min = eval_lf_min(lp, len, ind, val);
#line 387
    lf_max = eval_lf_max(lp, len, ind, val);
#line 388
    p = 1;
    }
    {
#line 388
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 388
      if (! (p <= len)) {
#line 388
        goto while_break___1;
      }
      {
#line 389
      tmp___3 = is_binary(lp, *(ind + p));
      }
#line 389
      if (! tmp___3) {
#line 389
        goto __Cont___0;
      }
#line 390
      q = p + 1;
      {
#line 390
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 390
        if (! (q <= len)) {
#line 390
          goto while_break___2;
        }
        {
#line 391
        tmp___4 = is_binary(lp, *(ind + q));
        }
#line 391
        if (! tmp___4) {
#line 391
          goto __Cont___1;
        }
        {
#line 392
        tmp___5 = probing(len, val, L, U, lf_min, lf_max, p, 0, q);
        }
#line 392
        if (tmp___5) {
#line 392
          goto _L;
        } else {
          {
#line 392
          tmp___6 = probing(len, val, L, U, lf_min, lf_max, p, 1, q);
          }
#line 392
          if (tmp___6) {
            _L: /* CIL Label */ 
#line 396
            j = *(ind + p);
#line 397
            if (*(vert + j) == 0) {
#line 397
              nb ++;
#line 397
              *(vert + j) = nb;
#line 397
              *(orig + nb) = j;
            }
#line 399
            j = *(ind + q);
#line 400
            if (*(vert + j) == 0) {
#line 400
              nb ++;
#line 400
              *(vert + j) = nb;
#line 400
              *(orig + nb) = j;
            }
          }
        }
        __Cont___1: /* CIL Label */ 
#line 390
        q ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 388
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 380
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  if (nb == 0) {
    {
#line 408
    _glp_lib_xprintf("The conflict graph is either empty or too big\n");
#line 409
    _glp_lib_xfree((void *)vert);
#line 410
    _glp_lib_xfree((void *)orig);
    }
#line 411
    goto done;
  } else
#line 407
  if (nb > 4000) {
    {
#line 408
    _glp_lib_xprintf("The conflict graph is either empty or too big\n");
#line 409
    _glp_lib_xfree((void *)vert);
#line 410
    _glp_lib_xfree((void *)orig);
    }
#line 411
    goto done;
  }
  {
#line 414
  tmp___7 = _glp_lib_xmalloc((int )sizeof(struct COG ));
#line 414
  cog = (struct COG *)tmp___7;
#line 415
  cog->n = n;
#line 416
  cog->nb = nb;
#line 417
  cog->ne = 0;
#line 418
  cog->vert = vert;
#line 419
  cog->orig = orig;
#line 420
  len = nb + nb;
#line 421
  len = (len * (len - 1)) / 2;
#line 422
  len = (len + 7) / 8;
#line 423
  tmp___8 = _glp_lib_xmalloc(len);
#line 423
  cog->a = (unsigned char *)tmp___8;
#line 424
  memset((void *)cog->a, 0, (size_t )len);
#line 425
  j = 1;
  }
  {
#line 425
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 425
    if (! (j <= nb)) {
#line 425
      goto while_break___3;
    }
    {
#line 427
    lpx_add_cog_edge((void *)cog, *(orig + j), - *(orig + j));
#line 425
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 429
  i = 1;
  {
#line 429
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 429
    if (! (i <= m)) {
#line 429
      goto while_break___4;
    }
    {
#line 430
    L = get_row_lb(lp, i);
#line 431
    U = get_row_ub(lp, i);
    }
#line 432
    if (L == - 1.7976931348623157e+308) {
#line 432
      if (U == 1.7976931348623157e+308) {
#line 432
        goto __Cont___2;
      }
    }
    {
#line 433
    len = _glp_lpx_get_mat_row(lp, i, ind, val);
    }
#line 434
    if (len > 500) {
#line 434
      goto __Cont___2;
    }
    {
#line 435
    lf_min = eval_lf_min(lp, len, ind, val);
#line 436
    lf_max = eval_lf_max(lp, len, ind, val);
#line 437
    p = 1;
    }
    {
#line 437
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 437
      if (! (p <= len)) {
#line 437
        goto while_break___5;
      }
      {
#line 438
      tmp___9 = is_binary(lp, *(ind + p));
      }
#line 438
      if (! tmp___9) {
#line 438
        goto __Cont___3;
      }
#line 439
      q = p + 1;
      {
#line 439
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 439
        if (! (q <= len)) {
#line 439
          goto while_break___6;
        }
        {
#line 440
        tmp___10 = is_binary(lp, *(ind + q));
        }
#line 440
        if (! tmp___10) {
#line 440
          goto __Cont___4;
        }
        {
#line 442
        tmp___11 = probing(len, val, L, U, lf_min, lf_max, p, 0, q);
        }
        {
#line 443
        if (tmp___11 == 0) {
#line 443
          goto case_0;
        }
#line 446
        if (tmp___11 == 1) {
#line 446
          goto case_1;
        }
#line 450
        if (tmp___11 == 2) {
#line 450
          goto case_2;
        }
#line 454
        goto switch_default;
        case_0: /* CIL Label */ 
#line 445
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 448
        lpx_add_cog_edge((void *)cog, - *(ind + p), *(ind + q));
        }
#line 449
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 452
        lpx_add_cog_edge((void *)cog, - *(ind + p), - *(ind + q));
        }
#line 453
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 455
        if ((unsigned long )lp != (unsigned long )lp) {
#line 455
          tmp___12 = 1;
        } else {
          {
#line 455
          _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                           455);
#line 455
          tmp___12 = 1;
          }
        }
        switch_break: /* CIL Label */ ;
        }
        {
#line 458
        tmp___13 = probing(len, val, L, U, lf_min, lf_max, p, 1, q);
        }
        {
#line 459
        if (tmp___13 == 0) {
#line 459
          goto case_0___0;
        }
#line 462
        if (tmp___13 == 1) {
#line 462
          goto case_1___0;
        }
#line 466
        if (tmp___13 == 2) {
#line 466
          goto case_2___0;
        }
#line 470
        goto switch_default___0;
        case_0___0: /* CIL Label */ 
#line 461
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
        {
#line 464
        lpx_add_cog_edge((void *)cog, *(ind + p), *(ind + q));
        }
#line 465
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 468
        lpx_add_cog_edge((void *)cog, *(ind + p), - *(ind + q));
        }
#line 469
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 471
        if ((unsigned long )lp != (unsigned long )lp) {
#line 471
          tmp___14 = 1;
        } else {
          {
#line 471
          _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                           471);
#line 471
          tmp___14 = 1;
          }
        }
        switch_break___0: /* CIL Label */ ;
        }
        __Cont___4: /* CIL Label */ 
#line 439
        q ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      __Cont___3: /* CIL Label */ 
#line 437
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    __Cont___2: /* CIL Label */ 
#line 429
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 476
  _glp_lib_xprintf("The conflict graph has 2*%d vertices and %d edges\n", cog->nb,
                   cog->ne);
  }
  done: 
  {
#line 478
  _glp_lib_xfree((void *)ind);
#line 479
  _glp_lib_xfree((void *)val);
  }
#line 480
  return ((void *)cog);
}
}
#line 498 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static void lpx_add_cog_edge(void *_cog , int i , int j ) 
{ 
  struct COG *cog ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 499
  cog = (struct COG *)_cog;
#line 501
  if (i != j) {
#line 501
    tmp = 1;
  } else {
    {
#line 501
    _glp_lib_xassert("i != j", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     501);
#line 501
    tmp = 1;
    }
  }
#line 503
  if (i > 0) {
#line 504
    if (1 <= i) {
#line 504
      if (i <= cog->n) {
#line 504
        tmp___0 = 1;
      } else {
        {
#line 504
        _glp_lib_xassert("1 <= i && i <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                         504);
#line 504
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 504
      _glp_lib_xassert("1 <= i && i <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       504);
#line 504
      tmp___0 = 1;
      }
    }
#line 505
    i = *(cog->vert + i);
#line 506
    if (i != 0) {
#line 506
      tmp___1 = 1;
    } else {
      {
#line 506
      _glp_lib_xassert("i != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       506);
#line 506
      tmp___1 = 1;
      }
    }
  } else {
#line 509
    i = - i;
#line 510
    if (1 <= i) {
#line 510
      if (i <= cog->n) {
#line 510
        tmp___2 = 1;
      } else {
        {
#line 510
        _glp_lib_xassert("1 <= i && i <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                         510);
#line 510
        tmp___2 = 1;
        }
      }
    } else {
      {
#line 510
      _glp_lib_xassert("1 <= i && i <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       510);
#line 510
      tmp___2 = 1;
      }
    }
#line 511
    i = *(cog->vert + i);
#line 512
    if (i != 0) {
#line 512
      tmp___3 = 1;
    } else {
      {
#line 512
      _glp_lib_xassert("i != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       512);
#line 512
      tmp___3 = 1;
      }
    }
#line 513
    i += cog->nb;
  }
#line 515
  if (j > 0) {
#line 516
    if (1 <= j) {
#line 516
      if (j <= cog->n) {
#line 516
        tmp___4 = 1;
      } else {
        {
#line 516
        _glp_lib_xassert("1 <= j && j <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                         516);
#line 516
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 516
      _glp_lib_xassert("1 <= j && j <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       516);
#line 516
      tmp___4 = 1;
      }
    }
#line 517
    j = *(cog->vert + j);
#line 518
    if (j != 0) {
#line 518
      tmp___5 = 1;
    } else {
      {
#line 518
      _glp_lib_xassert("j != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       518);
#line 518
      tmp___5 = 1;
      }
    }
  } else {
#line 521
    j = - j;
#line 522
    if (1 <= j) {
#line 522
      if (j <= cog->n) {
#line 522
        tmp___6 = 1;
      } else {
        {
#line 522
        _glp_lib_xassert("1 <= j && j <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                         522);
#line 522
        tmp___6 = 1;
        }
      }
    } else {
      {
#line 522
      _glp_lib_xassert("1 <= j && j <= cog->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       522);
#line 522
      tmp___6 = 1;
      }
    }
#line 523
    j = *(cog->vert + j);
#line 524
    if (j != 0) {
#line 524
      tmp___7 = 1;
    } else {
      {
#line 524
      _glp_lib_xassert("j != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       524);
#line 524
      tmp___7 = 1;
      }
    }
#line 525
    j += cog->nb;
  }
#line 528
  if (i < j) {
#line 528
    k = i;
#line 528
    i = j;
#line 528
    j = k;
  }
#line 529
  k = ((i - 1) * (i - 2)) / 2 + (j - 1);
#line 530
  *(cog->a + k / 8) = (unsigned char )((int )*(cog->a + k / 8) | (int )((unsigned char )(1 << (7 - k % 8))));
#line 532
  (cog->ne) ++;
#line 533
  return;
}
}
#line 601 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static void sub___0(struct dsa___1 *dsa , int ct , int *table , int level , int weight ,
                    int l_weight ) 
{ 
  int i ;
  int j ;
  int k ;
  int curr_weight ;
  int left_weight ;
  int *p1 ;
  int *p2 ;
  int *newtable ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 604
  tmp = _glp_lib_xcalloc(dsa->n, (int )sizeof(int ));
#line 604
  newtable = (int *)tmp;
  }
#line 605
  if (ct <= 0) {
#line 607
    if (ct == 0) {
#line 608
      tmp___0 = level;
#line 608
      level ++;
#line 608
      *(dsa->set + tmp___0) = *(table + 0);
#line 609
      weight += l_weight;
    }
#line 611
    if (weight > dsa->record) {
#line 612
      dsa->record = weight;
#line 613
      dsa->rec_level = level;
#line 614
      i = 0;
      {
#line 614
      while (1) {
        while_continue: /* CIL Label */ ;
#line 614
        if (! (i < level)) {
#line 614
          goto while_break;
        }
#line 614
        *(dsa->rec + i) = *(dsa->set + i);
#line 614
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 616
    goto done;
  }
#line 618
  i = ct;
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 618
    if (! (i >= 0)) {
#line 618
      goto while_break___0;
    }
#line 619
    if (level == 0) {
#line 619
      if (i < ct) {
#line 619
        goto done;
      }
    }
#line 620
    k = *(table + i);
#line 621
    if (level > 0) {
#line 621
      if (*(dsa->clique + k) <= dsa->record - weight) {
#line 622
        goto done;
      }
    }
#line 623
    *(dsa->set + level) = k;
#line 624
    curr_weight = weight + *(dsa->wt + k);
#line 625
    l_weight -= *(dsa->wt + k);
#line 626
    if (l_weight <= dsa->record - curr_weight) {
#line 627
      goto done;
    }
#line 628
    p1 = newtable;
#line 629
    p2 = table;
#line 630
    left_weight = 0;
    {
#line 631
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 631
      if (! ((unsigned long )p2 < (unsigned long )(table + i))) {
#line 631
        goto while_break___1;
      }
#line 632
      tmp___1 = p2;
#line 632
      p2 ++;
#line 632
      j = *tmp___1;
#line 633
      if (j == k) {
#line 633
        tmp___4 = 0;
      } else {
#line 633
        if (j > k) {
#line 633
          tmp___3 = (int )*(dsa->a + ((j * (j - 1)) / 2 + k) / 8) & (int )((unsigned char )(1 << (7 - ((j * (j - 1)) / 2 + k) % 8)));
        } else {
#line 633
          tmp___3 = (int )*(dsa->a + ((k * (k - 1)) / 2 + j) / 8) & (int )((unsigned char )(1 << (7 - ((k * (k - 1)) / 2 + j) % 8)));
        }
#line 633
        tmp___4 = tmp___3;
      }
#line 633
      if (tmp___4) {
#line 634
        tmp___2 = p1;
#line 634
        p1 ++;
#line 634
        *tmp___2 = j;
#line 635
        left_weight += *(dsa->wt + j);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 638
    if (left_weight <= dsa->record - curr_weight) {
#line 638
      goto __Cont;
    }
    {
#line 639
    sub___0(dsa, (int )((p1 - newtable) - 1L), newtable, level + 1, curr_weight, left_weight);
    }
    __Cont: /* CIL Label */ 
#line 618
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
  {
#line 642
  _glp_lib_xfree((void *)newtable);
  }
#line 643
  return;
}
}
#line 646 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static int wclique___0(int _n , int *w , unsigned char *_a , int *sol ) 
{ 
  struct dsa___1 _dsa ;
  struct dsa___1 *dsa ;
  int i ;
  int j ;
  int p ;
  int max_wt ;
  int max_nwt ;
  int wth ;
  int *used ;
  int *nwt ;
  int *pos ;
  xlong_t timer ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  xlong_t tmp___8 ;
  double tmp___9 ;
  char *__cil_tmp28 ;

  {
  {
#line 647
  dsa = & _dsa;
#line 650
  dsa->n = _n;
#line 651
  dsa->wt = w + 1;
#line 652
  dsa->a = _a;
#line 653
  dsa->record = 0;
#line 654
  dsa->rec_level = 0;
#line 655
  dsa->rec = sol + 1;
#line 656
  tmp = _glp_lib_xcalloc(dsa->n, (int )sizeof(int ));
#line 656
  dsa->clique = (int *)tmp;
#line 657
  tmp___0 = _glp_lib_xcalloc(dsa->n, (int )sizeof(int ));
#line 657
  dsa->set = (int *)tmp___0;
#line 658
  tmp___1 = _glp_lib_xcalloc(dsa->n, (int )sizeof(int ));
#line 658
  used = (int *)tmp___1;
#line 659
  tmp___2 = _glp_lib_xcalloc(dsa->n, (int )sizeof(int ));
#line 659
  nwt = (int *)tmp___2;
#line 660
  tmp___3 = _glp_lib_xcalloc(dsa->n, (int )sizeof(int ));
#line 660
  pos = (int *)tmp___3;
#line 662
  timer = _glp_lib_xtime();
#line 664
  i = 0;
  }
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! (i < dsa->n)) {
#line 664
      goto while_break;
    }
#line 665
    *(nwt + i) = 0;
#line 666
    j = 0;
    {
#line 666
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 666
      if (! (j < dsa->n)) {
#line 666
        goto while_break___0;
      }
#line 667
      if (i == j) {
#line 667
        tmp___5 = 0;
      } else {
#line 667
        if (i > j) {
#line 667
          tmp___4 = (int )*(dsa->a + ((i * (i - 1)) / 2 + j) / 8) & (int )((unsigned char )(1 << (7 - ((i * (i - 1)) / 2 + j) % 8)));
        } else {
#line 667
          tmp___4 = (int )*(dsa->a + ((j * (j - 1)) / 2 + i) / 8) & (int )((unsigned char )(1 << (7 - ((j * (j - 1)) / 2 + i) % 8)));
        }
#line 667
        tmp___5 = tmp___4;
      }
#line 667
      if (tmp___5) {
#line 667
        *(nwt + i) += *(dsa->wt + j);
      }
#line 666
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 664
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 669
  i = 0;
  {
#line 669
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 669
    if (! (i < dsa->n)) {
#line 669
      goto while_break___1;
    }
#line 670
    *(used + i) = 0;
#line 669
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 671
  i = dsa->n - 1;
  {
#line 671
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 671
    if (! (i >= 0)) {
#line 671
      goto while_break___2;
    }
#line 672
    max_wt = -1;
#line 673
    max_nwt = -1;
#line 674
    j = 0;
    {
#line 674
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 674
      if (! (j < dsa->n)) {
#line 674
        goto while_break___3;
      }
#line 675
      if (! *(used + j)) {
#line 675
        if (*(dsa->wt + j) > max_wt) {
#line 677
          max_wt = *(dsa->wt + j);
#line 678
          max_nwt = *(nwt + j);
#line 679
          p = j;
        } else
#line 675
        if (*(dsa->wt + j) == max_wt) {
#line 675
          if (*(nwt + j) > max_nwt) {
#line 677
            max_wt = *(dsa->wt + j);
#line 678
            max_nwt = *(nwt + j);
#line 679
            p = j;
          }
        }
      }
#line 674
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 682
    *(pos + i) = p;
#line 683
    *(used + p) = 1;
#line 684
    j = 0;
    {
#line 684
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 684
      if (! (j < dsa->n)) {
#line 684
        goto while_break___4;
      }
#line 685
      if (! *(used + j)) {
#line 685
        if (j != p) {
#line 685
          if (p == j) {
#line 685
            tmp___7 = 0;
          } else {
#line 685
            if (p > j) {
#line 685
              tmp___6 = (int )*(dsa->a + ((p * (p - 1)) / 2 + j) / 8) & (int )((unsigned char )(1 << (7 - ((p * (p - 1)) / 2 + j) % 8)));
            } else {
#line 685
              tmp___6 = (int )*(dsa->a + ((j * (j - 1)) / 2 + p) / 8) & (int )((unsigned char )(1 << (7 - ((j * (j - 1)) / 2 + p) % 8)));
            }
#line 685
            tmp___7 = tmp___6;
          }
#line 685
          if (tmp___7) {
#line 686
            *(nwt + j) -= *(dsa->wt + p);
          }
        }
      }
#line 684
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 671
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 689
  wth = 0;
#line 690
  i = 0;
  {
#line 690
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 690
    if (! (i < dsa->n)) {
#line 690
      goto while_break___5;
    }
    {
#line 691
    wth += *(dsa->wt + *(pos + i));
#line 692
    sub___0(dsa, i, pos, 0, 0, wth);
#line 693
    *(dsa->clique + *(pos + i)) = dsa->record;
#line 697
    tmp___8 = _glp_lib_xtime();
#line 697
    tmp___9 = _glp_lib_xdifftime(tmp___8, timer);
    }
#line 697
    if (tmp___9 >= 5.0 - 0.001) {
      {
#line 700
      _glp_lib_xprintf("level = %d (%d); best = %d\n", i + 1, dsa->n, dsa->record);
#line 704
      timer = _glp_lib_xtime();
      }
    }
#line 690
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 708
  _glp_lib_xfree((void *)dsa->clique);
#line 709
  _glp_lib_xfree((void *)dsa->set);
#line 710
  _glp_lib_xfree((void *)used);
#line 711
  _glp_lib_xfree((void *)nwt);
#line 712
  _glp_lib_xfree((void *)pos);
#line 714
  i = 1;
  }
  {
#line 714
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 714
    if (! (i <= dsa->rec_level)) {
#line 714
      goto while_break___6;
    }
#line 714
    (*(sol + i)) ++;
#line 714
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 715
  return (dsa->rec_level);
}
}
#line 755 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static int lpx_clique_cut(glp_prob *lp , void *_cog , int *ind , double *val ) 
{ 
  struct COG *cog ;
  int n ;
  int tmp ;
  int j ;
  int t ;
  int v ;
  int card ;
  int temp ;
  int len ;
  int *w ;
  int *sol ;
  double x ;
  double sum ;
  double b ;
  double *vec ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 756
  cog = (struct COG *)_cog;
#line 757
  tmp = _glp_lpx_get_num_cols(lp);
#line 757
  n = tmp;
#line 758
  len = 0;
#line 761
  tmp___0 = _glp_lib_xcalloc(1 + 2 * cog->nb, (int )sizeof(int ));
#line 761
  w = (int *)tmp___0;
#line 762
  tmp___1 = _glp_lib_xcalloc(1 + 2 * cog->nb, (int )sizeof(int ));
#line 762
  sol = (int *)tmp___1;
#line 763
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 763
  vec = (double *)tmp___2;
#line 765
  t = 1;
  }
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! (t <= cog->nb)) {
#line 765
      goto while_break;
    }
    {
#line 766
    j = *(cog->orig + t);
#line 767
    x = _glp_lpx_get_col_prim(lp, j);
#line 768
    temp = (int )(100.0 * x + 0.5);
    }
#line 769
    if (temp < 0) {
#line 769
      temp = 0;
    }
#line 770
    if (temp > 100) {
#line 770
      temp = 100;
    }
#line 771
    *(w + t) = temp;
#line 772
    *(w + (cog->nb + t)) = 100 - temp;
#line 765
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 775
  card = wclique___0(2 * cog->nb, w, cog->a, sol);
#line 777
  sum = 0.0;
#line 778
  t = 1;
  }
  {
#line 778
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 778
    if (! (t <= card)) {
#line 778
      goto while_break___0;
    }
#line 779
    v = *(sol + t);
#line 780
    if (1 <= v) {
#line 780
      if (v <= 2 * cog->nb) {
#line 780
        tmp___3 = 1;
      } else {
        {
#line 780
        _glp_lib_xassert("1 <= v && v <= 2 * cog->nb", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                         780);
#line 780
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 780
      _glp_lib_xassert("1 <= v && v <= 2 * cog->nb", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       780);
#line 780
      tmp___3 = 1;
      }
    }
#line 781
    if (v <= cog->nb) {
      {
#line 783
      j = *(cog->orig + v);
#line 784
      x = _glp_lpx_get_col_prim(lp, j);
#line 785
      sum += x;
      }
    } else {
      {
#line 789
      j = *(cog->orig + (v - cog->nb));
#line 790
      x = _glp_lpx_get_col_prim(lp, j);
#line 791
      sum += 1.0 - x;
      }
    }
#line 778
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 796
  if (sum >= 1.01) {
#line 798
    j = 1;
    {
#line 798
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 798
      if (! (j <= n)) {
#line 798
        goto while_break___1;
      }
#line 798
      *(vec + j) = (double )0;
#line 798
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 799
    b = 1.0;
#line 800
    t = 1;
    {
#line 800
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 800
      if (! (t <= card)) {
#line 800
        goto while_break___2;
      }
#line 801
      v = *(sol + t);
#line 802
      if (v <= cog->nb) {
#line 804
        j = *(cog->orig + v);
#line 805
        if (1 <= j) {
#line 805
          if (j <= n) {
#line 805
            tmp___4 = 1;
          } else {
            {
#line 805
            _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                             805);
#line 805
            tmp___4 = 1;
            }
          }
        } else {
          {
#line 805
          _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                           805);
#line 805
          tmp___4 = 1;
          }
        }
#line 806
        *(vec + j) += 1.0;
      } else {
#line 810
        j = *(cog->orig + (v - cog->nb));
#line 811
        if (1 <= j) {
#line 811
          if (j <= n) {
#line 811
            tmp___5 = 1;
          } else {
            {
#line 811
            _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                             811);
#line 811
            tmp___5 = 1;
            }
          }
        } else {
          {
#line 811
          _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                           811);
#line 811
          tmp___5 = 1;
          }
        }
#line 812
        *(vec + j) -= 1.0;
#line 813
        b -= 1.0;
      }
#line 800
      t ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 816
    if (len == 0) {
#line 816
      tmp___6 = 1;
    } else {
      {
#line 816
      _glp_lib_xassert("len == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                       816);
#line 816
      tmp___6 = 1;
      }
    }
#line 817
    j = 1;
    {
#line 817
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 817
      if (! (j <= n)) {
#line 817
        goto while_break___3;
      }
#line 818
      if (*(vec + j) != 0.0) {
#line 819
        len ++;
#line 820
        *(ind + len) = j;
#line 820
        *(val + len) = *(vec + j);
      }
#line 817
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 823
    *(ind + 0) = 0;
#line 823
    *(val + 0) = b;
  }
  {
#line 826
  _glp_lib_xfree((void *)w);
#line 827
  _glp_lib_xfree((void *)sol);
#line 828
  _glp_lib_xfree((void *)vec);
  }
#line 830
  return (len);
}
}
#line 847 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
static void lpx_delete_cog(void *_cog ) 
{ 
  struct COG *cog ;

  {
  {
#line 848
  cog = (struct COG *)_cog;
#line 849
  _glp_lib_xfree((void *)cog->vert);
#line 850
  _glp_lib_xfree((void *)cog->orig);
#line 851
  _glp_lib_xfree((void *)cog->a);
#line 852
  _glp_lib_xfree((void *)cog);
  }
#line 853
  return;
}
}
#line 857 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
void *_glp_ios_clq_init(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 859
  mip = tree->mip;
#line 860
  if ((unsigned long )mip != (unsigned long )((void *)0)) {
#line 860
    tmp = 1;
  } else {
    {
#line 860
    _glp_lib_xassert("mip != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     860);
#line 860
    tmp = 1;
    }
  }
  {
#line 861
  tmp___0 = lpx_create_cog(mip);
  }
#line 861
  return (tmp___0);
}
}
#line 879 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
void _glp_ios_clq_gen(glp_tree___0 *tree , void *gen ) 
{ 
  int n ;
  int tmp ;
  int len ;
  int *ind ;
  double *val ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 880
  tmp = _glp_lpx_get_num_cols(tree->mip);
#line 880
  n = tmp;
  }
#line 883
  if ((unsigned long )gen != (unsigned long )((void *)0)) {
#line 883
    tmp___0 = 1;
  } else {
    {
#line 883
    _glp_lib_xassert("gen != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     883);
#line 883
    tmp___0 = 1;
    }
  }
  {
#line 884
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 884
  ind = (int *)tmp___1;
#line 885
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 885
  val = (double *)tmp___2;
#line 886
  len = lpx_clique_cut(tree->mip, gen, ind, val);
  }
#line 887
  if (len > 0) {
    {
#line 889
    glp_ios_add_row(tree, (char const   *)((void *)0), 4, 0, len, (int const   *)ind,
                    (double const   *)val, 3, *(val + 0));
    }
  }
  {
#line 892
  _glp_lib_xfree((void *)ind);
#line 893
  _glp_lib_xfree((void *)val);
  }
#line 894
  return;
}
}
#line 899 "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c"
void _glp_ios_clq_term(void *gen ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 901
  if ((unsigned long )gen != (unsigned long )((void *)0)) {
#line 901
    tmp = 1;
  } else {
    {
#line 901
    _glp_lib_xassert("gen != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios08.c",
                     901);
#line 901
    tmp = 1;
    }
  }
  {
#line 902
  lpx_delete_cog(gen);
  }
#line 903
  return;
}
}
#line 592 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
void _glp_ios_cov_gen(glp_tree___0 *tree ) ;
#line 140 "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c"
static int cover2(int n , double *a , double b , double u , double *x , double y ,
                  int *cov , double *_alfa , double *_beta ) 
{ 
  int i ;
  int j ;
  int try ;
  int ret ;
  double eps ;
  double alfa ;
  double beta ;
  double temp ;
  double rmax ;
  double tmp ;

  {
  {
#line 143
  try = 0;
#line 143
  ret = 0;
#line 144
  rmax = 0.001;
#line 145
  tmp = fabs(b);
#line 145
  eps = 0.001 * (1.0 + tmp);
#line 146
  i = 1;
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i <= n)) {
#line 146
      goto while_break;
    }
#line 147
    j = i + 1;
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 147
      if (! (j <= n)) {
#line 147
        goto while_break___0;
      }
#line 149
      try ++;
#line 150
      if (try > 1000) {
#line 150
        goto done;
      }
#line 152
      if ((*(a + i) + *(a + j)) + y > b + eps) {
#line 154
        temp = (*(a + i) + *(a + j)) - b;
#line 155
        alfa = 1.0 / (temp + u);
#line 156
        beta = 2.0 - alfa * temp;
#line 158
        temp = ((*(x + i) + *(x + j)) + alfa * y) - beta;
#line 160
        if (rmax < temp) {
#line 161
          rmax = temp;
#line 162
          *(cov + 1) = i;
#line 163
          *(cov + 2) = j;
#line 164
          *_alfa = alfa;
#line 165
          *_beta = beta;
#line 166
          ret = 1;
        }
      }
#line 147
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 170
  return (ret);
}
}
#line 173 "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c"
static int cover3(int n , double *a , double b , double u , double *x , double y ,
                  int *cov , double *_alfa , double *_beta ) 
{ 
  int i ;
  int j ;
  int k ;
  int try ;
  int ret ;
  double eps ;
  double alfa ;
  double beta ;
  double temp ;
  double rmax ;
  double tmp ;

  {
  {
#line 176
  try = 0;
#line 176
  ret = 0;
#line 177
  rmax = 0.001;
#line 178
  tmp = fabs(b);
#line 178
  eps = 0.001 * (1.0 + tmp);
#line 179
  i = 1;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i <= n)) {
#line 179
      goto while_break;
    }
#line 180
    j = i + 1;
    {
#line 180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 180
      if (! (j <= n)) {
#line 180
        goto while_break___0;
      }
#line 181
      k = j + 1;
      {
#line 181
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 181
        if (! (k <= n)) {
#line 181
          goto while_break___1;
        }
#line 183
        try ++;
#line 184
        if (try > 1000) {
#line 184
          goto done;
        }
#line 186
        if (((*(a + i) + *(a + j)) + *(a + k)) + y > b + eps) {
#line 188
          temp = ((*(a + i) + *(a + j)) + *(a + k)) - b;
#line 189
          alfa = 1.0 / (temp + u);
#line 190
          beta = 3.0 - alfa * temp;
#line 192
          temp = (((*(x + i) + *(x + j)) + *(x + k)) + alfa * y) - beta;
#line 194
          if (rmax < temp) {
#line 195
            rmax = temp;
#line 196
            *(cov + 1) = i;
#line 197
            *(cov + 2) = j;
#line 198
            *(cov + 3) = k;
#line 199
            *_alfa = alfa;
#line 200
            *_beta = beta;
#line 201
            ret = 1;
          }
        }
#line 181
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 180
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 205
  return (ret);
}
}
#line 208 "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c"
static int cover4(int n , double *a , double b , double u , double *x , double y ,
                  int *cov , double *_alfa , double *_beta ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int try ;
  int ret ;
  double eps ;
  double alfa ;
  double beta ;
  double temp ;
  double rmax ;
  double tmp ;

  {
  {
#line 211
  try = 0;
#line 211
  ret = 0;
#line 212
  rmax = 0.001;
#line 213
  tmp = fabs(b);
#line 213
  eps = 0.001 * (1.0 + tmp);
#line 214
  i = 1;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (i <= n)) {
#line 214
      goto while_break;
    }
#line 215
    j = i + 1;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! (j <= n)) {
#line 215
        goto while_break___0;
      }
#line 216
      k = j + 1;
      {
#line 216
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 216
        if (! (k <= n)) {
#line 216
          goto while_break___1;
        }
#line 217
        l = k + 1;
        {
#line 217
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 217
          if (! (l <= n)) {
#line 217
            goto while_break___2;
          }
#line 219
          try ++;
#line 220
          if (try > 1000) {
#line 220
            goto done;
          }
#line 222
          if ((((*(a + i) + *(a + j)) + *(a + k)) + *(a + l)) + y > b + eps) {
#line 224
            temp = (((*(a + i) + *(a + j)) + *(a + k)) + *(a + l)) - b;
#line 225
            alfa = 1.0 / (temp + u);
#line 226
            beta = 4.0 - alfa * temp;
#line 228
            temp = ((((*(x + i) + *(x + j)) + *(x + k)) + *(x + l)) + alfa * y) - beta;
#line 230
            if (rmax < temp) {
#line 231
              rmax = temp;
#line 232
              *(cov + 1) = i;
#line 233
              *(cov + 2) = j;
#line 234
              *(cov + 3) = k;
#line 235
              *(cov + 4) = l;
#line 236
              *_alfa = alfa;
#line 237
              *_beta = beta;
#line 238
              ret = 1;
            }
          }
#line 217
          l ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 216
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 215
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 242
  return (ret);
}
}
#line 245 "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c"
static int cover(int n , double *a , double b , double u , double *x , double y ,
                 int *cov , double *alfa , double *beta ) 
{ 
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 262
  if (n >= 2) {
#line 262
    tmp = 1;
  } else {
    {
#line 262
    _glp_lib_xassert("n >= 2", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     262);
#line 262
    tmp = 1;
    }
  }
#line 263
  j = 1;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (j <= n)) {
#line 263
      goto while_break;
    }
#line 263
    if (*(a + j) > 0.0) {
#line 263
      tmp___0 = 1;
    } else {
      {
#line 263
      _glp_lib_xassert("a[j] > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                       263);
#line 263
      tmp___0 = 1;
      }
    }
#line 263
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  if (b > - 1e-5) {
#line 265
    tmp___1 = 1;
  } else {
    {
#line 265
    _glp_lib_xassert("b > -1e-5", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     265);
#line 265
    tmp___1 = 1;
    }
  }
#line 269
  if (u >= 0.0) {
#line 269
    tmp___2 = 1;
  } else {
    {
#line 269
    _glp_lib_xassert("u >= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     269);
#line 269
    tmp___2 = 1;
    }
  }
#line 270
  j = 1;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    if (! (j <= n)) {
#line 270
      goto while_break___0;
    }
#line 270
    if (0.0 <= *(x + j)) {
#line 270
      if (*(x + j) <= 1.0) {
#line 270
        tmp___3 = 1;
      } else {
        {
#line 270
        _glp_lib_xassert("0.0 <= x[j] && x[j] <= 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                         270);
#line 270
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 270
      _glp_lib_xassert("0.0 <= x[j] && x[j] <= 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                       270);
#line 270
      tmp___3 = 1;
      }
    }
#line 270
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 271
  if (0.0 <= y) {
#line 271
    if (y <= u) {
#line 271
      tmp___4 = 1;
    } else {
      {
#line 271
      _glp_lib_xassert("0.0 <= y && y <= u", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                       271);
#line 271
      tmp___4 = 1;
      }
    }
  } else {
    {
#line 271
    _glp_lib_xassert("0.0 <= y && y <= u", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     271);
#line 271
    tmp___4 = 1;
    }
  }
  {
#line 273
  tmp___5 = cover2(n, a, b, u, x, y, cov, alfa, beta);
  }
#line 273
  if (tmp___5) {
#line 273
    return (2);
  }
  {
#line 274
  tmp___6 = cover3(n, a, b, u, x, y, cov, alfa, beta);
  }
#line 274
  if (tmp___6) {
#line 274
    return (3);
  }
  {
#line 275
  tmp___7 = cover4(n, a, b, u, x, y, cov, alfa, beta);
  }
#line 275
  if (tmp___7) {
#line 275
    return (4);
  }
#line 276
  return (0);
}
}
#line 317 "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c"
static int lpx_cover_cut(glp_prob *lp , int len , int *ind , double *val , double *work ) 
{ 
  int cov[5] ;
  int j ;
  int k ;
  int nb ;
  int newlen ;
  int r ;
  double f_min ;
  double f_max ;
  double alfa ;
  double beta ;
  double u ;
  double *x ;
  double y ;
  double tmp ;
  int tmp___0 ;
  int ind_k ;
  double val_k ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 320
  x = work;
#line 322
  newlen = 0;
#line 323
  k = 1;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (k <= len)) {
#line 323
      goto while_break;
    }
    {
#line 324
    j = *(ind + k);
#line 325
    tmp___0 = _glp_lpx_get_col_type(lp, j);
    }
#line 325
    if (tmp___0 == 114) {
      {
#line 326
      tmp = _glp_lpx_get_col_lb(lp, j);
#line 326
      *(val + 0) -= *(val + k) * tmp;
      }
    } else {
#line 328
      newlen ++;
#line 329
      *(ind + newlen) = *(ind + k);
#line 330
      *(val + newlen) = *(val + k);
    }
#line 323
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  len = newlen;
#line 337
  nb = 0;
#line 338
  k = 1;
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! (k <= len)) {
#line 338
      goto while_break___0;
    }
    {
#line 339
    j = *(ind + k);
#line 340
    tmp___1 = _glp_lpx_get_col_kind(lp, j);
    }
#line 340
    if (tmp___1 == 161) {
      {
#line 340
      tmp___2 = _glp_lpx_get_col_type(lp, j);
      }
#line 340
      if (tmp___2 == 113) {
        {
#line 340
        tmp___3 = _glp_lpx_get_col_lb(lp, j);
        }
#line 340
        if (tmp___3 == 0.0) {
          {
#line 340
          tmp___4 = _glp_lpx_get_col_ub(lp, j);
          }
#line 340
          if (tmp___4 == 1.0) {
#line 347
            nb ++;
#line 348
            ind_k = *(ind + nb);
#line 348
            val_k = *(val + nb);
#line 349
            *(ind + nb) = *(ind + k);
#line 349
            *(val + nb) = *(val + k);
#line 350
            *(ind + k) = ind_k;
#line 350
            *(val + k) = val_k;
          }
        }
      }
    }
#line 338
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 357
  if (nb < 2) {
#line 357
    return (0);
  }
#line 359
  f_max = 0.0;
#line 359
  f_min = f_max;
#line 360
  k = nb + 1;
  {
#line 360
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 360
    if (! (k <= len)) {
#line 360
      goto while_break___1;
    }
    {
#line 361
    j = *(ind + k);
#line 363
    tmp___5 = _glp_lpx_get_col_type(lp, j);
    }
#line 363
    if (tmp___5 != 113) {
#line 363
      return (0);
    }
#line 364
    if (*(val + k) > 0.0) {
      {
#line 365
      tmp___6 = _glp_lpx_get_col_lb(lp, j);
#line 365
      f_min += *(val + k) * tmp___6;
#line 366
      tmp___7 = _glp_lpx_get_col_ub(lp, j);
#line 366
      f_max += *(val + k) * tmp___7;
      }
    } else {
      {
#line 369
      tmp___8 = _glp_lpx_get_col_ub(lp, j);
#line 369
      f_min += *(val + k) * tmp___8;
#line 370
      tmp___9 = _glp_lpx_get_col_lb(lp, j);
#line 370
      f_max += *(val + k) * tmp___9;
      }
    }
#line 360
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 379
  u = f_max - f_min;
#line 381
  y = 0.0;
#line 382
  k = nb + 1;
  {
#line 382
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 382
    if (! (k <= len)) {
#line 382
      goto while_break___2;
    }
    {
#line 383
    j = *(ind + k);
#line 384
    tmp___10 = _glp_lpx_get_col_prim(lp, j);
#line 384
    y += *(val + k) * tmp___10;
#line 382
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 386
  y -= f_min;
#line 387
  if (y < 0.0) {
#line 387
    y = 0.0;
  }
#line 388
  if (y > u) {
#line 388
    y = u;
  }
#line 390
  *(val + 0) -= f_min;
#line 394
  k = 1;
  {
#line 394
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 394
    if (! (k <= nb)) {
#line 394
      goto while_break___3;
    }
    {
#line 395
    j = *(ind + k);
#line 396
    *(x + k) = _glp_lpx_get_col_prim(lp, j);
    }
#line 397
    if (*(x + k) < 0.0) {
#line 397
      *(x + k) = 0.0;
    }
#line 398
    if (*(x + k) > 1.0) {
#line 398
      *(x + k) = 1.0;
    }
#line 394
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 401
  k = 1;
  {
#line 401
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 401
    if (! (k <= nb)) {
#line 401
      goto while_break___4;
    }
#line 402
    if (*(val + k) < 0.0) {
#line 403
      *(ind + k) = - *(ind + k);
#line 404
      *(val + k) = - *(val + k);
#line 405
      *(val + 0) += *(val + k);
#line 406
      *(x + k) = 1.0 - *(x + k);
    }
#line 401
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 410
  r = cover(nb, val, *(val + 0), u, x, y, cov, & alfa, & beta);
  }
#line 411
  if (r == 0) {
#line 411
    return (0);
  }
#line 412
  if (2 <= r) {
#line 412
    if (r <= 4) {
#line 412
      tmp___11 = 1;
    } else {
      {
#line 412
      _glp_lib_xassert("2 <= r && r <= 4", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                       412);
#line 412
      tmp___11 = 1;
      }
    }
  } else {
    {
#line 412
    _glp_lib_xassert("2 <= r && r <= 4", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     412);
#line 412
    tmp___11 = 1;
    }
  }
#line 416
  *(ind + 0) = 0;
#line 416
  *(val + 0) = beta;
#line 418
  j = 1;
  {
#line 418
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 418
    if (! (j <= r)) {
#line 418
      goto while_break___5;
    }
#line 418
    cov[j] = *(ind + cov[j]);
#line 418
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 421
  if (r <= nb) {
#line 421
    tmp___12 = 1;
  } else {
    {
#line 421
    _glp_lib_xassert("r <= nb", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     421);
#line 421
    tmp___12 = 1;
    }
  }
#line 422
  k = 1;
  {
#line 422
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 422
    if (! (k <= r)) {
#line 422
      goto while_break___6;
    }
#line 423
    if (cov[k] > 0) {
#line 424
      *(ind + k) = cov[k];
#line 425
      *(val + k) = 1.0;
    } else {
#line 428
      *(ind + k) = - cov[k];
#line 429
      *(val + k) = - 1.0;
#line 430
      *(val + 0) -= 1.0;
    }
#line 422
    k ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 434
  k = nb + 1;
  {
#line 434
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 434
    if (! (k <= len)) {
#line 434
      goto while_break___7;
    }
#line 435
    r ++;
#line 436
    *(ind + r) = *(ind + k);
#line 437
    *(val + r) = alfa * *(val + k);
#line 434
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 439
  *(val + 0) += alfa * f_min;
#line 440
  if (r <= len) {
#line 440
    tmp___13 = 1;
  } else {
    {
#line 440
    _glp_lib_xassert("r <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     440);
#line 440
    tmp___13 = 1;
    }
  }
#line 441
  len = r;
#line 442
  return (len);
}
}
#line 475 "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c"
static double lpx_eval_row(glp_prob *lp , int len , int *ind , double *val ) 
{ 
  int n ;
  int tmp ;
  int j ;
  int k ;
  double sum ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 476
  tmp = _glp_lpx_get_num_cols(lp);
#line 476
  n = tmp;
#line 478
  sum = 0.0;
  }
#line 479
  if (len < 0) {
    {
#line 480
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                               480);
#line 480
    (*tmp___0)("lpx_eval_row: len = %d; invalid row length\n", len);
    }
  }
#line 481
  k = 1;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (k <= len)) {
#line 481
      goto while_break;
    }
#line 482
    j = *(ind + k);
#line 483
    if (1 <= j) {
#line 483
      if (! (j <= n)) {
        {
#line 484
        tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                                   484);
#line 484
        (*tmp___1)("lpx_eval_row: j = %d; column number out of range\n", j);
        }
      }
    } else {
      {
#line 484
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                                 484);
#line 484
      (*tmp___1)("lpx_eval_row: j = %d; column number out of range\n", j);
      }
    }
    {
#line 486
    tmp___2 = _glp_lpx_get_col_prim(lp, j);
#line 486
    sum += *(val + k) * tmp___2;
#line 481
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  return (sum);
}
}
#line 506 "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c"
void _glp_ios_cov_gen(glp_tree___0 *tree ) 
{ 
  glp_prob *prob ;
  int m ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int i ;
  int k ;
  int type ;
  int kase ;
  int len ;
  int *ind ;
  double r ;
  double *val ;
  double *work ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 507
  prob = tree->mip;
#line 508
  tmp = _glp_lpx_get_num_rows(prob);
#line 508
  m = tmp;
#line 509
  tmp___0 = _glp_lpx_get_num_cols(prob);
#line 509
  n = tmp___0;
#line 512
  tmp___1 = _glp_lpx_get_status(prob);
  }
#line 512
  if (tmp___1 == 180) {
#line 512
    tmp___2 = 1;
  } else {
    {
#line 512
    _glp_lib_xassert("lpx_get_status(prob) == LPX_OPT", "/home/wslee/benchmarks/glpk-4.38/src/glpios07.c",
                     512);
#line 512
    tmp___2 = 1;
    }
  }
  {
#line 514
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 514
  ind = (int *)tmp___3;
#line 515
  tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 515
  val = (double *)tmp___4;
#line 516
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 516
  work = (double *)tmp___5;
#line 518
  i = 1;
  }
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! (i <= m)) {
#line 518
      goto while_break;
    }
#line 519
    kase = 1;
    {
#line 519
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 519
      if (! (kase <= 2)) {
#line 519
        goto while_break___0;
      }
      {
#line 520
      type = _glp_lpx_get_row_type(prob, i);
      }
#line 521
      if (kase == 1) {
#line 523
        if (! (type == 112)) {
#line 523
          if (! (type == 113)) {
#line 523
            goto __Cont;
          }
        }
        {
#line 524
        len = _glp_lpx_get_mat_row(prob, i, ind, val);
#line 525
        *(val + 0) = _glp_lpx_get_row_ub(prob, i);
        }
      } else {
#line 529
        if (! (type == 111)) {
#line 529
          if (! (type == 113)) {
#line 529
            goto __Cont;
          }
        }
        {
#line 530
        len = _glp_lpx_get_mat_row(prob, i, ind, val);
#line 531
        k = 1;
        }
        {
#line 531
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 531
          if (! (k <= len)) {
#line 531
            goto while_break___1;
          }
#line 531
          *(val + k) = - *(val + k);
#line 531
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 532
        tmp___6 = _glp_lpx_get_row_lb(prob, i);
#line 532
        *(val + 0) = - tmp___6;
        }
      }
      {
#line 536
      len = lpx_cover_cut(prob, len, ind, val, work);
      }
#line 537
      if (len == 0) {
#line 537
        goto __Cont;
      }
      {
#line 540
      tmp___7 = lpx_eval_row(prob, len, ind, val);
#line 540
      r = tmp___7 - *(val + 0);
      }
#line 541
      if (r < 1e-3) {
#line 541
        goto __Cont;
      }
      {
#line 543
      glp_ios_add_row(tree, (char const   *)((void *)0), 3, 0, len, (int const   *)ind,
                      (double const   *)val, 3, *(val + 0));
      }
      __Cont: /* CIL Label */ 
#line 519
      kase ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 518
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 547
  _glp_lib_xfree((void *)ind);
#line 548
  _glp_lib_xfree((void *)val);
#line 549
  _glp_lib_xfree((void *)work);
  }
#line 550
  return;
}
}
#line 538 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
IOSVEC *_glp_ios_create_vec(int n ) ;
#line 550
void _glp_ios_set_vj(IOSVEC *v , int j , double val ) ;
#line 554
void _glp_ios_clear_vec(IOSVEC *v ) ;
#line 558
void _glp_ios_clean_vec(IOSVEC *v , double eps ) ;
#line 562
void _glp_ios_copy_vec(IOSVEC *x , IOSVEC *y ) ;
#line 566
void _glp_ios_linear_comb(IOSVEC *x , double a , IOSVEC *y ) ;
#line 570
void _glp_ios_delete_vec(IOSVEC *v ) ;
#line 580
void *_glp_ios_mir_init(glp_tree___0 *tree ) ;
#line 584
void _glp_ios_mir_gen(glp_tree___0 *tree , void *gen ) ;
#line 588
void _glp_ios_mir_term(void *gen ) ;
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void set_row_attrib(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  glp_prob *mip ;
  int m ;
  int k ;
  GLPROW *row ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 126
  mip = tree->mip;
#line 127
  m = mir->m;
#line 129
  k = 1;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (k <= m)) {
#line 129
      goto while_break;
    }
#line 130
    row = *(mip->row + k);
#line 131
    *(mir->skip + k) = (char)0;
#line 132
    *(mir->isint + k) = (char)0;
    {
#line 134
    if (row->type == 1) {
#line 134
      goto case_1;
    }
#line 136
    if (row->type == 2) {
#line 136
      goto case_2;
    }
#line 138
    if (row->type == 3) {
#line 138
      goto case_3;
    }
#line 140
    if (row->type == 4) {
#line 140
      goto case_4;
    }
#line 142
    if (row->type == 5) {
#line 142
      goto case_5;
    }
#line 144
    goto switch_default;
    case_1: /* CIL Label */ 
#line 135
    *(mir->lb + k) = - 1.7976931348623157e+308;
#line 135
    *(mir->ub + k) = 1.7976931348623157e+308;
#line 135
    goto switch_break;
    case_2: /* CIL Label */ 
#line 137
    *(mir->lb + k) = row->lb;
#line 137
    *(mir->ub + k) = 1.7976931348623157e+308;
#line 137
    goto switch_break;
    case_3: /* CIL Label */ 
#line 139
    *(mir->lb + k) = - 1.7976931348623157e+308;
#line 139
    *(mir->ub + k) = row->ub;
#line 139
    goto switch_break;
    case_4: /* CIL Label */ 
#line 141
    *(mir->lb + k) = row->lb;
#line 141
    *(mir->ub + k) = row->ub;
#line 141
    goto switch_break;
    case_5: /* CIL Label */ 
#line 143
    tmp = row->lb;
#line 143
    *(mir->ub + k) = tmp;
#line 143
    *(mir->lb + k) = tmp;
#line 143
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 145
    if ((unsigned long )row != (unsigned long )row) {
#line 145
      tmp___0 = 1;
    } else {
      {
#line 145
      _glp_lib_xassert("row != row", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       145);
#line 145
      tmp___0 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 147
    tmp___1 = 0;
#line 147
    *(mir->vub + k) = tmp___1;
#line 147
    *(mir->vlb + k) = tmp___1;
#line 129
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 152 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void set_col_attrib(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  int k ;
  GLPCOL *col ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 154
  mip = tree->mip;
#line 155
  m = mir->m;
#line 156
  n = mir->n;
#line 158
  k = m + 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (k <= m + n)) {
#line 158
      goto while_break;
    }
#line 159
    col = *(mip->col + (k - m));
    {
#line 161
    if (col->kind == 1) {
#line 161
      goto case_1;
    }
#line 163
    if (col->kind == 2) {
#line 163
      goto case_2;
    }
#line 165
    goto switch_default;
    case_1: /* CIL Label */ 
#line 162
    *(mir->isint + k) = (char)0;
#line 162
    goto switch_break;
    case_2: /* CIL Label */ 
#line 164
    *(mir->isint + k) = (char)1;
#line 164
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 166
    if ((unsigned long )col != (unsigned long )col) {
#line 166
      tmp = 1;
    } else {
      {
#line 166
      _glp_lib_xassert("col != col", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       166);
#line 166
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 169
    if (col->type == 1) {
#line 169
      goto case_1___0;
    }
#line 171
    if (col->type == 2) {
#line 171
      goto case_2___0;
    }
#line 173
    if (col->type == 3) {
#line 173
      goto case_3;
    }
#line 175
    if (col->type == 4) {
#line 175
      goto case_4;
    }
#line 177
    if (col->type == 5) {
#line 177
      goto case_5;
    }
#line 179
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 170
    *(mir->lb + k) = - 1.7976931348623157e+308;
#line 170
    *(mir->ub + k) = 1.7976931348623157e+308;
#line 170
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 172
    *(mir->lb + k) = col->lb;
#line 172
    *(mir->ub + k) = 1.7976931348623157e+308;
#line 172
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 174
    *(mir->lb + k) = - 1.7976931348623157e+308;
#line 174
    *(mir->ub + k) = col->ub;
#line 174
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 176
    *(mir->lb + k) = col->lb;
#line 176
    *(mir->ub + k) = col->ub;
#line 176
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 178
    tmp___0 = col->lb;
#line 178
    *(mir->ub + k) = tmp___0;
#line 178
    *(mir->lb + k) = tmp___0;
#line 178
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 180
    if ((unsigned long )col != (unsigned long )col) {
#line 180
      tmp___1 = 1;
    } else {
      {
#line 180
      _glp_lib_xassert("col != col", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       180);
#line 180
      tmp___1 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 182
    tmp___2 = 0;
#line 182
    *(mir->vub + k) = tmp___2;
#line 182
    *(mir->vlb + k) = tmp___2;
#line 158
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 187 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void set_var_bounds(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  glp_prob *mip ;
  int m ;
  GLPAIJ *aij ;
  int i ;
  int k1 ;
  int k2 ;
  double a1 ;
  double a2 ;

  {
#line 189
  mip = tree->mip;
#line 190
  m = mir->m;
#line 194
  i = 1;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i <= m)) {
#line 194
      goto while_break;
    }
#line 196
    if (*(mir->lb + i) == 0.0) {
#line 196
      if (! (*(mir->ub + i) == 1.7976931348623157e+308)) {
#line 196
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 196
    if (*(mir->lb + i) == - 1.7976931348623157e+308) {
#line 196
      if (! (*(mir->ub + i) == 0.0)) {
#line 197
        goto __Cont;
      }
    } else {
#line 197
      goto __Cont;
    }
#line 199
    aij = (*(mip->row + i))->ptr;
#line 200
    if ((unsigned long )aij == (unsigned long )((void *)0)) {
#line 200
      goto __Cont;
    }
#line 201
    k1 = m + (aij->col)->j;
#line 201
    a1 = aij->val;
#line 203
    aij = aij->r_next;
#line 204
    if ((unsigned long )aij == (unsigned long )((void *)0)) {
#line 204
      goto __Cont;
    }
#line 205
    k2 = m + (aij->col)->j;
#line 205
    a2 = aij->val;
#line 207
    if ((unsigned long )aij->r_next != (unsigned long )((void *)0)) {
#line 207
      goto __Cont;
    }
#line 209
    if (! *(mir->isint + k1)) {
#line 209
      if (! *(mir->isint + k2)) {
#line 209
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 211
    if (*(mir->isint + k1)) {
#line 211
      if (! *(mir->isint + k2)) {
#line 212
        k2 = k1;
#line 212
        a2 = a1;
#line 213
        k1 = m + (aij->col)->j;
#line 213
        a1 = aij->val;
      } else {
#line 217
        goto __Cont;
      }
    } else {
#line 217
      goto __Cont;
    }
#line 220
    if (*(mir->lb + k2) == - 1.7976931348623157e+308) {
#line 221
      goto __Cont;
    } else
#line 220
    if (*(mir->ub + k2) == 1.7976931348623157e+308) {
#line 221
      goto __Cont;
    } else
#line 220
    if (*(mir->lb + k2) == *(mir->ub + k2)) {
#line 221
      goto __Cont;
    }
#line 223
    if (*(mir->ub + i) == 0.0) {
#line 223
      a1 = - a1;
#line 223
      a2 = - a2;
    }
#line 226
    if (a1 > 0.0) {
#line 228
      if (*(mir->vlb + k1) == 0) {
#line 230
        *(mir->lb + k1) = - a2 / a1;
#line 231
        *(mir->vlb + k1) = k2;
#line 233
        *(mir->skip + i) = (char)1;
      }
    } else
#line 238
    if (*(mir->vub + k1) == 0) {
#line 240
      *(mir->ub + k1) = - a2 / a1;
#line 241
      *(mir->vub + k1) = k2;
#line 243
      *(mir->skip + i) = (char)1;
    }
    __Cont: /* CIL Label */ 
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 250 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void mark_useless_rows(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  glp_prob *mip ;
  int m ;
  GLPAIJ *aij ;
  int i ;
  int k ;
  int nv ;

  {
#line 252
  mip = tree->mip;
#line 253
  m = mir->m;
#line 256
  i = 1;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i <= m)) {
#line 256
      goto while_break;
    }
#line 258
    if (*(mir->lb + i) == - 1.7976931348623157e+308) {
#line 258
      if (*(mir->ub + i) == 1.7976931348623157e+308) {
#line 259
        *(mir->skip + i) = (char)1;
#line 260
        goto __Cont;
      }
    }
#line 262
    nv = 0;
#line 263
    aij = (*(mip->row + i))->ptr;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 263
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 263
        goto while_break___0;
      }
#line 264
      k = m + (aij->col)->j;
#line 266
      if (*(mir->lb + k) == - 1.7976931348623157e+308) {
#line 266
        if (*(mir->ub + k) == 1.7976931348623157e+308) {
#line 267
          *(mir->skip + i) = (char)1;
#line 268
          goto while_break___0;
        }
      }
#line 272
      if (*(mir->isint + k)) {
#line 272
        if (*(mir->lb + k) == - 1.7976931348623157e+308) {
#line 274
          *(mir->skip + i) = (char)1;
#line 275
          goto while_break___0;
        } else {
#line 272
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 272
      if (*(mir->isint + k)) {
#line 272
        if (*(mir->ub + k) == 1.7976931348623157e+308) {
#line 274
          *(mir->skip + i) = (char)1;
#line 275
          goto while_break___0;
        }
      }
#line 278
      if (*(mir->vlb + k) == 0) {
#line 278
        if (*(mir->vub + k) == 0) {
#line 278
          if (! (*(mir->lb + k) == *(mir->ub + k))) {
#line 279
            nv ++;
          }
        } else {
#line 279
          nv ++;
        }
      } else {
#line 279
        nv ++;
      }
#line 263
      aij = aij->r_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 282
    if (nv == 0) {
#line 283
      *(mir->skip + i) = (char)1;
#line 284
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 256
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 290 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
void *_glp_ios_mir_init(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  struct MIR *mir ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 292
  mip = tree->mip;
#line 293
  m = mip->m;
#line 294
  n = mip->n;
#line 300
  tmp = _glp_lib_xmalloc((int )sizeof(struct MIR ));
#line 300
  mir = (struct MIR *)tmp;
#line 301
  mir->m = m;
#line 302
  mir->n = n;
#line 303
  tmp___0 = _glp_lib_xcalloc(1 + m, (int )sizeof(char ));
#line 303
  mir->skip = (char *)tmp___0;
#line 304
  tmp___1 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(char ));
#line 304
  mir->isint = (char *)tmp___1;
#line 305
  tmp___2 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 305
  mir->lb = (double *)tmp___2;
#line 306
  tmp___3 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 306
  mir->vlb = (int *)tmp___3;
#line 307
  tmp___4 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 307
  mir->ub = (double *)tmp___4;
#line 308
  tmp___5 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 308
  mir->vub = (int *)tmp___5;
#line 309
  tmp___6 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 309
  mir->x = (double *)tmp___6;
#line 310
  tmp___7 = _glp_lib_xcalloc(6, (int )sizeof(int ));
#line 310
  mir->agg_row = (int *)tmp___7;
#line 311
  mir->agg_vec = _glp_ios_create_vec(m + n);
#line 312
  tmp___8 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(char ));
#line 312
  mir->subst = (char *)tmp___8;
#line 313
  mir->mod_vec = _glp_ios_create_vec(m + n);
#line 314
  mir->cut_vec = _glp_ios_create_vec(m + n);
#line 316
  set_row_attrib(tree, mir);
#line 318
  set_col_attrib(tree, mir);
#line 320
  set_var_bounds(tree, mir);
#line 322
  mark_useless_rows(tree, mir);
  }
#line 323
  return ((void *)mir);
}
}
#line 341 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void get_current_point(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  int k ;

  {
#line 343
  mip = tree->mip;
#line 344
  m = mir->m;
#line 345
  n = mir->n;
#line 347
  k = 1;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (k <= m)) {
#line 347
      goto while_break;
    }
#line 348
    *(mir->x + k) = (*(mip->row + k))->prim;
#line 347
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  k = m + 1;
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! (k <= m + n)) {
#line 349
      goto while_break___0;
    }
#line 350
    *(mir->x + k) = (*(mip->col + (k - m)))->prim;
#line 349
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 351
  return;
}
}
#line 395 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void initial_agg_row(glp_tree___0 *tree , struct MIR *mir , int i ) 
{ 
  glp_prob *mip ;
  int m ;
  GLPAIJ *aij ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 397
  mip = tree->mip;
#line 398
  m = mir->m;
#line 400
  if (1 <= i) {
#line 400
    if (i <= m) {
#line 400
      tmp = 1;
    } else {
      {
#line 400
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       400);
#line 400
      tmp = 1;
      }
    }
  } else {
    {
#line 400
    _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     400);
#line 400
    tmp = 1;
    }
  }
#line 401
  if (! *(mir->skip + i)) {
#line 401
    tmp___0 = 1;
  } else {
    {
#line 401
    _glp_lib_xassert("!mir->skip[i]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     401);
#line 401
    tmp___0 = 1;
    }
  }
  {
#line 404
  *(mir->skip + i) = (char)2;
#line 405
  mir->agg_cnt = 1;
#line 406
  *(mir->agg_row + 1) = i;
#line 409
  _glp_ios_clear_vec(mir->agg_vec);
#line 410
  _glp_ios_set_vj(mir->agg_vec, i, 1.0);
#line 411
  aij = (*(mip->row + i))->ptr;
  }
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 411
      goto while_break;
    }
    {
#line 412
    _glp_ios_set_vj(mir->agg_vec, m + (aij->col)->j, - aij->val);
#line 411
    aij = aij->r_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  mir->agg_rhs = 0.0;
#line 417
  return;
}
}
#line 446 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void subst_fixed_vars(struct MIR *mir ) 
{ 
  int m ;
  int n ;
  int j ;
  int k ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 448
  m = mir->m;
#line 449
  n = mir->n;
#line 451
  j = 1;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (j <= (mir->agg_vec)->nnz)) {
#line 451
      goto while_break;
    }
#line 452
    k = *((mir->agg_vec)->ind + j);
#line 453
    if (1 <= k) {
#line 453
      if (k <= m + n) {
#line 453
        tmp = 1;
      } else {
        {
#line 453
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         453);
#line 453
        tmp = 1;
        }
      }
    } else {
      {
#line 453
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       453);
#line 453
      tmp = 1;
      }
    }
#line 454
    if (*(mir->vlb + k) == 0) {
#line 454
      if (*(mir->vub + k) == 0) {
#line 454
        if (*(mir->lb + k) == *(mir->ub + k)) {
#line 457
          mir->agg_rhs -= *((mir->agg_vec)->val + j) * *(mir->lb + k);
#line 458
          *((mir->agg_vec)->val + j) = 0.0;
        }
      }
    }
#line 451
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 462
  _glp_ios_clean_vec(mir->agg_vec, 2.2204460492503131e-16);
  }
#line 466
  return;
}
}
#line 469 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void bound_subst_heur(struct MIR *mir ) 
{ 
  int m ;
  int n ;
  int j ;
  int k ;
  int kk ;
  double d1 ;
  double d2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 471
  m = mir->m;
#line 472
  n = mir->n;
#line 475
  j = 1;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (j <= (mir->agg_vec)->nnz)) {
#line 475
      goto while_break;
    }
#line 476
    k = *((mir->agg_vec)->ind + j);
#line 477
    if (1 <= k) {
#line 477
      if (k <= m + n) {
#line 477
        tmp = 1;
      } else {
        {
#line 477
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         477);
#line 477
        tmp = 1;
        }
      }
    } else {
      {
#line 477
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       477);
#line 477
      tmp = 1;
      }
    }
#line 478
    if (*(mir->isint + k)) {
#line 478
      goto __Cont;
    }
#line 480
    kk = *(mir->vlb + k);
#line 481
    if (kk == 0) {
#line 482
      if (*(mir->lb + k) == - 1.7976931348623157e+308) {
#line 483
        d1 = 1.7976931348623157e+308;
      } else {
#line 485
        d1 = *(mir->x + k) - *(mir->lb + k);
      }
    } else {
#line 488
      if (1 <= kk) {
#line 488
        if (kk <= m + n) {
#line 488
          tmp___0 = 1;
        } else {
          {
#line 488
          _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           488);
#line 488
          tmp___0 = 1;
          }
        }
      } else {
        {
#line 488
        _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         488);
#line 488
        tmp___0 = 1;
        }
      }
#line 489
      if (*(mir->isint + kk)) {
#line 489
        tmp___1 = 1;
      } else {
        {
#line 489
        _glp_lib_xassert("mir->isint[kk]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         489);
#line 489
        tmp___1 = 1;
        }
      }
#line 490
      if (*(mir->lb + k) != - 1.7976931348623157e+308) {
#line 490
        tmp___2 = 1;
      } else {
        {
#line 490
        _glp_lib_xassert("mir->lb[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         490);
#line 490
        tmp___2 = 1;
        }
      }
#line 491
      d1 = *(mir->x + k) - *(mir->lb + k) * *(mir->x + kk);
    }
#line 494
    kk = *(mir->vub + k);
#line 495
    if (kk == 0) {
#line 496
      if ((double )*(mir->vub + k) == 1.7976931348623157e+308) {
#line 497
        d2 = 1.7976931348623157e+308;
      } else {
#line 499
        d2 = *(mir->ub + k) - *(mir->x + k);
      }
    } else {
#line 502
      if (1 <= kk) {
#line 502
        if (kk <= m + n) {
#line 502
          tmp___3 = 1;
        } else {
          {
#line 502
          _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           502);
#line 502
          tmp___3 = 1;
          }
        }
      } else {
        {
#line 502
        _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         502);
#line 502
        tmp___3 = 1;
        }
      }
#line 503
      if (*(mir->isint + kk)) {
#line 503
        tmp___4 = 1;
      } else {
        {
#line 503
        _glp_lib_xassert("mir->isint[kk]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         503);
#line 503
        tmp___4 = 1;
        }
      }
#line 504
      if (*(mir->ub + k) != 1.7976931348623157e+308) {
#line 504
        tmp___5 = 1;
      } else {
        {
#line 504
        _glp_lib_xassert("mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         504);
#line 504
        tmp___5 = 1;
        }
      }
#line 505
      d2 = *(mir->ub + k) * *(mir->x + kk) - *(mir->x + k);
    }
#line 508
    if (d1 != 1.7976931348623157e+308) {
#line 508
      tmp___6 = 1;
    } else
#line 508
    if (d2 != 1.7976931348623157e+308) {
#line 508
      tmp___6 = 1;
    } else {
      {
#line 508
      _glp_lib_xassert("d1 != DBL_MAX || d2 != DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       508);
#line 508
      tmp___6 = 1;
      }
    }
#line 510
    if ((int )*(mir->subst + k) == 63) {
#line 510
      tmp___7 = 1;
    } else {
      {
#line 510
      _glp_lib_xassert("mir->subst[k] == \'?\'", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       510);
#line 510
      tmp___7 = 1;
      }
    }
#line 511
    if (d1 <= d2) {
#line 512
      *(mir->subst + k) = (char )'L';
    } else {
#line 514
      *(mir->subst + k) = (char )'U';
    }
    __Cont: /* CIL Label */ 
#line 475
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 516
  return;
}
}
#line 519 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void build_mod_row(struct MIR *mir ) 
{ 
  int m ;
  int n ;
  int j ;
  int jj ;
  int k ;
  int kk ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 521
  m = mir->m;
#line 522
  n = mir->n;
#line 525
  _glp_ios_copy_vec(mir->mod_vec, mir->agg_vec);
#line 526
  mir->mod_rhs = mir->agg_rhs;
#line 533
  j = (mir->mod_vec)->nnz;
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (j >= 1)) {
#line 533
      goto while_break;
    }
#line 534
    k = *((mir->mod_vec)->ind + j);
#line 535
    if (1 <= k) {
#line 535
      if (k <= m + n) {
#line 535
        tmp = 1;
      } else {
        {
#line 535
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         535);
#line 535
        tmp = 1;
        }
      }
    } else {
      {
#line 535
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       535);
#line 535
      tmp = 1;
      }
    }
#line 536
    if (*(mir->isint + k)) {
#line 536
      goto __Cont;
    }
#line 537
    if ((int )*(mir->subst + k) == 76) {
#line 539
      if (*(mir->lb + k) != - 1.7976931348623157e+308) {
#line 539
        tmp___0 = 1;
      } else {
        {
#line 539
        _glp_lib_xassert("mir->lb[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         539);
#line 539
        tmp___0 = 1;
        }
      }
#line 540
      kk = *(mir->vlb + k);
#line 541
      if (kk == 0) {
#line 543
        mir->mod_rhs -= *((mir->mod_vec)->val + j) * *(mir->lb + k);
      } else {
#line 547
        if (*(mir->isint + kk)) {
#line 547
          tmp___1 = 1;
        } else {
          {
#line 547
          _glp_lib_xassert("mir->isint[kk]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           547);
#line 547
          tmp___1 = 1;
          }
        }
#line 548
        jj = *((mir->mod_vec)->pos + kk);
#line 549
        if (jj == 0) {
          {
#line 550
          _glp_ios_set_vj(mir->mod_vec, kk, 1.0);
#line 551
          jj = *((mir->mod_vec)->pos + kk);
#line 552
          *((mir->mod_vec)->val + jj) = 0.0;
          }
        }
#line 554
        *((mir->mod_vec)->val + jj) += *((mir->mod_vec)->val + j) * *(mir->lb + k);
      }
    } else
#line 558
    if ((int )*(mir->subst + k) == 85) {
#line 560
      if (*(mir->ub + k) != 1.7976931348623157e+308) {
#line 560
        tmp___2 = 1;
      } else {
        {
#line 560
        _glp_lib_xassert("mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         560);
#line 560
        tmp___2 = 1;
        }
      }
#line 561
      kk = *(mir->vub + k);
#line 562
      if (kk == 0) {
#line 564
        mir->mod_rhs -= *((mir->mod_vec)->val + j) * *(mir->ub + k);
      } else {
#line 568
        if (*(mir->isint + kk)) {
#line 568
          tmp___3 = 1;
        } else {
          {
#line 568
          _glp_lib_xassert("mir->isint[kk]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           568);
#line 568
          tmp___3 = 1;
          }
        }
#line 569
        jj = *((mir->mod_vec)->pos + kk);
#line 570
        if (jj == 0) {
          {
#line 571
          _glp_ios_set_vj(mir->mod_vec, kk, 1.0);
#line 572
          jj = *((mir->mod_vec)->pos + kk);
#line 573
          *((mir->mod_vec)->val + jj) = 0.0;
          }
        }
#line 575
        *((mir->mod_vec)->val + jj) += *((mir->mod_vec)->val + j) * *(mir->ub + k);
      }
#line 578
      *((mir->mod_vec)->val + j) = - *((mir->mod_vec)->val + j);
    } else
#line 581
    if (k != k) {
#line 581
      tmp___4 = 1;
    } else {
      {
#line 581
      _glp_lib_xassert("k != k", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       581);
#line 581
      tmp___4 = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 533
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  j = 1;
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 587
    if (! (j <= (mir->mod_vec)->nnz)) {
#line 587
      goto while_break___0;
    }
#line 588
    k = *((mir->mod_vec)->ind + j);
#line 589
    if (1 <= k) {
#line 589
      if (k <= m + n) {
#line 589
        tmp___5 = 1;
      } else {
        {
#line 589
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         589);
#line 589
        tmp___5 = 1;
        }
      }
    } else {
      {
#line 589
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       589);
#line 589
      tmp___5 = 1;
      }
    }
#line 590
    if (! *(mir->isint + k)) {
#line 590
      goto __Cont___0;
    }
#line 591
    if ((int )*(mir->subst + k) == 63) {
#line 591
      tmp___6 = 1;
    } else {
      {
#line 591
      _glp_lib_xassert("mir->subst[k] == \'?\'", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       591);
#line 591
      tmp___6 = 1;
      }
    }
#line 592
    if (*(mir->vlb + k) == 0) {
#line 592
      if (*(mir->vub + k) == 0) {
#line 592
        tmp___7 = 1;
      } else {
        {
#line 592
        _glp_lib_xassert("mir->vlb[k] == 0 && mir->vub[k] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         592);
#line 592
        tmp___7 = 1;
        }
      }
    } else {
      {
#line 592
      _glp_lib_xassert("mir->vlb[k] == 0 && mir->vub[k] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       592);
#line 592
      tmp___7 = 1;
      }
    }
#line 593
    if (*(mir->lb + k) != - 1.7976931348623157e+308) {
#line 593
      if (*(mir->ub + k) != 1.7976931348623157e+308) {
#line 593
        tmp___8 = 1;
      } else {
        {
#line 593
        _glp_lib_xassert("mir->lb[k] != -DBL_MAX && mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         593);
#line 593
        tmp___8 = 1;
        }
      }
    } else {
      {
#line 593
      _glp_lib_xassert("mir->lb[k] != -DBL_MAX && mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       593);
#line 593
      tmp___8 = 1;
      }
    }
    {
#line 594
    tmp___9 = fabs(*(mir->lb + k));
#line 594
    tmp___10 = fabs(*(mir->ub + k));
    }
#line 594
    if (tmp___9 <= tmp___10) {
#line 596
      *(mir->subst + k) = (char )'L';
#line 597
      mir->mod_rhs -= *((mir->mod_vec)->val + j) * *(mir->lb + k);
    } else {
#line 601
      *(mir->subst + k) = (char )'U';
#line 602
      mir->mod_rhs -= *((mir->mod_vec)->val + j) * *(mir->ub + k);
#line 603
      *((mir->mod_vec)->val + j) = - *((mir->mod_vec)->val + j);
    }
    __Cont___0: /* CIL Label */ 
#line 587
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 609
  return;
}
}
#line 679 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static int mir_ineq(int const   n , double const   *a , double const   b , double *alpha ,
                    double *beta , double *gamma___0 ) 
{ 
  int j ;
  double f ;
  double t ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 683
  tmp = floor((double )(b + (double const   ).5));
#line 683
  tmp___0 = fabs((double )(b - (double const   )tmp));
  }
#line 683
  if (tmp___0 < 0.01) {
#line 684
    return (1);
  }
  {
#line 685
  tmp___1 = floor((double )b);
#line 685
  f = (double )(b - (double const   )tmp___1);
#line 686
  j = 1;
  }
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! (j <= (int )n)) {
#line 686
      goto while_break;
    }
    {
#line 687
    tmp___2 = floor((double )*(a + j));
#line 687
    t = (double )((*(a + j) - (double const   )tmp___2) - (double const   )f);
    }
#line 688
    if (t <= 0.0) {
      {
#line 689
      *(alpha + j) = floor((double )*(a + j));
      }
    } else {
      {
#line 691
      tmp___3 = floor((double )*(a + j));
#line 691
      *(alpha + j) = tmp___3 + t / (1.0 - f);
      }
    }
#line 686
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  *beta = floor((double )b);
#line 694
  *gamma___0 = 1.0 / (1.0 - f);
  }
#line 695
  return (0);
}
}
#line 722 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static int cmir_ineq(int const   n , double const   *a , double const   b , double const   *u ,
                     char const   *cset , double const   delta , double *alpha , double *beta ,
                     double *gamma___0 ) 
{ 
  int j ;
  double *aa ;
  double bb ;
  int tmp ;

  {
#line 727
  aa = alpha;
#line 727
  bb = (double )b;
#line 728
  j = 1;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (! (j <= (int )n)) {
#line 728
      goto while_break;
    }
#line 729
    *(aa + j) = (double )(*(a + j) / delta);
#line 730
    if (*(cset + j)) {
#line 731
      *(aa + j) = - *(aa + j);
#line 731
      bb -= (double )(*(a + j) * *(u + j));
    }
#line 728
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 733
  bb /= (double )delta;
#line 734
  tmp = mir_ineq(n, (double const   *)aa, (double const   )bb, alpha, beta, gamma___0);
  }
#line 734
  if (tmp) {
#line 734
    return (1);
  }
#line 735
  j = 1;
  {
#line 735
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 735
    if (! (j <= (int )n)) {
#line 735
      goto while_break___0;
    }
#line 736
    if (*(cset + j)) {
#line 737
      *(alpha + j) = - *(alpha + j);
#line 737
      *beta += *(alpha + j) * (double )*(u + j);
    }
#line 735
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 739
  *gamma___0 /= (double )delta;
#line 740
  return (0);
}
}
#line 777 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static int cmir_cmp(void const   *p1 , void const   *p2 ) 
{ 
  struct vset  const  *v1 ;
  struct vset  const  *v2 ;

  {
#line 778
  v1 = (struct vset  const  *)p1;
#line 778
  v2 = (struct vset  const  *)p2;
#line 779
  if (v1->v < v2->v) {
#line 779
    return (-1);
  }
#line 780
  if (v1->v > v2->v) {
#line 780
    return (1);
  }
#line 781
  return (0);
}
}
#line 784 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static double cmir_sep(int const   n , double const   *a , double const   b , double const   *u ,
                       double const   *x , double const   s , double *alpha , double *beta ,
                       double *gamma___0 ) 
{ 
  int fail ;
  int j ;
  int k ;
  int nv ;
  int v ;
  double delta ;
  double eps ;
  double d_try[4] ;
  double r ;
  double r_best ;
  char *cset ;
  struct vset *vset ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 792
  tmp = _glp_lib_xcalloc(1 + (int )n, (int )sizeof(char ));
#line 792
  cset = (char *)tmp;
#line 793
  tmp___0 = _glp_lib_xcalloc(1 + (int )n, (int )sizeof(struct vset ));
#line 793
  vset = (struct vset *)tmp___0;
#line 795
  j = 1;
  }
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (! (j <= (int )n)) {
#line 795
      goto while_break;
    }
#line 796
    *(cset + j) = (char )(*(x + j) >= (double const   )(0.5 * (double )*(u + j)));
#line 795
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  delta = 0.0;
#line 798
  r_best = delta;
#line 799
  j = 1;
  {
#line 799
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 799
    if (! (j <= (int )n)) {
#line 799
      goto while_break___0;
    }
#line 800
    if (*(a + j) != (double const   )0.0) {
#line 800
      tmp___1 = 1;
    } else {
      {
#line 800
      _glp_lib_xassert("a[j] != 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       800);
#line 800
      tmp___1 = 1;
      }
    }
    {
#line 802
    tmp___2 = fabs((double )*(u + j));
#line 802
    eps = 1e-9 * (1.0 + tmp___2);
    }
#line 803
    if (*(x + j) < (double const   )eps) {
#line 803
      goto __Cont;
    } else
#line 803
    if (*(x + j) > *(u + j) - (double const   )eps) {
#line 803
      goto __Cont;
    }
    {
#line 805
    tmp___3 = fabs((double )*(a + j));
#line 805
    fail = cmir_ineq(n, a, b, u, (char const   *)cset, (double const   )tmp___3, alpha,
                     beta, gamma___0);
    }
#line 807
    if (fail) {
#line 807
      goto __Cont;
    }
#line 809
    r = - *beta - *gamma___0 * (double )s;
#line 810
    k = 1;
    {
#line 810
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 810
      if (! (k <= (int )n)) {
#line 810
        goto while_break___1;
      }
#line 810
      r += *(alpha + k) * (double )*(x + k);
#line 810
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 811
    if (r_best < r) {
      {
#line 811
      r_best = r;
#line 811
      delta = fabs((double )*(a + j));
      }
    }
    __Cont: /* CIL Label */ 
#line 799
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 813
  if (r_best < 0.001) {
#line 813
    r_best = 0.0;
  }
#line 814
  if (r_best == 0.0) {
#line 814
    goto done;
  }
#line 815
  if (delta > 0.0) {
#line 815
    tmp___4 = 1;
  } else {
    {
#line 815
    _glp_lib_xassert("delta > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     815);
#line 815
    tmp___4 = 1;
    }
  }
#line 818
  d_try[1] = delta / 2.0;
#line 819
  d_try[2] = delta / 4.0;
#line 820
  d_try[3] = delta / 8.0;
#line 821
  j = 1;
  {
#line 821
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 821
    if (! (j <= 3)) {
#line 821
      goto while_break___2;
    }
    {
#line 823
    fail = cmir_ineq(n, a, b, u, (char const   *)cset, (double const   )d_try[j],
                     alpha, beta, gamma___0);
    }
#line 825
    if (fail) {
#line 825
      goto __Cont___0;
    }
#line 827
    r = - *beta - *gamma___0 * (double )s;
#line 828
    k = 1;
    {
#line 828
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 828
      if (! (k <= (int )n)) {
#line 828
        goto while_break___3;
      }
#line 828
      r += *(alpha + k) * (double )*(x + k);
#line 828
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 829
    if (r_best < r) {
#line 829
      r_best = r;
#line 829
      delta = d_try[j];
    }
    __Cont___0: /* CIL Label */ 
#line 821
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 833
  nv = 0;
#line 834
  j = 1;
  {
#line 834
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 834
    if (! (j <= (int )n)) {
#line 834
      goto while_break___4;
    }
    {
#line 836
    tmp___5 = fabs((double )*(u + j));
#line 836
    eps = 1e-9 * (1.0 + tmp___5);
    }
#line 837
    if (*(x + j) < (double const   )eps) {
#line 837
      goto __Cont___1;
    } else
#line 837
    if (*(x + j) > *(u + j) - (double const   )eps) {
#line 837
      goto __Cont___1;
    }
    {
#line 839
    nv ++;
#line 840
    (vset + nv)->j = j;
#line 841
    (vset + nv)->v = fabs((double )(*(x + j) - (double const   )(0.5 * (double )*(u + j))));
    }
    __Cont___1: /* CIL Label */ 
#line 834
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 843
  qsort((void *)(vset + 1), (size_t )nv, (size_t )sizeof(struct vset ), & cmir_cmp);
#line 846
  v = 1;
  }
  {
#line 846
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 846
    if (! (v <= nv)) {
#line 846
      goto while_break___5;
    }
    {
#line 847
    j = (vset + v)->j;
#line 849
    *(cset + j) = (char )(! *(cset + j));
#line 851
    fail = cmir_ineq(n, a, b, u, (char const   *)cset, (double const   )delta, alpha,
                     beta, gamma___0);
#line 853
    *(cset + j) = (char )(! *(cset + j));
    }
#line 855
    if (fail) {
#line 855
      goto __Cont___2;
    }
#line 857
    r = - *beta - *gamma___0 * (double )s;
#line 858
    k = 1;
    {
#line 858
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 858
      if (! (k <= (int )n)) {
#line 858
        goto while_break___6;
      }
#line 858
      r += *(alpha + k) * (double )*(x + k);
#line 858
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 859
    if (r_best < r) {
#line 859
      r_best = r;
#line 859
      *(cset + j) = (char )(! *(cset + j));
    }
    __Cont___2: /* CIL Label */ 
#line 846
    v ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 862
  fail = cmir_ineq(n, a, b, u, (char const   *)cset, (double const   )delta, alpha,
                   beta, gamma___0);
  }
#line 863
  if (! fail) {
#line 863
    tmp___6 = 1;
  } else {
    {
#line 863
    _glp_lib_xassert("!fail", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c", 863);
#line 863
    tmp___6 = 1;
    }
  }
  done: 
  {
#line 865
  _glp_lib_xfree((void *)cset);
#line 866
  _glp_lib_xfree((void *)vset);
  }
#line 868
  return (r_best);
}
}
#line 871 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static double generate___0(struct MIR *mir ) 
{ 
  int m ;
  int n ;
  int j ;
  int k ;
  int kk ;
  int nint ;
  double s ;
  double *u ;
  double *x ;
  double *alpha ;
  double r_best ;
  double b ;
  double beta ;
  double gamma___0 ;
  int tmp ;
  int tmp___0 ;
  double temp ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double x___0 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
#line 873
  m = mir->m;
#line 874
  n = mir->n;
#line 876
  r_best = 0.0;
#line 877
  _glp_ios_copy_vec(mir->cut_vec, mir->mod_vec);
#line 878
  mir->cut_rhs = mir->mod_rhs;
#line 881
  _glp_ios_clean_vec(mir->cut_vec, 2.2204460492503131e-16);
#line 886
  j = 1;
  }
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 886
    if (! (j <= (mir->cut_vec)->nnz)) {
#line 886
      goto while_break;
    }
#line 887
    k = *((mir->cut_vec)->ind + j);
#line 888
    if (1 <= k) {
#line 888
      if (k <= m + n) {
#line 888
        tmp = 1;
      } else {
        {
#line 888
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         888);
#line 888
        tmp = 1;
        }
      }
    } else {
      {
#line 888
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       888);
#line 888
      tmp = 1;
      }
    }
#line 889
    if (! *(mir->isint + k)) {
#line 889
      if (*((mir->cut_vec)->val + j) > 0.0) {
#line 890
        *((mir->cut_vec)->val + j) = 0.0;
      }
    }
#line 886
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 892
  _glp_ios_clean_vec(mir->cut_vec, 0.0);
#line 898
  nint = 0;
#line 899
  j = 1;
  }
  {
#line 899
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 899
    if (! (j <= (mir->cut_vec)->nnz)) {
#line 899
      goto while_break___0;
    }
#line 900
    k = *((mir->cut_vec)->ind + j);
#line 901
    if (1 <= k) {
#line 901
      if (k <= m + n) {
#line 901
        tmp___0 = 1;
      } else {
        {
#line 901
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         901);
#line 901
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 901
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       901);
#line 901
      tmp___0 = 1;
      }
    }
#line 902
    if (*(mir->isint + k)) {
#line 904
      nint ++;
#line 906
      kk = *((mir->cut_vec)->ind + nint);
#line 907
      *((mir->cut_vec)->pos + k) = nint;
#line 908
      *((mir->cut_vec)->pos + kk) = j;
#line 909
      *((mir->cut_vec)->ind + nint) = k;
#line 910
      *((mir->cut_vec)->ind + j) = kk;
#line 911
      temp = *((mir->cut_vec)->val + nint);
#line 912
      *((mir->cut_vec)->val + nint) = *((mir->cut_vec)->val + j);
#line 913
      *((mir->cut_vec)->val + j) = temp;
    }
#line 899
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 920
  if (nint == 0) {
#line 920
    goto done;
  }
  {
#line 922
  tmp___1 = _glp_lib_xcalloc(1 + nint, (int )sizeof(double ));
#line 922
  u = (double *)tmp___1;
#line 923
  tmp___2 = _glp_lib_xcalloc(1 + nint, (int )sizeof(double ));
#line 923
  x = (double *)tmp___2;
#line 924
  tmp___3 = _glp_lib_xcalloc(1 + nint, (int )sizeof(double ));
#line 924
  alpha = (double *)tmp___3;
#line 926
  j = 1;
  }
  {
#line 926
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 926
    if (! (j <= nint)) {
#line 926
      goto while_break___1;
    }
#line 927
    k = *((mir->cut_vec)->ind + j);
#line 928
    if (m + 1 <= k) {
#line 928
      if (k <= m + n) {
#line 928
        tmp___4 = 1;
      } else {
        {
#line 928
        _glp_lib_xassert("m+1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         928);
#line 928
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 928
      _glp_lib_xassert("m+1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       928);
#line 928
      tmp___4 = 1;
      }
    }
#line 929
    if (*(mir->isint + k)) {
#line 929
      tmp___5 = 1;
    } else {
      {
#line 929
      _glp_lib_xassert("mir->isint[k]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       929);
#line 929
      tmp___5 = 1;
      }
    }
#line 930
    *(u + j) = *(mir->ub + k) - *(mir->lb + k);
#line 931
    if (*(u + j) >= 1.0) {
#line 931
      tmp___6 = 1;
    } else {
      {
#line 931
      _glp_lib_xassert("u[j] >= 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       931);
#line 931
      tmp___6 = 1;
      }
    }
#line 932
    if ((int )*(mir->subst + k) == 76) {
#line 933
      *(x + j) = *(mir->x + k) - *(mir->lb + k);
    } else
#line 934
    if ((int )*(mir->subst + k) == 85) {
#line 935
      *(x + j) = *(mir->ub + k) - *(mir->x + k);
    } else
#line 937
    if (k != k) {
#line 937
      tmp___7 = 1;
    } else {
      {
#line 937
      _glp_lib_xassert("k != k", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       937);
#line 937
      tmp___7 = 1;
      }
    }
#line 938
    if (*(x + j) >= - 0.001) {
#line 938
      tmp___8 = 1;
    } else {
      {
#line 938
      _glp_lib_xassert("x[j] >= -0.001", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       938);
#line 938
      tmp___8 = 1;
      }
    }
#line 939
    if (*(x + j) < 0.0) {
#line 939
      *(x + j) = 0.0;
    }
#line 926
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 942
  s = 0.0;
#line 943
  j = nint + 1;
  {
#line 943
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 943
    if (! (j <= (mir->cut_vec)->nnz)) {
#line 943
      goto while_break___2;
    }
#line 945
    k = *((mir->cut_vec)->ind + j);
#line 946
    if (1 <= k) {
#line 946
      if (k <= m + n) {
#line 946
        tmp___9 = 1;
      } else {
        {
#line 946
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         946);
#line 946
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 946
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       946);
#line 946
      tmp___9 = 1;
      }
    }
#line 948
    if (! *(mir->isint + k)) {
#line 948
      tmp___10 = 1;
    } else {
      {
#line 948
      _glp_lib_xassert("!mir->isint[k]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       948);
#line 948
      tmp___10 = 1;
      }
    }
#line 949
    if ((int )*(mir->subst + k) == 76) {
#line 950
      if (*(mir->lb + k) != - 1.7976931348623157e+308) {
#line 950
        tmp___11 = 1;
      } else {
        {
#line 950
        _glp_lib_xassert("mir->lb[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         950);
#line 950
        tmp___11 = 1;
        }
      }
#line 951
      kk = *(mir->vlb + k);
#line 952
      if (kk == 0) {
#line 953
        x___0 = *(mir->x + k) - *(mir->lb + k);
      } else {
#line 955
        x___0 = *(mir->x + k) - *(mir->lb + k) * *(mir->x + kk);
      }
    } else
#line 957
    if ((int )*(mir->subst + k) == 85) {
#line 958
      if (*(mir->ub + k) != 1.7976931348623157e+308) {
#line 958
        tmp___12 = 1;
      } else {
        {
#line 958
        _glp_lib_xassert("mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         958);
#line 958
        tmp___12 = 1;
        }
      }
#line 959
      kk = *(mir->vub + k);
#line 960
      if (kk == 0) {
#line 961
        x___0 = *(mir->ub + k) - *(mir->x + k);
      } else {
#line 963
        x___0 = *(mir->ub + k) * *(mir->x + kk) - *(mir->x + k);
      }
    } else
#line 966
    if (k != k) {
#line 966
      tmp___13 = 1;
    } else {
      {
#line 966
      _glp_lib_xassert("k != k", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       966);
#line 966
      tmp___13 = 1;
      }
    }
#line 967
    if (x___0 >= - 0.001) {
#line 967
      tmp___14 = 1;
    } else {
      {
#line 967
      _glp_lib_xassert("x >= -0.001", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       967);
#line 967
      tmp___14 = 1;
      }
    }
#line 968
    if (x___0 < 0.0) {
#line 968
      x___0 = 0.0;
    }
#line 969
    s -= *((mir->cut_vec)->val + j) * x___0;
#line 943
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 971
  if (s >= 0.0) {
#line 971
    tmp___15 = 1;
  } else {
    {
#line 971
    _glp_lib_xassert("s >= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     971);
#line 971
    tmp___15 = 1;
    }
  }
  {
#line 973
  b = mir->cut_rhs;
#line 974
  r_best = cmir_sep((int const   )nint, (double const   *)(mir->cut_vec)->val, (double const   )b,
                    (double const   *)u, (double const   *)x, (double const   )s,
                    alpha, & beta, & gamma___0);
  }
#line 976
  if (r_best == 0.0) {
#line 976
    goto skip;
  }
#line 977
  if (r_best > 0.0) {
#line 977
    tmp___16 = 1;
  } else {
    {
#line 977
    _glp_lib_xassert("r_best > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     977);
#line 977
    tmp___16 = 1;
    }
  }
#line 980
  j = 1;
  {
#line 980
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 980
    if (! (j <= nint)) {
#line 980
      goto while_break___3;
    }
#line 981
    *((mir->cut_vec)->val + j) = *(alpha + j);
#line 980
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 982
  j = nint + 1;
  {
#line 982
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 982
    if (! (j <= (mir->cut_vec)->nnz)) {
#line 982
      goto while_break___4;
    }
#line 983
    k = *((mir->cut_vec)->ind + j);
#line 984
    if (k <= m + n) {
#line 984
      *((mir->cut_vec)->val + j) *= gamma___0;
    }
#line 982
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 986
  mir->cut_rhs = beta;
  skip: 
  {
#line 991
  _glp_lib_xfree((void *)u);
#line 992
  _glp_lib_xfree((void *)x);
#line 993
  _glp_lib_xfree((void *)alpha);
  }
  done: 
#line 994
  return (r_best);
}
}
#line 1041 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void back_subst(struct MIR *mir ) 
{ 
  int m ;
  int n ;
  int j ;
  int jj ;
  int k ;
  int kk ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 1043
  m = mir->m;
#line 1044
  n = mir->n;
#line 1049
  j = 1;
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1049
    if (! (j <= (mir->cut_vec)->nnz)) {
#line 1049
      goto while_break;
    }
#line 1050
    k = *((mir->cut_vec)->ind + j);
#line 1051
    if (1 <= k) {
#line 1051
      if (k <= m + n) {
#line 1051
        tmp = 1;
      } else {
        {
#line 1051
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1051);
#line 1051
        tmp = 1;
        }
      }
    } else {
      {
#line 1051
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1051);
#line 1051
      tmp = 1;
      }
    }
#line 1052
    if (! *(mir->isint + k)) {
#line 1052
      goto __Cont;
    }
#line 1053
    if ((int )*(mir->subst + k) == 76) {
#line 1055
      if (*(mir->lb + k) != - 1.7976931348623157e+308) {
#line 1055
        tmp___0 = 1;
      } else {
        {
#line 1055
        _glp_lib_xassert("mir->lb[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1055);
#line 1055
        tmp___0 = 1;
        }
      }
#line 1056
      if (*(mir->vlb + k) == 0) {
#line 1056
        tmp___1 = 1;
      } else {
        {
#line 1056
        _glp_lib_xassert("mir->vlb[k] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1056);
#line 1056
        tmp___1 = 1;
        }
      }
#line 1057
      mir->cut_rhs += *((mir->cut_vec)->val + j) * *(mir->lb + k);
    } else
#line 1059
    if ((int )*(mir->subst + k) == 85) {
#line 1061
      if (*(mir->ub + k) != 1.7976931348623157e+308) {
#line 1061
        tmp___2 = 1;
      } else {
        {
#line 1061
        _glp_lib_xassert("mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1061);
#line 1061
        tmp___2 = 1;
        }
      }
#line 1062
      if (*(mir->vub + k) == 0) {
#line 1062
        tmp___3 = 1;
      } else {
        {
#line 1062
        _glp_lib_xassert("mir->vub[k] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1062);
#line 1062
        tmp___3 = 1;
        }
      }
#line 1063
      mir->cut_rhs -= *((mir->cut_vec)->val + j) * *(mir->ub + k);
#line 1064
      *((mir->cut_vec)->val + j) = - *((mir->cut_vec)->val + j);
    } else
#line 1067
    if (k != k) {
#line 1067
      tmp___4 = 1;
    } else {
      {
#line 1067
      _glp_lib_xassert("k != k", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1067);
#line 1067
      tmp___4 = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 1049
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  j = 1;
  {
#line 1070
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1070
    if (! (j <= (mir->cut_vec)->nnz)) {
#line 1070
      goto while_break___0;
    }
#line 1071
    k = *((mir->cut_vec)->ind + j);
#line 1072
    if (1 <= k) {
#line 1072
      if (k <= m + n) {
#line 1072
        tmp___5 = 1;
      } else {
        {
#line 1072
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1072);
#line 1072
        tmp___5 = 1;
        }
      }
    } else {
      {
#line 1072
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1072);
#line 1072
      tmp___5 = 1;
      }
    }
#line 1073
    if (*(mir->isint + k)) {
#line 1073
      goto __Cont___0;
    }
#line 1074
    if ((int )*(mir->subst + k) == 76) {
#line 1076
      if (*(mir->lb + k) != - 1.7976931348623157e+308) {
#line 1076
        tmp___6 = 1;
      } else {
        {
#line 1076
        _glp_lib_xassert("mir->lb[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1076);
#line 1076
        tmp___6 = 1;
        }
      }
#line 1077
      kk = *(mir->vlb + k);
#line 1078
      if (kk == 0) {
#line 1080
        mir->cut_rhs += *((mir->cut_vec)->val + j) * *(mir->lb + k);
      } else {
#line 1084
        jj = *((mir->cut_vec)->pos + kk);
#line 1088
        if (jj == 0) {
          {
#line 1089
          _glp_ios_set_vj(mir->cut_vec, kk, 1.0);
#line 1090
          jj = *((mir->cut_vec)->pos + kk);
          }
#line 1091
          if (jj != 0) {
#line 1091
            tmp___7 = 1;
          } else {
            {
#line 1091
            _glp_lib_xassert("jj != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                             1091);
#line 1091
            tmp___7 = 1;
            }
          }
#line 1092
          *((mir->cut_vec)->val + jj) = 0.0;
        }
#line 1095
        *((mir->cut_vec)->val + jj) -= *((mir->cut_vec)->val + j) * *(mir->lb + k);
      }
    } else
#line 1099
    if ((int )*(mir->subst + k) == 85) {
#line 1101
      if (*(mir->ub + k) != 1.7976931348623157e+308) {
#line 1101
        tmp___8 = 1;
      } else {
        {
#line 1101
        _glp_lib_xassert("mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1101);
#line 1101
        tmp___8 = 1;
        }
      }
#line 1102
      kk = *(mir->vub + k);
#line 1103
      if (kk == 0) {
#line 1105
        mir->cut_rhs -= *((mir->cut_vec)->val + j) * *(mir->ub + k);
      } else {
#line 1109
        jj = *((mir->cut_vec)->pos + kk);
#line 1110
        if (jj == 0) {
          {
#line 1111
          _glp_ios_set_vj(mir->cut_vec, kk, 1.0);
#line 1112
          jj = *((mir->cut_vec)->pos + kk);
          }
#line 1113
          if (jj != 0) {
#line 1113
            tmp___9 = 1;
          } else {
            {
#line 1113
            _glp_lib_xassert("jj != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                             1113);
#line 1113
            tmp___9 = 1;
            }
          }
#line 1114
          *((mir->cut_vec)->val + jj) = 0.0;
        }
#line 1116
        *((mir->cut_vec)->val + jj) += *((mir->cut_vec)->val + j) * *(mir->ub + k);
      }
#line 1119
      *((mir->cut_vec)->val + j) = - *((mir->cut_vec)->val + j);
    } else
#line 1122
    if (k != k) {
#line 1122
      tmp___10 = 1;
    } else {
      {
#line 1122
      _glp_lib_xassert("k != k", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1122);
#line 1122
      tmp___10 = 1;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 1070
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1127
  return;
}
}
#line 1157 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void subst_aux_vars(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  GLPAIJ *aij ;
  int j ;
  int k ;
  int kk ;
  int jj ;
  int tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1159
  mip = tree->mip;
#line 1160
  m = mir->m;
#line 1161
  n = mir->n;
#line 1164
  j = (mir->cut_vec)->nnz;
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    if (! (j >= 1)) {
#line 1164
      goto while_break;
    }
#line 1165
    k = *((mir->cut_vec)->ind + j);
#line 1166
    if (1 <= k) {
#line 1166
      if (k <= m + n) {
#line 1166
        tmp = 1;
      } else {
        {
#line 1166
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1166);
#line 1166
        tmp = 1;
        }
      }
    } else {
      {
#line 1166
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1166);
#line 1166
      tmp = 1;
      }
    }
#line 1167
    if (k > m) {
#line 1167
      goto __Cont;
    }
#line 1168
    aij = (*(mip->row + k))->ptr;
    {
#line 1168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1168
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1168
        goto while_break___0;
      }
#line 1169
      kk = m + (aij->col)->j;
#line 1170
      jj = *((mir->cut_vec)->pos + kk);
#line 1171
      if (jj == 0) {
        {
#line 1172
        _glp_ios_set_vj(mir->cut_vec, kk, 1.0);
#line 1173
        jj = *((mir->cut_vec)->pos + kk);
#line 1174
        *((mir->cut_vec)->val + jj) = 0.0;
        }
      }
#line 1176
      *((mir->cut_vec)->val + jj) += *((mir->cut_vec)->val + j) * aij->val;
#line 1168
      aij = aij->r_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1178
    *((mir->cut_vec)->val + j) = 0.0;
    __Cont: /* CIL Label */ 
#line 1164
    j --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1180
  _glp_ios_clean_vec(mir->cut_vec, 0.0);
  }
#line 1181
  return;
}
}
#line 1184 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static void add_cut(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  int m ;
  int n ;
  int j ;
  int k ;
  int len ;
  int *ind ;
  void *tmp ;
  double *val ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 1186
  m = mir->m;
#line 1187
  n = mir->n;
#line 1189
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 1189
  ind = (int *)tmp;
#line 1190
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 1190
  val = (double *)tmp___0;
#line 1191
  len = 0;
#line 1192
  j = (mir->cut_vec)->nnz;
  }
  {
#line 1192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1192
    if (! (j >= 1)) {
#line 1192
      goto while_break;
    }
#line 1193
    k = *((mir->cut_vec)->ind + j);
#line 1194
    if (m + 1 <= k) {
#line 1194
      if (k <= m + n) {
#line 1194
        tmp___1 = 1;
      } else {
        {
#line 1194
        _glp_lib_xassert("m+1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1194);
#line 1194
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 1194
      _glp_lib_xassert("m+1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1194);
#line 1194
      tmp___1 = 1;
      }
    }
#line 1195
    len ++;
#line 1195
    *(ind + len) = k - m;
#line 1195
    *(val + len) = *((mir->cut_vec)->val + j);
#line 1192
    j --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1201
  glp_ios_add_row(tree, (char const   *)((void *)0), 2, 0, len, (int const   *)ind,
                  (double const   *)val, 3, mir->cut_rhs);
#line 1204
  _glp_lib_xfree((void *)ind);
#line 1205
  _glp_lib_xfree((void *)val);
  }
#line 1206
  return;
}
}
#line 1209 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
static int aggregate_row(glp_tree___0 *tree , struct MIR *mir ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  GLPAIJ *aij ;
  IOSVEC *v ;
  int ii ;
  int j ;
  int jj ;
  int k ;
  int kk ;
  int kappa___1 ;
  int ret ;
  double d1 ;
  double d2 ;
  double d___0 ;
  double d_max ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
#line 1211
  mip = tree->mip;
#line 1212
  m = mir->m;
#line 1213
  n = mir->n;
#line 1216
  kappa___1 = 0;
#line 1216
  ret = 0;
#line 1217
  d_max = 0.0;
#line 1220
  j = 1;
  {
#line 1220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1220
    if (! (j <= (mir->agg_vec)->nnz)) {
#line 1220
      goto while_break;
    }
#line 1221
    k = *((mir->agg_vec)->ind + j);
#line 1222
    if (1 <= k) {
#line 1222
      if (k <= m + n) {
#line 1222
        tmp = 1;
      } else {
        {
#line 1222
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1222);
#line 1222
        tmp = 1;
        }
      }
    } else {
      {
#line 1222
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1222);
#line 1222
      tmp = 1;
      }
    }
#line 1223
    if (k <= m) {
#line 1223
      goto __Cont;
    }
#line 1224
    if (*(mir->isint + k)) {
#line 1224
      goto __Cont;
    }
    {
#line 1225
    tmp___0 = fabs(*((mir->agg_vec)->val + j));
    }
#line 1225
    if (tmp___0 < 0.001) {
#line 1225
      goto __Cont;
    }
#line 1227
    kk = *(mir->vlb + k);
#line 1228
    if (kk == 0) {
#line 1229
      if (*(mir->lb + k) == - 1.7976931348623157e+308) {
#line 1230
        d1 = 1.7976931348623157e+308;
      } else {
#line 1232
        d1 = *(mir->x + k) - *(mir->lb + k);
      }
    } else {
#line 1235
      if (1 <= kk) {
#line 1235
        if (kk <= m + n) {
#line 1235
          tmp___1 = 1;
        } else {
          {
#line 1235
          _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           1235);
#line 1235
          tmp___1 = 1;
          }
        }
      } else {
        {
#line 1235
        _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1235);
#line 1235
        tmp___1 = 1;
        }
      }
#line 1236
      if (*(mir->isint + kk)) {
#line 1236
        tmp___2 = 1;
      } else {
        {
#line 1236
        _glp_lib_xassert("mir->isint[kk]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1236);
#line 1236
        tmp___2 = 1;
        }
      }
#line 1237
      if (*(mir->lb + k) != - 1.7976931348623157e+308) {
#line 1237
        tmp___3 = 1;
      } else {
        {
#line 1237
        _glp_lib_xassert("mir->lb[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1237);
#line 1237
        tmp___3 = 1;
        }
      }
#line 1238
      d1 = *(mir->x + k) - *(mir->lb + k) * *(mir->x + kk);
    }
#line 1241
    kk = *(mir->vub + k);
#line 1242
    if (kk == 0) {
#line 1243
      if ((double )*(mir->vub + k) == 1.7976931348623157e+308) {
#line 1244
        d2 = 1.7976931348623157e+308;
      } else {
#line 1246
        d2 = *(mir->ub + k) - *(mir->x + k);
      }
    } else {
#line 1249
      if (1 <= kk) {
#line 1249
        if (kk <= m + n) {
#line 1249
          tmp___4 = 1;
        } else {
          {
#line 1249
          _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           1249);
#line 1249
          tmp___4 = 1;
          }
        }
      } else {
        {
#line 1249
        _glp_lib_xassert("1 <= kk && kk <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1249);
#line 1249
        tmp___4 = 1;
        }
      }
#line 1250
      if (*(mir->isint + kk)) {
#line 1250
        tmp___5 = 1;
      } else {
        {
#line 1250
        _glp_lib_xassert("mir->isint[kk]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1250);
#line 1250
        tmp___5 = 1;
        }
      }
#line 1251
      if (*(mir->ub + k) != 1.7976931348623157e+308) {
#line 1251
        tmp___6 = 1;
      } else {
        {
#line 1251
        _glp_lib_xassert("mir->ub[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1251);
#line 1251
        tmp___6 = 1;
        }
      }
#line 1252
      d2 = *(mir->ub + k) * *(mir->x + kk) - *(mir->x + k);
    }
#line 1255
    if (d1 != 1.7976931348623157e+308) {
#line 1255
      tmp___7 = 1;
    } else
#line 1255
    if (d2 != 1.7976931348623157e+308) {
#line 1255
      tmp___7 = 1;
    } else {
      {
#line 1255
      _glp_lib_xassert("d1 != DBL_MAX || d2 != DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1255);
#line 1255
      tmp___7 = 1;
      }
    }
#line 1257
    if (d1 <= d2) {
#line 1257
      d___0 = d1;
    } else {
#line 1257
      d___0 = d2;
    }
#line 1258
    if (d___0 != 1.7976931348623157e+308) {
#line 1258
      tmp___8 = 1;
    } else {
      {
#line 1258
      _glp_lib_xassert("d != DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1258);
#line 1258
      tmp___8 = 1;
      }
    }
#line 1260
    if (d___0 < 0.001) {
#line 1260
      goto __Cont;
    }
#line 1261
    if (d_max < d___0) {
#line 1261
      d_max = d___0;
#line 1261
      kappa___1 = k;
    }
    __Cont: /* CIL Label */ 
#line 1220
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  if (kappa___1 == 0) {
#line 1265
    ret = 1;
#line 1266
    goto done;
  }
#line 1269
  if (m + 1 <= kappa___1) {
#line 1269
    if (kappa___1 <= m + n) {
#line 1269
      tmp___9 = 1;
    } else {
      {
#line 1269
      _glp_lib_xassert("m+1 <= kappa && kappa <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                       1269);
#line 1269
      tmp___9 = 1;
      }
    }
  } else {
    {
#line 1269
    _glp_lib_xassert("m+1 <= kappa && kappa <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     1269);
#line 1269
    tmp___9 = 1;
    }
  }
#line 1270
  if (! *(mir->isint + kappa___1)) {
#line 1270
    tmp___10 = 1;
  } else {
    {
#line 1270
    _glp_lib_xassert("!mir->isint[kappa]", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     1270);
#line 1270
    tmp___10 = 1;
    }
  }
#line 1273
  ii = 1;
  {
#line 1273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1273
    if (! (ii <= m)) {
#line 1273
      goto while_break___0;
    }
#line 1274
    if (*(mir->skip + ii)) {
#line 1274
      goto __Cont___0;
    }
#line 1275
    aij = (*(mip->row + ii))->ptr;
    {
#line 1275
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1275
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1275
        goto while_break___1;
      }
#line 1276
      if ((aij->col)->j == kappa___1 - m) {
#line 1276
        goto while_break___1;
      }
#line 1275
      aij = aij->r_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1277
    if ((unsigned long )aij != (unsigned long )((void *)0)) {
      {
#line 1277
      tmp___11 = fabs(aij->val);
      }
#line 1277
      if (tmp___11 >= 0.001) {
#line 1277
        goto while_break___0;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 1273
    ii ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1279
  if (ii > m) {
#line 1281
    ret = 2;
#line 1282
    goto done;
  }
#line 1285
  (mir->agg_cnt) ++;
#line 1286
  if (mir->agg_cnt <= 5) {
#line 1286
    tmp___12 = 1;
  } else {
    {
#line 1286
    _glp_lib_xassert("mir->agg_cnt <= MAXAGGR", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     1286);
#line 1286
    tmp___12 = 1;
    }
  }
  {
#line 1287
  *(mir->agg_row + mir->agg_cnt) = ii;
#line 1288
  *(mir->skip + ii) = (char)2;
#line 1290
  v = _glp_ios_create_vec(m + n);
#line 1291
  _glp_ios_set_vj(v, ii, 1.0);
#line 1292
  aij = (*(mip->row + ii))->ptr;
  }
  {
#line 1292
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1292
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1292
      goto while_break___2;
    }
    {
#line 1293
    _glp_ios_set_vj(v, m + (aij->col)->j, - aij->val);
#line 1292
    aij = aij->r_next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1298
  j = *((mir->agg_vec)->pos + kappa___1);
#line 1299
  if (j != 0) {
#line 1299
    tmp___13 = 1;
  } else {
    {
#line 1299
    _glp_lib_xassert("j != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     1299);
#line 1299
    tmp___13 = 1;
    }
  }
#line 1300
  jj = *(v->pos + kappa___1);
#line 1301
  if (jj != 0) {
#line 1301
    tmp___14 = 1;
  } else {
    {
#line 1301
    _glp_lib_xassert("jj != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     1301);
#line 1301
    tmp___14 = 1;
    }
  }
  {
#line 1302
  _glp_ios_linear_comb(mir->agg_vec, - *((mir->agg_vec)->val + j) / *(v->val + jj),
                       v);
#line 1304
  _glp_ios_delete_vec(v);
#line 1305
  _glp_ios_set_vj(mir->agg_vec, kappa___1, 0.0);
  }
  done: 
#line 1309
  return (ret);
}
}
#line 1312 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
void _glp_ios_mir_gen(glp_tree___0 *tree , void *gen ) 
{ 
  glp_prob *mip ;
  struct MIR *mir ;
  int m ;
  int n ;
  int i ;
  double r_best ;
  int tmp ;
  int tmp___0 ;
  int j ;
  int k ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int k___0 ;
  int ii ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1314
  mip = tree->mip;
#line 1315
  mir = (struct MIR *)gen;
#line 1316
  m = mir->m;
#line 1317
  n = mir->n;
#line 1320
  if (mip->m >= m) {
#line 1320
    tmp = 1;
  } else {
    {
#line 1320
    _glp_lib_xassert("mip->m >= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     1320);
#line 1320
    tmp = 1;
    }
  }
#line 1321
  if (mip->n == n) {
#line 1321
    tmp___0 = 1;
  } else {
    {
#line 1321
    _glp_lib_xassert("mip->n == n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                     1321);
#line 1321
    tmp___0 = 1;
    }
  }
  {
#line 1323
  get_current_point(tree, mir);
#line 1329
  memset((void *)(mir->subst + 1), '?', (size_t )(m + n));
#line 1331
  i = 1;
  }
  {
#line 1331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1331
    if (! (i <= m)) {
#line 1331
      goto while_break;
    }
#line 1332
    if (*(mir->skip + i)) {
#line 1332
      goto __Cont;
    }
    {
#line 1334
    initial_agg_row(tree, mir, i);
    }
    loop: 
    {
#line 1341
    subst_fixed_vars(mir);
#line 1354
    bound_subst_heur(mir);
#line 1356
    build_mod_row(mir);
#line 1362
    r_best = generate___0(mir);
    }
#line 1363
    if (r_best > 0.0) {
      {
#line 1370
      back_subst(mir);
#line 1376
      subst_aux_vars(tree, mir);
#line 1382
      add_cut(tree, mir);
      }
    }
#line 1386
    j = 1;
    {
#line 1386
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1386
      if (! (j <= (mir->mod_vec)->nnz)) {
#line 1386
        goto while_break___0;
      }
#line 1387
      k = *((mir->mod_vec)->ind + j);
#line 1388
      if (1 <= k) {
#line 1388
        if (k <= m + n) {
#line 1388
          tmp___1 = 1;
        } else {
          {
#line 1388
          _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           1388);
#line 1388
          tmp___1 = 1;
          }
        }
      } else {
        {
#line 1388
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1388);
#line 1388
        tmp___1 = 1;
        }
      }
#line 1389
      if ((int )*(mir->subst + k) != 63) {
#line 1389
        tmp___2 = 1;
      } else {
        {
#line 1389
        _glp_lib_xassert("mir->subst[k] != \'?\'", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1389);
#line 1389
        tmp___2 = 1;
        }
      }
#line 1390
      *(mir->subst + k) = (char )'?';
#line 1386
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1393
    if (r_best == 0.0) {
#line 1395
      if (mir->agg_cnt < 5) {
        {
#line 1397
        tmp___3 = aggregate_row(tree, mir);
        }
#line 1397
        if (tmp___3 == 0) {
#line 1397
          goto loop;
        }
      }
    }
#line 1402
    k___0 = 1;
    {
#line 1402
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1402
      if (! (k___0 <= mir->agg_cnt)) {
#line 1402
        goto while_break___1;
      }
#line 1403
      ii = *(mir->agg_row + k___0);
#line 1404
      if (1 <= ii) {
#line 1404
        if (ii <= m) {
#line 1404
          tmp___4 = 1;
        } else {
          {
#line 1404
          _glp_lib_xassert("1 <= ii && ii <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                           1404);
#line 1404
          tmp___4 = 1;
          }
        }
      } else {
        {
#line 1404
        _glp_lib_xassert("1 <= ii && ii <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1404);
#line 1404
        tmp___4 = 1;
        }
      }
#line 1405
      if ((int )*(mir->skip + ii) == 2) {
#line 1405
        tmp___5 = 1;
      } else {
        {
#line 1405
        _glp_lib_xassert("mir->skip[ii] == 2", "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c",
                         1405);
#line 1405
        tmp___5 = 1;
        }
      }
#line 1406
      *(mir->skip + ii) = (char)0;
#line 1402
      k___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1410
  return;
}
}
#line 1428 "/home/wslee/benchmarks/glpk-4.38/src/glpios06.c"
void _glp_ios_mir_term(void *gen ) 
{ 
  struct MIR *mir ;

  {
  {
#line 1429
  mir = (struct MIR *)gen;
#line 1430
  _glp_lib_xfree((void *)mir->skip);
#line 1431
  _glp_lib_xfree((void *)mir->isint);
#line 1432
  _glp_lib_xfree((void *)mir->lb);
#line 1433
  _glp_lib_xfree((void *)mir->vlb);
#line 1434
  _glp_lib_xfree((void *)mir->ub);
#line 1435
  _glp_lib_xfree((void *)mir->vub);
#line 1436
  _glp_lib_xfree((void *)mir->x);
#line 1437
  _glp_lib_xfree((void *)mir->agg_row);
#line 1438
  _glp_ios_delete_vec(mir->agg_vec);
#line 1439
  _glp_lib_xfree((void *)mir->subst);
#line 1440
  _glp_ios_delete_vec(mir->mod_vec);
#line 1441
  _glp_ios_delete_vec(mir->cut_vec);
#line 1442
  _glp_lib_xfree((void *)mir);
  }
#line 1443
  return;
}
}
#line 639 "./../include/glpk.h"
int glp_ios_pool_size(glp_tree___0 *tree ) ;
#line 576 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
void _glp_ios_gmi_gen(glp_tree___0 *tree ) ;
#line 54 "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c"
static void gen_cut(glp_tree___0 *tree , struct worka *worka , int j ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  int *ind ;
  double *val ;
  double *phi ;
  int i ;
  int k ;
  int len ;
  int kind ;
  int stat ;
  double lb ;
  double ub ;
  double alfa ;
  double beta ;
  double ksi ;
  double phi1 ;
  double rhs ;
  double tmp ;
  int tmp___0 ;
  GLPROW *row ;
  GLPCOL *col ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  GLPROW *row___0 ;
  GLPAIJ *aij ;
  double tmp___17 ;
  int tmp___18 ;
  GLPCOL *col___0 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 59
  mip = tree->mip;
#line 60
  m = mip->m;
#line 61
  n = mip->n;
#line 62
  ind = worka->ind;
#line 63
  val = worka->val;
#line 64
  phi = worka->phi;
#line 69
  len = glp_eval_tab_row(mip, m + j, ind, val);
#line 74
  beta = (*(mip->col + j))->prim;
#line 78
  k = 1;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (k <= m + n)) {
#line 78
      goto while_break;
    }
#line 78
    *(phi + k) = 0.0;
#line 78
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  tmp = floor(beta);
#line 79
  rhs = beta - tmp;
#line 80
  j = 1;
  }
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (j <= len)) {
#line 80
      goto while_break___0;
    }
#line 82
    k = *(ind + j);
#line 83
    if (1 <= k) {
#line 83
      if (k <= m + n) {
#line 83
        tmp___0 = 1;
      } else {
        {
#line 83
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c",
                         83);
#line 83
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 83
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c",
                       83);
#line 83
      tmp___0 = 1;
      }
    }
#line 86
    if (k <= m) {
#line 88
      row = *(mip->row + k);
#line 89
      kind = 1;
#line 90
      lb = row->lb;
#line 91
      ub = row->ub;
#line 92
      stat = row->stat;
    } else {
#line 96
      col = *(mip->col + (k - m));
#line 97
      kind = col->kind;
#line 98
      lb = col->lb;
#line 99
      ub = col->ub;
#line 100
      stat = col->stat;
    }
#line 103
    if (stat != 1) {
#line 103
      tmp___1 = 1;
    } else {
      {
#line 103
      _glp_lib_xassert("stat != GLP_BS", "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c",
                       103);
#line 103
      tmp___1 = 1;
      }
    }
    {
#line 105
    ksi = *(val + j);
#line 108
    tmp___2 = fabs(ksi);
    }
#line 108
    if (tmp___2 > 1e+05) {
#line 108
      goto fini;
    }
    {
#line 110
    tmp___3 = fabs(ksi);
    }
#line 110
    if (tmp___3 < 1e-10) {
#line 110
      goto skip;
    }
    {
#line 113
    if (stat == 4) {
#line 113
      goto case_4;
    }
#line 117
    if (stat == 2) {
#line 117
      goto case_2;
    }
#line 121
    if (stat == 3) {
#line 121
      goto case_3;
    }
#line 125
    if (stat == 5) {
#line 125
      goto case_5;
    }
#line 128
    goto switch_default;
    case_4: /* CIL Label */ 
#line 116
    goto fini;
    case_2: /* CIL Label */ 
#line 119
    alfa = - ksi;
#line 120
    goto switch_break;
    case_3: /* CIL Label */ 
#line 123
    alfa = ksi;
#line 124
    goto switch_break;
    case_5: /* CIL Label */ 
#line 127
    goto skip;
    switch_default: /* CIL Label */ 
#line 129
    if (stat != stat) {
#line 129
      tmp___4 = 1;
    } else {
      {
#line 129
      _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c",
                       129);
#line 129
      tmp___4 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 133
    if (kind == 2) {
#line 133
      goto case_2___0;
    }
#line 144
    if (kind == 1) {
#line 144
      goto case_1;
    }
#line 151
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
    {
#line 135
    tmp___11 = floor(alfa + 0.5);
#line 135
    tmp___12 = fabs(alfa - tmp___11);
    }
#line 135
    if (tmp___12 < 1e-10) {
#line 137
      goto skip;
    } else {
      {
#line 139
      tmp___9 = floor(alfa);
#line 139
      tmp___10 = floor(beta);
      }
#line 139
      if (alfa - tmp___9 <= beta - tmp___10) {
        {
#line 140
        tmp___5 = floor(alfa);
#line 140
        phi1 = alfa - tmp___5;
        }
      } else {
        {
#line 142
        tmp___6 = floor(beta);
#line 142
        tmp___7 = floor(beta);
#line 142
        tmp___8 = floor(alfa);
#line 142
        phi1 = ((beta - tmp___6) / (1.0 - (beta - tmp___7))) * (1.0 - (alfa - tmp___8));
        }
      }
    }
#line 143
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 146
    if (alfa >= 0.0) {
#line 147
      phi1 = alfa;
    } else {
      {
#line 149
      tmp___13 = floor(beta);
#line 149
      tmp___14 = floor(beta);
#line 149
      phi1 = ((beta - tmp___13) / (1.0 - (beta - tmp___14))) * - alfa;
      }
    }
#line 150
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 152
    if (kind != kind) {
#line 152
      tmp___15 = 1;
    } else {
      {
#line 152
      _glp_lib_xassert("kind != kind", "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c",
                       152);
#line 152
      tmp___15 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 157
    if (stat == 2) {
#line 157
      goto case_2___1;
    }
#line 162
    if (stat == 3) {
#line 162
      goto case_3___0;
    }
#line 167
    goto switch_default___1;
    case_2___1: /* CIL Label */ 
#line 159
    *(phi + k) = phi1;
#line 160
    rhs += phi1 * lb;
#line 161
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 164
    *(phi + k) = - phi1;
#line 165
    rhs -= phi1 * ub;
#line 166
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 168
    if (stat != stat) {
#line 168
      tmp___16 = 1;
    } else {
      {
#line 168
      _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c",
                       168);
#line 168
      tmp___16 = 1;
      }
    }
    switch_break___1: /* CIL Label */ ;
    }
    skip: 
#line 80
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 178
  i = 1;
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 178
    if (! (i <= m)) {
#line 178
      goto while_break___1;
    }
    {
#line 181
    tmp___17 = fabs(*(phi + i));
    }
#line 181
    if (tmp___17 < 1e-10) {
#line 181
      goto __Cont;
    }
#line 183
    row___0 = *(mip->row + i);
#line 185
    if (row___0->type != 5) {
#line 185
      tmp___18 = 1;
    } else {
      {
#line 185
      _glp_lib_xassert("row->type != GLP_FX", "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c",
                       185);
#line 185
      tmp___18 = 1;
      }
    }
#line 187
    aij = row___0->ptr;
    {
#line 187
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 187
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 187
        goto while_break___2;
      }
#line 188
      *(phi + (m + (aij->col)->j)) += *(phi + i) * aij->val;
#line 187
      aij = aij->r_next;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 178
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 192
  len = 0;
#line 193
  j = 1;
  {
#line 193
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 193
    if (! (j <= n)) {
#line 193
      goto while_break___3;
    }
    {
#line 195
    tmp___19 = fabs(*(phi + (m + j)));
    }
#line 195
    if (tmp___19 < 1e-10) {
#line 195
      goto __Cont___0;
    }
#line 197
    col___0 = *(mip->col + j);
#line 198
    if (col___0->type == 5) {
#line 200
      rhs -= *(phi + (m + j)) * col___0->lb;
    } else {
#line 203
      len ++;
#line 204
      *(ind + len) = j;
#line 205
      *(val + len) = *(phi + (m + j));
    }
    __Cont___0: /* CIL Label */ 
#line 193
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 208
  tmp___20 = fabs(rhs);
  }
#line 208
  if (tmp___20 < 1e-12) {
#line 208
    rhs = 0.0;
  }
#line 211
  k = 1;
  {
#line 211
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 211
    if (! (k <= len)) {
#line 211
      goto while_break___4;
    }
    {
#line 212
    tmp___21 = fabs(*(val + k));
    }
#line 212
    if (tmp___21 < 1e-03) {
#line 212
      goto fini;
    }
    {
#line 213
    tmp___22 = fabs(*(val + k));
    }
#line 213
    if (tmp___22 > 1e+03) {
#line 213
      goto fini;
    }
#line 211
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 220
  glp_ios_add_row(tree, (char const   *)((void *)0), 1, 0, len, (int const   *)ind,
                  (double const   *)val, 2, rhs);
  }
  fini: 
#line 223
  return;
}
}
#line 228 "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c"
static int fcmp___0(void const   *p1 , void const   *p2 ) 
{ 
  struct var  const  *v1 ;
  struct var  const  *v2 ;

  {
#line 229
  v1 = (struct var  const  *)p1;
#line 229
  v2 = (struct var  const  *)p2;
#line 230
  if (v1->f > v2->f) {
#line 230
    return (-1);
  }
#line 231
  if (v1->f < v2->f) {
#line 231
    return (1);
  }
#line 232
  return (0);
}
}
#line 235 "/home/wslee/benchmarks/glpk-4.38/src/glpios05.c"
void _glp_ios_gmi_gen(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  struct var *var ;
  int k ;
  int nv ;
  int j ;
  int size ;
  struct worka _worka ;
  struct worka *worka ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  GLPCOL *col ;
  double frac ;
  double tmp___3 ;
  int tmp___4 ;

  {
  {
#line 237
  mip = tree->mip;
#line 238
  m = mip->m;
#line 239
  n = mip->n;
#line 242
  worka = & _worka;
#line 244
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(struct var ));
#line 244
  var = (struct var *)tmp;
#line 245
  tmp___0 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 245
  worka->ind = (int *)tmp___0;
#line 246
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 246
  worka->val = (double *)tmp___1;
#line 247
  tmp___2 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 247
  worka->phi = (double *)tmp___2;
#line 251
  nv = 0;
#line 252
  j = 1;
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (j <= n)) {
#line 252
      goto while_break;
    }
#line 253
    col = *(mip->col + j);
#line 255
    if (col->kind != 2) {
#line 255
      goto __Cont;
    }
#line 256
    if (col->type == 5) {
#line 256
      goto __Cont;
    }
#line 257
    if (col->stat != 1) {
#line 257
      goto __Cont;
    }
    {
#line 258
    tmp___3 = floor(col->prim);
#line 258
    frac = col->prim - tmp___3;
    }
#line 259
    if (0.05 <= frac) {
#line 259
      if (! (frac <= 0.95)) {
#line 259
        goto __Cont;
      }
    } else {
#line 259
      goto __Cont;
    }
#line 261
    nv ++;
#line 261
    (var + nv)->j = j;
#line 261
    (var + nv)->f = frac;
    __Cont: /* CIL Label */ 
#line 252
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  qsort((void *)(var + 1), (size_t )nv, (size_t )sizeof(struct var ), & fcmp___0);
#line 267
  size = glp_ios_pool_size(tree);
#line 268
  k = 1;
  }
  {
#line 268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 268
    if (! (k <= nv)) {
#line 268
      goto while_break___0;
    }
    {
#line 269
    tmp___4 = glp_ios_pool_size(tree);
    }
#line 269
    if (tmp___4 - size >= 50) {
#line 269
      goto while_break___0;
    }
    {
#line 270
    gen_cut(tree, worka, (var + k)->j);
#line 268
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 273
  _glp_lib_xfree((void *)var);
#line 274
  _glp_lib_xfree((void *)worka->ind);
#line 275
  _glp_lib_xfree((void *)worka->val);
#line 276
  _glp_lib_xfree((void *)worka->phi);
  }
#line 277
  return;
}
}
#line 542 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
void _glp_ios_check_vec(IOSVEC *v ) ;
#line 546
double _glp_ios_get_vj(IOSVEC *v , int j ) ;
#line 45 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
IOSVEC *_glp_ios_create_vec(int n ) 
{ 
  IOSVEC *v ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 47
  if (n >= 0) {
#line 47
    tmp = 1;
  } else {
    {
#line 47
    _glp_lib_xassert("n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     47);
#line 47
    tmp = 1;
    }
  }
  {
#line 48
  tmp___0 = _glp_lib_xmalloc((int )sizeof(IOSVEC ));
#line 48
  v = (IOSVEC *)tmp___0;
#line 49
  v->n = n;
#line 50
  v->nnz = 0;
#line 51
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 51
  v->pos = (int *)tmp___1;
#line 52
  memset((void *)(v->pos + 1), 0, (size_t )((unsigned long )n * sizeof(int )));
#line 53
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 53
  v->ind = (int *)tmp___2;
#line 54
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 54
  v->val = (double *)tmp___3;
  }
#line 55
  return (v);
}
}
#line 77 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
void _glp_ios_check_vec(IOSVEC *v ) 
{ 
  int j ;
  int k ;
  int nnz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 79
  if (v->n >= 0) {
#line 79
    tmp = 1;
  } else {
    {
#line 79
    _glp_lib_xassert("v->n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     79);
#line 79
    tmp = 1;
    }
  }
#line 80
  nnz = 0;
#line 81
  j = v->n;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (j >= 1)) {
#line 81
      goto while_break;
    }
#line 82
    k = *(v->pos + j);
#line 83
    if (0 <= k) {
#line 83
      if (k <= v->nnz) {
#line 83
        tmp___0 = 1;
      } else {
        {
#line 83
        _glp_lib_xassert("0 <= k && k <= v->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                         83);
#line 83
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 83
      _glp_lib_xassert("0 <= k && k <= v->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                       83);
#line 83
      tmp___0 = 1;
      }
    }
#line 84
    if (k != 0) {
#line 85
      if (*(v->ind + k) == j) {
#line 85
        tmp___1 = 1;
      } else {
        {
#line 85
        _glp_lib_xassert("v->ind[k] == j", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                         85);
#line 85
        tmp___1 = 1;
        }
      }
#line 86
      nnz ++;
    }
#line 81
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  if (v->nnz == nnz) {
#line 89
    tmp___2 = 1;
  } else {
    {
#line 89
    _glp_lib_xassert("v->nnz == nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     89);
#line 89
    tmp___2 = 1;
    }
  }
#line 90
  return;
}
}
#line 108 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
double _glp_ios_get_vj(IOSVEC *v , int j ) 
{ 
  int k ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 110
  if (1 <= j) {
#line 110
    if (j <= v->n) {
#line 110
      tmp = 1;
    } else {
      {
#line 110
      _glp_lib_xassert("1 <= j && j <= v->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                       110);
#line 110
      tmp = 1;
      }
    }
  } else {
    {
#line 110
    _glp_lib_xassert("1 <= j && j <= v->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     110);
#line 110
    tmp = 1;
    }
  }
#line 111
  k = *(v->pos + j);
#line 112
  if (0 <= k) {
#line 112
    if (k <= v->nnz) {
#line 112
      tmp___0 = 1;
    } else {
      {
#line 112
      _glp_lib_xassert("0 <= k && k <= v->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                       112);
#line 112
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 112
    _glp_lib_xassert("0 <= k && k <= v->nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     112);
#line 112
    tmp___0 = 1;
    }
  }
#line 113
  if (k == 0) {
#line 113
    tmp___1 = 0.0;
  } else {
#line 113
    tmp___1 = *(v->val + k);
  }
#line 113
  return (tmp___1);
}
}
#line 131 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
void _glp_ios_set_vj(IOSVEC *v , int j , double val ) 
{ 
  int k ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 133
  if (1 <= j) {
#line 133
    if (j <= v->n) {
#line 133
      tmp = 1;
    } else {
      {
#line 133
      _glp_lib_xassert("1 <= j && j <= v->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                       133);
#line 133
      tmp = 1;
      }
    }
  } else {
    {
#line 133
    _glp_lib_xassert("1 <= j && j <= v->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     133);
#line 133
    tmp = 1;
    }
  }
#line 134
  k = *(v->pos + j);
#line 135
  if (val == 0.0) {
#line 136
    if (k != 0) {
#line 138
      *(v->pos + j) = 0;
#line 139
      if (k < v->nnz) {
#line 140
        *(v->pos + *(v->ind + v->nnz)) = k;
#line 141
        *(v->ind + k) = *(v->ind + v->nnz);
#line 142
        *(v->val + k) = *(v->val + v->nnz);
      }
#line 144
      (v->nnz) --;
    }
  } else {
#line 148
    if (k == 0) {
#line 150
      (v->nnz) ++;
#line 150
      k = v->nnz;
#line 151
      *(v->pos + j) = k;
#line 152
      *(v->ind + k) = j;
    }
#line 154
    *(v->val + k) = val;
  }
#line 156
  return;
}
}
#line 174 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
void _glp_ios_clear_vec(IOSVEC *v ) 
{ 
  int k ;

  {
#line 176
  k = 1;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (k <= v->nnz)) {
#line 176
      goto while_break;
    }
#line 177
    *(v->pos + *(v->ind + k)) = 0;
#line 176
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  v->nnz = 0;
#line 179
  return;
}
}
#line 198 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
void _glp_ios_clean_vec(IOSVEC *v , double eps ) 
{ 
  int k ;
  int nnz ;
  double tmp ;
  double tmp___0 ;

  {
#line 200
  nnz = 0;
#line 201
  k = 1;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (k <= v->nnz)) {
#line 201
      goto while_break;
    }
    {
#line 202
    tmp = fabs(*(v->val + k));
    }
#line 202
    if (tmp == 0.0) {
#line 204
      *(v->pos + *(v->ind + k)) = 0;
    } else {
      {
#line 202
      tmp___0 = fabs(*(v->val + k));
      }
#line 202
      if (tmp___0 < eps) {
#line 204
        *(v->pos + *(v->ind + k)) = 0;
      } else {
#line 208
        nnz ++;
#line 209
        *(v->pos + *(v->ind + k)) = nnz;
#line 210
        *(v->ind + nnz) = *(v->ind + k);
#line 211
        *(v->val + nnz) = *(v->val + k);
      }
    }
#line 201
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  v->nnz = nnz;
#line 215
  return;
}
}
#line 233 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
void _glp_ios_copy_vec(IOSVEC *x , IOSVEC *y ) 
{ 
  int j ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 235
  if ((unsigned long )x != (unsigned long )y) {
#line 235
    tmp = 1;
  } else {
    {
#line 235
    _glp_lib_xassert("x != y", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     235);
#line 235
    tmp = 1;
    }
  }
#line 236
  if (x->n == y->n) {
#line 236
    tmp___0 = 1;
  } else {
    {
#line 236
    _glp_lib_xassert("x->n == y->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     236);
#line 236
    tmp___0 = 1;
    }
  }
  {
#line 237
  _glp_ios_clear_vec(x);
#line 238
  x->nnz = y->nnz;
#line 239
  memcpy((void */* __restrict  */)(x->ind + 1), (void const   */* __restrict  */)(y->ind + 1),
         (size_t )((unsigned long )x->nnz * sizeof(int )));
#line 240
  memcpy((void */* __restrict  */)(x->val + 1), (void const   */* __restrict  */)(y->val + 1),
         (size_t )((unsigned long )x->nnz * sizeof(double )));
#line 241
  j = 1;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (j <= x->nnz)) {
#line 241
      goto while_break;
    }
#line 242
    *(x->pos + *(x->ind + j)) = j;
#line 241
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 264 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
void _glp_ios_linear_comb(IOSVEC *x , double a , IOSVEC *y ) 
{ 
  int j ;
  int k ;
  double xj ;
  double yj ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 267
  if ((unsigned long )x != (unsigned long )y) {
#line 267
    tmp = 1;
  } else {
    {
#line 267
    _glp_lib_xassert("x != y", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     267);
#line 267
    tmp = 1;
    }
  }
#line 268
  if (x->n == y->n) {
#line 268
    tmp___0 = 1;
  } else {
    {
#line 268
    _glp_lib_xassert("x->n == y->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c",
                     268);
#line 268
    tmp___0 = 1;
    }
  }
#line 269
  k = 1;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (k <= y->nnz)) {
#line 269
      goto while_break;
    }
    {
#line 270
    j = *(y->ind + k);
#line 271
    xj = _glp_ios_get_vj(x, j);
#line 272
    yj = *(y->val + k);
#line 273
    _glp_ios_set_vj(x, j, xj + a * yj);
#line 269
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 293 "/home/wslee/benchmarks/glpk-4.38/src/glpios04.c"
void _glp_ios_delete_vec(IOSVEC *v ) 
{ 


  {
  {
#line 295
  _glp_lib_xfree((void *)v->pos);
#line 296
  _glp_lib_xfree((void *)v->ind);
#line 297
  _glp_lib_xfree((void *)v->val);
#line 298
  _glp_lib_xfree((void *)v);
  }
#line 299
  return;
}
}
#line 647 "./../include/glpk.h"
void glp_ios_del_row(glp_tree___0 *tree , int i ) ;
#line 656
void glp_ios_branch_upon(glp_tree___0 *tree , int j , int sel ) ;
#line 436 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
void _glp_ios_revive_node(glp_tree___0 *tree , int p ) ;
#line 440
void _glp_ios_freeze_node(glp_tree___0 *tree ) ;
#line 444
void _glp_ios_clone_node(glp_tree___0 *tree , int p , int nnn , int *ref ) ;
#line 448
void _glp_ios_delete_node(glp_tree___0 *tree , int p ) ;
#line 456
void _glp_ios_eval_degrad(glp_tree___0 *tree , int j , double *dn , double *up ) ;
#line 460
double _glp_ios_round_bound(glp_tree___0 *tree , double bound ) ;
#line 468
int _glp_ios_best_node(glp_tree___0 *tree ) ;
#line 472
double _glp_ios_relative_gap(glp_tree___0 *tree ) ;
#line 476
int _glp_ios_solve_node(glp_tree___0 *tree ) ;
#line 490
IOSCUT *_glp_ios_find_row(IOSPOOL *pool , int i ) ;
#line 498
void _glp_ios_clear_pool(glp_tree___0 *tree , IOSPOOL *pool ) ;
#line 510
int _glp_ios_preprocess_node(glp_tree___0 *tree , int max_pass ) ;
#line 514
int _glp_ios_driver(glp_tree___0 *tree ) ;
#line 51 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void show_progress___0(glp_tree___0 *tree , int bingo ) 
{ 
  int p ;
  double temp ;
  char best_mip[50] ;
  char best_bound[50] ;
  char *rho ;
  char rel_gap[50] ;
  int tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 56
  if ((tree->mip)->mip_stat == 2) {
    {
#line 57
    sprintf((char */* __restrict  */)(best_mip), (char const   */* __restrict  */)"%17.9e",
            (tree->mip)->mip_obj);
    }
  } else {
    {
#line 59
    sprintf((char */* __restrict  */)(best_mip), (char const   */* __restrict  */)"%17s",
            "not found yet");
    }
  }
  {
#line 62
  p = _glp_ios_best_node(tree);
  }
#line 64
  if (p == 0) {
    {
#line 65
    sprintf((char */* __restrict  */)(best_bound), (char const   */* __restrict  */)"%17s",
            "tree is empty");
    }
  } else {
#line 67
    temp = ((tree->slot + p)->node)->bound;
#line 68
    if (temp == - 1.7976931348623157e+308) {
      {
#line 69
      sprintf((char */* __restrict  */)(best_bound), (char const   */* __restrict  */)"%17s",
              "-inf");
      }
    } else
#line 70
    if (temp == 1.7976931348623157e+308) {
      {
#line 71
      sprintf((char */* __restrict  */)(best_bound), (char const   */* __restrict  */)"%17s",
              "+inf");
      }
    } else {
      {
#line 73
      sprintf((char */* __restrict  */)(best_bound), (char const   */* __restrict  */)"%17.9e",
              temp);
      }
    }
  }
  {
#line 77
  if ((tree->mip)->dir == 1) {
#line 77
    goto case_1;
  }
#line 78
  if ((tree->mip)->dir == 2) {
#line 78
    goto case_2;
  }
#line 79
  goto switch_default;
  case_1: /* CIL Label */ 
#line 77
  rho = (char *)">=";
#line 77
  goto switch_break;
  case_2: /* CIL Label */ 
#line 78
  rho = (char *)"<=";
#line 78
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 79
  if ((unsigned long )tree != (unsigned long )tree) {
#line 79
    tmp = 1;
  } else {
    {
#line 79
    _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     79);
#line 79
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 82
  temp = _glp_ios_relative_gap(tree);
  }
#line 83
  if (temp == 0.0) {
    {
#line 84
    sprintf((char */* __restrict  */)(rel_gap), (char const   */* __restrict  */)"  0.0%%");
    }
  } else
#line 85
  if (temp < 0.001) {
    {
#line 86
    sprintf((char */* __restrict  */)(rel_gap), (char const   */* __restrict  */)"< 0.1%%");
    }
  } else
#line 87
  if (temp <= 9.999) {
    {
#line 88
    sprintf((char */* __restrict  */)(rel_gap), (char const   */* __restrict  */)"%5.1f%%",
            100.0 * temp);
    }
  } else {
    {
#line 90
    sprintf((char */* __restrict  */)(rel_gap), (char const   */* __restrict  */)"%6s",
            "");
    }
  }
#line 92
  if (bingo) {
#line 92
    tmp___0 = ">>>>>";
  } else {
#line 92
    tmp___0 = "mip =";
  }
  {
#line 92
  _glp_lib_xprintf("+%6d: %s %s %s %s %s (%d; %d)\n", (tree->mip)->it_cnt, tmp___0,
                   best_mip, rho, best_bound, rel_gap, tree->a_cnt, tree->t_cnt - tree->n_cnt);
#line 95
  tree->tm_lag = _glp_lib_xtime();
  }
#line 96
  return;
}
}
#line 113 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static int is_branch_hopeful(glp_tree___0 *tree , int p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 114
  if (1 <= p) {
#line 114
    if (p <= tree->nslots) {
#line 114
      tmp = 1;
    } else {
      {
#line 114
      _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       114);
#line 114
      tmp = 1;
      }
    }
  } else {
    {
#line 114
    _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     114);
#line 114
    tmp = 1;
    }
  }
#line 115
  if ((unsigned long )(tree->slot + p)->node != (unsigned long )((void *)0)) {
#line 115
    tmp___0 = 1;
  } else {
    {
#line 115
    _glp_lib_xassert("tree->slot[p].node != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     115);
#line 115
    tmp___0 = 1;
    }
  }
  {
#line 116
  tmp___1 = _glp_ios_is_hopeful(tree, ((tree->slot + p)->node)->bound);
  }
#line 116
  return (tmp___1);
}
}
#line 119 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static int is_curr_node_hopeful(glp_tree___0 *tree ) 
{ 
  int tmp ;

  {
  {
#line 120
  tmp = _glp_ios_is_hopeful(tree, (tree->curr)->bound);
  }
#line 120
  return (tmp);
}
}
#line 154 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void check_integrality(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int j ;
  int type ;
  int ii_cnt ;
  double lb ;
  double ub ;
  double x ;
  double temp1 ;
  double temp2 ;
  double ii_sum ;
  GLPCOL *col ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 155
  mip = tree->mip;
#line 156
  ii_cnt = 0;
#line 157
  ii_sum = 0.0;
#line 159
  j = 1;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (j <= mip->n)) {
#line 159
      goto while_break;
    }
#line 160
    col = *(mip->col + j);
#line 161
    *(tree->non_int + j) = 0;
#line 163
    if (col->kind != 2) {
#line 163
      goto __Cont;
    }
#line 165
    if (col->stat != 1) {
#line 165
      goto __Cont;
    }
#line 167
    type = col->type;
#line 167
    lb = col->lb;
#line 167
    ub = col->ub;
#line 169
    x = col->prim;
#line 172
    if (type == 2) {
#line 172
      goto _L;
    } else
#line 172
    if (type == 4) {
#line 172
      goto _L;
    } else
#line 172
    if (type == 5) {
      _L: /* CIL Label */ 
#line 173
      temp1 = lb - (double )(tree->parm)->tol_int;
#line 174
      temp2 = lb + (double )(tree->parm)->tol_int;
#line 175
      if (temp1 <= x) {
#line 175
        if (x <= temp2) {
#line 175
          goto __Cont;
        }
      }
#line 180
      if (x < lb) {
#line 180
        goto __Cont;
      }
    }
#line 185
    if (type == 3) {
#line 185
      goto _L___0;
    } else
#line 185
    if (type == 4) {
#line 185
      goto _L___0;
    } else
#line 185
    if (type == 5) {
      _L___0: /* CIL Label */ 
#line 186
      temp1 = ub - (double )(tree->parm)->tol_int;
#line 187
      temp2 = ub + (double )(tree->parm)->tol_int;
#line 188
      if (temp1 <= x) {
#line 188
        if (x <= temp2) {
#line 188
          goto __Cont;
        }
      }
#line 193
      if (x > ub) {
#line 193
        goto __Cont;
      }
    }
    {
#line 198
    tmp = floor(x + 0.5);
#line 198
    temp1 = tmp - (double )(tree->parm)->tol_int;
#line 199
    tmp___0 = floor(x + 0.5);
#line 199
    temp2 = tmp___0 + (double )(tree->parm)->tol_int;
    }
#line 200
    if (temp1 <= x) {
#line 200
      if (x <= temp2) {
#line 200
        goto __Cont;
      }
    }
    {
#line 202
    *(tree->non_int + j) = 1;
#line 204
    ii_cnt ++;
#line 206
    tmp___1 = floor(x);
#line 206
    temp1 = x - tmp___1;
#line 207
    tmp___2 = ceil(x);
#line 207
    temp2 = tmp___2 - x;
    }
#line 208
    if (temp1 > 0.0) {
#line 208
      if (temp2 > 0.0) {
#line 208
        tmp___3 = 1;
      } else {
        {
#line 208
        _glp_lib_xassert("temp1 > 0.0 && temp2 > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         208);
#line 208
        tmp___3 = 1;
        }
      }
    } else {
      {
#line 208
      _glp_lib_xassert("temp1 > 0.0 && temp2 > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       208);
#line 208
      tmp___3 = 1;
      }
    }
#line 209
    if (temp1 <= temp2) {
#line 209
      tmp___4 = temp1;
    } else {
#line 209
      tmp___4 = temp2;
    }
#line 209
    ii_sum += tmp___4;
    __Cont: /* CIL Label */ 
#line 159
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 212
    tmp___5 = 1;
  } else {
    {
#line 212
    _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     212);
#line 212
    tmp___5 = 1;
    }
  }
#line 213
  (tree->curr)->ii_cnt = ii_cnt;
#line 214
  (tree->curr)->ii_sum = ii_sum;
#line 216
  if ((tree->parm)->msg_lev >= 4) {
#line 217
    if (ii_cnt == 0) {
      {
#line 218
      _glp_lib_xprintf("There are no fractional columns\n");
      }
    } else
#line 219
    if (ii_cnt == 1) {
      {
#line 220
      _glp_lib_xprintf("There is one fractional column, integer infeasibility is %.3e\n",
                       ii_sum);
      }
    } else {
      {
#line 223
      _glp_lib_xprintf("There are %d fractional columns, integer infeasibility is %.3e\n",
                       ii_cnt, ii_sum);
      }
    }
  }
#line 226
  return;
}
}
#line 236 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void record_solution(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int i ;
  int j ;
  GLPROW *row ;
  GLPCOL *col ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 237
  mip = tree->mip;
#line 239
  mip->mip_stat = 2;
#line 240
  mip->mip_obj = mip->obj_val;
#line 241
  i = 1;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (i <= mip->m)) {
#line 241
      goto while_break;
    }
#line 242
    row = *(mip->row + i);
#line 243
    row->mipx = row->prim;
#line 241
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  j = 1;
  {
#line 245
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 245
    if (! (j <= mip->n)) {
#line 245
      goto while_break___0;
    }
#line 246
    col = *(mip->col + j);
    {
#line 248
    if (col->kind == 1) {
#line 248
      goto case_1;
    }
#line 251
    if (col->kind == 2) {
#line 251
      goto case_2;
    }
#line 255
    goto switch_default;
    case_1: /* CIL Label */ 
#line 249
    col->mipx = col->prim;
#line 250
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 253
    col->mipx = floor(col->prim + 0.5);
    }
#line 254
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 256
    if ((unsigned long )col != (unsigned long )col) {
#line 256
      tmp = 1;
    } else {
      {
#line 256
      _glp_lib_xassert("col != col", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       256);
#line 256
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 245
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 259
  (tree->sol_cnt) ++;
#line 260
  return;
}
}
#line 271 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void fix_by_red_cost(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int j ;
  int stat ;
  int fixed ;
  double obj ;
  double lb ;
  double ub ;
  double dj ;
  int tmp ;
  int tmp___0 ;
  GLPCOL *col ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 272
  mip = tree->mip;
#line 273
  fixed = 0;
#line 276
  if ((tree->mip)->mip_stat == 2) {
#line 276
    tmp = 1;
  } else {
    {
#line 276
    _glp_lib_xassert("tree->mip->mip_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     276);
#line 276
    tmp = 1;
    }
  }
#line 278
  if (mip->pbs_stat == 2) {
#line 278
    if (mip->dbs_stat == 2) {
#line 278
      tmp___0 = 1;
    } else {
      {
#line 278
      _glp_lib_xassert("mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       278);
#line 278
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 278
    _glp_lib_xassert("mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     278);
#line 278
    tmp___0 = 1;
    }
  }
#line 280
  obj = mip->obj_val;
#line 282
  j = 1;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (j <= mip->n)) {
#line 282
      goto while_break;
    }
#line 283
    col = *(mip->col + j);
#line 285
    if (col->kind != 2) {
#line 285
      goto __Cont;
    }
#line 287
    lb = col->lb;
#line 287
    ub = col->ub;
#line 289
    stat = col->stat;
#line 289
    dj = col->dual;
    {
#line 292
    if (mip->dir == 1) {
#line 292
      goto case_1;
    }
#line 307
    if (mip->dir == 2) {
#line 307
      goto case_2;
    }
#line 322
    goto switch_default;
    case_1: /* CIL Label */ 
#line 294
    if (stat == 2) {
#line 296
      if (dj < 0.0) {
#line 296
        dj = 0.0;
      }
#line 297
      if (obj + dj >= mip->mip_obj) {
        {
#line 298
        glp_set_col_bnds(mip, j, 5, lb, lb);
#line 298
        fixed ++;
        }
      }
    } else
#line 300
    if (stat == 3) {
#line 302
      if (dj > 0.0) {
#line 302
        dj = 0.0;
      }
#line 303
      if (obj - dj >= mip->mip_obj) {
        {
#line 304
        glp_set_col_bnds(mip, j, 5, ub, ub);
#line 304
        fixed ++;
        }
      }
    }
#line 306
    goto switch_break;
    case_2: /* CIL Label */ 
#line 309
    if (stat == 2) {
#line 311
      if (dj > 0.0) {
#line 311
        dj = 0.0;
      }
#line 312
      if (obj + dj <= mip->mip_obj) {
        {
#line 313
        glp_set_col_bnds(mip, j, 5, lb, lb);
#line 313
        fixed ++;
        }
      }
    } else
#line 315
    if (stat == 3) {
#line 317
      if (dj < 0.0) {
#line 317
        dj = 0.0;
      }
#line 318
      if (obj - dj <= mip->mip_obj) {
        {
#line 319
        glp_set_col_bnds(mip, j, 5, ub, ub);
#line 319
        fixed ++;
        }
      }
    }
#line 321
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 323
    if ((unsigned long )tree != (unsigned long )tree) {
#line 323
      tmp___1 = 1;
    } else {
      {
#line 323
      _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       323);
#line 323
      tmp___1 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 282
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if ((tree->parm)->msg_lev >= 4) {
#line 327
    if (! (fixed == 0)) {
#line 329
      if (fixed == 1) {
        {
#line 330
        _glp_lib_xprintf("One column has been fixed by reduced cost\n");
        }
      } else {
        {
#line 332
        _glp_lib_xprintf("%d columns have been fixed by reduced costs\n", fixed);
        }
      }
    }
  }
#line 337
  if (mip->pbs_stat == 2) {
#line 337
    if (mip->dbs_stat == 2) {
#line 337
      tmp___2 = 1;
    } else {
      {
#line 337
      _glp_lib_xassert("mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       337);
#line 337
      tmp___2 = 1;
      }
    }
  } else {
    {
#line 337
    _glp_lib_xassert("mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     337);
#line 337
    tmp___2 = 1;
    }
  }
#line 338
  return;
}
}
#line 355 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void branch_first(glp_tree___0 *tree ) 
{ 
  glp_prob *lp ;
  int n ;
  int j ;
  int next ;
  double beta ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 356
  lp = tree->mip;
#line 357
  n = lp->n;
#line 361
  j = 1;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (j <= n)) {
#line 361
      goto while_break;
    }
#line 362
    if (*(tree->non_int + j)) {
#line 362
      goto while_break;
    }
#line 361
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  if (1 <= j) {
#line 363
    if (j <= n) {
#line 363
      tmp = 1;
    } else {
      {
#line 363
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       363);
#line 363
      tmp = 1;
      }
    }
  } else {
    {
#line 363
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     363);
#line 363
    tmp = 1;
    }
  }
  {
#line 365
  beta = _glp_lpx_get_col_prim(lp, j);
#line 366
  tmp___0 = floor(beta);
#line 366
  tmp___1 = ceil(beta);
  }
#line 366
  if (beta - tmp___0 < tmp___1 - beta) {
#line 367
    next = 1;
  } else {
#line 369
    next = 2;
  }
  {
#line 371
  glp_ios_branch_upon(tree, j, next);
  }
#line 372
  return;
}
}
#line 385 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void branch_last(glp_tree___0 *tree ) 
{ 
  glp_prob *lp ;
  int n ;
  int j ;
  int next ;
  double beta ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 386
  lp = tree->mip;
#line 387
  n = lp->n;
#line 391
  j = n;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (j >= 1)) {
#line 391
      goto while_break;
    }
#line 392
    if (*(tree->non_int + j)) {
#line 392
      goto while_break;
    }
#line 391
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (1 <= j) {
#line 393
    if (j <= n) {
#line 393
      tmp = 1;
    } else {
      {
#line 393
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       393);
#line 393
      tmp = 1;
      }
    }
  } else {
    {
#line 393
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     393);
#line 393
    tmp = 1;
    }
  }
  {
#line 395
  beta = _glp_lpx_get_col_prim(lp, j);
#line 396
  tmp___0 = floor(beta);
#line 396
  tmp___1 = ceil(beta);
  }
#line 396
  if (beta - tmp___0 < tmp___1 - beta) {
#line 397
    next = 1;
  } else {
#line 399
    next = 2;
  }
  {
#line 401
  glp_ios_branch_upon(tree, j, next);
  }
#line 402
  return;
}
}
#line 443 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void branch_drtom(glp_tree___0 *tree ) 
{ 
  glp_prob *lp ;
  int m ;
  int n ;
  int *non_int ;
  int j ;
  int jj ;
  int k ;
  int t ;
  int next ;
  int kase ;
  int len ;
  int stat ;
  int *ind ;
  double x ;
  double dk ;
  double alfa ;
  double delta_j ;
  double delta_k ;
  double delta_z ;
  double dz_dn ;
  double dz_up ;
  double dd_dn ;
  double dd_up ;
  double degrad ;
  double *val ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  int tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
#line 444
  lp = tree->mip;
#line 445
  m = lp->m;
#line 446
  n = lp->n;
#line 447
  non_int = tree->non_int;
#line 456
  tmp = _glp_lpx_get_status(lp);
  }
#line 456
  if (tmp == 180) {
#line 456
    tmp___0 = 1;
  } else {
    {
#line 456
    _glp_lib_xassert("lpx_get_status(lp) == LPX_OPT", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     456);
#line 456
    tmp___0 = 1;
    }
  }
  {
#line 458
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 458
  ind = (int *)tmp___1;
#line 459
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 459
  val = (double *)tmp___2;
#line 481
  jj = 0;
#line 481
  degrad = - 1.0;
#line 484
  j = 1;
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! (j <= n)) {
#line 484
      goto while_break;
    }
#line 486
    if (! *(non_int + j)) {
#line 486
      goto __Cont;
    }
    {
#line 493
    x = _glp_lpx_get_col_prim(lp, j);
#line 496
    len = _glp_lpx_eval_tab_row(lp, m + j, ind, val);
#line 511
    kase = -1;
    }
    {
#line 511
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 511
      if (! (kase <= 1)) {
#line 511
        goto while_break___0;
      }
      {
#line 521
      k = _glp_lpx_dual_ratio_test(lp, len, (int const   *)ind, (double const   *)val,
                                   kase, 1e-8);
      }
#line 526
      if (k == 0) {
#line 527
        if ((tree->mip)->dir == 1) {
#line 527
          delta_z = 1.7976931348623157e+308;
        } else {
#line 527
          delta_z = - 1.7976931348623157e+308;
        }
#line 529
        goto skip;
      }
#line 537
      t = 1;
      {
#line 537
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 537
        if (! (t <= len)) {
#line 537
          goto while_break___1;
        }
#line 537
        if (*(ind + t) == k) {
#line 537
          goto while_break___1;
        }
#line 537
        t ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 538
      if (1 <= t) {
#line 538
        if (t <= len) {
#line 538
          tmp___3 = 1;
        } else {
          {
#line 538
          _glp_lib_xassert("1 <= t && t <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                           538);
#line 538
          tmp___3 = 1;
          }
        }
      } else {
        {
#line 538
        _glp_lib_xassert("1 <= t && t <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         538);
#line 538
        tmp___3 = 1;
        }
      }
#line 539
      alfa = *(val + t);
#line 543
      if (kase < 0) {
        {
#line 543
        tmp___4 = floor(x);
#line 543
        tmp___6 = tmp___4;
        }
      } else {
        {
#line 543
        tmp___5 = ceil(x);
#line 543
        tmp___6 = tmp___5;
        }
      }
#line 543
      delta_j = tmp___6 - x;
#line 548
      delta_k = delta_j / alfa;
#line 552
      if (k > m) {
        {
#line 552
        tmp___9 = _glp_lpx_get_col_kind(tree->mip, k - m);
        }
#line 552
        if (tmp___9 == 161) {
          {
#line 554
          tmp___7 = floor(delta_k + 0.5);
#line 554
          tmp___8 = fabs(delta_k - tmp___7);
          }
#line 554
          if (tmp___8 > 1e-3) {
#line 555
            if (delta_k > 0.0) {
              {
#line 556
              delta_k = ceil(delta_k);
              }
            } else {
              {
#line 558
              delta_k = floor(delta_k);
              }
            }
          }
        }
      }
#line 563
      if (k <= m) {
        {
#line 564
        stat = _glp_lpx_get_row_stat(lp, k);
#line 565
        dk = _glp_lpx_get_row_dual(lp, k);
        }
      } else {
        {
#line 568
        stat = _glp_lpx_get_col_stat(lp, k - m);
#line 569
        dk = _glp_lpx_get_col_dual(lp, k - m);
        }
      }
      {
#line 575
      if ((tree->mip)->dir == 1) {
#line 575
        goto case_1;
      }
#line 580
      if ((tree->mip)->dir == 2) {
#line 580
        goto case_2;
      }
#line 585
      goto switch_default;
      case_1: /* CIL Label */ 
#line 576
      if (stat == 141) {
#line 576
        if (dk < 0.0) {
#line 578
          dk = 0.0;
        } else {
#line 576
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 576
      if (stat == 142) {
#line 576
        if (dk > 0.0) {
#line 578
          dk = 0.0;
        } else {
#line 576
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 576
      if (stat == 143) {
#line 578
        dk = 0.0;
      }
#line 579
      goto switch_break;
      case_2: /* CIL Label */ 
#line 581
      if (stat == 141) {
#line 581
        if (dk > 0.0) {
#line 583
          dk = 0.0;
        } else {
#line 581
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 581
      if (stat == 142) {
#line 581
        if (dk < 0.0) {
#line 583
          dk = 0.0;
        } else {
#line 581
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 581
      if (stat == 143) {
#line 583
        dk = 0.0;
      }
#line 584
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 586
      if ((unsigned long )tree != (unsigned long )tree) {
#line 586
        tmp___10 = 1;
      } else {
        {
#line 586
        _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         586);
#line 586
        tmp___10 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 593
      delta_z = dk * delta_k;
      skip: 
      {
#line 598
      if ((tree->mip)->dir == 1) {
#line 598
        goto case_1___0;
      }
#line 599
      if ((tree->mip)->dir == 2) {
#line 599
        goto case_2___0;
      }
#line 600
      goto switch_default___0;
      case_1___0: /* CIL Label */ 
#line 598
      if (delta_z >= 0.0) {
#line 598
        tmp___11 = 1;
      } else {
        {
#line 598
        _glp_lib_xassert("delta_z >= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         598);
#line 598
        tmp___11 = 1;
        }
      }
#line 598
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 599
      if (delta_z <= 0.0) {
#line 599
        tmp___12 = 1;
      } else {
        {
#line 599
        _glp_lib_xassert("delta_z <= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         599);
#line 599
        tmp___12 = 1;
        }
      }
#line 599
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 600
      if ((unsigned long )tree != (unsigned long )tree) {
#line 600
        tmp___13 = 1;
      } else {
        {
#line 600
        _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         600);
#line 600
        tmp___13 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 604
      if (kase < 0) {
#line 604
        dz_dn = delta_z;
      } else {
#line 604
        dz_up = delta_z;
      }
#line 511
      kase += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 617
    tmp___16 = fabs(dz_dn);
    }
#line 617
    if (degrad < tmp___16) {
#line 617
      goto _L___3;
    } else {
      {
#line 617
      tmp___17 = fabs(dz_up);
      }
#line 617
      if (degrad < tmp___17) {
        _L___3: /* CIL Label */ 
        {
#line 618
        jj = j;
#line 619
        tmp___14 = fabs(dz_dn);
#line 619
        tmp___15 = fabs(dz_up);
        }
#line 619
        if (tmp___14 < tmp___15) {
          {
#line 621
          next = 1;
#line 622
          degrad = fabs(dz_up);
          }
        } else {
          {
#line 626
          next = 2;
#line 627
          degrad = fabs(dz_dn);
          }
        }
#line 630
        dd_dn = dz_dn;
#line 630
        dd_up = dz_up;
#line 634
        if (degrad == 1.7976931348623157e+308) {
#line 634
          goto while_break;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 484
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 638
  _glp_lib_xfree((void *)ind);
#line 639
  _glp_lib_xfree((void *)val);
  }
#line 644
  if (1 <= jj) {
#line 644
    if (jj <= n) {
#line 644
      tmp___18 = 1;
    } else {
      {
#line 644
      _glp_lib_xassert("1 <= jj && jj <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       644);
#line 644
      tmp___18 = 1;
      }
    }
  } else {
    {
#line 644
    _glp_lib_xassert("1 <= jj && jj <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     644);
#line 644
    tmp___18 = 1;
    }
  }
#line 645
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 646
    _glp_lib_xprintf("branch_drtom: column %d chosen to branch on\n", jj);
#line 647
    tmp___20 = fabs(dd_dn);
    }
#line 647
    if (tmp___20 == 1.7976931348623157e+308) {
      {
#line 648
      _glp_lib_xprintf("branch_drtom: down-branch is infeasible\n");
      }
    } else {
      {
#line 650
      tmp___19 = _glp_lpx_get_obj_val(lp);
#line 650
      _glp_lib_xprintf("branch_drtom: down-branch bound is %.9e\n", tmp___19 + dd_dn);
      }
    }
    {
#line 652
    tmp___22 = fabs(dd_up);
    }
#line 652
    if (tmp___22 == 1.7976931348623157e+308) {
      {
#line 653
      _glp_lib_xprintf("branch_drtom: up-branch   is infeasible\n");
      }
    } else {
      {
#line 655
      tmp___21 = _glp_lpx_get_obj_val(lp);
#line 655
      _glp_lib_xprintf("branch_drtom: up-branch   bound is %.9e\n", tmp___21 + dd_up);
      }
    }
  }
  {
#line 659
  glp_ios_branch_upon(tree, jj, next);
  }
#line 660
  return;
}
}
#line 675 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void branch_mostf(glp_tree___0 *tree ) 
{ 
  glp_prob *lp ;
  int n ;
  int j ;
  int jj ;
  int next ;
  double beta ;
  double most ;
  double temp ;
  double tmp ;
  double tmp___0 ;

  {
#line 676
  lp = tree->mip;
#line 677
  n = lp->n;
#line 681
  jj = 0;
#line 681
  most = 1.7976931348623157e+308;
#line 682
  j = 1;
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! (j <= n)) {
#line 682
      goto while_break;
    }
#line 683
    if (*(tree->non_int + j)) {
      {
#line 684
      beta = _glp_lpx_get_col_prim(lp, j);
#line 685
      tmp = floor(beta);
#line 685
      temp = tmp + 0.5;
#line 686
      tmp___0 = fabs(beta - temp);
      }
#line 686
      if (most > tmp___0) {
        {
#line 687
        jj = j;
#line 687
        most = fabs(beta - temp);
        }
#line 688
        if (beta < temp) {
#line 689
          next = 1;
        } else {
#line 691
          next = 2;
        }
      }
    }
#line 682
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 696
  glp_ios_branch_upon(tree, jj, next);
  }
#line 697
  return;
}
}
#line 726 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static int branch_on(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int n ;
  int j ;
  int next ;
  int type ;
  int dn_type ;
  int up_type ;
  int dn_bad ;
  int up_bad ;
  int p ;
  int ret ;
  int clone[3] ;
  double lb ;
  double ub ;
  double beta ;
  double new_ub ;
  double new_lb ;
  double dn_lp ;
  double up_lp ;
  double dn_bnd ;
  double up_bnd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;

  {
#line 727
  mip = tree->mip;
#line 728
  n = mip->n;
#line 729
  j = tree->br_var;
#line 730
  next = tree->br_sel;
#line 735
  if (1 <= j) {
#line 735
    if (j <= n) {
#line 735
      tmp = 1;
    } else {
      {
#line 735
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       735);
#line 735
      tmp = 1;
      }
    }
  } else {
    {
#line 735
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     735);
#line 735
    tmp = 1;
    }
  }
  {
#line 736
  type = (*(mip->col + j))->type;
#line 737
  lb = (*(mip->col + j))->lb;
#line 738
  ub = (*(mip->col + j))->ub;
#line 739
  beta = (*(mip->col + j))->prim;
#line 741
  new_ub = floor(beta);
#line 742
  new_lb = ceil(beta);
  }
  {
#line 744
  if (type == 1) {
#line 744
    goto case_1;
  }
#line 748
  if (type == 2) {
#line 748
    goto case_2;
  }
#line 754
  if (type == 3) {
#line 754
    goto case_3;
  }
#line 760
  if (type == 4) {
#line 760
    goto case_4;
  }
#line 766
  goto switch_default;
  case_1: /* CIL Label */ 
#line 745
  dn_type = 3;
#line 746
  up_type = 2;
#line 747
  goto switch_break;
  case_2: /* CIL Label */ 
#line 749
  if (lb <= new_ub) {
#line 749
    tmp___0 = 1;
  } else {
    {
#line 749
    _glp_lib_xassert("lb <= new_ub", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     749);
#line 749
    tmp___0 = 1;
    }
  }
#line 750
  if (lb == new_ub) {
#line 750
    dn_type = 5;
  } else {
#line 750
    dn_type = 4;
  }
#line 751
  if (lb + 1.0 <= new_lb) {
#line 751
    tmp___1 = 1;
  } else {
    {
#line 751
    _glp_lib_xassert("lb + 1.0 <= new_lb", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     751);
#line 751
    tmp___1 = 1;
    }
  }
#line 752
  up_type = 2;
#line 753
  goto switch_break;
  case_3: /* CIL Label */ 
#line 755
  if (new_ub <= ub - 1.0) {
#line 755
    tmp___2 = 1;
  } else {
    {
#line 755
    _glp_lib_xassert("new_ub <= ub - 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     755);
#line 755
    tmp___2 = 1;
    }
  }
#line 756
  dn_type = 3;
#line 757
  if (new_lb <= ub) {
#line 757
    tmp___3 = 1;
  } else {
    {
#line 757
    _glp_lib_xassert("new_lb <= ub", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     757);
#line 757
    tmp___3 = 1;
    }
  }
#line 758
  if (new_lb == ub) {
#line 758
    up_type = 5;
  } else {
#line 758
    up_type = 4;
  }
#line 759
  goto switch_break;
  case_4: /* CIL Label */ 
#line 761
  if (lb <= new_ub) {
#line 761
    if (new_ub <= ub - 1.0) {
#line 761
      tmp___4 = 1;
    } else {
      {
#line 761
      _glp_lib_xassert("lb <= new_ub && new_ub <= ub - 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       761);
#line 761
      tmp___4 = 1;
      }
    }
  } else {
    {
#line 761
    _glp_lib_xassert("lb <= new_ub && new_ub <= ub - 1.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     761);
#line 761
    tmp___4 = 1;
    }
  }
#line 762
  if (lb == new_ub) {
#line 762
    dn_type = 5;
  } else {
#line 762
    dn_type = 4;
  }
#line 763
  if (lb + 1.0 <= new_lb) {
#line 763
    if (new_lb <= ub) {
#line 763
      tmp___5 = 1;
    } else {
      {
#line 763
      _glp_lib_xassert("lb + 1.0 <= new_lb && new_lb <= ub", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       763);
#line 763
      tmp___5 = 1;
      }
    }
  } else {
    {
#line 763
    _glp_lib_xassert("lb + 1.0 <= new_lb && new_lb <= ub", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     763);
#line 763
    tmp___5 = 1;
    }
  }
#line 764
  if (new_lb == ub) {
#line 764
    up_type = 5;
  } else {
#line 764
    up_type = 4;
  }
#line 765
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 767
  if (type != type) {
#line 767
    tmp___6 = 1;
  } else {
    {
#line 767
    _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     767);
#line 767
    tmp___6 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 770
  _glp_ios_eval_degrad(tree, j, & dn_lp, & up_lp);
#line 772
  dn_bnd = _glp_ios_round_bound(tree, dn_lp);
#line 773
  up_bnd = _glp_ios_round_bound(tree, up_lp);
#line 775
  tmp___7 = _glp_ios_is_hopeful(tree, dn_bnd);
  }
#line 775
  if (tmp___7) {
#line 775
    tmp___8 = 0;
  } else {
#line 775
    tmp___8 = 1;
  }
  {
#line 775
  dn_bad = tmp___8;
#line 776
  tmp___9 = _glp_ios_is_hopeful(tree, up_bnd);
  }
#line 776
  if (tmp___9) {
#line 776
    tmp___10 = 0;
  } else {
#line 776
    tmp___10 = 1;
  }
#line 776
  up_bad = tmp___10;
#line 777
  if (dn_bad) {
#line 777
    if (up_bad) {
#line 778
      if ((tree->parm)->msg_lev >= 4) {
        {
#line 779
        _glp_lib_xprintf("Both down- and up-branches are hopeless\n");
        }
      }
#line 780
      ret = 2;
#line 781
      goto done;
    } else {
#line 777
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 783
  if (up_bad) {
#line 784
    if ((tree->parm)->msg_lev >= 4) {
      {
#line 785
      _glp_lib_xprintf("Up-branch is hopeless\n");
      }
    }
    {
#line 786
    glp_set_col_bnds(mip, j, dn_type, lb, new_ub);
#line 787
    (tree->curr)->lp_obj = dn_lp;
    }
#line 788
    if (mip->dir == 1) {
#line 789
      if ((tree->curr)->bound < dn_bnd) {
#line 790
        (tree->curr)->bound = dn_bnd;
      }
    } else
#line 792
    if (mip->dir == 2) {
#line 793
      if ((tree->curr)->bound > dn_bnd) {
#line 794
        (tree->curr)->bound = dn_bnd;
      }
    } else
#line 797
    if ((unsigned long )mip != (unsigned long )mip) {
#line 797
      tmp___11 = 1;
    } else {
      {
#line 797
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       797);
#line 797
      tmp___11 = 1;
      }
    }
#line 798
    ret = 1;
#line 799
    goto done;
  } else
#line 801
  if (dn_bad) {
#line 802
    if ((tree->parm)->msg_lev >= 4) {
      {
#line 803
      _glp_lib_xprintf("Down-branch is hopeless\n");
      }
    }
    {
#line 804
    glp_set_col_bnds(mip, j, up_type, new_lb, ub);
#line 805
    (tree->curr)->lp_obj = up_lp;
    }
#line 806
    if (mip->dir == 1) {
#line 807
      if ((tree->curr)->bound < up_bnd) {
#line 808
        (tree->curr)->bound = up_bnd;
      }
    } else
#line 810
    if (mip->dir == 2) {
#line 811
      if ((tree->curr)->bound > up_bnd) {
#line 812
        (tree->curr)->bound = up_bnd;
      }
    } else
#line 815
    if ((unsigned long )mip != (unsigned long )mip) {
#line 815
      tmp___12 = 1;
    } else {
      {
#line 815
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       815);
#line 815
      tmp___12 = 1;
      }
    }
#line 816
    ret = 1;
#line 817
    goto done;
  }
#line 821
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 822
    _glp_lib_xprintf("Branching on column %d, primal value is %.9e\n", j, beta);
    }
  }
#line 825
  if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 825
    tmp___13 = 1;
  } else {
    {
#line 825
    _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     825);
#line 825
    tmp___13 = 1;
    }
  }
  {
#line 826
  p = (tree->curr)->p;
#line 827
  (tree->curr)->br_var = j;
#line 828
  (tree->curr)->br_val = beta;
#line 830
  _glp_ios_freeze_node(tree);
#line 833
  _glp_ios_clone_node(tree, p, 2, clone);
  }
#line 834
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 835
    _glp_lib_xprintf("Node %d begins down branch, node %d begins up branch \n", clone[1],
                     clone[2]);
    }
  }
  {
#line 838
  _glp_ios_revive_node(tree, clone[1]);
#line 839
  glp_set_col_bnds(mip, j, dn_type, lb, new_ub);
#line 840
  (tree->curr)->lp_obj = dn_lp;
  }
#line 841
  if (mip->dir == 1) {
#line 842
    if ((tree->curr)->bound < dn_bnd) {
#line 843
      (tree->curr)->bound = dn_bnd;
    }
  } else
#line 845
  if (mip->dir == 2) {
#line 846
    if ((tree->curr)->bound > dn_bnd) {
#line 847
      (tree->curr)->bound = dn_bnd;
    }
  } else
#line 850
  if ((unsigned long )mip != (unsigned long )mip) {
#line 850
    tmp___14 = 1;
  } else {
    {
#line 850
    _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     850);
#line 850
    tmp___14 = 1;
    }
  }
  {
#line 851
  _glp_ios_freeze_node(tree);
#line 853
  _glp_ios_revive_node(tree, clone[2]);
#line 854
  glp_set_col_bnds(mip, j, up_type, new_lb, ub);
#line 855
  (tree->curr)->lp_obj = up_lp;
  }
#line 856
  if (mip->dir == 1) {
#line 857
    if ((tree->curr)->bound < up_bnd) {
#line 858
      (tree->curr)->bound = up_bnd;
    }
  } else
#line 860
  if (mip->dir == 2) {
#line 861
    if ((tree->curr)->bound > up_bnd) {
#line 862
      (tree->curr)->bound = up_bnd;
    }
  } else
#line 865
  if ((unsigned long )mip != (unsigned long )mip) {
#line 865
    tmp___15 = 1;
  } else {
    {
#line 865
    _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     865);
#line 865
    tmp___15 = 1;
    }
  }
  {
#line 866
  _glp_ios_freeze_node(tree);
  }
#line 868
  if (! (next == 0)) {
#line 870
    if (next == 1) {
      {
#line 871
      _glp_ios_revive_node(tree, clone[1]);
      }
    } else
#line 872
    if (next == 2) {
      {
#line 873
      _glp_ios_revive_node(tree, clone[2]);
      }
    } else
#line 875
    if (next != next) {
#line 875
      tmp___16 = 1;
    } else {
      {
#line 875
      _glp_lib_xassert("next != next", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       875);
#line 875
      tmp___16 = 1;
      }
    }
  }
#line 876
  ret = 0;
  done: 
#line 877
  return (ret);
}
}
#line 889 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void cleanup_the_tree(glp_tree___0 *tree ) 
{ 
  IOSNPD *node ;
  IOSNPD *next_node ;
  int count ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 891
  count = 0;
#line 893
  if ((tree->mip)->mip_stat == 2) {
#line 893
    tmp = 1;
  } else {
    {
#line 893
    _glp_lib_xassert("tree->mip->mip_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     893);
#line 893
    tmp = 1;
    }
  }
#line 895
  node = tree->head;
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 895
      goto while_break;
    }
    {
#line 900
    next_node = node->next;
#line 902
    tmp___0 = is_branch_hopeful(tree, node->p);
    }
#line 902
    if (! tmp___0) {
      {
#line 903
      _glp_ios_delete_node(tree, node->p);
#line 903
      count ++;
      }
    }
#line 895
    node = next_node;
  }
  while_break: /* CIL Label */ ;
  }
#line 905
  if ((tree->parm)->msg_lev >= 4) {
#line 906
    if (count == 1) {
      {
#line 907
      _glp_lib_xprintf("One hopeless branch has been pruned\n");
      }
    } else
#line 908
    if (count > 1) {
      {
#line 909
      _glp_lib_xprintf("%d hopeless branches have been pruned\n", count);
      }
    }
  }
#line 911
  return;
}
}
#line 920 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void btrack_most_feas(glp_tree___0 *tree ) 
{ 
  IOSNPD *node ;
  int p ;
  double best ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 924
  p = 0;
#line 924
  best = 1.7976931348623157e+308;
#line 925
  node = tree->head;
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 925
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 925
      goto while_break;
    }
#line 926
    if ((unsigned long )node->up != (unsigned long )((void *)0)) {
#line 926
      tmp = 1;
    } else {
      {
#line 926
      _glp_lib_xassert("node->up != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       926);
#line 926
      tmp = 1;
      }
    }
#line 927
    if (best > (node->up)->ii_sum) {
#line 928
      p = node->p;
#line 928
      best = (node->up)->ii_sum;
    }
#line 925
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 930
  _glp_ios_revive_node(tree, p);
  }
#line 931
  return;
}
}
#line 940 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void btrack_best_proj(glp_tree___0 *tree ) 
{ 
  IOSNPD *root ;
  IOSNPD *node ;
  int p ;
  double best ;
  double deg ;
  double obj ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 945
  if ((tree->mip)->mip_stat == 2) {
#line 945
    tmp = 1;
  } else {
    {
#line 945
    _glp_lib_xassert("tree->mip->mip_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     945);
#line 945
    tmp = 1;
    }
  }
#line 947
  root = (tree->slot + 1)->node;
#line 948
  if ((unsigned long )root != (unsigned long )((void *)0)) {
#line 948
    tmp___0 = 1;
  } else {
    {
#line 948
    _glp_lib_xassert("root != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     948);
#line 948
    tmp___0 = 1;
    }
  }
#line 951
  if (root->ii_sum > 0.0) {
#line 951
    tmp___1 = 1;
  } else {
    {
#line 951
    _glp_lib_xassert("root->ii_sum > 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     951);
#line 951
    tmp___1 = 1;
    }
  }
#line 952
  deg = ((tree->mip)->mip_obj - root->bound) / root->ii_sum;
#line 954
  p = 0;
#line 954
  best = 1.7976931348623157e+308;
#line 956
  node = tree->head;
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 956
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 956
      goto while_break;
    }
#line 957
    if ((unsigned long )node->up != (unsigned long )((void *)0)) {
#line 957
      tmp___2 = 1;
    } else {
      {
#line 957
      _glp_lib_xassert("node->up != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       957);
#line 957
      tmp___2 = 1;
      }
    }
#line 960
    obj = (node->up)->bound + deg * (node->up)->ii_sum;
#line 961
    if ((tree->mip)->dir == 2) {
#line 961
      obj = - obj;
    }
#line 964
    if (best > obj) {
#line 964
      p = node->p;
#line 964
      best = obj;
    }
#line 956
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 966
  _glp_ios_revive_node(tree, p);
  }
#line 967
  return;
}
}
#line 973 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void btrack_best_node(glp_tree___0 *tree ) 
{ 
  IOSNPD *node ;
  IOSNPD *best ;
  double bound ;
  double eps ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 974
  best = (IOSNPD *)((void *)0);
  {
#line 977
  if ((tree->mip)->dir == 1) {
#line 977
    goto case_1;
  }
#line 995
  if ((tree->mip)->dir == 2) {
#line 995
    goto case_2;
  }
#line 1013
  goto switch_default;
  case_1: /* CIL Label */ 
#line 978
  bound = 1.7976931348623157e+308;
#line 979
  node = tree->head;
  {
#line 979
  while (1) {
    while_continue: /* CIL Label */ ;
#line 979
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 979
      goto while_break;
    }
#line 980
    if (bound > node->bound) {
#line 980
      bound = node->bound;
    }
#line 979
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  if (bound != 1.7976931348623157e+308) {
#line 981
    tmp = 1;
  } else {
    {
#line 981
    _glp_lib_xassert("bound != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     981);
#line 981
    tmp = 1;
    }
  }
  {
#line 982
  tmp___0 = fabs(bound);
#line 982
  eps = 0.001 * (1.0 + tmp___0);
#line 983
  node = tree->head;
  }
  {
#line 983
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 983
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 983
      goto while_break___0;
    }
#line 984
    if (node->bound <= bound + eps) {
#line 985
      if ((unsigned long )node->up != (unsigned long )((void *)0)) {
#line 985
        tmp___1 = 1;
      } else {
        {
#line 985
        _glp_lib_xassert("node->up != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         985);
#line 985
        tmp___1 = 1;
        }
      }
#line 986
      if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 988
        best = node;
      } else
#line 986
      if ((best->up)->ii_sum > (node->up)->ii_sum) {
#line 988
        best = node;
      }
    }
#line 983
    node = node->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 994
  goto switch_break;
  case_2: /* CIL Label */ 
#line 996
  bound = - 1.7976931348623157e+308;
#line 997
  node = tree->head;
  {
#line 997
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 997
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 997
      goto while_break___1;
    }
#line 998
    if (bound < node->bound) {
#line 998
      bound = node->bound;
    }
#line 997
    node = node->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 999
  if (bound != - 1.7976931348623157e+308) {
#line 999
    tmp___2 = 1;
  } else {
    {
#line 999
    _glp_lib_xassert("bound != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     999);
#line 999
    tmp___2 = 1;
    }
  }
  {
#line 1000
  tmp___3 = fabs(bound);
#line 1000
  eps = 0.001 * (1.0 + tmp___3);
#line 1001
  node = tree->head;
  }
  {
#line 1001
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1001
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1001
      goto while_break___2;
    }
#line 1002
    if (node->bound >= bound - eps) {
#line 1003
      if ((unsigned long )node->up != (unsigned long )((void *)0)) {
#line 1003
        tmp___4 = 1;
      } else {
        {
#line 1003
        _glp_lib_xassert("node->up != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1003);
#line 1003
        tmp___4 = 1;
        }
      }
#line 1004
      if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 1006
        best = node;
      } else
#line 1004
      if ((best->up)->ii_sum > (node->up)->ii_sum) {
#line 1006
        best = node;
      }
    }
#line 1001
    node = node->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1012
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1014
  if ((unsigned long )tree != (unsigned long )tree) {
#line 1014
    tmp___5 = 1;
  } else {
    {
#line 1014
    _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1014);
#line 1014
    tmp___5 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1016
  if ((unsigned long )best != (unsigned long )((void *)0)) {
#line 1016
    tmp___6 = 1;
  } else {
    {
#line 1016
    _glp_lib_xassert("best != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1016);
#line 1016
    tmp___6 = 1;
    }
  }
  {
#line 1017
  _glp_ios_revive_node(tree, best->p);
  }
#line 1018
  return;
}
}
#line 1039 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void display_cut_info(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int i ;
  int gmi ;
  int mir ;
  int cov ;
  int clq ;
  int app ;
  GLPROW *row ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1041
  mip = tree->mip;
#line 1042
  gmi = 0;
#line 1042
  mir = 0;
#line 1042
  cov = 0;
#line 1042
  clq = 0;
#line 1042
  app = 0;
#line 1043
  i = mip->m;
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    if (! (i > 0)) {
#line 1043
      goto while_break;
    }
#line 1045
    row = *(mip->row + i);
#line 1047
    if ((int )row->origin == 2) {
#line 1048
      if ((int )row->klass == 1) {
#line 1049
        gmi ++;
      } else
#line 1050
      if ((int )row->klass == 2) {
#line 1051
        mir ++;
      } else
#line 1052
      if ((int )row->klass == 3) {
#line 1053
        cov ++;
      } else
#line 1054
      if ((int )row->klass == 4) {
#line 1055
        clq ++;
      } else {
#line 1057
        app ++;
      }
    }
#line 1043
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  if ((((gmi + mir) + cov) + clq) + app > 0) {
#line 1061
    if (gmi > 0) {
      {
#line 1061
      _glp_lib_xprintf(" gmi:%3d", gmi);
      }
    }
#line 1062
    if (mir > 0) {
      {
#line 1062
      _glp_lib_xprintf(" mir:%3d", mir);
      }
    }
#line 1063
    if (cov > 0) {
      {
#line 1063
      _glp_lib_xprintf(" cov:%3d", cov);
      }
    }
#line 1064
    if (clq > 0) {
      {
#line 1064
      _glp_lib_xprintf(" clq:%3d", clq);
      }
    }
#line 1065
    if (app > 0) {
      {
#line 1065
      _glp_lib_xprintf(" app:%3d", app);
      }
    }
    {
#line 1066
    _glp_lib_xprintf("\n");
    }
  }
#line 1068
  return;
}
}
#line 1110
static void generate_cuts(glp_tree___0 *tree ) ;
#line 1111
static void separation(glp_tree___0 *tree ) ;
#line 1113 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
int _glp_ios_driver(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int p ;
  int p_stat ;
  int d_stat ;
  int ret ;
  xlong_t ttt ;
  int tmp ;
  xlong_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int level ;
  int tmp___10 ;
  int tmp___11 ;
  xlong_t tmp___12 ;
  double tmp___13 ;
  xlong_t total ;
  double tmp___14 ;
  xlong_t tmp___15 ;
  double tmp___16 ;
  xlong_t tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  xlong_t tmp___20 ;
  double tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  double bound ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;

  {
#line 1114
  mip = tree->mip;
#line 1116
  ttt = tree->tm_beg;
  back: 
#line 1121
  if ((unsigned long )tree->curr == (unsigned long )((void *)0)) {
#line 1121
    tmp = 1;
  } else {
    {
#line 1121
    _glp_lib_xassert("tree->curr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1121);
#line 1121
    tmp = 1;
    }
  }
#line 1123
  if ((unsigned long )tree->head == (unsigned long )((void *)0)) {
#line 1124
    if ((tree->parm)->msg_lev >= 4) {
      {
#line 1125
      _glp_lib_xprintf("Active list is empty!\n");
      }
    }
    {
#line 1126
    tmp___0 = _glp_dmp_in_use(tree->pool);
    }
#line 1126
    if (tmp___0.lo == 0) {
#line 1126
      tmp___1 = 1;
    } else {
      {
#line 1126
      _glp_lib_xassert("dmp_in_use(tree->pool).lo == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1126);
#line 1126
      tmp___1 = 1;
      }
    }
#line 1127
    ret = 0;
#line 1128
    goto done;
  }
#line 1131
  tree->just_selected = 1;
#line 1135
  if ((unsigned long )(tree->parm)->cb_func != (unsigned long )((void *)0)) {
#line 1136
    if (tree->reason == 0) {
#line 1136
      tmp___2 = 1;
    } else {
      {
#line 1136
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1136);
#line 1136
      tmp___2 = 1;
      }
    }
#line 1137
    if ((unsigned long )tree->btrack == (unsigned long )((void *)0)) {
#line 1137
      tmp___3 = 1;
    } else {
      {
#line 1137
      _glp_lib_xassert("tree->btrack == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1137);
#line 1137
      tmp___3 = 1;
      }
    }
    {
#line 1138
    tree->reason = 6;
#line 1139
    (*((tree->parm)->cb_func))(tree, (void *)(tree->parm)->cb_info);
#line 1140
    tree->reason = 0;
    }
#line 1141
    if (tree->terminate) {
#line 1142
      ret = 13;
#line 1143
      goto done;
    }
#line 1145
    if ((unsigned long )tree->btrack != (unsigned long )((void *)0)) {
      {
#line 1147
      _glp_ios_revive_node(tree, (tree->btrack)->p);
#line 1148
      tree->btrack = (IOSNPD *)((void *)0);
      }
#line 1149
      goto loop;
    }
  }
#line 1153
  if (tree->a_cnt == 1) {
#line 1154
    if ((unsigned long )(tree->head)->next == (unsigned long )((void *)0)) {
#line 1154
      tmp___4 = 1;
    } else {
      {
#line 1154
      _glp_lib_xassert("tree->head->next == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1154);
#line 1154
      tmp___4 = 1;
      }
    }
    {
#line 1155
    _glp_ios_revive_node(tree, (tree->head)->p);
    }
  } else {
    {
#line 1159
    if ((tree->parm)->bt_tech == 1) {
#line 1159
      goto case_1;
    }
#line 1164
    if ((tree->parm)->bt_tech == 2) {
#line 1164
      goto case_2;
    }
#line 1169
    if ((tree->parm)->bt_tech == 3) {
#line 1169
      goto case_3;
    }
#line 1177
    if ((tree->parm)->bt_tech == 4) {
#line 1177
      goto case_4;
    }
#line 1187
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1161
    if ((unsigned long )tree->tail != (unsigned long )((void *)0)) {
#line 1161
      tmp___5 = 1;
    } else {
      {
#line 1161
      _glp_lib_xassert("tree->tail != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1161);
#line 1161
      tmp___5 = 1;
      }
    }
    {
#line 1162
    _glp_ios_revive_node(tree, (tree->tail)->p);
    }
#line 1163
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1166
    if ((unsigned long )tree->head != (unsigned long )((void *)0)) {
#line 1166
      tmp___6 = 1;
    } else {
      {
#line 1166
      _glp_lib_xassert("tree->head != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1166);
#line 1166
      tmp___6 = 1;
      }
    }
    {
#line 1167
    _glp_ios_revive_node(tree, (tree->head)->p);
    }
#line 1168
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1174
    btrack_best_node(tree);
    }
#line 1176
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1178
    if (mip->mip_stat == 1) {
      {
#line 1180
      btrack_most_feas(tree);
      }
    } else {
      {
#line 1184
      btrack_best_proj(tree);
      }
    }
#line 1186
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1188
    if ((unsigned long )tree != (unsigned long )tree) {
#line 1188
      tmp___7 = 1;
    } else {
      {
#line 1188
      _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1188);
#line 1188
      tmp___7 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  loop: 
#line 1196
  if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 1196
    tmp___8 = 1;
  } else {
    {
#line 1196
    _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1196);
#line 1196
    tmp___8 = 1;
    }
  }
#line 1197
  if (tree->solved == 0) {
#line 1197
    tmp___9 = 1;
  } else {
    {
#line 1197
    _glp_lib_xassert("tree->solved == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1197);
#line 1197
    tmp___9 = 1;
    }
  }
#line 1199
  tree->round = 0;
#line 1202
  p = (tree->curr)->p;
#line 1203
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 1204
    level = ((tree->slot + p)->node)->level;
#line 1205
    _glp_lib_xprintf("------------------------------------------------------------------------\n");
#line 1207
    _glp_lib_xprintf("Processing node %d at level %d\n", p, level);
    }
  }
#line 1211
  if (p == 1) {
#line 1212
    if ((tree->parm)->gmi_cuts == 1) {
#line 1213
      if ((tree->parm)->msg_lev >= 3) {
        {
#line 1214
        _glp_lib_xprintf("Gomory\'s cuts enabled\n");
        }
      }
    }
#line 1216
    if ((tree->parm)->mir_cuts == 1) {
#line 1217
      if ((tree->parm)->msg_lev >= 3) {
        {
#line 1218
        _glp_lib_xprintf("MIR cuts enabled\n");
        }
      }
#line 1219
      if ((unsigned long )tree->mir_gen == (unsigned long )((void *)0)) {
#line 1219
        tmp___10 = 1;
      } else {
        {
#line 1219
        _glp_lib_xassert("tree->mir_gen == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1219);
#line 1219
        tmp___10 = 1;
        }
      }
      {
#line 1220
      tree->mir_gen = _glp_ios_mir_init(tree);
      }
    }
#line 1222
    if ((tree->parm)->cov_cuts == 1) {
#line 1223
      if ((tree->parm)->msg_lev >= 3) {
        {
#line 1224
        _glp_lib_xprintf("Cover cuts enabled\n");
        }
      }
    }
#line 1226
    if ((tree->parm)->clq_cuts == 1) {
#line 1227
      if ((unsigned long )tree->clq_gen == (unsigned long )((void *)0)) {
#line 1227
        tmp___11 = 1;
      } else {
        {
#line 1227
        _glp_lib_xassert("tree->clq_gen == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1227);
#line 1227
        tmp___11 = 1;
        }
      }
#line 1228
      if ((tree->parm)->msg_lev >= 3) {
        {
#line 1229
        _glp_lib_xprintf("Clique cuts enabled\n");
        }
      }
      {
#line 1230
      tree->clq_gen = _glp_ios_clq_init(tree);
      }
    }
  }
  more: 
#line 1239
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 1243
    show_progress___0(tree, 0);
    }
  } else
#line 1239
  if ((tree->parm)->msg_lev >= 2) {
    {
#line 1239
    tmp___12 = _glp_lib_xtime();
#line 1239
    tmp___13 = _glp_lib_xdifftime(tmp___12, tree->tm_lag);
    }
#line 1239
    if ((double )((tree->parm)->out_frq - 1) <= 1000.0 * tmp___13) {
      {
#line 1243
      show_progress___0(tree, 0);
      }
    }
  }
#line 1244
  if ((tree->parm)->msg_lev >= 3) {
    {
#line 1244
    tmp___17 = _glp_lib_xtime();
#line 1244
    tmp___18 = _glp_lib_xdifftime(tmp___17, ttt);
    }
#line 1244
    if (tmp___18 >= 60.0) {
      {
#line 1247
      _glp_lib_mem_usage((int *)((void *)0), (int *)((void *)0), & total, (xlong_t *)((void *)0));
#line 1248
      tmp___14 = _glp_lib_xltod(total);
#line 1248
      tmp___15 = _glp_lib_xtime();
#line 1248
      tmp___16 = _glp_lib_xdifftime(tmp___15, tree->tm_beg);
#line 1248
      _glp_lib_xprintf("Time used: %.1f secs.  Memory used: %.1f Mb.\n", tmp___16,
                       tmp___14 / 1048576.0);
#line 1250
      ttt = _glp_lib_xtime();
      }
    }
  }
#line 1255
  if ((tree->parm)->mip_gap > (double const   )0.0) {
    {
#line 1255
    tmp___19 = _glp_ios_relative_gap(tree);
    }
#line 1255
    if (tmp___19 <= (double )(tree->parm)->mip_gap) {
#line 1257
      if ((tree->parm)->msg_lev >= 4) {
        {
#line 1258
        _glp_lib_xprintf("Relative gap tolerance reached; search terminated \n");
        }
      }
#line 1260
      ret = 14;
#line 1261
      goto done;
    }
  }
#line 1265
  if ((tree->parm)->tm_lim < 2147483647) {
    {
#line 1265
    tmp___20 = _glp_lib_xtime();
#line 1265
    tmp___21 = _glp_lib_xdifftime(tmp___20, tree->tm_beg);
    }
#line 1265
    if ((double )((tree->parm)->tm_lim - 1) <= 1000.0 * tmp___21) {
#line 1268
      if ((tree->parm)->msg_lev >= 4) {
        {
#line 1269
        _glp_lib_xprintf("Time limit exhausted; search terminated\n");
        }
      }
#line 1270
      ret = 9;
#line 1271
      goto done;
    }
  }
  {
#line 1276
  if ((tree->parm)->pp_tech == 0) {
#line 1276
    goto case_0;
  }
#line 1278
  if ((tree->parm)->pp_tech == 1) {
#line 1278
    goto case_1___0;
  }
#line 1284
  if ((tree->parm)->pp_tech == 2) {
#line 1284
    goto case_2___0;
  }
#line 1288
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 1277
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 1279
  if ((tree->curr)->level == 0) {
    {
#line 1280
    tmp___22 = _glp_ios_preprocess_node(tree, 99);
    }
#line 1280
    if (tmp___22) {
#line 1281
      goto fath;
    }
  }
#line 1283
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 1285
  if ((tree->curr)->level == 0) {
#line 1285
    tmp___23 = 99;
  } else {
#line 1285
    tmp___23 = 10;
  }
  {
#line 1285
  tmp___24 = _glp_ios_preprocess_node(tree, tmp___23);
  }
#line 1285
  if (tmp___24) {
#line 1286
    goto fath;
  }
#line 1287
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1289
  if ((unsigned long )tree != (unsigned long )tree) {
#line 1289
    tmp___25 = 1;
  } else {
    {
#line 1289
    _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1289);
#line 1289
    tmp___25 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 1293
  if ((unsigned long )(tree->parm)->cb_func != (unsigned long )((void *)0)) {
#line 1294
    if (tree->reason == 0) {
#line 1294
      tmp___26 = 1;
    } else {
      {
#line 1294
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1294);
#line 1294
      tmp___26 = 1;
      }
    }
    {
#line 1295
    tree->reason = 7;
#line 1296
    (*((tree->parm)->cb_func))(tree, (void *)(tree->parm)->cb_info);
#line 1297
    tree->reason = 0;
    }
#line 1298
    if (tree->terminate) {
#line 1299
      ret = 13;
#line 1300
      goto done;
    }
  }
  {
#line 1304
  tmp___27 = is_curr_node_hopeful(tree);
  }
#line 1304
  if (! tmp___27) {
#line 1306
    goto fath;
  }
#line 1329
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 1330
    _glp_lib_xprintf("Solving LP relaxation...\n");
    }
  }
  {
#line 1331
  ret = _glp_ios_solve_node(tree);
#line 1332
  (tree->solved) ++;
  }
  {
#line 1336
  if (ret == 7) {
#line 1336
    goto case_7;
  }
#line 1336
  if (ret == 6) {
#line 1336
    goto case_7;
  }
#line 1336
  if (ret == 0) {
#line 1336
    goto case_7;
  }
#line 1338
  goto switch_default___1;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 1337
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1339
  if ((tree->parm)->msg_lev >= 1) {
    {
#line 1340
    _glp_lib_xprintf("ios_driver: unable to solve current LP relaxation; glp_simplex returned %d\n",
                     ret);
    }
  }
#line 1342
  ret = 5;
#line 1343
  goto done;
  switch_break___1: /* CIL Label */ ;
  }
#line 1346
  p_stat = mip->pbs_stat;
#line 1347
  d_stat = mip->dbs_stat;
#line 1348
  if (p_stat == 2) {
#line 1348
    if (d_stat == 2) {
#line 1350
      if ((tree->parm)->msg_lev >= 4) {
        {
#line 1351
        _glp_lib_xprintf("Found optimal solution to LP relaxation\n");
        }
      }
    } else {
#line 1348
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1357
  if (d_stat == 4) {
#line 1362
    if ((tree->parm)->msg_lev >= 1) {
      {
#line 1367
      _glp_lib_xprintf("ios_driver: current LP relaxation has no dual feasible solution\n");
      }
    }
#line 1370
    ret = 5;
#line 1371
    goto done;
  } else
#line 1373
  if (p_stat == 3) {
#line 1373
    if (d_stat == 2) {
#line 1376
      if (mip->mip_stat == 2) {
#line 1376
        tmp___28 = 1;
      } else {
        {
#line 1376
        _glp_lib_xassert("mip->mip_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1376);
#line 1376
        tmp___28 = 1;
        }
      }
#line 1377
      if ((tree->parm)->msg_lev >= 4) {
        {
#line 1378
        _glp_lib_xprintf("LP relaxation has no solution better than incumbent objective value\n");
        }
      }
#line 1381
      goto fath;
    } else {
#line 1373
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1383
  if (p_stat == 4) {
#line 1385
    if ((tree->parm)->msg_lev >= 4) {
      {
#line 1386
      _glp_lib_xprintf("LP relaxation has no feasible solution\n");
      }
    }
#line 1388
    goto fath;
  } else
#line 1392
  if ((unsigned long )mip != (unsigned long )mip) {
#line 1392
    tmp___29 = 1;
  } else {
    {
#line 1392
    _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1392);
#line 1392
    tmp___29 = 1;
    }
  }
#line 1396
  if (p_stat == 2) {
#line 1396
    if (d_stat == 2) {
#line 1396
      tmp___30 = 1;
    } else {
      {
#line 1396
      _glp_lib_xassert("p_stat == GLP_FEAS && d_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1396);
#line 1396
      tmp___30 = 1;
      }
    }
  } else {
    {
#line 1396
    _glp_lib_xassert("p_stat == GLP_FEAS && d_stat == GLP_FEAS", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1396);
#line 1396
    tmp___30 = 1;
    }
  }
#line 1398
  if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 1398
    tmp___31 = 1;
  } else {
    {
#line 1398
    _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1398);
#line 1398
    tmp___31 = 1;
    }
  }
  {
#line 1399
  (tree->curr)->lp_obj = (tree->mip)->obj_val;
#line 1406
  bound = (tree->mip)->obj_val;
#line 1409
  bound = _glp_ios_round_bound(tree, bound);
  }
#line 1410
  if (mip->dir == 1) {
#line 1411
    if ((tree->curr)->bound < bound) {
#line 1412
      (tree->curr)->bound = bound;
    }
  } else
#line 1414
  if (mip->dir == 2) {
#line 1415
    if ((tree->curr)->bound > bound) {
#line 1416
      (tree->curr)->bound = bound;
    }
  } else
#line 1419
  if ((unsigned long )mip != (unsigned long )mip) {
#line 1419
    tmp___32 = 1;
  } else {
    {
#line 1419
    _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1419);
#line 1419
    tmp___32 = 1;
    }
  }
#line 1420
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 1421
    _glp_lib_xprintf("Local bound is %.9e\n", bound);
    }
  }
  {
#line 1427
  tmp___33 = is_branch_hopeful(tree, p);
  }
#line 1427
  if (! tmp___33) {
#line 1428
    if ((tree->parm)->msg_lev >= 4) {
      {
#line 1429
      _glp_lib_xprintf("Current branch is hopeless and can be pruned\n");
      }
    }
#line 1430
    goto fath;
  }
#line 1434
  if ((unsigned long )(tree->parm)->cb_func != (unsigned long )((void *)0)) {
#line 1436
    if (tree->reason == 0) {
#line 1436
      tmp___34 = 1;
    } else {
      {
#line 1436
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1436);
#line 1436
      tmp___34 = 1;
      }
    }
    {
#line 1437
    tree->reason = 1;
#line 1438
    (*((tree->parm)->cb_func))(tree, (void *)(tree->parm)->cb_info);
#line 1439
    tree->reason = 0;
    }
#line 1440
    if (tree->terminate) {
#line 1441
      ret = 13;
#line 1442
      goto done;
    }
#line 1457
    if (tree->reopt) {
#line 1458
      tree->reopt = 0;
#line 1459
      goto more;
    }
  }
  {
#line 1464
  check_integrality(tree);
  }
#line 1467
  if ((tree->curr)->ii_cnt == 0) {
#line 1468
    if ((tree->parm)->msg_lev >= 4) {
      {
#line 1469
      _glp_lib_xprintf("New integer feasible solution found\n");
      }
    }
    {
#line 1470
    record_solution(tree);
    }
#line 1471
    if ((tree->parm)->msg_lev >= 2) {
      {
#line 1472
      show_progress___0(tree, 1);
      }
    }
#line 1479
    if ((unsigned long )(& display_cut_info) == (unsigned long )(& display_cut_info)) {
#line 1479
      tmp___35 = 1;
    } else {
      {
#line 1479
      _glp_lib_xassert("display_cut_info == display_cut_info", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1479);
#line 1479
      tmp___35 = 1;
      }
    }
#line 1482
    if ((unsigned long )(tree->parm)->cb_func != (unsigned long )((void *)0)) {
#line 1483
      if (tree->reason == 0) {
#line 1483
        tmp___36 = 1;
      } else {
        {
#line 1483
        _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1483);
#line 1483
        tmp___36 = 1;
        }
      }
      {
#line 1484
      tree->reason = 2;
#line 1485
      (*((tree->parm)->cb_func))(tree, (void *)(tree->parm)->cb_info);
#line 1486
      tree->reason = 0;
      }
#line 1487
      if (tree->terminate) {
#line 1488
        ret = 13;
#line 1489
        goto done;
      }
    }
#line 1493
    goto fath;
  }
#line 1499
  if (mip->mip_stat == 2) {
    {
#line 1500
    fix_by_red_cost(tree);
    }
  }
#line 1503
  if ((tree->parm)->fp_heur) {
#line 1504
    if (tree->reason == 0) {
#line 1504
      tmp___37 = 1;
    } else {
      {
#line 1504
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1504);
#line 1504
      tmp___37 = 1;
      }
    }
    {
#line 1505
    tree->reason = 3;
#line 1506
    _glp_ios_feas_pump(tree);
#line 1507
    tree->reason = 0;
#line 1509
    tmp___38 = is_branch_hopeful(tree, p);
    }
#line 1509
    if (! tmp___38) {
#line 1510
      if ((tree->parm)->msg_lev >= 4) {
        {
#line 1511
        _glp_lib_xprintf("Current branch became hopeless and can be pruned\n");
        }
      }
#line 1513
      goto fath;
    }
  }
#line 1519
  if ((unsigned long )(tree->parm)->cb_func != (unsigned long )((void *)0)) {
#line 1520
    if (tree->reason == 0) {
#line 1520
      tmp___39 = 1;
    } else {
      {
#line 1520
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1520);
#line 1520
      tmp___39 = 1;
      }
    }
    {
#line 1521
    tree->reason = 3;
#line 1522
    (*((tree->parm)->cb_func))(tree, (void *)(tree->parm)->cb_info);
#line 1523
    tree->reason = 0;
    }
#line 1524
    if (tree->terminate) {
#line 1525
      ret = 13;
#line 1526
      goto done;
    }
    {
#line 1529
    tmp___40 = is_branch_hopeful(tree, p);
    }
#line 1529
    if (! tmp___40) {
#line 1530
      if ((tree->parm)->msg_lev >= 4) {
        {
#line 1531
        _glp_lib_xprintf("Current branch became hopeless and can be pruned\n");
        }
      }
#line 1533
      goto fath;
    }
  }
#line 1536
  (tree->round) ++;
#line 1538
  if ((unsigned long )tree->local != (unsigned long )((void *)0)) {
#line 1538
    tmp___41 = 1;
  } else {
    {
#line 1538
    _glp_lib_xassert("tree->local != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1538);
#line 1538
    tmp___41 = 1;
    }
  }
#line 1539
  if ((tree->local)->size == 0) {
#line 1539
    tmp___42 = 1;
  } else {
    {
#line 1539
    _glp_lib_xassert("tree->local->size == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1539);
#line 1539
    tmp___42 = 1;
    }
  }
#line 1541
  if (tree->reason == 0) {
#line 1541
    tmp___43 = 1;
  } else {
    {
#line 1541
    _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1541);
#line 1541
    tmp___43 = 1;
    }
  }
  {
#line 1542
  tree->reason = 4;
#line 1543
  generate_cuts(tree);
#line 1544
  tree->reason = 0;
  }
#line 1548
  if ((unsigned long )(tree->parm)->cb_func != (unsigned long )((void *)0)) {
#line 1549
    if (tree->reason == 0) {
#line 1549
      tmp___44 = 1;
    } else {
      {
#line 1549
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1549);
#line 1549
      tmp___44 = 1;
      }
    }
    {
#line 1550
    tree->reason = 4;
#line 1551
    (*((tree->parm)->cb_func))(tree, (void *)(tree->parm)->cb_info);
#line 1552
    tree->reason = 0;
    }
#line 1553
    if (tree->terminate) {
#line 1554
      ret = 13;
#line 1555
      goto done;
    }
  }
#line 1560
  if ((tree->local)->size > 0) {
#line 1561
    if (tree->reason == 0) {
#line 1561
      tmp___45 = 1;
    } else {
      {
#line 1561
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1561);
#line 1561
      tmp___45 = 1;
      }
    }
    {
#line 1562
    tree->reason = 4;
#line 1563
    separation(tree);
#line 1564
    tree->reason = 0;
    }
  }
  {
#line 1567
  _glp_ios_clear_pool(tree, tree->local);
  }
#line 1569
  if (tree->reopt) {
#line 1570
    tree->reopt = 0;
#line 1571
    goto more;
  }
#line 1575
  tree->just_selected = 0;
#line 1579
  if ((unsigned long )(tree->parm)->cb_func != (unsigned long )((void *)0)) {
#line 1580
    if (tree->reason == 0) {
#line 1580
      tmp___46 = 1;
    } else {
      {
#line 1580
      _glp_lib_xassert("tree->reason == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1580);
#line 1580
      tmp___46 = 1;
      }
    }
#line 1581
    if (tree->br_var == 0) {
#line 1581
      tmp___47 = 1;
    } else {
      {
#line 1581
      _glp_lib_xassert("tree->br_var == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1581);
#line 1581
      tmp___47 = 1;
      }
    }
#line 1582
    if (tree->br_sel == 0) {
#line 1582
      tmp___48 = 1;
    } else {
      {
#line 1582
      _glp_lib_xassert("tree->br_sel == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1582);
#line 1582
      tmp___48 = 1;
      }
    }
    {
#line 1583
    tree->reason = 5;
#line 1584
    (*((tree->parm)->cb_func))(tree, (void *)(tree->parm)->cb_info);
#line 1585
    tree->reason = 0;
    }
#line 1586
    if (tree->terminate) {
#line 1587
      ret = 13;
#line 1588
      goto done;
    }
  }
#line 1593
  if (tree->br_var == 0) {
    {
#line 1595
    if ((tree->parm)->br_tech == 1) {
#line 1595
      goto case_1___1;
    }
#line 1599
    if ((tree->parm)->br_tech == 2) {
#line 1599
      goto case_2___1;
    }
#line 1603
    if ((tree->parm)->br_tech == 3) {
#line 1603
      goto case_3___0;
    }
#line 1607
    if ((tree->parm)->br_tech == 4) {
#line 1607
      goto case_4___0;
    }
#line 1611
    if ((tree->parm)->br_tech == 5) {
#line 1611
      goto case_5;
    }
#line 1615
    goto switch_default___2;
    case_1___1: /* CIL Label */ 
    {
#line 1597
    branch_first(tree);
    }
#line 1598
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
    {
#line 1601
    branch_last(tree);
    }
#line 1602
    goto switch_break___2;
    case_3___0: /* CIL Label */ 
    {
#line 1605
    branch_mostf(tree);
    }
#line 1606
    goto switch_break___2;
    case_4___0: /* CIL Label */ 
    {
#line 1609
    branch_drtom(tree);
    }
#line 1610
    goto switch_break___2;
    case_5: /* CIL Label */ 
    {
#line 1613
    _glp_ios_pcost_branch(tree);
    }
#line 1614
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 1616
    if ((unsigned long )tree != (unsigned long )tree) {
#line 1616
      tmp___49 = 1;
    } else {
      {
#line 1616
      _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1616);
#line 1616
      tmp___49 = 1;
      }
    }
    switch_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1620
  ret = branch_on(tree);
#line 1621
  tree->br_var = 0;
#line 1622
  tree->br_sel = 0;
  }
#line 1623
  if (ret == 0) {
#line 1624
    if ((unsigned long )tree->curr == (unsigned long )((void *)0)) {
#line 1627
      goto back;
    } else {
#line 1633
      goto loop;
    }
  } else
#line 1636
  if (ret == 1) {
#line 1637
    goto more;
  } else
#line 1638
  if (! (ret == 2)) {
#line 1641
    if (ret != ret) {
#line 1641
      tmp___50 = 1;
    } else {
      {
#line 1641
      _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1641);
#line 1641
      tmp___50 = 1;
      }
    }
  }
  fath: 
#line 1643
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 1644
    _glp_lib_xprintf("Node %d fathomed\n", p);
    }
  }
  {
#line 1646
  _glp_ios_freeze_node(tree);
#line 1648
  _glp_ios_delete_node(tree, p);
  }
#line 1651
  if (mip->mip_stat == 2) {
    {
#line 1651
    cleanup_the_tree(tree);
    }
  }
#line 1653
  goto back;
  done: 
#line 1696
  if ((tree->parm)->msg_lev >= 2) {
    {
#line 1697
    show_progress___0(tree, 0);
    }
  }
#line 1699
  if ((unsigned long )tree->mir_gen != (unsigned long )((void *)0)) {
    {
#line 1700
    _glp_ios_mir_term(tree->mir_gen);
#line 1700
    tree->mir_gen = (void *)0;
    }
  }
#line 1701
  if ((unsigned long )tree->clq_gen != (unsigned long )((void *)0)) {
    {
#line 1702
    _glp_ios_clq_term(tree->clq_gen);
#line 1702
    tree->clq_gen = (void *)0;
    }
  }
#line 1705
  return (ret);
}
}
#line 1721 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void generate_cuts(glp_tree___0 *tree ) 
{ 
  int i ;
  int added_cuts ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1723
  if (tree->first_attempt) {
#line 1724
    tree->first_attempt = 0;
#line 1725
    tree->max_added_cuts = (tree->mip)->n;
#line 1727
    if (tree->max_added_cuts < 1000) {
#line 1727
      tree->max_added_cuts = 1000;
    }
  }
#line 1730
  if (! ((tree->parm)->mir_cuts == 1)) {
#line 1730
    if (! ((tree->parm)->gmi_cuts == 1)) {
#line 1730
      if (! ((tree->parm)->cov_cuts == 1)) {
#line 1730
        if (! ((tree->parm)->clq_cuts == 1)) {
#line 1733
          goto done;
        }
      }
    }
  }
#line 1734
  if ((tree->curr)->level > 0) {
#line 1734
    if (! tree->just_selected) {
#line 1734
      goto done;
    }
  }
#line 1737
  added_cuts = 0;
#line 1738
  i = tree->orig_m + 1;
  {
#line 1738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1738
    if (! (i <= (tree->mip)->m)) {
#line 1738
      goto while_break;
    }
#line 1739
    if ((int )(*((tree->mip)->row + i))->origin == 2) {
#line 1740
      added_cuts ++;
    }
#line 1738
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1743
  if (added_cuts >= tree->max_added_cuts) {
#line 1743
    goto done;
  }
#line 1747
  if ((tree->parm)->gmi_cuts == 1) {
#line 1748
    if (tree->round <= 5) {
      {
#line 1749
      _glp_ios_gmi_gen(tree);
      }
    }
  }
#line 1751
  if ((tree->parm)->mir_cuts == 1) {
#line 1752
    if ((unsigned long )tree->mir_gen != (unsigned long )((void *)0)) {
#line 1752
      tmp = 1;
    } else {
      {
#line 1752
      _glp_lib_xassert("tree->mir_gen != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1752);
#line 1752
      tmp = 1;
      }
    }
    {
#line 1753
    _glp_ios_mir_gen(tree, tree->mir_gen);
    }
  }
#line 1755
  if ((tree->parm)->cov_cuts == 1) {
    {
#line 1758
    _glp_ios_cov_gen(tree);
    }
  }
#line 1760
  if ((tree->parm)->clq_cuts == 1) {
#line 1761
    if ((unsigned long )tree->clq_gen != (unsigned long )((void *)0)) {
#line 1762
      if ((tree->curr)->level == 0) {
#line 1762
        if (tree->round <= 50) {
          {
#line 1764
          _glp_ios_clq_gen(tree, tree->clq_gen);
          }
        } else {
#line 1762
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1762
      if ((tree->curr)->level > 0) {
#line 1762
        if (tree->round <= 5) {
          {
#line 1764
          _glp_ios_clq_gen(tree, tree->clq_gen);
          }
        }
      }
    }
  }
  done: 
#line 1767
  return;
}
}
#line 1770 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static double efficacy(glp_tree___0 *tree , IOSCUT *cut ) 
{ 
  glp_prob *mip ;
  IOSAIJ *aij ;
  double s ;
  double t ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1771
  mip = tree->mip;
#line 1773
  s = 0.0;
#line 1773
  t = 0.0;
#line 1774
  aij = cut->ptr;
  {
#line 1774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1774
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1774
      goto while_break;
    }
#line 1775
    if (1 <= aij->j) {
#line 1775
      if (aij->j <= mip->n) {
#line 1775
        tmp = 1;
      } else {
        {
#line 1775
        _glp_lib_xassert("1 <= aij->j && aij->j <= mip->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1775);
#line 1775
        tmp = 1;
        }
      }
    } else {
      {
#line 1775
      _glp_lib_xassert("1 <= aij->j && aij->j <= mip->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                       1775);
#line 1775
      tmp = 1;
      }
    }
#line 1776
    s += aij->val * (*(mip->col + aij->j))->prim;
#line 1777
    t += aij->val * aij->val;
#line 1774
    aij = aij->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1779
  temp = sqrt(t);
  }
#line 1780
  if (temp < 2.2204460492503131e-16) {
#line 1780
    temp = 2.2204460492503131e-16;
  }
  {
#line 1782
  if (cut->type == 2) {
#line 1782
    goto case_2;
  }
#line 1785
  if (cut->type == 3) {
#line 1785
    goto case_3;
  }
#line 1788
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1783
  if (s >= cut->rhs) {
#line 1783
    temp = 0.0;
  } else {
#line 1783
    temp = (cut->rhs - s) / temp;
  }
#line 1784
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1786
  if (s <= cut->rhs) {
#line 1786
    temp = 0.0;
  } else {
#line 1786
    temp = (s - cut->rhs) / temp;
  }
#line 1787
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1789
  if ((unsigned long )cut != (unsigned long )cut) {
#line 1789
    tmp___0 = 1;
  } else {
    {
#line 1789
    _glp_lib_xassert("cut != cut", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1789);
#line 1789
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1791
  return (temp);
}
}
#line 1794 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static double parallel(IOSCUT *a , IOSCUT *b , double *work ) 
{ 
  IOSAIJ *aij ;
  double s ;
  double sa ;
  double sb ;
  double temp ;

  {
#line 1796
  s = 0.0;
#line 1796
  sa = 0.0;
#line 1796
  sb = 0.0;
#line 1797
  aij = a->ptr;
  {
#line 1797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1797
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1797
      goto while_break;
    }
#line 1798
    *(work + aij->j) = aij->val;
#line 1799
    sa += aij->val * aij->val;
#line 1797
    aij = aij->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1801
  aij = b->ptr;
  {
#line 1801
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1801
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1801
      goto while_break___0;
    }
#line 1802
    s += *(work + aij->j) * aij->val;
#line 1803
    sb += aij->val * aij->val;
#line 1801
    aij = aij->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1805
  aij = a->ptr;
  {
#line 1805
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1805
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1805
      goto while_break___1;
    }
#line 1806
    *(work + aij->j) = 0.0;
#line 1805
    aij = aij->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1807
  temp = sqrt(sa * sb);
  }
#line 1808
  if (temp < 2.2204460492503131e-16) {
#line 1808
    temp = 2.2204460492503131e-16;
  }
#line 1809
  return (s / temp);
}
}
#line 1814 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static int fcmp___1(void const   *x1 , void const   *x2 ) 
{ 
  struct cut  const  *c1 ;
  struct cut  const  *c2 ;

  {
#line 1815
  c1 = (struct cut  const  *)x1;
#line 1815
  c2 = (struct cut  const  *)x2;
#line 1816
  if (c1->eff > c2->eff) {
#line 1816
    return (-1);
  }
#line 1817
  if (c1->eff < c2->eff) {
#line 1817
    return (1);
  }
#line 1818
  return (0);
}
}
#line 1821 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void sort_pool(glp_tree___0 *tree , IOSPOOL *pool ) 
{ 
  struct cut *cuts ;
  void *tmp ;
  IOSCUT *cut ;
  int c ;
  int tmp___0 ;
  IOSCUT *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1823
  tmp = _glp_lib_xcalloc(1 + pool->size, (int )sizeof(struct cut ));
#line 1823
  cuts = (struct cut *)tmp;
#line 1825
  c = 0;
#line 1826
  cut = pool->head;
  }
  {
#line 1826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1826
    if (! ((unsigned long )cut != (unsigned long )((void *)0))) {
#line 1826
      goto while_break;
    }
    {
#line 1827
    c ++;
#line 1827
    (cuts + c)->cut = cut;
#line 1827
    (cuts + c)->eff = efficacy(tree, cut);
#line 1826
    cut = cut->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1828
  if (c == pool->size) {
#line 1828
    tmp___0 = 1;
  } else {
    {
#line 1828
    _glp_lib_xassert("c == pool->size", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1828);
#line 1828
    tmp___0 = 1;
    }
  }
  {
#line 1829
  qsort((void *)(cuts + 1), (size_t )pool->size, (size_t )sizeof(struct cut ), & fcmp___1);
#line 1830
  tmp___1 = (IOSCUT *)((void *)0);
#line 1830
  pool->tail = tmp___1;
#line 1830
  pool->head = tmp___1;
#line 1831
  c = 1;
  }
  {
#line 1831
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1831
    if (! (c <= pool->size)) {
#line 1831
      goto while_break___0;
    }
#line 1832
    cut = (cuts + c)->cut;
#line 1833
    cut->prev = pool->tail;
#line 1834
    cut->next = (IOSCUT *)((void *)0);
#line 1835
    if ((unsigned long )cut->prev == (unsigned long )((void *)0)) {
#line 1836
      pool->head = cut;
    } else {
#line 1838
      (cut->prev)->next = cut;
    }
#line 1839
    pool->tail = cut;
#line 1831
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1841
  _glp_lib_xfree((void *)cuts);
#line 1842
  pool->ord = 0;
#line 1842
  pool->curr = (IOSCUT *)((void *)0);
  }
#line 1843
  return;
}
}
#line 1846 "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c"
static void separation(glp_tree___0 *tree ) 
{ 
  IOSPOOL *pool ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int j ;
  int num ;
  double *work ;
  void *tmp___3 ;
  int *ind ;
  void *tmp___4 ;
  double *val ;
  void *tmp___5 ;
  IOSCUT *cut ;
  IOSCUT *ccc ;
  double tmp___6 ;
  double tmp___7 ;
  IOSAIJ *aij ;
  int len ;
  int i ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1848
  pool = tree->local;
#line 1849
  if ((unsigned long )pool != (unsigned long )((void *)0)) {
#line 1849
    tmp = 1;
  } else {
    {
#line 1849
    _glp_lib_xassert("pool != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1849);
#line 1849
    tmp = 1;
    }
  }
#line 1850
  if (pool->size > 0) {
#line 1850
    tmp___0 = 1;
  } else {
    {
#line 1850
    _glp_lib_xassert("pool->size > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                     1850);
#line 1850
    tmp___0 = 1;
    }
  }
  {
#line 1853
  sort_pool(tree, pool);
  }
  {
#line 1855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1855
    if (! (pool->size > 10)) {
#line 1855
      goto while_break;
    }
    {
#line 1856
    glp_ios_del_row(tree, pool->size);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1858
  if (tree->first_attempt) {
    {
#line 1859
    tmp___1 = efficacy(tree, pool->head);
#line 1859
    tree->min_eff = 0.7 * tmp___1;
    }
#line 1860
    if (tree->min_eff > 0.02) {
#line 1860
      tree->min_eff = 0.02;
    }
#line 1861
    tree->miss = 0;
  }
  {
#line 1863
  tmp___2 = efficacy(tree, pool->head);
  }
#line 1863
  if (tmp___2 < tree->min_eff) {
#line 1864
    (tree->miss) ++;
#line 1865
    if (tree->miss == 20) {
#line 1865
      tree->miss = 0;
#line 1865
      tree->min_eff -= 0.03;
    }
#line 1866
    goto done;
  }
  {
#line 1870
  tmp___3 = _glp_lib_xcalloc(1 + (tree->mip)->n, (int )sizeof(double ));
#line 1870
  work = (double *)tmp___3;
#line 1871
  tmp___4 = _glp_lib_xcalloc(1 + (tree->mip)->n, (int )sizeof(int ));
#line 1871
  ind = (int *)tmp___4;
#line 1872
  tmp___5 = _glp_lib_xcalloc(1 + (tree->mip)->n, (int )sizeof(double ));
#line 1872
  val = (double *)tmp___5;
#line 1873
  j = 1;
  }
  {
#line 1873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1873
    if (! (j <= (tree->mip)->n)) {
#line 1873
      goto while_break___0;
    }
#line 1873
    *(work + j) = 0.0;
#line 1873
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1874
  num = 1;
  {
#line 1874
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1874
    if (! (num <= pool->size)) {
#line 1874
      goto while_break___1;
    }
    {
#line 1876
    cut = _glp_ios_find_row(pool, num);
#line 1877
    tmp___6 = efficacy(tree, cut);
    }
#line 1877
    if (tmp___6 < tree->min_eff) {
#line 1877
      goto while_break___1;
    }
#line 1879
    ccc = pool->head;
    {
#line 1879
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1879
      if (! ((unsigned long )ccc != (unsigned long )cut)) {
#line 1879
        goto while_break___2;
      }
      {
#line 1880
      tmp___7 = parallel(cut, ccc, work);
      }
#line 1880
      if (tmp___7 > 0.1) {
#line 1880
        goto while_break___2;
      }
#line 1879
      ccc = ccc->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1881
    if ((unsigned long )ccc == (unsigned long )cut) {
      {
#line 1884
      len = 0;
#line 1885
      i = glp_add_rows(tree->mip, 1);
      }
#line 1886
      if ((unsigned long )cut->name != (unsigned long )((void *)0)) {
        {
#line 1887
        glp_set_row_name(tree->mip, i, (char const   *)cut->name);
        }
      }
#line 1888
      if ((int )(*((tree->mip)->row + i))->origin == 2) {
#line 1888
        tmp___8 = 1;
      } else {
        {
#line 1888
        _glp_lib_xassert("tree->mip->row[i]->origin == GLP_RF_CUT", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1888);
#line 1888
        tmp___8 = 1;
        }
      }
#line 1889
      (*((tree->mip)->row + i))->klass = cut->klass;
#line 1890
      aij = cut->ptr;
      {
#line 1890
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1890
        if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1890
          goto while_break___3;
        }
#line 1891
        len ++;
#line 1891
        *(ind + len) = aij->j;
#line 1891
        *(val + len) = aij->val;
#line 1890
        aij = aij->next;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1892
      glp_set_mat_row(tree->mip, i, len, (int const   *)ind, (double const   *)val);
      }
#line 1893
      if (cut->type == 2) {
#line 1893
        tmp___9 = 1;
      } else
#line 1893
      if (cut->type == 3) {
#line 1893
        tmp___9 = 1;
      } else {
        {
#line 1893
        _glp_lib_xassert("cut->type == GLP_LO || cut->type == GLP_UP", "/home/wslee/benchmarks/glpk-4.38/src/glpios03.c",
                         1893);
#line 1893
        tmp___9 = 1;
        }
      }
      {
#line 1894
      glp_set_row_bnds(tree->mip, i, cut->type, cut->rhs, cut->rhs);
      }
    } else {
      {
#line 1899
      glp_ios_del_row(tree, num);
#line 1899
      num --;
      }
    }
#line 1874
    num ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1902
  _glp_lib_xfree((void *)work);
#line 1903
  _glp_lib_xfree((void *)ind);
#line 1904
  _glp_lib_xfree((void *)val);
  }
  done: 
#line 1907
  return;
}
}
#line 101 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
static void prepare_row_info(int n , double const   *a , double const   *l , double const   *u ,
                             struct f_info *f ) 
{ 
  int j ;
  int j_min ;
  int j_max ;
  double f_min ;
  double f_max ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 105
  if (n >= 0) {
#line 105
    tmp = 1;
  } else {
    {
#line 105
    _glp_lib_xassert("n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     105);
#line 105
    tmp = 1;
    }
  }
#line 107
  f_min = 0.0;
#line 107
  j_min = 0;
#line 108
  j = 1;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (j <= n)) {
#line 108
      goto while_break;
    }
#line 109
    if (*(a + j) > (double const   )0.0) {
#line 110
      if (*(l + j) == (double const   )(- 1.7976931348623157e+308)) {
#line 111
        if (j_min == 0) {
#line 112
          j_min = j;
        } else {
#line 114
          f_min = - 1.7976931348623157e+308;
#line 114
          j_min = 0;
#line 115
          goto while_break;
        }
      } else {
#line 119
        f_min += (double )(*(a + j) * *(l + j));
      }
    } else
#line 121
    if (*(a + j) < (double const   )0.0) {
#line 122
      if (*(u + j) == (double const   )1.7976931348623157e+308) {
#line 123
        if (j_min == 0) {
#line 124
          j_min = j;
        } else {
#line 126
          f_min = - 1.7976931348623157e+308;
#line 126
          j_min = 0;
#line 127
          goto while_break;
        }
      } else {
#line 131
        f_min += (double )(*(a + j) * *(u + j));
      }
    } else
#line 134
    if ((unsigned long )a != (unsigned long )a) {
#line 134
      tmp___0 = 1;
    } else {
      {
#line 134
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       134);
#line 134
      tmp___0 = 1;
      }
    }
#line 108
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  f->f_min = f_min;
#line 136
  f->j_min = j_min;
#line 138
  f_max = 0.0;
#line 138
  j_max = 0;
#line 139
  j = 1;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! (j <= n)) {
#line 139
      goto while_break___0;
    }
#line 140
    if (*(a + j) > (double const   )0.0) {
#line 141
      if (*(u + j) == (double const   )1.7976931348623157e+308) {
#line 142
        if (j_max == 0) {
#line 143
          j_max = j;
        } else {
#line 145
          f_max = 1.7976931348623157e+308;
#line 145
          j_max = 0;
#line 146
          goto while_break___0;
        }
      } else {
#line 150
        f_max += (double )(*(a + j) * *(u + j));
      }
    } else
#line 152
    if (*(a + j) < (double const   )0.0) {
#line 153
      if (*(l + j) == (double const   )(- 1.7976931348623157e+308)) {
#line 154
        if (j_max == 0) {
#line 155
          j_max = j;
        } else {
#line 157
          f_max = 1.7976931348623157e+308;
#line 157
          j_max = 0;
#line 158
          goto while_break___0;
        }
      } else {
#line 162
        f_max += (double )(*(a + j) * *(l + j));
      }
    } else
#line 165
    if ((unsigned long )a != (unsigned long )a) {
#line 165
      tmp___1 = 1;
    } else {
      {
#line 165
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       165);
#line 165
      tmp___1 = 1;
      }
    }
#line 139
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  f->f_max = f_max;
#line 167
  f->j_max = j_max;
#line 168
  return;
}
}
#line 210 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
static void row_implied_bounds(struct f_info  const  *f , double *LL , double *UU ) 
{ 


  {
#line 212
  if (f->j_min == 0) {
#line 212
    *LL = (double )f->f_min;
  } else {
#line 212
    *LL = - 1.7976931348623157e+308;
  }
#line 213
  if (f->j_max == 0) {
#line 213
    *UU = (double )f->f_max;
  } else {
#line 213
    *UU = 1.7976931348623157e+308;
  }
#line 214
  return;
}
}
#line 296 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
static void col_implied_bounds(struct f_info  const  *f , int n , double const   *a ,
                               double L , double U , double const   *l , double const   *u ,
                               int k , double *ll , double *uu ) 
{ 
  double ilb ;
  double iub ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 300
  if (n >= 0) {
#line 300
    tmp = 1;
  } else {
    {
#line 300
    _glp_lib_xassert("n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     300);
#line 300
    tmp = 1;
    }
  }
#line 301
  if (1 <= k) {
#line 301
    if (k <= n) {
#line 301
      tmp___0 = 1;
    } else {
      {
#line 301
      _glp_lib_xassert("1 <= k && k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       301);
#line 301
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 301
    _glp_lib_xassert("1 <= k && k <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     301);
#line 301
    tmp___0 = 1;
    }
  }
#line 303
  if (L == - 1.7976931348623157e+308) {
#line 304
    ilb = - 1.7976931348623157e+308;
  } else
#line 303
  if (f->f_max == (double const   )1.7976931348623157e+308) {
#line 304
    ilb = - 1.7976931348623157e+308;
  } else
#line 305
  if (f->j_max == 0) {
#line 306
    if (*(a + k) > (double const   )0.0) {
#line 307
      if (*(u + k) != (double const   )1.7976931348623157e+308) {
#line 307
        tmp___1 = 1;
      } else {
        {
#line 307
        _glp_lib_xassert("u[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                         307);
#line 307
        tmp___1 = 1;
        }
      }
#line 308
      ilb = L - (double )(f->f_max - *(a + k) * *(u + k));
    } else
#line 310
    if (*(a + k) < (double const   )0.0) {
#line 311
      if (*(l + k) != (double const   )(- 1.7976931348623157e+308)) {
#line 311
        tmp___2 = 1;
      } else {
        {
#line 311
        _glp_lib_xassert("l[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                         311);
#line 311
        tmp___2 = 1;
        }
      }
#line 312
      ilb = L - (double )(f->f_max - *(a + k) * *(l + k));
    } else
#line 315
    if ((unsigned long )a != (unsigned long )a) {
#line 315
      tmp___3 = 1;
    } else {
      {
#line 315
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       315);
#line 315
      tmp___3 = 1;
      }
    }
  } else
#line 317
  if (f->j_max == (int const   )k) {
#line 318
    ilb = L - (double )f->f_max;
  } else {
#line 320
    ilb = - 1.7976931348623157e+308;
  }
#line 322
  if (U == 1.7976931348623157e+308) {
#line 323
    iub = 1.7976931348623157e+308;
  } else
#line 322
  if (f->f_min == (double const   )(- 1.7976931348623157e+308)) {
#line 323
    iub = 1.7976931348623157e+308;
  } else
#line 324
  if (f->j_min == 0) {
#line 325
    if (*(a + k) > (double const   )0.0) {
#line 326
      if (*(l + k) != (double const   )(- 1.7976931348623157e+308)) {
#line 326
        tmp___4 = 1;
      } else {
        {
#line 326
        _glp_lib_xassert("l[k] != -DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                         326);
#line 326
        tmp___4 = 1;
        }
      }
#line 327
      iub = U - (double )(f->f_min - *(a + k) * *(l + k));
    } else
#line 329
    if (*(a + k) < (double const   )0.0) {
#line 330
      if (*(u + k) != (double const   )1.7976931348623157e+308) {
#line 330
        tmp___5 = 1;
      } else {
        {
#line 330
        _glp_lib_xassert("u[k] != +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                         330);
#line 330
        tmp___5 = 1;
        }
      }
#line 331
      iub = U - (double )(f->f_min - *(a + k) * *(u + k));
    } else
#line 334
    if ((unsigned long )a != (unsigned long )a) {
#line 334
      tmp___6 = 1;
    } else {
      {
#line 334
      _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       334);
#line 334
      tmp___6 = 1;
      }
    }
  } else
#line 336
  if (f->j_min == (int const   )k) {
#line 337
    iub = U - (double )f->f_min;
  } else {
#line 339
    iub = 1.7976931348623157e+308;
  }
  {
#line 346
  tmp___8 = fabs((double )*(a + k));
  }
#line 346
  if (tmp___8 < 1e-6) {
#line 347
    *ll = - 1.7976931348623157e+308;
#line 347
    *uu = 1.7976931348623157e+308;
  } else
#line 349
  if (*(a + k) > (double const   )0.0) {
#line 350
    if (ilb == - 1.7976931348623157e+308) {
#line 350
      *ll = - 1.7976931348623157e+308;
    } else {
#line 350
      *ll = ilb / (double )*(a + k);
    }
#line 351
    if (iub == 1.7976931348623157e+308) {
#line 351
      *uu = 1.7976931348623157e+308;
    } else {
#line 351
      *uu = iub / (double )*(a + k);
    }
  } else
#line 353
  if (*(a + k) < (double const   )0.0) {
#line 354
    if (iub == 1.7976931348623157e+308) {
#line 354
      *ll = - 1.7976931348623157e+308;
    } else {
#line 354
      *ll = iub / (double )*(a + k);
    }
#line 355
    if (ilb == - 1.7976931348623157e+308) {
#line 355
      *uu = 1.7976931348623157e+308;
    } else {
#line 355
      *uu = ilb / (double )*(a + k);
    }
  } else
#line 358
  if ((unsigned long )a != (unsigned long )a) {
#line 358
    tmp___7 = 1;
  } else {
    {
#line 358
    _glp_lib_xassert("a != a", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     358);
#line 358
    tmp___7 = 1;
    }
  }
#line 359
  return;
}
}
#line 383 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
static int check_row_bounds(struct f_info  const  *f , double *L_ , double *U_ ) 
{ 
  int ret ;
  double L ;
  double U ;
  double LL ;
  double UU ;
  double eps ;
  double tmp ;
  double eps___0 ;
  double tmp___0 ;
  double eps___1 ;
  double tmp___1 ;
  double eps___2 ;
  double tmp___2 ;

  {
  {
#line 385
  ret = 0;
#line 386
  L = *L_;
#line 386
  U = *U_;
#line 388
  row_implied_bounds(f, & LL, & UU);
  }
#line 390
  if (L != - 1.7976931348623157e+308) {
    {
#line 391
    tmp = fabs(L);
#line 391
    eps = 1e-3 * (1.0 + tmp);
    }
#line 392
    if (UU < L - eps) {
#line 393
      ret = 1;
#line 394
      goto done;
    }
  }
#line 398
  if (U != 1.7976931348623157e+308) {
    {
#line 399
    tmp___0 = fabs(U);
#line 399
    eps___0 = 1e-3 * (1.0 + tmp___0);
    }
#line 400
    if (LL > U + eps___0) {
#line 401
      ret = 1;
#line 402
      goto done;
    }
  }
#line 406
  if (L != - 1.7976931348623157e+308) {
    {
#line 407
    tmp___1 = fabs(L);
#line 407
    eps___1 = 1e-12 * (1.0 + tmp___1);
    }
#line 408
    if (LL > L - eps___1) {
#line 410
      *L_ = - 1.7976931348623157e+308;
    }
  }
#line 414
  if (U != 1.7976931348623157e+308) {
    {
#line 415
    tmp___2 = fabs(U);
#line 415
    eps___2 = 1e-12 * (1.0 + tmp___2);
    }
#line 416
    if (UU < U + eps___2) {
#line 418
      *U_ = 1.7976931348623157e+308;
    }
  }
  done: 
#line 421
  return (ret);
}
}
#line 453 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
static int check_col_bounds(struct f_info  const  *f , int n , double const   *a ,
                            double L , double U , double const   *l , double const   *u ,
                            int flag , int j , double *_lj , double *_uj ) 
{ 
  int ret ;
  double lj ;
  double uj ;
  double ll ;
  double uu ;
  int tmp ;
  int tmp___0 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double eps ;
  double tmp___9 ;
  double eps___0 ;
  double tmp___10 ;
  double eps___1 ;
  double tmp___11 ;
  double eps___2 ;
  double tmp___12 ;
  double t1 ;
  double tmp___13 ;
  double t2 ;
  double tmp___14 ;
  double eps___3 ;
  double tmp___15 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 456
  ret = 0;
#line 458
  if (n >= 0) {
#line 458
    tmp = 1;
  } else {
    {
#line 458
    _glp_lib_xassert("n >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     458);
#line 458
    tmp = 1;
    }
  }
#line 459
  if (1 <= j) {
#line 459
    if (j <= n) {
#line 459
      tmp___0 = 1;
    } else {
      {
#line 459
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       459);
#line 459
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 459
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     459);
#line 459
    tmp___0 = 1;
    }
  }
  {
#line 460
  lj = (double )*(l + j);
#line 460
  uj = (double )*(u + j);
#line 462
  col_implied_bounds(f, n, a, L, U, l, u, j, & ll, & uu);
  }
#line 464
  if (flag) {
#line 465
    if (ll != - 1.7976931348623157e+308) {
      {
#line 466
      tmp___4 = floor(ll);
      }
#line 466
      if (ll - tmp___4 < 1e-3) {
        {
#line 466
        tmp___2 = floor(ll);
#line 466
        ll = tmp___2;
        }
      } else {
        {
#line 466
        tmp___3 = ceil(ll);
#line 466
        ll = tmp___3;
        }
      }
    }
#line 467
    if (uu != 1.7976931348623157e+308) {
      {
#line 468
      tmp___8 = ceil(uu);
      }
#line 468
      if (tmp___8 - uu < 1e-3) {
        {
#line 468
        tmp___6 = ceil(uu);
#line 468
        uu = tmp___6;
        }
      } else {
        {
#line 468
        tmp___7 = floor(uu);
#line 468
        uu = tmp___7;
        }
      }
    }
  }
#line 471
  if (lj != - 1.7976931348623157e+308) {
    {
#line 472
    tmp___9 = fabs(lj);
#line 472
    eps = 1e-3 * (1.0 + tmp___9);
    }
#line 473
    if (uu < lj - eps) {
#line 474
      ret = 1;
#line 475
      goto done;
    }
  }
#line 479
  if (uj != 1.7976931348623157e+308) {
    {
#line 480
    tmp___10 = fabs(uj);
#line 480
    eps___0 = 1e-3 * (1.0 + tmp___10);
    }
#line 481
    if (ll > uj + eps___0) {
#line 482
      ret = 1;
#line 483
      goto done;
    }
  }
#line 487
  if (ll != - 1.7976931348623157e+308) {
    {
#line 488
    tmp___11 = fabs(ll);
#line 488
    eps___1 = 1e-3 * (1.0 + tmp___11);
    }
#line 489
    if (lj < ll - eps___1) {
#line 491
      lj = ll;
    }
  }
#line 495
  if (uu != 1.7976931348623157e+308) {
    {
#line 496
    tmp___12 = fabs(uu);
#line 496
    eps___2 = 1e-3 * (1.0 + tmp___12);
    }
#line 497
    if (uj > uu + eps___2) {
#line 499
      uj = uu;
    }
  }
#line 505
  if (! (lj == - 1.7976931348623157e+308)) {
#line 505
    if (! (uj == 1.7976931348623157e+308)) {
      {
#line 506
      tmp___13 = fabs(lj);
#line 506
      t1 = tmp___13;
#line 506
      tmp___14 = fabs(uj);
#line 506
      t2 = tmp___14;
      }
#line 507
      if (t1 <= t2) {
#line 507
        tmp___15 = t1;
      } else {
#line 507
        tmp___15 = t2;
      }
#line 507
      eps___3 = 1e-10 * (1.0 + tmp___15);
#line 508
      if (lj > uj - eps___3) {
#line 509
        if (lj == (double )*(l + j)) {
#line 510
          uj = lj;
        } else
#line 511
        if (uj == (double )*(u + j)) {
#line 512
          lj = uj;
        } else
#line 513
        if (t1 <= t2) {
#line 514
          uj = lj;
        } else {
#line 516
          lj = uj;
        }
      }
    }
  }
#line 519
  *_lj = lj;
#line 519
  *_uj = uj;
  done: 
#line 520
  return (ret);
}
}
#line 533 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
static int check_efficiency(int flag , double l , double u , double ll , double uu ) 
{ 
  int eff ;
  double r ;
  double tmp ;
  double r___0 ;
  double tmp___0 ;

  {
#line 535
  eff = 0;
#line 537
  if (l < ll) {
#line 538
    if (flag) {
#line 539
      eff ++;
    } else
#line 538
    if (l == - 1.7976931348623157e+308) {
#line 539
      eff ++;
    } else {
#line 542
      if (u == 1.7976931348623157e+308) {
        {
#line 543
        tmp = fabs(l);
#line 543
        r = 1.0 + tmp;
        }
      } else {
#line 545
        r = 1.0 + (u - l);
      }
#line 546
      if (ll - l >= 0.25 * r) {
#line 547
        eff ++;
      }
    }
  }
#line 551
  if (u > uu) {
#line 552
    if (flag) {
#line 553
      eff ++;
    } else
#line 552
    if (u == 1.7976931348623157e+308) {
#line 553
      eff ++;
    } else {
#line 556
      if (l == - 1.7976931348623157e+308) {
        {
#line 557
        tmp___0 = fabs(u);
#line 557
        r___0 = 1.0 + tmp___0;
        }
      } else {
#line 559
        r___0 = 1.0 + (u - l);
      }
#line 560
      if (u - uu >= 0.25 * r___0) {
#line 561
        eff ++;
      }
    }
  }
#line 564
  return (eff);
}
}
#line 601 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
static int basic_preprocessing(glp_prob *mip , double *L , double *U , double *l ,
                               double *u , int nrs , int const   *num , int max_pass ) 
{ 
  int m ;
  int n ;
  struct f_info f ;
  int i ;
  int j ;
  int k ;
  int len ;
  int size ;
  int ret ;
  int *ind ;
  int *list ;
  int *mark ;
  int *pass ;
  double *val ;
  double *lb ;
  double *ub ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  GLPCOL *col ;
  GLPROW *row ;
  GLPAIJ *aij ;
  int tmp___12 ;
  GLPCOL *col___0 ;
  int flag ;
  int eff ;
  double ll ;
  double uu ;
  int tmp___13 ;
  GLPAIJ *aij___0 ;
  int ii ;
  int tmp___14 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
#line 603
  m = mip->m;
#line 604
  n = mip->n;
#line 606
  ret = 0;
#line 609
  if (0 <= nrs) {
#line 609
    if (nrs <= m + 1) {
#line 609
      tmp = 1;
    } else {
      {
#line 609
      _glp_lib_xassert("0 <= nrs && nrs <= m+1", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       609);
#line 609
      tmp = 1;
      }
    }
  } else {
    {
#line 609
    _glp_lib_xassert("0 <= nrs && nrs <= m+1", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     609);
#line 609
    tmp = 1;
    }
  }
#line 610
  if (max_pass > 0) {
#line 610
    tmp___0 = 1;
  } else {
    {
#line 610
    _glp_lib_xassert("max_pass > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     610);
#line 610
    tmp___0 = 1;
    }
  }
  {
#line 612
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 612
  ind = (int *)tmp___1;
#line 613
  tmp___2 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 613
  list = (int *)tmp___2;
#line 614
  tmp___3 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 614
  mark = (int *)tmp___3;
#line 615
  memset((void *)(mark + 0), 0, (size_t )((unsigned long )(m + 1) * sizeof(int )));
#line 616
  tmp___4 = _glp_lib_xcalloc((1 + m) + 1, (int )sizeof(int ));
#line 616
  pass = (int *)tmp___4;
#line 617
  memset((void *)(pass + 0), 0, (size_t )((unsigned long )(m + 1) * sizeof(int )));
#line 618
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 618
  val = (double *)tmp___5;
#line 619
  tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 619
  lb = (double *)tmp___6;
#line 620
  tmp___7 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 620
  ub = (double *)tmp___7;
#line 622
  size = 0;
#line 623
  k = 1;
  }
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! (k <= nrs)) {
#line 623
      goto while_break;
    }
#line 624
    i = (int )*(num + k);
#line 625
    if (0 <= i) {
#line 625
      if (i <= m) {
#line 625
        tmp___8 = 1;
      } else {
        {
#line 625
        _glp_lib_xassert("0 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                         625);
#line 625
        tmp___8 = 1;
        }
      }
    } else {
      {
#line 625
      _glp_lib_xassert("0 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       625);
#line 625
      tmp___8 = 1;
      }
    }
#line 627
    if (! *(mark + i)) {
#line 627
      tmp___9 = 1;
    } else {
      {
#line 627
      _glp_lib_xassert("!mark[i]", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                       627);
#line 627
      tmp___9 = 1;
      }
    }
#line 628
    size ++;
#line 628
    *(list + size) = i;
#line 628
    *(mark + i) = 1;
#line 623
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  if (size == nrs) {
#line 630
    tmp___10 = 1;
  } else {
    {
#line 630
    _glp_lib_xassert("size == nrs", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     630);
#line 630
    tmp___10 = 1;
    }
  }
  {
#line 632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 632
    if (! (size > 0)) {
#line 632
      goto while_break___0;
    }
#line 634
    tmp___11 = size;
#line 634
    size --;
#line 634
    i = *(list + tmp___11);
#line 634
    *(mark + i) = 0;
#line 636
    (*(pass + i)) ++;
#line 638
    if (*(L + i) == - 1.7976931348623157e+308) {
#line 638
      if (*(U + i) == 1.7976931348623157e+308) {
#line 638
        goto while_continue___0;
      }
    }
#line 640
    len = 0;
#line 641
    if (i == 0) {
#line 642
      j = 1;
      {
#line 642
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 642
        if (! (j <= n)) {
#line 642
          goto while_break___1;
        }
#line 643
        col = *(mip->col + j);
#line 644
        if (col->coef != 0.0) {
#line 645
          len ++;
#line 645
          *(ind + len) = j;
#line 645
          *(val + len) = col->coef;
        }
#line 642
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 649
      row = *(mip->row + i);
#line 651
      aij = row->ptr;
      {
#line 651
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 651
        if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 651
          goto while_break___2;
        }
#line 652
        len ++;
#line 652
        *(ind + len) = (aij->col)->j;
#line 652
        *(val + len) = aij->val;
#line 651
        aij = aij->r_next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 656
    k = 1;
    {
#line 656
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 656
      if (! (k <= len)) {
#line 656
        goto while_break___3;
      }
#line 657
      j = *(ind + k);
#line 657
      *(lb + k) = *(l + j);
#line 657
      *(ub + k) = *(u + j);
#line 656
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 659
    prepare_row_info(len, (double const   *)val, (double const   *)lb, (double const   *)ub,
                     & f);
#line 661
    tmp___12 = check_row_bounds((struct f_info  const  *)(& f), L + i, U + i);
    }
#line 661
    if (tmp___12) {
#line 663
      ret = 1;
#line 664
      goto done;
    }
#line 667
    if (*(L + i) == - 1.7976931348623157e+308) {
#line 667
      if (*(U + i) == 1.7976931348623157e+308) {
#line 667
        goto while_continue___0;
      }
    }
#line 669
    k = 1;
    {
#line 669
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 669
      if (! (k <= len)) {
#line 669
        goto while_break___4;
      }
      {
#line 674
      j = *(ind + k);
#line 674
      col___0 = *(mip->col + j);
#line 675
      flag = col___0->kind != 1;
#line 677
      tmp___13 = check_col_bounds((struct f_info  const  *)(& f), len, (double const   *)val,
                                  *(L + i), *(U + i), (double const   *)lb, (double const   *)ub,
                                  flag, k, & ll, & uu);
      }
#line 677
      if (tmp___13) {
#line 680
        ret = 1;
#line 681
        goto done;
      }
      {
#line 684
      eff = check_efficiency(flag, *(l + j), *(u + j), ll, uu);
#line 686
      *(l + j) = ll;
#line 686
      *(u + j) = uu;
      }
#line 689
      if (eff > 0) {
#line 691
        aij___0 = col___0->ptr;
        {
#line 691
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 691
          if (! ((unsigned long )aij___0 != (unsigned long )((void *)0))) {
#line 691
            goto while_break___5;
          }
#line 692
          ii = (aij___0->row)->i;
#line 695
          if (*(pass + ii) >= max_pass) {
#line 695
            goto __Cont;
          }
#line 697
          if (*(L + ii) == - 1.7976931348623157e+308) {
#line 697
            if (*(U + ii) == 1.7976931348623157e+308) {
#line 697
              goto __Cont;
            }
          }
#line 699
          if (*(mark + ii) == 0) {
#line 700
            if (size <= m) {
#line 700
              tmp___14 = 1;
            } else {
              {
#line 700
              _glp_lib_xassert("size <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                               700);
#line 700
              tmp___14 = 1;
              }
            }
#line 701
            size ++;
#line 701
            *(list + size) = ii;
#line 701
            *(mark + ii) = 1;
          }
          __Cont: /* CIL Label */ 
#line 691
          aij___0 = aij___0->c_next;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 669
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
  {
#line 708
  _glp_lib_xfree((void *)ind);
#line 709
  _glp_lib_xfree((void *)list);
#line 710
  _glp_lib_xfree((void *)mark);
#line 711
  _glp_lib_xfree((void *)pass);
#line 712
  _glp_lib_xfree((void *)val);
#line 713
  _glp_lib_xfree((void *)lb);
#line 714
  _glp_lib_xfree((void *)ub);
  }
#line 715
  return (ret);
}
}
#line 738 "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c"
int _glp_ios_preprocess_node(glp_tree___0 *tree , int max_pass ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  int i ;
  int j ;
  int nrs ;
  int *num ;
  int ret ;
  double *L ;
  double *U ;
  double *l ;
  double *u ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int type ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 739
  mip = tree->mip;
#line 740
  m = mip->m;
#line 741
  n = mip->n;
#line 742
  ret = 0;
#line 745
  if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 745
    tmp = 1;
  } else {
    {
#line 745
    _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     745);
#line 745
    tmp = 1;
    }
  }
  {
#line 747
  tmp___0 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 747
  L = (double *)tmp___0;
#line 748
  tmp___1 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 748
  U = (double *)tmp___1;
  }
  {
#line 750
  if (mip->mip_stat == 1) {
#line 750
    goto case_1;
  }
#line 753
  if (mip->mip_stat == 2) {
#line 753
    goto case_2;
  }
#line 765
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 751
  *(L + 0) = - 1.7976931348623157e+308;
#line 751
  *(U + 0) = 1.7976931348623157e+308;
#line 752
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 755
  if (mip->dir == 1) {
#line 755
    goto case_1___0;
  }
#line 758
  if (mip->dir == 2) {
#line 758
    goto case_2___0;
  }
#line 761
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 756
  *(L + 0) = - 1.7976931348623157e+308;
#line 756
  *(U + 0) = mip->mip_obj - mip->c0;
#line 757
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 759
  *(L + 0) = mip->mip_obj - mip->c0;
#line 759
  *(U + 0) = 1.7976931348623157e+308;
#line 760
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 762
  if ((unsigned long )mip != (unsigned long )mip) {
#line 762
    tmp___2 = 1;
  } else {
    {
#line 762
    _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     762);
#line 762
    tmp___2 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 764
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 766
  if ((unsigned long )mip != (unsigned long )mip) {
#line 766
    tmp___3 = 1;
  } else {
    {
#line 766
    _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios02.c",
                     766);
#line 766
    tmp___3 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 768
  i = 1;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (i <= m)) {
#line 768
      goto while_break;
    }
    {
#line 769
    *(L + i) = glp_get_row_lb(mip, i);
#line 770
    *(U + i) = glp_get_row_ub(mip, i);
#line 768
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 773
  tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 773
  l = (double *)tmp___4;
#line 774
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 774
  u = (double *)tmp___5;
#line 775
  j = 1;
  }
  {
#line 775
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 775
    if (! (j <= n)) {
#line 775
      goto while_break___0;
    }
    {
#line 776
    *(l + j) = glp_get_col_lb(mip, j);
#line 777
    *(u + j) = glp_get_col_ub(mip, j);
#line 775
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 780
  nrs = m + 1;
#line 781
  tmp___6 = _glp_lib_xcalloc(1 + nrs, (int )sizeof(int ));
#line 781
  num = (int *)tmp___6;
#line 782
  i = 1;
  }
  {
#line 782
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 782
    if (! (i <= nrs)) {
#line 782
      goto while_break___1;
    }
#line 782
    *(num + i) = i - 1;
#line 782
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 784
  tmp___7 = basic_preprocessing(mip, L, U, l, u, nrs, (int const   *)num, max_pass);
  }
#line 784
  if (tmp___7) {
#line 785
    ret = 1;
#line 786
    goto done;
  }
#line 789
  i = 1;
  {
#line 789
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 789
    if (! (i <= m)) {
#line 789
      goto while_break___2;
    }
    {
#line 791
    tmp___8 = glp_get_row_stat(mip, i);
    }
#line 791
    if (tmp___8 == 1) {
#line 792
      if (*(L + i) == - 1.7976931348623157e+308) {
#line 792
        if (*(U + i) == 1.7976931348623157e+308) {
          {
#line 793
          glp_set_row_bnds(mip, i, 1, 0.0, 0.0);
          }
        } else {
#line 792
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 794
      if (*(U + i) == 1.7976931348623157e+308) {
        {
#line 795
        glp_set_row_bnds(mip, i, 2, *(L + i), 0.0);
        }
      } else
#line 796
      if (*(L + i) == - 1.7976931348623157e+308) {
        {
#line 797
        glp_set_row_bnds(mip, i, 3, 0.0, *(U + i));
        }
      }
    }
#line 789
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 801
  j = 1;
  {
#line 801
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 801
    if (! (j <= n)) {
#line 801
      goto while_break___3;
    }
#line 803
    if (*(l + j) == - 1.7976931348623157e+308) {
#line 803
      if (*(u + j) == 1.7976931348623157e+308) {
#line 804
        type = 1;
      } else {
#line 803
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 805
    if (*(u + j) == 1.7976931348623157e+308) {
#line 806
      type = 2;
    } else
#line 807
    if (*(l + j) == - 1.7976931348623157e+308) {
#line 808
      type = 3;
    } else
#line 809
    if (*(l + j) != *(u + j)) {
#line 810
      type = 4;
    } else {
#line 812
      type = 5;
    }
    {
#line 813
    glp_set_col_bnds(mip, j, type, *(l + j), *(u + j));
#line 801
    j ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
  {
#line 816
  _glp_lib_xfree((void *)L);
#line 817
  _glp_lib_xfree((void *)U);
#line 818
  _glp_lib_xfree((void *)l);
#line 819
  _glp_lib_xfree((void *)u);
#line 820
  _glp_lib_xfree((void *)num);
  }
#line 821
  return (ret);
}
}
#line 432 "/home/wslee/benchmarks/glpk-4.38/src/glpios.h"
glp_tree___0 *_glp_ios_create_tree(glp_prob *mip , glp_iocp___0 const   *parm ) ;
#line 452
void _glp_ios_delete_tree(glp_tree___0 *tree ) ;
#line 480
IOSPOOL *_glp_ios_create_pool(glp_tree___0 *tree ) ;
#line 484
int _glp_ios_add_row(glp_tree___0 *tree , IOSPOOL *pool , char const   *name , int klass ,
                     int flags , int len , int const   *ind , double const   *val ,
                     int type , double rhs ) ;
#line 494
void _glp_ios_del_row(glp_tree___0 *tree , IOSPOOL *pool , int i ) ;
#line 502
void _glp_ios_delete_pool(glp_tree___0 *tree , IOSPOOL *pool ) ;
#line 506
void _glp_ios_add_edge(glp_tree___0 *tree , int j1___0 , int j2 ) ;
#line 48 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
static IOSNPD *new_node(glp_tree___0 *tree , IOSNPD *parent ) ;
#line 50 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
glp_tree___0 *_glp_ios_create_tree(glp_prob *mip , glp_iocp___0 const   *parm ) 
{ 
  int m ;
  int n ;
  glp_tree___0 *tree ;
  int i ;
  int j ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  GLPROW *row ;
  GLPCOL *col ;
  IOSNPD *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  double *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  double *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 51
  m = mip->m;
#line 52
  n = mip->n;
#line 55
  if ((unsigned long )mip->tree == (unsigned long )((void *)0)) {
#line 55
    tmp = 1;
  } else {
    {
#line 55
    _glp_lib_xassert("mip->tree == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     55);
#line 55
    tmp = 1;
    }
  }
  {
#line 56
  tmp___0 = _glp_lib_xmalloc((int )sizeof(glp_tree___0 ));
#line 56
  tree = (glp_tree___0 *)tmp___0;
#line 56
  mip->tree = (void *)tree;
#line 57
  tree->pool = _glp_dmp_create_pool();
#line 58
  tree->n = n;
#line 60
  tree->orig_m = m;
#line 61
  tmp___1 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 61
  tree->orig_type = (int *)tmp___1;
#line 62
  tmp___2 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 62
  tree->orig_lb = (double *)tmp___2;
#line 63
  tmp___3 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 63
  tree->orig_ub = (double *)tmp___3;
#line 64
  tmp___4 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 64
  tree->orig_stat = (int *)tmp___4;
#line 65
  tmp___5 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 65
  tree->orig_prim = (double *)tmp___5;
#line 66
  tmp___6 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 66
  tree->orig_dual = (double *)tmp___6;
#line 67
  i = 1;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i <= m)) {
#line 67
      goto while_break;
    }
#line 68
    row = *(mip->row + i);
#line 69
    *(tree->orig_type + i) = row->type;
#line 70
    *(tree->orig_lb + i) = row->lb;
#line 71
    *(tree->orig_ub + i) = row->ub;
#line 72
    *(tree->orig_stat + i) = row->stat;
#line 73
    *(tree->orig_prim + i) = row->prim;
#line 74
    *(tree->orig_dual + i) = row->dual;
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  j = 1;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! (j <= n)) {
#line 76
      goto while_break___0;
    }
#line 77
    col = *(mip->col + j);
#line 78
    *(tree->orig_type + (m + j)) = col->type;
#line 79
    *(tree->orig_lb + (m + j)) = col->lb;
#line 80
    *(tree->orig_ub + (m + j)) = col->ub;
#line 81
    *(tree->orig_stat + (m + j)) = col->stat;
#line 82
    *(tree->orig_prim + (m + j)) = col->prim;
#line 83
    *(tree->orig_dual + (m + j)) = col->dual;
#line 76
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  tree->orig_obj = mip->obj_val;
#line 87
  tree->nslots = 0;
#line 88
  tree->avail = 0;
#line 89
  tree->slot = (IOSLOT *)((void *)0);
#line 90
  tmp___7 = (IOSNPD *)((void *)0);
#line 90
  tree->tail = tmp___7;
#line 90
  tree->head = tmp___7;
#line 91
  tmp___9 = 0;
#line 91
  tree->t_cnt = tmp___9;
#line 91
  tmp___8 = tmp___9;
#line 91
  tree->n_cnt = tmp___8;
#line 91
  tree->a_cnt = tmp___8;
#line 94
  tree->root_m = 0;
#line 95
  tree->root_type = (int *)((void *)0);
#line 96
  tmp___10 = (double *)((void *)0);
#line 96
  tree->root_ub = tmp___10;
#line 96
  tree->root_lb = tmp___10;
#line 97
  tree->root_stat = (int *)((void *)0);
#line 99
  tree->curr = (IOSNPD *)((void *)0);
#line 100
  tree->mip = mip;
#line 101
  tree->solved = 0;
#line 102
  tmp___11 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 102
  tree->non_int = (int *)tmp___11;
#line 103
  memset((void *)(tree->non_int + 1), 0, (size_t )((unsigned long )n * sizeof(int )));
#line 106
  tmp___12 = 0;
#line 106
  tree->pred_max = tmp___12;
#line 106
  tree->pred_m = tmp___12;
#line 107
  tree->pred_type = (int *)((void *)0);
#line 108
  tmp___13 = (double *)((void *)0);
#line 108
  tree->pred_ub = tmp___13;
#line 108
  tree->pred_lb = tmp___13;
#line 109
  tree->pred_stat = (int *)((void *)0);
#line 111
  tree->local = _glp_ios_create_pool(tree);
#line 112
  tree->first_attempt = 1;
#line 113
  tree->max_added_cuts = 0;
#line 114
  tree->min_eff = 0.0;
#line 115
  tree->miss = 0;
#line 116
  tree->just_selected = 0;
#line 117
  tree->mir_gen = (void *)0;
#line 118
  tree->clq_gen = (void *)0;
#line 119
  tree->round = 0;
#line 121
  tmp___14 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 121
  tree->n_ref = (int *)tmp___14;
#line 122
  memset((void *)(tree->n_ref + 1), 0, (size_t )((unsigned long )n * sizeof(int )));
#line 123
  tmp___15 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 123
  tree->c_ref = (int *)tmp___15;
#line 124
  memset((void *)(tree->c_ref + 1), 0, (size_t )((unsigned long )n * sizeof(int )));
#line 125
  tree->g = _glp_scg_create_graph(0);
#line 126
  tmp___16 = _glp_lib_xcalloc(1 + (tree->g)->n_max, (int )sizeof(int ));
#line 126
  tree->j_ref = (int *)tmp___16;
#line 128
  tree->pcost = (void *)0;
#line 129
  tmp___17 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 129
  tree->iwrk = (int *)tmp___17;
#line 130
  tmp___18 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 130
  tree->dwrk = (double *)tmp___18;
#line 132
  tree->parm = parm;
#line 133
  tree->tm_beg = _glp_lib_xtime();
#line 134
  tree->tm_lag = _glp_lib_xlset(0);
#line 135
  tree->sol_cnt = 0;
#line 137
  tree->reason = 0;
#line 138
  tree->reopt = 0;
#line 139
  tree->br_var = 0;
#line 140
  tree->br_sel = 0;
#line 141
  tree->btrack = (IOSNPD *)((void *)0);
#line 142
  tree->terminate = 0;
#line 145
  new_node(tree, (IOSNPD *)((void *)0));
  }
#line 146
  return (tree);
}
}
#line 167 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_revive_node(glp_tree___0 *tree , int p ) 
{ 
  glp_prob *mip ;
  IOSNPD *node ;
  IOSNPD *root ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int m ;
  int n ;
  int i ;
  int j ;
  int new_size ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  GLPROW *row ;
  GLPCOL *col ;
  IOSBND *b ;
  IOSTAT *s ;
  IOSROW *r ;
  IOSAIJ *a ;
  int i___0 ;
  int len ;
  int *ind ;
  double *val ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  IOSBND *b___0 ;
  IOSTAT *s___0 ;
  int tmp___16 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
#line 168
  mip = tree->mip;
#line 171
  if (1 <= p) {
#line 171
    if (p <= tree->nslots) {
#line 171
      tmp = 1;
    } else {
      {
#line 171
      _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       171);
#line 171
      tmp = 1;
      }
    }
  } else {
    {
#line 171
    _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     171);
#line 171
    tmp = 1;
    }
  }
#line 172
  node = (tree->slot + p)->node;
#line 173
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 173
    tmp___0 = 1;
  } else {
    {
#line 173
    _glp_lib_xassert("node != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     173);
#line 173
    tmp___0 = 1;
    }
  }
#line 175
  if (node->count == 0) {
#line 175
    tmp___1 = 1;
  } else {
    {
#line 175
    _glp_lib_xassert("node->count == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     175);
#line 175
    tmp___1 = 1;
    }
  }
#line 177
  if ((unsigned long )tree->curr == (unsigned long )((void *)0)) {
#line 177
    tmp___2 = 1;
  } else {
    {
#line 177
    _glp_lib_xassert("tree->curr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     177);
#line 177
    tmp___2 = 1;
    }
  }
#line 179
  tree->curr = node;
#line 180
  tree->solved = 0;
#line 182
  root = (tree->slot + 1)->node;
#line 183
  if ((unsigned long )root != (unsigned long )((void *)0)) {
#line 183
    tmp___3 = 1;
  } else {
    {
#line 183
    _glp_lib_xassert("root != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     183);
#line 183
    tmp___3 = 1;
    }
  }
#line 187
  if ((unsigned long )node == (unsigned long )root) {
#line 187
    goto done;
  }
#line 188
  if (mip->m == tree->root_m) {
#line 188
    tmp___4 = 1;
  } else {
    {
#line 188
    _glp_lib_xassert("mip->m == tree->root_m", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     188);
#line 188
    tmp___4 = 1;
    }
  }
#line 190
  node->temp = (IOSNPD *)((void *)0);
#line 191
  node = node;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 191
      goto while_break;
    }
#line 192
    if ((unsigned long )node->up == (unsigned long )((void *)0)) {
#line 193
      if ((unsigned long )node == (unsigned long )root) {
#line 193
        tmp___5 = 1;
      } else {
        {
#line 193
        _glp_lib_xassert("node == root", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         193);
#line 193
        tmp___5 = 1;
        }
      }
    } else {
#line 195
      (node->up)->temp = node;
    }
#line 191
    node = node->up;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  node = root;
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 199
      goto while_break___0;
    }
#line 200
    m = mip->m;
#line 201
    n = mip->n;
#line 205
    if ((unsigned long )node->temp == (unsigned long )((void *)0)) {
#line 207
      tree->pred_m = m;
#line 209
      if (tree->pred_max < m + n) {
#line 210
        new_size = (m + n) + 100;
#line 211
        if ((unsigned long )tree->pred_type != (unsigned long )((void *)0)) {
          {
#line 211
          _glp_lib_xfree((void *)tree->pred_type);
          }
        }
#line 212
        if ((unsigned long )tree->pred_lb != (unsigned long )((void *)0)) {
          {
#line 212
          _glp_lib_xfree((void *)tree->pred_lb);
          }
        }
#line 213
        if ((unsigned long )tree->pred_ub != (unsigned long )((void *)0)) {
          {
#line 213
          _glp_lib_xfree((void *)tree->pred_ub);
          }
        }
#line 214
        if ((unsigned long )tree->pred_stat != (unsigned long )((void *)0)) {
          {
#line 214
          _glp_lib_xfree((void *)tree->pred_stat);
          }
        }
        {
#line 215
        tree->pred_max = new_size;
#line 216
        tmp___6 = _glp_lib_xcalloc(1 + new_size, (int )sizeof(int ));
#line 216
        tree->pred_type = (int *)tmp___6;
#line 217
        tmp___7 = _glp_lib_xcalloc(1 + new_size, (int )sizeof(double ));
#line 217
        tree->pred_lb = (double *)tmp___7;
#line 218
        tmp___8 = _glp_lib_xcalloc(1 + new_size, (int )sizeof(double ));
#line 218
        tree->pred_ub = (double *)tmp___8;
#line 219
        tmp___9 = _glp_lib_xcalloc(1 + new_size, (int )sizeof(int ));
#line 219
        tree->pred_stat = (int *)tmp___9;
        }
      }
#line 222
      i = 1;
      {
#line 222
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 222
        if (! (i <= m)) {
#line 222
          goto while_break___1;
        }
#line 223
        row = *(mip->row + i);
#line 224
        *(tree->pred_type + i) = row->type;
#line 225
        *(tree->pred_lb + i) = row->lb;
#line 226
        *(tree->pred_ub + i) = row->ub;
#line 227
        *(tree->pred_stat + i) = row->stat;
#line 222
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 230
      j = 1;
      {
#line 230
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 230
        if (! (j <= n)) {
#line 230
          goto while_break___2;
        }
#line 231
        col = *(mip->col + j);
#line 232
        *(tree->pred_type + (mip->m + j)) = col->type;
#line 233
        *(tree->pred_lb + (mip->m + j)) = col->lb;
#line 234
        *(tree->pred_ub + (mip->m + j)) = col->ub;
#line 235
        *(tree->pred_stat + (mip->m + j)) = col->stat;
#line 230
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 240
    b = node->b_ptr;
    {
#line 240
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 240
      if (! ((unsigned long )b != (unsigned long )((void *)0))) {
#line 240
        goto while_break___3;
      }
#line 241
      if (b->k <= m) {
        {
#line 242
        glp_set_row_bnds(mip, b->k, b->type, b->lb, b->ub);
        }
      } else {
        {
#line 244
        glp_set_col_bnds(mip, b->k - m, b->type, b->lb, b->ub);
        }
      }
#line 240
      b = b->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 249
    s = node->s_ptr;
    {
#line 249
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 249
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 249
        goto while_break___4;
      }
#line 250
      if (s->k <= m) {
        {
#line 251
        glp_set_row_stat(mip, s->k, s->stat);
        }
      } else {
        {
#line 253
        glp_set_col_stat(mip, s->k - m, s->stat);
        }
      }
#line 249
      s = s->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 257
    if ((unsigned long )node->r_ptr != (unsigned long )((void *)0)) {
      {
#line 262
      tmp___10 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 262
      ind = (int *)tmp___10;
#line 263
      tmp___11 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 263
      val = (double *)tmp___11;
#line 264
      r = node->r_ptr;
      }
      {
#line 264
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 264
        if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 264
          goto while_break___5;
        }
        {
#line 265
        i___0 = glp_add_rows(mip, 1);
#line 266
        glp_set_row_name(mip, i___0, (char const   *)r->name);
        }
#line 268
        if ((*(mip->row + i___0))->level == 0) {
#line 268
          tmp___12 = 1;
        } else {
          {
#line 268
          _glp_lib_xassert("mip->row[i]->level == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                           268);
#line 268
          tmp___12 = 1;
          }
        }
        {
#line 269
        (*(mip->row + i___0))->level = node->level;
#line 270
        (*(mip->row + i___0))->origin = r->origin;
#line 271
        (*(mip->row + i___0))->klass = r->klass;
#line 273
        glp_set_row_bnds(mip, i___0, r->type, r->lb, r->ub);
#line 274
        len = 0;
#line 275
        a = r->ptr;
        }
        {
#line 275
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 275
          if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 275
            goto while_break___6;
          }
#line 276
          len ++;
#line 276
          *(ind + len) = a->j;
#line 276
          *(val + len) = a->val;
#line 275
          a = a->next;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 277
        glp_set_mat_row(mip, i___0, len, (int const   *)ind, (double const   *)val);
#line 278
        glp_set_rii(mip, i___0, r->rii);
#line 279
        glp_set_row_stat(mip, i___0, r->stat);
#line 264
        r = r->next;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 281
      _glp_lib_xfree((void *)ind);
#line 282
      _glp_lib_xfree((void *)val);
      }
    }
#line 288
    if (node->own_nn == 0) {
#line 288
      tmp___13 = 1;
    } else {
      {
#line 288
      _glp_lib_xassert("node->own_nn == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       288);
#line 288
      tmp___13 = 1;
      }
    }
#line 289
    if (node->own_nc == 0) {
#line 289
      tmp___14 = 1;
    } else {
      {
#line 289
      _glp_lib_xassert("node->own_nc == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       289);
#line 289
      tmp___14 = 1;
      }
    }
#line 290
    if ((unsigned long )node->e_ptr == (unsigned long )((void *)0)) {
#line 290
      tmp___15 = 1;
    } else {
      {
#line 290
      _glp_lib_xassert("node->e_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       290);
#line 290
      tmp___15 = 1;
      }
    }
#line 199
    node = node->temp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 294
  node = tree->curr;
  {
#line 296
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )node->b_ptr != (unsigned long )((void *)0))) {
#line 296
      goto while_break___7;
    }
    {
#line 298
    b___0 = node->b_ptr;
#line 299
    node->b_ptr = b___0->next;
#line 300
    _glp_dmp_free_atom(tree->pool, (void *)b___0, (int )sizeof(IOSBND ));
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 303
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 303
    if (! ((unsigned long )node->s_ptr != (unsigned long )((void *)0))) {
#line 303
      goto while_break___8;
    }
    {
#line 305
    s___0 = node->s_ptr;
#line 306
    node->s_ptr = s___0->next;
#line 307
    _glp_dmp_free_atom(tree->pool, (void *)s___0, (int )sizeof(IOSTAT ));
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 313
  if ((unsigned long )node->r_ptr == (unsigned long )((void *)0)) {
#line 313
    tmp___16 = 1;
  } else {
    {
#line 313
    _glp_lib_xassert("node->r_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     313);
#line 313
    tmp___16 = 1;
    }
  }
  done: 
#line 315
  return;
}
}
#line 332 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_freeze_node(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  IOSNPD *node ;
  int tmp ;
  int k ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  GLPROW *row ;
  GLPCOL *col ;
  int root_m ;
  int pred_m ;
  int i ;
  int j ;
  int k___0 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int pred_type ;
  int pred_stat ;
  int type ;
  int stat ;
  double pred_lb ;
  double pred_ub ;
  double lb ;
  double ub ;
  GLPROW *row___0 ;
  GLPCOL *col___0 ;
  IOSBND *b ;
  void *tmp___13 ;
  IOSTAT *s ;
  void *tmp___14 ;
  int tmp___15 ;
  int i___0 ;
  int len ;
  int *ind ;
  double *val ;
  void *tmp___16 ;
  void *tmp___17 ;
  GLPROW *row___1 ;
  IOSROW *r ;
  char const   *name ;
  void *tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  IOSAIJ *a ;
  void *tmp___21 ;
  int nrs ;
  int *num ;
  int tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
#line 333
  mip = tree->mip;
#line 334
  m = mip->m;
#line 335
  n = mip->n;
#line 338
  node = tree->curr;
#line 339
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 339
    tmp = 1;
  } else {
    {
#line 339
    _glp_lib_xassert("node != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     339);
#line 339
    tmp = 1;
    }
  }
#line 340
  if ((unsigned long )node->up == (unsigned long )((void *)0)) {
#line 343
    if (node->p == 1) {
#line 343
      tmp___0 = 1;
    } else {
      {
#line 343
      _glp_lib_xassert("node->p == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       343);
#line 343
      tmp___0 = 1;
      }
    }
#line 344
    if (tree->root_m == 0) {
#line 344
      tmp___1 = 1;
    } else {
      {
#line 344
      _glp_lib_xassert("tree->root_m == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       344);
#line 344
      tmp___1 = 1;
      }
    }
#line 345
    if ((unsigned long )tree->root_type == (unsigned long )((void *)0)) {
#line 345
      tmp___2 = 1;
    } else {
      {
#line 345
      _glp_lib_xassert("tree->root_type == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       345);
#line 345
      tmp___2 = 1;
      }
    }
#line 346
    if ((unsigned long )tree->root_lb == (unsigned long )((void *)0)) {
#line 346
      tmp___3 = 1;
    } else {
      {
#line 346
      _glp_lib_xassert("tree->root_lb == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       346);
#line 346
      tmp___3 = 1;
      }
    }
#line 347
    if ((unsigned long )tree->root_ub == (unsigned long )((void *)0)) {
#line 347
      tmp___4 = 1;
    } else {
      {
#line 347
      _glp_lib_xassert("tree->root_ub == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       347);
#line 347
      tmp___4 = 1;
      }
    }
#line 348
    if ((unsigned long )tree->root_stat == (unsigned long )((void *)0)) {
#line 348
      tmp___5 = 1;
    } else {
      {
#line 348
      _glp_lib_xassert("tree->root_stat == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       348);
#line 348
      tmp___5 = 1;
      }
    }
    {
#line 349
    tree->root_m = m;
#line 350
    tmp___6 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 350
    tree->root_type = (int *)tmp___6;
#line 351
    tmp___7 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 351
    tree->root_lb = (double *)tmp___7;
#line 352
    tmp___8 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 352
    tree->root_ub = (double *)tmp___8;
#line 353
    tmp___9 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 353
    tree->root_stat = (int *)tmp___9;
#line 354
    k = 1;
    }
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 354
      if (! (k <= m + n)) {
#line 354
        goto while_break;
      }
#line 355
      if (k <= m) {
#line 356
        row = *(mip->row + k);
#line 357
        *(tree->root_type + k) = row->type;
#line 358
        *(tree->root_lb + k) = row->lb;
#line 359
        *(tree->root_ub + k) = row->ub;
#line 360
        *(tree->root_stat + k) = row->stat;
      } else {
#line 363
        col = *(mip->col + (k - m));
#line 364
        *(tree->root_type + k) = col->type;
#line 365
        *(tree->root_lb + k) = col->lb;
#line 366
        *(tree->root_ub + k) = col->ub;
#line 367
        *(tree->root_stat + k) = col->stat;
      }
#line 354
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 373
    root_m = tree->root_m;
#line 374
    pred_m = tree->pred_m;
#line 376
    if (pred_m <= m) {
#line 376
      tmp___10 = 1;
    } else {
      {
#line 376
      _glp_lib_xassert("pred_m <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       376);
#line 376
      tmp___10 = 1;
      }
    }
#line 379
    if ((unsigned long )node->b_ptr == (unsigned long )((void *)0)) {
#line 379
      tmp___11 = 1;
    } else {
      {
#line 379
      _glp_lib_xassert("node->b_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       379);
#line 379
      tmp___11 = 1;
      }
    }
#line 380
    if ((unsigned long )node->s_ptr == (unsigned long )((void *)0)) {
#line 380
      tmp___12 = 1;
    } else {
      {
#line 380
      _glp_lib_xassert("node->s_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       380);
#line 380
      tmp___12 = 1;
      }
    }
#line 381
    k___0 = 1;
    {
#line 381
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 381
      if (! (k___0 <= pred_m + n)) {
#line 381
        goto while_break___0;
      }
#line 385
      pred_type = *(tree->pred_type + k___0);
#line 386
      pred_lb = *(tree->pred_lb + k___0);
#line 387
      pred_ub = *(tree->pred_ub + k___0);
#line 388
      pred_stat = *(tree->pred_stat + k___0);
#line 390
      if (k___0 <= pred_m) {
#line 391
        row___0 = *(mip->row + k___0);
#line 392
        type = row___0->type;
#line 393
        lb = row___0->lb;
#line 394
        ub = row___0->ub;
#line 395
        stat = row___0->stat;
      } else {
#line 398
        col___0 = *(mip->col + (k___0 - pred_m));
#line 399
        type = col___0->type;
#line 400
        lb = col___0->lb;
#line 401
        ub = col___0->ub;
#line 402
        stat = col___0->stat;
      }
#line 405
      if (pred_type == type) {
#line 405
        if (pred_lb == lb) {
#line 405
          if (! (pred_ub == ub)) {
#line 405
            goto _L___0;
          }
        } else {
#line 405
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 407
        tmp___13 = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSBND ));
#line 407
        b = (IOSBND *)tmp___13;
#line 408
        b->k = k___0;
#line 409
        b->type = type;
#line 410
        b->lb = lb;
#line 411
        b->ub = ub;
#line 412
        b->next = node->b_ptr;
#line 413
        node->b_ptr = b;
        }
      }
#line 416
      if (pred_stat != stat) {
        {
#line 418
        tmp___14 = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSTAT ));
#line 418
        s = (IOSTAT *)tmp___14;
#line 419
        s->k = k___0;
#line 420
        s->stat = stat;
#line 421
        s->next = node->s_ptr;
#line 422
        node->s_ptr = s;
        }
      }
#line 381
      k___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 426
    if ((unsigned long )node->r_ptr == (unsigned long )((void *)0)) {
#line 426
      tmp___15 = 1;
    } else {
      {
#line 426
      _glp_lib_xassert("node->r_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       426);
#line 426
      tmp___15 = 1;
      }
    }
#line 427
    if (pred_m < m) {
      {
#line 430
      tmp___16 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 430
      ind = (int *)tmp___16;
#line 431
      tmp___17 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 431
      val = (double *)tmp___17;
#line 432
      i___0 = m;
      }
      {
#line 432
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 432
        if (! (i___0 > pred_m)) {
#line 432
          goto while_break___1;
        }
        {
#line 433
        row___1 = *(mip->row + i___0);
#line 436
        tmp___18 = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSROW ));
#line 436
        r = (IOSROW *)tmp___18;
#line 437
        name = glp_get_row_name(mip, i___0);
        }
#line 438
        if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 439
          r->name = (char *)((void *)0);
        } else {
          {
#line 441
          tmp___19 = strlen(name);
#line 441
          tmp___20 = _glp_dmp_get_atom(tree->pool, (int )(tmp___19 + 1U));
#line 441
          r->name = (char *)tmp___20;
#line 442
          strcpy((char */* __restrict  */)r->name, (char const   */* __restrict  */)name);
          }
        }
        {
#line 445
        r->origin = row___1->origin;
#line 446
        r->klass = row___1->klass;
#line 448
        r->type = row___1->type;
#line 449
        r->lb = row___1->lb;
#line 450
        r->ub = row___1->ub;
#line 451
        r->ptr = (IOSAIJ *)((void *)0);
#line 452
        len = glp_get_mat_row(mip, i___0, ind, val);
#line 453
        k___0 = 1;
        }
        {
#line 453
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 453
          if (! (k___0 <= len)) {
#line 453
            goto while_break___2;
          }
          {
#line 455
          tmp___21 = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSAIJ ));
#line 455
          a = (IOSAIJ *)tmp___21;
#line 456
          a->j = *(ind + k___0);
#line 457
          a->val = *(val + k___0);
#line 458
          a->next = r->ptr;
#line 459
          r->ptr = a;
#line 453
          k___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 461
        r->rii = row___1->rii;
#line 462
        r->stat = row___1->stat;
#line 463
        r->next = node->r_ptr;
#line 464
        node->r_ptr = r;
#line 432
        i___0 --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 466
      _glp_lib_xfree((void *)ind);
#line 467
      _glp_lib_xfree((void *)val);
      }
    }
#line 470
    if (m != root_m) {
#line 472
      nrs = m - root_m;
#line 473
      if (nrs > 0) {
#line 473
        tmp___22 = 1;
      } else {
        {
#line 473
        _glp_lib_xassert("nrs > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         473);
#line 473
        tmp___22 = 1;
        }
      }
      {
#line 474
      tmp___23 = _glp_lib_xcalloc(1 + nrs, (int )sizeof(int ));
#line 474
      num = (int *)tmp___23;
#line 475
      i = 1;
      }
      {
#line 475
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 475
        if (! (i <= nrs)) {
#line 475
          goto while_break___3;
        }
#line 475
        *(num + i) = root_m + i;
#line 475
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 476
      glp_del_rows(mip, nrs, (int const   *)num);
#line 477
      _glp_lib_xfree((void *)num);
      }
    }
#line 479
    m = mip->m;
#line 482
    if (m == root_m) {
#line 482
      tmp___24 = 1;
    } else {
      {
#line 482
      _glp_lib_xassert("m == root_m", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       482);
#line 482
      tmp___24 = 1;
      }
    }
#line 483
    i = 1;
    {
#line 483
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 483
      if (! (i <= m)) {
#line 483
        goto while_break___4;
      }
      {
#line 484
      glp_set_row_bnds(mip, i, *(tree->root_type + i), *(tree->root_lb + i), *(tree->root_ub + i));
#line 486
      glp_set_row_stat(mip, i, *(tree->root_stat + i));
#line 483
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 488
    j = 1;
    {
#line 488
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 488
      if (! (j <= n)) {
#line 488
        goto while_break___5;
      }
      {
#line 489
      glp_set_col_bnds(mip, j, *(tree->root_type + (m + j)), *(tree->root_lb + (m + j)),
                       *(tree->root_ub + (m + j)));
#line 491
      glp_set_col_stat(mip, j, *(tree->root_stat + (m + j)));
#line 488
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 500
  tree->curr = (IOSNPD *)((void *)0);
#line 501
  return;
}
}
#line 528 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
static int get_slot(glp_tree___0 *tree ) 
{ 
  int p ;
  int nslots ;
  IOSLOT *save ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 531
  if (tree->avail == 0) {
#line 532
    nslots = tree->nslots;
#line 533
    save = tree->slot;
#line 534
    if (nslots == 0) {
#line 535
      tree->nslots = 20;
    } else {
#line 537
      tree->nslots = nslots + nslots;
#line 538
      if (tree->nslots > nslots) {
#line 538
        tmp = 1;
      } else {
        {
#line 538
        _glp_lib_xassert("tree->nslots > nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         538);
#line 538
        tmp = 1;
        }
      }
    }
    {
#line 540
    tmp___0 = _glp_lib_xcalloc(1 + tree->nslots, (int )sizeof(IOSLOT ));
#line 540
    tree->slot = (IOSLOT *)tmp___0;
    }
#line 541
    if ((unsigned long )save != (unsigned long )((void *)0)) {
      {
#line 542
      memcpy((void */* __restrict  */)(tree->slot + 1), (void const   */* __restrict  */)(save + 1),
             (size_t )((unsigned long )nslots * sizeof(IOSLOT )));
#line 543
      _glp_lib_xfree((void *)save);
      }
    }
#line 546
    p = tree->nslots;
    {
#line 546
    while (1) {
      while_continue: /* CIL Label */ ;
#line 546
      if (! (p > nslots)) {
#line 546
        goto while_break;
      }
#line 547
      (tree->slot + p)->node = (IOSNPD *)((void *)0);
#line 548
      (tree->slot + p)->next = tree->avail;
#line 549
      tree->avail = p;
#line 546
      p --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 553
  p = tree->avail;
#line 554
  tree->avail = (tree->slot + p)->next;
#line 555
  if ((unsigned long )(tree->slot + p)->node == (unsigned long )((void *)0)) {
#line 555
    tmp___1 = 1;
  } else {
    {
#line 555
    _glp_lib_xassert("tree->slot[p].node == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     555);
#line 555
    tmp___1 = 1;
    }
  }
#line 556
  (tree->slot + p)->next = 0;
#line 557
  return (p);
}
}
#line 560 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
static IOSNPD *new_node(glp_tree___0 *tree , IOSNPD *parent ) 
{ 
  IOSNPD *node ;
  int p ;
  void *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 564
  p = get_slot(tree);
#line 566
  tmp = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSNPD ));
#line 566
  node = (IOSNPD *)tmp;
#line 567
  (tree->slot + p)->node = node;
#line 568
  node->p = p;
#line 569
  node->up = parent;
  }
#line 570
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 570
    node->level = 0;
  } else {
#line 570
    node->level = parent->level + 1;
  }
#line 571
  node->count = 0;
#line 572
  node->b_ptr = (IOSBND *)((void *)0);
#line 573
  node->s_ptr = (IOSTAT *)((void *)0);
#line 574
  node->r_ptr = (IOSROW *)((void *)0);
#line 575
  tmp___0 = 0;
#line 575
  node->own_nc = tmp___0;
#line 575
  node->own_nn = tmp___0;
#line 576
  node->e_ptr = (IOSRIB *)((void *)0);
#line 578
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 578
    if ((tree->mip)->dir == 1) {
#line 578
      tmp___1 = - 1.7976931348623157e+308;
    } else {
#line 578
      tmp___1 = 1.7976931348623157e+308;
    }
#line 578
    node->lp_obj = tmp___1;
  } else {
#line 578
    node->lp_obj = parent->lp_obj;
  }
#line 581
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 581
    if ((tree->mip)->dir == 1) {
#line 581
      tmp___2 = - 1.7976931348623157e+308;
    } else {
#line 581
      tmp___2 = 1.7976931348623157e+308;
    }
#line 581
    node->bound = tmp___2;
  } else {
#line 581
    node->bound = parent->bound;
  }
#line 583
  node->br_var = 0;
#line 584
  node->br_val = 0.0;
#line 585
  node->ii_cnt = 0;
#line 586
  node->ii_sum = 0.0;
#line 587
  if ((tree->parm)->cb_size == 0) {
#line 588
    node->data = (void *)0;
  } else {
    {
#line 590
    node->data = _glp_dmp_get_atom(tree->pool, (int )(tree->parm)->cb_size);
#line 591
    memset(node->data, 0, (size_t )(tree->parm)->cb_size);
    }
  }
#line 593
  node->temp = (IOSNPD *)((void *)0);
#line 594
  node->prev = tree->tail;
#line 595
  node->next = (IOSNPD *)((void *)0);
#line 597
  if ((unsigned long )tree->head == (unsigned long )((void *)0)) {
#line 598
    tree->head = node;
  } else {
#line 600
    (tree->tail)->next = node;
  }
#line 601
  tree->tail = node;
#line 602
  (tree->a_cnt) ++;
#line 603
  (tree->n_cnt) ++;
#line 604
  (tree->t_cnt) ++;
#line 606
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 607
    if (p == 1) {
#line 607
      tmp___3 = 1;
    } else {
      {
#line 607
      _glp_lib_xassert("p == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       607);
#line 607
      tmp___3 = 1;
      }
    }
  } else {
#line 609
    (parent->count) ++;
  }
#line 610
  return (node);
}
}
#line 613 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_clone_node(glp_tree___0 *tree , int p , int nnn , int *ref ) 
{ 
  IOSNPD *node ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  IOSNPD *tmp___3 ;
  int tmp___4 ;
  IOSNPD *tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 617
  if (1 <= p) {
#line 617
    if (p <= tree->nslots) {
#line 617
      tmp = 1;
    } else {
      {
#line 617
      _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       617);
#line 617
      tmp = 1;
      }
    }
  } else {
    {
#line 617
    _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     617);
#line 617
    tmp = 1;
    }
  }
#line 618
  node = (tree->slot + p)->node;
#line 619
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 619
    tmp___0 = 1;
  } else {
    {
#line 619
    _glp_lib_xassert("node != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     619);
#line 619
    tmp___0 = 1;
    }
  }
#line 621
  if (node->count == 0) {
#line 621
    tmp___1 = 1;
  } else {
    {
#line 621
    _glp_lib_xassert("node->count == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     621);
#line 621
    tmp___1 = 1;
    }
  }
#line 623
  if ((unsigned long )tree->curr != (unsigned long )node) {
#line 623
    tmp___2 = 1;
  } else {
    {
#line 623
    _glp_lib_xassert("tree->curr != node", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     623);
#line 623
    tmp___2 = 1;
    }
  }
#line 626
  if ((unsigned long )node->prev == (unsigned long )((void *)0)) {
#line 627
    tree->head = node->next;
  } else {
#line 629
    (node->prev)->next = node->next;
  }
#line 630
  if ((unsigned long )node->next == (unsigned long )((void *)0)) {
#line 631
    tree->tail = node->prev;
  } else {
#line 633
    (node->next)->prev = node->prev;
  }
#line 634
  tmp___3 = (IOSNPD *)((void *)0);
#line 634
  node->next = tmp___3;
#line 634
  node->prev = tmp___3;
#line 635
  (tree->a_cnt) --;
#line 637
  if (nnn > 0) {
#line 637
    tmp___4 = 1;
  } else {
    {
#line 637
    _glp_lib_xassert("nnn > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     637);
#line 637
    tmp___4 = 1;
    }
  }
#line 638
  k = 1;
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! (k <= nnn)) {
#line 638
      goto while_break;
    }
    {
#line 639
    tmp___5 = new_node(tree, node);
#line 639
    *(ref + k) = tmp___5->p;
#line 638
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  return;
}
}
#line 663 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_delete_node(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  IOSNPD *temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  IOSNPD *tmp___3 ;
  IOSBND *b ;
  IOSTAT *s ;
  IOSROW *r ;
  size_t tmp___4 ;
  IOSAIJ *a ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 666
  if (1 <= p) {
#line 666
    if (p <= tree->nslots) {
#line 666
      tmp = 1;
    } else {
      {
#line 666
      _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       666);
#line 666
      tmp = 1;
      }
    }
  } else {
    {
#line 666
    _glp_lib_xassert("1 <= p && p <= tree->nslots", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     666);
#line 666
    tmp = 1;
    }
  }
#line 667
  node = (tree->slot + p)->node;
#line 668
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 668
    tmp___0 = 1;
  } else {
    {
#line 668
    _glp_lib_xassert("node != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     668);
#line 668
    tmp___0 = 1;
    }
  }
#line 670
  if (node->count == 0) {
#line 670
    tmp___1 = 1;
  } else {
    {
#line 670
    _glp_lib_xassert("node->count == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     670);
#line 670
    tmp___1 = 1;
    }
  }
#line 672
  if ((unsigned long )tree->curr != (unsigned long )node) {
#line 672
    tmp___2 = 1;
  } else {
    {
#line 672
    _glp_lib_xassert("tree->curr != node", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     672);
#line 672
    tmp___2 = 1;
    }
  }
#line 675
  if ((unsigned long )node->prev == (unsigned long )((void *)0)) {
#line 676
    tree->head = node->next;
  } else {
#line 678
    (node->prev)->next = node->next;
  }
#line 679
  if ((unsigned long )node->next == (unsigned long )((void *)0)) {
#line 680
    tree->tail = node->prev;
  } else {
#line 682
    (node->next)->prev = node->prev;
  }
#line 683
  tmp___3 = (IOSNPD *)((void *)0);
#line 683
  node->next = tmp___3;
#line 683
  node->prev = tmp___3;
#line 684
  (tree->a_cnt) --;
  loop: 
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 688
    if (! ((unsigned long )node->b_ptr != (unsigned long )((void *)0))) {
#line 688
      goto while_break;
    }
    {
#line 689
    b = node->b_ptr;
#line 690
    node->b_ptr = b->next;
#line 691
    _glp_dmp_free_atom(tree->pool, (void *)b, (int )sizeof(IOSBND ));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 696
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 696
    if (! ((unsigned long )node->s_ptr != (unsigned long )((void *)0))) {
#line 696
      goto while_break___0;
    }
    {
#line 697
    s = node->s_ptr;
#line 698
    node->s_ptr = s->next;
#line 699
    _glp_dmp_free_atom(tree->pool, (void *)s, (int )sizeof(IOSTAT ));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 703
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 703
    if (! ((unsigned long )node->r_ptr != (unsigned long )((void *)0))) {
#line 703
      goto while_break___1;
    }
#line 705
    r = node->r_ptr;
#line 706
    if ((unsigned long )r->name != (unsigned long )((void *)0)) {
      {
#line 707
      tmp___4 = strlen((char const   *)r->name);
#line 707
      _glp_dmp_free_atom(tree->pool, (void *)r->name, (int )(tmp___4 + 1U));
      }
    }
    {
#line 708
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 708
      if (! ((unsigned long )r->ptr != (unsigned long )((void *)0))) {
#line 708
        goto while_break___2;
      }
      {
#line 710
      a = r->ptr;
#line 711
      r->ptr = a->next;
#line 712
      _glp_dmp_free_atom(tree->pool, (void *)a, (int )sizeof(IOSAIJ ));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 714
    node->r_ptr = r->next;
#line 715
    _glp_dmp_free_atom(tree->pool, (void *)r, (int )sizeof(IOSROW ));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 721
  if (node->own_nn == 0) {
#line 721
    tmp___5 = 1;
  } else {
    {
#line 721
    _glp_lib_xassert("node->own_nn == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     721);
#line 721
    tmp___5 = 1;
    }
  }
#line 722
  if (node->own_nc == 0) {
#line 722
    tmp___6 = 1;
  } else {
    {
#line 722
    _glp_lib_xassert("node->own_nc == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     722);
#line 722
    tmp___6 = 1;
    }
  }
#line 723
  if ((unsigned long )node->e_ptr == (unsigned long )((void *)0)) {
#line 723
    tmp___7 = 1;
  } else {
    {
#line 723
    _glp_lib_xassert("node->e_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     723);
#line 723
    tmp___7 = 1;
    }
  }
#line 726
  if ((tree->parm)->cb_size == 0) {
#line 727
    if ((unsigned long )node->data == (unsigned long )((void *)0)) {
#line 727
      tmp___8 = 1;
    } else {
      {
#line 727
      _glp_lib_xassert("node->data == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       727);
#line 727
      tmp___8 = 1;
      }
    }
  } else {
    {
#line 729
    _glp_dmp_free_atom(tree->pool, node->data, (int )(tree->parm)->cb_size);
    }
  }
#line 731
  p = node->p;
#line 732
  if ((unsigned long )(tree->slot + p)->node == (unsigned long )node) {
#line 732
    tmp___9 = 1;
  } else {
    {
#line 732
    _glp_lib_xassert("tree->slot[p].node == node", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     732);
#line 732
    tmp___9 = 1;
    }
  }
  {
#line 733
  (tree->slot + p)->node = (IOSNPD *)((void *)0);
#line 734
  (tree->slot + p)->next = tree->avail;
#line 735
  tree->avail = p;
#line 737
  temp = node->up;
#line 739
  _glp_dmp_free_atom(tree->pool, (void *)node, (int )sizeof(IOSNPD ));
#line 740
  (tree->n_cnt) --;
#line 742
  node = temp;
  }
#line 743
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 746
    if (node->count > 0) {
#line 746
      tmp___10 = 1;
    } else {
      {
#line 746
      _glp_lib_xassert("node->count > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       746);
#line 746
      tmp___10 = 1;
      }
    }
#line 747
    (node->count) --;
#line 750
    if (node->count == 0) {
#line 750
      goto loop;
    }
  }
#line 752
  return;
}
}
#line 774 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_delete_tree(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int i ;
  int j ;
  int m ;
  int n ;
  int tmp ;
  int nrs ;
  int *num ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 775
  mip = tree->mip;
#line 777
  m = mip->m;
#line 778
  n = mip->n;
#line 779
  if ((unsigned long )mip->tree == (unsigned long )tree) {
#line 779
    tmp = 1;
  } else {
    {
#line 779
    _glp_lib_xassert("mip->tree == tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     779);
#line 779
    tmp = 1;
    }
  }
#line 781
  if (m != tree->orig_m) {
#line 783
    nrs = m - tree->orig_m;
#line 784
    if (nrs > 0) {
#line 784
      tmp___0 = 1;
    } else {
      {
#line 784
      _glp_lib_xassert("nrs > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       784);
#line 784
      tmp___0 = 1;
      }
    }
    {
#line 785
    tmp___1 = _glp_lib_xcalloc(1 + nrs, (int )sizeof(int ));
#line 785
    num = (int *)tmp___1;
#line 786
    i = 1;
    }
    {
#line 786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 786
      if (! (i <= nrs)) {
#line 786
        goto while_break;
      }
#line 786
      *(num + i) = tree->orig_m + i;
#line 786
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 787
    glp_del_rows(mip, nrs, (int const   *)num);
#line 788
    _glp_lib_xfree((void *)num);
    }
  }
#line 790
  m = tree->orig_m;
#line 792
  if (m == tree->orig_m) {
#line 792
    tmp___2 = 1;
  } else {
    {
#line 792
    _glp_lib_xassert("m == tree->orig_m", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     792);
#line 792
    tmp___2 = 1;
    }
  }
#line 793
  if (n == tree->n) {
#line 793
    tmp___3 = 1;
  } else {
    {
#line 793
    _glp_lib_xassert("n == tree->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     793);
#line 793
    tmp___3 = 1;
    }
  }
#line 794
  i = 1;
  {
#line 794
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 794
    if (! (i <= m)) {
#line 794
      goto while_break___0;
    }
    {
#line 795
    glp_set_row_bnds(mip, i, *(tree->orig_type + i), *(tree->orig_lb + i), *(tree->orig_ub + i));
#line 797
    glp_set_row_stat(mip, i, *(tree->orig_stat + i));
#line 798
    (*(mip->row + i))->prim = *(tree->orig_prim + i);
#line 799
    (*(mip->row + i))->dual = *(tree->orig_dual + i);
#line 794
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 801
  j = 1;
  {
#line 801
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 801
    if (! (j <= n)) {
#line 801
      goto while_break___1;
    }
    {
#line 802
    glp_set_col_bnds(mip, j, *(tree->orig_type + (m + j)), *(tree->orig_lb + (m + j)),
                     *(tree->orig_ub + (m + j)));
#line 804
    glp_set_col_stat(mip, j, *(tree->orig_stat + (m + j)));
#line 805
    (*(mip->col + j))->prim = *(tree->orig_prim + (m + j));
#line 806
    (*(mip->col + j))->dual = *(tree->orig_dual + (m + j));
#line 801
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 808
  tmp___4 = 2;
#line 808
  mip->dbs_stat = tmp___4;
#line 808
  mip->pbs_stat = tmp___4;
#line 809
  mip->obj_val = tree->orig_obj;
#line 811
  if ((unsigned long )tree->local != (unsigned long )((void *)0)) {
#line 811
    tmp___5 = 1;
  } else {
    {
#line 811
    _glp_lib_xassert("tree->local != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     811);
#line 811
    tmp___5 = 1;
    }
  }
  {
#line 812
  _glp_ios_delete_pool(tree, tree->local);
#line 813
  _glp_dmp_delete_pool(tree->pool);
#line 814
  _glp_lib_xfree((void *)tree->orig_type);
#line 815
  _glp_lib_xfree((void *)tree->orig_lb);
#line 816
  _glp_lib_xfree((void *)tree->orig_ub);
#line 817
  _glp_lib_xfree((void *)tree->orig_stat);
#line 818
  _glp_lib_xfree((void *)tree->orig_prim);
#line 819
  _glp_lib_xfree((void *)tree->orig_dual);
#line 820
  _glp_lib_xfree((void *)tree->slot);
  }
#line 821
  if ((unsigned long )tree->root_type != (unsigned long )((void *)0)) {
    {
#line 821
    _glp_lib_xfree((void *)tree->root_type);
    }
  }
#line 822
  if ((unsigned long )tree->root_lb != (unsigned long )((void *)0)) {
    {
#line 822
    _glp_lib_xfree((void *)tree->root_lb);
    }
  }
#line 823
  if ((unsigned long )tree->root_ub != (unsigned long )((void *)0)) {
    {
#line 823
    _glp_lib_xfree((void *)tree->root_ub);
    }
  }
#line 824
  if ((unsigned long )tree->root_stat != (unsigned long )((void *)0)) {
    {
#line 824
    _glp_lib_xfree((void *)tree->root_stat);
    }
  }
  {
#line 825
  _glp_lib_xfree((void *)tree->non_int);
#line 826
  _glp_lib_xfree((void *)tree->n_ref);
#line 827
  _glp_lib_xfree((void *)tree->c_ref);
#line 828
  _glp_lib_xfree((void *)tree->j_ref);
  }
#line 829
  if ((unsigned long )tree->pcost != (unsigned long )((void *)0)) {
    {
#line 829
    _glp_ios_pcost_free(tree);
    }
  }
  {
#line 830
  _glp_lib_xfree((void *)tree->iwrk);
#line 831
  _glp_lib_xfree((void *)tree->dwrk);
#line 832
  _glp_scg_delete_graph(tree->g);
  }
#line 833
  if ((unsigned long )tree->pred_type != (unsigned long )((void *)0)) {
    {
#line 833
    _glp_lib_xfree((void *)tree->pred_type);
    }
  }
#line 834
  if ((unsigned long )tree->pred_lb != (unsigned long )((void *)0)) {
    {
#line 834
    _glp_lib_xfree((void *)tree->pred_lb);
    }
  }
#line 835
  if ((unsigned long )tree->pred_ub != (unsigned long )((void *)0)) {
    {
#line 835
    _glp_lib_xfree((void *)tree->pred_ub);
    }
  }
#line 836
  if ((unsigned long )tree->pred_stat != (unsigned long )((void *)0)) {
    {
#line 836
    _glp_lib_xfree((void *)tree->pred_stat);
    }
  }
#line 840
  if ((unsigned long )tree->mir_gen == (unsigned long )((void *)0)) {
#line 840
    tmp___6 = 1;
  } else {
    {
#line 840
    _glp_lib_xassert("tree->mir_gen == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     840);
#line 840
    tmp___6 = 1;
    }
  }
#line 841
  if ((unsigned long )tree->clq_gen == (unsigned long )((void *)0)) {
#line 841
    tmp___7 = 1;
  } else {
    {
#line 841
    _glp_lib_xassert("tree->clq_gen == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     841);
#line 841
    tmp___7 = 1;
    }
  }
  {
#line 842
  _glp_lib_xfree((void *)tree);
#line 843
  mip->tree = (void *)0;
  }
#line 844
  return;
}
}
#line 865 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_eval_degrad(glp_tree___0 *tree , int j , double *dn , double *up ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  int len ;
  int kase ;
  int k ;
  int t ;
  int stat ;
  double alfa ;
  double beta ;
  double gamma___0 ;
  double delta ;
  double dz ;
  int *ind ;
  double *val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
#line 866
  mip = tree->mip;
#line 867
  m = mip->m;
#line 867
  n = mip->n;
#line 870
  ind = tree->iwrk;
#line 871
  val = tree->dwrk;
#line 873
  tmp = glp_get_status(mip);
  }
#line 873
  if (tmp == 5) {
#line 873
    tmp___0 = 1;
  } else {
    {
#line 873
    _glp_lib_xassert("glp_get_status(mip) == GLP_OPT", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     873);
#line 873
    tmp___0 = 1;
    }
  }
  {
#line 875
  tmp___1 = glp_bf_exists(mip);
  }
#line 875
  if (tmp___1) {
#line 875
    tmp___2 = 1;
  } else {
    {
#line 875
    _glp_lib_xassert("glp_bf_exists(mip)", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     875);
#line 875
    tmp___2 = 1;
    }
  }
#line 878
  if (1 <= j) {
#line 878
    if (j <= n) {
#line 878
      tmp___3 = 1;
    } else {
      {
#line 878
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       878);
#line 878
      tmp___3 = 1;
      }
    }
  } else {
    {
#line 878
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     878);
#line 878
    tmp___3 = 1;
    }
  }
  {
#line 879
  beta = (*(mip->col + j))->prim;
#line 882
  len = _glp_lpx_eval_tab_row(mip, m + j, ind, val);
#line 884
  kase = -1;
  }
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    if (! (kase <= 1)) {
#line 884
      goto while_break;
    }
    {
#line 892
    k = _glp_lpx_dual_ratio_test(mip, len, (int const   *)ind, (double const   *)val,
                                 kase, 1e-7);
    }
#line 897
    if (k == 0) {
#line 898
      if (mip->dir == 1) {
#line 899
        if (kase < 0) {
#line 900
          *dn = 1.7976931348623157e+308;
        } else {
#line 902
          *up = 1.7976931348623157e+308;
        }
      } else
#line 904
      if (mip->dir == 2) {
#line 905
        if (kase < 0) {
#line 906
          *dn = - 1.7976931348623157e+308;
        } else {
#line 908
          *up = - 1.7976931348623157e+308;
        }
      } else
#line 911
      if ((unsigned long )mip != (unsigned long )mip) {
#line 911
        tmp___4 = 1;
      } else {
        {
#line 911
        _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         911);
#line 911
        tmp___4 = 1;
        }
      }
#line 912
      goto __Cont;
    }
#line 914
    if (1 <= k) {
#line 914
      if (k <= m + n) {
#line 914
        tmp___5 = 1;
      } else {
        {
#line 914
        _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         914);
#line 914
        tmp___5 = 1;
        }
      }
    } else {
      {
#line 914
      _glp_lib_xassert("1 <= k && k <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       914);
#line 914
      tmp___5 = 1;
      }
    }
#line 920
    t = 1;
    {
#line 920
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 920
      if (! (t <= len)) {
#line 920
        goto while_break___0;
      }
#line 921
      if (*(ind + t) == k) {
#line 921
        goto while_break___0;
      }
#line 920
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 922
    if (1 <= t) {
#line 922
      if (t <= len) {
#line 922
        tmp___6 = 1;
      } else {
        {
#line 922
        _glp_lib_xassert("1 <= t && t <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         922);
#line 922
        tmp___6 = 1;
        }
      }
    } else {
      {
#line 922
      _glp_lib_xassert("1 <= t && t <= len", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       922);
#line 922
      tmp___6 = 1;
      }
    }
#line 923
    alfa = *(val + t);
#line 925
    if (k <= m) {
#line 926
      stat = (*(mip->row + k))->stat;
#line 927
      gamma___0 = (*(mip->row + k))->dual;
    } else {
#line 930
      stat = (*(mip->col + (k - m)))->stat;
#line 931
      gamma___0 = (*(mip->col + (k - m)))->dual;
    }
#line 934
    if (stat == 2) {
#line 934
      tmp___7 = 1;
    } else
#line 934
    if (stat == 3) {
#line 934
      tmp___7 = 1;
    } else
#line 934
    if (stat == 4) {
#line 934
      tmp___7 = 1;
    } else {
      {
#line 934
      _glp_lib_xassert("stat == GLP_NL || stat == GLP_NU || stat == GLP_NF", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       934);
#line 934
      tmp___7 = 1;
      }
    }
#line 938
    if (mip->dir == 1) {
#line 939
      if (stat == 2) {
#line 939
        if (gamma___0 < 0.0) {
#line 941
          gamma___0 = 0.0;
        } else {
#line 939
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 939
      if (stat == 3) {
#line 939
        if (gamma___0 > 0.0) {
#line 941
          gamma___0 = 0.0;
        } else {
#line 939
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 939
      if (stat == 4) {
#line 941
        gamma___0 = 0.0;
      }
    } else
#line 943
    if (mip->dir == 2) {
#line 944
      if (stat == 2) {
#line 944
        if (gamma___0 > 0.0) {
#line 946
          gamma___0 = 0.0;
        } else {
#line 944
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 944
      if (stat == 3) {
#line 944
        if (gamma___0 < 0.0) {
#line 946
          gamma___0 = 0.0;
        } else {
#line 944
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 944
      if (stat == 4) {
#line 946
        gamma___0 = 0.0;
      }
    } else
#line 949
    if ((unsigned long )mip != (unsigned long )mip) {
#line 949
      tmp___8 = 1;
    } else {
      {
#line 949
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       949);
#line 949
      tmp___8 = 1;
      }
    }
#line 952
    if (kase < 0) {
      {
#line 952
      tmp___9 = floor(beta);
#line 952
      tmp___11 = tmp___9;
      }
    } else {
      {
#line 952
      tmp___10 = ceil(beta);
#line 952
      tmp___11 = tmp___10;
      }
    }
#line 952
    delta = tmp___11 - beta;
#line 955
    delta /= alfa;
#line 958
    dz = gamma___0 * delta;
#line 959
    if (mip->dir == 1) {
#line 960
      if (dz >= 0.0) {
#line 960
        tmp___12 = 1;
      } else {
        {
#line 960
        _glp_lib_xassert("dz >= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         960);
#line 960
        tmp___12 = 1;
        }
      }
    } else
#line 961
    if (mip->dir == 2) {
#line 962
      if (dz <= 0.0) {
#line 962
        tmp___13 = 1;
      } else {
        {
#line 962
        _glp_lib_xassert("dz <= 0.0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         962);
#line 962
        tmp___13 = 1;
        }
      }
    } else
#line 964
    if ((unsigned long )mip != (unsigned long )mip) {
#line 964
      tmp___14 = 1;
    } else {
      {
#line 964
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       964);
#line 964
      tmp___14 = 1;
      }
    }
#line 967
    if (kase < 0) {
#line 968
      *dn = mip->obj_val + dz;
    } else {
#line 970
      *up = mip->obj_val + dz;
    }
    __Cont: /* CIL Label */ 
#line 884
    kase += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 974
  return;
}
}
#line 1033 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
double _glp_ios_round_bound(glp_tree___0 *tree , double bound ) 
{ 
  glp_prob *mip ;
  int n ;
  int d___0 ;
  int j ;
  int nn ;
  int *c ;
  double s ;
  double h ;
  GLPCOL *col ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1034
  mip = tree->mip;
#line 1035
  n = mip->n;
#line 1036
  c = tree->iwrk;
#line 1039
  nn = 0;
#line 1039
  s = mip->c0;
#line 1039
  d___0 = 0;
#line 1040
  j = 1;
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1040
    if (! (j <= n)) {
#line 1040
      goto while_break;
    }
#line 1041
    col = *(mip->col + j);
#line 1042
    if (col->coef == 0.0) {
#line 1042
      goto __Cont;
    }
#line 1043
    if (col->type == 5) {
#line 1045
      s += col->coef * col->prim;
    } else {
#line 1049
      if (col->kind != 2) {
#line 1049
        goto skip;
      }
      {
#line 1050
      tmp = floor(col->coef);
      }
#line 1050
      if (col->coef != tmp) {
#line 1050
        goto skip;
      }
      {
#line 1051
      tmp___1 = fabs(col->coef);
      }
#line 1051
      if (tmp___1 <= (double )2147483647) {
        {
#line 1052
        nn ++;
#line 1052
        tmp___0 = fabs(col->coef);
#line 1052
        *(c + nn) = (int )tmp___0;
        }
      } else {
#line 1054
        d___0 = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 1040
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1058
  if (d___0 == 0) {
#line 1059
    if (nn == 0) {
#line 1059
      goto skip;
    }
    {
#line 1060
    d___0 = _glp_lib_gcdn(nn, c);
    }
  }
#line 1062
  if (d___0 > 0) {
#line 1062
    tmp___2 = 1;
  } else {
    {
#line 1062
    _glp_lib_xassert("d > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c", 1062);
#line 1062
    tmp___2 = 1;
    }
  }
#line 1064
  if (mip->dir == 1) {
#line 1065
    if (bound != 1.7976931348623157e+308) {
      {
#line 1066
      h = (bound - s) / (double )d___0;
#line 1067
      tmp___3 = floor(h);
      }
#line 1067
      if (h >= tmp___3 + 0.001) {
        {
#line 1069
        h = ceil(h);
#line 1071
        bound = (double )d___0 * h + s;
        }
      }
    }
  } else
#line 1076
  if (mip->dir == 2) {
#line 1077
    if (bound != - 1.7976931348623157e+308) {
      {
#line 1078
      h = (bound - s) / (double )d___0;
#line 1079
      tmp___4 = ceil(h);
      }
#line 1079
      if (h <= tmp___4 - 0.001) {
        {
#line 1081
        h = floor(h);
#line 1082
        bound = (double )d___0 * h + s;
        }
      }
    }
  } else
#line 1087
  if ((unsigned long )mip != (unsigned long )mip) {
#line 1087
    tmp___5 = 1;
  } else {
    {
#line 1087
    _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1087);
#line 1087
    tmp___5 = 1;
    }
  }
  skip: 
#line 1088
  return (bound);
}
}
#line 1113 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
int _glp_ios_is_hopeful(glp_tree___0 *tree , double bound ) 
{ 
  glp_prob *mip ;
  int ret ;
  double eps ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1114
  mip = tree->mip;
#line 1115
  ret = 1;
#line 1117
  if (mip->mip_stat == 2) {
    {
#line 1118
    tmp = fabs(mip->mip_obj);
#line 1118
    eps = (double )((tree->parm)->tol_obj * (double const   )(1.0 + tmp));
    }
    {
#line 1120
    if (mip->dir == 1) {
#line 1120
      goto case_1;
    }
#line 1123
    if (mip->dir == 2) {
#line 1123
      goto case_2;
    }
#line 1126
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1121
    if (bound >= mip->mip_obj - eps) {
#line 1121
      ret = 0;
    }
#line 1122
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1124
    if (bound <= mip->mip_obj + eps) {
#line 1124
      ret = 0;
    }
#line 1125
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1127
    if ((unsigned long )mip != (unsigned long )mip) {
#line 1127
      tmp___0 = 1;
    } else {
      {
#line 1127
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1127);
#line 1127
      tmp___0 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1132
    if (mip->dir == 1) {
#line 1132
      goto case_1___0;
    }
#line 1135
    if (mip->dir == 2) {
#line 1135
      goto case_2___0;
    }
#line 1138
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 1133
    if (bound == 1.7976931348623157e+308) {
#line 1133
      ret = 0;
    }
#line 1134
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1136
    if (bound == - 1.7976931348623157e+308) {
#line 1136
      ret = 0;
    }
#line 1137
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1139
    if ((unsigned long )mip != (unsigned long )mip) {
#line 1139
      tmp___1 = 1;
    } else {
      {
#line 1139
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1139);
#line 1139
      tmp___1 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1142
  return (ret);
}
}
#line 1170 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
int _glp_ios_best_node(glp_tree___0 *tree ) 
{ 
  IOSNPD *node ;
  IOSNPD *best ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1171
  best = (IOSNPD *)((void *)0);
  {
#line 1173
  if ((tree->mip)->dir == 1) {
#line 1173
    goto case_1;
  }
#line 1179
  if ((tree->mip)->dir == 2) {
#line 1179
    goto case_2;
  }
#line 1185
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1175
  node = tree->head;
  {
#line 1175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1175
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1175
      goto while_break;
    }
#line 1176
    if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 1177
      best = node;
    } else
#line 1176
    if (best->bound > node->bound) {
#line 1177
      best = node;
    }
#line 1175
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1181
  node = tree->head;
  {
#line 1181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1181
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 1181
      goto while_break___0;
    }
#line 1182
    if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 1183
      best = node;
    } else
#line 1182
    if (best->bound < node->bound) {
#line 1183
      best = node;
    }
#line 1181
    node = node->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1184
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1186
  if ((unsigned long )tree != (unsigned long )tree) {
#line 1186
    tmp = 1;
  } else {
    {
#line 1186
    _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1186);
#line 1186
    tmp = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1188
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 1188
    tmp___0 = 0;
  } else {
#line 1188
    tmp___0 = best->p;
  }
#line 1188
  return (tmp___0);
}
}
#line 1216 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
double _glp_ios_relative_gap(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  int p ;
  double best_mip ;
  double best_bnd ;
  double gap ;
  double tmp ;
  double tmp___0 ;

  {
#line 1217
  mip = tree->mip;
#line 1220
  if (mip->mip_stat == 2) {
    {
#line 1221
    best_mip = mip->mip_obj;
#line 1222
    p = _glp_ios_best_node(tree);
    }
#line 1223
    if (p == 0) {
#line 1225
      gap = 0.0;
    } else {
      {
#line 1228
      best_bnd = ((tree->slot + p)->node)->bound;
#line 1229
      tmp = fabs(best_mip - best_bnd);
#line 1229
      tmp___0 = fabs(best_mip);
#line 1229
      gap = tmp / (tmp___0 + 2.2204460492503131e-16);
      }
    }
  } else {
#line 1235
    gap = 1.7976931348623157e+308;
  }
#line 1237
  return (gap);
}
}
#line 1259 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
int _glp_ios_solve_node(glp_tree___0 *tree ) 
{ 
  glp_prob *mip ;
  glp_smcp parm ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1260
  mip = tree->mip;
#line 1264
  if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 1264
    tmp = 1;
  } else {
    {
#line 1264
    _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1264);
#line 1264
    tmp = 1;
    }
  }
  {
#line 1266
  glp_init_smcp(& parm);
  }
  {
#line 1268
  if ((tree->parm)->msg_lev == 0) {
#line 1268
    goto case_0;
  }
#line 1270
  if ((tree->parm)->msg_lev == 1) {
#line 1270
    goto case_1;
  }
#line 1273
  if ((tree->parm)->msg_lev == 3) {
#line 1273
    goto case_3;
  }
#line 1273
  if ((tree->parm)->msg_lev == 2) {
#line 1273
    goto case_3;
  }
#line 1275
  if ((tree->parm)->msg_lev == 4) {
#line 1275
    goto case_4;
  }
#line 1277
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1269
  parm.msg_lev = 0;
#line 1269
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1271
  parm.msg_lev = 1;
#line 1271
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1274
  parm.msg_lev = 2;
#line 1274
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1276
  parm.msg_lev = 3;
#line 1276
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1278
  if ((unsigned long )tree != (unsigned long )tree) {
#line 1278
    tmp___0 = 1;
  } else {
    {
#line 1278
    _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1278);
#line 1278
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1280
  parm.meth = 2;
#line 1281
  if ((tree->parm)->msg_lev < 4) {
#line 1282
    parm.out_dly = (int )(tree->parm)->out_dly;
  } else {
#line 1284
    parm.out_dly = 0;
  }
#line 1287
  if (mip->mip_stat == 2) {
    {
#line 1289
    if ((tree->mip)->dir == 1) {
#line 1289
      goto case_1___0;
    }
#line 1292
    if ((tree->mip)->dir == 2) {
#line 1292
      goto case_2___0;
    }
#line 1295
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 1290
    parm.obj_ul = mip->mip_obj;
#line 1291
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1293
    parm.obj_ll = mip->mip_obj;
#line 1294
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1296
    if ((unsigned long )mip != (unsigned long )mip) {
#line 1296
      tmp___1 = 1;
    } else {
      {
#line 1296
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1296);
#line 1296
      tmp___1 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1300
  ret = glp_simplex(mip, (glp_smcp const   *)(& parm));
  }
#line 1307
  return (ret);
}
}
#line 1312 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
IOSPOOL *_glp_ios_create_pool(glp_tree___0 *tree ) 
{ 
  IOSPOOL *pool ;
  int tmp ;
  void *tmp___0 ;
  IOSCUT *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1318
  if ((unsigned long )tree == (unsigned long )tree) {
#line 1318
    tmp = 1;
  } else {
    {
#line 1318
    _glp_lib_xassert("tree == tree", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1318);
#line 1318
    tmp = 1;
    }
  }
  {
#line 1319
  tmp___0 = _glp_lib_xmalloc((int )sizeof(IOSPOOL ));
#line 1319
  pool = (IOSPOOL *)tmp___0;
#line 1321
  pool->size = 0;
#line 1322
  tmp___1 = (IOSCUT *)((void *)0);
#line 1322
  pool->tail = tmp___1;
#line 1322
  pool->head = tmp___1;
#line 1323
  pool->ord = 0;
#line 1323
  pool->curr = (IOSCUT *)((void *)0);
  }
#line 1324
  return (pool);
}
}
#line 1327 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
int _glp_ios_add_row(glp_tree___0 *tree , IOSPOOL *pool , char const   *name , int klass ,
                     int flags , int len , int const   *ind , double const   *val ,
                     int type , double rhs ) 
{ 
  IOSCUT *cut ;
  IOSAIJ *aij ;
  int k ;
  int tmp ;
  void *tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  xerror_t tmp___6 ;
  xerror_t tmp___7 ;
  xerror_t tmp___8 ;
  void *tmp___9 ;
  xerror_t tmp___10 ;
  xerror_t tmp___11 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 1334
  if ((unsigned long )pool != (unsigned long )((void *)0)) {
#line 1334
    tmp = 1;
  } else {
    {
#line 1334
    _glp_lib_xassert("pool != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1334);
#line 1334
    tmp = 1;
    }
  }
  {
#line 1335
  tmp___0 = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSCUT ));
#line 1335
  cut = (IOSCUT *)tmp___0;
  }
#line 1336
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1337
    cut->name = (char *)((void *)0);
  } else
#line 1336
  if ((int const   )*(name + 0) == 0) {
#line 1337
    cut->name = (char *)((void *)0);
  } else {
#line 1339
    k = 0;
    {
#line 1339
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1339
      if (! ((int const   )*(name + k) != 0)) {
#line 1339
        goto while_break;
      }
#line 1340
      if (k == 256) {
        {
#line 1341
        tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                   1341);
#line 1341
        (*tmp___1)("glp_ios_add_row: cut name too long\n");
        }
      }
      {
#line 1342
      tmp___3 = __ctype_b_loc();
      }
#line 1342
      if ((int const   )*(*tmp___3 + (int )((unsigned char )*(name + k))) & 2) {
        {
#line 1343
        tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                   1343);
#line 1343
        (*tmp___2)("glp_ios_add_row: cut name contains invalid character(s)\n");
        }
      }
#line 1339
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1346
    tmp___4 = strlen(name);
#line 1346
    tmp___5 = _glp_dmp_get_atom(tree->pool, (int )(tmp___4 + 1U));
#line 1346
    cut->name = (char *)tmp___5;
#line 1347
    strcpy((char */* __restrict  */)cut->name, (char const   */* __restrict  */)name);
    }
  }
#line 1349
  if (0 <= klass) {
#line 1349
    if (! (klass <= 255)) {
      {
#line 1350
      tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                 1350);
#line 1350
      (*tmp___6)("glp_ios_add_row: klass = %d; invalid cut class\n", klass);
      }
    }
  } else {
    {
#line 1350
    tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                               1350);
#line 1350
    (*tmp___6)("glp_ios_add_row: klass = %d; invalid cut class\n", klass);
    }
  }
#line 1352
  cut->klass = (unsigned char )klass;
#line 1353
  if (flags != 0) {
    {
#line 1354
    tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                               1354);
#line 1354
    (*tmp___7)("glp_ios_add_row: flags = %d; invalid cut flags\n", flags);
    }
  }
#line 1356
  cut->ptr = (IOSAIJ *)((void *)0);
#line 1357
  if (0 <= len) {
#line 1357
    if (! (len <= tree->n)) {
      {
#line 1358
      tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                 1358);
#line 1358
      (*tmp___8)("glp_ios_add_row: len = %d; invalid cut length\n", len);
      }
    }
  } else {
    {
#line 1358
    tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                               1358);
#line 1358
    (*tmp___8)("glp_ios_add_row: len = %d; invalid cut length\n", len);
    }
  }
#line 1360
  k = 1;
  {
#line 1360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1360
    if (! (k <= len)) {
#line 1360
      goto while_break___0;
    }
    {
#line 1361
    tmp___9 = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSAIJ ));
#line 1361
    aij = (IOSAIJ *)tmp___9;
    }
#line 1362
    if (1 <= (int )*(ind + k)) {
#line 1362
      if (! (*(ind + k) <= (int const   )tree->n)) {
        {
#line 1363
        tmp___10 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                    1363);
#line 1363
        (*tmp___10)("glp_ios_add_row: ind[%d] = %d; column index out of range\n",
                    k, *(ind + k));
        }
      }
    } else {
      {
#line 1363
      tmp___10 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                  1363);
#line 1363
      (*tmp___10)("glp_ios_add_row: ind[%d] = %d; column index out of range\n", k,
                  *(ind + k));
      }
    }
#line 1365
    aij->j = (int )*(ind + k);
#line 1366
    aij->val = (double )*(val + k);
#line 1367
    aij->next = cut->ptr;
#line 1368
    cut->ptr = aij;
#line 1360
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1370
  if (! (type == 2)) {
#line 1370
    if (! (type == 3)) {
#line 1370
      if (! (type == 5)) {
        {
#line 1371
        tmp___11 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                    1371);
#line 1371
        (*tmp___11)("glp_ios_add_row: type = %d; invalid cut type\n", type);
        }
      }
    }
  }
#line 1373
  cut->type = type;
#line 1374
  cut->rhs = rhs;
#line 1375
  cut->prev = pool->tail;
#line 1376
  cut->next = (IOSCUT *)((void *)0);
#line 1377
  if ((unsigned long )cut->prev == (unsigned long )((void *)0)) {
#line 1378
    pool->head = cut;
  } else {
#line 1380
    (cut->prev)->next = cut;
  }
#line 1381
  pool->tail = cut;
#line 1382
  (pool->size) ++;
#line 1383
  return (pool->size);
}
}
#line 1386 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
IOSCUT *_glp_ios_find_row(IOSPOOL *pool , int i ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1389
  if ((unsigned long )pool != (unsigned long )((void *)0)) {
#line 1389
    tmp = 1;
  } else {
    {
#line 1389
    _glp_lib_xassert("pool != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1389);
#line 1389
    tmp = 1;
    }
  }
#line 1390
  if (1 <= i) {
#line 1390
    if (i <= pool->size) {
#line 1390
      tmp___0 = 1;
    } else {
      {
#line 1390
      _glp_lib_xassert("1 <= i && i <= pool->size", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1390);
#line 1390
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1390
    _glp_lib_xassert("1 <= i && i <= pool->size", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1390);
#line 1390
    tmp___0 = 1;
    }
  }
#line 1391
  if (pool->ord == 0) {
#line 1392
    if ((unsigned long )pool->curr == (unsigned long )((void *)0)) {
#line 1392
      tmp___1 = 1;
    } else {
      {
#line 1392
      _glp_lib_xassert("pool->curr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1392);
#line 1392
      tmp___1 = 1;
      }
    }
#line 1393
    pool->ord = 1;
#line 1394
    pool->curr = pool->head;
  }
#line 1396
  if ((unsigned long )pool->curr != (unsigned long )((void *)0)) {
#line 1396
    tmp___2 = 1;
  } else {
    {
#line 1396
    _glp_lib_xassert("pool->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1396);
#line 1396
    tmp___2 = 1;
    }
  }
#line 1397
  if (i < pool->ord) {
#line 1398
    if (i < pool->ord - i) {
#line 1399
      pool->ord = 1;
#line 1400
      pool->curr = pool->head;
      {
#line 1401
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1401
        if (! (pool->ord != i)) {
#line 1401
          goto while_break;
        }
#line 1402
        (pool->ord) ++;
#line 1403
        if ((unsigned long )pool->curr != (unsigned long )((void *)0)) {
#line 1403
          tmp___3 = 1;
        } else {
          {
#line 1403
          _glp_lib_xassert("pool->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                           1403);
#line 1403
          tmp___3 = 1;
          }
        }
#line 1404
        pool->curr = (pool->curr)->next;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1408
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1408
        if (! (pool->ord != i)) {
#line 1408
          goto while_break___0;
        }
#line 1409
        (pool->ord) --;
#line 1410
        if ((unsigned long )pool->curr != (unsigned long )((void *)0)) {
#line 1410
          tmp___4 = 1;
        } else {
          {
#line 1410
          _glp_lib_xassert("pool->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                           1410);
#line 1410
          tmp___4 = 1;
          }
        }
#line 1411
        pool->curr = (pool->curr)->prev;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 1415
  if (i > pool->ord) {
#line 1416
    if (i - pool->ord < pool->size - i) {
      {
#line 1417
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1417
        if (! (pool->ord != i)) {
#line 1417
          goto while_break___1;
        }
#line 1418
        (pool->ord) ++;
#line 1419
        if ((unsigned long )pool->curr != (unsigned long )((void *)0)) {
#line 1419
          tmp___5 = 1;
        } else {
          {
#line 1419
          _glp_lib_xassert("pool->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                           1419);
#line 1419
          tmp___5 = 1;
          }
        }
#line 1420
        pool->curr = (pool->curr)->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1424
      pool->ord = pool->size;
#line 1425
      pool->curr = pool->tail;
      {
#line 1426
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1426
        if (! (pool->ord != i)) {
#line 1426
          goto while_break___2;
        }
#line 1427
        (pool->ord) --;
#line 1428
        if ((unsigned long )pool->curr != (unsigned long )((void *)0)) {
#line 1428
          tmp___6 = 1;
        } else {
          {
#line 1428
          _glp_lib_xassert("pool->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                           1428);
#line 1428
          tmp___6 = 1;
          }
        }
#line 1429
        pool->curr = (pool->curr)->prev;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1433
  if (pool->ord == i) {
#line 1433
    tmp___7 = 1;
  } else {
    {
#line 1433
    _glp_lib_xassert("pool->ord == i", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1433);
#line 1433
    tmp___7 = 1;
    }
  }
#line 1434
  if ((unsigned long )pool->curr != (unsigned long )((void *)0)) {
#line 1434
    tmp___8 = 1;
  } else {
    {
#line 1434
    _glp_lib_xassert("pool->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1434);
#line 1434
    tmp___8 = 1;
    }
  }
#line 1435
  return (pool->curr);
}
}
#line 1438 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_del_row(glp_tree___0 *tree , IOSPOOL *pool , int i ) 
{ 
  IOSCUT *cut ;
  IOSAIJ *aij ;
  int tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1442
  if ((unsigned long )pool != (unsigned long )((void *)0)) {
#line 1442
    tmp = 1;
  } else {
    {
#line 1442
    _glp_lib_xassert("pool != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1442);
#line 1442
    tmp = 1;
    }
  }
#line 1443
  if (1 <= i) {
#line 1443
    if (! (i <= pool->size)) {
      {
#line 1444
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                                 1444);
#line 1444
      (*tmp___0)("glp_ios_del_row: i = %d; cut number out of range\n", i);
      }
    }
  } else {
    {
#line 1444
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                               1444);
#line 1444
    (*tmp___0)("glp_ios_del_row: i = %d; cut number out of range\n", i);
    }
  }
  {
#line 1446
  cut = _glp_ios_find_row(pool, i);
  }
#line 1447
  if ((unsigned long )pool->curr == (unsigned long )cut) {
#line 1447
    tmp___1 = 1;
  } else {
    {
#line 1447
    _glp_lib_xassert("pool->curr == cut", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1447);
#line 1447
    tmp___1 = 1;
    }
  }
#line 1448
  if ((unsigned long )cut->next != (unsigned long )((void *)0)) {
#line 1449
    pool->curr = cut->next;
  } else
#line 1450
  if ((unsigned long )cut->prev != (unsigned long )((void *)0)) {
#line 1451
    (pool->ord) --;
#line 1451
    pool->curr = cut->prev;
  } else {
#line 1453
    pool->ord = 0;
#line 1453
    pool->curr = (IOSCUT *)((void *)0);
  }
#line 1454
  if ((unsigned long )cut->name != (unsigned long )((void *)0)) {
    {
#line 1455
    tmp___2 = strlen((char const   *)cut->name);
#line 1455
    _glp_dmp_free_atom(tree->pool, (void *)cut->name, (int )(tmp___2 + 1U));
    }
  }
#line 1456
  if ((unsigned long )cut->prev == (unsigned long )((void *)0)) {
#line 1457
    if ((unsigned long )pool->head == (unsigned long )cut) {
#line 1457
      tmp___3 = 1;
    } else {
      {
#line 1457
      _glp_lib_xassert("pool->head == cut", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1457);
#line 1457
      tmp___3 = 1;
      }
    }
#line 1458
    pool->head = cut->next;
  } else {
#line 1461
    if ((unsigned long )(cut->prev)->next == (unsigned long )cut) {
#line 1461
      tmp___4 = 1;
    } else {
      {
#line 1461
      _glp_lib_xassert("cut->prev->next == cut", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1461);
#line 1461
      tmp___4 = 1;
      }
    }
#line 1462
    (cut->prev)->next = cut->next;
  }
#line 1464
  if ((unsigned long )cut->next == (unsigned long )((void *)0)) {
#line 1465
    if ((unsigned long )pool->tail == (unsigned long )cut) {
#line 1465
      tmp___5 = 1;
    } else {
      {
#line 1465
      _glp_lib_xassert("pool->tail == cut", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1465);
#line 1465
      tmp___5 = 1;
      }
    }
#line 1466
    pool->tail = cut->prev;
  } else {
#line 1469
    if ((unsigned long )(cut->next)->prev == (unsigned long )cut) {
#line 1469
      tmp___6 = 1;
    } else {
      {
#line 1469
      _glp_lib_xassert("cut->next->prev == cut", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1469);
#line 1469
      tmp___6 = 1;
      }
    }
#line 1470
    (cut->next)->prev = cut->prev;
  }
  {
#line 1472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1472
    if (! ((unsigned long )cut->ptr != (unsigned long )((void *)0))) {
#line 1472
      goto while_break;
    }
    {
#line 1473
    aij = cut->ptr;
#line 1474
    cut->ptr = aij->next;
#line 1475
    _glp_dmp_free_atom(tree->pool, (void *)aij, (int )sizeof(IOSAIJ ));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1477
  _glp_dmp_free_atom(tree->pool, (void *)cut, (int )sizeof(IOSCUT ));
#line 1478
  (pool->size) --;
  }
#line 1479
  return;
}
}
#line 1482 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_clear_pool(glp_tree___0 *tree , IOSPOOL *pool ) 
{ 
  int tmp ;
  IOSCUT *cut ;
  size_t tmp___0 ;
  IOSAIJ *aij ;
  IOSCUT *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1484
  if ((unsigned long )pool != (unsigned long )((void *)0)) {
#line 1484
    tmp = 1;
  } else {
    {
#line 1484
    _glp_lib_xassert("pool != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1484);
#line 1484
    tmp = 1;
    }
  }
  {
#line 1485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1485
    if (! ((unsigned long )pool->head != (unsigned long )((void *)0))) {
#line 1485
      goto while_break;
    }
#line 1486
    cut = pool->head;
#line 1487
    pool->head = cut->next;
#line 1488
    if ((unsigned long )cut->name != (unsigned long )((void *)0)) {
      {
#line 1489
      tmp___0 = strlen((char const   *)cut->name);
#line 1489
      _glp_dmp_free_atom(tree->pool, (void *)cut->name, (int )(tmp___0 + 1U));
      }
    }
    {
#line 1490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1490
      if (! ((unsigned long )cut->ptr != (unsigned long )((void *)0))) {
#line 1490
        goto while_break___0;
      }
      {
#line 1491
      aij = cut->ptr;
#line 1492
      cut->ptr = aij->next;
#line 1493
      _glp_dmp_free_atom(tree->pool, (void *)aij, (int )sizeof(IOSAIJ ));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1495
    _glp_dmp_free_atom(tree->pool, (void *)cut, (int )sizeof(IOSCUT ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1497
  pool->size = 0;
#line 1498
  tmp___1 = (IOSCUT *)((void *)0);
#line 1498
  pool->tail = tmp___1;
#line 1498
  pool->head = tmp___1;
#line 1499
  pool->ord = 0;
#line 1499
  pool->curr = (IOSCUT *)((void *)0);
#line 1500
  return;
}
}
#line 1503 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_delete_pool(glp_tree___0 *tree , IOSPOOL *pool ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1505
  if ((unsigned long )pool != (unsigned long )((void *)0)) {
#line 1505
    tmp = 1;
  } else {
    {
#line 1505
    _glp_lib_xassert("pool != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1505);
#line 1505
    tmp = 1;
    }
  }
  {
#line 1506
  _glp_ios_clear_pool(tree, pool);
#line 1507
  _glp_lib_xfree((void *)pool);
  }
#line 1508
  return;
}
}
#line 1513 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
static int refer_to_node(glp_tree___0 *tree , int j ) 
{ 
  glp_prob *mip ;
  int n ;
  int *ref ;
  int tmp ;
  SCG *g ;
  int n_max ;
  int *save ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1516
  mip = tree->mip;
#line 1517
  n = mip->n;
#line 1519
  if (j > 0) {
#line 1520
    ref = tree->n_ref;
  } else {
#line 1522
    ref = tree->c_ref;
#line 1522
    j = - j;
  }
#line 1523
  if (1 <= j) {
#line 1523
    if (j <= n) {
#line 1523
      tmp = 1;
    } else {
      {
#line 1523
      _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1523);
#line 1523
      tmp = 1;
      }
    }
  } else {
    {
#line 1523
    _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1523);
#line 1523
    tmp = 1;
    }
  }
#line 1524
  if (*(ref + j) == 0) {
    {
#line 1526
    g = tree->g;
#line 1527
    n_max = g->n_max;
#line 1528
    *(ref + j) = _glp_scg_add_nodes(g, 1);
    }
#line 1529
    if (g->n_max > n_max) {
      {
#line 1530
      save = tree->j_ref;
#line 1531
      tmp___0 = _glp_lib_xcalloc(1 + g->n_max, (int )sizeof(int ));
#line 1531
      tree->j_ref = (int *)tmp___0;
#line 1532
      memcpy((void */* __restrict  */)(tree->j_ref + 1), (void const   */* __restrict  */)(save + 1),
             (size_t )((unsigned long )g->n * sizeof(int )));
#line 1533
      _glp_lib_xfree((void *)save);
      }
    }
#line 1535
    if (*(ref + j) == g->n) {
#line 1535
      tmp___1 = 1;
    } else {
      {
#line 1535
      _glp_lib_xassert("ref[j] == g->n", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1535);
#line 1535
      tmp___1 = 1;
      }
    }
#line 1536
    *(tree->j_ref + *(ref + j)) = j;
#line 1537
    if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 1537
      tmp___2 = 1;
    } else {
      {
#line 1537
      _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1537);
#line 1537
      tmp___2 = 1;
      }
    }
#line 1538
    if ((tree->curr)->level > 0) {
#line 1538
      ((tree->curr)->own_nn) ++;
    }
  }
#line 1540
  return (*(ref + j));
}
}
#line 1543 "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c"
void _glp_ios_add_edge(glp_tree___0 *tree , int j1___0 , int j2 ) 
{ 
  glp_prob *mip ;
  int n ;
  SCGRIB *e ;
  int first ;
  int i1 ;
  int i2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  IOSRIB *rib ;
  void *tmp___3 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1545
  mip = tree->mip;
#line 1546
  n = mip->n;
#line 1549
  if (- n <= j1___0) {
#line 1549
    if (j1___0 <= n) {
#line 1549
      if (j1___0 != 0) {
#line 1549
        tmp = 1;
      } else {
        {
#line 1549
        _glp_lib_xassert("-n <= j1 && j1 <= +n && j1 != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         1549);
#line 1549
        tmp = 1;
        }
      }
    } else {
      {
#line 1549
      _glp_lib_xassert("-n <= j1 && j1 <= +n && j1 != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1549);
#line 1549
      tmp = 1;
      }
    }
  } else {
    {
#line 1549
    _glp_lib_xassert("-n <= j1 && j1 <= +n && j1 != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1549);
#line 1549
    tmp = 1;
    }
  }
#line 1550
  if (- n <= j2) {
#line 1550
    if (j2 <= n) {
#line 1550
      if (j2 != 0) {
#line 1550
        tmp___0 = 1;
      } else {
        {
#line 1550
        _glp_lib_xassert("-n <= j2 && j2 <= +n && j2 != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                         1550);
#line 1550
        tmp___0 = 1;
        }
      }
    } else {
      {
#line 1550
      _glp_lib_xassert("-n <= j2 && j2 <= +n && j2 != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                       1550);
#line 1550
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1550
    _glp_lib_xassert("-n <= j2 && j2 <= +n && j2 != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1550);
#line 1550
    tmp___0 = 1;
    }
  }
#line 1551
  if (j1___0 != j2) {
#line 1551
    tmp___1 = 1;
  } else {
    {
#line 1551
    _glp_lib_xassert("j1 != j2", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1551);
#line 1551
    tmp___1 = 1;
    }
  }
#line 1554
  if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 1554
    tmp___2 = 1;
  } else {
    {
#line 1554
    _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpios01.c",
                     1554);
#line 1554
    tmp___2 = 1;
    }
  }
  {
#line 1555
  first = ((tree->g)->n - (tree->curr)->own_nn) + 1;
#line 1557
  i1 = refer_to_node(tree, j1___0);
#line 1558
  i2 = refer_to_node(tree, j2);
#line 1560
  e = _glp_scg_add_edge(tree->g, i1, i2);
  }
#line 1563
  if ((tree->curr)->level > 0) {
#line 1563
    if (i1 < first) {
#line 1563
      if (i2 < first) {
        {
#line 1565
        tmp___3 = _glp_dmp_get_atom(tree->pool, (int )sizeof(IOSRIB ));
#line 1565
        rib = (IOSRIB *)tmp___3;
#line 1566
        rib->j1 = j1___0;
#line 1567
        rib->j2 = j2;
#line 1568
        rib->e = e;
#line 1569
        rib->next = (tree->curr)->e_ptr;
#line 1570
        (tree->curr)->e_ptr = rib;
        }
      }
    }
  }
#line 1572
  return;
}
}
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpini.h"
void _glp_cpx_basis(glp_prob *lp ) ;
#line 34 "/home/wslee/benchmarks/glpk-4.38/src/glpini02.c"
static int fcmp___2(void const   *ptr1 , void const   *ptr2 ) 
{ 
  struct var *col1 ;
  struct var *col2 ;

  {
#line 36
  col1 = (struct var *)((void *)ptr1);
#line 36
  col2 = (struct var *)((void *)ptr2);
#line 37
  if (col1->f < col2->f) {
#line 37
    return (-1);
  }
#line 38
  if (col1->f > col2->f) {
#line 38
    return (1);
  }
#line 39
  return (0);
}
}
#line 42 "/home/wslee/benchmarks/glpk-4.38/src/glpini02.c"
static int get_column(glp_prob *lp , int j , int *ind , double *val ) 
{ 
  int k ;
  int len ;
  double big ;
  double tmp ;

  {
  {
#line 48
  len = glp_get_mat_col(lp, j, ind, val);
#line 49
  big = 0.0;
#line 50
  k = 1;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (k <= len)) {
#line 50
      goto while_break;
    }
    {
#line 51
    tmp = fabs(*(val + k));
    }
#line 51
    if (big < tmp) {
      {
#line 51
      big = fabs(*(val + k));
      }
    }
#line 50
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (big == 0.0) {
#line 52
    big = 1.0;
  }
#line 53
  k = 1;
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! (k <= len)) {
#line 53
      goto while_break___0;
    }
#line 53
    *(val + k) /= big;
#line 53
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 54
  return (len);
}
}
#line 57 "/home/wslee/benchmarks/glpk-4.38/src/glpini02.c"
void _glp_cpx_basis(glp_prob *lp ) 
{ 
  struct var *C ;
  struct var *C2 ;
  struct var *C3 ;
  struct var *C4 ;
  int m ;
  int n ;
  int i ;
  int j ;
  int jk ;
  int k ;
  int l ;
  int ll ;
  int t ;
  int n2 ;
  int n3 ;
  int n4 ;
  int type ;
  int len ;
  int *I ;
  int *r ;
  int *ind ;
  double alpha ;
  double gamma___0 ;
  double cmax ;
  double temp ;
  double *v ;
  double *val ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  double tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
#line 63
  _glp_lib_xprintf("Crashing...\n");
#line 65
  m = glp_get_num_rows(lp);
#line 66
  n = glp_get_num_cols(lp);
#line 68
  tmp = _glp_lib_xcalloc(1 + n, (int )sizeof(struct var ));
#line 68
  C = (struct var *)tmp;
#line 69
  tmp___0 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 69
  I = (int *)tmp___0;
#line 70
  tmp___1 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 70
  r = (int *)tmp___1;
#line 71
  tmp___2 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 71
  v = (double *)tmp___2;
#line 72
  tmp___3 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 72
  ind = (int *)tmp___3;
#line 73
  tmp___4 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 73
  val = (double *)tmp___4;
#line 75
  i = 1;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i <= m)) {
#line 75
      goto while_break;
    }
    {
#line 76
    tmp___9 = glp_get_row_type(lp, i);
    }
#line 76
    if (tmp___9 != 4) {
      {
#line 77
      glp_set_row_stat(lp, i, 5);
      }
    } else {
      {
#line 78
      tmp___5 = glp_get_row_lb(lp, i);
#line 78
      tmp___6 = fabs(tmp___5);
#line 78
      tmp___7 = glp_get_row_ub(lp, i);
#line 78
      tmp___8 = fabs(tmp___7);
      }
#line 78
      if (tmp___6 <= tmp___8) {
        {
#line 80
        glp_set_row_stat(lp, i, 2);
        }
      } else {
        {
#line 82
        glp_set_row_stat(lp, i, 3);
        }
      }
    }
#line 75
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  j = 1;
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! (j <= n)) {
#line 85
      goto while_break___0;
    }
    {
#line 86
    tmp___14 = glp_get_col_type(lp, j);
    }
#line 86
    if (tmp___14 != 4) {
      {
#line 87
      glp_set_col_stat(lp, j, 5);
      }
    } else {
      {
#line 88
      tmp___10 = glp_get_col_lb(lp, j);
#line 88
      tmp___11 = fabs(tmp___10);
#line 88
      tmp___12 = glp_get_col_ub(lp, j);
#line 88
      tmp___13 = fabs(tmp___12);
      }
#line 88
      if (tmp___11 <= tmp___13) {
        {
#line 90
        glp_set_col_stat(lp, j, 2);
        }
      } else {
        {
#line 92
        glp_set_col_stat(lp, j, 3);
        }
      }
    }
#line 85
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  n2 = 0;
#line 95
  C2 = C + 0;
#line 96
  j = 1;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! (j <= n)) {
#line 96
      goto while_break___1;
    }
    {
#line 97
    type = glp_get_col_type(lp, j);
    }
#line 98
    if (type == 1) {
#line 99
      n2 ++;
#line 100
      (C2 + n2)->j = j;
#line 101
      (C2 + n2)->f = 0.0;
    }
#line 96
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 106
  n3 = 0;
#line 106
  C3 = C2 + n2;
#line 107
  j = 1;
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 107
    if (! (j <= n)) {
#line 107
      goto while_break___2;
    }
    {
#line 108
    type = glp_get_col_type(lp, j);
    }
#line 109
    if (type == 2) {
      {
#line 110
      n3 ++;
#line 111
      (C3 + n3)->j = j;
#line 112
      (C3 + n3)->f = glp_get_col_lb(lp, j);
      }
    } else
#line 114
    if (type == 3) {
      {
#line 115
      n3 ++;
#line 116
      (C3 + n3)->j = j;
#line 117
      tmp___15 = glp_get_col_ub(lp, j);
#line 117
      (C3 + n3)->f = - tmp___15;
      }
    }
#line 107
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 122
  n4 = 0;
#line 122
  C4 = C3 + n3;
#line 123
  j = 1;
  {
#line 123
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 123
    if (! (j <= n)) {
#line 123
      goto while_break___3;
    }
    {
#line 124
    type = glp_get_col_type(lp, j);
    }
#line 125
    if (type == 4) {
      {
#line 126
      n4 ++;
#line 127
      (C4 + n4)->j = j;
#line 128
      tmp___16 = glp_get_col_lb(lp, j);
#line 128
      tmp___17 = glp_get_col_ub(lp, j);
#line 128
      (C4 + n4)->f = tmp___16 - tmp___17;
      }
    }
#line 123
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 132
  gamma___0 = 0.0;
#line 133
  j = 1;
  {
#line 133
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 133
    if (! (j <= n)) {
#line 133
      goto while_break___4;
    }
    {
#line 134
    tmp___18 = glp_get_obj_coef(lp, j);
#line 134
    temp = fabs(tmp___18);
    }
#line 135
    if (gamma___0 < temp) {
#line 135
      gamma___0 = temp;
    }
#line 133
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 138
  if (gamma___0 == 0.0) {
#line 138
    cmax = 1.0;
  } else {
#line 138
    cmax = 1000.0 * gamma___0;
  }
  {
#line 141
  tmp___19 = glp_get_obj_dir(lp);
  }
  {
#line 142
  if (tmp___19 == 1) {
#line 142
    goto case_1;
  }
#line 143
  if (tmp___19 == 2) {
#line 143
    goto case_2;
  }
#line 144
  goto switch_default;
  case_1: /* CIL Label */ 
#line 142
  temp = 1.0;
#line 142
  goto switch_break;
  case_2: /* CIL Label */ 
#line 143
  temp = - 1.0;
#line 143
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 144
  if ((unsigned long )lp != (unsigned long )lp) {
#line 144
    tmp___20 = 1;
  } else {
    {
#line 144
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpini02.c",
                     144);
#line 144
    tmp___20 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 146
  k = 1;
  {
#line 146
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 146
    if (! (k <= (n2 + n3) + n4)) {
#line 146
      goto while_break___5;
    }
    {
#line 147
    j = (C + k)->j;
#line 148
    tmp___21 = glp_get_obj_coef(lp, j);
#line 148
    (C + k)->f += (temp * tmp___21) / cmax;
#line 146
    k ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 152
  qsort((void *)(C2 + 1), (size_t )n2, (size_t )sizeof(struct var ), & fcmp___2);
#line 153
  k = 1;
  }
  {
#line 153
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 153
    if (! (k < n2)) {
#line 153
      goto while_break___6;
    }
#line 153
    if ((C2 + k)->f <= (C2 + (k + 1))->f) {
#line 153
      tmp___22 = 1;
    } else {
      {
#line 153
      _glp_lib_xassert("C2[k].q <= C2[k+1].q", "/home/wslee/benchmarks/glpk-4.38/src/glpini02.c",
                       153);
#line 153
      tmp___22 = 1;
      }
    }
#line 153
    k ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 154
  qsort((void *)(C3 + 1), (size_t )n3, (size_t )sizeof(struct var ), & fcmp___2);
#line 155
  k = 1;
  }
  {
#line 155
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 155
    if (! (k < n3)) {
#line 155
      goto while_break___7;
    }
#line 155
    if ((C3 + k)->f <= (C3 + (k + 1))->f) {
#line 155
      tmp___23 = 1;
    } else {
      {
#line 155
      _glp_lib_xassert("C3[k].q <= C3[k+1].q", "/home/wslee/benchmarks/glpk-4.38/src/glpini02.c",
                       155);
#line 155
      tmp___23 = 1;
      }
    }
#line 155
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 156
  qsort((void *)(C4 + 1), (size_t )n4, (size_t )sizeof(struct var ), & fcmp___2);
#line 157
  k = 1;
  }
  {
#line 157
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 157
    if (! (k < n4)) {
#line 157
      goto while_break___8;
    }
#line 157
    if ((C4 + k)->f <= (C4 + (k + 1))->f) {
#line 157
      tmp___24 = 1;
    } else {
      {
#line 157
      _glp_lib_xassert("C4[k].q <= C4[k+1].q", "/home/wslee/benchmarks/glpk-4.38/src/glpini02.c",
                       157);
#line 157
      tmp___24 = 1;
      }
    }
#line 157
    k ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 159
  i = 1;
  {
#line 159
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 159
    if (! (i <= m)) {
#line 159
      goto while_break___9;
    }
    {
#line 160
    type = glp_get_row_type(lp, i);
    }
#line 161
    if (type != 5) {
      {
#line 163
      glp_set_row_stat(lp, i, 1);
#line 164
      *(I + i) = 1;
#line 165
      *(r + i) = 1;
      }
    } else {
#line 169
      *(I + i) = 0;
#line 170
      *(r + i) = 0;
    }
#line 172
    *(v + i) = 1.7976931348623157e+308;
#line 159
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 175
  k = 1;
  {
#line 175
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 175
    if (! (k <= (n2 + n3) + n4)) {
#line 175
      goto while_break___10;
    }
    {
#line 176
    jk = (C + k)->j;
#line 177
    len = get_column(lp, jk, ind, val);
#line 180
    alpha = 0.0;
#line 180
    ll = 0;
#line 181
    t = 1;
    }
    {
#line 181
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 181
      if (! (t <= len)) {
#line 181
        goto while_break___11;
      }
#line 182
      l = *(ind + t);
#line 183
      if (*(r + l) == 0) {
        {
#line 183
        tmp___25 = fabs(*(val + t));
        }
#line 183
        if (alpha < tmp___25) {
          {
#line 184
          alpha = fabs(*(val + t));
#line 184
          ll = l;
          }
        }
      }
#line 181
      t ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 186
    if (alpha >= 0.99) {
      {
#line 188
      glp_set_col_stat(lp, jk, 1);
#line 189
      *(I + ll) = 1;
#line 190
      *(v + ll) = alpha;
#line 192
      t = 1;
      }
      {
#line 192
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 192
        if (! (t <= len)) {
#line 192
          goto while_break___12;
        }
#line 193
        l = *(ind + t);
#line 194
        if (*(val + t) != 0.0) {
#line 194
          (*(r + l)) ++;
        }
#line 192
        t ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 197
      goto __Cont;
    }
#line 201
    t = 1;
    {
#line 201
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 201
      if (! (t <= len)) {
#line 201
        goto while_break___13;
      }
      {
#line 202
      l = *(ind + t);
#line 203
      tmp___26 = fabs(*(val + t));
      }
#line 203
      if (tmp___26 > 0.01 * *(v + l)) {
#line 203
        goto while_break___13;
      }
#line 201
      t ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 205
    if (t <= len) {
#line 205
      goto __Cont;
    }
#line 208
    alpha = 0.0;
#line 208
    ll = 0;
#line 209
    t = 1;
    {
#line 209
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 209
      if (! (t <= len)) {
#line 209
        goto while_break___14;
      }
#line 210
      l = *(ind + t);
#line 211
      if (*(I + l) == 0) {
        {
#line 211
        tmp___27 = fabs(*(val + t));
        }
#line 211
        if (alpha < tmp___27) {
          {
#line 212
          alpha = fabs(*(val + t));
#line 212
          ll = l;
          }
        }
      }
#line 209
      t ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 215
    if (alpha == 0.0) {
#line 215
      goto __Cont;
    }
    {
#line 217
    glp_set_col_stat(lp, jk, 1);
#line 218
    *(I + ll) = 1;
#line 219
    *(v + ll) = alpha;
#line 221
    t = 1;
    }
    {
#line 221
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 221
      if (! (t <= len)) {
#line 221
        goto while_break___15;
      }
#line 222
      l = *(ind + t);
#line 223
      if (*(val + t) != 0.0) {
#line 223
        (*(r + l)) ++;
      }
#line 221
      t ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 175
    k ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 229
  i = 1;
  {
#line 229
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 229
    if (! (i <= m)) {
#line 229
      goto while_break___16;
    }
#line 230
    if (*(I + i) == 0) {
      {
#line 230
      glp_set_row_stat(lp, i, 1);
      }
    }
#line 229
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 232
  _glp_lib_xfree((void *)C);
#line 233
  _glp_lib_xfree((void *)I);
#line 234
  _glp_lib_xfree((void *)r);
#line 235
  _glp_lib_xfree((void *)v);
#line 236
  _glp_lib_xfree((void *)ind);
#line 237
  _glp_lib_xfree((void *)val);
  }
#line 238
  return;
}
}
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpini.h"
void _glp_adv_basis(glp_prob *lp ) ;
#line 126 "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c"
static int triang(int m , int n , void *info , int (*mat___0)(void *info , int k ,
                                                              int *ndx ) , int *rn ,
                  int *cn ) 
{ 
  int *ndx ;
  int *rs_len ;
  int *rs_head ;
  int *rs_prev ;
  int *rs_next ;
  int cs_head ;
  int *cs_prev ;
  int *cs_next ;
  int i ;
  int j ;
  int ii ;
  int jj ;
  int k1 ;
  int k2 ;
  int len ;
  int t ;
  int size ;
  int *head ;
  int *rn_inv ;
  int *cn_inv ;
  xerror_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int diag ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;

  {
#line 163
  size = 0;
#line 165
  if (m > 0) {
#line 165
    if (! (n > 0)) {
      {
#line 166
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpini01.c", 166);
#line 166
      (*tmp)("triang: m = %d; n = %d; invalid dimension\n", m, n);
      }
    }
  } else {
    {
#line 166
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpini01.c", 166);
#line 166
    (*tmp)("triang: m = %d; n = %d; invalid dimension\n", m, n);
    }
  }
#line 168
  if (m >= n) {
#line 168
    tmp___0 = m;
  } else {
#line 168
    tmp___0 = n;
  }
  {
#line 168
  tmp___1 = _glp_lib_xcalloc(1 + tmp___0, (int )sizeof(int ));
#line 168
  ndx = (int *)tmp___1;
#line 169
  tmp___2 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 169
  rs_len = (int *)tmp___2;
#line 170
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 170
  rs_head = (int *)tmp___3;
#line 171
  tmp___4 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 171
  rs_prev = (int *)tmp___4;
#line 172
  tmp___5 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 172
  rs_next = (int *)tmp___5;
#line 173
  tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 173
  cs_prev = (int *)tmp___6;
#line 174
  tmp___7 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 174
  cs_next = (int *)tmp___7;
#line 177
  head = rs_len;
#line 178
  len = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (len <= m)) {
#line 178
      goto while_break;
    }
#line 178
    *(head + len) = 0;
#line 178
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  j = 1;
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 179
    if (! (j <= n)) {
#line 179
      goto while_break___0;
    }
    {
#line 181
    len = (*mat___0)(info, - j, ndx);
    }
#line 182
    if (0 <= len) {
#line 182
      if (len <= m) {
#line 182
        tmp___8 = 1;
      } else {
        {
#line 182
        _glp_lib_xassert("0 <= len && len <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         182);
#line 182
        tmp___8 = 1;
        }
      }
    } else {
      {
#line 182
      _glp_lib_xassert("0 <= len && len <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       182);
#line 182
      tmp___8 = 1;
      }
    }
#line 184
    *(cs_prev + j) = *(head + len);
#line 185
    *(head + len) = j;
#line 179
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 189
  cs_head = 0;
#line 190
  len = 0;
  {
#line 190
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 190
    if (! (len <= m)) {
#line 190
      goto while_break___1;
    }
#line 191
    j = *(head + len);
    {
#line 191
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 191
      if (! (j != 0)) {
#line 191
        goto while_break___2;
      }
#line 192
      *(cs_next + j) = cs_head;
#line 193
      cs_head = j;
#line 191
      j = *(cs_prev + j);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 190
    len ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 196
  jj = 0;
#line 197
  j = cs_head;
  {
#line 197
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 197
    if (! (j != 0)) {
#line 197
      goto while_break___3;
    }
#line 198
    *(cs_prev + j) = jj;
#line 199
    jj = j;
#line 197
    j = *(cs_next + j);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 203
  len = 0;
  {
#line 203
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 203
    if (! (len <= n)) {
#line 203
      goto while_break___4;
    }
#line 203
    *(rs_head + len) = 0;
#line 203
    len ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 204
  i = 1;
  {
#line 204
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 204
    if (! (i <= m)) {
#line 204
      goto while_break___5;
    }
    {
#line 206
    len = (*mat___0)(info, i, ndx);
#line 206
    *(rs_len + i) = len;
    }
#line 207
    if (0 <= len) {
#line 207
      if (len <= n) {
#line 207
        tmp___9 = 1;
      } else {
        {
#line 207
        _glp_lib_xassert("0 <= len && len <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         207);
#line 207
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 207
      _glp_lib_xassert("0 <= len && len <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       207);
#line 207
      tmp___9 = 1;
      }
    }
#line 209
    *(rs_prev + i) = 0;
#line 210
    *(rs_next + i) = *(rs_head + len);
#line 211
    if (*(rs_next + i) != 0) {
#line 211
      *(rs_prev + *(rs_next + i)) = i;
    }
#line 212
    *(rs_head + len) = i;
#line 204
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 215
  i = 1;
  {
#line 215
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 215
    if (! (i <= m)) {
#line 215
      goto while_break___6;
    }
#line 215
    *(rn + i) = 0;
#line 215
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 216
  j = 1;
  {
#line 216
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 216
    if (! (j <= n)) {
#line 216
      goto while_break___7;
    }
#line 216
    *(cn + j) = 0;
#line 216
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 218
  k1 = 1;
#line 218
  k2 = n;
  {
#line 220
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 220
    if (! (k1 <= k2)) {
#line 220
      goto while_break___8;
    }
#line 221
    i = *(rs_head + 1);
#line 222
    if (i != 0) {
#line 225
      if (*(rs_len + i) == 1) {
#line 225
        tmp___10 = 1;
      } else {
        {
#line 225
        _glp_lib_xassert("rs_len[i] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         225);
#line 225
        tmp___10 = 1;
        }
      }
      {
#line 228
      j = 0;
#line 229
      t = (*mat___0)(info, i, ndx);
      }
#line 230
      if (0 <= t) {
#line 230
        if (t <= n) {
#line 230
          tmp___11 = 1;
        } else {
          {
#line 230
          _glp_lib_xassert("0 <= t && t <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                           230);
#line 230
          tmp___11 = 1;
          }
        }
      } else {
        {
#line 230
        _glp_lib_xassert("0 <= t && t <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         230);
#line 230
        tmp___11 = 1;
        }
      }
#line 231
      t = t;
      {
#line 231
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 231
        if (! (t >= 1)) {
#line 231
          goto while_break___9;
        }
#line 232
        jj = *(ndx + t);
#line 233
        if (1 <= jj) {
#line 233
          if (jj <= n) {
#line 233
            tmp___12 = 1;
          } else {
            {
#line 233
            _glp_lib_xassert("1 <= jj && jj <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                             233);
#line 233
            tmp___12 = 1;
            }
          }
        } else {
          {
#line 233
          _glp_lib_xassert("1 <= jj && jj <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                           233);
#line 233
          tmp___12 = 1;
          }
        }
#line 234
        if (*(cn + jj) == 0) {
#line 235
          if (j == 0) {
#line 235
            tmp___13 = 1;
          } else {
            {
#line 235
            _glp_lib_xassert("j == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                             235);
#line 235
            tmp___13 = 1;
            }
          }
#line 236
          j = jj;
        }
#line 231
        t --;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 239
      if (j != 0) {
#line 239
        tmp___14 = 1;
      } else {
        {
#line 239
        _glp_lib_xassert("j != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         239);
#line 239
        tmp___14 = 1;
        }
      }
#line 242
      tmp___15 = k1;
#line 242
      *(cn + j) = tmp___15;
#line 242
      *(rn + i) = tmp___15;
#line 244
      k1 ++;
#line 246
      size ++;
    } else {
#line 252
      j = cs_head;
#line 253
      if (j != 0) {
#line 253
        tmp___16 = 1;
      } else {
        {
#line 253
        _glp_lib_xassert("j != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         253);
#line 253
        tmp___16 = 1;
        }
      }
#line 254
      *(cn + j) = k2;
#line 256
      k2 --;
    }
#line 261
    if (*(cs_prev + j) == 0) {
#line 262
      cs_head = *(cs_next + j);
    } else {
#line 264
      *(cs_next + *(cs_prev + j)) = *(cs_next + j);
    }
#line 265
    if (! (*(cs_next + j) == 0)) {
#line 268
      *(cs_prev + *(cs_next + j)) = *(cs_prev + j);
    }
    {
#line 271
    t = (*mat___0)(info, - j, ndx);
    }
#line 272
    if (0 <= t) {
#line 272
      if (t <= m) {
#line 272
        tmp___17 = 1;
      } else {
        {
#line 272
        _glp_lib_xassert("0 <= t && t <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         272);
#line 272
        tmp___17 = 1;
        }
      }
    } else {
      {
#line 272
      _glp_lib_xassert("0 <= t && t <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       272);
#line 272
      tmp___17 = 1;
      }
    }
#line 273
    t = t;
    {
#line 273
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 273
      if (! (t >= 1)) {
#line 273
        goto while_break___10;
      }
#line 274
      i = *(ndx + t);
#line 275
      if (1 <= i) {
#line 275
        if (i <= m) {
#line 275
          tmp___18 = 1;
        } else {
          {
#line 275
          _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                           275);
#line 275
          tmp___18 = 1;
          }
        }
      } else {
        {
#line 275
        _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         275);
#line 275
        tmp___18 = 1;
        }
      }
#line 277
      len = *(rs_len + i);
#line 278
      if (len >= 1) {
#line 278
        tmp___19 = 1;
      } else {
        {
#line 278
        _glp_lib_xassert("len >= 1", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         278);
#line 278
        tmp___19 = 1;
        }
      }
#line 281
      if (*(rs_prev + i) == 0) {
#line 282
        *(rs_head + len) = *(rs_next + i);
      } else {
#line 284
        *(rs_next + *(rs_prev + i)) = *(rs_next + i);
      }
#line 285
      if (! (*(rs_next + i) == 0)) {
#line 288
        *(rs_prev + *(rs_next + i)) = *(rs_prev + i);
      }
#line 290
      len --;
#line 290
      *(rs_len + i) = len;
#line 292
      *(rs_prev + i) = 0;
#line 293
      *(rs_next + i) = *(rs_head + len);
#line 294
      if (*(rs_next + i) != 0) {
#line 294
        *(rs_prev + *(rs_next + i)) = i;
      }
#line 295
      *(rs_head + len) = i;
#line 273
      t --;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 300
  i = 1;
  {
#line 300
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 300
    if (! (i <= m)) {
#line 300
      goto while_break___11;
    }
#line 300
    if (*(rn + i) == 0) {
#line 300
      tmp___20 = k1;
#line 300
      k1 ++;
#line 300
      *(rn + i) = tmp___20;
    }
#line 300
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 303
  j = 1;
  {
#line 303
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 303
    if (! (j <= n)) {
#line 303
      goto while_break___12;
    }
#line 303
    if (*(cn + j) != 0) {
#line 303
      tmp___21 = 1;
    } else {
      {
#line 303
      _glp_lib_xassert("cn[j] != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       303);
#line 303
      tmp___21 = 1;
      }
    }
#line 303
    j ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 307
  rn_inv = rs_len;
#line 308
  ii = 1;
  {
#line 308
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 308
    if (! (ii <= m)) {
#line 308
      goto while_break___13;
    }
#line 308
    *(rn_inv + ii) = 0;
#line 308
    ii ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 309
  i = 1;
  {
#line 309
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 309
    if (! (i <= m)) {
#line 309
      goto while_break___14;
    }
#line 310
    ii = *(rn + i);
#line 311
    if (1 <= ii) {
#line 311
      if (ii <= m) {
#line 311
        tmp___22 = 1;
      } else {
        {
#line 311
        _glp_lib_xassert("1 <= ii && ii <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         311);
#line 311
        tmp___22 = 1;
        }
      }
    } else {
      {
#line 311
      _glp_lib_xassert("1 <= ii && ii <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       311);
#line 311
      tmp___22 = 1;
      }
    }
#line 312
    if (*(rn_inv + ii) == 0) {
#line 312
      tmp___23 = 1;
    } else {
      {
#line 312
      _glp_lib_xassert("rn_inv[ii] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       312);
#line 312
      tmp___23 = 1;
      }
    }
#line 313
    *(rn_inv + ii) = i;
#line 309
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 315
  cn_inv = rs_head;
#line 316
  jj = 1;
  {
#line 316
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 316
    if (! (jj <= n)) {
#line 316
      goto while_break___15;
    }
#line 316
    *(cn_inv + jj) = 0;
#line 316
    jj ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 317
  j = 1;
  {
#line 317
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 317
    if (! (j <= n)) {
#line 317
      goto while_break___16;
    }
#line 318
    jj = *(cn + j);
#line 319
    if (1 <= jj) {
#line 319
      if (jj <= n) {
#line 319
        tmp___24 = 1;
      } else {
        {
#line 319
        _glp_lib_xassert("1 <= jj && jj <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         319);
#line 319
        tmp___24 = 1;
        }
      }
    } else {
      {
#line 319
      _glp_lib_xassert("1 <= jj && jj <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       319);
#line 319
      tmp___24 = 1;
      }
    }
#line 320
    if (*(cn_inv + jj) == 0) {
#line 320
      tmp___25 = 1;
    } else {
      {
#line 320
      _glp_lib_xassert("cn_inv[jj] == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       320);
#line 320
      tmp___25 = 1;
      }
    }
#line 321
    *(cn_inv + jj) = j;
#line 317
    j ++;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 325
  ii = 1;
  {
#line 325
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 325
    if (! (ii <= size)) {
#line 325
      goto while_break___17;
    }
    {
#line 326
    diag = 0;
#line 327
    i = *(rn_inv + ii);
#line 328
    t = (*mat___0)(info, i, ndx);
    }
#line 329
    if (0 <= t) {
#line 329
      if (t <= n) {
#line 329
        tmp___26 = 1;
      } else {
        {
#line 329
        _glp_lib_xassert("0 <= t && t <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         329);
#line 329
        tmp___26 = 1;
        }
      }
    } else {
      {
#line 329
      _glp_lib_xassert("0 <= t && t <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       329);
#line 329
      tmp___26 = 1;
      }
    }
#line 330
    t = t;
    {
#line 330
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 330
      if (! (t >= 1)) {
#line 330
        goto while_break___18;
      }
#line 331
      j = *(ndx + t);
#line 332
      if (1 <= j) {
#line 332
        if (j <= n) {
#line 332
          tmp___27 = 1;
        } else {
          {
#line 332
          _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                           332);
#line 332
          tmp___27 = 1;
          }
        }
      } else {
        {
#line 332
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         332);
#line 332
        tmp___27 = 1;
        }
      }
#line 333
      jj = *(cn + j);
#line 334
      if (jj <= size) {
#line 334
        if (jj <= ii) {
#line 334
          tmp___28 = 1;
        } else {
          {
#line 334
          _glp_lib_xassert("jj <= ii", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                           334);
#line 334
          tmp___28 = 1;
          }
        }
      }
#line 335
      if (jj == ii) {
#line 336
        if (! diag) {
#line 336
          tmp___29 = 1;
        } else {
          {
#line 336
          _glp_lib_xassert("!diag", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                           336);
#line 336
          tmp___29 = 1;
          }
        }
#line 337
        diag = 1;
      }
#line 330
      t --;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 340
    if (diag) {
#line 340
      tmp___30 = 1;
    } else {
      {
#line 340
      _glp_lib_xassert("diag", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       340);
#line 340
      tmp___30 = 1;
      }
    }
#line 325
    ii ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 343
  _glp_lib_xfree((void *)ndx);
#line 344
  _glp_lib_xfree((void *)rs_len);
#line 345
  _glp_lib_xfree((void *)rs_head);
#line 346
  _glp_lib_xfree((void *)rs_prev);
#line 347
  _glp_lib_xfree((void *)rs_next);
#line 348
  _glp_lib_xfree((void *)cs_prev);
#line 349
  _glp_lib_xfree((void *)cs_next);
  }
#line 351
  return (size);
}
}
#line 380 "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c"
static int mat(void *info , int k , int *ndx ) 
{ 
  glp_prob *lp ;
  int m ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int typx ;
  int i ;
  int j ;
  int lll ;
  int len ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 384
  lp = (glp_prob *)info;
#line 385
  tmp = _glp_lpx_get_num_rows(lp);
#line 385
  m = tmp;
#line 386
  tmp___0 = _glp_lpx_get_num_cols(lp);
#line 386
  n = tmp___0;
#line 387
  len = 0;
  }
#line 388
  if (k > 0) {
#line 390
    i = k;
#line 391
    if (1 <= i) {
#line 391
      if (i <= m) {
#line 391
        tmp___1 = 1;
      } else {
        {
#line 391
        _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         391);
#line 391
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 391
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       391);
#line 391
      tmp___1 = 1;
      }
    }
    {
#line 407
    lll = _glp_lpx_get_mat_row(lp, i, ndx, (double *)((void *)0));
#line 408
    k = 1;
    }
    {
#line 408
    while (1) {
      while_continue: /* CIL Label */ ;
#line 408
      if (! (k <= lll)) {
#line 408
        goto while_break;
      }
      {
#line 409
      _glp_lpx_get_col_bnds(lp, *(ndx + k), & typx, (double *)((void *)0), (double *)((void *)0));
      }
#line 410
      if (typx != 114) {
#line 410
        len ++;
#line 410
        *(ndx + len) = m + *(ndx + k);
      }
#line 408
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 412
    _glp_lpx_get_row_bnds(lp, i, & typx, (double *)((void *)0), (double *)((void *)0));
    }
#line 413
    if (typx != 114) {
#line 413
      len ++;
#line 413
      *(ndx + len) = i;
    }
  } else {
#line 418
    j = - k;
#line 419
    if (1 <= j) {
#line 419
      if (j <= m + n) {
#line 419
        tmp___2 = 1;
      } else {
        {
#line 419
        _glp_lib_xassert("1 <= j && j <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         419);
#line 419
        tmp___2 = 1;
        }
      }
    } else {
      {
#line 419
      _glp_lib_xassert("1 <= j && j <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       419);
#line 419
      tmp___2 = 1;
      }
    }
#line 422
    if (j <= m) {
      {
#line 423
      _glp_lpx_get_row_bnds(lp, j, & typx, (double *)((void *)0), (double *)((void *)0));
      }
    } else {
      {
#line 425
      _glp_lpx_get_col_bnds(lp, j - m, & typx, (double *)((void *)0), (double *)((void *)0));
      }
    }
#line 426
    if (typx != 114) {
#line 427
      if (j <= m) {
#line 429
        len ++;
#line 429
        *(ndx + len) = j;
      } else {
        {
#line 439
        len = _glp_lpx_get_mat_col(lp, j - m, ndx, (double *)((void *)0));
        }
      }
    }
  }
#line 445
  return (len);
}
}
#line 448 "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c"
void _glp_adv_basis(glp_prob *lp ) 
{ 
  int m ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int i ;
  int j ;
  int jj ;
  int k ;
  int size ;
  int *rn ;
  int *cn ;
  int *rn_inv ;
  int *cn_inv ;
  int typx ;
  int *tagx ;
  void *tmp___1 ;
  double lb ;
  double ub ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___13 ;
  double tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 449
  tmp = _glp_lpx_get_num_rows(lp);
#line 449
  m = tmp;
#line 450
  tmp___0 = _glp_lpx_get_num_cols(lp);
#line 450
  n = tmp___0;
#line 453
  tmp___1 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 453
  tagx = (int *)tmp___1;
#line 455
  _glp_lib_xprintf("Crashing...\n");
  }
#line 456
  if (m == 0) {
    {
#line 457
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                               457);
#line 457
    (*tmp___2)("glp_adv_basis: problem has no rows\n");
    }
  }
#line 458
  if (n == 0) {
    {
#line 459
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                               459);
#line 459
    (*tmp___3)("glp_adv_basis: problem has no columns\n");
    }
  }
  {
#line 465
  tmp___4 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 465
  rn = (int *)tmp___4;
#line 466
  tmp___5 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 466
  cn = (int *)tmp___5;
#line 467
  size = triang(m, m + n, (void *)lp, & mat, rn, cn);
#line 468
  tmp___6 = _glp_lpx_get_int_parm(lp, 300);
  }
#line 468
  if (tmp___6 >= 3) {
    {
#line 469
    _glp_lib_xprintf("Size of triangular part = %d\n", size);
    }
  }
  {
#line 474
  tmp___7 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 474
  rn_inv = (int *)tmp___7;
#line 475
  tmp___8 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 475
  cn_inv = (int *)tmp___8;
#line 476
  i = 1;
  }
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (i <= m)) {
#line 476
      goto while_break;
    }
#line 476
    *(rn_inv + *(rn + i)) = i;
#line 476
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  j = 1;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 477
    if (! (j <= m + n)) {
#line 477
      goto while_break___0;
    }
#line 477
    *(cn_inv + *(cn + j)) = j;
#line 477
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 480
  k = 1;
  {
#line 480
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 480
    if (! (k <= m + n)) {
#line 480
      goto while_break___1;
    }
#line 480
    *(tagx + k) = -1;
#line 480
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 481
  jj = 1;
  {
#line 481
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 481
    if (! (jj <= size)) {
#line 481
      goto while_break___2;
    }
#line 482
    j = *(cn_inv + jj);
#line 484
    *(tagx + j) = 140;
#line 481
    jj ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 488
  jj = size + 1;
  {
#line 488
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 488
    if (! (jj <= m)) {
#line 488
      goto while_break___3;
    }
#line 492
    i = *(rn_inv + jj);
#line 498
    if (1 <= i) {
#line 498
      if (i <= m) {
#line 498
        tmp___9 = 1;
      } else {
        {
#line 498
        _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         498);
#line 498
        tmp___9 = 1;
        }
      }
    } else {
      {
#line 498
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       498);
#line 498
      tmp___9 = 1;
      }
    }
#line 499
    if (*(cn + i) > size) {
#line 499
      tmp___10 = 1;
    } else {
      {
#line 499
      _glp_lib_xassert("cn[i] > size", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                       499);
#line 499
      tmp___10 = 1;
      }
    }
#line 500
    *(tagx + i) = 140;
#line 488
    jj ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 503
  _glp_lib_xfree((void *)rn);
#line 504
  _glp_lib_xfree((void *)cn);
#line 505
  _glp_lib_xfree((void *)rn_inv);
#line 506
  _glp_lib_xfree((void *)cn_inv);
#line 508
  k = 1;
  }
  {
#line 508
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 508
    if (! (k <= m + n)) {
#line 508
      goto while_break___4;
    }
#line 509
    if (*(tagx + k) != 140) {
#line 510
      if (k <= m) {
        {
#line 511
        _glp_lpx_get_row_bnds(lp, k, & typx, & lb, & ub);
        }
      } else {
        {
#line 513
        _glp_lpx_get_col_bnds(lp, k - m, & typx, & lb, & ub);
        }
      }
      {
#line 515
      if (typx == 110) {
#line 515
        goto case_110;
      }
#line 517
      if (typx == 111) {
#line 517
        goto case_111;
      }
#line 519
      if (typx == 112) {
#line 519
        goto case_112;
      }
#line 521
      if (typx == 113) {
#line 521
        goto case_113;
      }
#line 525
      if (typx == 114) {
#line 525
        goto case_114;
      }
#line 527
      goto switch_default;
      case_110: /* CIL Label */ 
#line 516
      *(tagx + k) = 143;
#line 516
      goto switch_break;
      case_111: /* CIL Label */ 
#line 518
      *(tagx + k) = 141;
#line 518
      goto switch_break;
      case_112: /* CIL Label */ 
#line 520
      *(tagx + k) = 142;
#line 520
      goto switch_break;
      case_113: /* CIL Label */ 
      {
#line 522
      tmp___13 = fabs(lb);
#line 522
      tmp___14 = fabs(ub);
      }
#line 522
      if (tmp___13 <= tmp___14) {
#line 522
        *(tagx + k) = 141;
      } else {
#line 522
        *(tagx + k) = 142;
      }
#line 524
      goto switch_break;
      case_114: /* CIL Label */ 
#line 526
      *(tagx + k) = 144;
#line 526
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 528
      if (typx != typx) {
#line 528
        tmp___15 = 1;
      } else {
        {
#line 528
        _glp_lib_xassert("typx != typx", "/home/wslee/benchmarks/glpk-4.38/src/glpini01.c",
                         528);
#line 528
        tmp___15 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 508
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 532
  k = 1;
  {
#line 532
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 532
    if (! (k <= m + n)) {
#line 532
      goto while_break___5;
    }
#line 533
    if (k <= m) {
      {
#line 534
      _glp_lpx_set_row_stat(lp, k, *(tagx + k));
      }
    } else {
      {
#line 536
      _glp_lpx_set_col_stat(lp, k - m, *(tagx + k));
      }
    }
#line 532
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 538
  _glp_lib_xfree((void *)tagx);
  }
#line 539
  return;
}
}
#line 85 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
static int read_card(struct dsa___2 *dsa ) 
{ 
  int k ;
  int c ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 87
  (dsa->seqn) ++;
#line 88
  memset((void *)(dsa->card), ' ', (size_t )80);
#line 88
  dsa->card[80] = (char )'\000';
#line 89
  k = 0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    c = fgetc(dsa->fp);
#line 92
    tmp___1 = ferror(dsa->fp);
    }
#line 92
    if (tmp___1) {
      {
#line 93
      tmp = __errno_location();
#line 93
      tmp___0 = strerror(*tmp);
#line 93
      _glp_lib_xprintf("%s:%d: read error - %s\n", dsa->fname, dsa->seqn, tmp___0);
      }
#line 95
      return (1);
    }
    {
#line 97
    tmp___2 = feof(dsa->fp);
    }
#line 97
    if (tmp___2) {
#line 98
      if (k == 0) {
        {
#line 99
        _glp_lib_xprintf("%s:%d: unexpected EOF\n", dsa->fname, dsa->seqn);
        }
      } else {
        {
#line 102
        _glp_lib_xprintf("%s:%d: missing final LF\n", dsa->fname, dsa->seqn);
        }
      }
#line 104
      return (1);
    }
#line 106
    if (c == 13) {
#line 106
      goto __Cont;
    }
#line 107
    if (c == 10) {
#line 107
      goto while_break;
    }
    {
#line 108
    tmp___3 = __ctype_b_loc();
    }
#line 108
    if ((int const   )*(*tmp___3 + c) & 2) {
      {
#line 109
      _glp_lib_xprintf("%s:%d: invalid control character 0x%02X\n", dsa->fname, dsa->seqn,
                       c);
      }
#line 111
      return (1);
    }
#line 113
    if (k == 80) {
      {
#line 114
      _glp_lib_xprintf("%s:%d: card image too long\n", dsa->fname, dsa->seqn);
      }
#line 116
      return (1);
    }
#line 118
    tmp___4 = k;
#line 118
    k ++;
#line 118
    dsa->card[tmp___4] = (char )c;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (0);
}
}
#line 132 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
static int scan_int(struct dsa___2 *dsa , char *fld , int pos , int width , int *val ) 
{ 
  char str[81] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 135
  if (1 <= width) {
#line 135
    if (width <= 80) {
#line 135
      tmp = 1;
    } else {
      {
#line 135
      _glp_lib_xassert("1 <= width && width <= 80", "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c",
                       135);
#line 135
      tmp = 1;
      }
    }
  } else {
    {
#line 135
    _glp_lib_xassert("1 <= width && width <= 80", "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c",
                     135);
#line 135
    tmp = 1;
    }
  }
  {
#line 136
  memcpy((void */* __restrict  */)(str), (void const   */* __restrict  */)(dsa->card + pos),
         (size_t )width);
#line 136
  str[width] = (char )'\000';
#line 137
  tmp___0 = _glp_lib_strspx(str);
#line 137
  tmp___1 = _glp_lib_str2int((char const   *)tmp___0, val);
  }
#line 137
  if (tmp___1) {
    {
#line 138
    _glp_lib_xprintf("%s:%d: field `%s\' contains invalid value `%s\'\n", dsa->fname,
                     dsa->seqn, fld, str);
    }
#line 140
    return (1);
  }
#line 142
  return (0);
}
}
#line 154 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
static int parse_fmt(struct dsa___2 *dsa , char *fmt___0 ) 
{ 
  int k ;
  int s ;
  int val ;
  char str[81] ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___20 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 158
  if ((int )*(fmt___0 + 0) != 40) {
    fail: 
    {
#line 159
    _glp_lib_xprintf("hbm_read_mat: format `%s\' not recognised\n", fmt___0);
    }
#line 160
    return (1);
  }
  {
#line 162
  k = 1;
#line 164
  dsa->fmt_p = 0;
#line 165
  tmp___4 = __ctype_b_loc();
  }
#line 165
  if ((int const   )*(*tmp___4 + (int )((unsigned char )*(fmt___0 + k))) & 2048) {
#line 166
    s = 0;
    {
#line 167
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 167
      tmp___1 = __ctype_b_loc();
      }
#line 167
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*(fmt___0 + k))) & 2048)) {
#line 167
        goto while_break;
      }
#line 168
      if (s == 80) {
#line 168
        goto fail;
      }
#line 169
      tmp = s;
#line 169
      s ++;
#line 169
      tmp___0 = k;
#line 169
      k ++;
#line 169
      str[tmp] = *(fmt___0 + tmp___0);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 171
    str[s] = (char )'\000';
#line 172
    tmp___2 = _glp_lib_str2int((char const   *)(str), & val);
    }
#line 172
    if (tmp___2) {
#line 172
      goto fail;
    }
    {
#line 173
    tmp___3 = toupper((int )((unsigned char )*(fmt___0 + k)));
    }
#line 173
    if (tmp___3 != 80) {
#line 173
      goto iter;
    }
#line 174
    dsa->fmt_p = val;
#line 174
    k ++;
#line 175
    if (0 <= dsa->fmt_p) {
#line 175
      if (! (dsa->fmt_p <= 255)) {
#line 175
        goto fail;
      }
    } else {
#line 175
      goto fail;
    }
#line 177
    if ((int )*(fmt___0 + k) == 44) {
#line 177
      k ++;
    }
  }
  {
#line 180
  dsa->fmt_k = 1;
#line 181
  tmp___9 = __ctype_b_loc();
  }
#line 181
  if ((int const   )*(*tmp___9 + (int )((unsigned char )*(fmt___0 + k))) & 2048) {
#line 182
    s = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 183
      tmp___7 = __ctype_b_loc();
      }
#line 183
      if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*(fmt___0 + k))) & 2048)) {
#line 183
        goto while_break___0;
      }
#line 184
      if (s == 80) {
#line 184
        goto fail;
      }
#line 185
      tmp___5 = s;
#line 185
      s ++;
#line 185
      tmp___6 = k;
#line 185
      k ++;
#line 185
      str[tmp___5] = *(fmt___0 + tmp___6);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 187
    str[s] = (char )'\000';
#line 188
    tmp___8 = _glp_lib_str2int((char const   *)(str), & val);
    }
#line 188
    if (tmp___8) {
#line 188
      goto fail;
    }
    iter: 
#line 189
    dsa->fmt_k = val;
#line 190
    if (1 <= dsa->fmt_k) {
#line 190
      if (! (dsa->fmt_k <= 255)) {
#line 190
        goto fail;
      }
    } else {
#line 190
      goto fail;
    }
  }
  {
#line 193
  tmp___10 = k;
#line 193
  k ++;
#line 193
  dsa->fmt_f = toupper((int )((unsigned char )*(fmt___0 + tmp___10)));
  }
#line 194
  if (! (dsa->fmt_f == 68)) {
#line 194
    if (! (dsa->fmt_f == 69)) {
#line 194
      if (! (dsa->fmt_f == 70)) {
#line 194
        if (! (dsa->fmt_f == 71)) {
#line 194
          if (! (dsa->fmt_f == 73)) {
#line 196
            goto fail;
          }
        }
      }
    }
  }
  {
#line 198
  tmp___11 = __ctype_b_loc();
  }
#line 198
  if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*(fmt___0 + k))) & 2048)) {
#line 198
    goto fail;
  }
#line 199
  s = 0;
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 200
    tmp___14 = __ctype_b_loc();
    }
#line 200
    if (! ((int const   )*(*tmp___14 + (int )((unsigned char )*(fmt___0 + k))) & 2048)) {
#line 200
      goto while_break___1;
    }
#line 201
    if (s == 80) {
#line 201
      goto fail;
    }
#line 202
    tmp___12 = s;
#line 202
    s ++;
#line 202
    tmp___13 = k;
#line 202
    k ++;
#line 202
    str[tmp___12] = *(fmt___0 + tmp___13);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 204
  str[s] = (char )'\000';
#line 205
  tmp___15 = _glp_lib_str2int((char const   *)(str), & dsa->fmt_w);
  }
#line 205
  if (tmp___15) {
#line 205
    goto fail;
  }
#line 206
  if (1 <= dsa->fmt_w) {
#line 206
    if (! (dsa->fmt_w <= 255)) {
#line 206
      goto fail;
    }
  } else {
#line 206
    goto fail;
  }
#line 208
  dsa->fmt_d = 0;
#line 209
  if ((int )*(fmt___0 + k) == 46) {
    {
#line 210
    k ++;
#line 211
    tmp___16 = __ctype_b_loc();
    }
#line 211
    if (! ((int const   )*(*tmp___16 + (int )((unsigned char )*(fmt___0 + k))) & 2048)) {
#line 211
      goto fail;
    }
#line 212
    s = 0;
    {
#line 213
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 213
      tmp___19 = __ctype_b_loc();
      }
#line 213
      if (! ((int const   )*(*tmp___19 + (int )((unsigned char )*(fmt___0 + k))) & 2048)) {
#line 213
        goto while_break___2;
      }
#line 214
      if (s == 80) {
#line 214
        goto fail;
      }
#line 215
      tmp___17 = s;
#line 215
      s ++;
#line 215
      tmp___18 = k;
#line 215
      k ++;
#line 215
      str[tmp___17] = *(fmt___0 + tmp___18);
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 217
    str[s] = (char )'\000';
#line 218
    tmp___20 = _glp_lib_str2int((char const   *)(str), & dsa->fmt_d);
    }
#line 218
    if (tmp___20) {
#line 218
      goto fail;
    }
#line 219
    if (0 <= dsa->fmt_d) {
#line 219
      if (! (dsa->fmt_d <= 255)) {
#line 219
        goto fail;
      }
    } else {
#line 219
      goto fail;
    }
  }
#line 222
  if ((int )*(fmt___0 + k) == 41) {
#line 222
    if (! ((int )*(fmt___0 + (k + 1)) == 0)) {
#line 222
      goto fail;
    }
  } else {
#line 222
    goto fail;
  }
#line 223
  return (0);
}
}
#line 235 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
static int read_int_array(struct dsa___2 *dsa , char *name , char *fmt___0 , int n ,
                          int *val ) 
{ 
  int k ;
  int pos ;
  char str[81] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 239
  tmp = parse_fmt(dsa, fmt___0);
  }
#line 239
  if (tmp) {
#line 239
    return (1);
  }
#line 240
  if (dsa->fmt_f == 73) {
#line 240
    if (dsa->fmt_w <= 80) {
#line 240
      if (! (dsa->fmt_k * dsa->fmt_w <= 80)) {
        {
#line 242
        _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid format `%s\'\n",
                         dsa->fname, dsa->seqn, name, fmt___0);
        }
#line 245
        return (1);
      }
    } else {
      {
#line 242
      _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid format `%s\'\n",
                       dsa->fname, dsa->seqn, name, fmt___0);
      }
#line 245
      return (1);
    }
  } else {
    {
#line 242
    _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid format `%s\'\n", dsa->fname,
                     dsa->seqn, name, fmt___0);
    }
#line 245
    return (1);
  }
#line 247
  k = 1;
#line 247
  pos = 2147483647;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (k <= n)) {
#line 247
      goto while_break;
    }
#line 248
    if (pos >= dsa->fmt_k) {
      {
#line 249
      tmp___0 = read_card(dsa);
      }
#line 249
      if (tmp___0) {
#line 249
        return (1);
      }
#line 250
      pos = 0;
    }
    {
#line 252
    memcpy((void */* __restrict  */)(str), (void const   */* __restrict  */)(dsa->card + dsa->fmt_w * pos),
           (size_t )dsa->fmt_w);
#line 253
    str[dsa->fmt_w] = (char )'\000';
#line 254
    _glp_lib_strspx(str);
#line 255
    tmp___1 = _glp_lib_str2int((char const   *)(str), val + k);
    }
#line 255
    if (tmp___1) {
      {
#line 256
      _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid value `%s\'\n", dsa->fname,
                       dsa->seqn, name, str);
      }
#line 259
      return (1);
    }
#line 247
    k ++;
#line 247
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (0);
}
}
#line 274 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
static int read_real_array(struct dsa___2 *dsa , char *name , char *fmt___0 , int n ,
                           double *val ) 
{ 
  int k ;
  int pos ;
  char str[81] ;
  char *ptr ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 278
  tmp = parse_fmt(dsa, fmt___0);
  }
#line 278
  if (tmp) {
#line 278
    return (1);
  }
#line 279
  if (dsa->fmt_f != 73) {
#line 279
    if (dsa->fmt_w <= 80) {
#line 279
      if (! (dsa->fmt_k * dsa->fmt_w <= 80)) {
        {
#line 281
        _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid format `%s\'\n",
                         dsa->fname, dsa->seqn, name, fmt___0);
        }
#line 284
        return (1);
      }
    } else {
      {
#line 281
      _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid format `%s\'\n",
                       dsa->fname, dsa->seqn, name, fmt___0);
      }
#line 284
      return (1);
    }
  } else {
    {
#line 281
    _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid format `%s\'\n", dsa->fname,
                     dsa->seqn, name, fmt___0);
    }
#line 284
    return (1);
  }
#line 286
  k = 1;
#line 286
  pos = 2147483647;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (k <= n)) {
#line 286
      goto while_break;
    }
#line 287
    if (pos >= dsa->fmt_k) {
      {
#line 288
      tmp___0 = read_card(dsa);
      }
#line 288
      if (tmp___0) {
#line 288
        return (1);
      }
#line 289
      pos = 0;
    }
    {
#line 291
    memcpy((void */* __restrict  */)(str), (void const   */* __restrict  */)(dsa->card + dsa->fmt_w * pos),
           (size_t )dsa->fmt_w);
#line 292
    str[dsa->fmt_w] = (char )'\000';
#line 293
    _glp_lib_strspx(str);
#line 294
    tmp___1 = strchr((char const   *)(str), '.');
    }
#line 294
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 294
      tmp___2 = strcmp((char const   *)(str), "0");
      }
#line 294
      if (tmp___2) {
        {
#line 295
        _glp_lib_xprintf("%s(%d): can\'t read array `%s\' - value `%s\' has no decimal point\n",
                         dsa->fname, dsa->seqn, name, str);
        }
#line 297
        return (1);
      }
    }
#line 300
    ptr = str;
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 300
      if (! *ptr) {
#line 300
        goto while_break___0;
      }
      {
#line 301
      tmp___3 = toupper((int )((unsigned char )*ptr));
#line 301
      *ptr = (char )tmp___3;
#line 300
      ptr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 302
    ptr = strchr((char const   *)(str), 'D');
    }
#line 303
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 303
      *ptr = (char )'E';
    }
    {
#line 307
    ptr = strchr((char const   *)(str + 1), '+');
    }
#line 308
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 308
      ptr = strchr((char const   *)(str + 1), '-');
      }
    }
#line 309
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 309
      if ((int )*(ptr - 1) != 69) {
        {
#line 310
        tmp___4 = strlen((char const   *)(str));
        }
#line 310
        if (tmp___4 < 80U) {
#line 310
          tmp___5 = 1;
        } else {
          {
#line 310
          _glp_lib_xassert("strlen(str) < 80", "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c",
                           310);
#line 310
          tmp___5 = 1;
          }
        }
        {
#line 311
        tmp___6 = strlen((char const   *)ptr);
#line 311
        memmove((void *)(ptr + 1), (void const   *)ptr, tmp___6 + 1U);
#line 312
        *ptr = (char )'E';
        }
      }
    }
    {
#line 314
    tmp___7 = _glp_lib_str2num((char const   *)(str), val + k);
    }
#line 314
    if (tmp___7) {
      {
#line 315
      _glp_lib_xprintf("%s:%d: can\'t read array `%s\' - invalid value `%s\'\n", dsa->fname,
                       dsa->seqn, name, str);
      }
#line 318
      return (1);
    }
#line 286
    k ++;
#line 286
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return (0);
}
}
#line 324 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
HBM *_glp_hbm_read_mat(char const   *fname ) 
{ 
  struct dsa___2 _dsa ;
  struct dsa___2 *dsa ;
  HBM *hbm ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  int tmp___30 ;
  void *tmp___31 ;
  int tmp___32 ;
  void *tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  int tmp___36 ;
  void *tmp___37 ;
  int tmp___38 ;
  void *tmp___39 ;
  int tmp___40 ;
  void *tmp___41 ;
  int tmp___42 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;

  {
  {
#line 325
  dsa = & _dsa;
#line 326
  hbm = (HBM *)((void *)0);
#line 327
  dsa->fname = fname;
#line 328
  _glp_lib_xprintf("hbm_read_mat: reading matrix from `%s\'...\n", dsa->fname);
#line 330
  dsa->fp = fopen((char const   */* __restrict  */)dsa->fname, (char const   */* __restrict  */)"r");
  }
#line 331
  if ((unsigned long )dsa->fp == (unsigned long )((void *)0)) {
    {
#line 332
    tmp = __errno_location();
#line 332
    tmp___0 = strerror(*tmp);
#line 332
    _glp_lib_xprintf("hbm_read_mat: unable to open `%s\' - %s\n", dsa->fname, tmp___0);
    }
#line 334
    goto fail;
  }
  {
#line 336
  dsa->seqn = 0;
#line 337
  tmp___1 = _glp_lib_xmalloc((int )sizeof(HBM ));
#line 337
  hbm = (HBM *)tmp___1;
#line 338
  memset((void *)hbm, 0, (size_t )sizeof(HBM ));
#line 340
  tmp___2 = read_card(dsa);
  }
#line 340
  if (tmp___2) {
#line 340
    goto fail;
  }
  {
#line 341
  memcpy((void */* __restrict  */)(hbm->title), (void const   */* __restrict  */)(dsa->card),
         (size_t )72);
#line 341
  hbm->title[72] = (char )'\000';
#line 342
  _glp_lib_strtrim(hbm->title);
#line 343
  _glp_lib_xprintf("%s\n", hbm->title);
#line 344
  memcpy((void */* __restrict  */)(hbm->key), (void const   */* __restrict  */)(dsa->card + 72),
         (size_t )8);
#line 344
  hbm->key[8] = (char )'\000';
#line 345
  _glp_lib_strspx(hbm->key);
#line 346
  _glp_lib_xprintf("key = %s\n", hbm->key);
#line 348
  tmp___3 = read_card(dsa);
  }
#line 348
  if (tmp___3) {
#line 348
    goto fail;
  }
  {
#line 349
  tmp___4 = scan_int(dsa, (char *)"totcrd", 0, 14, & hbm->totcrd);
  }
#line 349
  if (tmp___4) {
#line 349
    goto fail;
  }
  {
#line 350
  tmp___5 = scan_int(dsa, (char *)"ptrcrd", 14, 14, & hbm->ptrcrd);
  }
#line 350
  if (tmp___5) {
#line 350
    goto fail;
  }
  {
#line 351
  tmp___6 = scan_int(dsa, (char *)"indcrd", 28, 14, & hbm->indcrd);
  }
#line 351
  if (tmp___6) {
#line 351
    goto fail;
  }
  {
#line 352
  tmp___7 = scan_int(dsa, (char *)"valcrd", 42, 14, & hbm->valcrd);
  }
#line 352
  if (tmp___7) {
#line 352
    goto fail;
  }
  {
#line 353
  tmp___8 = scan_int(dsa, (char *)"rhscrd", 56, 14, & hbm->rhscrd);
  }
#line 353
  if (tmp___8) {
#line 353
    goto fail;
  }
  {
#line 354
  _glp_lib_xprintf("totcrd = %d; ptrcrd = %d; indcrd = %d; valcrd = %d; rhscrd = %d\n",
                   hbm->totcrd, hbm->ptrcrd, hbm->indcrd, hbm->valcrd, hbm->rhscrd);
#line 358
  tmp___9 = read_card(dsa);
  }
#line 358
  if (tmp___9) {
#line 358
    goto fail;
  }
  {
#line 359
  memcpy((void */* __restrict  */)(hbm->mxtype), (void const   */* __restrict  */)(dsa->card),
         (size_t )3);
#line 359
  hbm->mxtype[3] = (char )'\000';
#line 360
  tmp___10 = strchr("RCP", (int )hbm->mxtype[0]);
  }
#line 360
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
    {
#line 363
    _glp_lib_xprintf("%s:%d: matrix type `%s\' not recognised\n", dsa->fname, dsa->seqn,
                     hbm->mxtype);
    }
#line 365
    goto fail;
  } else {
    {
#line 360
    tmp___11 = strchr("SUHZR", (int )hbm->mxtype[1]);
    }
#line 360
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
      {
#line 363
      _glp_lib_xprintf("%s:%d: matrix type `%s\' not recognised\n", dsa->fname, dsa->seqn,
                       hbm->mxtype);
      }
#line 365
      goto fail;
    } else {
      {
#line 360
      tmp___12 = strchr("AE", (int )hbm->mxtype[2]);
      }
#line 360
      if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
        {
#line 363
        _glp_lib_xprintf("%s:%d: matrix type `%s\' not recognised\n", dsa->fname,
                         dsa->seqn, hbm->mxtype);
        }
#line 365
        goto fail;
      }
    }
  }
  {
#line 367
  tmp___13 = scan_int(dsa, (char *)"nrow", 14, 14, & hbm->nrow);
  }
#line 367
  if (tmp___13) {
#line 367
    goto fail;
  }
  {
#line 368
  tmp___14 = scan_int(dsa, (char *)"ncol", 28, 14, & hbm->ncol);
  }
#line 368
  if (tmp___14) {
#line 368
    goto fail;
  }
  {
#line 369
  tmp___15 = scan_int(dsa, (char *)"nnzero", 42, 14, & hbm->nnzero);
  }
#line 369
  if (tmp___15) {
#line 369
    goto fail;
  }
  {
#line 370
  tmp___16 = scan_int(dsa, (char *)"neltvl", 56, 14, & hbm->neltvl);
  }
#line 370
  if (tmp___16) {
#line 370
    goto fail;
  }
  {
#line 371
  _glp_lib_xprintf("mxtype = %s; nrow = %d; ncol = %d; nnzero = %d; neltvl = %d\n",
                   hbm->mxtype, hbm->nrow, hbm->ncol, hbm->nnzero, hbm->neltvl);
#line 375
  tmp___17 = read_card(dsa);
  }
#line 375
  if (tmp___17) {
#line 375
    goto fail;
  }
  {
#line 376
  memcpy((void */* __restrict  */)(hbm->ptrfmt), (void const   */* __restrict  */)(dsa->card),
         (size_t )16);
#line 376
  hbm->ptrfmt[16] = (char )'\000';
#line 377
  _glp_lib_strspx(hbm->ptrfmt);
#line 378
  memcpy((void */* __restrict  */)(hbm->indfmt), (void const   */* __restrict  */)(dsa->card + 16),
         (size_t )16);
#line 378
  hbm->indfmt[16] = (char )'\000';
#line 379
  _glp_lib_strspx(hbm->indfmt);
#line 380
  memcpy((void */* __restrict  */)(hbm->valfmt), (void const   */* __restrict  */)(dsa->card + 32),
         (size_t )20);
#line 380
  hbm->valfmt[20] = (char )'\000';
#line 381
  _glp_lib_strspx(hbm->valfmt);
#line 382
  memcpy((void */* __restrict  */)(hbm->rhsfmt), (void const   */* __restrict  */)(dsa->card + 52),
         (size_t )20);
#line 382
  hbm->rhsfmt[20] = (char )'\000';
#line 383
  _glp_lib_strspx(hbm->rhsfmt);
#line 384
  _glp_lib_xprintf("ptrfmt = %s; indfmt = %s; valfmt = %s; rhsfmt = %s\n", hbm->ptrfmt,
                   hbm->indfmt, hbm->valfmt, hbm->rhsfmt);
  }
#line 387
  if (hbm->rhscrd <= 0) {
    {
#line 388
    strcpy((char */* __restrict  */)(hbm->rhstyp), (char const   */* __restrict  */)"???");
#line 389
    hbm->nrhs = 0;
#line 390
    hbm->nrhsix = 0;
    }
  } else {
    {
#line 393
    tmp___18 = read_card(dsa);
    }
#line 393
    if (tmp___18) {
#line 393
      goto fail;
    }
    {
#line 394
    memcpy((void */* __restrict  */)(hbm->rhstyp), (void const   */* __restrict  */)(dsa->card),
           (size_t )3);
#line 394
    hbm->rhstyp[3] = (char )'\000';
#line 395
    tmp___19 = scan_int(dsa, (char *)"nrhs", 14, 14, & hbm->nrhs);
    }
#line 395
    if (tmp___19) {
#line 395
      goto fail;
    }
    {
#line 396
    tmp___20 = scan_int(dsa, (char *)"nrhsix", 28, 14, & hbm->nrhsix);
    }
#line 396
    if (tmp___20) {
#line 396
      goto fail;
    }
    {
#line 397
    _glp_lib_xprintf("rhstyp = `%s\'; nrhs = %d; nrhsix = %d\n", hbm->rhstyp, hbm->nrhs,
                     hbm->nrhsix);
    }
  }
  {
#line 401
  tmp___21 = _glp_lib_xcalloc((1 + hbm->ncol) + 1, (int )sizeof(int ));
#line 401
  hbm->colptr = (int *)tmp___21;
#line 402
  tmp___22 = read_int_array(dsa, (char *)"colptr", hbm->ptrfmt, hbm->ncol + 1, hbm->colptr);
  }
#line 402
  if (tmp___22) {
#line 403
    goto fail;
  }
  {
#line 404
  tmp___23 = _glp_lib_xcalloc(1 + hbm->nnzero, (int )sizeof(int ));
#line 404
  hbm->rowind = (int *)tmp___23;
#line 405
  tmp___24 = read_int_array(dsa, (char *)"rowind", hbm->indfmt, hbm->nnzero, hbm->rowind);
  }
#line 405
  if (tmp___24) {
#line 406
    goto fail;
  }
#line 408
  if (hbm->valcrd <= 0) {
#line 408
    goto done;
  }
#line 409
  if ((int )hbm->mxtype[2] == 65) {
    {
#line 411
    tmp___25 = _glp_lib_xcalloc(1 + hbm->nnzero, (int )sizeof(double ));
#line 411
    hbm->values = (double *)tmp___25;
#line 412
    tmp___26 = read_real_array(dsa, (char *)"values", hbm->valfmt, hbm->nnzero, hbm->values);
    }
#line 412
    if (tmp___26) {
#line 413
      goto fail;
    }
  } else {
    {
#line 417
    tmp___27 = _glp_lib_xcalloc(1 + hbm->neltvl, (int )sizeof(double ));
#line 417
    hbm->values = (double *)tmp___27;
#line 418
    tmp___28 = read_real_array(dsa, (char *)"values", hbm->valfmt, hbm->neltvl, hbm->values);
    }
#line 418
    if (tmp___28) {
#line 419
      goto fail;
    }
  }
#line 422
  if (hbm->nrhs <= 0) {
#line 422
    goto done;
  }
#line 423
  if ((int )hbm->rhstyp[0] == 70) {
    {
#line 425
    hbm->nrhsvl = hbm->nrow * hbm->nrhs;
#line 426
    tmp___29 = _glp_lib_xcalloc(1 + hbm->nrhsvl, (int )sizeof(double ));
#line 426
    hbm->rhsval = (double *)tmp___29;
#line 427
    tmp___30 = read_real_array(dsa, (char *)"rhsval", hbm->rhsfmt, hbm->nrhsvl, hbm->rhsval);
    }
#line 427
    if (tmp___30) {
#line 428
      goto fail;
    }
  } else
#line 430
  if ((int )hbm->rhstyp[0] == 77) {
#line 430
    if ((int )hbm->mxtype[2] == 65) {
      {
#line 433
      tmp___31 = _glp_lib_xcalloc((1 + hbm->nrhs) + 1, (int )sizeof(int ));
#line 433
      hbm->rhsptr = (int *)tmp___31;
#line 434
      tmp___32 = read_int_array(dsa, (char *)"rhsptr", hbm->ptrfmt, hbm->nrhs + 1,
                                hbm->rhsptr);
      }
#line 434
      if (tmp___32) {
#line 435
        goto fail;
      }
      {
#line 437
      tmp___33 = _glp_lib_xcalloc(1 + hbm->nrhsix, (int )sizeof(int ));
#line 437
      hbm->rhsind = (int *)tmp___33;
#line 438
      tmp___34 = read_int_array(dsa, (char *)"rhsind", hbm->indfmt, hbm->nrhsix, hbm->rhsind);
      }
#line 438
      if (tmp___34) {
#line 439
        goto fail;
      }
      {
#line 441
      tmp___35 = _glp_lib_xcalloc(1 + hbm->nrhsix, (int )sizeof(double ));
#line 441
      hbm->rhsval = (double *)tmp___35;
#line 442
      tmp___36 = read_real_array(dsa, (char *)"rhsval", hbm->rhsfmt, hbm->nrhsix,
                                 hbm->rhsval);
      }
#line 442
      if (tmp___36) {
#line 443
        goto fail;
      }
    } else {
#line 430
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 445
  if ((int )hbm->rhstyp[0] == 77) {
#line 445
    if ((int )hbm->mxtype[2] == 69) {
      {
#line 447
      tmp___37 = _glp_lib_xcalloc(1 + hbm->nrhsvl, (int )sizeof(double ));
#line 447
      hbm->rhsval = (double *)tmp___37;
#line 448
      tmp___38 = read_real_array(dsa, (char *)"rhsval", hbm->rhsfmt, hbm->nrhsvl,
                                 hbm->rhsval);
      }
#line 448
      if (tmp___38) {
#line 449
        goto fail;
      }
    } else {
      {
#line 452
      _glp_lib_xprintf("%s:%d: right-hand side type `%c\' not recognised\n", dsa->fname,
                       dsa->seqn, (int )hbm->rhstyp[0]);
      }
#line 454
      goto fail;
    }
  } else {
    {
#line 452
    _glp_lib_xprintf("%s:%d: right-hand side type `%c\' not recognised\n", dsa->fname,
                     dsa->seqn, (int )hbm->rhstyp[0]);
    }
#line 454
    goto fail;
  }
#line 457
  if ((int )hbm->rhstyp[1] == 71) {
    {
#line 458
    hbm->nguess = hbm->nrow * hbm->nrhs;
#line 459
    tmp___39 = _glp_lib_xcalloc(1 + hbm->nguess, (int )sizeof(double ));
#line 459
    hbm->sguess = (double *)tmp___39;
#line 460
    tmp___40 = read_real_array(dsa, (char *)"sguess", hbm->rhsfmt, hbm->nguess, hbm->sguess);
    }
#line 460
    if (tmp___40) {
#line 461
      goto fail;
    }
  }
#line 464
  if ((int )hbm->rhstyp[2] == 88) {
    {
#line 465
    hbm->nexact = hbm->nrow * hbm->nrhs;
#line 466
    tmp___41 = _glp_lib_xcalloc(1 + hbm->nexact, (int )sizeof(double ));
#line 466
    hbm->xexact = (double *)tmp___41;
#line 467
    tmp___42 = read_real_array(dsa, (char *)"xexact", hbm->rhsfmt, hbm->nexact, hbm->xexact);
    }
#line 467
    if (tmp___42) {
#line 468
      goto fail;
    }
  }
  done: 
  {
#line 471
  _glp_lib_xprintf("hbm_read_mat: %d cards were read\n", dsa->seqn);
#line 472
  fclose(dsa->fp);
  }
#line 473
  return (hbm);
  fail: 
#line 475
  if ((unsigned long )hbm != (unsigned long )((void *)0)) {
#line 476
    if ((unsigned long )hbm->colptr != (unsigned long )((void *)0)) {
      {
#line 476
      _glp_lib_xfree((void *)hbm->colptr);
      }
    }
#line 477
    if ((unsigned long )hbm->rowind != (unsigned long )((void *)0)) {
      {
#line 477
      _glp_lib_xfree((void *)hbm->rowind);
      }
    }
#line 478
    if ((unsigned long )hbm->rhsptr != (unsigned long )((void *)0)) {
      {
#line 478
      _glp_lib_xfree((void *)hbm->rhsptr);
      }
    }
#line 479
    if ((unsigned long )hbm->rhsind != (unsigned long )((void *)0)) {
      {
#line 479
      _glp_lib_xfree((void *)hbm->rhsind);
      }
    }
#line 480
    if ((unsigned long )hbm->values != (unsigned long )((void *)0)) {
      {
#line 480
      _glp_lib_xfree((void *)hbm->values);
      }
    }
#line 481
    if ((unsigned long )hbm->rhsval != (unsigned long )((void *)0)) {
      {
#line 481
      _glp_lib_xfree((void *)hbm->rhsval);
      }
    }
#line 482
    if ((unsigned long )hbm->sguess != (unsigned long )((void *)0)) {
      {
#line 482
      _glp_lib_xfree((void *)hbm->sguess);
      }
    }
#line 483
    if ((unsigned long )hbm->xexact != (unsigned long )((void *)0)) {
      {
#line 483
      _glp_lib_xfree((void *)hbm->xexact);
      }
    }
    {
#line 484
    _glp_lib_xfree((void *)hbm);
    }
  }
#line 486
  if ((unsigned long )dsa->fp != (unsigned long )((void *)0)) {
    {
#line 486
    fclose(dsa->fp);
    }
  }
#line 487
  return ((HBM *)((void *)0));
}
}
#line 505 "/home/wslee/benchmarks/glpk-4.38/src/glphbm.c"
void _glp_hbm_free_mat(HBM *hbm ) 
{ 


  {
#line 506
  if ((unsigned long )hbm->colptr != (unsigned long )((void *)0)) {
    {
#line 506
    _glp_lib_xfree((void *)hbm->colptr);
    }
  }
#line 507
  if ((unsigned long )hbm->rowind != (unsigned long )((void *)0)) {
    {
#line 507
    _glp_lib_xfree((void *)hbm->rowind);
    }
  }
#line 508
  if ((unsigned long )hbm->rhsptr != (unsigned long )((void *)0)) {
    {
#line 508
    _glp_lib_xfree((void *)hbm->rhsptr);
    }
  }
#line 509
  if ((unsigned long )hbm->rhsind != (unsigned long )((void *)0)) {
    {
#line 509
    _glp_lib_xfree((void *)hbm->rhsind);
    }
  }
#line 510
  if ((unsigned long )hbm->values != (unsigned long )((void *)0)) {
    {
#line 510
    _glp_lib_xfree((void *)hbm->values);
    }
  }
#line 511
  if ((unsigned long )hbm->rhsval != (unsigned long )((void *)0)) {
    {
#line 511
    _glp_lib_xfree((void *)hbm->rhsval);
    }
  }
#line 512
  if ((unsigned long )hbm->sguess != (unsigned long )((void *)0)) {
    {
#line 512
    _glp_lib_xfree((void *)hbm->sguess);
    }
  }
#line 513
  if ((unsigned long )hbm->xexact != (unsigned long )((void *)0)) {
    {
#line 513
    _glp_lib_xfree((void *)hbm->xexact);
    }
  }
  {
#line 514
  _glp_lib_xfree((void *)hbm);
  }
#line 515
  return;
}
}
#line 142 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.h"
void *_glp_gmp_get_atom(int size ) ;
#line 143
void _glp_gmp_free_atom(void *ptr , int size ) ;
#line 144
int _glp_gmp_pool_count(void) ;
#line 145
unsigned short *_glp_gmp_get_work(int size ) ;
#line 146
void _glp_gmp_free_mem(void) ;
#line 148
mpz_t _glp_mpz_init(void) ;
#line 150
void _glp_mpz_clear(mpz_t x ) ;
#line 151
void _glp_mpz_set(mpz_t z , mpz_t x ) ;
#line 152
void _glp_mpz_set_si(mpz_t x , int val ) ;
#line 153
double _glp_mpz_get_d(mpz_t x ) ;
#line 154
double _glp_mpz_get_d_2exp(int *exp___0 , mpz_t x ) ;
#line 155
void _glp_mpz_swap(mpz_t x , mpz_t y ) ;
#line 156
void _glp_mpz_add(mpz_t z , mpz_t x , mpz_t y ) ;
#line 157
void _glp_mpz_sub(mpz_t z , mpz_t x , mpz_t y ) ;
#line 158
void _glp_mpz_mul(mpz_t z , mpz_t x , mpz_t y ) ;
#line 159
void _glp_mpz_neg(mpz_t z , mpz_t x ) ;
#line 160
void _glp_mpz_abs(mpz_t z , mpz_t x ) ;
#line 161
void _glp_mpz_div(mpz_t q , mpz_t r , mpz_t x , mpz_t y ) ;
#line 162
void _glp_mpz_gcd(mpz_t z , mpz_t x , mpz_t y ) ;
#line 163
int _glp_mpz_cmp(mpz_t x , mpz_t y ) ;
#line 164
int _glp_mpz_sgn(mpz_t x ) ;
#line 165
int _glp_mpz_out_str(void *_fp , int base , mpz_t x ) ;
#line 170
void _glp_mpq_canonicalize(mpq_t x ) ;
#line 174
void _glp_mpq_set_d(mpq_t x , double val ) ;
#line 183
int _glp_mpq_out_str(void *_fp , int base , mpq_t x ) ;
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
static DMP *gmp_pool  =    (DMP *)((void *)0);
#line 38 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
static int gmp_size  =    0;
#line 39 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
static unsigned short *gmp_work  =    (unsigned short *)((void *)0);
#line 41 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void *_glp_gmp_get_atom(int size ) 
{ 
  void *tmp ;

  {
#line 42
  if ((unsigned long )gmp_pool == (unsigned long )((void *)0)) {
    {
#line 43
    gmp_pool = _glp_dmp_create_pool();
    }
  }
  {
#line 44
  tmp = _glp_dmp_get_atom(gmp_pool, size);
  }
#line 44
  return (tmp);
}
}
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_gmp_free_atom(void *ptr , int size ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 48
  if ((unsigned long )gmp_pool != (unsigned long )((void *)0)) {
#line 48
    tmp = 1;
  } else {
    {
#line 48
    _glp_lib_xassert("gmp_pool != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     48);
#line 48
    tmp = 1;
    }
  }
  {
#line 49
  _glp_dmp_free_atom(gmp_pool, ptr, size);
  }
#line 50
  return;
}
}
#line 53 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
int _glp_gmp_pool_count(void) 
{ 
  xlong_t tmp ;

  {
#line 54
  if ((unsigned long )gmp_pool == (unsigned long )((void *)0)) {
#line 55
    return (0);
  } else {
    {
#line 57
    tmp = _glp_dmp_in_use(gmp_pool);
    }
#line 57
    return (tmp.lo);
  }
}
}
#line 60 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
unsigned short *_glp_gmp_get_work(int size ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 61
  if (size > 0) {
#line 61
    tmp = 1;
  } else {
    {
#line 61
    _glp_lib_xassert("size > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     61);
#line 61
    tmp = 1;
    }
  }
#line 62
  if (gmp_size < size) {
#line 63
    if (gmp_size == 0) {
#line 64
      if ((unsigned long )gmp_work == (unsigned long )((void *)0)) {
#line 64
        tmp___0 = 1;
      } else {
        {
#line 64
        _glp_lib_xassert("gmp_work == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         64);
#line 64
        tmp___0 = 1;
        }
      }
#line 65
      gmp_size = 100;
    } else {
#line 68
      if ((unsigned long )gmp_work != (unsigned long )((void *)0)) {
#line 68
        tmp___1 = 1;
      } else {
        {
#line 68
        _glp_lib_xassert("gmp_work != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         68);
#line 68
        tmp___1 = 1;
        }
      }
      {
#line 69
      _glp_lib_xfree((void *)gmp_work);
      }
    }
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if (! (gmp_size < size)) {
#line 71
        goto while_break;
      }
#line 71
      gmp_size += gmp_size;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 72
    tmp___2 = _glp_lib_xcalloc(gmp_size, (int )sizeof(unsigned short ));
#line 72
    gmp_work = (unsigned short *)tmp___2;
    }
  }
#line 74
  return (gmp_work);
}
}
#line 77 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_gmp_free_mem(void) 
{ 


  {
#line 78
  if ((unsigned long )gmp_pool != (unsigned long )((void *)0)) {
    {
#line 78
    _glp_dmp_delete_pool(gmp_pool);
    }
  }
#line 79
  if ((unsigned long )gmp_work != (unsigned long )((void *)0)) {
    {
#line 79
    _glp_lib_xfree((void *)gmp_work);
    }
  }
#line 80
  gmp_pool = (DMP *)((void *)0);
#line 81
  gmp_size = 0;
#line 82
  gmp_work = (unsigned short *)((void *)0);
#line 83
  return;
}
}
#line 88 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
mpz_t _glp_mpz_init(void) 
{ 
  mpz_t x ;
  void *tmp ;

  {
  {
#line 91
  tmp = _glp_gmp_get_atom((int )sizeof(struct mpz ));
#line 91
  x = (mpz_t )tmp;
#line 92
  x->val = 0;
#line 93
  x->ptr = (struct mpz_seg *)((void *)0);
  }
#line 94
  return (x);
}
}
#line 97 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_clear(mpz_t x ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 99
  _glp_mpz_set_si(x, 0);
  }
#line 100
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 100
    tmp = 1;
  } else {
    {
#line 100
    _glp_lib_xassert("x->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     100);
#line 100
    tmp = 1;
    }
  }
  {
#line 102
  _glp_gmp_free_atom((void *)x, (int )sizeof(struct mpz ));
  }
#line 103
  return;
}
}
#line 106 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_set(mpz_t z , mpz_t x ) 
{ 
  struct mpz_seg *e ;
  struct mpz_seg *ee ;
  struct mpz_seg *es ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 109
  if ((unsigned long )z != (unsigned long )x) {
    {
#line 110
    _glp_mpz_set_si(z, 0);
#line 111
    z->val = x->val;
    }
#line 112
    if ((unsigned long )z->ptr == (unsigned long )((void *)0)) {
#line 112
      tmp = 1;
    } else {
      {
#line 112
      _glp_lib_xassert("z->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       112);
#line 112
      tmp = 1;
      }
    }
#line 113
    e = x->ptr;
#line 113
    es = (struct mpz_seg *)((void *)0);
    {
#line 113
    while (1) {
      while_continue: /* CIL Label */ ;
#line 113
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 113
        goto while_break;
      }
      {
#line 114
      tmp___0 = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 114
      ee = (struct mpz_seg *)tmp___0;
#line 115
      memcpy((void */* __restrict  */)(ee->d), (void const   */* __restrict  */)(e->d),
             (size_t )12);
#line 116
      ee->next = (struct mpz_seg *)((void *)0);
      }
#line 117
      if ((unsigned long )z->ptr == (unsigned long )((void *)0)) {
#line 118
        z->ptr = ee;
      } else {
#line 120
        es->next = ee;
      }
#line 121
      es = ee;
#line 113
      e = e->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 124
  return;
}
}
#line 127 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_set_si(mpz_t x , int val ) 
{ 
  struct mpz_seg *e ;
  void *tmp ;

  {
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned long )x->ptr != (unsigned long )((void *)0))) {
#line 131
      goto while_break;
    }
    {
#line 132
    e = x->ptr;
#line 133
    x->ptr = e->next;
#line 134
    _glp_gmp_free_atom((void *)e, (int )sizeof(struct mpz_seg ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if ((unsigned int )val == 2147483648U) {
    {
#line 139
    x->val = -1;
#line 140
    tmp = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 140
    e = (struct mpz_seg *)tmp;
#line 140
    x->ptr = e;
#line 141
    memset((void *)(e->d), 0, (size_t )12);
#line 142
    e->d[1] = (unsigned short)32768;
#line 143
    e->next = (struct mpz_seg *)((void *)0);
    }
  } else {
#line 147
    x->val = val;
  }
#line 149
  return;
}
}
#line 152 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
double _glp_mpz_get_d(mpz_t x ) 
{ 
  struct mpz_seg *e ;
  int j ;
  double val ;
  double deg ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 157
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 158
    val = (double )x->val;
  } else {
#line 160
    if (x->val != 0) {
#line 160
      tmp = 1;
    } else {
      {
#line 160
      _glp_lib_xassert("x->val != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       160);
#line 160
      tmp = 1;
      }
    }
#line 161
    val = 0.0;
#line 162
    deg = 1.0;
#line 163
    e = x->ptr;
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 163
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 163
        goto while_break;
      }
#line 164
      j = 0;
      {
#line 164
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 164
        if (! (j <= 5)) {
#line 164
          goto while_break___0;
        }
#line 165
        val += deg * (double )((int )e->d[j]);
#line 166
        deg *= 65536.0;
#line 164
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 163
      e = e->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 169
    if (x->val < 0) {
#line 169
      val = - val;
    }
  }
#line 171
  return (val);
}
}
#line 174 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
double _glp_mpz_get_d_2exp(int *exp___0 , mpz_t x ) 
{ 
  struct mpz_seg *e ;
  int j ;
  int n ;
  int n1 ;
  double val ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 184
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 185
    val = (double )x->val;
#line 185
    n = 0;
  } else {
#line 187
    if (x->val != 0) {
#line 187
      tmp = 1;
    } else {
      {
#line 187
      _glp_lib_xassert("x->val != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       187);
#line 187
      tmp = 1;
      }
    }
#line 188
    val = 0.0;
#line 188
    n = 0;
#line 189
    e = x->ptr;
    {
#line 189
    while (1) {
      while_continue: /* CIL Label */ ;
#line 189
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 189
        goto while_break;
      }
#line 190
      j = 0;
      {
#line 190
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 190
        if (! (j <= 5)) {
#line 190
          goto while_break___0;
        }
#line 191
        val += (double )((int )e->d[j]);
#line 192
        val /= 65536.0;
#line 192
        n += 16;
#line 190
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      e = e->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 195
    if (x->val < 0) {
#line 195
      val = - val;
    }
  }
  {
#line 197
  val = frexp(val, & n1);
#line 198
  *exp___0 = n + n1;
  }
#line 199
  return (val);
}
}
#line 202 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_swap(mpz_t x , mpz_t y ) 
{ 
  int val ;
  void *ptr ;

  {
#line 206
  val = x->val;
#line 206
  ptr = (void *)x->ptr;
#line 207
  x->val = y->val;
#line 207
  x->ptr = y->ptr;
#line 208
  y->val = val;
#line 208
  y->ptr = (struct mpz_seg *)ptr;
#line 209
  return;
}
}
#line 212 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
static void normalize(mpz_t x ) 
{ 
  struct mpz_seg *es ;
  struct mpz_seg *e ;
  int tmp ;
  int tmp___0 ;
  int val ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 217
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 218
    if ((unsigned int )x->val != 2147483648U) {
#line 218
      tmp = 1;
    } else {
      {
#line 218
      _glp_lib_xassert("x->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       218);
#line 218
      tmp = 1;
      }
    }
#line 219
    goto done;
  }
#line 221
  if (x->val == 1) {
#line 221
    tmp___0 = 1;
  } else
#line 221
  if (x->val == -1) {
#line 221
    tmp___0 = 1;
  } else {
    {
#line 221
    _glp_lib_xassert("x->val == +1 || x->val == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     221);
#line 221
    tmp___0 = 1;
    }
  }
#line 223
  es = (struct mpz_seg *)((void *)0);
#line 224
  e = x->ptr;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 224
      goto while_break;
    }
#line 225
    if (e->d[0]) {
#line 226
      es = e;
    } else
#line 225
    if (e->d[1]) {
#line 226
      es = e;
    } else
#line 225
    if (e->d[2]) {
#line 226
      es = e;
    } else
#line 225
    if (e->d[3]) {
#line 226
      es = e;
    } else
#line 225
    if (e->d[4]) {
#line 226
      es = e;
    } else
#line 225
    if (e->d[5]) {
#line 226
      es = e;
    }
#line 224
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  if ((unsigned long )es == (unsigned long )((void *)0)) {
    {
#line 230
    _glp_mpz_set_si(x, 0);
    }
#line 231
    goto done;
  }
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 234
    if (! ((unsigned long )es->next != (unsigned long )((void *)0))) {
#line 234
      goto while_break___0;
    }
    {
#line 235
    e = es->next;
#line 236
    es->next = e->next;
#line 237
    _glp_gmp_free_atom((void *)e, (int )sizeof(struct mpz_seg ));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 240
  e = x->ptr;
#line 241
  if ((unsigned long )e->next == (unsigned long )((void *)0)) {
#line 241
    if ((int )e->d[1] <= 32767) {
#line 241
      if (! e->d[2]) {
#line 241
        if (! e->d[3]) {
#line 241
          if (! e->d[4]) {
#line 241
            if (! e->d[5]) {
#line 244
              val = (int )e->d[0] + ((int )e->d[1] << 16);
#line 245
              if (x->val < 0) {
#line 245
                val = - val;
              }
              {
#line 246
              _glp_mpz_set_si(x, val);
              }
            }
          }
        }
      }
    }
  }
  done: 
#line 248
  return;
}
}
#line 253 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
static struct mpz_seg zero  =    {{(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0}, (struct mpz_seg *)((void *)0)};
#line 251 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_add(mpz_t z , mpz_t x , mpz_t y ) 
{ 
  struct mpz_seg dumx ;
  struct mpz_seg dumy ;
  struct mpz_seg *ex ;
  struct mpz_seg *ey ;
  struct mpz_seg *ez ;
  struct mpz_seg *es ;
  struct mpz_seg *ee ;
  int k ;
  int sx ;
  int sy ;
  int sz ;
  unsigned int t ;
  int tmp ;
  int tmp___0 ;
  int xval ;
  int yval ;
  int zval ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short tmp___9 ;
  unsigned short tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  unsigned short tmp___14 ;
  unsigned short tmp___15 ;
  unsigned short tmp___16 ;
  unsigned short tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
#line 258
  if (x->val == 0) {
#line 259
    if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 259
      tmp = 1;
    } else {
      {
#line 259
      _glp_lib_xassert("x->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       259);
#line 259
      tmp = 1;
      }
    }
    {
#line 260
    _glp_mpz_set(z, y);
    }
#line 261
    goto done;
  }
#line 264
  if (y->val == 0) {
#line 265
    if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 265
      tmp___0 = 1;
    } else {
      {
#line 265
      _glp_lib_xassert("y->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       265);
#line 265
      tmp___0 = 1;
      }
    }
    {
#line 266
    _glp_mpz_set(z, x);
    }
#line 267
    goto done;
  }
#line 270
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 270
    if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 271
      xval = x->val;
#line 271
      yval = y->val;
#line 271
      zval = x->val + y->val;
#line 272
      if ((unsigned int )xval != 2147483648U) {
#line 272
        if ((unsigned int )yval != 2147483648U) {
#line 272
          tmp___1 = 1;
        } else {
          {
#line 272
          _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                           272);
#line 272
          tmp___1 = 1;
          }
        }
      } else {
        {
#line 272
        _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         272);
#line 272
        tmp___1 = 1;
        }
      }
#line 273
      if (xval > 0) {
#line 273
        if (yval > 0) {
#line 273
          if (! (zval <= 0)) {
#line 273
            goto _L___0;
          }
        } else {
#line 273
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 273
      if (xval < 0) {
#line 273
        if (yval < 0) {
#line 273
          if (! (zval >= 0)) {
            {
#line 275
            _glp_mpz_set_si(z, zval);
            }
#line 276
            goto done;
          }
        } else {
          {
#line 275
          _glp_mpz_set_si(z, zval);
          }
#line 276
          goto done;
        }
      } else {
        {
#line 275
        _glp_mpz_set_si(z, zval);
        }
#line 276
        goto done;
      }
    }
  }
#line 280
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 281
    if ((unsigned int )x->val != 2147483648U) {
#line 281
      tmp___2 = 1;
    } else {
      {
#line 281
      _glp_lib_xassert("x->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       281);
#line 281
      tmp___2 = 1;
      }
    }
#line 282
    if (x->val >= 0) {
#line 283
      sx = 1;
#line 284
      t = (unsigned int )x->val;
    } else {
#line 287
      sx = -1;
#line 288
      t = (unsigned int )(- x->val);
    }
#line 290
    ex = & dumx;
#line 291
    ex->d[0] = (unsigned short )t;
#line 292
    ex->d[1] = (unsigned short )(t >> 16);
#line 293
    tmp___5 = (unsigned short)0;
#line 293
    ex->d[5] = tmp___5;
#line 293
    tmp___4 = tmp___5;
#line 293
    ex->d[4] = tmp___4;
#line 293
    tmp___3 = tmp___4;
#line 293
    ex->d[3] = tmp___3;
#line 293
    ex->d[2] = tmp___3;
#line 294
    ex->next = (struct mpz_seg *)((void *)0);
  } else {
#line 297
    sx = x->val;
#line 298
    if (sx == 1) {
#line 298
      tmp___6 = 1;
    } else
#line 298
    if (sx == -1) {
#line 298
      tmp___6 = 1;
    } else {
      {
#line 298
      _glp_lib_xassert("sx == +1 || sx == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       298);
#line 298
      tmp___6 = 1;
      }
    }
#line 299
    ex = x->ptr;
  }
#line 302
  if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 303
    if ((unsigned int )y->val != 2147483648U) {
#line 303
      tmp___7 = 1;
    } else {
      {
#line 303
      _glp_lib_xassert("y->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       303);
#line 303
      tmp___7 = 1;
      }
    }
#line 304
    if (y->val >= 0) {
#line 305
      sy = 1;
#line 306
      t = (unsigned int )y->val;
    } else {
#line 309
      sy = -1;
#line 310
      t = (unsigned int )(- y->val);
    }
#line 312
    ey = & dumy;
#line 313
    ey->d[0] = (unsigned short )t;
#line 314
    ey->d[1] = (unsigned short )(t >> 16);
#line 315
    tmp___10 = (unsigned short)0;
#line 315
    ey->d[5] = tmp___10;
#line 315
    tmp___9 = tmp___10;
#line 315
    ey->d[4] = tmp___9;
#line 315
    tmp___8 = tmp___9;
#line 315
    ey->d[3] = tmp___8;
#line 315
    ey->d[2] = tmp___8;
#line 316
    ey->next = (struct mpz_seg *)((void *)0);
  } else {
#line 319
    sy = y->val;
#line 320
    if (sy == 1) {
#line 320
      tmp___11 = 1;
    } else
#line 320
    if (sy == -1) {
#line 320
      tmp___11 = 1;
    } else {
      {
#line 320
      _glp_lib_xassert("sy == +1 || sy == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       320);
#line 320
      tmp___11 = 1;
      }
    }
#line 321
    ey = y->ptr;
  }
#line 324
  sz = sx;
#line 325
  es = (struct mpz_seg *)((void *)0);
#line 325
  ez = es;
#line 326
  if (sx > 0) {
#line 326
    if (sy > 0) {
#line 326
      goto _L___1;
    } else {
#line 326
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 326
  if (sx < 0) {
#line 326
    if (sy < 0) {
      _L___1: /* CIL Label */ 
#line 328
      t = 0U;
      {
#line 329
      while (1) {
        while_continue: /* CIL Label */ ;
#line 329
        if (! ex) {
#line 329
          if (! ey) {
#line 329
            goto while_break;
          }
        }
#line 330
        if ((unsigned long )ex == (unsigned long )((void *)0)) {
#line 330
          ex = & zero;
        }
#line 331
        if ((unsigned long )ey == (unsigned long )((void *)0)) {
#line 331
          ey = & zero;
        }
        {
#line 332
        tmp___12 = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 332
        ee = (struct mpz_seg *)tmp___12;
#line 333
        k = 0;
        }
        {
#line 333
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 333
          if (! (k <= 5)) {
#line 333
            goto while_break___0;
          }
#line 334
          t += (unsigned int )ex->d[k];
#line 335
          t += (unsigned int )ey->d[k];
#line 336
          ee->d[k] = (unsigned short )t;
#line 337
          t >>= 16;
#line 333
          k ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 339
        ee->next = (struct mpz_seg *)((void *)0);
#line 340
        if ((unsigned long )ez == (unsigned long )((void *)0)) {
#line 341
          ez = ee;
        } else {
#line 343
          es->next = ee;
        }
#line 344
        es = ee;
#line 329
        ex = ex->next;
#line 329
        ey = ey->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 346
      if (t) {
        {
#line 348
        tmp___13 = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 348
        ee = (struct mpz_seg *)tmp___13;
#line 349
        ee->d[0] = (unsigned short)1;
#line 350
        tmp___17 = (unsigned short)0;
#line 350
        ee->d[5] = tmp___17;
#line 350
        tmp___16 = tmp___17;
#line 350
        ee->d[4] = tmp___16;
#line 350
        tmp___15 = tmp___16;
#line 350
        ee->d[3] = tmp___15;
#line 350
        tmp___14 = tmp___15;
#line 350
        ee->d[2] = tmp___14;
#line 350
        ee->d[1] = tmp___14;
#line 351
        ee->next = (struct mpz_seg *)((void *)0);
        }
#line 352
        if ((unsigned long )es != (unsigned long )((void *)0)) {
#line 352
          tmp___18 = 1;
        } else {
          {
#line 352
          _glp_lib_xassert("es != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                           352);
#line 352
          tmp___18 = 1;
          }
        }
#line 353
        es->next = ee;
      }
    } else {
#line 326
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 358
    t = 1U;
    {
#line 359
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 359
      if (! ex) {
#line 359
        if (! ey) {
#line 359
          goto while_break___1;
        }
      }
#line 360
      if ((unsigned long )ex == (unsigned long )((void *)0)) {
#line 360
        ex = & zero;
      }
#line 361
      if ((unsigned long )ey == (unsigned long )((void *)0)) {
#line 361
        ey = & zero;
      }
      {
#line 362
      tmp___19 = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 362
      ee = (struct mpz_seg *)tmp___19;
#line 363
      k = 0;
      }
      {
#line 363
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 363
        if (! (k <= 5)) {
#line 363
          goto while_break___2;
        }
#line 364
        t += (unsigned int )ex->d[k];
#line 365
        t += 65535U - (unsigned int )ey->d[k];
#line 366
        ee->d[k] = (unsigned short )t;
#line 367
        t >>= 16;
#line 363
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 369
      ee->next = (struct mpz_seg *)((void *)0);
#line 370
      if ((unsigned long )ez == (unsigned long )((void *)0)) {
#line 371
        ez = ee;
      } else {
#line 373
        es->next = ee;
      }
#line 374
      es = ee;
#line 359
      ex = ex->next;
#line 359
      ey = ey->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 376
    if (! t) {
#line 378
      sz = - sz;
#line 379
      t = 1U;
#line 380
      ee = ez;
      {
#line 380
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 380
        if (! ((unsigned long )ee != (unsigned long )((void *)0))) {
#line 380
          goto while_break___3;
        }
#line 381
        k = 0;
        {
#line 381
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 381
          if (! (k <= 5)) {
#line 381
            goto while_break___4;
          }
#line 382
          t += 65535U - (unsigned int )ee->d[k];
#line 383
          ee->d[k] = (unsigned short )t;
#line 384
          t >>= 16;
#line 381
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 380
        ee = ee->next;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  {
#line 389
  _glp_mpz_set_si(z, 0);
#line 390
  z->val = sz;
#line 391
  z->ptr = ez;
#line 392
  normalize(z);
  }
  done: 
#line 393
  return;
}
}
#line 396 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_sub(mpz_t z , mpz_t x , mpz_t y ) 
{ 


  {
#line 398
  if ((unsigned long )x == (unsigned long )y) {
    {
#line 399
    _glp_mpz_set_si(z, 0);
    }
  } else {
    {
#line 401
    y->val = - y->val;
#line 402
    _glp_mpz_add(z, x, y);
    }
#line 403
    if ((unsigned long )y != (unsigned long )z) {
#line 403
      y->val = - y->val;
    }
  }
#line 405
  return;
}
}
#line 408 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_mul(mpz_t z , mpz_t x , mpz_t y ) 
{ 
  struct mpz_seg dumx ;
  struct mpz_seg dumy ;
  struct mpz_seg *ex ;
  struct mpz_seg *ey ;
  struct mpz_seg *es ;
  struct mpz_seg *e ;
  int sx ;
  int sy ;
  int k ;
  int nx ;
  int ny ;
  int n ;
  unsigned int t ;
  unsigned short *work ;
  unsigned short *wx ;
  unsigned short *wy ;
  int tmp ;
  int tmp___0 ;
  int xval ;
  int yval ;
  int sz ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short tmp___9 ;
  unsigned short tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  unsigned short tmp___15 ;
  unsigned short tmp___16 ;
  unsigned short tmp___17 ;
  unsigned short tmp___18 ;
  int tmp___19 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
#line 415
  if (x->val == 0) {
#line 416
    if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 416
      tmp = 1;
    } else {
      {
#line 416
      _glp_lib_xassert("x->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       416);
#line 416
      tmp = 1;
      }
    }
    {
#line 417
    _glp_mpz_set_si(z, 0);
    }
#line 418
    goto done;
  }
#line 421
  if (y->val == 0) {
#line 422
    if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 422
      tmp___0 = 1;
    } else {
      {
#line 422
      _glp_lib_xassert("y->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       422);
#line 422
      tmp___0 = 1;
      }
    }
    {
#line 423
    _glp_mpz_set_si(z, 0);
    }
#line 424
    goto done;
  }
#line 427
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 427
    if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 428
      xval = x->val;
#line 428
      yval = y->val;
#line 428
      sz = 1;
#line 429
      if ((unsigned int )xval != 2147483648U) {
#line 429
        if ((unsigned int )yval != 2147483648U) {
#line 429
          tmp___1 = 1;
        } else {
          {
#line 429
          _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                           429);
#line 429
          tmp___1 = 1;
          }
        }
      } else {
        {
#line 429
        _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         429);
#line 429
        tmp___1 = 1;
        }
      }
#line 430
      if (xval < 0) {
#line 430
        xval = - xval;
#line 430
        sz = - sz;
      }
#line 431
      if (yval < 0) {
#line 431
        yval = - yval;
#line 431
        sz = - sz;
      }
#line 432
      if (xval <= 2147483647 / yval) {
        {
#line 433
        _glp_mpz_set_si(z, sz * (xval * yval));
        }
#line 434
        goto done;
      }
    }
  }
#line 438
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 439
    if ((unsigned int )x->val != 2147483648U) {
#line 439
      tmp___2 = 1;
    } else {
      {
#line 439
      _glp_lib_xassert("x->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       439);
#line 439
      tmp___2 = 1;
      }
    }
#line 440
    if (x->val >= 0) {
#line 441
      sx = 1;
#line 442
      t = (unsigned int )x->val;
    } else {
#line 445
      sx = -1;
#line 446
      t = (unsigned int )(- x->val);
    }
#line 448
    ex = & dumx;
#line 449
    ex->d[0] = (unsigned short )t;
#line 450
    ex->d[1] = (unsigned short )(t >> 16);
#line 451
    tmp___5 = (unsigned short)0;
#line 451
    ex->d[5] = tmp___5;
#line 451
    tmp___4 = tmp___5;
#line 451
    ex->d[4] = tmp___4;
#line 451
    tmp___3 = tmp___4;
#line 451
    ex->d[3] = tmp___3;
#line 451
    ex->d[2] = tmp___3;
#line 452
    ex->next = (struct mpz_seg *)((void *)0);
  } else {
#line 455
    sx = x->val;
#line 456
    if (sx == 1) {
#line 456
      tmp___6 = 1;
    } else
#line 456
    if (sx == -1) {
#line 456
      tmp___6 = 1;
    } else {
      {
#line 456
      _glp_lib_xassert("sx == +1 || sx == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       456);
#line 456
      tmp___6 = 1;
      }
    }
#line 457
    ex = x->ptr;
  }
#line 460
  if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 461
    if ((unsigned int )y->val != 2147483648U) {
#line 461
      tmp___7 = 1;
    } else {
      {
#line 461
      _glp_lib_xassert("y->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       461);
#line 461
      tmp___7 = 1;
      }
    }
#line 462
    if (y->val >= 0) {
#line 463
      sy = 1;
#line 464
      t = (unsigned int )y->val;
    } else {
#line 467
      sy = -1;
#line 468
      t = (unsigned int )(- y->val);
    }
#line 470
    ey = & dumy;
#line 471
    ey->d[0] = (unsigned short )t;
#line 472
    ey->d[1] = (unsigned short )(t >> 16);
#line 473
    tmp___10 = (unsigned short)0;
#line 473
    ey->d[5] = tmp___10;
#line 473
    tmp___9 = tmp___10;
#line 473
    ey->d[4] = tmp___9;
#line 473
    tmp___8 = tmp___9;
#line 473
    ey->d[3] = tmp___8;
#line 473
    ey->d[2] = tmp___8;
#line 474
    ey->next = (struct mpz_seg *)((void *)0);
  } else {
#line 477
    sy = y->val;
#line 478
    if (sy == 1) {
#line 478
      tmp___11 = 1;
    } else
#line 478
    if (sy == -1) {
#line 478
      tmp___11 = 1;
    } else {
      {
#line 478
      _glp_lib_xassert("sy == +1 || sy == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       478);
#line 478
      tmp___11 = 1;
      }
    }
#line 479
    ey = y->ptr;
  }
#line 482
  n = 0;
#line 482
  nx = n;
#line 483
  e = ex;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 483
      goto while_break;
    }
#line 484
    k = 0;
    {
#line 484
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 484
      if (! (k <= 5)) {
#line 484
        goto while_break___0;
      }
#line 485
      n ++;
#line 486
      if (e->d[k]) {
#line 486
        nx = n;
      }
#line 484
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 483
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  if (nx > 0) {
#line 488
    tmp___12 = 1;
  } else {
    {
#line 488
    _glp_lib_xassert("nx > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 488);
#line 488
    tmp___12 = 1;
    }
  }
#line 490
  n = 0;
#line 490
  ny = n;
#line 491
  e = ey;
  {
#line 491
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 491
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 491
      goto while_break___1;
    }
#line 492
    k = 0;
    {
#line 492
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 492
      if (! (k <= 5)) {
#line 492
        goto while_break___2;
      }
#line 493
      n ++;
#line 494
      if (e->d[k]) {
#line 494
        ny = n;
      }
#line 492
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 491
    e = e->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 496
  if (ny > 0) {
#line 496
    tmp___13 = 1;
  } else {
    {
#line 496
    _glp_lib_xassert("ny > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 496);
#line 496
    tmp___13 = 1;
    }
  }
  {
#line 498
  work = _glp_gmp_get_work((nx + ny) + ny);
#line 500
  wx = work + 0;
#line 501
  n = 0;
  }
  {
#line 501
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 501
    if (! (n < nx)) {
#line 501
      goto while_break___3;
    }
#line 501
    *(wx + (ny + n)) = (unsigned short)0;
#line 501
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 502
  n = 0;
#line 502
  e = ex;
  {
#line 502
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 502
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 502
      goto while_break___4;
    }
#line 503
    k = 0;
    {
#line 503
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 503
      if (! (k <= 5)) {
#line 503
        goto while_break___5;
      }
#line 504
      if (e->d[k]) {
#line 504
        *(wx + (ny + n)) = e->d[k];
      }
#line 503
      k ++;
#line 503
      n ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 502
    e = e->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 506
  wy = work + (nx + ny);
#line 507
  n = 0;
  {
#line 507
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 507
    if (! (n < ny)) {
#line 507
      goto while_break___6;
    }
#line 507
    *(wy + n) = (unsigned short)0;
#line 507
    n ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 508
  n = 0;
#line 508
  e = ey;
  {
#line 508
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 508
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 508
      goto while_break___7;
    }
#line 509
    k = 0;
    {
#line 509
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 509
      if (! (k <= 5)) {
#line 509
        goto while_break___8;
      }
#line 510
      if (e->d[k]) {
#line 510
        *(wy + n) = e->d[k];
      }
#line 509
      k ++;
#line 509
      n ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 508
    e = e->next;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 512
  _glp_lib_bigmul(nx, ny, wx, wy);
#line 514
  _glp_mpz_set_si(z, 0);
#line 515
  z->val = sx * sy;
#line 516
  es = (struct mpz_seg *)((void *)0);
#line 517
  k = 6;
#line 518
  n = 0;
  }
  {
#line 518
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 518
    if (! (n < nx + ny)) {
#line 518
      goto while_break___9;
    }
#line 519
    if (k > 5) {
      {
#line 520
      tmp___14 = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 520
      e = (struct mpz_seg *)tmp___14;
#line 521
      tmp___16 = (unsigned short)0;
#line 521
      e->d[2] = tmp___16;
#line 521
      tmp___15 = tmp___16;
#line 521
      e->d[1] = tmp___15;
#line 521
      e->d[0] = tmp___15;
#line 522
      tmp___18 = (unsigned short)0;
#line 522
      e->d[5] = tmp___18;
#line 522
      tmp___17 = tmp___18;
#line 522
      e->d[4] = tmp___17;
#line 522
      e->d[3] = tmp___17;
#line 523
      e->next = (struct mpz_seg *)((void *)0);
      }
#line 524
      if ((unsigned long )z->ptr == (unsigned long )((void *)0)) {
#line 525
        z->ptr = e;
      } else {
#line 527
        es->next = e;
      }
#line 528
      es = e;
#line 529
      k = 0;
    }
#line 531
    tmp___19 = k;
#line 531
    k ++;
#line 531
    es->d[tmp___19] = *(wx + n);
#line 518
    n ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 533
  normalize(z);
  }
  done: 
#line 534
  return;
}
}
#line 537 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_neg(mpz_t z , mpz_t x ) 
{ 


  {
  {
#line 539
  _glp_mpz_set(z, x);
#line 540
  z->val = - z->val;
  }
#line 541
  return;
}
}
#line 544 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_abs(mpz_t z , mpz_t x ) 
{ 


  {
  {
#line 546
  _glp_mpz_set(z, x);
  }
#line 547
  if (z->val < 0) {
#line 547
    z->val = - z->val;
  }
#line 548
  return;
}
}
#line 551 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_div(mpz_t q , mpz_t r , mpz_t x , mpz_t y ) 
{ 
  struct mpz_seg dumx ;
  struct mpz_seg dumy ;
  struct mpz_seg *ex ;
  struct mpz_seg *ey ;
  struct mpz_seg *es ;
  struct mpz_seg *e ;
  int sx ;
  int sy ;
  int k ;
  int nx ;
  int ny ;
  int n ;
  unsigned int t ;
  unsigned short *work ;
  unsigned short *wx ;
  unsigned short *wy ;
  int tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  int xval ;
  int yval ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned short tmp___9 ;
  unsigned short tmp___10 ;
  unsigned short tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  unsigned short tmp___17 ;
  unsigned short tmp___18 ;
  unsigned short tmp___19 ;
  unsigned short tmp___20 ;
  int tmp___21 ;
  void *tmp___22 ;
  unsigned short tmp___23 ;
  unsigned short tmp___24 ;
  unsigned short tmp___25 ;
  unsigned short tmp___26 ;
  int tmp___27 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
#line 566
  if (y->val == 0) {
#line 567
    if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 567
      tmp = 1;
    } else {
      {
#line 567
      _glp_lib_xassert("y->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       567);
#line 567
      tmp = 1;
      }
    }
    {
#line 568
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 568);
#line 568
    (*tmp___0)("mpz_div: divide by zero not allowed\n");
    }
  }
#line 571
  if (x->val == 0) {
#line 572
    if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 572
      tmp___1 = 1;
    } else {
      {
#line 572
      _glp_lib_xassert("x->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       572);
#line 572
      tmp___1 = 1;
      }
    }
#line 573
    if ((unsigned long )q != (unsigned long )((void *)0)) {
      {
#line 573
      _glp_mpz_set_si(q, 0);
      }
    }
#line 574
    if ((unsigned long )r != (unsigned long )((void *)0)) {
      {
#line 574
      _glp_mpz_set_si(r, 0);
      }
    }
#line 575
    goto done;
  }
#line 578
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 578
    if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 579
      xval = x->val;
#line 579
      yval = y->val;
#line 580
      if ((unsigned int )xval != 2147483648U) {
#line 580
        if ((unsigned int )yval != 2147483648U) {
#line 580
          tmp___2 = 1;
        } else {
          {
#line 580
          _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                           580);
#line 580
          tmp___2 = 1;
          }
        }
      } else {
        {
#line 580
        _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         580);
#line 580
        tmp___2 = 1;
        }
      }
#line 581
      if ((unsigned long )q != (unsigned long )((void *)0)) {
        {
#line 581
        _glp_mpz_set_si(q, xval / yval);
        }
      }
#line 582
      if ((unsigned long )r != (unsigned long )((void *)0)) {
        {
#line 582
        _glp_mpz_set_si(r, xval % yval);
        }
      }
#line 583
      goto done;
    }
  }
#line 586
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 587
    if ((unsigned int )x->val != 2147483648U) {
#line 587
      tmp___3 = 1;
    } else {
      {
#line 587
      _glp_lib_xassert("x->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       587);
#line 587
      tmp___3 = 1;
      }
    }
#line 588
    if (x->val >= 0) {
#line 589
      sx = 1;
#line 590
      t = (unsigned int )x->val;
    } else {
#line 593
      sx = -1;
#line 594
      t = (unsigned int )(- x->val);
    }
#line 596
    ex = & dumx;
#line 597
    ex->d[0] = (unsigned short )t;
#line 598
    ex->d[1] = (unsigned short )(t >> 16);
#line 599
    tmp___6 = (unsigned short)0;
#line 599
    ex->d[5] = tmp___6;
#line 599
    tmp___5 = tmp___6;
#line 599
    ex->d[4] = tmp___5;
#line 599
    tmp___4 = tmp___5;
#line 599
    ex->d[3] = tmp___4;
#line 599
    ex->d[2] = tmp___4;
#line 600
    ex->next = (struct mpz_seg *)((void *)0);
  } else {
#line 603
    sx = x->val;
#line 604
    if (sx == 1) {
#line 604
      tmp___7 = 1;
    } else
#line 604
    if (sx == -1) {
#line 604
      tmp___7 = 1;
    } else {
      {
#line 604
      _glp_lib_xassert("sx == +1 || sx == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       604);
#line 604
      tmp___7 = 1;
      }
    }
#line 605
    ex = x->ptr;
  }
#line 608
  if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 609
    if ((unsigned int )y->val != 2147483648U) {
#line 609
      tmp___8 = 1;
    } else {
      {
#line 609
      _glp_lib_xassert("y->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       609);
#line 609
      tmp___8 = 1;
      }
    }
#line 610
    if (y->val >= 0) {
#line 611
      sy = 1;
#line 612
      t = (unsigned int )y->val;
    } else {
#line 615
      sy = -1;
#line 616
      t = (unsigned int )(- y->val);
    }
#line 618
    ey = & dumy;
#line 619
    ey->d[0] = (unsigned short )t;
#line 620
    ey->d[1] = (unsigned short )(t >> 16);
#line 621
    tmp___11 = (unsigned short)0;
#line 621
    ey->d[5] = tmp___11;
#line 621
    tmp___10 = tmp___11;
#line 621
    ey->d[4] = tmp___10;
#line 621
    tmp___9 = tmp___10;
#line 621
    ey->d[3] = tmp___9;
#line 621
    ey->d[2] = tmp___9;
#line 622
    ey->next = (struct mpz_seg *)((void *)0);
  } else {
#line 625
    sy = y->val;
#line 626
    if (sy == 1) {
#line 626
      tmp___12 = 1;
    } else
#line 626
    if (sy == -1) {
#line 626
      tmp___12 = 1;
    } else {
      {
#line 626
      _glp_lib_xassert("sy == +1 || sy == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       626);
#line 626
      tmp___12 = 1;
      }
    }
#line 627
    ey = y->ptr;
  }
#line 630
  n = 0;
#line 630
  nx = n;
#line 631
  e = ex;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 631
      goto while_break;
    }
#line 632
    k = 0;
    {
#line 632
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 632
      if (! (k <= 5)) {
#line 632
        goto while_break___0;
      }
#line 633
      n ++;
#line 634
      if (e->d[k]) {
#line 634
        nx = n;
      }
#line 632
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  if (nx > 0) {
#line 636
    tmp___13 = 1;
  } else {
    {
#line 636
    _glp_lib_xassert("nx > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 636);
#line 636
    tmp___13 = 1;
    }
  }
#line 638
  n = 0;
#line 638
  ny = n;
#line 639
  e = ey;
  {
#line 639
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 639
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 639
      goto while_break___1;
    }
#line 640
    k = 0;
    {
#line 640
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 640
      if (! (k <= 5)) {
#line 640
        goto while_break___2;
      }
#line 641
      n ++;
#line 642
      if (e->d[k]) {
#line 642
        ny = n;
      }
#line 640
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 639
    e = e->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 644
  if (ny > 0) {
#line 644
    tmp___14 = 1;
  } else {
    {
#line 644
    _glp_lib_xassert("ny > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 644);
#line 644
    tmp___14 = 1;
    }
  }
#line 646
  if (nx < ny) {
#line 647
    if ((unsigned long )r != (unsigned long )((void *)0)) {
      {
#line 647
      _glp_mpz_set(r, x);
      }
    }
#line 648
    if ((unsigned long )q != (unsigned long )((void *)0)) {
      {
#line 648
      _glp_mpz_set_si(q, 0);
      }
    }
#line 649
    goto done;
  }
  {
#line 652
  work = _glp_gmp_get_work((nx + ny) + 1);
#line 654
  wx = work + 0;
#line 655
  n = 0;
  }
  {
#line 655
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 655
    if (! (n < nx)) {
#line 655
      goto while_break___3;
    }
#line 655
    *(wx + n) = (unsigned short)0;
#line 655
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 656
  n = 0;
#line 656
  e = ex;
  {
#line 656
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 656
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 656
      goto while_break___4;
    }
#line 657
    k = 0;
    {
#line 657
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 657
      if (! (k <= 5)) {
#line 657
        goto while_break___5;
      }
#line 658
      if (e->d[k]) {
#line 658
        *(wx + n) = e->d[k];
      }
#line 657
      k ++;
#line 657
      n ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 656
    e = e->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 660
  wy = work + (nx + 1);
#line 661
  n = 0;
  {
#line 661
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 661
    if (! (n < ny)) {
#line 661
      goto while_break___6;
    }
#line 661
    *(wy + n) = (unsigned short)0;
#line 661
    n ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 662
  n = 0;
#line 662
  e = ey;
  {
#line 662
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 662
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 662
      goto while_break___7;
    }
#line 663
    k = 0;
    {
#line 663
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 663
      if (! (k <= 5)) {
#line 663
        goto while_break___8;
      }
#line 664
      if (e->d[k]) {
#line 664
        *(wy + n) = e->d[k];
      }
#line 663
      k ++;
#line 663
      n ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 662
    e = e->next;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 666
  if ((int )*(wy + (ny - 1)) != 0) {
#line 666
    tmp___15 = 1;
  } else {
    {
#line 666
    _glp_lib_xassert("wy[ny-1] != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     666);
#line 666
    tmp___15 = 1;
    }
  }
  {
#line 667
  _glp_lib_bigdiv(nx - ny, ny, wx, wy);
  }
#line 669
  if ((unsigned long )q != (unsigned long )((void *)0)) {
    {
#line 670
    _glp_mpz_set_si(q, 0);
#line 671
    q->val = sx * sy;
#line 672
    es = (struct mpz_seg *)((void *)0);
#line 673
    k = 6;
#line 674
    n = ny;
    }
    {
#line 674
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 674
      if (! (n <= nx)) {
#line 674
        goto while_break___9;
      }
#line 675
      if (k > 5) {
        {
#line 676
        tmp___16 = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 676
        e = (struct mpz_seg *)tmp___16;
#line 677
        tmp___18 = (unsigned short)0;
#line 677
        e->d[2] = tmp___18;
#line 677
        tmp___17 = tmp___18;
#line 677
        e->d[1] = tmp___17;
#line 677
        e->d[0] = tmp___17;
#line 678
        tmp___20 = (unsigned short)0;
#line 678
        e->d[5] = tmp___20;
#line 678
        tmp___19 = tmp___20;
#line 678
        e->d[4] = tmp___19;
#line 678
        e->d[3] = tmp___19;
#line 679
        e->next = (struct mpz_seg *)((void *)0);
        }
#line 680
        if ((unsigned long )q->ptr == (unsigned long )((void *)0)) {
#line 681
          q->ptr = e;
        } else {
#line 683
          es->next = e;
        }
#line 684
        es = e;
#line 685
        k = 0;
      }
#line 687
      tmp___21 = k;
#line 687
      k ++;
#line 687
      es->d[tmp___21] = *(wx + n);
#line 674
      n ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 689
    normalize(q);
    }
  }
#line 692
  if ((unsigned long )r != (unsigned long )((void *)0)) {
    {
#line 693
    _glp_mpz_set_si(r, 0);
#line 694
    r->val = sx;
#line 695
    es = (struct mpz_seg *)((void *)0);
#line 696
    k = 6;
#line 697
    n = 0;
    }
    {
#line 697
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 697
      if (! (n < ny)) {
#line 697
        goto while_break___10;
      }
#line 698
      if (k > 5) {
        {
#line 699
        tmp___22 = _glp_gmp_get_atom((int )sizeof(struct mpz_seg ));
#line 699
        e = (struct mpz_seg *)tmp___22;
#line 700
        tmp___24 = (unsigned short)0;
#line 700
        e->d[2] = tmp___24;
#line 700
        tmp___23 = tmp___24;
#line 700
        e->d[1] = tmp___23;
#line 700
        e->d[0] = tmp___23;
#line 701
        tmp___26 = (unsigned short)0;
#line 701
        e->d[5] = tmp___26;
#line 701
        tmp___25 = tmp___26;
#line 701
        e->d[4] = tmp___25;
#line 701
        e->d[3] = tmp___25;
#line 702
        e->next = (struct mpz_seg *)((void *)0);
        }
#line 703
        if ((unsigned long )r->ptr == (unsigned long )((void *)0)) {
#line 704
          r->ptr = e;
        } else {
#line 706
          es->next = e;
        }
#line 707
        es = e;
#line 708
        k = 0;
      }
#line 710
      tmp___27 = k;
#line 710
      k ++;
#line 710
      es->d[tmp___27] = *(wx + n);
#line 697
      n ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 712
    normalize(r);
    }
  }
  done: 
#line 714
  return;
}
}
#line 717 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpz_gcd(mpz_t z , mpz_t x , mpz_t y ) 
{ 
  mpz_t u ;
  mpz_t v ;
  mpz_t r ;
  int tmp ;

  {
  {
#line 722
  u = _glp_mpz_init();
#line 723
  v = _glp_mpz_init();
#line 724
  r = _glp_mpz_init();
#line 725
  _glp_mpz_abs(u, x);
#line 726
  _glp_mpz_abs(v, y);
  }
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 727
    tmp = _glp_mpz_sgn(v);
    }
#line 727
    if (! tmp) {
#line 727
      goto while_break;
    }
    {
#line 728
    _glp_mpz_div((mpz_t )((void *)0), r, u, v);
#line 729
    _glp_mpz_set(u, v);
#line 730
    _glp_mpz_set(v, r);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 732
  _glp_mpz_set(z, u);
#line 733
  _glp_mpz_clear(u);
#line 734
  _glp_mpz_clear(v);
#line 735
  _glp_mpz_clear(r);
  }
#line 736
  return;
}
}
#line 742 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
static struct mpz_seg zero___0  =    {{(unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0}, (struct mpz_seg *)((void *)0)};
#line 739 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
int _glp_mpz_cmp(mpz_t x , mpz_t y ) 
{ 
  struct mpz_seg dumx ;
  struct mpz_seg dumy ;
  struct mpz_seg *ex ;
  struct mpz_seg *ey ;
  int cc ;
  int sx ;
  int sy ;
  int k ;
  unsigned int t ;
  int xval ;
  int yval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 746
  if ((unsigned long )x == (unsigned long )y) {
#line 747
    cc = 0;
#line 748
    goto done;
  }
#line 751
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 751
    if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 752
      xval = x->val;
#line 752
      yval = y->val;
#line 753
      if ((unsigned int )xval != 2147483648U) {
#line 753
        if ((unsigned int )yval != 2147483648U) {
#line 753
          tmp = 1;
        } else {
          {
#line 753
          _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                           753);
#line 753
          tmp = 1;
          }
        }
      } else {
        {
#line 753
        _glp_lib_xassert("xval != 0x80000000 && yval != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         753);
#line 753
        tmp = 1;
        }
      }
#line 754
      if (xval > yval) {
#line 754
        cc = 1;
      } else {
#line 754
        if (xval < yval) {
#line 754
          tmp___0 = -1;
        } else {
#line 754
          tmp___0 = 0;
        }
#line 754
        cc = tmp___0;
      }
#line 755
      goto done;
    }
  }
#line 758
  if (x->val > 0) {
#line 758
    if (y->val <= 0) {
#line 759
      cc = 1;
#line 760
      goto done;
    } else {
#line 758
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 758
  if (x->val == 0) {
#line 758
    if (y->val < 0) {
#line 759
      cc = 1;
#line 760
      goto done;
    }
  }
#line 762
  if (x->val < 0) {
#line 762
    if (y->val >= 0) {
#line 763
      cc = -1;
#line 764
      goto done;
    } else {
#line 762
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 762
  if (x->val == 0) {
#line 762
    if (y->val > 0) {
#line 763
      cc = -1;
#line 764
      goto done;
    }
  }
#line 767
  if ((unsigned long )x->ptr == (unsigned long )((void *)0)) {
#line 768
    if ((unsigned int )x->val != 2147483648U) {
#line 768
      tmp___1 = 1;
    } else {
      {
#line 768
      _glp_lib_xassert("x->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       768);
#line 768
      tmp___1 = 1;
      }
    }
#line 769
    if (x->val >= 0) {
#line 770
      sx = 1;
#line 771
      t = (unsigned int )x->val;
    } else {
#line 774
      sx = -1;
#line 775
      t = (unsigned int )(- x->val);
    }
#line 777
    ex = & dumx;
#line 778
    ex->d[0] = (unsigned short )t;
#line 779
    ex->d[1] = (unsigned short )(t >> 16);
#line 780
    tmp___4 = (unsigned short)0;
#line 780
    ex->d[5] = tmp___4;
#line 780
    tmp___3 = tmp___4;
#line 780
    ex->d[4] = tmp___3;
#line 780
    tmp___2 = tmp___3;
#line 780
    ex->d[3] = tmp___2;
#line 780
    ex->d[2] = tmp___2;
#line 781
    ex->next = (struct mpz_seg *)((void *)0);
  } else {
#line 784
    sx = x->val;
#line 785
    if (sx == 1) {
#line 785
      tmp___5 = 1;
    } else
#line 785
    if (sx == -1) {
#line 785
      tmp___5 = 1;
    } else {
      {
#line 785
      _glp_lib_xassert("sx == +1 || sx == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       785);
#line 785
      tmp___5 = 1;
      }
    }
#line 786
    ex = x->ptr;
  }
#line 789
  if ((unsigned long )y->ptr == (unsigned long )((void *)0)) {
#line 790
    if ((unsigned int )y->val != 2147483648U) {
#line 790
      tmp___6 = 1;
    } else {
      {
#line 790
      _glp_lib_xassert("y->val != 0x80000000", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       790);
#line 790
      tmp___6 = 1;
      }
    }
#line 791
    if (y->val >= 0) {
#line 792
      sy = 1;
#line 793
      t = (unsigned int )y->val;
    } else {
#line 796
      sy = -1;
#line 797
      t = (unsigned int )(- y->val);
    }
#line 799
    ey = & dumy;
#line 800
    ey->d[0] = (unsigned short )t;
#line 801
    ey->d[1] = (unsigned short )(t >> 16);
#line 802
    tmp___9 = (unsigned short)0;
#line 802
    ey->d[5] = tmp___9;
#line 802
    tmp___8 = tmp___9;
#line 802
    ey->d[4] = tmp___8;
#line 802
    tmp___7 = tmp___8;
#line 802
    ey->d[3] = tmp___7;
#line 802
    ey->d[2] = tmp___7;
#line 803
    ey->next = (struct mpz_seg *)((void *)0);
  } else {
#line 806
    sy = y->val;
#line 807
    if (sy == 1) {
#line 807
      tmp___10 = 1;
    } else
#line 807
    if (sy == -1) {
#line 807
      tmp___10 = 1;
    } else {
      {
#line 807
      _glp_lib_xassert("sy == +1 || sy == -1", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       807);
#line 807
      tmp___10 = 1;
      }
    }
#line 808
    ey = y->ptr;
  }
#line 811
  if (sx > 0) {
#line 811
    if (sy > 0) {
#line 811
      tmp___11 = 1;
    } else {
#line 811
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 811
  if (sx < 0) {
#line 811
    if (sy < 0) {
#line 811
      tmp___11 = 1;
    } else {
      {
#line 811
      _glp_lib_xassert("sx > 0 && sy > 0 || sx < 0 && sy < 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       811);
#line 811
      tmp___11 = 1;
      }
    }
  } else {
    {
#line 811
    _glp_lib_xassert("sx > 0 && sy > 0 || sx < 0 && sy < 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     811);
#line 811
    tmp___11 = 1;
    }
  }
#line 812
  cc = 0;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! ex) {
#line 813
      if (! ey) {
#line 813
        goto while_break;
      }
    }
#line 814
    if ((unsigned long )ex == (unsigned long )((void *)0)) {
#line 814
      ex = & zero___0;
    }
#line 815
    if ((unsigned long )ey == (unsigned long )((void *)0)) {
#line 815
      ey = & zero___0;
    }
#line 816
    k = 0;
    {
#line 816
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 816
      if (! (k <= 5)) {
#line 816
        goto while_break___0;
      }
#line 817
      if ((int )ex->d[k] > (int )ey->d[k]) {
#line 817
        cc = 1;
      }
#line 818
      if ((int )ex->d[k] < (int )ey->d[k]) {
#line 818
        cc = -1;
      }
#line 816
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 813
    ex = ex->next;
#line 813
    ey = ey->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  if (sx < 0) {
#line 821
    cc = - cc;
  }
  done: 
#line 822
  return (cc);
}
}
#line 825 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
int _glp_mpz_sgn(mpz_t x ) 
{ 
  int s ;
  int tmp ;

  {
#line 828
  if (x->val > 0) {
#line 828
    s = 1;
  } else {
#line 828
    if (x->val < 0) {
#line 828
      tmp = -1;
    } else {
#line 828
      tmp = 0;
    }
#line 828
    s = tmp;
  }
#line 829
  return (s);
}
}
#line 841 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
static char *set  =    (char *)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
#line 832 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
int _glp_mpz_out_str(void *_fp , int base , mpz_t x ) 
{ 
  FILE *fp ;
  mpz_t b ;
  mpz_t y ;
  mpz_t r ;
  int n ;
  int j ;
  int nwr ;
  unsigned char *d___0 ;
  xerror_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 837
  fp = (FILE *)_fp;
#line 839
  nwr = 0;
#line 842
  if (2 <= base) {
#line 842
    if (! (base <= 36)) {
      {
#line 843
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 843);
#line 843
      (*tmp)("mpz_out_str: base = %d; invalid base\n", base);
      }
    }
  } else {
    {
#line 843
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 843);
#line 843
    (*tmp)("mpz_out_str: base = %d; invalid base\n", base);
    }
  }
  {
#line 844
  b = _glp_mpz_init();
#line 845
  _glp_mpz_set_si(b, base);
#line 846
  y = _glp_mpz_init();
#line 847
  r = _glp_mpz_init();
#line 849
  _glp_mpz_abs(y, x);
#line 850
  n = 0;
  }
  {
#line 850
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 850
    tmp___0 = _glp_mpz_sgn(y);
    }
#line 850
    if (! (tmp___0 != 0)) {
#line 850
      goto while_break;
    }
    {
#line 851
    _glp_mpz_div(y, (mpz_t )((void *)0), y, b);
#line 850
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 852
  if (n == 0) {
#line 852
    n = 1;
  }
  {
#line 854
  tmp___1 = _glp_lib_xmalloc(n);
#line 854
  d___0 = (unsigned char *)tmp___1;
#line 855
  _glp_mpz_abs(y, x);
#line 856
  j = 0;
  }
  {
#line 856
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 856
    if (! (j < n)) {
#line 856
      goto while_break___0;
    }
    {
#line 857
    _glp_mpz_div(y, r, y, b);
    }
#line 858
    if (0 <= r->val) {
#line 858
      if (r->val < base) {
#line 858
        if ((unsigned long )r->ptr == (unsigned long )((void *)0)) {
#line 858
          tmp___2 = 1;
        } else {
          {
#line 858
          _glp_lib_xassert("0 <= r->val && r->val < base && r->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                           858);
#line 858
          tmp___2 = 1;
          }
        }
      } else {
        {
#line 858
        _glp_lib_xassert("0 <= r->val && r->val < base && r->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         858);
#line 858
        tmp___2 = 1;
        }
      }
    } else {
      {
#line 858
      _glp_lib_xassert("0 <= r->val && r->val < base && r->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       858);
#line 858
      tmp___2 = 1;
      }
    }
#line 859
    *(d___0 + j) = (unsigned char )r->val;
#line 856
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 862
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 862
    fp = stdout;
  }
  {
#line 863
  tmp___3 = _glp_mpz_sgn(x);
  }
#line 863
  if (tmp___3 < 0) {
    {
#line 864
    fputc('-', fp);
#line 864
    nwr ++;
    }
  }
#line 865
  j = n - 1;
  {
#line 865
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 865
    if (! (j >= 0)) {
#line 865
      goto while_break___1;
    }
    {
#line 866
    fputc((int )*(set + *(d___0 + j)), fp);
#line 866
    nwr ++;
#line 865
    j --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 867
  tmp___4 = ferror(fp);
  }
#line 867
  if (tmp___4) {
#line 867
    nwr = 0;
  }
  {
#line 868
  _glp_mpz_clear(b);
#line 869
  _glp_mpz_clear(y);
#line 870
  _glp_mpz_clear(r);
#line 871
  _glp_lib_xfree((void *)d___0);
  }
#line 872
  return (nwr);
}
}
#line 877 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
mpq_t _glp_mpq_init(void) 
{ 
  mpq_t x ;
  void *tmp ;

  {
  {
#line 880
  tmp = _glp_gmp_get_atom((int )sizeof(struct mpq ));
#line 880
  x = (mpq_t )tmp;
#line 881
  x->p.val = 0;
#line 882
  x->p.ptr = (struct mpz_seg *)((void *)0);
#line 883
  x->q.val = 1;
#line 884
  x->q.ptr = (struct mpz_seg *)((void *)0);
  }
#line 885
  return (x);
}
}
#line 888 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_clear(mpq_t x ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 890
  _glp_mpz_set_si(& x->p, 0);
  }
#line 891
  if ((unsigned long )x->p.ptr == (unsigned long )((void *)0)) {
#line 891
    tmp = 1;
  } else {
    {
#line 891
    _glp_lib_xassert("x->p.ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     891);
#line 891
    tmp = 1;
    }
  }
  {
#line 892
  _glp_mpz_set_si(& x->q, 0);
  }
#line 893
  if ((unsigned long )x->q.ptr == (unsigned long )((void *)0)) {
#line 893
    tmp___0 = 1;
  } else {
    {
#line 893
    _glp_lib_xassert("x->q.ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     893);
#line 893
    tmp___0 = 1;
    }
  }
  {
#line 895
  _glp_gmp_free_atom((void *)x, (int )sizeof(struct mpq ));
  }
#line 896
  return;
}
}
#line 899 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_canonicalize(mpq_t x ) 
{ 
  mpz_t f ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 903
  if (x->q.val != 0) {
#line 903
    tmp = 1;
  } else {
    {
#line 903
    _glp_lib_xassert("x->q.val != 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     903);
#line 903
    tmp = 1;
    }
  }
#line 904
  if (x->q.val < 0) {
    {
#line 905
    _glp_mpz_neg(& x->p, & x->p);
#line 906
    _glp_mpz_neg(& x->q, & x->q);
    }
  }
  {
#line 908
  f = _glp_mpz_init();
#line 909
  _glp_mpz_gcd(f, & x->p, & x->q);
  }
#line 910
  if (f->val == 1) {
#line 910
    if (! ((unsigned long )f->ptr == (unsigned long )((void *)0))) {
      {
#line 911
      _glp_mpz_div(& x->p, (mpz_t )((void *)0), & x->p, f);
#line 912
      _glp_mpz_div(& x->q, (mpz_t )((void *)0), & x->q, f);
      }
    }
  } else {
    {
#line 911
    _glp_mpz_div(& x->p, (mpz_t )((void *)0), & x->p, f);
#line 912
    _glp_mpz_div(& x->q, (mpz_t )((void *)0), & x->q, f);
    }
  }
  {
#line 914
  _glp_mpz_clear(f);
  }
#line 915
  return;
}
}
#line 918 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_set(mpq_t z , mpq_t x ) 
{ 


  {
#line 920
  if ((unsigned long )z != (unsigned long )x) {
    {
#line 921
    _glp_mpz_set(& z->p, & x->p);
#line 922
    _glp_mpz_set(& z->q, & x->q);
    }
  }
#line 924
  return;
}
}
#line 927 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_set_si(mpq_t x , int p , unsigned int q ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 929
  if (q == 0U) {
    {
#line 930
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 930);
#line 930
    (*tmp)("mpq_set_si: zero denominator not allowed\n");
    }
  }
  {
#line 931
  _glp_mpz_set_si(& x->p, p);
  }
#line 932
  if (q <= 2147483647U) {
#line 932
    tmp___0 = 1;
  } else {
    {
#line 932
    _glp_lib_xassert("q <= 0x7FFFFFFF", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     932);
#line 932
    tmp___0 = 1;
    }
  }
  {
#line 933
  _glp_mpz_set_si(& x->q, (int )q);
  }
#line 934
  return;
}
}
#line 937 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
double _glp_mpq_get_d(mpq_t x ) 
{ 
  int np ;
  int nq ;
  double p ;
  double q ;
  double tmp ;

  {
  {
#line 941
  p = _glp_mpz_get_d_2exp(& np, & x->p);
#line 942
  q = _glp_mpz_get_d_2exp(& nq, & x->q);
#line 943
  tmp = ldexp(p / q, np - nq);
  }
#line 943
  return (tmp);
}
}
#line 946 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_set_d(mpq_t x , double val ) 
{ 
  int s ;
  int n ;
  int d___0 ;
  int j ;
  double f ;
  mpz_t temp ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 951
  if (- 1.7976931348623157e+308 <= val) {
#line 951
    if (val <= 1.7976931348623157e+308) {
#line 951
      tmp = 1;
    } else {
      {
#line 951
      _glp_lib_xassert("-DBL_MAX <= val && val <= +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       951);
#line 951
      tmp = 1;
      }
    }
  } else {
    {
#line 951
    _glp_lib_xassert("-DBL_MAX <= val && val <= +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     951);
#line 951
    tmp = 1;
    }
  }
  {
#line 952
  _glp_mpq_set_si(x, 0, 1U);
  }
#line 953
  if (val > 0.0) {
#line 954
    s = 1;
  } else
#line 955
  if (val < 0.0) {
#line 956
    s = -1;
  } else {
#line 958
    goto done;
  }
  {
#line 959
  tmp___0 = fabs(val);
#line 959
  f = frexp(tmp___0, & n);
#line 961
  temp = _glp_mpz_init();
  }
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 962
    if (! (f != 0.0)) {
#line 962
      goto while_break;
    }
#line 963
    f *= 16.0;
#line 963
    n -= 4;
#line 964
    d___0 = (int )f;
#line 965
    if (0 <= d___0) {
#line 965
      if (d___0 <= 15) {
#line 965
        tmp___1 = 1;
      } else {
        {
#line 965
        _glp_lib_xassert("0 <= d && d <= 15", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                         965);
#line 965
        tmp___1 = 1;
        }
      }
    } else {
      {
#line 965
      _glp_lib_xassert("0 <= d && d <= 15", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                       965);
#line 965
      tmp___1 = 1;
      }
    }
    {
#line 966
    f -= (double )d___0;
#line 968
    _glp_mpz_set_si(temp, 16);
#line 969
    _glp_mpz_mul(& x->p, & x->p, temp);
#line 970
    _glp_mpz_set_si(temp, d___0);
#line 971
    _glp_mpz_add(& x->p, & x->p, temp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 973
  _glp_mpz_clear(temp);
  }
#line 975
  if (n > 0) {
#line 976
    j = 1;
    {
#line 976
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 976
      if (! (j <= n)) {
#line 976
        goto while_break___0;
      }
      {
#line 977
      _glp_mpz_add(& x->p, & x->p, & x->p);
#line 976
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 979
  if (n < 0) {
#line 980
    j = 1;
    {
#line 980
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 980
      if (! (j <= - n)) {
#line 980
        goto while_break___1;
      }
      {
#line 981
      _glp_mpz_add(& x->q, & x->q, & x->q);
#line 980
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 982
    _glp_mpq_canonicalize(x);
    }
  }
#line 984
  if (s < 0) {
    {
#line 984
    _glp_mpq_neg(x, x);
    }
  }
  done: 
#line 985
  return;
}
}
#line 988 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_add(mpq_t z , mpq_t x , mpq_t y ) 
{ 
  mpz_t p ;
  mpz_t q ;

  {
  {
#line 991
  p = _glp_mpz_init();
#line 992
  q = _glp_mpz_init();
#line 993
  _glp_mpz_mul(p, & x->p, & y->q);
#line 994
  _glp_mpz_mul(q, & x->q, & y->p);
#line 995
  _glp_mpz_add(p, p, q);
#line 996
  _glp_mpz_mul(q, & x->q, & y->q);
#line 997
  _glp_mpz_set(& z->p, p);
#line 998
  _glp_mpz_set(& z->q, q);
#line 999
  _glp_mpz_clear(p);
#line 1000
  _glp_mpz_clear(q);
#line 1001
  _glp_mpq_canonicalize(z);
  }
#line 1002
  return;
}
}
#line 1005 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_sub(mpq_t z , mpq_t x , mpq_t y ) 
{ 
  mpz_t p ;
  mpz_t q ;

  {
  {
#line 1008
  p = _glp_mpz_init();
#line 1009
  q = _glp_mpz_init();
#line 1010
  _glp_mpz_mul(p, & x->p, & y->q);
#line 1011
  _glp_mpz_mul(q, & x->q, & y->p);
#line 1012
  _glp_mpz_sub(p, p, q);
#line 1013
  _glp_mpz_mul(q, & x->q, & y->q);
#line 1014
  _glp_mpz_set(& z->p, p);
#line 1015
  _glp_mpz_set(& z->q, q);
#line 1016
  _glp_mpz_clear(p);
#line 1017
  _glp_mpz_clear(q);
#line 1018
  _glp_mpq_canonicalize(z);
  }
#line 1019
  return;
}
}
#line 1022 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_mul(mpq_t z , mpq_t x , mpq_t y ) 
{ 


  {
  {
#line 1024
  _glp_mpz_mul(& z->p, & x->p, & y->p);
#line 1025
  _glp_mpz_mul(& z->q, & x->q, & y->q);
#line 1026
  _glp_mpq_canonicalize(z);
  }
#line 1027
  return;
}
}
#line 1030 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_div(mpq_t z , mpq_t x , mpq_t y ) 
{ 
  mpz_t p ;
  mpz_t q ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1033
  tmp___0 = _glp_mpq_sgn(y);
  }
#line 1033
  if (tmp___0 == 0) {
    {
#line 1034
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 1034);
#line 1034
    (*tmp)("mpq_div: zero divisor not allowed\n");
    }
  }
  {
#line 1035
  p = _glp_mpz_init();
#line 1036
  q = _glp_mpz_init();
#line 1037
  _glp_mpz_mul(p, & x->p, & y->q);
#line 1038
  _glp_mpz_mul(q, & x->q, & y->p);
#line 1039
  _glp_mpz_set(& z->p, p);
#line 1040
  _glp_mpz_set(& z->q, q);
#line 1041
  _glp_mpz_clear(p);
#line 1042
  _glp_mpz_clear(q);
#line 1043
  _glp_mpq_canonicalize(z);
  }
#line 1044
  return;
}
}
#line 1047 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_neg(mpq_t z , mpq_t x ) 
{ 


  {
  {
#line 1049
  _glp_mpq_set(z, x);
#line 1050
  _glp_mpz_neg(& z->p, & z->p);
  }
#line 1051
  return;
}
}
#line 1054 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
void _glp_mpq_abs(mpq_t z , mpq_t x ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1056
  _glp_mpq_set(z, x);
#line 1057
  _glp_mpz_abs(& z->p, & z->p);
#line 1058
  tmp = _glp_mpz_sgn(& x->q);
  }
#line 1058
  if (tmp > 0) {
#line 1058
    tmp___0 = 1;
  } else {
    {
#line 1058
    _glp_lib_xassert("mpz_sgn(&x->q) > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     1058);
#line 1058
    tmp___0 = 1;
    }
  }
#line 1059
  return;
}
}
#line 1062 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
int _glp_mpq_cmp(mpq_t x , mpq_t y ) 
{ 
  mpq_t temp ;
  int s ;

  {
  {
#line 1067
  temp = _glp_mpq_init();
#line 1068
  _glp_mpq_sub(temp, x, y);
#line 1069
  s = _glp_mpq_sgn(temp);
#line 1070
  _glp_mpq_clear(temp);
  }
#line 1071
  return (s);
}
}
#line 1074 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
int _glp_mpq_sgn(mpq_t x ) 
{ 
  int s ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1077
  s = _glp_mpz_sgn(& x->p);
#line 1078
  tmp = _glp_mpz_sgn(& x->q);
  }
#line 1078
  if (tmp > 0) {
#line 1078
    tmp___0 = 1;
  } else {
    {
#line 1078
    _glp_lib_xassert("mpz_sgn(&x->q) > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c",
                     1078);
#line 1078
    tmp___0 = 1;
    }
  }
#line 1079
  return (s);
}
}
#line 1082 "/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c"
int _glp_mpq_out_str(void *_fp , int base , mpq_t x ) 
{ 
  FILE *fp ;
  int nwr ;
  xerror_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1089
  fp = (FILE *)_fp;
#line 1091
  if (2 <= base) {
#line 1091
    if (! (base <= 36)) {
      {
#line 1092
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 1092);
#line 1092
      (*tmp)("mpq_out_str: base = %d; invalid base\n", base);
      }
    }
  } else {
    {
#line 1092
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpgmp.c", 1092);
#line 1092
    (*tmp)("mpq_out_str: base = %d; invalid base\n", base);
    }
  }
#line 1093
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1093
    fp = stdout;
  }
  {
#line 1094
  nwr = _glp_mpz_out_str((void *)fp, base, & x->p);
  }
#line 1095
  if (x->q.val == 1) {
#line 1095
    if (! ((unsigned long )x->q.ptr == (unsigned long )((void *)0))) {
      {
#line 1098
      fputc('/', fp);
#line 1098
      nwr ++;
#line 1099
      tmp___0 = _glp_mpz_out_str((void *)fp, base, & x->q);
#line 1099
      nwr += tmp___0;
      }
    }
  } else {
    {
#line 1098
    fputc('/', fp);
#line 1098
    nwr ++;
#line 1099
    tmp___0 = _glp_mpz_out_str((void *)fp, base, & x->q);
#line 1099
    nwr += tmp___0;
    }
  }
  {
#line 1101
  tmp___1 = ferror(fp);
  }
#line 1101
  if (tmp___1) {
#line 1101
    nwr = 0;
  }
#line 1102
  return (nwr);
}
}
#line 138 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.h"
FHV *_glp_fhv_create_it(void) ;
#line 142
int _glp_fhv_factorize(FHV *fhv , int m , int (*col)(void *info , int j , int *ind ,
                                                     double *val ) , void *info ) ;
#line 147
void _glp_fhv_h_solve(FHV *fhv , int tr , double *x ) ;
#line 151
void _glp_fhv_ftran(FHV *fhv , double *x ) ;
#line 155
void _glp_fhv_btran(FHV *fhv , double *x ) ;
#line 159
int _glp_fhv_update_it(FHV *fhv , int j , int len , int const   *ind , double const   *val ) ;
#line 164
void _glp_fhv_delete_it(FHV *fhv ) ;
#line 52 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c"
FHV *_glp_fhv_create_it(void) 
{ 
  FHV *fhv ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 54
  tmp = _glp_lib_xmalloc((int )sizeof(FHV ));
#line 54
  fhv = (FHV *)tmp;
#line 55
  tmp___0 = 0;
#line 55
  fhv->m = tmp___0;
#line 55
  fhv->m_max = tmp___0;
#line 56
  fhv->valid = 0;
#line 57
  fhv->luf = _glp_luf_create_it();
#line 58
  fhv->hh_max = 50;
#line 59
  fhv->hh_nfs = 0;
#line 60
  tmp___2 = (int *)((void *)0);
#line 60
  fhv->hh_len = tmp___2;
#line 60
  tmp___1 = tmp___2;
#line 60
  fhv->hh_ptr = tmp___1;
#line 60
  fhv->hh_ind = tmp___1;
#line 61
  tmp___3 = (int *)((void *)0);
#line 61
  fhv->p0_col = tmp___3;
#line 61
  fhv->p0_row = tmp___3;
#line 62
  fhv->cc_ind = (int *)((void *)0);
#line 63
  fhv->cc_val = (double *)((void *)0);
#line 64
  fhv->upd_tol = 1e-6;
#line 65
  fhv->nnz_h = 0;
  }
#line 66
  return (fhv);
}
}
#line 138 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c"
int _glp_fhv_factorize(FHV *fhv , int m , int (*col)(void *info , int j , int *ind ,
                                                     double *val ) , void *info ) 
{ 
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 141
  if (m < 1) {
    {
#line 142
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c", 142);
#line 142
    (*tmp)("fhv_factorize: m = %d; invalid parameter\n", m);
    }
  }
#line 143
  if (m > 100000000) {
    {
#line 144
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c", 144);
#line 144
    (*tmp___0)("fhv_factorize: m = %d; matrix too big\n", m);
    }
  }
#line 145
  fhv->m = m;
#line 147
  fhv->valid = 0;
#line 149
  if ((unsigned long )fhv->hh_ind == (unsigned long )((void *)0)) {
    {
#line 150
    tmp___1 = _glp_lib_xcalloc(1 + fhv->hh_max, (int )sizeof(int ));
#line 150
    fhv->hh_ind = (int *)tmp___1;
    }
  }
#line 151
  if ((unsigned long )fhv->hh_ptr == (unsigned long )((void *)0)) {
    {
#line 152
    tmp___2 = _glp_lib_xcalloc(1 + fhv->hh_max, (int )sizeof(int ));
#line 152
    fhv->hh_ptr = (int *)tmp___2;
    }
  }
#line 153
  if ((unsigned long )fhv->hh_len == (unsigned long )((void *)0)) {
    {
#line 154
    tmp___3 = _glp_lib_xcalloc(1 + fhv->hh_max, (int )sizeof(int ));
#line 154
    fhv->hh_len = (int *)tmp___3;
    }
  }
#line 155
  if (fhv->m_max < m) {
#line 156
    if ((unsigned long )fhv->p0_row != (unsigned long )((void *)0)) {
      {
#line 156
      _glp_lib_xfree((void *)fhv->p0_row);
      }
    }
#line 157
    if ((unsigned long )fhv->p0_col != (unsigned long )((void *)0)) {
      {
#line 157
      _glp_lib_xfree((void *)fhv->p0_col);
      }
    }
#line 158
    if ((unsigned long )fhv->cc_ind != (unsigned long )((void *)0)) {
      {
#line 158
      _glp_lib_xfree((void *)fhv->cc_ind);
      }
    }
#line 159
    if ((unsigned long )fhv->cc_val != (unsigned long )((void *)0)) {
      {
#line 159
      _glp_lib_xfree((void *)fhv->cc_val);
      }
    }
    {
#line 160
    fhv->m_max = m + 100;
#line 161
    tmp___4 = _glp_lib_xcalloc(1 + fhv->m_max, (int )sizeof(int ));
#line 161
    fhv->p0_row = (int *)tmp___4;
#line 162
    tmp___5 = _glp_lib_xcalloc(1 + fhv->m_max, (int )sizeof(int ));
#line 162
    fhv->p0_col = (int *)tmp___5;
#line 163
    tmp___6 = _glp_lib_xcalloc(1 + fhv->m_max, (int )sizeof(int ));
#line 163
    fhv->cc_ind = (int *)tmp___6;
#line 164
    tmp___7 = _glp_lib_xcalloc(1 + fhv->m_max, (int )sizeof(double ));
#line 164
    fhv->cc_val = (double *)tmp___7;
    }
  }
  {
#line 167
  tmp___8 = _glp_luf_factorize(fhv->luf, m, col, info);
  }
  {
#line 168
  if (tmp___8 == 0) {
#line 168
    goto case_0;
  }
#line 170
  if (tmp___8 == 1) {
#line 170
    goto case_1;
  }
#line 173
  if (tmp___8 == 2) {
#line 173
    goto case_2;
  }
#line 176
  goto switch_default;
  case_0: /* CIL Label */ 
#line 169
  goto switch_break;
  case_1: /* CIL Label */ 
#line 171
  ret = 1;
#line 172
  goto done;
  case_2: /* CIL Label */ 
#line 174
  ret = 2;
#line 175
  goto done;
  switch_default: /* CIL Label */ 
#line 177
  if ((unsigned long )fhv != (unsigned long )fhv) {
#line 177
    tmp___9 = 1;
  } else {
    {
#line 177
    _glp_lib_xassert("fhv != fhv", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                     177);
#line 177
    tmp___9 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 180
  fhv->valid = 1;
#line 182
  fhv->hh_nfs = 0;
#line 184
  memcpy((void */* __restrict  */)(fhv->p0_row + 1), (void const   */* __restrict  */)((fhv->luf)->pp_row + 1),
         (size_t )(sizeof(int ) * (unsigned long )m));
#line 185
  memcpy((void */* __restrict  */)(fhv->p0_col + 1), (void const   */* __restrict  */)((fhv->luf)->pp_col + 1),
         (size_t )(sizeof(int ) * (unsigned long )m));
#line 187
  fhv->nnz_h = 0;
#line 188
  ret = 0;
  }
  done: 
#line 190
  return (ret);
}
}
#line 215 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c"
void _glp_fhv_h_solve(FHV *fhv , int tr , double *x ) 
{ 
  int nfs ;
  int *hh_ind ;
  int *hh_ptr ;
  int *hh_len ;
  int *sv_ind ;
  double *sv_val ;
  int i ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;
  xerror_t tmp ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 216
  nfs = fhv->hh_nfs;
#line 217
  hh_ind = fhv->hh_ind;
#line 218
  hh_ptr = fhv->hh_ptr;
#line 219
  hh_len = fhv->hh_len;
#line 220
  sv_ind = (fhv->luf)->sv_ind;
#line 221
  sv_val = (fhv->luf)->sv_val;
#line 224
  if (! fhv->valid) {
    {
#line 225
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c", 225);
#line 225
    (*tmp)("fhv_h_solve: the factorization is not valid\n");
    }
  }
#line 226
  if (! tr) {
#line 228
    k = 1;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! (k <= nfs)) {
#line 228
        goto while_break;
      }
#line 229
      i = *(hh_ind + k);
#line 230
      temp = *(x + i);
#line 231
      beg = *(hh_ptr + k);
#line 232
      end = (beg + *(hh_len + k)) - 1;
#line 233
      ptr = beg;
      {
#line 233
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 233
        if (! (ptr <= end)) {
#line 233
          goto while_break___0;
        }
#line 234
        temp -= *(sv_val + ptr) * *(x + *(sv_ind + ptr));
#line 233
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 235
      *(x + i) = temp;
#line 228
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 240
    k = nfs;
    {
#line 240
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 240
      if (! (k >= 1)) {
#line 240
        goto while_break___1;
      }
#line 241
      i = *(hh_ind + k);
#line 242
      temp = *(x + i);
#line 243
      if (temp == 0.0) {
#line 243
        goto __Cont;
      }
#line 244
      beg = *(hh_ptr + k);
#line 245
      end = (beg + *(hh_len + k)) - 1;
#line 246
      ptr = beg;
      {
#line 246
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 246
        if (! (ptr <= end)) {
#line 246
          goto while_break___2;
        }
#line 247
        *(x + *(sv_ind + ptr)) -= *(sv_val + ptr) * temp;
#line 246
        ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 240
      k --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 250
  return;
}
}
#line 273 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c"
void _glp_fhv_ftran(FHV *fhv , double *x ) 
{ 
  int *pp_row ;
  int *pp_col ;
  int *p0_row ;
  int *p0_col ;
  xerror_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 274
  pp_row = (fhv->luf)->pp_row;
#line 275
  pp_col = (fhv->luf)->pp_col;
#line 276
  p0_row = fhv->p0_row;
#line 277
  p0_col = fhv->p0_col;
#line 278
  if (! fhv->valid) {
    {
#line 279
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c", 279);
#line 279
    (*tmp)("fhv_ftran: the factorization is not valid\n");
    }
  }
  {
#line 281
  (fhv->luf)->pp_row = p0_row;
#line 282
  (fhv->luf)->pp_col = p0_col;
#line 283
  _glp_luf_f_solve(fhv->luf, 0, x);
#line 284
  (fhv->luf)->pp_row = pp_row;
#line 285
  (fhv->luf)->pp_col = pp_col;
#line 286
  _glp_fhv_h_solve(fhv, 0, x);
#line 287
  _glp_luf_v_solve(fhv->luf, 0, x);
  }
#line 288
  return;
}
}
#line 312 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c"
void _glp_fhv_btran(FHV *fhv , double *x ) 
{ 
  int *pp_row ;
  int *pp_col ;
  int *p0_row ;
  int *p0_col ;
  xerror_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 313
  pp_row = (fhv->luf)->pp_row;
#line 314
  pp_col = (fhv->luf)->pp_col;
#line 315
  p0_row = fhv->p0_row;
#line 316
  p0_col = fhv->p0_col;
#line 317
  if (! fhv->valid) {
    {
#line 318
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c", 318);
#line 318
    (*tmp)("fhv_btran: the factorization is not valid\n");
    }
  }
  {
#line 320
  _glp_luf_v_solve(fhv->luf, 1, x);
#line 321
  _glp_fhv_h_solve(fhv, 1, x);
#line 322
  (fhv->luf)->pp_row = p0_row;
#line 323
  (fhv->luf)->pp_col = p0_col;
#line 324
  _glp_luf_f_solve(fhv->luf, 1, x);
#line 325
  (fhv->luf)->pp_row = pp_row;
#line 326
  (fhv->luf)->pp_col = pp_col;
  }
#line 327
  return;
}
}
#line 438 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c"
int _glp_fhv_update_it(FHV *fhv , int j , int len , int const   *ind , double const   *val ) 
{ 
  int m ;
  LUF *luf ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  double *vr_piv ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *pp_row ;
  int *pp_col ;
  int *qq_row ;
  int *qq_col ;
  int *sv_ind ;
  double *sv_val ;
  double *work ;
  double eps_tol ;
  int *hh_ind ;
  int *hh_ptr ;
  int *hh_len ;
  int *p0_row ;
  int *p0_col ;
  int *cc_ind ;
  double *cc_val ;
  double upd_tol ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int k ;
  int k1 ;
  int k2 ;
  int p ;
  int q ;
  int p_beg ;
  int p_end ;
  int p_ptr ;
  int ptr ;
  int ret ;
  double f ;
  double temp ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;

  {
#line 440
  m = fhv->m;
#line 441
  luf = fhv->luf;
#line 442
  vr_ptr = luf->vr_ptr;
#line 443
  vr_len = luf->vr_len;
#line 444
  vr_cap = luf->vr_cap;
#line 445
  vr_piv = luf->vr_piv;
#line 446
  vc_ptr = luf->vc_ptr;
#line 447
  vc_len = luf->vc_len;
#line 448
  vc_cap = luf->vc_cap;
#line 449
  pp_row = luf->pp_row;
#line 450
  pp_col = luf->pp_col;
#line 451
  qq_row = luf->qq_row;
#line 452
  qq_col = luf->qq_col;
#line 453
  sv_ind = luf->sv_ind;
#line 454
  sv_val = luf->sv_val;
#line 455
  work = luf->work;
#line 456
  eps_tol = luf->eps_tol;
#line 457
  hh_ind = fhv->hh_ind;
#line 458
  hh_ptr = fhv->hh_ptr;
#line 459
  hh_len = fhv->hh_len;
#line 460
  p0_row = fhv->p0_row;
#line 461
  p0_col = fhv->p0_col;
#line 462
  cc_ind = fhv->cc_ind;
#line 463
  cc_val = fhv->cc_val;
#line 464
  upd_tol = fhv->upd_tol;
#line 468
  if (! fhv->valid) {
    {
#line 469
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c", 469);
#line 469
    (*tmp)("fhv_update_it: the factorization is not valid\n");
    }
  }
#line 470
  if (1 <= j) {
#line 470
    if (! (j <= m)) {
      {
#line 471
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                                 471);
#line 471
      (*tmp___0)("fhv_update_it: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 471
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c", 471);
#line 471
    (*tmp___0)("fhv_update_it: j = %d; column number out of range\n", j);
    }
  }
#line 474
  if (fhv->hh_nfs == fhv->hh_max) {
#line 476
    fhv->valid = 0;
#line 477
    ret = 4;
#line 478
    goto done;
  }
#line 481
  i = 1;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i <= m)) {
#line 481
      goto while_break;
    }
#line 482
    *(cc_val + i) = 0.0;
#line 481
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  k = 1;
  {
#line 483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 483
    if (! (k <= len)) {
#line 483
      goto while_break___0;
    }
#line 484
    i = (int )*(ind + k);
#line 485
    if (1 <= i) {
#line 485
      if (! (i <= m)) {
        {
#line 486
        tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                                   486);
#line 486
        (*tmp___1)("fhv_update_it: ind[%d] = %d; row number out of range\n", k, i);
        }
      }
    } else {
      {
#line 486
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                                 486);
#line 486
      (*tmp___1)("fhv_update_it: ind[%d] = %d; row number out of range\n", k, i);
      }
    }
#line 488
    if (*(cc_val + i) != 0.0) {
      {
#line 489
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                                 489);
#line 489
      (*tmp___2)("fhv_update_it: ind[%d] = %d; duplicate row index not allowed\n",
                 k, i);
      }
    }
#line 491
    if (*(val + k) == (double const   )0.0) {
      {
#line 492
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                                 492);
#line 492
      (*tmp___3)("fhv_update_it: val[%d] = %g; zero element not allowed\n", k, *(val + k));
      }
    }
#line 494
    *(cc_val + i) = (double )*(val + k);
#line 483
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 497
  (fhv->luf)->pp_row = p0_row;
#line 498
  (fhv->luf)->pp_col = p0_col;
#line 499
  _glp_luf_f_solve(fhv->luf, 0, cc_val);
#line 500
  (fhv->luf)->pp_row = pp_row;
#line 501
  (fhv->luf)->pp_col = pp_col;
#line 502
  _glp_fhv_h_solve(fhv, 0, cc_val);
#line 504
  len = 0;
#line 505
  i = 1;
  }
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 505
    if (! (i <= m)) {
#line 505
      goto while_break___1;
    }
#line 506
    temp = *(cc_val + i);
#line 507
    if (temp == 0.0) {
#line 507
      goto __Cont;
    } else {
      {
#line 507
      tmp___4 = fabs(temp);
      }
#line 507
      if (tmp___4 < eps_tol) {
#line 507
        goto __Cont;
      }
    }
#line 508
    len ++;
#line 508
    *(cc_ind + len) = i;
#line 508
    *(cc_val + len) = temp;
    __Cont: /* CIL Label */ 
#line 505
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 511
  j_beg = *(vc_ptr + j);
#line 512
  j_end = (j_beg + *(vc_len + j)) - 1;
#line 513
  j_ptr = j_beg;
  {
#line 513
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 513
    if (! (j_ptr <= j_end)) {
#line 513
      goto while_break___2;
    }
#line 515
    i = *(sv_ind + j_ptr);
#line 517
    i_beg = *(vr_ptr + i);
#line 518
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 519
    i_ptr = i_beg;
    {
#line 519
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 519
      if (! (*(sv_ind + i_ptr) != j)) {
#line 519
        goto while_break___3;
      }
#line 519
      i_ptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 520
    if (i_ptr <= i_end) {
#line 520
      tmp___5 = 1;
    } else {
      {
#line 520
      _glp_lib_xassert("i_ptr <= i_end", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                       520);
#line 520
      tmp___5 = 1;
      }
    }
#line 522
    *(sv_ind + i_ptr) = *(sv_ind + i_end);
#line 523
    *(sv_val + i_ptr) = *(sv_val + i_end);
#line 524
    (*(vr_len + i)) --;
#line 513
    j_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 527
  luf->nnz_v -= *(vc_len + j);
#line 528
  *(vc_len + j) = 0;
#line 531
  k1 = *(qq_row + j);
#line 531
  k2 = 0;
#line 532
  ptr = 1;
  {
#line 532
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 532
    if (! (ptr <= len)) {
#line 532
      goto while_break___4;
    }
#line 534
    i = *(cc_ind + ptr);
#line 536
    if (*(vr_len + i) + 1 > *(vr_cap + i)) {
      {
#line 537
      tmp___7 = _glp_luf_enlarge_row(luf, i, *(vr_len + i) + 10);
      }
#line 537
      if (tmp___7) {
#line 539
        fhv->valid = 0;
#line 540
        luf->new_sva = luf->sv_size + luf->sv_size;
#line 541
        if (luf->new_sva > luf->sv_size) {
#line 541
          tmp___6 = 1;
        } else {
          {
#line 541
          _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                           541);
#line 541
          tmp___6 = 1;
          }
        }
#line 542
        ret = 5;
#line 543
        goto done;
      }
    }
#line 547
    i_ptr = *(vr_ptr + i) + *(vr_len + i);
#line 548
    *(sv_ind + i_ptr) = j;
#line 549
    *(sv_val + i_ptr) = *(cc_val + ptr);
#line 550
    (*(vr_len + i)) ++;
#line 552
    if (k2 < *(pp_col + i)) {
#line 552
      k2 = *(pp_col + i);
    }
#line 532
    ptr ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 556
  if (*(vc_cap + j) < len) {
    {
#line 557
    tmp___9 = _glp_luf_enlarge_col(luf, j, len);
    }
#line 557
    if (tmp___9) {
#line 559
      fhv->valid = 0;
#line 560
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 561
      if (luf->new_sva > luf->sv_size) {
#line 561
        tmp___8 = 1;
      } else {
        {
#line 561
        _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                         561);
#line 561
        tmp___8 = 1;
        }
      }
#line 562
      ret = 5;
#line 563
      goto done;
    }
  }
  {
#line 567
  j_ptr = *(vc_ptr + j);
#line 568
  memmove((void *)(sv_ind + j_ptr), (void const   *)(cc_ind + 1), (size_t )((unsigned long )len * sizeof(int )));
#line 569
  memmove((void *)(sv_val + j_ptr), (void const   *)(cc_val + 1), (size_t )((unsigned long )len * sizeof(double )));
#line 570
  *(vc_len + j) = len;
#line 571
  luf->nnz_v += len;
  }
#line 574
  if (k1 > k2) {
#line 575
    fhv->valid = 0;
#line 576
    ret = 1;
#line 577
    goto done;
  }
#line 581
  i = *(pp_row + k1);
#line 581
  j = *(qq_col + k1);
#line 582
  k = k1;
  {
#line 582
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 582
    if (! (k < k2)) {
#line 582
      goto while_break___5;
    }
#line 583
    *(pp_row + k) = *(pp_row + (k + 1));
#line 583
    *(pp_col + *(pp_row + k)) = k;
#line 584
    *(qq_col + k) = *(qq_col + (k + 1));
#line 584
    *(qq_row + *(qq_col + k)) = k;
#line 582
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 586
  *(pp_row + k2) = i;
#line 586
  *(pp_col + i) = k2;
#line 587
  *(qq_col + k2) = j;
#line 587
  *(qq_row + j) = k2;
#line 592
  j = 1;
  {
#line 592
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 592
    if (! (j <= m)) {
#line 592
      goto while_break___6;
    }
#line 592
    *(work + j) = 0.0;
#line 592
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 593
  i_beg = *(vr_ptr + i);
#line 594
  i_end = (i_beg + *(vr_len + i)) - 1;
#line 595
  i_ptr = i_beg;
  {
#line 595
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 595
    if (! (i_ptr <= i_end)) {
#line 595
      goto while_break___7;
    }
#line 597
    j = *(sv_ind + i_ptr);
#line 599
    *(work + j) = *(sv_val + i_ptr);
#line 601
    j_beg = *(vc_ptr + j);
#line 602
    j_end = (j_beg + *(vc_len + j)) - 1;
#line 603
    j_ptr = j_beg;
    {
#line 603
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 603
      if (! (*(sv_ind + j_ptr) != i)) {
#line 603
        goto while_break___8;
      }
#line 603
      j_ptr ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 604
    if (j_ptr <= j_end) {
#line 604
      tmp___10 = 1;
    } else {
      {
#line 604
      _glp_lib_xassert("j_ptr <= j_end", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                       604);
#line 604
      tmp___10 = 1;
      }
    }
#line 606
    *(sv_ind + j_ptr) = *(sv_ind + j_end);
#line 607
    *(sv_val + j_ptr) = *(sv_val + j_end);
#line 608
    (*(vc_len + j)) --;
#line 595
    i_ptr ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 611
  luf->nnz_v -= *(vr_len + i);
#line 612
  *(vr_len + i) = 0;
#line 615
  (fhv->hh_nfs) ++;
#line 616
  *(hh_ind + fhv->hh_nfs) = i;
#line 618
  *(hh_len + fhv->hh_nfs) = 0;
#line 621
  if (luf->sv_end - luf->sv_beg < k2 - k1) {
    {
#line 622
    _glp_luf_defrag_sva(luf);
    }
#line 623
    if (luf->sv_end - luf->sv_beg < k2 - k1) {
#line 625
      tmp___11 = 0;
#line 625
      luf->valid = tmp___11;
#line 625
      fhv->valid = tmp___11;
#line 626
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 627
      if (luf->new_sva > luf->sv_size) {
#line 627
        tmp___12 = 1;
      } else {
        {
#line 627
        _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                         627);
#line 627
        tmp___12 = 1;
        }
      }
#line 628
      ret = 5;
#line 629
      goto done;
    }
  }
#line 633
  k = k1;
  {
#line 633
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 633
    if (! (k < k2)) {
#line 633
      goto while_break___9;
    }
#line 635
    p = *(pp_row + k);
#line 635
    q = *(qq_col + k);
#line 638
    if (*(work + q) == 0.0) {
#line 638
      goto __Cont___0;
    }
#line 640
    f = *(work + q) / *(vr_piv + p);
#line 644
    p_beg = *(vr_ptr + p);
#line 645
    p_end = (p_beg + *(vr_len + p)) - 1;
#line 646
    p_ptr = p_beg;
    {
#line 646
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 646
      if (! (p_ptr <= p_end)) {
#line 646
        goto while_break___10;
      }
#line 647
      *(work + *(sv_ind + p_ptr)) -= f * *(sv_val + p_ptr);
#line 646
      p_ptr ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 650
    (luf->sv_end) --;
#line 651
    *(sv_ind + luf->sv_end) = p;
#line 652
    *(sv_val + luf->sv_end) = f;
#line 653
    (*(hh_len + fhv->hh_nfs)) ++;
    __Cont___0: /* CIL Label */ 
#line 633
    k ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 658
  if (*(hh_len + fhv->hh_nfs) == 0) {
#line 659
    (fhv->hh_nfs) --;
  } else {
#line 661
    *(hh_ptr + fhv->hh_nfs) = luf->sv_end;
#line 662
    fhv->nnz_h += *(hh_len + fhv->hh_nfs);
  }
#line 665
  *(vr_piv + i) = *(work + *(qq_col + k2));
#line 669
  len = 0;
#line 670
  k = k2 + 1;
  {
#line 670
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 670
    if (! (k <= m)) {
#line 670
      goto while_break___11;
    }
    {
#line 672
    j = *(qq_col + k);
#line 673
    temp = *(work + j);
#line 675
    tmp___13 = fabs(temp);
    }
#line 675
    if (tmp___13 < eps_tol) {
#line 675
      goto __Cont___1;
    }
#line 677
    if (*(vc_len + j) + 1 > *(vc_cap + j)) {
      {
#line 678
      tmp___15 = _glp_luf_enlarge_col(luf, j, *(vc_len + j) + 10);
      }
#line 678
      if (tmp___15) {
#line 680
        fhv->valid = 0;
#line 681
        luf->new_sva = luf->sv_size + luf->sv_size;
#line 682
        if (luf->new_sva > luf->sv_size) {
#line 682
          tmp___14 = 1;
        } else {
          {
#line 682
          _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                           682);
#line 682
          tmp___14 = 1;
          }
        }
#line 683
        ret = 5;
#line 684
        goto done;
      }
    }
#line 688
    j_ptr = *(vc_ptr + j) + *(vc_len + j);
#line 689
    *(sv_ind + j_ptr) = i;
#line 690
    *(sv_val + j_ptr) = temp;
#line 691
    (*(vc_len + j)) ++;
#line 693
    len ++;
#line 693
    *(cc_ind + len) = j;
#line 693
    *(cc_val + len) = temp;
    __Cont___1: /* CIL Label */ 
#line 670
    k ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 697
  if (*(vr_cap + i) < len) {
    {
#line 698
    tmp___17 = _glp_luf_enlarge_row(luf, i, len);
    }
#line 698
    if (tmp___17) {
#line 700
      fhv->valid = 0;
#line 701
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 702
      if (luf->new_sva > luf->sv_size) {
#line 702
        tmp___16 = 1;
      } else {
        {
#line 702
        _glp_lib_xassert("luf->new_sva > luf->sv_size", "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c",
                         702);
#line 702
        tmp___16 = 1;
        }
      }
#line 703
      ret = 5;
#line 704
      goto done;
    }
  }
  {
#line 708
  i_ptr = *(vr_ptr + i);
#line 709
  memmove((void *)(sv_ind + i_ptr), (void const   *)(cc_ind + 1), (size_t )((unsigned long )len * sizeof(int )));
#line 710
  memmove((void *)(sv_val + i_ptr), (void const   *)(cc_val + 1), (size_t )((unsigned long )len * sizeof(double )));
#line 711
  *(vr_len + i) = len;
#line 712
  luf->nnz_v += len;
#line 717
  temp = 0.0;
#line 719
  i = *(pp_row + k2);
#line 720
  i_beg = *(vr_ptr + i);
#line 721
  i_end = (i_beg + *(vr_len + i)) - 1;
#line 722
  i_ptr = i_beg;
  }
  {
#line 722
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 722
    if (! (i_ptr <= i_end)) {
#line 722
      goto while_break___12;
    }
    {
#line 723
    tmp___18 = fabs(*(sv_val + i_ptr));
    }
#line 723
    if (temp < tmp___18) {
      {
#line 723
      temp = fabs(*(sv_val + i_ptr));
      }
    }
#line 722
    i_ptr ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 725
  j = *(qq_col + k2);
#line 726
  j_beg = *(vc_ptr + j);
#line 727
  j_end = (j_beg + *(vc_len + j)) - 1;
#line 728
  j_ptr = j_beg;
  {
#line 728
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 728
    if (! (j_ptr <= j_end)) {
#line 728
      goto while_break___13;
    }
    {
#line 729
    tmp___19 = fabs(*(sv_val + j_ptr));
    }
#line 729
    if (temp < tmp___19) {
      {
#line 729
      temp = fabs(*(sv_val + j_ptr));
      }
    }
#line 728
    j_ptr ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 731
  tmp___20 = fabs(*(vr_piv + i));
  }
#line 731
  if (tmp___20 < upd_tol * temp) {
#line 734
    fhv->valid = 0;
#line 735
    ret = 3;
#line 736
    goto done;
  }
#line 739
  ret = 0;
  done: 
#line 741
  return (ret);
}
}
#line 760 "/home/wslee/benchmarks/glpk-4.38/src/glpfhv.c"
void _glp_fhv_delete_it(FHV *fhv ) 
{ 


  {
  {
#line 761
  _glp_luf_delete_it(fhv->luf);
  }
#line 762
  if ((unsigned long )fhv->hh_ind != (unsigned long )((void *)0)) {
    {
#line 762
    _glp_lib_xfree((void *)fhv->hh_ind);
    }
  }
#line 763
  if ((unsigned long )fhv->hh_ptr != (unsigned long )((void *)0)) {
    {
#line 763
    _glp_lib_xfree((void *)fhv->hh_ptr);
    }
  }
#line 764
  if ((unsigned long )fhv->hh_len != (unsigned long )((void *)0)) {
    {
#line 764
    _glp_lib_xfree((void *)fhv->hh_len);
    }
  }
#line 765
  if ((unsigned long )fhv->p0_row != (unsigned long )((void *)0)) {
    {
#line 765
    _glp_lib_xfree((void *)fhv->p0_row);
    }
  }
#line 766
  if ((unsigned long )fhv->p0_col != (unsigned long )((void *)0)) {
    {
#line 766
    _glp_lib_xfree((void *)fhv->p0_col);
    }
  }
#line 767
  if ((unsigned long )fhv->cc_ind != (unsigned long )((void *)0)) {
    {
#line 767
    _glp_lib_xfree((void *)fhv->cc_ind);
    }
  }
#line 768
  if ((unsigned long )fhv->cc_val != (unsigned long )((void *)0)) {
    {
#line 768
    _glp_lib_xfree((void *)fhv->cc_val);
    }
  }
  {
#line 769
  _glp_lib_xfree((void *)fhv);
  }
#line 770
  return;
}
}
#line 820 "./../include/glpk.h"
int glp_read_mincost(glp_graph *G , int v_rhs , int a_low , int a_cap , int a_cost ,
                     char const   *fname ) ;
#line 824
int glp_write_mincost(glp_graph *G , int v_rhs , int a_low , int a_cap , int a_cost ,
                      char const   *fname ) ;
#line 828
int glp_read_maxflow(glp_graph *G , int *_s , int *_t , int a_cap , char const   *fname ) ;
#line 832
int glp_write_maxflow(glp_graph *G , int s , int t , int a_cap , char const   *fname ) ;
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
static void error___0(struct csa___6 *csa , char const   *fmt___0  , ...) 
{ 
  va_list arg ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 50
  _glp_lib_xprintf("%s:%d: error: ", csa->fname, csa->count);
#line 51
  __builtin_va_start(arg, fmt___0);
#line 52
  _glp_lib_xvprintf(fmt___0, arg);
#line 53
  __builtin_va_end(arg);
#line 54
  _glp_lib_xprintf("\n");
#line 55
  longjmp((struct __jmp_buf_tag *)(csa->jump), 1);
  }
}
}
#line 59 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
static void warning___0(struct csa___6 *csa , char const   *fmt___0  , ...) 
{ 
  va_list arg ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 62
  _glp_lib_xprintf("%s:%d: warning: ", csa->fname, csa->count);
#line 63
  __builtin_va_start(arg, fmt___0);
#line 64
  _glp_lib_xvprintf(fmt___0, arg);
#line 65
  __builtin_va_end(arg);
#line 66
  _glp_lib_xprintf("\n");
  }
#line 67
  return;
}
}
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
static void read_char___1(struct csa___6 *csa ) 
{ 
  int c ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 73
  if (csa->c == 10) {
#line 73
    (csa->count) ++;
  }
  {
#line 74
  c = _glp_lib_xfgetc(csa->fp);
  }
#line 75
  if (c < 0) {
    {
#line 76
    tmp___0 = _glp_lib_xferror(csa->fp);
    }
#line 76
    if (tmp___0) {
      {
#line 77
      tmp = _glp_lib_xerrmsg();
#line 77
      error___0(csa, "read error - %s", tmp);
      }
    } else
#line 78
    if (csa->c == 10) {
      {
#line 79
      error___0(csa, "unexpected end of file");
      }
    } else {
      {
#line 81
      warning___0(csa, "missing final end of line");
#line 82
      c = '\n';
      }
    }
  } else
#line 85
  if (! (c == 10)) {
    {
#line 87
    tmp___2 = __ctype_b_loc();
    }
#line 87
    if ((int const   )*(*tmp___2 + c) & 8192) {
#line 88
      c = ' ';
    } else {
      {
#line 89
      tmp___1 = __ctype_b_loc();
      }
#line 89
      if ((int const   )*(*tmp___1 + c) & 2) {
        {
#line 90
        error___0(csa, "invalid control character 0x%02X", c);
        }
      }
    }
  }
#line 91
  csa->c = c;
#line 92
  return;
}
}
#line 95 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
static void read_designator(struct csa___6 *csa ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 97
  if (csa->c == 10) {
#line 97
    tmp = 1;
  } else {
    {
#line 97
    _glp_lib_xassert("csa->c == \'\\n\'", "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                     97);
#line 97
    tmp = 1;
    }
  }
  {
#line 98
  read_char___1(csa);
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      if (! (csa->c == 32)) {
#line 101
        goto while_break___0;
      }
      {
#line 102
      read_char___1(csa);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    if (csa->c == 10) {
#line 105
      if (! csa->empty) {
        {
#line 106
        warning___0(csa, "empty line ignored");
#line 107
        csa->empty = 1;
        }
      }
      {
#line 109
      read_char___1(csa);
      }
    } else
#line 111
    if (csa->c == 99) {
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        if (! (csa->c != 10)) {
#line 113
          goto while_break___1;
        }
        {
#line 114
        read_char___1(csa);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 115
      read_char___1(csa);
      }
    } else {
      {
#line 119
      csa->field[0] = (char )csa->c;
#line 119
      csa->field[1] = (char )'\000';
#line 121
      read_char___1(csa);
      }
#line 122
      if (! (csa->c == 32)) {
#line 122
        if (! (csa->c == 10)) {
          {
#line 123
          error___0(csa, "line designator missing or invalid");
          }
        }
      }
#line 124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 130 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
static void read_field___1(struct csa___6 *csa ) 
{ 
  int len ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 132
  len = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (csa->c == 32)) {
#line 134
      goto while_break;
    }
    {
#line 135
    read_char___1(csa);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (csa->c == 10) {
    {
#line 138
    error___0(csa, "unexpected end of line");
    }
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (csa->c == 32) {
#line 139
      goto while_break___0;
    } else
#line 139
    if (csa->c == 10) {
#line 139
      goto while_break___0;
    }
#line 140
    if ((unsigned long )len == sizeof(csa->field) - 1UL) {
      {
#line 141
      error___0(csa, "data field `%.*s...\' too long", sizeof(csa->field) - 1UL, csa->field);
      }
    }
    {
#line 143
    tmp = len;
#line 143
    len ++;
#line 143
    csa->field[tmp] = (char )csa->c;
#line 144
    read_char___1(csa);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  csa->field[len] = (char )'\000';
#line 147
  return;
}
}
#line 150 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
static void end_of_line(struct csa___6 *csa ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (csa->c == 32)) {
#line 152
      goto while_break;
    }
    {
#line 153
    read_char___1(csa);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  if (csa->c != 10) {
    {
#line 155
    error___0(csa, "too many data fields specified");
    }
  }
#line 156
  return;
}
}
#line 159 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
static void check_int(struct csa___6 *csa , double num ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;

  {
#line 161
  if (! csa->nonint) {
    {
#line 161
    tmp = floor(num);
    }
#line 161
    if (num != tmp) {
      {
#line 162
      warning___0(csa, "non-integer data detected");
#line 163
      csa->nonint = 1;
      }
    }
  }
#line 165
  return;
}
}
#line 188 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
int glp_read_mincost(glp_graph *G , int v_rhs , int a_low , int a_cap , int a_cost ,
                     char const   *fname ) 
{ 
  struct csa___6 _csa ;
  struct csa___6 *csa ;
  glp_vertex *v ;
  glp_arc *a ;
  int i ;
  int j ;
  int k ;
  int nv ;
  int na ;
  int ret ;
  double rhs ;
  double low ;
  double cap ;
  double cost ;
  char *flag ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
#line 190
  csa = & _csa;
#line 193
  ret = 0;
#line 195
  flag = (char *)((void *)0);
#line 196
  if (v_rhs >= 0) {
#line 196
    if (v_rhs > G->v_size - (int )sizeof(double )) {
      {
#line 197
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c", 197);
#line 197
      (*tmp)("glp_read_mincost: v_rhs = %d; invalid offset\n", v_rhs);
      }
    }
  }
#line 199
  if (a_low >= 0) {
#line 199
    if (a_low > G->a_size - (int )sizeof(double )) {
      {
#line 200
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 200);
#line 200
      (*tmp___0)("glp_read_mincost: a_low = %d; invalid offset\n", a_low);
      }
    }
  }
#line 202
  if (a_cap >= 0) {
#line 202
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 203
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 203);
#line 203
      (*tmp___1)("glp_read_mincost: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
#line 205
  if (a_cost >= 0) {
#line 205
    if (a_cost > G->a_size - (int )sizeof(double )) {
      {
#line 206
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 206);
#line 206
      (*tmp___2)("glp_read_mincost: a_cost = %d; invalid offset\n", a_cost);
      }
    }
  }
  {
#line 208
  glp_erase_graph(G, G->v_size, G->a_size);
#line 209
  tmp___3 = _setjmp((struct __jmp_buf_tag *)(csa->jump));
  }
#line 209
  if (tmp___3) {
#line 210
    ret = 1;
#line 211
    goto done;
  }
  {
#line 213
  csa->fname = fname;
#line 214
  csa->fp = (XFILE *)((void *)0);
#line 215
  csa->count = 0;
#line 216
  csa->c = '\n';
#line 217
  csa->field[0] = (char )'\000';
#line 218
  tmp___4 = 0;
#line 218
  csa->nonint = tmp___4;
#line 218
  csa->empty = tmp___4;
#line 219
  _glp_lib_xprintf("Reading min-cost flow problem data from `%s\'...\n", fname);
#line 221
  csa->fp = _glp_lib_xfopen(fname, "r");
  }
#line 222
  if ((unsigned long )csa->fp == (unsigned long )((void *)0)) {
    {
#line 223
    tmp___5 = _glp_lib_xerrmsg();
#line 223
    _glp_lib_xprintf("Unable to open `%s\' - %s\n", fname, tmp___5);
#line 224
    longjmp((struct __jmp_buf_tag *)(csa->jump), 1);
    }
  }
  {
#line 227
  read_designator(csa);
#line 228
  tmp___6 = strcmp((char const   *)(csa->field), "p");
  }
#line 228
  if (tmp___6 != 0) {
    {
#line 229
    error___0(csa, "problem line missing or invalid");
    }
  }
  {
#line 230
  read_field___1(csa);
#line 231
  tmp___7 = strcmp((char const   *)(csa->field), "min");
  }
#line 231
  if (tmp___7 != 0) {
    {
#line 232
    error___0(csa, "wrong problem designator; `min\' expected");
    }
  }
  {
#line 233
  read_field___1(csa);
#line 234
  tmp___8 = _glp_lib_str2int((char const   *)(csa->field), & nv);
  }
#line 234
  if (tmp___8 == 0) {
#line 234
    if (! (nv >= 0)) {
      {
#line 235
      error___0(csa, "number of nodes missing or invalid");
      }
    }
  } else {
    {
#line 235
    error___0(csa, "number of nodes missing or invalid");
    }
  }
  {
#line 236
  read_field___1(csa);
#line 237
  tmp___9 = _glp_lib_str2int((char const   *)(csa->field), & na);
  }
#line 237
  if (tmp___9 == 0) {
#line 237
    if (! (na >= 0)) {
      {
#line 238
      error___0(csa, "number of arcs missing or invalid");
      }
    }
  } else {
    {
#line 238
    error___0(csa, "number of arcs missing or invalid");
    }
  }
#line 239
  if (na == 1) {
#line 239
    tmp___10 = "";
  } else {
#line 239
    tmp___10 = "s";
  }
#line 239
  if (nv == 1) {
#line 239
    tmp___11 = "";
  } else {
#line 239
    tmp___11 = "s";
  }
  {
#line 239
  _glp_lib_xprintf("Flow network has %d node%s and %d arc%s\n", nv, tmp___11, na,
                   tmp___10);
  }
#line 241
  if (nv > 0) {
    {
#line 241
    glp_add_vertices(G, nv);
    }
  }
  {
#line 242
  end_of_line(csa);
#line 244
  tmp___12 = _glp_lib_xcalloc(1 + nv, (int )sizeof(char ));
#line 244
  flag = (char *)tmp___12;
#line 245
  memset((void *)(flag + 1), 0, (size_t )((unsigned long )nv * sizeof(char )));
  }
#line 246
  if (v_rhs >= 0) {
#line 247
    rhs = 0.0;
#line 248
    i = 1;
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      if (! (i <= nv)) {
#line 248
        goto while_break;
      }
      {
#line 249
      v = *(G->v + i);
#line 250
      memcpy((void */* __restrict  */)((char *)v->data + v_rhs), (void const   */* __restrict  */)(& rhs),
             (size_t )sizeof(double ));
#line 248
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 254
    read_designator(csa);
#line 255
    tmp___13 = strcmp((char const   *)(csa->field), "n");
    }
#line 255
    if (tmp___13 != 0) {
#line 255
      goto while_break___0;
    }
    {
#line 256
    read_field___1(csa);
#line 257
    tmp___14 = _glp_lib_str2int((char const   *)(csa->field), & i);
    }
#line 257
    if (tmp___14 != 0) {
      {
#line 258
      error___0(csa, "node number missing or invalid");
      }
    }
#line 259
    if (1 <= i) {
#line 259
      if (! (i <= nv)) {
        {
#line 260
        error___0(csa, "node number %d out of range", i);
        }
      }
    } else {
      {
#line 260
      error___0(csa, "node number %d out of range", i);
      }
    }
#line 261
    if (*(flag + i)) {
      {
#line 262
      error___0(csa, "duplicate descriptor of node %d", i);
      }
    }
    {
#line 263
    read_field___1(csa);
#line 264
    tmp___15 = _glp_lib_str2num((char const   *)(csa->field), & rhs);
    }
#line 264
    if (tmp___15 != 0) {
      {
#line 265
      error___0(csa, "node supply/demand missing or invalid");
      }
    }
    {
#line 266
    check_int(csa, rhs);
    }
#line 267
    if (v_rhs >= 0) {
      {
#line 268
      v = *(G->v + i);
#line 269
      memcpy((void */* __restrict  */)((char *)v->data + v_rhs), (void const   */* __restrict  */)(& rhs),
             (size_t )sizeof(double ));
      }
    }
    {
#line 271
    *(flag + i) = (char)1;
#line 272
    end_of_line(csa);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 274
  _glp_lib_xfree((void *)flag);
#line 274
  flag = (char *)((void *)0);
#line 276
  k = 1;
  }
  {
#line 276
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 276
    if (! (k <= na)) {
#line 276
      goto while_break___1;
    }
#line 277
    if (k > 1) {
      {
#line 277
      read_designator(csa);
      }
    }
    {
#line 278
    tmp___16 = strcmp((char const   *)(csa->field), "a");
    }
#line 278
    if (tmp___16 != 0) {
      {
#line 279
      error___0(csa, "wrong line designator; `a\' expected");
      }
    }
    {
#line 280
    read_field___1(csa);
#line 281
    tmp___17 = _glp_lib_str2int((char const   *)(csa->field), & i);
    }
#line 281
    if (tmp___17 != 0) {
      {
#line 282
      error___0(csa, "starting node number missing or invalid");
      }
    }
#line 283
    if (1 <= i) {
#line 283
      if (! (i <= nv)) {
        {
#line 284
        error___0(csa, "starting node number %d out of range", i);
        }
      }
    } else {
      {
#line 284
      error___0(csa, "starting node number %d out of range", i);
      }
    }
    {
#line 285
    read_field___1(csa);
#line 286
    tmp___18 = _glp_lib_str2int((char const   *)(csa->field), & j);
    }
#line 286
    if (tmp___18 != 0) {
      {
#line 287
      error___0(csa, "ending node number missing or invalid");
      }
    }
#line 288
    if (1 <= j) {
#line 288
      if (! (j <= nv)) {
        {
#line 289
        error___0(csa, "ending node number %d out of range", j);
        }
      }
    } else {
      {
#line 289
      error___0(csa, "ending node number %d out of range", j);
      }
    }
    {
#line 290
    read_field___1(csa);
#line 291
    tmp___19 = _glp_lib_str2num((char const   *)(csa->field), & low);
    }
#line 291
    if (tmp___19 == 0) {
#line 291
      if (! (low >= 0.0)) {
        {
#line 292
        error___0(csa, "lower bound of arc flow missing or invalid");
        }
      }
    } else {
      {
#line 292
      error___0(csa, "lower bound of arc flow missing or invalid");
      }
    }
    {
#line 293
    check_int(csa, low);
#line 294
    read_field___1(csa);
#line 295
    tmp___20 = _glp_lib_str2num((char const   *)(csa->field), & cap);
    }
#line 295
    if (tmp___20 == 0) {
#line 295
      if (! (cap >= low)) {
        {
#line 296
        error___0(csa, "upper bound of arc flow missing or invalid");
        }
      }
    } else {
      {
#line 296
      error___0(csa, "upper bound of arc flow missing or invalid");
      }
    }
    {
#line 297
    check_int(csa, cap);
#line 298
    read_field___1(csa);
#line 299
    tmp___21 = _glp_lib_str2num((char const   *)(csa->field), & cost);
    }
#line 299
    if (tmp___21 != 0) {
      {
#line 300
      error___0(csa, "per-unit cost of arc flow missing or invalid");
      }
    }
    {
#line 301
    check_int(csa, cost);
#line 302
    a = glp_add_arc(G, i, j);
    }
#line 303
    if (a_low >= 0) {
      {
#line 304
      memcpy((void */* __restrict  */)((char *)a->data + a_low), (void const   */* __restrict  */)(& low),
             (size_t )sizeof(double ));
      }
    }
#line 305
    if (a_cap >= 0) {
      {
#line 306
      memcpy((void */* __restrict  */)((char *)a->data + a_cap), (void const   */* __restrict  */)(& cap),
             (size_t )sizeof(double ));
      }
    }
#line 307
    if (a_cost >= 0) {
      {
#line 308
      memcpy((void */* __restrict  */)((char *)a->data + a_cost), (void const   */* __restrict  */)(& cost),
             (size_t )sizeof(double ));
      }
    }
    {
#line 309
    end_of_line(csa);
#line 276
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 311
  _glp_lib_xprintf("%d lines were read\n", csa->count);
  }
  done: 
#line 312
  if (ret) {
    {
#line 312
    glp_erase_graph(G, G->v_size, G->a_size);
    }
  }
#line 313
  if ((unsigned long )csa->fp != (unsigned long )((void *)0)) {
    {
#line 313
    _glp_lib_xfclose(csa->fp);
    }
  }
#line 314
  if ((unsigned long )flag != (unsigned long )((void *)0)) {
    {
#line 314
    _glp_lib_xfree((void *)flag);
    }
  }
#line 315
  return (ret);
}
}
#line 338 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
int glp_write_mincost(glp_graph *G , int v_rhs , int a_low , int a_cap , int a_cost ,
                      char const   *fname ) 
{ 
  XFILE *fp ;
  glp_vertex *v ;
  glp_arc *a ;
  int i ;
  int count ;
  int ret ;
  double rhs ;
  double low ;
  double cap ;
  double cost ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 343
  count = 0;
#line 345
  if (v_rhs >= 0) {
#line 345
    if (v_rhs > G->v_size - (int )sizeof(double )) {
      {
#line 346
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c", 346);
#line 346
      (*tmp)("glp_write_mincost: v_rhs = %d; invalid offset\n", v_rhs);
      }
    }
  }
#line 348
  if (a_low >= 0) {
#line 348
    if (a_low > G->a_size - (int )sizeof(double )) {
      {
#line 349
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 349);
#line 349
      (*tmp___0)("glp_write_mincost: a_low = %d; invalid offset\n", a_low);
      }
    }
  }
#line 351
  if (a_cap >= 0) {
#line 351
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 352
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 352);
#line 352
      (*tmp___1)("glp_write_mincost: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
#line 354
  if (a_cost >= 0) {
#line 354
    if (a_cost > G->a_size - (int )sizeof(double )) {
      {
#line 355
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 355);
#line 355
      (*tmp___2)("glp_write_mincost: a_cost = %d; invalid offset\n", a_cost);
      }
    }
  }
  {
#line 357
  _glp_lib_xprintf("Writing min-cost flow problem data to `%s\'...\n", fname);
#line 359
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 360
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 361
    tmp___3 = _glp_lib_xerrmsg();
#line 361
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp___3);
#line 362
    ret = 1;
    }
#line 363
    goto done;
  }
#line 365
  if ((unsigned long )G->name == (unsigned long )((void *)0)) {
#line 365
    tmp___4 = "unknown";
  } else {
#line 365
    tmp___4 = (char const   *)G->name;
  }
  {
#line 365
  _glp_lib_xfprintf(fp, "c %s\n", tmp___4);
#line 365
  count ++;
#line 367
  _glp_lib_xfprintf(fp, "p min %d %d\n", G->nv, G->na);
#line 367
  count ++;
  }
#line 368
  if (v_rhs >= 0) {
#line 369
    i = 1;
    {
#line 369
    while (1) {
      while_continue: /* CIL Label */ ;
#line 369
      if (! (i <= G->nv)) {
#line 369
        goto while_break;
      }
      {
#line 370
      v = *(G->v + i);
#line 371
      memcpy((void */* __restrict  */)(& rhs), (void const   */* __restrict  */)((char *)v->data + v_rhs),
             (size_t )sizeof(double ));
      }
#line 372
      if (rhs != 0.0) {
        {
#line 373
        _glp_lib_xfprintf(fp, "n %d %.*g\n", i, 15, rhs);
#line 373
        count ++;
        }
      }
#line 369
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 376
  i = 1;
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! (i <= G->nv)) {
#line 376
      goto while_break___0;
    }
#line 377
    v = *(G->v + i);
#line 378
    a = v->out;
    {
#line 378
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 378
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 378
        goto while_break___1;
      }
#line 379
      if (a_low >= 0) {
        {
#line 380
        memcpy((void */* __restrict  */)(& low), (void const   */* __restrict  */)((char *)a->data + a_low),
               (size_t )sizeof(double ));
        }
      } else {
#line 382
        low = 0.0;
      }
#line 383
      if (a_cap >= 0) {
        {
#line 384
        memcpy((void */* __restrict  */)(& cap), (void const   */* __restrict  */)((char *)a->data + a_cap),
               (size_t )sizeof(double ));
        }
      } else {
#line 386
        cap = 1.0;
      }
#line 387
      if (a_cost >= 0) {
        {
#line 388
        memcpy((void */* __restrict  */)(& cost), (void const   */* __restrict  */)((char *)a->data + a_cost),
               (size_t )sizeof(double ));
        }
      } else {
#line 390
        cost = 0.0;
      }
      {
#line 391
      _glp_lib_xfprintf(fp, "a %d %d %.*g %.*g %.*g\n", (a->tail)->i, (a->head)->i,
                        15, low, 15, cap, 15, cost);
#line 391
      count ++;
#line 378
      a = a->t_next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 376
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 396
  _glp_lib_xfprintf(fp, "c eof\n");
#line 396
  count ++;
#line 397
  _glp_lib_xfflush(fp);
#line 398
  tmp___6 = _glp_lib_xferror(fp);
  }
#line 398
  if (tmp___6) {
    {
#line 399
    tmp___5 = _glp_lib_xerrmsg();
#line 399
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___5);
#line 400
    ret = 1;
    }
#line 401
    goto done;
  }
  {
#line 403
  _glp_lib_xprintf("%d lines were written\n", count);
#line 404
  ret = 0;
  }
  done: 
#line 405
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 405
    _glp_lib_xfclose(fp);
    }
  }
#line 406
  return (ret);
}
}
#line 429 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
int glp_read_maxflow(glp_graph *G , int *_s , int *_t , int a_cap , char const   *fname ) 
{ 
  struct csa___6 _csa ;
  struct csa___6 *csa ;
  glp_arc *a ;
  int i ;
  int j ;
  int k ;
  int s ;
  int t ;
  int nv ;
  int na ;
  int ret ;
  double cap ;
  xerror_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 431
  csa = & _csa;
#line 433
  ret = 0;
#line 435
  if (a_cap >= 0) {
#line 435
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 436
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c", 436);
#line 436
      (*tmp)("glp_read_maxflow: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
  {
#line 438
  glp_erase_graph(G, G->v_size, G->a_size);
#line 439
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(csa->jump));
  }
#line 439
  if (tmp___0) {
#line 440
    ret = 1;
#line 441
    goto done;
  }
  {
#line 443
  csa->fname = fname;
#line 444
  csa->fp = (XFILE *)((void *)0);
#line 445
  csa->count = 0;
#line 446
  csa->c = '\n';
#line 447
  csa->field[0] = (char )'\000';
#line 448
  tmp___1 = 0;
#line 448
  csa->nonint = tmp___1;
#line 448
  csa->empty = tmp___1;
#line 449
  _glp_lib_xprintf("Reading maximum flow problem data from `%s\'...\n", fname);
#line 451
  csa->fp = _glp_lib_xfopen(fname, "r");
  }
#line 452
  if ((unsigned long )csa->fp == (unsigned long )((void *)0)) {
    {
#line 453
    tmp___2 = _glp_lib_xerrmsg();
#line 453
    _glp_lib_xprintf("Unable to open `%s\' - %s\n", fname, tmp___2);
#line 454
    longjmp((struct __jmp_buf_tag *)(csa->jump), 1);
    }
  }
  {
#line 457
  read_designator(csa);
#line 458
  tmp___3 = strcmp((char const   *)(csa->field), "p");
  }
#line 458
  if (tmp___3 != 0) {
    {
#line 459
    error___0(csa, "problem line missing or invalid");
    }
  }
  {
#line 460
  read_field___1(csa);
#line 461
  tmp___4 = strcmp((char const   *)(csa->field), "max");
  }
#line 461
  if (tmp___4 != 0) {
    {
#line 462
    error___0(csa, "wrong problem designator; `max\' expected");
    }
  }
  {
#line 463
  read_field___1(csa);
#line 464
  tmp___5 = _glp_lib_str2int((char const   *)(csa->field), & nv);
  }
#line 464
  if (tmp___5 == 0) {
#line 464
    if (! (nv >= 2)) {
      {
#line 465
      error___0(csa, "number of nodes missing or invalid");
      }
    }
  } else {
    {
#line 465
    error___0(csa, "number of nodes missing or invalid");
    }
  }
  {
#line 466
  read_field___1(csa);
#line 467
  tmp___6 = _glp_lib_str2int((char const   *)(csa->field), & na);
  }
#line 467
  if (tmp___6 == 0) {
#line 467
    if (! (na >= 0)) {
      {
#line 468
      error___0(csa, "number of arcs missing or invalid");
      }
    }
  } else {
    {
#line 468
    error___0(csa, "number of arcs missing or invalid");
    }
  }
#line 469
  if (na == 1) {
#line 469
    tmp___7 = "";
  } else {
#line 469
    tmp___7 = "s";
  }
#line 469
  if (nv == 1) {
#line 469
    tmp___8 = "";
  } else {
#line 469
    tmp___8 = "s";
  }
  {
#line 469
  _glp_lib_xprintf("Flow network has %d node%s and %d arc%s\n", nv, tmp___8, na, tmp___7);
  }
#line 471
  if (nv > 0) {
    {
#line 471
    glp_add_vertices(G, nv);
    }
  }
  {
#line 472
  end_of_line(csa);
#line 474
  t = 0;
#line 474
  s = t;
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 476
    read_designator(csa);
#line 477
    tmp___9 = strcmp((char const   *)(csa->field), "n");
    }
#line 477
    if (tmp___9 != 0) {
#line 477
      goto while_break;
    }
    {
#line 478
    read_field___1(csa);
#line 479
    tmp___10 = _glp_lib_str2int((char const   *)(csa->field), & i);
    }
#line 479
    if (tmp___10 != 0) {
      {
#line 480
      error___0(csa, "node number missing or invalid");
      }
    }
#line 481
    if (1 <= i) {
#line 481
      if (! (i <= nv)) {
        {
#line 482
        error___0(csa, "node number %d out of range", i);
        }
      }
    } else {
      {
#line 482
      error___0(csa, "node number %d out of range", i);
      }
    }
    {
#line 483
    read_field___1(csa);
#line 484
    tmp___12 = strcmp((char const   *)(csa->field), "s");
    }
#line 484
    if (tmp___12 == 0) {
#line 485
      if (s > 0) {
        {
#line 486
        error___0(csa, "only one source node allowed");
        }
      }
#line 487
      s = i;
    } else {
      {
#line 489
      tmp___11 = strcmp((char const   *)(csa->field), "t");
      }
#line 489
      if (tmp___11 == 0) {
#line 490
        if (t > 0) {
          {
#line 491
          error___0(csa, "only one sink node allowed");
          }
        }
#line 492
        t = i;
      } else {
        {
#line 495
        error___0(csa, "wrong node designator; `s\' or `t\' expected");
        }
      }
    }
#line 496
    if (s > 0) {
#line 496
      if (s == t) {
        {
#line 497
        error___0(csa, "source and sink nodes must be distinct");
        }
      }
    }
    {
#line 498
    end_of_line(csa);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  if (s == 0) {
    {
#line 501
    error___0(csa, "source node descriptor missing\n");
    }
  }
#line 502
  if (t == 0) {
    {
#line 503
    error___0(csa, "sink node descriptor missing\n");
    }
  }
#line 504
  if ((unsigned long )_s != (unsigned long )((void *)0)) {
#line 504
    *_s = s;
  }
#line 505
  if ((unsigned long )_t != (unsigned long )((void *)0)) {
#line 505
    *_t = t;
  }
#line 507
  k = 1;
  {
#line 507
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 507
    if (! (k <= na)) {
#line 507
      goto while_break___0;
    }
#line 508
    if (k > 1) {
      {
#line 508
      read_designator(csa);
      }
    }
    {
#line 509
    tmp___13 = strcmp((char const   *)(csa->field), "a");
    }
#line 509
    if (tmp___13 != 0) {
      {
#line 510
      error___0(csa, "wrong line designator; `a\' expected");
      }
    }
    {
#line 511
    read_field___1(csa);
#line 512
    tmp___14 = _glp_lib_str2int((char const   *)(csa->field), & i);
    }
#line 512
    if (tmp___14 != 0) {
      {
#line 513
      error___0(csa, "starting node number missing or invalid");
      }
    }
#line 514
    if (1 <= i) {
#line 514
      if (! (i <= nv)) {
        {
#line 515
        error___0(csa, "starting node number %d out of range", i);
        }
      }
    } else {
      {
#line 515
      error___0(csa, "starting node number %d out of range", i);
      }
    }
    {
#line 516
    read_field___1(csa);
#line 517
    tmp___15 = _glp_lib_str2int((char const   *)(csa->field), & j);
    }
#line 517
    if (tmp___15 != 0) {
      {
#line 518
      error___0(csa, "ending node number missing or invalid");
      }
    }
#line 519
    if (1 <= j) {
#line 519
      if (! (j <= nv)) {
        {
#line 520
        error___0(csa, "ending node number %d out of range", j);
        }
      }
    } else {
      {
#line 520
      error___0(csa, "ending node number %d out of range", j);
      }
    }
    {
#line 521
    read_field___1(csa);
#line 522
    tmp___16 = _glp_lib_str2num((char const   *)(csa->field), & cap);
    }
#line 522
    if (tmp___16 == 0) {
#line 522
      if (! (cap >= 0.0)) {
        {
#line 523
        error___0(csa, "arc capacity missing or invalid");
        }
      }
    } else {
      {
#line 523
      error___0(csa, "arc capacity missing or invalid");
      }
    }
    {
#line 524
    check_int(csa, cap);
#line 525
    a = glp_add_arc(G, i, j);
    }
#line 526
    if (a_cap >= 0) {
      {
#line 527
      memcpy((void */* __restrict  */)((char *)a->data + a_cap), (void const   */* __restrict  */)(& cap),
             (size_t )sizeof(double ));
      }
    }
    {
#line 528
    end_of_line(csa);
#line 507
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 530
  _glp_lib_xprintf("%d lines were read\n", csa->count);
  }
  done: 
#line 531
  if (ret) {
    {
#line 531
    glp_erase_graph(G, G->v_size, G->a_size);
    }
  }
#line 532
  if ((unsigned long )csa->fp != (unsigned long )((void *)0)) {
    {
#line 532
    _glp_lib_xfclose(csa->fp);
    }
  }
#line 533
  return (ret);
}
}
#line 556 "/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c"
int glp_write_maxflow(glp_graph *G , int s , int t , int a_cap , char const   *fname ) 
{ 
  XFILE *fp ;
  glp_vertex *v ;
  glp_arc *a ;
  int i ;
  int count ;
  int ret ;
  double cap ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 561
  count = 0;
#line 563
  if (1 <= s) {
#line 563
    if (! (s <= G->nv)) {
      {
#line 564
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c", 564);
#line 564
      (*tmp)("glp_write_maxflow: s = %d; source node number out of range\n", s);
      }
    }
  } else {
    {
#line 564
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c", 564);
#line 564
    (*tmp)("glp_write_maxflow: s = %d; source node number out of range\n", s);
    }
  }
#line 566
  if (1 <= t) {
#line 566
    if (! (t <= G->nv)) {
      {
#line 567
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 567);
#line 567
      (*tmp___0)("glp_write_maxflow: t = %d: sink node number out of range\n", t);
      }
    }
  } else {
    {
#line 567
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c", 567);
#line 567
    (*tmp___0)("glp_write_maxflow: t = %d: sink node number out of range\n", t);
    }
  }
#line 569
  if (a_cap >= 0) {
#line 569
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 570
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmx.c",
                                 570);
#line 570
      (*tmp___1)("glp_write_mincost: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
  {
#line 572
  _glp_lib_xprintf("Writing maximum flow problem data to `%s\'...\n", fname);
#line 574
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 575
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 576
    tmp___2 = _glp_lib_xerrmsg();
#line 576
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp___2);
#line 577
    ret = 1;
    }
#line 578
    goto done;
  }
#line 580
  if ((unsigned long )G->name == (unsigned long )((void *)0)) {
#line 580
    tmp___3 = "unknown";
  } else {
#line 580
    tmp___3 = (char const   *)G->name;
  }
  {
#line 580
  _glp_lib_xfprintf(fp, "c %s\n", tmp___3);
#line 580
  count ++;
#line 582
  _glp_lib_xfprintf(fp, "p max %d %d\n", G->nv, G->na);
#line 582
  count ++;
#line 583
  _glp_lib_xfprintf(fp, "n %d s\n", s);
#line 583
  count ++;
#line 584
  _glp_lib_xfprintf(fp, "n %d t\n", t);
#line 584
  count ++;
#line 585
  i = 1;
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! (i <= G->nv)) {
#line 585
      goto while_break;
    }
#line 586
    v = *(G->v + i);
#line 587
    a = v->out;
    {
#line 587
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 587
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 587
        goto while_break___0;
      }
#line 588
      if (a_cap >= 0) {
        {
#line 589
        memcpy((void */* __restrict  */)(& cap), (void const   */* __restrict  */)((char *)a->data + a_cap),
               (size_t )sizeof(double ));
        }
      } else {
#line 591
        cap = 1.0;
      }
      {
#line 592
      _glp_lib_xfprintf(fp, "a %d %d %.*g\n", (a->tail)->i, (a->head)->i, 15, cap);
#line 592
      count ++;
#line 587
      a = a->t_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 585
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 596
  _glp_lib_xfprintf(fp, "c eof\n");
#line 596
  count ++;
#line 597
  _glp_lib_xfflush(fp);
#line 598
  tmp___5 = _glp_lib_xferror(fp);
  }
#line 598
  if (tmp___5) {
    {
#line 599
    tmp___4 = _glp_lib_xerrmsg();
#line 599
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___4);
#line 600
    ret = 1;
    }
#line 601
    goto done;
  }
  {
#line 603
  _glp_lib_xprintf("%d lines were written\n", count);
#line 604
  ret = 0;
  }
  done: 
#line 605
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 605
    _glp_lib_xfclose(fp);
    }
  }
#line 606
  return (ret);
}
}
#line 60 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c"
DMP *_glp_dmp_create_pool(void) 
{ 
  DMP *pool ;
  int k ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 66
  tmp = _glp_lib_xmalloc((int )sizeof(DMP ));
#line 66
  pool = (DMP *)tmp;
#line 70
  k = 0;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (k <= 31)) {
#line 70
      goto while_break;
    }
#line 70
    pool->avail[k] = (void *)0;
#line 70
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  pool->block = (void *)0;
#line 72
  pool->used = 8000;
#line 73
  tmp___0 = 0;
#line 73
  pool->count.hi = tmp___0;
#line 73
  pool->count.lo = tmp___0;
#line 74
  return (pool);
}
}
#line 100 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c"
void *_glp_dmp_get_atom(DMP *pool , int size ) 
{ 
  void *atom ;
  int k ;
  xerror_t tmp ;
  int tmp___0 ;
  void *block ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 106
  if (1 <= size) {
#line 106
    if (! (size <= 256)) {
      {
#line 107
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c", 107);
#line 107
      (*tmp)("dmp_get_atom: size = %d; invalid atom size\n", size);
      }
    }
  } else {
    {
#line 107
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c", 107);
#line 107
    (*tmp)("dmp_get_atom: size = %d; invalid atom size\n", size);
    }
  }
#line 113
  size = ((size + 7) / 8) * 8;
#line 118
  size = ((size + 7) / 8) * 8;
#line 120
  k = size / 8 - 1;
#line 121
  if (0 <= k) {
#line 121
    if (k <= 31) {
#line 121
      tmp___0 = 1;
    } else {
      {
#line 121
      _glp_lib_xassert("0 <= k && k <= 31", "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c",
                       121);
#line 121
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 121
    _glp_lib_xassert("0 <= k && k <= 31", "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c",
                     121);
#line 121
    tmp___0 = 1;
    }
  }
#line 123
  if ((unsigned long )pool->avail[k] == (unsigned long )((void *)0)) {
#line 125
    if (pool->used + size > 8000) {
      {
#line 127
      tmp___1 = _glp_lib_xmalloc(8000);
#line 127
      block = tmp___1;
#line 128
      *((void **)block) = pool->block;
#line 129
      pool->block = block;
#line 130
      pool->used = (int )(((sizeof(void *) + 7UL) / 8UL) * 8UL);
      }
    }
#line 133
    atom = (void *)((char *)pool->block + pool->used);
#line 134
    pool->used += size;
  } else {
#line 138
    atom = pool->avail[k];
#line 139
    pool->avail[k] = *((void **)atom);
  }
  {
#line 141
  memset(atom, '?', (size_t )size);
#line 143
  (pool->count.lo) ++;
  }
#line 144
  if (pool->count.lo == 0) {
#line 144
    (pool->count.hi) ++;
  }
#line 150
  return (atom);
}
}
#line 174 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c"
void _glp_dmp_free_atom(DMP *pool , void *atom , int size ) 
{ 
  int k ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 176
  if (1 <= size) {
#line 176
    if (! (size <= 256)) {
      {
#line 177
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c", 177);
#line 177
      (*tmp)("dmp_free_atom: size = %d; invalid atom size\n", size);
      }
    }
  } else {
    {
#line 177
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c", 177);
#line 177
    (*tmp)("dmp_free_atom: size = %d; invalid atom size\n", size);
    }
  }
#line 182
  if (pool->count.lo == 0) {
#line 182
    if (pool->count.hi == 0) {
      {
#line 183
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c",
                                 183);
#line 183
      (*tmp___0)("dmp_free_atom: pool allocation error\n");
      }
    }
  }
#line 190
  size = ((size + 7) / 8) * 8;
#line 195
  size = ((size + 7) / 8) * 8;
#line 197
  k = size / 8 - 1;
#line 198
  if (0 <= k) {
#line 198
    if (k <= 31) {
#line 198
      tmp___1 = 1;
    } else {
      {
#line 198
      _glp_lib_xassert("0 <= k && k <= 31", "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c",
                       198);
#line 198
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 198
    _glp_lib_xassert("0 <= k && k <= 31", "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c",
                     198);
#line 198
    tmp___1 = 1;
    }
  }
#line 200
  *((void **)atom) = pool->avail[k];
#line 201
  pool->avail[k] = atom;
#line 203
  (pool->count.lo) --;
#line 204
  if ((unsigned int )pool->count.lo == 4294967295U) {
#line 204
    (pool->count.hi) --;
  }
#line 205
  return;
}
}
#line 228 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c"
xlong_t _glp_dmp_in_use(DMP *pool ) 
{ 


  {
#line 229
  return (pool->count);
}
}
#line 248 "/home/wslee/benchmarks/glpk-4.38/src/glpdmp.c"
void _glp_dmp_delete_pool(DMP *pool ) 
{ 
  void *block ;

  {
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )pool->block != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
#line 250
    block = pool->block;
#line 251
    pool->block = *((void **)block);
#line 252
    _glp_lib_xfree(block);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  _glp_lib_xfree((void *)pool);
  }
#line 255
  return;
}
}
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.h"
int _glp_read_cpxlp(glp_prob *lp , char const   *fname ) ;
#line 34
int _glp_write_cpxlp(glp_prob *lp , char const   *fname ) ;
#line 100 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void fatal(struct dsa___3 *dsa , char *fmt___0  , ...) 
{ 
  va_list arg ;
  char msg[4096] ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 104
  __builtin_va_start(arg, fmt___0);
#line 105
  vsprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)fmt___0,
           arg);
#line 106
  tmp = strlen((char const   *)(msg));
  }
#line 106
  if (tmp <= 4095U) {
#line 106
    tmp___0 = 1;
  } else {
    {
#line 106
    _glp_lib_xassert("strlen(msg) <= 4095", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                     106);
#line 106
    tmp___0 = 1;
    }
  }
  {
#line 107
  __builtin_va_end(arg);
#line 108
  _glp_lib_xprintf("%s:%d: %s\n", dsa->fname, dsa->count, msg);
#line 109
  longjmp((struct __jmp_buf_tag *)(dsa->jump), 1);
  }
}
}
#line 113 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void read_char___2(struct dsa___3 *dsa ) 
{ 
  int c ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 116
  if (dsa->c != -1) {
#line 116
    tmp = 1;
  } else {
    {
#line 116
    _glp_lib_xassert("dsa->c != EOF", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                     116);
#line 116
    tmp = 1;
    }
  }
#line 117
  if (dsa->c == 10) {
#line 117
    (dsa->count) ++;
  }
  {
#line 118
  c = fgetc(dsa->fp);
#line 119
  tmp___2 = ferror(dsa->fp);
  }
#line 119
  if (tmp___2) {
    {
#line 120
    tmp___0 = __errno_location();
#line 120
    tmp___1 = strerror(*tmp___0);
#line 120
    fatal(dsa, (char *)"read error - %s", tmp___1);
    }
  }
  {
#line 121
  tmp___5 = feof(dsa->fp);
  }
#line 121
  if (tmp___5) {
#line 122
    if (dsa->c == 10) {
#line 123
      (dsa->count) --;
#line 124
      c = -1;
    } else {
      {
#line 127
      _glp_lib_xprintf("%s:%d: warning: missing final LF\n", dsa->fname, dsa->count);
#line 129
      c = '\n';
      }
    }
  } else
#line 132
  if (! (c == 10)) {
    {
#line 134
    tmp___4 = __ctype_b_loc();
    }
#line 134
    if ((int const   )*(*tmp___4 + c) & 8192) {
#line 135
      c = ' ';
    } else {
      {
#line 136
      tmp___3 = __ctype_b_loc();
      }
#line 136
      if ((int const   )*(*tmp___3 + c) & 2) {
        {
#line 137
        fatal(dsa, (char *)"invalid control character 0x%02X", c);
        }
      }
    }
  }
#line 138
  dsa->c = c;
#line 139
  return;
}
}
#line 142 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void add_char(struct dsa___3 *dsa ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
#line 144
  if ((unsigned long )dsa->imlen == sizeof(dsa->image) - 1UL) {
    {
#line 145
    fatal(dsa, (char *)"token `%.15s...\' too long", dsa->image);
    }
  }
  {
#line 146
  tmp = dsa->imlen;
#line 146
  (dsa->imlen) ++;
#line 146
  dsa->image[tmp] = (char )dsa->c;
#line 147
  dsa->image[dsa->imlen] = (char )'\000';
#line 148
  read_char___2(dsa);
  }
#line 149
  return;
}
}
#line 152 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static int the_same(char *s1 , char *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((int )*s1 != 0)) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp = tolower((int )((unsigned char )*s1));
#line 155
    tmp___0 = tolower((int )((unsigned char )*s2));
    }
#line 155
    if (tmp != tmp___0) {
#line 156
      return (0);
    }
#line 154
    s1 ++;
#line 154
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (1);
}
}
#line 160 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void scan_token___0(struct dsa___3 *dsa ) 
{ 
  int flag ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  unsigned short const   **tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  int tmp___40 ;
  unsigned short const   **tmp___41 ;
  unsigned short const   **tmp___42 ;
  char *tmp___43 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;

  {
#line 163
  dsa->token = -1;
#line 164
  dsa->image[0] = (char )'\000';
#line 165
  dsa->imlen = 0;
#line 166
  dsa->value = 0.0;
  loop: 
#line 167
  flag = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (dsa->c == 32)) {
#line 169
      goto while_break;
    }
    {
#line 169
    read_char___2(dsa);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (dsa->c == -1) {
#line 172
    dsa->token = 0;
  } else
#line 173
  if (dsa->c == 10) {
    {
#line 174
    read_char___2(dsa);
#line 176
    tmp = __ctype_b_loc();
    }
#line 176
    if ((int const   )*(*tmp + dsa->c) & 1024) {
#line 177
      flag = 1;
#line 178
      goto name;
    }
#line 180
    goto loop;
  } else
#line 182
  if (dsa->c == 92) {
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 184
      if (! (dsa->c != 10)) {
#line 184
        goto while_break___0;
      }
      {
#line 184
      read_char___2(dsa);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 185
    goto loop;
  } else {
    {
#line 187
    tmp___42 = __ctype_b_loc();
    }
#line 187
    if ((int const   )*(*tmp___42 + dsa->c) & 1024) {
#line 187
      goto name;
    } else
#line 187
    if (dsa->c != 46) {
      {
#line 187
      tmp___43 = strchr("!\"#$%&()/,.;?@_`\'{}|~", dsa->c);
      }
#line 187
      if ((unsigned long )tmp___43 != (unsigned long )((void *)0)) {
        name: 
#line 190
        dsa->token = 9;
        {
#line 191
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 191
          tmp___0 = __ctype_b_loc();
          }
#line 191
          if (! ((int const   )*(*tmp___0 + dsa->c) & 8)) {
            {
#line 191
            tmp___1 = strchr("!\"#$%&()/,.;?@_`\'{}|~", dsa->c);
            }
#line 191
            if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 191
              goto while_break___1;
            }
          }
          {
#line 192
          add_char(dsa);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 193
        if (flag) {
          {
#line 195
          tmp___34 = the_same(dsa->image, (char *)"minimize");
          }
#line 195
          if (tmp___34) {
#line 196
            dsa->token = 1;
          } else {
            {
#line 197
            tmp___33 = the_same(dsa->image, (char *)"minimum");
            }
#line 197
            if (tmp___33) {
#line 198
              dsa->token = 1;
            } else {
              {
#line 199
              tmp___32 = the_same(dsa->image, (char *)"min");
              }
#line 199
              if (tmp___32) {
#line 200
                dsa->token = 1;
              } else {
                {
#line 201
                tmp___31 = the_same(dsa->image, (char *)"maximize");
                }
#line 201
                if (tmp___31) {
#line 202
                  dsa->token = 2;
                } else {
                  {
#line 203
                  tmp___30 = the_same(dsa->image, (char *)"maximum");
                  }
#line 203
                  if (tmp___30) {
#line 204
                    dsa->token = 2;
                  } else {
                    {
#line 205
                    tmp___29 = the_same(dsa->image, (char *)"max");
                    }
#line 205
                    if (tmp___29) {
#line 206
                      dsa->token = 2;
                    } else {
                      {
#line 207
                      tmp___28 = the_same(dsa->image, (char *)"subject");
                      }
#line 207
                      if (tmp___28) {
#line 208
                        if (dsa->c == 32) {
                          {
#line 209
                          read_char___2(dsa);
#line 210
                          tmp___5 = tolower(dsa->c);
                          }
#line 210
                          if (tmp___5 == 116) {
                            {
#line 211
                            dsa->token = 3;
#line 212
                            tmp___2 = dsa->imlen;
#line 212
                            (dsa->imlen) ++;
#line 212
                            dsa->image[tmp___2] = (char )' ';
#line 213
                            dsa->image[dsa->imlen] = (char )'\000';
#line 214
                            add_char(dsa);
#line 215
                            tmp___3 = tolower(dsa->c);
                            }
#line 215
                            if (tmp___3 != 111) {
                              {
#line 216
                              fatal(dsa, (char *)"keyword `subject to\' incomplete");
                              }
                            }
                            {
#line 217
                            add_char(dsa);
#line 218
                            tmp___4 = __ctype_b_loc();
                            }
#line 218
                            if ((int const   )*(*tmp___4 + dsa->c) & 1024) {
                              {
#line 219
                              fatal(dsa, (char *)"keyword `%s%c...\' not recognized",
                                    dsa->image, dsa->c);
                              }
                            }
                          }
                        }
                      } else {
                        {
#line 224
                        tmp___27 = the_same(dsa->image, (char *)"such");
                        }
#line 224
                        if (tmp___27) {
#line 225
                          if (dsa->c == 32) {
                            {
#line 226
                            read_char___2(dsa);
#line 227
                            tmp___11 = tolower(dsa->c);
                            }
#line 227
                            if (tmp___11 == 116) {
                              {
#line 228
                              dsa->token = 3;
#line 229
                              tmp___6 = dsa->imlen;
#line 229
                              (dsa->imlen) ++;
#line 229
                              dsa->image[tmp___6] = (char )' ';
#line 230
                              dsa->image[dsa->imlen] = (char )'\000';
#line 231
                              add_char(dsa);
#line 232
                              tmp___7 = tolower(dsa->c);
                              }
#line 232
                              if (tmp___7 != 104) {
                                err: 
                                {
#line 233
                                fatal(dsa, (char *)"keyword `such that\' incomplete");
                                }
                              }
                              {
#line 234
                              add_char(dsa);
#line 235
                              tmp___8 = tolower(dsa->c);
                              }
#line 235
                              if (tmp___8 != 97) {
#line 235
                                goto err;
                              }
                              {
#line 236
                              add_char(dsa);
#line 237
                              tmp___9 = tolower(dsa->c);
                              }
#line 237
                              if (tmp___9 != 116) {
#line 237
                                goto err;
                              }
                              {
#line 238
                              add_char(dsa);
#line 239
                              tmp___10 = __ctype_b_loc();
                              }
#line 239
                              if ((int const   )*(*tmp___10 + dsa->c) & 1024) {
                                {
#line 240
                                fatal(dsa, (char *)"keyword `%s%c...\' not recognized",
                                      dsa->image, dsa->c);
                                }
                              }
                            }
                          }
                        } else {
                          {
#line 245
                          tmp___26 = the_same(dsa->image, (char *)"st");
                          }
#line 245
                          if (tmp___26) {
#line 246
                            dsa->token = 3;
                          } else {
                            {
#line 247
                            tmp___25 = the_same(dsa->image, (char *)"s.t.");
                            }
#line 247
                            if (tmp___25) {
#line 248
                              dsa->token = 3;
                            } else {
                              {
#line 249
                              tmp___24 = the_same(dsa->image, (char *)"st.");
                              }
#line 249
                              if (tmp___24) {
#line 250
                                dsa->token = 3;
                              } else {
                                {
#line 251
                                tmp___23 = the_same(dsa->image, (char *)"bounds");
                                }
#line 251
                                if (tmp___23) {
#line 252
                                  dsa->token = 4;
                                } else {
                                  {
#line 253
                                  tmp___22 = the_same(dsa->image, (char *)"bound");
                                  }
#line 253
                                  if (tmp___22) {
#line 254
                                    dsa->token = 4;
                                  } else {
                                    {
#line 255
                                    tmp___21 = the_same(dsa->image, (char *)"general");
                                    }
#line 255
                                    if (tmp___21) {
#line 256
                                      dsa->token = 5;
                                    } else {
                                      {
#line 257
                                      tmp___20 = the_same(dsa->image, (char *)"generals");
                                      }
#line 257
                                      if (tmp___20) {
#line 258
                                        dsa->token = 5;
                                      } else {
                                        {
#line 259
                                        tmp___19 = the_same(dsa->image, (char *)"gen");
                                        }
#line 259
                                        if (tmp___19) {
#line 260
                                          dsa->token = 5;
                                        } else {
                                          {
#line 261
                                          tmp___18 = the_same(dsa->image, (char *)"integer");
                                          }
#line 261
                                          if (tmp___18) {
#line 262
                                            dsa->token = 6;
                                          } else {
                                            {
#line 263
                                            tmp___17 = the_same(dsa->image, (char *)"integers");
                                            }
#line 263
                                            if (tmp___17) {
#line 264
                                              dsa->token = 6;
                                            } else {
                                              {
#line 265
                                              tmp___16 = the_same(dsa->image, (char *)"int");
                                              }
#line 265
                                              if (tmp___16) {
#line 266
                                                dsa->token = 6;
                                              } else {
                                                {
#line 267
                                                tmp___15 = the_same(dsa->image, (char *)"binary");
                                                }
#line 267
                                                if (tmp___15) {
#line 268
                                                  dsa->token = 7;
                                                } else {
                                                  {
#line 269
                                                  tmp___14 = the_same(dsa->image,
                                                                      (char *)"binaries");
                                                  }
#line 269
                                                  if (tmp___14) {
#line 270
                                                    dsa->token = 7;
                                                  } else {
                                                    {
#line 271
                                                    tmp___13 = the_same(dsa->image,
                                                                        (char *)"bin");
                                                    }
#line 271
                                                    if (tmp___13) {
#line 272
                                                      dsa->token = 7;
                                                    } else {
                                                      {
#line 273
                                                      tmp___12 = the_same(dsa->image,
                                                                          (char *)"end");
                                                      }
#line 273
                                                      if (tmp___12) {
#line 274
                                                        dsa->token = 8;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
#line 187
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 277
      tmp___41 = __ctype_b_loc();
      }
#line 277
      if ((int const   )*(*tmp___41 + dsa->c) & 2048) {
#line 277
        goto _L___0;
      } else
#line 277
      if (dsa->c == 46) {
        _L___0: /* CIL Label */ 
#line 279
        dsa->token = 10;
        {
#line 281
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 281
          tmp___35 = __ctype_b_loc();
          }
#line 281
          if (! ((int const   )*(*tmp___35 + dsa->c) & 2048)) {
#line 281
            goto while_break___2;
          }
          {
#line 281
          add_char(dsa);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 284
        if (dsa->c == 46) {
          {
#line 285
          add_char(dsa);
          }
#line 286
          if (dsa->imlen == 1) {
            {
#line 286
            tmp___36 = __ctype_b_loc();
            }
#line 286
            if (! ((int const   )*(*tmp___36 + dsa->c) & 2048)) {
              {
#line 287
              fatal(dsa, (char *)"invalid use of decimal point");
              }
            }
          }
          {
#line 288
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 288
            tmp___37 = __ctype_b_loc();
            }
#line 288
            if (! ((int const   )*(*tmp___37 + dsa->c) & 2048)) {
#line 288
              goto while_break___3;
            }
            {
#line 288
            add_char(dsa);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 291
        if (dsa->c == 101) {
#line 291
          goto _L;
        } else
#line 291
        if (dsa->c == 69) {
          _L: /* CIL Label */ 
          {
#line 292
          add_char(dsa);
          }
#line 293
          if (dsa->c == 43) {
            {
#line 293
            add_char(dsa);
            }
          } else
#line 293
          if (dsa->c == 45) {
            {
#line 293
            add_char(dsa);
            }
          }
          {
#line 294
          tmp___38 = __ctype_b_loc();
          }
#line 294
          if (! ((int const   )*(*tmp___38 + dsa->c) & 2048)) {
            {
#line 295
            fatal(dsa, (char *)"numeric constant `%s\' incomplete", dsa->image);
            }
          }
          {
#line 297
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 297
            tmp___39 = __ctype_b_loc();
            }
#line 297
            if (! ((int const   )*(*tmp___39 + dsa->c) & 2048)) {
#line 297
              goto while_break___4;
            }
            {
#line 297
            add_char(dsa);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 300
        tmp___40 = _glp_lib_str2num((char const   *)(dsa->image), & dsa->value);
        }
#line 300
        if (tmp___40) {
          {
#line 301
          fatal(dsa, (char *)"numeric constant `%s\' out of range", dsa->image);
          }
        }
      } else
#line 304
      if (dsa->c == 43) {
        {
#line 305
        dsa->token = 11;
#line 305
        add_char(dsa);
        }
      } else
#line 306
      if (dsa->c == 45) {
        {
#line 307
        dsa->token = 12;
#line 307
        add_char(dsa);
        }
      } else
#line 308
      if (dsa->c == 58) {
        {
#line 309
        dsa->token = 13;
#line 309
        add_char(dsa);
        }
      } else
#line 310
      if (dsa->c == 60) {
        {
#line 311
        dsa->token = 14;
#line 311
        add_char(dsa);
        }
#line 312
        if (dsa->c == 61) {
          {
#line 312
          add_char(dsa);
          }
        }
      } else
#line 314
      if (dsa->c == 62) {
        {
#line 315
        dsa->token = 15;
#line 315
        add_char(dsa);
        }
#line 316
        if (dsa->c == 61) {
          {
#line 316
          add_char(dsa);
          }
        }
      } else
#line 318
      if (dsa->c == 61) {
        {
#line 319
        dsa->token = 16;
#line 319
        add_char(dsa);
        }
#line 320
        if (dsa->c == 60) {
          {
#line 321
          dsa->token = 14;
#line 321
          add_char(dsa);
          }
        } else
#line 322
        if (dsa->c == 62) {
          {
#line 323
          dsa->token = 15;
#line 323
          add_char(dsa);
          }
        }
      } else {
        {
#line 326
        fatal(dsa, (char *)"character `%c\' not recognized", dsa->c);
        }
      }
    }
  }
  {
#line 328
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 328
    if (! (dsa->c == 32)) {
#line 328
      goto while_break___5;
    }
    {
#line 328
    read_char___2(dsa);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 329
  return;
}
}
#line 332 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static int find_col(struct dsa___3 *dsa , char *name ) 
{ 
  int j ;
  int n_max ;
  int *map ;
  int *ind ;
  double *val ;
  double *lb ;
  double *ub ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 335
  j = _glp_lpx_find_col(dsa->lp, (char const   *)name);
  }
#line 336
  if (j == 0) {
    {
#line 338
    j = _glp_lpx_add_cols(dsa->lp, 1);
#line 339
    _glp_lpx_set_col_name(dsa->lp, j, (char const   *)name);
    }
#line 341
    if (dsa->n_max < j) {
      {
#line 342
      n_max = dsa->n_max;
#line 343
      map = dsa->map;
#line 344
      ind = dsa->ind;
#line 345
      val = dsa->val;
#line 346
      lb = dsa->lb;
#line 347
      ub = dsa->ub;
#line 348
      dsa->n_max += dsa->n_max;
#line 349
      tmp = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(int ));
#line 349
      dsa->map = (int *)tmp;
#line 350
      memset((void *)(dsa->map + 1), 0, (size_t )((unsigned long )dsa->n_max * sizeof(int )));
#line 351
      memcpy((void */* __restrict  */)(dsa->map + 1), (void const   */* __restrict  */)(map + 1),
             (size_t )((unsigned long )n_max * sizeof(int )));
#line 352
      _glp_lib_xfree((void *)map);
#line 353
      tmp___0 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(int ));
#line 353
      dsa->ind = (int *)tmp___0;
#line 354
      memcpy((void */* __restrict  */)(dsa->ind + 1), (void const   */* __restrict  */)(ind + 1),
             (size_t )((unsigned long )n_max * sizeof(int )));
#line 355
      _glp_lib_xfree((void *)ind);
#line 356
      tmp___1 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(double ));
#line 356
      dsa->val = (double *)tmp___1;
#line 357
      memcpy((void */* __restrict  */)(dsa->val + 1), (void const   */* __restrict  */)(val + 1),
             (size_t )((unsigned long )n_max * sizeof(double )));
#line 358
      _glp_lib_xfree((void *)val);
#line 359
      tmp___2 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(double ));
#line 359
      dsa->lb = (double *)tmp___2;
#line 360
      memcpy((void */* __restrict  */)(dsa->lb + 1), (void const   */* __restrict  */)(lb + 1),
             (size_t )((unsigned long )n_max * sizeof(double )));
#line 361
      _glp_lib_xfree((void *)lb);
#line 362
      tmp___3 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(double ));
#line 362
      dsa->ub = (double *)tmp___3;
#line 363
      memcpy((void */* __restrict  */)(dsa->ub + 1), (void const   */* __restrict  */)(ub + 1),
             (size_t )((unsigned long )n_max * sizeof(double )));
#line 364
      _glp_lib_xfree((void *)ub);
      }
    }
#line 366
    *(dsa->lb + j) = 1.7976931348623157e+308;
#line 366
    *(dsa->ub + j) = - 1.7976931348623157e+308;
  }
#line 368
  return (j);
}
}
#line 384 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static int parse_linear_form(struct dsa___3 *dsa ) 
{ 
  int j ;
  int k ;
  int len ;
  int newlen ;
  double s ;
  double coef ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 385
  len = 0;
  loop: 
#line 388
  if (dsa->token == 11) {
    {
#line 389
    s = 1.0;
#line 389
    scan_token___0(dsa);
    }
  } else
#line 390
  if (dsa->token == 12) {
    {
#line 391
    s = - 1.0;
#line 391
    scan_token___0(dsa);
    }
  } else {
#line 393
    s = 1.0;
  }
#line 395
  if (dsa->token == 10) {
    {
#line 396
    coef = dsa->value;
#line 396
    scan_token___0(dsa);
    }
  } else {
#line 398
    coef = 1.0;
  }
#line 400
  if (dsa->token != 9) {
    {
#line 401
    fatal(dsa, (char *)"missing variable name");
    }
  }
  {
#line 403
  j = find_col(dsa, dsa->image);
  }
#line 405
  if (*(dsa->map + j)) {
    {
#line 406
    fatal(dsa, (char *)"multiple use of variable `%s\' not allowed", dsa->image);
    }
  }
  {
#line 409
  *(dsa->map + j) = 1;
#line 411
  len ++;
#line 411
  *(dsa->ind + len) = j;
#line 411
  *(dsa->val + len) = s * coef;
#line 412
  scan_token___0(dsa);
  }
#line 414
  if (dsa->token == 11) {
#line 414
    goto loop;
  } else
#line 414
  if (dsa->token == 12) {
#line 414
    goto loop;
  }
#line 416
  k = 1;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (k <= len)) {
#line 416
      goto while_break;
    }
#line 416
    *(dsa->map + *(dsa->ind + k)) = 0;
#line 416
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  newlen = 0;
#line 419
  k = 1;
  {
#line 419
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 419
    if (! (k <= len)) {
#line 419
      goto while_break___0;
    }
#line 420
    if (*(dsa->val + k) != 0.0) {
#line 421
      newlen ++;
#line 422
      *(dsa->ind + newlen) = *(dsa->ind + k);
#line 423
      *(dsa->val + newlen) = *(dsa->val + k);
    }
#line 419
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 426
  return (newlen);
}
}
#line 439 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void parse_objective(struct dsa___3 *dsa ) 
{ 
  int k ;
  int len ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 443
  if (dsa->token == 1) {
    {
#line 444
    _glp_lpx_set_obj_dir(dsa->lp, 120);
    }
  } else
#line 445
  if (dsa->token == 2) {
    {
#line 446
    _glp_lpx_set_obj_dir(dsa->lp, 121);
    }
  } else
#line 448
  if ((unsigned long )dsa != (unsigned long )dsa) {
#line 448
    tmp = 1;
  } else {
    {
#line 448
    _glp_lib_xassert("dsa != dsa", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                     448);
#line 448
    tmp = 1;
    }
  }
  {
#line 449
  scan_token___0(dsa);
  }
#line 451
  if (dsa->token == 9) {
#line 451
    if (dsa->c == 58) {
      {
#line 453
      _glp_lpx_set_obj_name(dsa->lp, (char const   *)(dsa->image));
#line 454
      scan_token___0(dsa);
      }
#line 455
      if (dsa->token == 13) {
#line 455
        tmp___0 = 1;
      } else {
        {
#line 455
        _glp_lib_xassert("dsa->token == T_COLON", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                         455);
#line 455
        tmp___0 = 1;
        }
      }
      {
#line 456
      scan_token___0(dsa);
      }
    } else {
      {
#line 460
      _glp_lpx_set_obj_name(dsa->lp, "obj");
      }
    }
  } else {
    {
#line 460
    _glp_lpx_set_obj_name(dsa->lp, "obj");
    }
  }
  {
#line 463
  len = parse_linear_form(dsa);
#line 464
  k = 1;
  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (k <= len)) {
#line 464
      goto while_break;
    }
    {
#line 465
    _glp_lpx_set_obj_coef(dsa->lp, *(dsa->ind + k), *(dsa->val + k));
#line 464
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return;
}
}
#line 485 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void parse_constraints(struct dsa___3 *dsa ) 
{ 
  int i ;
  int len ;
  int type ;
  double s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char name[50] ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 489
  if (dsa->token == 3) {
#line 489
    tmp = 1;
  } else {
    {
#line 489
    _glp_lib_xassert("dsa->token == T_SUBJECT_TO", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                     489);
#line 489
    tmp = 1;
    }
  }
  {
#line 490
  scan_token___0(dsa);
  }
  loop: 
  {
#line 492
  i = _glp_lpx_add_rows(dsa->lp, 1);
  }
#line 494
  if (dsa->token == 9) {
#line 494
    if (dsa->c == 58) {
      {
#line 496
      tmp___0 = _glp_lpx_find_row(dsa->lp, (char const   *)(dsa->image));
      }
#line 496
      if (tmp___0 != 0) {
        {
#line 497
        fatal(dsa, (char *)"constraint `%s\' multiply defined", dsa->image);
        }
      }
      {
#line 498
      _glp_lpx_set_row_name(dsa->lp, i, (char const   *)(dsa->image));
#line 499
      scan_token___0(dsa);
      }
#line 500
      if (dsa->token == 13) {
#line 500
        tmp___1 = 1;
      } else {
        {
#line 500
        _glp_lib_xassert("dsa->token == T_COLON", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                         500);
#line 500
        tmp___1 = 1;
        }
      }
      {
#line 501
      scan_token___0(dsa);
      }
    } else {
      {
#line 506
      sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"r.%d",
              dsa->count);
#line 507
      _glp_lpx_set_row_name(dsa->lp, i, (char const   *)(name));
      }
    }
  } else {
    {
#line 506
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"r.%d",
            dsa->count);
#line 507
    _glp_lpx_set_row_name(dsa->lp, i, (char const   *)(name));
    }
  }
  {
#line 510
  len = parse_linear_form(dsa);
#line 511
  _glp_lpx_set_mat_row(dsa->lp, i, len, (int const   *)dsa->ind, (double const   *)dsa->val);
  }
#line 513
  if (dsa->token == 14) {
    {
#line 514
    type = 112;
#line 514
    scan_token___0(dsa);
    }
  } else
#line 515
  if (dsa->token == 15) {
    {
#line 516
    type = 111;
#line 516
    scan_token___0(dsa);
    }
  } else
#line 517
  if (dsa->token == 16) {
    {
#line 518
    type = 114;
#line 518
    scan_token___0(dsa);
    }
  } else {
    {
#line 520
    fatal(dsa, (char *)"missing constraint sense");
    }
  }
#line 522
  if (dsa->token == 11) {
    {
#line 523
    s = 1.0;
#line 523
    scan_token___0(dsa);
    }
  } else
#line 524
  if (dsa->token == 12) {
    {
#line 525
    s = - 1.0;
#line 525
    scan_token___0(dsa);
    }
  } else {
#line 527
    s = 1.0;
  }
#line 528
  if (dsa->token != 10) {
    {
#line 529
    fatal(dsa, (char *)"missing right-hand side");
    }
  }
  {
#line 531
  if (type == 111) {
#line 531
    goto case_111;
  }
#line 534
  if (type == 112) {
#line 534
    goto case_112;
  }
#line 537
  if (type == 114) {
#line 537
    goto case_114;
  }
#line 530
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 532
  _glp_lpx_set_row_bnds(dsa->lp, i, 111, s * dsa->value, 0.0);
  }
#line 533
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 535
  _glp_lpx_set_row_bnds(dsa->lp, i, 112, 0.0, s * dsa->value);
  }
#line 536
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 538
  _glp_lpx_set_row_bnds(dsa->lp, i, 114, s * dsa->value, 0.0);
  }
#line 539
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 542
  if (! (dsa->c == 10)) {
#line 542
    if (! (dsa->c == -1)) {
      {
#line 543
      fatal(dsa, (char *)"invalid symbol(s) beyond right-hand side");
      }
    }
  }
  {
#line 544
  scan_token___0(dsa);
  }
#line 547
  if (dsa->token == 11) {
#line 548
    goto loop;
  } else
#line 547
  if (dsa->token == 12) {
#line 548
    goto loop;
  } else
#line 547
  if (dsa->token == 10) {
#line 548
    goto loop;
  } else
#line 547
  if (dsa->token == 9) {
#line 548
    goto loop;
  }
#line 549
  return;
}
}
#line 552 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void set_lower_bound(struct dsa___3 *dsa , int j , double lb ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
#line 554
  if (*(dsa->lb + j) != 1.7976931348623157e+308) {
    {
#line 555
    tmp = _glp_lpx_get_col_name(dsa->lp, j);
#line 555
    _glp_lib_xprintf("%s:%d: warning: lower bound of variable `%s\' redefined\n",
                     dsa->fname, dsa->count, tmp);
    }
  }
#line 558
  *(dsa->lb + j) = lb;
#line 559
  return;
}
}
#line 562 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void set_upper_bound(struct dsa___3 *dsa , int j , double ub ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
#line 564
  if (*(dsa->ub + j) != - 1.7976931348623157e+308) {
    {
#line 565
    tmp = _glp_lpx_get_col_name(dsa->lp, j);
#line 565
    _glp_lib_xprintf("%s:%d: warning: upper bound of variable `%s\' redefined\n",
                     dsa->fname, dsa->count, tmp);
    }
  }
#line 568
  *(dsa->ub + j) = ub;
#line 569
  return;
}
}
#line 590 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void parse_bounds(struct dsa___3 *dsa ) 
{ 
  int j ;
  int lb_flag ;
  double lb ;
  double s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 594
  if (dsa->token == 4) {
#line 594
    tmp = 1;
  } else {
    {
#line 594
    _glp_lib_xassert("dsa->token == T_BOUNDS", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                     594);
#line 594
    tmp = 1;
    }
  }
  {
#line 595
  scan_token___0(dsa);
  }
  loop: 
#line 598
  if (! (dsa->token == 11)) {
#line 598
    if (! (dsa->token == 12)) {
#line 598
      if (! (dsa->token == 10)) {
#line 598
        if (! (dsa->token == 9)) {
#line 599
          goto done;
        }
      }
    }
  }
#line 601
  if (dsa->token == 11) {
#line 601
    goto _L___0;
  } else
#line 601
  if (dsa->token == 12) {
    _L___0: /* CIL Label */ 
#line 603
    lb_flag = 1;
#line 604
    if (dsa->token == 11) {
#line 604
      s = 1.0;
    } else {
#line 604
      s = - 1.0;
    }
    {
#line 605
    scan_token___0(dsa);
    }
#line 606
    if (dsa->token == 10) {
      {
#line 607
      lb = s * dsa->value;
#line 607
      scan_token___0(dsa);
      }
    } else {
      {
#line 608
      tmp___0 = the_same(dsa->image, (char *)"infinity");
      }
#line 608
      if (tmp___0) {
#line 608
        goto _L;
      } else {
        {
#line 608
        tmp___1 = the_same(dsa->image, (char *)"inf");
        }
#line 608
        if (tmp___1) {
          _L: /* CIL Label */ 
#line 610
          if (s > 0.0) {
            {
#line 611
            fatal(dsa, (char *)"invalid use of `+inf\' as lower bound");
            }
          }
          {
#line 612
          lb = - 1.7976931348623157e+308;
#line 612
          scan_token___0(dsa);
          }
        } else {
          {
#line 615
          fatal(dsa, (char *)"missing lower bound");
          }
        }
      }
    }
  } else
#line 617
  if (dsa->token == 10) {
    {
#line 619
    lb_flag = 1;
#line 620
    lb = dsa->value;
#line 620
    scan_token___0(dsa);
    }
  } else {
#line 624
    lb_flag = 0;
  }
#line 627
  if (lb_flag) {
#line 628
    if (dsa->token != 14) {
      {
#line 629
      fatal(dsa, (char *)"missing `<\', `<=\', or `=<\' after lower bound");
      }
    }
    {
#line 630
    scan_token___0(dsa);
    }
  }
#line 633
  if (dsa->token != 9) {
    {
#line 634
    fatal(dsa, (char *)"missing variable name");
    }
  }
  {
#line 635
  j = find_col(dsa, dsa->image);
  }
#line 637
  if (lb_flag) {
    {
#line 637
    set_lower_bound(dsa, j, lb);
    }
  }
  {
#line 638
  scan_token___0(dsa);
  }
#line 640
  if (dsa->token == 14) {
    {
#line 642
    scan_token___0(dsa);
    }
#line 643
    if (dsa->token == 11) {
#line 643
      goto _L___2;
    } else
#line 643
    if (dsa->token == 12) {
      _L___2: /* CIL Label */ 
#line 645
      if (dsa->token == 11) {
#line 645
        s = 1.0;
      } else {
#line 645
        s = - 1.0;
      }
      {
#line 646
      scan_token___0(dsa);
      }
#line 647
      if (dsa->token == 10) {
        {
#line 648
        set_upper_bound(dsa, j, s * dsa->value);
#line 649
        scan_token___0(dsa);
        }
      } else {
        {
#line 651
        tmp___2 = the_same(dsa->image, (char *)"infinity");
        }
#line 651
        if (tmp___2) {
#line 651
          goto _L___1;
        } else {
          {
#line 651
          tmp___3 = the_same(dsa->image, (char *)"inf");
          }
#line 651
          if (tmp___3) {
            _L___1: /* CIL Label */ 
#line 653
            if (s < 0.0) {
              {
#line 654
              fatal(dsa, (char *)"invalid use of `-inf\' as upper bound");
              }
            }
            {
#line 655
            set_upper_bound(dsa, j, 1.7976931348623157e+308);
#line 656
            scan_token___0(dsa);
            }
          } else {
            {
#line 659
            fatal(dsa, (char *)"missing upper bound");
            }
          }
        }
      }
    } else
#line 661
    if (dsa->token == 10) {
      {
#line 663
      set_upper_bound(dsa, j, dsa->value);
#line 664
      scan_token___0(dsa);
      }
    } else {
      {
#line 667
      fatal(dsa, (char *)"missing upper bound");
      }
    }
  } else
#line 669
  if (dsa->token == 15) {
#line 671
    if (lb_flag) {
      {
#line 673
      fatal(dsa, (char *)"invalid bound definition");
      }
    }
    {
#line 675
    scan_token___0(dsa);
    }
#line 676
    if (dsa->token == 11) {
#line 676
      goto _L___4;
    } else
#line 676
    if (dsa->token == 12) {
      _L___4: /* CIL Label */ 
#line 678
      if (dsa->token == 11) {
#line 678
        s = 1.0;
      } else {
#line 678
        s = - 1.0;
      }
      {
#line 679
      scan_token___0(dsa);
      }
#line 680
      if (dsa->token == 10) {
        {
#line 681
        set_lower_bound(dsa, j, s * dsa->value);
#line 682
        scan_token___0(dsa);
        }
      } else {
        {
#line 684
        tmp___4 = the_same(dsa->image, (char *)"infinity");
        }
#line 684
        if (tmp___4) {
#line 684
          goto _L___3;
        } else {
          {
#line 684
          tmp___5 = the_same(dsa->image, (char *)"inf");
          }
#line 684
          if (tmp___5 == 0) {
            _L___3: /* CIL Label */ 
#line 686
            if (s > 0.0) {
              {
#line 687
              fatal(dsa, (char *)"invalid use of `+inf\' as lower bound");
              }
            }
            {
#line 688
            set_lower_bound(dsa, j, - 1.7976931348623157e+308);
#line 689
            scan_token___0(dsa);
            }
          } else {
            {
#line 692
            fatal(dsa, (char *)"missing lower bound");
            }
          }
        }
      }
    } else
#line 694
    if (dsa->token == 10) {
      {
#line 696
      set_lower_bound(dsa, j, dsa->value);
#line 697
      scan_token___0(dsa);
      }
    } else {
      {
#line 700
      fatal(dsa, (char *)"missing lower bound");
      }
    }
  } else
#line 702
  if (dsa->token == 16) {
#line 704
    if (lb_flag) {
      {
#line 706
      fatal(dsa, (char *)"invalid bound definition");
      }
    }
    {
#line 708
    scan_token___0(dsa);
    }
#line 709
    if (dsa->token == 11) {
#line 709
      goto _L___5;
    } else
#line 709
    if (dsa->token == 12) {
      _L___5: /* CIL Label */ 
#line 711
      if (dsa->token == 11) {
#line 711
        s = 1.0;
      } else {
#line 711
        s = - 1.0;
      }
      {
#line 712
      scan_token___0(dsa);
      }
#line 713
      if (dsa->token == 10) {
        {
#line 714
        set_lower_bound(dsa, j, s * dsa->value);
#line 715
        set_upper_bound(dsa, j, s * dsa->value);
#line 716
        scan_token___0(dsa);
        }
      } else {
        {
#line 719
        fatal(dsa, (char *)"missing fixed value");
        }
      }
    } else
#line 721
    if (dsa->token == 10) {
      {
#line 723
      set_lower_bound(dsa, j, dsa->value);
#line 724
      set_upper_bound(dsa, j, dsa->value);
#line 725
      scan_token___0(dsa);
      }
    } else {
      {
#line 728
      fatal(dsa, (char *)"missing fixed value");
      }
    }
  } else {
    {
#line 730
    tmp___6 = the_same(dsa->image, (char *)"free");
    }
#line 730
    if (tmp___6) {
#line 732
      if (lb_flag) {
        {
#line 734
        fatal(dsa, (char *)"invalid bound definition");
        }
      }
      {
#line 736
      set_lower_bound(dsa, j, - 1.7976931348623157e+308);
#line 737
      set_upper_bound(dsa, j, 1.7976931348623157e+308);
#line 738
      scan_token___0(dsa);
      }
    } else
#line 740
    if (! lb_flag) {
      {
#line 742
      fatal(dsa, (char *)"invalid bound definition");
      }
    }
  }
#line 744
  goto loop;
  done: 
#line 745
  return;
}
}
#line 759 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void parse_integer(struct dsa___3 *dsa ) 
{ 
  int j ;
  int binary ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 762
  if (dsa->token == 5) {
    {
#line 763
    binary = 0;
#line 763
    scan_token___0(dsa);
    }
  } else
#line 764
  if (dsa->token == 6) {
    {
#line 765
    binary = 0;
#line 765
    scan_token___0(dsa);
    }
  } else
#line 766
  if (dsa->token == 7) {
    {
#line 767
    binary = 1;
#line 767
    scan_token___0(dsa);
    }
  } else
#line 769
  if ((unsigned long )dsa != (unsigned long )dsa) {
#line 769
    tmp = 1;
  } else {
    {
#line 769
    _glp_lib_xassert("dsa != dsa", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                     769);
#line 769
    tmp = 1;
    }
  }
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (dsa->token == 9)) {
#line 771
      goto while_break;
    }
    {
#line 773
    j = find_col(dsa, dsa->image);
#line 778
    _glp_lpx_set_col_kind(dsa->lp, j, 161);
    }
#line 780
    if (binary) {
      {
#line 781
      set_lower_bound(dsa, j, 0.0);
#line 782
      set_upper_bound(dsa, j, 1.0);
      }
    }
    {
#line 784
    scan_token___0(dsa);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 786
  return;
}
}
#line 789 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
int _glp_read_cpxlp(glp_prob *lp , char const   *fname ) 
{ 
  struct dsa___3 _dsa ;
  struct dsa___3 *dsa ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int j ;
  int type ;
  double lb ;
  double ub ;
  int m ;
  int tmp___7 ;
  int n ;
  int tmp___8 ;
  int nnz ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int ni ;
  int tmp___13 ;
  int nb ;
  int tmp___14 ;
  char s[50] ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 791
  dsa = & _dsa;
#line 792
  glp_erase_prob(lp);
#line 793
  tmp = _setjmp((struct __jmp_buf_tag *)(dsa->jump));
  }
#line 793
  if (tmp) {
#line 793
    goto fail;
  }
  {
#line 794
  dsa->lp = lp;
#line 795
  dsa->fname = fname;
#line 796
  dsa->fp = (FILE *)((void *)0);
#line 797
  dsa->count = 0;
#line 798
  dsa->c = '\n';
#line 799
  dsa->token = 0;
#line 800
  dsa->image[0] = (char )'\000';
#line 801
  dsa->imlen = 0;
#line 802
  dsa->value = 0.0;
#line 803
  dsa->n_max = 100;
#line 804
  tmp___0 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(int ));
#line 804
  dsa->map = (int *)tmp___0;
#line 805
  memset((void *)(dsa->map + 1), 0, (size_t )((unsigned long )dsa->n_max * sizeof(int )));
#line 806
  tmp___1 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(int ));
#line 806
  dsa->ind = (int *)tmp___1;
#line 807
  tmp___2 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(double ));
#line 807
  dsa->val = (double *)tmp___2;
#line 808
  tmp___3 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(double ));
#line 808
  dsa->lb = (double *)tmp___3;
#line 809
  tmp___4 = _glp_lib_xcalloc(1 + dsa->n_max, (int )sizeof(double ));
#line 809
  dsa->ub = (double *)tmp___4;
#line 810
  _glp_lib_xprintf("glp_read_lp: reading problem data from `%s\'...\n", dsa->fname);
#line 812
  dsa->fp = fopen((char const   */* __restrict  */)dsa->fname, (char const   */* __restrict  */)"r");
  }
#line 813
  if ((unsigned long )dsa->fp == (unsigned long )((void *)0)) {
    {
#line 814
    tmp___5 = __errno_location();
#line 814
    tmp___6 = strerror(*tmp___5);
#line 814
    _glp_lib_xprintf("glp_read_lp: unable to open `%s\' - %s\n", dsa->fname, tmp___6);
    }
#line 816
    goto fail;
  }
  {
#line 818
  _glp_lpx_create_index(dsa->lp);
#line 824
  scan_token___0(dsa);
  }
#line 826
  if (! (dsa->token == 1)) {
#line 826
    if (! (dsa->token == 2)) {
      {
#line 827
      fatal(dsa, (char *)"`minimize\' or `maximize\' keyword missing");
      }
    }
  }
  {
#line 828
  parse_objective(dsa);
  }
#line 830
  if (dsa->token != 3) {
    {
#line 831
    fatal(dsa, (char *)"constraints section missing");
    }
  }
  {
#line 832
  parse_constraints(dsa);
  }
#line 834
  if (dsa->token == 4) {
    {
#line 834
    parse_bounds(dsa);
    }
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! (dsa->token == 5)) {
#line 836
      if (! (dsa->token == 6)) {
#line 836
        if (! (dsa->token == 7)) {
#line 836
          goto while_break;
        }
      }
    }
    {
#line 838
    parse_integer(dsa);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 840
  if (dsa->token == 8) {
    {
#line 841
    scan_token___0(dsa);
    }
  } else
#line 842
  if (dsa->token == 0) {
    {
#line 843
    _glp_lib_xprintf("%s:%d: warning: keyword `end\' missing\n", dsa->fname, dsa->count);
    }
  } else {
    {
#line 846
    fatal(dsa, (char *)"symbol `%s\' in wrong position", dsa->image);
    }
  }
#line 848
  if (dsa->token != 0) {
    {
#line 849
    fatal(dsa, (char *)"extra symbol(s) detected beyond `end\'");
    }
  }
  {
#line 853
  j = _glp_lpx_get_num_cols(dsa->lp);
  }
  {
#line 853
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 853
    if (! (j >= 1)) {
#line 853
      goto while_break___0;
    }
#line 854
    lb = *(dsa->lb + j);
#line 855
    ub = *(dsa->ub + j);
#line 856
    if (lb == 1.7976931348623157e+308) {
#line 856
      lb = 0.0;
    }
#line 857
    if (ub == - 1.7976931348623157e+308) {
#line 857
      ub = 1.7976931348623157e+308;
    }
#line 858
    if (lb == - 1.7976931348623157e+308) {
#line 858
      if (ub == 1.7976931348623157e+308) {
#line 859
        type = 110;
      } else {
#line 858
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 860
    if (ub == 1.7976931348623157e+308) {
#line 861
      type = 111;
    } else
#line 862
    if (lb == - 1.7976931348623157e+308) {
#line 863
      type = 112;
    } else
#line 864
    if (lb != ub) {
#line 865
      type = 113;
    } else {
#line 867
      type = 114;
    }
    {
#line 868
    _glp_lpx_set_col_bnds(dsa->lp, j, type, lb, ub);
#line 853
    j --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 872
  tmp___7 = _glp_lpx_get_num_rows(dsa->lp);
#line 872
  m = tmp___7;
#line 873
  tmp___8 = _glp_lpx_get_num_cols(dsa->lp);
#line 873
  n = tmp___8;
#line 874
  tmp___9 = _glp_lpx_get_num_nz(dsa->lp);
#line 874
  nnz = tmp___9;
  }
#line 875
  if (nnz == 1) {
#line 875
    tmp___10 = "";
  } else {
#line 875
    tmp___10 = "s";
  }
#line 875
  if (n == 1) {
#line 875
    tmp___11 = "";
  } else {
#line 875
    tmp___11 = "s";
  }
#line 875
  if (m == 1) {
#line 875
    tmp___12 = "";
  } else {
#line 875
    tmp___12 = "s";
  }
  {
#line 875
  _glp_lib_xprintf("glp_read_lp: %d row%s, %d column%s, %d non-zero%s\n", m, tmp___12,
                   n, tmp___11, nnz, tmp___10);
#line 880
  tmp___17 = _glp_lpx_get_class(dsa->lp);
  }
#line 880
  if (tmp___17 == 101) {
    {
#line 881
    tmp___13 = _glp_lpx_get_num_int(dsa->lp);
#line 881
    ni = tmp___13;
#line 882
    tmp___14 = _glp_lpx_get_num_bin(dsa->lp);
#line 882
    nb = tmp___14;
    }
#line 884
    if (nb == 0) {
      {
#line 885
      strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"none of");
      }
    } else
#line 886
    if (ni == 1) {
#line 886
      if (nb == 1) {
        {
#line 887
        strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"");
        }
      } else {
#line 886
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 888
    if (nb == 1) {
      {
#line 889
      strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"one of");
      }
    } else
#line 890
    if (nb == ni) {
      {
#line 891
      strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"all of");
      }
    } else {
      {
#line 893
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d of",
              nb);
      }
    }
#line 894
    if (nb == 1) {
#line 894
      tmp___15 = "is";
    } else {
#line 894
      tmp___15 = "are";
    }
#line 894
    if (ni == 1) {
#line 894
      tmp___16 = "";
    } else {
#line 894
      tmp___16 = "s";
    }
    {
#line 894
    _glp_lib_xprintf("glp_read_lp: %d integer column%s, %s which %s binary\n", ni,
                     tmp___16, s, tmp___15);
    }
  }
  {
#line 898
  _glp_lib_xprintf("glp_read_lp: %d lines were read\n", dsa->count);
#line 899
  fclose(dsa->fp);
#line 900
  _glp_lib_xfree((void *)dsa->map);
#line 901
  _glp_lib_xfree((void *)dsa->ind);
#line 902
  _glp_lib_xfree((void *)dsa->val);
#line 903
  _glp_lib_xfree((void *)dsa->lb);
#line 904
  _glp_lib_xfree((void *)dsa->ub);
#line 905
  _glp_lpx_delete_index(dsa->lp);
#line 906
  _glp_1px_order_matrix(dsa->lp);
  }
#line 907
  return (0);
  fail: 
#line 908
  if ((unsigned long )dsa->lp != (unsigned long )((void *)0)) {
    {
#line 908
    glp_erase_prob(dsa->lp);
    }
  }
#line 909
  if ((unsigned long )dsa->fp != (unsigned long )((void *)0)) {
    {
#line 909
    fclose(dsa->fp);
    }
  }
#line 910
  if ((unsigned long )dsa->map != (unsigned long )((void *)0)) {
    {
#line 910
    _glp_lib_xfree((void *)dsa->map);
    }
  }
#line 911
  if ((unsigned long )dsa->ind != (unsigned long )((void *)0)) {
    {
#line 911
    _glp_lib_xfree((void *)dsa->ind);
    }
  }
#line 912
  if ((unsigned long )dsa->val != (unsigned long )((void *)0)) {
    {
#line 912
    _glp_lib_xfree((void *)dsa->val);
    }
  }
#line 913
  if ((unsigned long )dsa->lb != (unsigned long )((void *)0)) {
    {
#line 913
    _glp_lib_xfree((void *)dsa->lb);
    }
  }
#line 914
  if ((unsigned long )dsa->ub != (unsigned long )((void *)0)) {
    {
#line 914
    _glp_lib_xfree((void *)dsa->ub);
    }
  }
#line 915
  return (1);
}
}
#line 936 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static int check_name(char *name ) 
{ 
  int k ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 939
  tmp = __ctype_b_loc();
  }
#line 939
  if ((int const   )*(*tmp + (int )((unsigned char )*(name + 0))) & 2048) {
#line 939
    return (1);
  }
#line 940
  if ((int )*(name + 0) == 46) {
#line 940
    return (1);
  }
#line 941
  k = 0;
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! ((int )*(name + k) != 0)) {
#line 941
      goto while_break;
    }
    {
#line 942
    tmp___0 = __ctype_b_loc();
    }
#line 942
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(name + k))) & 8)) {
      {
#line 942
      tmp___1 = strchr("!\"#$%&()/,.;?@_`\'{}|~", (int )((unsigned char )*(name + k)));
      }
#line 942
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 943
        return (1);
      }
    }
#line 941
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  return (0);
}
}
#line 947 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static void adjust_name(char *name ) 
{ 
  int k ;

  {
#line 950
  k = 0;
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    if (! ((int )*(name + k) != 0)) {
#line 950
      goto while_break;
    }
#line 951
    if ((int )*(name + k) == 32) {
#line 952
      *(name + k) = (char )'_';
    } else
#line 953
    if ((int )*(name + k) == 45) {
#line 954
      *(name + k) = (char )'~';
    } else
#line 955
    if ((int )*(name + k) == 91) {
#line 956
      *(name + k) = (char )'(';
    } else
#line 957
    if ((int )*(name + k) == 93) {
#line 958
      *(name + k) = (char )')';
    }
#line 950
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 960
  return;
}
}
#line 963 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static char *row_name___0(glp_prob *lp , int i , char *rname ) 
{ 
  char *name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 966
  if (i == 0) {
    {
#line 967
    tmp = _glp_lpx_get_obj_name(lp);
#line 967
    name = (char *)((void *)tmp);
    }
  } else {
    {
#line 969
    tmp___0 = _glp_lpx_get_row_name(lp, i);
#line 969
    name = (char *)((void *)tmp___0);
    }
  }
#line 970
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 970
    goto fake;
  }
  {
#line 971
  strcpy((char */* __restrict  */)rname, (char const   */* __restrict  */)name);
#line 972
  adjust_name((char *)rname);
#line 973
  tmp___1 = check_name((char *)rname);
  }
#line 973
  if (tmp___1) {
#line 973
    goto fake;
  }
#line 974
  return ((char *)rname);
  fake: 
#line 975
  if (i == 0) {
    {
#line 976
    strcpy((char */* __restrict  */)rname, (char const   */* __restrict  */)"obj");
    }
  } else {
    {
#line 978
    sprintf((char */* __restrict  */)rname, (char const   */* __restrict  */)"r_%d",
            i);
    }
  }
#line 979
  return ((char *)rname);
}
}
#line 982 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
static char *col_name___0(glp_prob *lp , int j , char *cname ) 
{ 
  char const   *name ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 985
  name = _glp_lpx_get_col_name(lp, j);
  }
#line 986
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 986
    goto fake;
  }
  {
#line 987
  strcpy((char */* __restrict  */)cname, (char const   */* __restrict  */)name);
#line 988
  adjust_name((char *)cname);
#line 989
  tmp = check_name((char *)cname);
  }
#line 989
  if (tmp) {
#line 989
    goto fake;
  }
#line 990
  return ((char *)cname);
  fake: 
  {
#line 991
  sprintf((char */* __restrict  */)cname, (char const   */* __restrict  */)"x_%d",
          j);
  }
#line 992
  return ((char *)cname);
}
}
#line 995 "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c"
int _glp_write_cpxlp(glp_prob *lp , char const   *fname ) 
{ 
  FILE *fp ;
  int nrows ;
  int ncols ;
  int i ;
  int j ;
  int t ;
  int len ;
  int typx ;
  int flag ;
  int kind ;
  int *ind ;
  double lb ;
  double ub ;
  double temp ;
  double *val ;
  char line[1024] ;
  char term[1024] ;
  char rname[256] ;
  char cname[256] ;
  int *tmp ;
  char *tmp___0 ;
  char const   *name ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;

  {
  {
#line 1001
  _glp_lib_xprintf("glp_write_lp: writing problem data to `%s\'...\n", fname);
#line 1004
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 1005
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1006
    tmp = __errno_location();
#line 1006
    tmp___0 = strerror(*tmp);
#line 1006
    _glp_lib_xprintf("glp_write_lp: unable to create `%s\' - %s\n", fname, tmp___0);
    }
#line 1008
    goto fail;
  }
  {
#line 1011
  nrows = _glp_lpx_get_num_rows(lp);
#line 1012
  ncols = _glp_lpx_get_num_cols(lp);
#line 1019
  tmp___1 = _glp_lpx_get_prob_name(lp);
#line 1019
  name = tmp___1;
  }
#line 1020
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1020
    name = "Unknown";
  }
  {
#line 1021
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\* Problem: %s *\\\n",
          name);
#line 1022
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 1025
  if (nrows > 0) {
#line 1025
    if (! (ncols > 0)) {
      {
#line 1026
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\\n");
      }
#line 1027
      goto skip;
    }
  } else {
    {
#line 1026
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\\n");
    }
#line 1027
    goto skip;
  }
  {
#line 1031
  tmp___2 = _glp_lib_xcalloc(1 + ncols, (int )sizeof(int ));
#line 1031
  ind = (int *)tmp___2;
#line 1032
  tmp___3 = _glp_lib_xcalloc(1 + ncols, (int )sizeof(double ));
#line 1032
  val = (double *)tmp___3;
#line 1035
  i = 0;
  }
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1035
    if (! (i <= nrows)) {
#line 1035
      goto while_break;
    }
#line 1036
    if (i == 0) {
      {
#line 1037
      tmp___4 = _glp_lpx_get_obj_dir(lp);
      }
      {
#line 1038
      if (tmp___4 == 120) {
#line 1038
        goto case_120;
      }
#line 1041
      if (tmp___4 == 121) {
#line 1041
        goto case_121;
      }
#line 1044
      goto switch_default;
      case_120: /* CIL Label */ 
      {
#line 1039
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Minimize\n");
      }
#line 1040
      goto switch_break;
      case_121: /* CIL Label */ 
      {
#line 1042
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Maximize\n");
      }
#line 1043
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1045
      if ((unsigned long )lp != (unsigned long )lp) {
#line 1045
        tmp___5 = 1;
      } else {
        {
#line 1045
        _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                         1045);
#line 1045
        tmp___5 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
    } else
#line 1048
    if (i == 1) {
      {
#line 1049
      temp = _glp_lpx_get_obj_coef(lp, 0);
      }
#line 1050
      if (temp != 0.0) {
        {
#line 1051
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\* constant term = %.*g *\\\n",
                15, temp);
        }
      }
      {
#line 1053
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 1054
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Subject To\n");
      }
    }
    {
#line 1056
    row_name___0(lp, i, (char *)(rname));
    }
#line 1057
    if (i == 0) {
#line 1058
      len = 0;
#line 1059
      j = 1;
      {
#line 1059
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1059
        if (! (j <= ncols)) {
#line 1059
          goto while_break___0;
        }
        {
#line 1060
        temp = _glp_lpx_get_obj_coef(lp, j);
        }
#line 1061
        if (temp != 0.0) {
#line 1062
          len ++;
#line 1062
          *(ind + len) = j;
#line 1062
          *(val + len) = temp;
        }
#line 1059
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1066
      _glp_lpx_get_row_bnds(lp, i, & typx, & lb, & ub);
      }
#line 1067
      if (typx == 110) {
#line 1067
        goto __Cont;
      }
      {
#line 1068
      len = _glp_lpx_get_mat_row(lp, i, ind, val);
      }
    }
#line 1070
    flag = 0;
    more: 
#line 1071
    if (! flag) {
      {
#line 1072
      sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)" %s:",
              rname);
      }
    } else {
      {
#line 1074
      tmp___6 = strlen((char const   *)(rname));
#line 1074
      sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)" %*s ",
              tmp___6, "");
      }
    }
#line 1075
    t = 1;
    {
#line 1075
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1075
      if (! (t <= len)) {
#line 1075
        goto while_break___1;
      }
      {
#line 1076
      col_name___0(lp, *(ind + t), (char *)(cname));
      }
#line 1077
      if (*(val + t) == 1.0) {
        {
#line 1078
        sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" + %s",
                cname);
        }
      } else
#line 1079
      if (*(val + t) == - 1.0) {
        {
#line 1080
        sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" - %s",
                cname);
        }
      } else
#line 1081
      if (*(val + t) > 0.0) {
        {
#line 1082
        sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" + %.*g %s",
                15, *(val + t), cname);
        }
      } else
#line 1083
      if (*(val + t) < 0.0) {
        {
#line 1084
        sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" - %.*g %s",
                15, - *(val + t), cname);
        }
      } else
#line 1086
      if ((unsigned long )lp != (unsigned long )lp) {
#line 1086
        tmp___7 = 1;
      } else {
        {
#line 1086
        _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                         1086);
#line 1086
        tmp___7 = 1;
        }
      }
      {
#line 1087
      tmp___8 = strlen((char const   *)(line));
#line 1087
      tmp___9 = strlen((char const   *)(term));
      }
#line 1087
      if (tmp___8 + tmp___9 > 72U) {
        {
#line 1088
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
                line);
#line 1088
        line[0] = (char )'\000';
        }
      }
      {
#line 1089
      strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(term));
#line 1075
      t ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1091
    if (len == 0) {
      {
#line 1093
      tmp___10 = col_name___0(lp, 1, (char *)(cname));
#line 1093
      sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" 0 %s",
              tmp___10);
#line 1094
      strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(term));
      }
    }
#line 1096
    if (i > 0) {
      {
#line 1099
      if (typx == 113) {
#line 1099
        goto case_113;
      }
#line 1099
      if (typx == 111) {
#line 1099
        goto case_113;
      }
#line 1102
      if (typx == 112) {
#line 1102
        goto case_112;
      }
#line 1105
      if (typx == 114) {
#line 1105
        goto case_114;
      }
#line 1108
      goto switch_default___0;
      case_113: /* CIL Label */ 
      case_111: /* CIL Label */ 
      {
#line 1100
      sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" >= %.*g",
              15, lb);
      }
#line 1101
      goto switch_break___0;
      case_112: /* CIL Label */ 
      {
#line 1103
      sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" <= %.*g",
              15, ub);
      }
#line 1104
      goto switch_break___0;
      case_114: /* CIL Label */ 
      {
#line 1106
      sprintf((char */* __restrict  */)(term), (char const   */* __restrict  */)" = %.*g",
              15, lb);
      }
#line 1107
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1109
      if (typx != typx) {
#line 1109
        tmp___11 = 1;
      } else {
        {
#line 1109
        _glp_lib_xassert("typx != typx", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                         1109);
#line 1109
        tmp___11 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1111
      tmp___12 = strlen((char const   *)(line));
#line 1111
      tmp___13 = strlen((char const   *)(term));
      }
#line 1111
      if (tmp___12 + tmp___13 > 72U) {
        {
#line 1112
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
                line);
#line 1112
        line[0] = (char )'\000';
        }
      }
      {
#line 1113
      strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(term));
      }
    }
    {
#line 1115
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
            line);
    }
#line 1116
    if (i > 0) {
#line 1116
      if (typx == 113) {
#line 1118
        flag = 1;
#line 1119
        typx = 112;
#line 1120
        goto more;
      }
    }
    __Cont: /* CIL Label */ 
#line 1035
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1124
  _glp_lib_xfree((void *)ind);
#line 1125
  _glp_lib_xfree((void *)val);
#line 1127
  flag = 0;
#line 1128
  j = 1;
  }
  {
#line 1128
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1128
    if (! (j <= ncols)) {
#line 1128
      goto while_break___2;
    }
    {
#line 1129
    col_name___0(lp, j, (char *)(cname));
#line 1130
    _glp_lpx_get_col_bnds(lp, j, & typx, & lb, & ub);
    }
#line 1131
    if (typx == 111) {
#line 1131
      if (lb == 0.0) {
#line 1131
        goto __Cont___0;
      }
    }
#line 1132
    if (! flag) {
      {
#line 1133
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 1134
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Bounds\n");
#line 1135
      flag = 1;
      }
    }
    {
#line 1138
    if (typx == 110) {
#line 1138
      goto case_110;
    }
#line 1141
    if (typx == 111) {
#line 1141
      goto case_111___0;
    }
#line 1144
    if (typx == 112) {
#line 1144
      goto case_112___0;
    }
#line 1147
    if (typx == 113) {
#line 1147
      goto case_113___0;
    }
#line 1151
    if (typx == 114) {
#line 1151
      goto case_114___0;
    }
#line 1154
    goto switch_default___1;
    case_110: /* CIL Label */ 
    {
#line 1139
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s free\n",
            cname);
    }
#line 1140
    goto switch_break___1;
    case_111___0: /* CIL Label */ 
    {
#line 1142
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s >= %.*g\n",
            cname, 15, lb);
    }
#line 1143
    goto switch_break___1;
    case_112___0: /* CIL Label */ 
    {
#line 1145
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" -inf <= %s <= %.*g\n",
            cname, 15, ub);
    }
#line 1146
    goto switch_break___1;
    case_113___0: /* CIL Label */ 
    {
#line 1148
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %.*g <= %s <= %.*g\n",
            15, lb, cname, 15, ub);
    }
#line 1150
    goto switch_break___1;
    case_114___0: /* CIL Label */ 
    {
#line 1152
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s = %.*g\n",
            cname, 15, lb);
    }
#line 1153
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 1155
    if (typx != typx) {
#line 1155
      tmp___14 = 1;
    } else {
      {
#line 1155
      _glp_lib_xassert("typx != typx", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                       1155);
#line 1155
      tmp___14 = 1;
      }
    }
    switch_break___1: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 1128
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1159
  tmp___17 = _glp_lpx_get_class(lp);
  }
#line 1159
  if (tmp___17 == 101) {
#line 1160
    flag = 0;
#line 1161
    j = 1;
    {
#line 1161
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1161
      if (! (j <= ncols)) {
#line 1161
        goto while_break___3;
      }
      {
#line 1162
      kind = _glp_lpx_get_col_kind(lp, j);
      }
#line 1163
      if (kind == 160) {
#line 1163
        goto __Cont___1;
      }
#line 1164
      if (kind == 161) {
#line 1164
        tmp___15 = 1;
      } else {
        {
#line 1164
        _glp_lib_xassert("kind == LPX_IV", "/home/wslee/benchmarks/glpk-4.38/src/glpcpx.c",
                         1164);
#line 1164
        tmp___15 = 1;
        }
      }
#line 1165
      if (! flag) {
        {
#line 1166
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 1167
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Generals\n");
#line 1168
        flag = 1;
        }
      }
      {
#line 1170
      tmp___16 = col_name___0(lp, j, (char *)(cname));
#line 1170
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s\n",
              tmp___16);
      }
      __Cont___1: /* CIL Label */ 
#line 1161
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  skip: 
  {
#line 1174
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 1175
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"End\n");
#line 1177
  fflush(fp);
#line 1178
  tmp___20 = ferror(fp);
  }
#line 1178
  if (tmp___20) {
    {
#line 1179
    tmp___18 = __errno_location();
#line 1179
    tmp___19 = strerror(*tmp___18);
#line 1179
    _glp_lib_xprintf("glp_write_lp: write error on `%s\' - %s\n", fname, tmp___19);
    }
#line 1181
    goto fail;
  }
  {
#line 1183
  fclose(fp);
  }
#line 1185
  return (0);
  fail: 
#line 1187
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1187
    fclose(fp);
    }
  }
#line 1188
  return (1);
}
}
#line 35 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
BFX___0 *_glp_bfx_create_binv(void) 
{ 
  BFX___0 *bfx ;
  void *tmp ;

  {
  {
#line 38
  tmp = _glp_lib_xmalloc((int )sizeof(BFX___0 ));
#line 38
  bfx = (BFX___0 *)tmp;
#line 39
  bfx->valid = 0;
#line 40
  bfx->lux = (LUX *)((void *)0);
  }
#line 41
  return (bfx);
}
}
#line 44 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
int _glp_bfx_factorize(BFX___0 *binv , int m , int (*col)(void *info , int j , int *ind ,
                                                          mpq_t *val ) , void *info ) 
{ 
  int ret ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 48
  if (m > 0) {
#line 48
    tmp = 1;
  } else {
    {
#line 48
    _glp_lib_xassert("m > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c", 48);
#line 48
    tmp = 1;
    }
  }
#line 49
  if ((unsigned long )binv->lux != (unsigned long )((void *)0)) {
#line 49
    if ((binv->lux)->n != m) {
      {
#line 50
      _glp_lux_delete(binv->lux);
#line 51
      binv->lux = (LUX *)((void *)0);
      }
    }
  }
#line 53
  if ((unsigned long )binv->lux == (unsigned long )((void *)0)) {
    {
#line 54
    binv->lux = _glp_lux_create(m);
    }
  }
  {
#line 55
  ret = _glp_lux_decomp(binv->lux, col, info);
#line 56
  binv->valid = ret == 0;
  }
#line 57
  return (ret);
}
}
#line 60 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
void _glp_bfx_ftran(BFX___0 *binv , mpq_t *x , int save ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 62
  if (binv->valid) {
#line 62
    tmp = 1;
  } else {
    {
#line 62
    _glp_lib_xassert("binv->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c",
                     62);
#line 62
    tmp = 1;
    }
  }
  {
#line 63
  _glp_lux_solve(binv->lux, 0, x);
  }
#line 64
  if (save == save) {
#line 64
    tmp___0 = 1;
  } else {
    {
#line 64
    _glp_lib_xassert("save == save", "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c",
                     64);
#line 64
    tmp___0 = 1;
    }
  }
#line 65
  return;
}
}
#line 68 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
void _glp_bfx_btran(BFX___0 *binv , mpq_t *x ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 70
  if (binv->valid) {
#line 70
    tmp = 1;
  } else {
    {
#line 70
    _glp_lib_xassert("binv->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c",
                     70);
#line 70
    tmp = 1;
    }
  }
  {
#line 71
  _glp_lux_solve(binv->lux, 1, x);
  }
#line 72
  return;
}
}
#line 75 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
int _glp_bfx_update(BFX___0 *binv , int j ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 77
  if (binv->valid) {
#line 77
    tmp = 1;
  } else {
    {
#line 77
    _glp_lib_xassert("binv->valid", "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c",
                     77);
#line 77
    tmp = 1;
    }
  }
#line 78
  if (1 <= j) {
#line 78
    if (j <= (binv->lux)->n) {
#line 78
      tmp___0 = 1;
    } else {
      {
#line 78
      _glp_lib_xassert("1 <= j && j <= binv->lux->n", "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c",
                       78);
#line 78
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 78
    _glp_lib_xassert("1 <= j && j <= binv->lux->n", "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c",
                     78);
#line 78
    tmp___0 = 1;
    }
  }
#line 79
  return (1);
}
}
#line 82 "/home/wslee/benchmarks/glpk-4.38/src/glpbfx.c"
void _glp_bfx_delete_binv(BFX___0 *binv ) 
{ 


  {
#line 84
  if ((unsigned long )binv->lux != (unsigned long )((void *)0)) {
    {
#line 85
    _glp_lux_delete(binv->lux);
    }
  }
  {
#line 86
  _glp_lib_xfree((void *)binv);
  }
#line 87
  return;
}
}
#line 74 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.h"
BFD___0 *_glp_bfd_create_it(void) ;
#line 96
void _glp_bfd_delete_it(BFD___0 *bfd ) ;
#line 53 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c"
BFD___0 *_glp_bfd_create_it(void) 
{ 
  BFD___0 *bfd ;
  void *tmp ;

  {
  {
#line 55
  tmp = _glp_lib_xmalloc((int )sizeof(BFD___0 ));
#line 55
  bfd = (BFD___0 *)tmp;
#line 56
  bfd->valid = 0;
#line 57
  bfd->type = 1;
#line 58
  bfd->fhv = (FHV *)((void *)0);
#line 59
  bfd->lpf = (LPF *)((void *)0);
#line 60
  bfd->lu_size = 0;
#line 61
  bfd->piv_tol = 0.10;
#line 62
  bfd->piv_lim = 4;
#line 63
  bfd->suhl = 1;
#line 64
  bfd->eps_tol = 1e-15;
#line 65
  bfd->max_gro = 1e+10;
#line 66
  bfd->nfs_max = 50;
#line 67
  bfd->upd_tol = 1e-6;
#line 68
  bfd->nrs_max = 50;
#line 69
  bfd->rs_size = 1000;
#line 70
  bfd->upd_lim = -1;
#line 71
  bfd->upd_cnt = 0;
  }
#line 72
  return (bfd);
}
}
#line 122 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c"
int _glp_bfd_factorize(BFD___0 *bfd , int m , int const   *bh , int (*col)(void *info ,
                                                                           int j ,
                                                                           int *ind ,
                                                                           double *val ) ,
                       void *info ) 
{ 
  LUF *luf ;
  int nov ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 126
  if (m < 1) {
    {
#line 127
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c", 127);
#line 127
    (*tmp)("bfd_factorize: m = %d; invalid parameter\n", m);
    }
  }
#line 128
  if (m > 100000000) {
    {
#line 129
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c", 129);
#line 129
    (*tmp___0)("bfd_factorize: m = %d; matrix too big\n", m);
    }
  }
#line 131
  bfd->valid = 0;
#line 133
  nov = 0;
  {
#line 135
  if (bfd->type == 1) {
#line 135
    goto case_1;
  }
#line 142
  if (bfd->type == 3) {
#line 142
    goto case_3;
  }
#line 142
  if (bfd->type == 2) {
#line 142
    goto case_3;
  }
#line 148
  goto switch_default;
  case_1: /* CIL Label */ 
#line 136
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
    {
#line 137
    _glp_lpf_delete_it(bfd->lpf);
#line 137
    bfd->lpf = (LPF *)((void *)0);
    }
  }
#line 138
  if ((unsigned long )bfd->fhv == (unsigned long )((void *)0)) {
    {
#line 139
    bfd->fhv = _glp_fhv_create_it();
#line 139
    nov = 1;
    }
  }
#line 140
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 143
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
    {
#line 144
    _glp_fhv_delete_it(bfd->fhv);
#line 144
    bfd->fhv = (FHV *)((void *)0);
    }
  }
#line 145
  if ((unsigned long )bfd->lpf == (unsigned long )((void *)0)) {
    {
#line 146
    bfd->lpf = _glp_lpf_create_it();
#line 146
    nov = 1;
    }
  }
#line 147
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 149
  tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c", 149);
#line 149
  (*tmp___1)("bfd_factorize: bfd->type = %d; invalid factorization type\n", bfd->type);
  }
  switch_break: /* CIL Label */ ;
  }
#line 153
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
#line 154
    luf = (bfd->fhv)->luf;
  } else
#line 155
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
#line 156
    luf = (bfd->lpf)->luf;
  } else
#line 158
  if ((unsigned long )bfd != (unsigned long )bfd) {
#line 158
    tmp___2 = 1;
  } else {
    {
#line 158
    _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                     158);
#line 158
    tmp___2 = 1;
    }
  }
#line 159
  if (nov) {
#line 159
    luf->new_sva = bfd->lu_size;
  }
#line 160
  luf->piv_tol = bfd->piv_tol;
#line 161
  luf->piv_lim = bfd->piv_lim;
#line 162
  luf->suhl = bfd->suhl;
#line 163
  luf->eps_tol = bfd->eps_tol;
#line 164
  luf->max_gro = bfd->max_gro;
#line 166
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
#line 167
    if (nov) {
#line 167
      (bfd->fhv)->hh_max = bfd->nfs_max;
    }
#line 168
    (bfd->fhv)->upd_tol = bfd->upd_tol;
  }
#line 171
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
#line 172
    if (nov) {
#line 172
      (bfd->lpf)->n_max = bfd->nrs_max;
    }
#line 173
    if (nov) {
#line 173
      (bfd->lpf)->v_size = bfd->rs_size;
    }
  }
#line 176
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
    {
#line 177
    tmp___3 = _glp_fhv_factorize(bfd->fhv, m, col, info);
    }
    {
#line 178
    if (tmp___3 == 0) {
#line 178
      goto case_0;
    }
#line 180
    if (tmp___3 == 1) {
#line 180
      goto case_1___0;
    }
#line 183
    if (tmp___3 == 2) {
#line 183
      goto case_2___0;
    }
#line 186
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 179
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 181
    ret = 1;
#line 182
    goto done;
    case_2___0: /* CIL Label */ 
#line 184
    ret = 2;
#line 185
    goto done;
    switch_default___0: /* CIL Label */ 
#line 187
    if ((unsigned long )bfd != (unsigned long )bfd) {
#line 187
      tmp___4 = 1;
    } else {
      {
#line 187
      _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                       187);
#line 187
      tmp___4 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 190
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
    {
#line 191
    tmp___5 = _glp_lpf_factorize(bfd->lpf, m, bh, col, info);
    }
    {
#line 192
    if (tmp___5 == 0) {
#line 192
      goto case_0___0;
    }
#line 207
    if (tmp___5 == 1) {
#line 207
      goto case_1___1;
    }
#line 210
    if (tmp___5 == 2) {
#line 210
      goto case_2___2;
    }
#line 213
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
    {
#line 195
    if (bfd->type == 2) {
#line 195
      goto case_2___1;
    }
#line 199
    if (bfd->type == 3) {
#line 199
      goto case_3___0;
    }
#line 203
    goto switch_default___1;
    case_2___1: /* CIL Label */ 
#line 197
    ((bfd->lpf)->scf)->t_opt = 1;
#line 198
    goto switch_break___2;
    case_3___0: /* CIL Label */ 
#line 201
    ((bfd->lpf)->scf)->t_opt = 2;
#line 202
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 204
    if ((unsigned long )bfd != (unsigned long )bfd) {
#line 204
      tmp___6 = 1;
    } else {
      {
#line 204
      _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                       204);
#line 204
      tmp___6 = 1;
      }
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 206
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
#line 208
    ret = 1;
#line 209
    goto done;
    case_2___2: /* CIL Label */ 
#line 211
    ret = 2;
#line 212
    goto done;
    switch_default___2: /* CIL Label */ 
#line 214
    if ((unsigned long )bfd != (unsigned long )bfd) {
#line 214
      tmp___7 = 1;
    } else {
      {
#line 214
      _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                       214);
#line 214
      tmp___7 = 1;
      }
    }
    switch_break___1: /* CIL Label */ ;
    }
  } else
#line 218
  if ((unsigned long )bfd != (unsigned long )bfd) {
#line 218
    tmp___8 = 1;
  } else {
    {
#line 218
    _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                     218);
#line 218
    tmp___8 = 1;
    }
  }
#line 220
  bfd->valid = 1;
#line 221
  bfd->upd_cnt = 0;
#line 222
  ret = 0;
  done: 
#line 224
  return (ret);
}
}
#line 247 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c"
void _glp_bfd_ftran(BFD___0 *bfd , double *x ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 248
  if (! bfd->valid) {
    {
#line 249
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c", 249);
#line 249
    (*tmp)("bfd_ftran: the factorization is not valid\n");
    }
  }
#line 250
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
    {
#line 251
    _glp_fhv_ftran(bfd->fhv, x);
    }
  } else
#line 252
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
    {
#line 253
    _glp_lpf_ftran(bfd->lpf, x);
    }
  } else
#line 255
  if ((unsigned long )bfd != (unsigned long )bfd) {
#line 255
    tmp___0 = 1;
  } else {
    {
#line 255
    _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                     255);
#line 255
    tmp___0 = 1;
    }
  }
#line 256
  return;
}
}
#line 280 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c"
void _glp_bfd_btran(BFD___0 *bfd , double *x ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 281
  if (! bfd->valid) {
    {
#line 282
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c", 282);
#line 282
    (*tmp)("bfd_btran: the factorization is not valid\n");
    }
  }
#line 283
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
    {
#line 284
    _glp_fhv_btran(bfd->fhv, x);
    }
  } else
#line 285
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
    {
#line 286
    _glp_lpf_btran(bfd->lpf, x);
    }
  } else
#line 288
  if ((unsigned long )bfd != (unsigned long )bfd) {
#line 288
    tmp___0 = 1;
  } else {
    {
#line 288
    _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                     288);
#line 288
    tmp___0 = 1;
    }
  }
#line 289
  return;
}
}
#line 340 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c"
int _glp_bfd_update_it(BFD___0 *bfd , int j , int bh , int len , int const   *ind ,
                       double const   *val ) 
{ 
  int ret ;
  xerror_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 343
  if (! bfd->valid) {
    {
#line 344
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c", 344);
#line 344
    (*tmp)("bfd_update_it: the factorization is not valid\n");
    }
  }
#line 346
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
    {
#line 347
    tmp___0 = _glp_fhv_update_it(bfd->fhv, j, len, ind, val);
    }
    {
#line 348
    if (tmp___0 == 0) {
#line 348
      goto case_0;
    }
#line 350
    if (tmp___0 == 1) {
#line 350
      goto case_1;
    }
#line 354
    if (tmp___0 == 3) {
#line 354
      goto case_3;
    }
#line 358
    if (tmp___0 == 4) {
#line 358
      goto case_4;
    }
#line 362
    if (tmp___0 == 5) {
#line 362
      goto case_5;
    }
#line 366
    goto switch_default;
    case_0: /* CIL Label */ 
#line 349
    goto switch_break;
    case_1: /* CIL Label */ 
#line 351
    bfd->valid = 0;
#line 352
    ret = 1;
#line 353
    goto done;
    case_3: /* CIL Label */ 
#line 355
    bfd->valid = 0;
#line 356
    ret = 3;
#line 357
    goto done;
    case_4: /* CIL Label */ 
#line 359
    bfd->valid = 0;
#line 360
    ret = 4;
#line 361
    goto done;
    case_5: /* CIL Label */ 
#line 363
    bfd->valid = 0;
#line 364
    ret = 5;
#line 365
    goto done;
    switch_default: /* CIL Label */ 
#line 367
    if ((unsigned long )bfd != (unsigned long )bfd) {
#line 367
      tmp___1 = 1;
    } else {
      {
#line 367
      _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                       367);
#line 367
      tmp___1 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  } else
#line 370
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
    {
#line 371
    tmp___2 = _glp_lpf_update_it(bfd->lpf, j, bh, len, ind, val);
    }
    {
#line 372
    if (tmp___2 == 0) {
#line 372
      goto case_0___0;
    }
#line 374
    if (tmp___2 == 1) {
#line 374
      goto case_1___0;
    }
#line 378
    if (tmp___2 == 3) {
#line 378
      goto case_3___0;
    }
#line 382
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
#line 373
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 375
    bfd->valid = 0;
#line 376
    ret = 1;
#line 377
    goto done;
    case_3___0: /* CIL Label */ 
#line 379
    bfd->valid = 0;
#line 380
    ret = 4;
#line 381
    goto done;
    switch_default___0: /* CIL Label */ 
#line 383
    if ((unsigned long )bfd != (unsigned long )bfd) {
#line 383
      tmp___3 = 1;
    } else {
      {
#line 383
      _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                       383);
#line 383
      tmp___3 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 387
  if ((unsigned long )bfd != (unsigned long )bfd) {
#line 387
    tmp___4 = 1;
  } else {
    {
#line 387
    _glp_lib_xassert("bfd != bfd", "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c",
                     387);
#line 387
    tmp___4 = 1;
    }
  }
#line 390
  (bfd->upd_cnt) ++;
#line 391
  ret = 0;
  done: 
#line 393
  return (ret);
}
}
#line 412 "/home/wslee/benchmarks/glpk-4.38/src/glpbfd.c"
void _glp_bfd_delete_it(BFD___0 *bfd ) 
{ 


  {
#line 413
  if ((unsigned long )bfd->fhv != (unsigned long )((void *)0)) {
    {
#line 413
    _glp_fhv_delete_it(bfd->fhv);
    }
  }
#line 414
  if ((unsigned long )bfd->lpf != (unsigned long )((void *)0)) {
    {
#line 414
    _glp_lpf_delete_it(bfd->lpf);
    }
  }
  {
#line 415
  _glp_lib_xfree((void *)bfd);
  }
#line 416
  return;
}
}
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
AVL *_glp_avl_create_tree(int (*fcmp___3)(void *info , void const   *key1 , void const   *key2 ) ,
                          void *info ) 
{ 
  AVL *tree ;
  void *tmp ;

  {
  {
#line 30
  tmp = _glp_lib_xmalloc((int )sizeof(AVL ));
#line 30
  tree = (AVL *)tmp;
#line 31
  tree->pool = _glp_dmp_create_pool();
#line 32
  tree->root = (AVLNODE *)((void *)0);
#line 33
  tree->fcmp = fcmp___3;
#line 34
  tree->info = info;
#line 35
  tree->size = 0;
#line 36
  tree->height = 0;
  }
#line 37
  return (tree);
}
}
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
int _glp_avl_strcmp(void *info , void const   *key1 , void const   *key2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 42
  if ((unsigned long )info == (unsigned long )info) {
#line 42
    tmp = 1;
  } else {
    {
#line 42
    _glp_lib_xassert("info == info", "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c",
                     42);
#line 42
    tmp = 1;
    }
  }
  {
#line 43
  tmp___0 = strcmp((char const   *)key1, (char const   *)key2);
  }
#line 43
  return (tmp___0);
}
}
#line 46
static AVLNODE *rotate_subtree(AVL *tree , AVLNODE *node ) ;
#line 48 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
AVLNODE *_glp_avl_insert_node(AVL *tree , void const   *key ) 
{ 
  AVLNODE *p ;
  AVLNODE *q ;
  AVLNODE *r ;
  short flag ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 53
  p = (AVLNODE *)((void *)0);
#line 53
  q = tree->root;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 54
      goto while_break;
    }
    {
#line 55
    p = q;
#line 56
    tmp = (*(tree->fcmp))(tree->info, key, p->key);
    }
#line 56
    if (tmp <= 0) {
#line 57
      flag = (short)0;
#line 58
      q = p->left;
#line 59
      (p->rank) ++;
    } else {
#line 62
      flag = (short)1;
#line 63
      q = p->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  tmp___0 = _glp_dmp_get_atom(tree->pool, (int )sizeof(AVLNODE ));
#line 67
  r = (AVLNODE *)tmp___0;
#line 68
  r->key = key;
#line 68
  r->type = 0;
#line 68
  r->link = (void *)0;
#line 69
  r->rank = 1;
#line 69
  r->up = p;
  }
#line 70
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 70
    tmp___1 = 0;
  } else {
#line 70
    tmp___1 = (int )flag;
  }
#line 70
  r->flag = (short )tmp___1;
#line 71
  r->bal = (short)0;
#line 71
  r->left = (AVLNODE *)((void *)0);
#line 71
  r->right = (AVLNODE *)((void *)0);
#line 72
  (tree->size) ++;
#line 73
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 74
    tree->root = r;
  } else
#line 76
  if ((int )flag == 0) {
#line 76
    p->left = r;
  } else {
#line 76
    p->right = r;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 79
      goto while_break___0;
    }
#line 80
    if ((int )flag == 0) {
#line 82
      if ((int )p->bal > 0) {
#line 83
        p->bal = (short)0;
#line 84
        goto while_break___0;
      }
#line 86
      if ((int )p->bal < 0) {
        {
#line 87
        rotate_subtree(tree, p);
        }
#line 88
        goto while_break___0;
      }
#line 90
      p->bal = (short)-1;
#line 90
      flag = p->flag;
#line 90
      p = p->up;
    } else {
#line 94
      if ((int )p->bal < 0) {
#line 95
        p->bal = (short)0;
#line 96
        goto while_break___0;
      }
#line 98
      if ((int )p->bal > 0) {
        {
#line 99
        rotate_subtree(tree, p);
        }
#line 100
        goto while_break___0;
      }
#line 102
      p->bal = (short)1;
#line 102
      flag = p->flag;
#line 102
      p = p->up;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 107
    (tree->height) ++;
  }
#line 108
  return (r);
}
}
#line 111 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
void _glp_avl_set_node_type(AVLNODE *node , int type ) 
{ 


  {
#line 113
  node->type = type;
#line 114
  return;
}
}
#line 117 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
void _glp_avl_set_node_link(AVLNODE *node , void *link ) 
{ 


  {
#line 119
  node->link = link;
#line 120
  return;
}
}
#line 123 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
AVLNODE *_glp_avl_find_node(AVL *tree , void const   *key ) 
{ 
  AVLNODE *p ;
  int c ;

  {
#line 127
  p = tree->root;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 128
      goto while_break;
    }
    {
#line 129
    c = (*(tree->fcmp))(tree->info, key, p->key);
    }
#line 130
    if (c == 0) {
#line 130
      goto while_break;
    }
#line 131
    if (c < 0) {
#line 131
      p = p->left;
    } else {
#line 131
      p = p->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (p);
}
}
#line 136 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
int _glp_avl_get_node_type(AVLNODE *node ) 
{ 


  {
#line 138
  return (node->type);
}
}
#line 141 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
void *_glp_avl_get_node_link(AVLNODE *node ) 
{ 


  {
#line 143
  return (node->link);
}
}
#line 146 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
static AVLNODE *find_next_node(AVL *tree , AVLNODE *node ) 
{ 
  AVLNODE *p ;
  AVLNODE *q ;

  {
#line 149
  if ((unsigned long )tree->root == (unsigned long )((void *)0)) {
#line 149
    return ((AVLNODE *)((void *)0));
  }
#line 150
  p = node;
#line 151
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 151
    q = tree->root;
  } else {
#line 151
    q = p->right;
  }
#line 152
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    {
#line 154
    while (1) {
      while_continue: /* CIL Label */ ;
#line 155
      q = p->up;
#line 156
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 156
        goto while_break;
      }
#line 157
      if ((int )p->flag == 0) {
#line 157
        goto while_break;
      }
#line 158
      p = q;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 164
      p = q->left;
#line 165
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 165
        goto while_break___0;
      }
#line 166
      q = p;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 169
  return (q);
}
}
#line 172 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
void _glp_avl_delete_node(AVL *tree , AVLNODE *node ) 
{ 
  AVLNODE *f ;
  AVLNODE *p ;
  AVLNODE *q ;
  AVLNODE *r ;
  AVLNODE *s ;
  AVLNODE *x ;
  AVLNODE *y ;
  short flag ;
  int tmp ;
  int tmp___0 ;

  {
#line 176
  p = node;
#line 180
  if ((unsigned long )p->left == (unsigned long )((void *)0)) {
#line 180
    goto skip;
  } else
#line 180
  if ((unsigned long )p->right == (unsigned long )((void *)0)) {
#line 180
    goto skip;
  }
  {
#line 181
  f = p->up;
#line 181
  q = p->left;
#line 182
  r = find_next_node(tree, p);
#line 182
  s = r->right;
  }
#line 183
  if ((unsigned long )p->right == (unsigned long )r) {
#line 184
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 185
      tree->root = r;
    } else
#line 187
    if ((int )p->flag == 0) {
#line 187
      f->left = r;
    } else {
#line 187
      f->right = r;
    }
#line 188
    r->rank = p->rank;
#line 188
    r->up = f;
#line 189
    r->flag = p->flag;
#line 189
    r->bal = p->bal;
#line 190
    r->left = q;
#line 190
    r->right = p;
#line 191
    q->up = r;
#line 192
    p->rank = 1;
#line 192
    p->up = r;
#line 192
    p->flag = (short)1;
#line 193
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 193
      tmp = 0;
    } else {
#line 193
      tmp = 1;
    }
#line 193
    p->bal = (short )tmp;
#line 194
    p->left = (AVLNODE *)((void *)0);
#line 194
    p->right = s;
#line 195
    if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 195
      s->up = p;
    }
  } else {
#line 198
    x = p->right;
#line 198
    y = r->up;
#line 199
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 200
      tree->root = r;
    } else
#line 202
    if ((int )p->flag == 0) {
#line 202
      f->left = r;
    } else {
#line 202
      f->right = r;
    }
#line 203
    r->rank = p->rank;
#line 203
    r->up = f;
#line 204
    r->flag = p->flag;
#line 204
    r->bal = p->bal;
#line 205
    r->left = q;
#line 205
    r->right = x;
#line 206
    q->up = r;
#line 206
    x->up = r;
#line 206
    y->left = p;
#line 207
    p->rank = 1;
#line 207
    p->up = y;
#line 207
    p->flag = (short)0;
#line 208
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 208
      tmp___0 = 0;
    } else {
#line 208
      tmp___0 = 1;
    }
#line 208
    p->bal = (short )tmp___0;
#line 209
    p->left = (AVLNODE *)((void *)0);
#line 209
    p->right = s;
#line 210
    if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 210
      s->up = p;
    }
  }
  skip: 
#line 215
  q = p;
#line 215
  f = q->up;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 216
      goto while_break;
    }
#line 217
    if ((int )q->flag == 0) {
#line 217
      (f->rank) --;
    }
#line 218
    q = f;
#line 218
    f = q->up;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  f = p->up;
#line 221
  flag = p->flag;
#line 222
  if ((unsigned long )p->left != (unsigned long )((void *)0)) {
#line 222
    q = p->left;
  } else {
#line 222
    q = p->right;
  }
#line 223
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 224
    tree->root = q;
  } else
#line 226
  if ((int )flag == 0) {
#line 226
    f->left = q;
  } else {
#line 226
    f->right = q;
  }
#line 227
  if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 227
    q->up = f;
#line 227
    q->flag = flag;
  }
#line 228
  (tree->size) --;
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 231
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 231
      goto while_break___0;
    }
#line 232
    if ((int )flag == 0) {
#line 234
      if ((int )f->bal == 0) {
#line 235
        f->bal = (short)1;
#line 236
        goto while_break___0;
      }
#line 238
      if ((int )f->bal < 0) {
#line 239
        f->bal = (short)0;
      } else {
        {
#line 241
        f = rotate_subtree(tree, f);
        }
#line 242
        if ((int )f->bal < 0) {
#line 242
          goto while_break___0;
        }
      }
#line 244
      flag = f->flag;
#line 244
      f = f->up;
    } else {
#line 248
      if ((int )f->bal == 0) {
#line 249
        f->bal = (short)-1;
#line 250
        goto while_break___0;
      }
#line 252
      if ((int )f->bal > 0) {
#line 253
        f->bal = (short)0;
      } else {
        {
#line 255
        f = rotate_subtree(tree, f);
        }
#line 256
        if ((int )f->bal > 0) {
#line 256
          goto while_break___0;
        }
      }
#line 258
      flag = f->flag;
#line 258
      f = f->up;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 263
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 263
    (tree->height) --;
  }
  {
#line 265
  _glp_dmp_free_atom(tree->pool, (void *)p, (int )sizeof(AVLNODE ));
  }
#line 266
  return;
}
}
#line 269 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
static AVLNODE *rotate_subtree(AVL *tree , AVLNODE *node ) 
{ 
  AVLNODE *f ;
  AVLNODE *p ;
  AVLNODE *q ;
  AVLNODE *r ;
  AVLNODE *x ;
  AVLNODE *y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 272
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 272
    tmp = 1;
  } else {
    {
#line 272
    _glp_lib_xassert("node != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c",
                     272);
#line 272
    tmp = 1;
    }
  }
#line 273
  p = node;
#line 274
  if ((int )p->bal < 0) {
#line 276
    f = p->up;
#line 276
    q = p->left;
#line 276
    r = q->right;
#line 277
    if ((int )q->bal <= 0) {
#line 279
      if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 280
        tree->root = q;
      } else
#line 282
      if ((int )p->flag == 0) {
#line 282
        f->left = q;
      } else {
#line 282
        f->right = q;
      }
#line 283
      p->rank -= q->rank;
#line 284
      q->up = f;
#line 284
      q->flag = p->flag;
#line 284
      q->bal = (short )((int )q->bal + 1);
#line 284
      q->right = p;
#line 285
      p->up = q;
#line 285
      p->flag = (short)1;
#line 286
      p->bal = (short )(- ((int )q->bal));
#line 286
      p->left = r;
#line 287
      if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 287
        r->up = p;
#line 287
        r->flag = (short)0;
      }
#line 288
      node = q;
    } else {
#line 292
      x = r->left;
#line 292
      y = r->right;
#line 293
      if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 294
        tree->root = r;
      } else
#line 296
      if ((int )p->flag == 0) {
#line 296
        f->left = r;
      } else {
#line 296
        f->right = r;
      }
#line 297
      p->rank -= q->rank + r->rank;
#line 298
      r->rank += q->rank;
#line 299
      if ((int )r->bal >= 0) {
#line 299
        tmp___0 = 0;
      } else {
#line 299
        tmp___0 = 1;
      }
#line 299
      p->bal = (short )tmp___0;
#line 300
      if ((int )r->bal <= 0) {
#line 300
        tmp___1 = 0;
      } else {
#line 300
        tmp___1 = -1;
      }
#line 300
      q->bal = (short )tmp___1;
#line 301
      r->up = f;
#line 301
      r->flag = p->flag;
#line 301
      r->bal = (short)0;
#line 302
      r->left = q;
#line 302
      r->right = p;
#line 303
      p->up = r;
#line 303
      p->flag = (short)1;
#line 303
      p->left = y;
#line 304
      q->up = r;
#line 304
      q->flag = (short)0;
#line 304
      q->right = x;
#line 305
      if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 305
        x->up = q;
#line 305
        x->flag = (short)1;
      }
#line 306
      if ((unsigned long )y != (unsigned long )((void *)0)) {
#line 306
        y->up = p;
#line 306
        y->flag = (short)0;
      }
#line 307
      node = r;
    }
  } else {
#line 312
    f = p->up;
#line 312
    q = p->right;
#line 312
    r = q->left;
#line 313
    if ((int )q->bal >= 0) {
#line 315
      if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 316
        tree->root = q;
      } else
#line 318
      if ((int )p->flag == 0) {
#line 318
        f->left = q;
      } else {
#line 318
        f->right = q;
      }
#line 319
      q->rank += p->rank;
#line 320
      q->up = f;
#line 320
      q->flag = p->flag;
#line 320
      q->bal = (short )((int )q->bal - 1);
#line 320
      q->left = p;
#line 321
      p->up = q;
#line 321
      p->flag = (short)0;
#line 322
      p->bal = (short )(- ((int )q->bal));
#line 322
      p->right = r;
#line 323
      if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 323
        r->up = p;
#line 323
        r->flag = (short)1;
      }
#line 324
      node = q;
    } else {
#line 328
      x = r->left;
#line 328
      y = r->right;
#line 329
      if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 330
        tree->root = r;
      } else
#line 332
      if ((int )p->flag == 0) {
#line 332
        f->left = r;
      } else {
#line 332
        f->right = r;
      }
#line 333
      q->rank -= r->rank;
#line 334
      r->rank += p->rank;
#line 335
      if ((int )r->bal <= 0) {
#line 335
        tmp___2 = 0;
      } else {
#line 335
        tmp___2 = -1;
      }
#line 335
      p->bal = (short )tmp___2;
#line 336
      if ((int )r->bal >= 0) {
#line 336
        tmp___3 = 0;
      } else {
#line 336
        tmp___3 = 1;
      }
#line 336
      q->bal = (short )tmp___3;
#line 337
      r->up = f;
#line 337
      r->flag = p->flag;
#line 337
      r->bal = (short)0;
#line 338
      r->left = p;
#line 338
      r->right = q;
#line 339
      p->up = r;
#line 339
      p->flag = (short)0;
#line 339
      p->right = x;
#line 340
      q->up = r;
#line 340
      q->flag = (short)1;
#line 340
      q->left = y;
#line 341
      if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 341
        x->up = p;
#line 341
        x->flag = (short)1;
      }
#line 342
      if ((unsigned long )y != (unsigned long )((void *)0)) {
#line 342
        y->up = q;
#line 342
        y->flag = (short)0;
      }
#line 343
      node = r;
    }
  }
#line 346
  return (node);
}
}
#line 349 "/home/wslee/benchmarks/glpk-4.38/src/glpavl.c"
void _glp_avl_delete_tree(AVL *tree ) 
{ 


  {
  {
#line 351
  _glp_dmp_delete_pool(tree->pool);
#line 352
  _glp_lib_xfree((void *)tree);
  }
#line 353
  return;
}
}
#line 155 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 485 "./../include/glpk.h"
void glp_init_iptcp(glp_iptcp *parm ) ;
#line 539
int glp_read_sol(glp_prob *lp , char const   *fname ) ;
#line 542
int glp_write_sol(glp_prob *lp , char const   *fname ) ;
#line 548
int glp_read_ipt(glp_prob *lp , char const   *fname ) ;
#line 551
int glp_write_ipt(glp_prob *lp , char const   *fname ) ;
#line 557
int glp_read_mip(glp_prob *mip , char const   *fname ) ;
#line 560
int glp_write_mip(glp_prob *mip , char const   *fname ) ;
#line 700
extern int glp_mpl_postsolve(glp_tran *tran , glp_prob *prob , int sol ) ;
#line 780
glp_graph *glp_create_graph(int v_size , int a_size ) ;
#line 795
void glp_delete_graph(glp_graph *G ) ;
#line 804
void glp_mincost_lp(glp_prob *lp , glp_graph *G , int names , int v_rhs , int a_low ,
                    int a_cap , int a_cost ) ;
#line 812
void glp_maxflow_lp(glp_prob *lp , glp_graph *G , int names , int s , int t , int a_cap ) ;
#line 859
char const   *glp_version(void) ;
#line 884
void glp_mem_limit(int limit ) ;
#line 112 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
static void print_help(char const   *my_name ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;

  {
  {
#line 114
  _glp_lib_xprintf("Usage: %s [options...] filename\n", my_name);
#line 115
  _glp_lib_xprintf("\n");
#line 116
  _glp_lib_xprintf("General options:\n");
#line 117
  _glp_lib_xprintf("   --mps             read LP/MIP problem in fixed MPS format\n");
#line 119
  _glp_lib_xprintf("   --freemps         read LP/MIP problem in free MPS format (default)\n");
#line 121
  _glp_lib_xprintf("   --cpxlp           read LP/MIP problem in CPLEX LP format\n");
#line 123
  _glp_lib_xprintf("   --math            read LP/MIP model written in GNU MathProg modeling\n");
#line 125
  _glp_lib_xprintf("                     language\n");
#line 126
  _glp_lib_xprintf("   -m filename, --model filename\n");
#line 127
  _glp_lib_xprintf("                     read model section and optional data section from\n");
#line 129
  _glp_lib_xprintf("                     filename (the same as --math)\n");
#line 130
  _glp_lib_xprintf("   -d filename, --data filename\n");
#line 131
  _glp_lib_xprintf("                     read data section from filename (for --math only);\n");
#line 133
  _glp_lib_xprintf("                     if model file also has data section, it is ignored\n");
#line 135
  _glp_lib_xprintf("   -y filename, --display filename\n");
#line 136
  _glp_lib_xprintf("                     send display output to filename (for --math only);\n");
#line 138
  _glp_lib_xprintf("                     by default the output is sent to terminal\n");
#line 140
  _glp_lib_xprintf("   --mincost         read min-cost flow problem in DIMACS format\n");
#line 142
  _glp_lib_xprintf("   --maxflow         read maximum flow problem in DIMACS format\n");
#line 144
  _glp_lib_xprintf("   --simplex         use simplex method (default)\n");
#line 145
  _glp_lib_xprintf("   --interior        use interior point method (LP only)\n");
#line 147
  _glp_lib_xprintf("   -r filename, --read filename\n");
#line 148
  _glp_lib_xprintf("                     read solution from filename rather to find it with\n");
#line 150
  _glp_lib_xprintf("                     the solver\n");
#line 151
  _glp_lib_xprintf("   --min             minimization\n");
#line 152
  _glp_lib_xprintf("   --max             maximization\n");
#line 153
  _glp_lib_xprintf("   --scale           scale problem (default)\n");
#line 154
  _glp_lib_xprintf("   --noscale         do not scale problem\n");
#line 155
  _glp_lib_xprintf("   -o filename, --output filename\n");
#line 156
  _glp_lib_xprintf("                     write solution to filename in printable format\n");
#line 158
  _glp_lib_xprintf("   -w filename, --write filename\n");
#line 159
  _glp_lib_xprintf("                     write solution to filename in plain text format\n");
#line 161
  _glp_lib_xprintf("   --bounds filename\n");
#line 162
  _glp_lib_xprintf("                     write sensitivity bounds to filename in printable\n");
#line 164
  _glp_lib_xprintf("                     format (LP only)\n");
#line 165
  _glp_lib_xprintf("   --tmlim nnn       limit solution time to nnn seconds \n");
#line 167
  _glp_lib_xprintf("   --memlim nnn      limit available memory to nnn megabytes\n");
#line 169
  _glp_lib_xprintf("   --check           do not solve problem, check input data only\n");
#line 171
  _glp_lib_xprintf("   --name probname   change problem name to probname\n");
#line 172
  _glp_lib_xprintf("   --wmps filename   write problem to filename in fixed MPS format\n");
#line 174
  _glp_lib_xprintf("   --wfreemps filename\n");
#line 175
  _glp_lib_xprintf("                     write problem to filename in free MPS format\n");
#line 177
  _glp_lib_xprintf("   --wcpxlp filename write problem to filename in CPLEX LP format\n");
#line 179
  _glp_lib_xprintf("   --wpb filename    write problem to filename in OPB format\n");
#line 181
  _glp_lib_xprintf("   --wnpb filename   write problem to filename in normalized OPB format\n");
#line 183
  _glp_lib_xprintf("   --log filename    write copy of terminal output to filename\n");
#line 185
  _glp_lib_xprintf("   -h, --help        display this help information and exit\n");
#line 187
  _glp_lib_xprintf("   -v, --version     display program version and exit\n");
#line 189
  _glp_lib_xprintf("\n");
#line 190
  _glp_lib_xprintf("LP basis factorization options:\n");
#line 191
  _glp_lib_xprintf("   --luf             LU + Forrest-Tomlin update\n");
#line 192
  _glp_lib_xprintf("                     (faster, less stable; default)\n");
#line 193
  _glp_lib_xprintf("   --cbg             LU + Schur complement + Bartels-Golub update\n");
#line 195
  _glp_lib_xprintf("                     (slower, more stable)\n");
#line 196
  _glp_lib_xprintf("   --cgr             LU + Schur complement + Givens rotation update\n");
#line 198
  _glp_lib_xprintf("                     (slower, more stable)\n");
#line 199
  _glp_lib_xprintf("\n");
#line 200
  _glp_lib_xprintf("Options specific to simplex solver:\n");
#line 201
  _glp_lib_xprintf("   --primal          use primal simplex (default)\n");
#line 202
  _glp_lib_xprintf("   --dual            use dual simplex\n");
#line 203
  _glp_lib_xprintf("   --std             use standard initial basis of all slacks\n");
#line 205
  _glp_lib_xprintf("   --adv             use advanced initial basis (default)\n");
#line 207
  _glp_lib_xprintf("   --bib             use Bixby\'s initial basis\n");
#line 208
  _glp_lib_xprintf("   --steep           use steepest edge technique (default)\n");
#line 210
  _glp_lib_xprintf("   --nosteep         use standard \"textbook\" pricing\n");
#line 212
  _glp_lib_xprintf("   --relax           use Harris\' two-pass ratio test (default)\n");
#line 214
  _glp_lib_xprintf("   --norelax         use standard \"textbook\" ratio test\n");
#line 216
  _glp_lib_xprintf("   --presol          use presolver (default; assumes --scale and --adv)\n");
#line 218
  _glp_lib_xprintf("   --nopresol        do not use presolver\n");
#line 219
  _glp_lib_xprintf("   --exact           use simplex method based on exact arithmetic\n");
#line 221
  _glp_lib_xprintf("   --xcheck          check final basis using exact arithmetic\n");
#line 223
  _glp_lib_xprintf("\n");
#line 224
  _glp_lib_xprintf("Options specific to interior-point solver:\n");
#line 225
  _glp_lib_xprintf("   --nord            use natural (original) ordering\n");
#line 226
  _glp_lib_xprintf("   --qmd             use quotient minimum degree ordering\n");
#line 228
  _glp_lib_xprintf("   --amd             use approximate minimum degree ordering (default)\n");
#line 230
  _glp_lib_xprintf("   --symamd          use approximate minimum degree ordering\n");
#line 232
  _glp_lib_xprintf("\n");
#line 233
  _glp_lib_xprintf("Options specific to MIP solver:\n");
#line 234
  _glp_lib_xprintf("   --nomip           consider all integer variables as continuous\n");
#line 236
  _glp_lib_xprintf("                     (allows solving MIP as pure LP)\n");
#line 237
  _glp_lib_xprintf("   --first           branch on first integer variable\n");
#line 239
  _glp_lib_xprintf("   --last            branch on last integer variable\n");
#line 240
  _glp_lib_xprintf("   --drtom           branch using heuristic by Driebeck and Tomlin\n");
#line 242
  _glp_lib_xprintf("                     (default)\n");
#line 243
  _glp_lib_xprintf("   --mostf           branch on most fractional variable \n");
#line 245
  _glp_lib_xprintf("   --dfs             backtrack using depth first search \n");
#line 247
  _glp_lib_xprintf("   --bfs             backtrack using breadth first search\n");
#line 249
  _glp_lib_xprintf("   --bestp           backtrack using the best projection heuristic\n");
#line 251
  _glp_lib_xprintf("   --bestb           backtrack using node with best local bound\n");
#line 253
  _glp_lib_xprintf("                     (default)\n");
#line 254
  _glp_lib_xprintf("   --intopt          use MIP presolver (default)\n");
#line 255
  _glp_lib_xprintf("   --nointopt        do not use MIP presolver\n");
#line 256
  _glp_lib_xprintf("   --binarize        replace general integer variables by binary ones\n");
#line 258
  _glp_lib_xprintf("                     (assumes --intopt)\n");
#line 259
  _glp_lib_xprintf("   --fpump           apply feasibility pump heuristic\n");
#line 261
  _glp_lib_xprintf("   --gomory          generate Gomory\'s mixed integer cuts\n");
#line 263
  _glp_lib_xprintf("   --mir             generate MIR (mixed integer rounding) cuts\n");
#line 265
  _glp_lib_xprintf("   --cover           generate mixed cover cuts\n");
#line 266
  _glp_lib_xprintf("   --clique          generate clique cuts\n");
#line 267
  _glp_lib_xprintf("   --cuts            generate all cuts above\n");
#line 268
  _glp_lib_xprintf("   --mipgap tol      set relative mip gap tolerance to tol\n");
#line 270
  _glp_lib_xprintf("\n");
#line 271
  _glp_lib_xprintf("For description of the MPS and CPLEX LP formats see Reference Manual.\n");
#line 273
  _glp_lib_xprintf("For description of the modeling language see \"GLPK: Modeling Language\n");
#line 275
  _glp_lib_xprintf("GNU MathProg\". Both documents are included in the GLPK distribution.\n");
#line 277
  _glp_lib_xprintf("\n");
#line 278
  _glp_lib_xprintf("See GLPK web page at <http://www.gnu.org/software/glpk/glpk.html>.\n");
#line 280
  _glp_lib_xprintf("\n");
#line 281
  _glp_lib_xprintf("Please report bugs to <bug-glpk@gnu.org>.\n");
  }
#line 282
  return;
}
}
#line 285 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
static void print_version(int briefly ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 287
  tmp = glp_version();
#line 287
  _glp_lib_xprintf("GLPSOL: GLPK LP/MIP Solver %s\n", tmp);
  }
#line 288
  if (briefly) {
#line 288
    goto done;
  }
  {
#line 289
  _glp_lib_xprintf("\n");
#line 290
  _glp_lib_xprintf("Copyright (C) 2008 Andrew Makhorin, Department for Applied Informatics,\n");
#line 292
  _glp_lib_xprintf("Moscow Aviation Institute, Moscow, Russia. All rights reserved.\n");
#line 294
  _glp_lib_xprintf("\n");
#line 295
  _glp_lib_xprintf("This program has ABSOLUTELY NO WARRANTY.\n");
#line 296
  _glp_lib_xprintf("\n");
#line 297
  _glp_lib_xprintf("This program is free software; you may re-distribute it under the terms\n");
#line 299
  _glp_lib_xprintf("of the GNU General Public License version 3 or later.\n");
  }
  done: 
#line 301
  return;
}
}
#line 304 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
static int parse_cmdline(struct csa___7 *csa , int argc , char const   **argv ) 
{ 
  int k ;
  int tm_lim ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int mem_lim ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double mip_gap ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;

  {
#line 308
  k = 1;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (k < argc)) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp___87 = strcmp(*(argv + k), "--mps");
    }
#line 309
    if (tmp___87 == 0) {
#line 310
      csa->format = 1;
    } else {
      {
#line 311
      tmp___86 = strcmp(*(argv + k), "--freemps");
      }
#line 311
      if (tmp___86 == 0) {
#line 312
        csa->format = 2;
      } else {
        {
#line 313
        tmp___85 = strcmp(*(argv + k), "--cpxlp");
        }
#line 313
        if (tmp___85 == 0) {
#line 314
          csa->format = 3;
        } else {
          {
#line 315
          tmp___82 = strcmp(*(argv + k), "--math");
          }
#line 315
          if (tmp___82 == 0) {
#line 316
            csa->format = 4;
          } else {
            {
#line 315
            tmp___83 = strcmp(*(argv + k), "-m");
            }
#line 315
            if (tmp___83 == 0) {
#line 316
              csa->format = 4;
            } else {
              {
#line 315
              tmp___84 = strcmp(*(argv + k), "--model");
              }
#line 315
              if (tmp___84 == 0) {
#line 316
                csa->format = 4;
              } else {
                {
#line 317
                tmp___80 = strcmp(*(argv + k), "-d");
                }
#line 317
                if (tmp___80 == 0) {
#line 317
                  goto _L___5;
                } else {
                  {
#line 317
                  tmp___81 = strcmp(*(argv + k), "--data");
                  }
#line 317
                  if (tmp___81 == 0) {
                    _L___5: /* CIL Label */ 
#line 318
                    k ++;
#line 319
                    if (k == argc) {
                      {
#line 320
                      _glp_lib_xprintf("No input data file specifed\n");
                      }
#line 321
                      return (1);
                    } else
#line 319
                    if ((int const   )*(*(argv + k) + 0) == 0) {
                      {
#line 320
                      _glp_lib_xprintf("No input data file specifed\n");
                      }
#line 321
                      return (1);
                    } else
#line 319
                    if ((int const   )*(*(argv + k) + 0) == 45) {
                      {
#line 320
                      _glp_lib_xprintf("No input data file specifed\n");
                      }
#line 321
                      return (1);
                    }
#line 323
                    if (csa->ndf == 10) {
                      {
#line 324
                      _glp_lib_xprintf("Too many input data files\n");
                      }
#line 325
                      return (1);
                    }
#line 327
                    (csa->ndf) ++;
#line 327
                    csa->in_data[csa->ndf] = *(argv + k);
                  } else {
                    {
#line 329
                    tmp___78 = strcmp(*(argv + k), "-y");
                    }
#line 329
                    if (tmp___78 == 0) {
#line 329
                      goto _L___4;
                    } else {
                      {
#line 329
                      tmp___79 = strcmp(*(argv + k), "--display");
                      }
#line 329
                      if (tmp___79 == 0) {
                        _L___4: /* CIL Label */ 
#line 330
                        k ++;
#line 331
                        if (k == argc) {
                          {
#line 332
                          _glp_lib_xprintf("No display output file specifed\n");
                          }
#line 333
                          return (1);
                        } else
#line 331
                        if ((int const   )*(*(argv + k) + 0) == 0) {
                          {
#line 332
                          _glp_lib_xprintf("No display output file specifed\n");
                          }
#line 333
                          return (1);
                        } else
#line 331
                        if ((int const   )*(*(argv + k) + 0) == 45) {
                          {
#line 332
                          _glp_lib_xprintf("No display output file specifed\n");
                          }
#line 333
                          return (1);
                        }
#line 335
                        if ((unsigned long )csa->out_dpy != (unsigned long )((void *)0)) {
                          {
#line 336
                          _glp_lib_xprintf("Only one display output file allowed\n");
                          }
#line 337
                          return (1);
                        }
#line 339
                        csa->out_dpy = *(argv + k);
                      } else {
                        {
#line 341
                        tmp___77 = strcmp(*(argv + k), "--mincost");
                        }
#line 341
                        if (tmp___77 == 0) {
#line 342
                          csa->format = 5;
                        } else {
                          {
#line 343
                          tmp___76 = strcmp(*(argv + k), "--maxflow");
                          }
#line 343
                          if (tmp___76 == 0) {
#line 344
                            csa->format = 6;
                          } else {
                            {
#line 345
                            tmp___75 = strcmp(*(argv + k), "--simplex");
                            }
#line 345
                            if (tmp___75 == 0) {
#line 346
                              csa->solution = 1;
                            } else {
                              {
#line 347
                              tmp___74 = strcmp(*(argv + k), "--interior");
                              }
#line 347
                              if (tmp___74 == 0) {
#line 348
                                csa->solution = 2;
                              } else {
                                {
#line 349
                                tmp___72 = strcmp(*(argv + k), "-r");
                                }
#line 349
                                if (tmp___72 == 0) {
#line 349
                                  goto _L___3;
                                } else {
                                  {
#line 349
                                  tmp___73 = strcmp(*(argv + k), "--read");
                                  }
#line 349
                                  if (tmp___73 == 0) {
                                    _L___3: /* CIL Label */ 
#line 350
                                    k ++;
#line 351
                                    if (k == argc) {
                                      {
#line 352
                                      _glp_lib_xprintf("No input solution file specifed\n");
                                      }
#line 353
                                      return (1);
                                    } else
#line 351
                                    if ((int const   )*(*(argv + k) + 0) == 0) {
                                      {
#line 352
                                      _glp_lib_xprintf("No input solution file specifed\n");
                                      }
#line 353
                                      return (1);
                                    } else
#line 351
                                    if ((int const   )*(*(argv + k) + 0) == 45) {
                                      {
#line 352
                                      _glp_lib_xprintf("No input solution file specifed\n");
                                      }
#line 353
                                      return (1);
                                    }
#line 355
                                    if ((unsigned long )csa->in_res != (unsigned long )((void *)0)) {
                                      {
#line 356
                                      _glp_lib_xprintf("Only one input solution file allowed\n");
                                      }
#line 357
                                      return (1);
                                    }
#line 359
                                    csa->in_res = *(argv + k);
                                  } else {
                                    {
#line 361
                                    tmp___71 = strcmp(*(argv + k), "--min");
                                    }
#line 361
                                    if (tmp___71 == 0) {
#line 362
                                      csa->dir = 1;
                                    } else {
                                      {
#line 363
                                      tmp___70 = strcmp(*(argv + k), "--max");
                                      }
#line 363
                                      if (tmp___70 == 0) {
#line 364
                                        csa->dir = 2;
                                      } else {
                                        {
#line 365
                                        tmp___69 = strcmp(*(argv + k), "--scale");
                                        }
#line 365
                                        if (tmp___69 == 0) {
#line 366
                                          csa->scale = 1;
                                        } else {
                                          {
#line 367
                                          tmp___68 = strcmp(*(argv + k), "--noscale");
                                          }
#line 367
                                          if (tmp___68 == 0) {
#line 368
                                            csa->scale = 0;
                                          } else {
                                            {
#line 369
                                            tmp___66 = strcmp(*(argv + k), "-o");
                                            }
#line 369
                                            if (tmp___66 == 0) {
#line 369
                                              goto _L___2;
                                            } else {
                                              {
#line 369
                                              tmp___67 = strcmp(*(argv + k), "--output");
                                              }
#line 369
                                              if (tmp___67 == 0) {
                                                _L___2: /* CIL Label */ 
#line 370
                                                k ++;
#line 371
                                                if (k == argc) {
                                                  {
#line 372
                                                  _glp_lib_xprintf("No output solution file specified\n");
                                                  }
#line 373
                                                  return (1);
                                                } else
#line 371
                                                if ((int const   )*(*(argv + k) + 0) == 0) {
                                                  {
#line 372
                                                  _glp_lib_xprintf("No output solution file specified\n");
                                                  }
#line 373
                                                  return (1);
                                                } else
#line 371
                                                if ((int const   )*(*(argv + k) + 0) == 45) {
                                                  {
#line 372
                                                  _glp_lib_xprintf("No output solution file specified\n");
                                                  }
#line 373
                                                  return (1);
                                                }
#line 375
                                                if ((unsigned long )csa->out_sol != (unsigned long )((void *)0)) {
                                                  {
#line 376
                                                  _glp_lib_xprintf("Only one output solution file allowed\n");
                                                  }
#line 377
                                                  return (1);
                                                }
#line 379
                                                csa->out_sol = *(argv + k);
                                              } else {
                                                {
#line 381
                                                tmp___64 = strcmp(*(argv + k), "-w");
                                                }
#line 381
                                                if (tmp___64 == 0) {
#line 381
                                                  goto _L___1;
                                                } else {
                                                  {
#line 381
                                                  tmp___65 = strcmp(*(argv + k), "--write");
                                                  }
#line 381
                                                  if (tmp___65 == 0) {
                                                    _L___1: /* CIL Label */ 
#line 382
                                                    k ++;
#line 383
                                                    if (k == argc) {
                                                      {
#line 384
                                                      _glp_lib_xprintf("No output solution file specifed\n");
                                                      }
#line 385
                                                      return (1);
                                                    } else
#line 383
                                                    if ((int const   )*(*(argv + k) + 0) == 0) {
                                                      {
#line 384
                                                      _glp_lib_xprintf("No output solution file specifed\n");
                                                      }
#line 385
                                                      return (1);
                                                    } else
#line 383
                                                    if ((int const   )*(*(argv + k) + 0) == 45) {
                                                      {
#line 384
                                                      _glp_lib_xprintf("No output solution file specifed\n");
                                                      }
#line 385
                                                      return (1);
                                                    }
#line 387
                                                    if ((unsigned long )csa->out_res != (unsigned long )((void *)0)) {
                                                      {
#line 388
                                                      _glp_lib_xprintf("Only one output solution file allowed\n");
                                                      }
#line 389
                                                      return (1);
                                                    }
#line 391
                                                    csa->out_res = *(argv + k);
                                                  } else {
                                                    {
#line 393
                                                    tmp___63 = strcmp(*(argv + k),
                                                                      "--bounds");
                                                    }
#line 393
                                                    if (tmp___63 == 0) {
#line 394
                                                      k ++;
#line 395
                                                      if (k == argc) {
                                                        {
#line 396
                                                        _glp_lib_xprintf("No sensitivity bounds output file specified\n");
                                                        }
#line 397
                                                        return (1);
                                                      } else
#line 395
                                                      if ((int const   )*(*(argv + k) + 0) == 0) {
                                                        {
#line 396
                                                        _glp_lib_xprintf("No sensitivity bounds output file specified\n");
                                                        }
#line 397
                                                        return (1);
                                                      } else
#line 395
                                                      if ((int const   )*(*(argv + k) + 0) == 45) {
                                                        {
#line 396
                                                        _glp_lib_xprintf("No sensitivity bounds output file specified\n");
                                                        }
#line 397
                                                        return (1);
                                                      }
#line 399
                                                      if ((unsigned long )csa->out_bnds != (unsigned long )((void *)0)) {
                                                        {
#line 400
                                                        _glp_lib_xprintf("Only one sensitivity bounds output file allowed\n");
                                                        }
#line 402
                                                        return (1);
                                                      }
#line 404
                                                      csa->out_bnds = *(argv + k);
                                                    } else {
                                                      {
#line 406
                                                      tmp___62 = strcmp(*(argv + k),
                                                                        "--tmlim");
                                                      }
#line 406
                                                      if (tmp___62 == 0) {
#line 408
                                                        k ++;
#line 409
                                                        if (k == argc) {
                                                          {
#line 410
                                                          _glp_lib_xprintf("No time limit specified\n");
                                                          }
#line 411
                                                          return (1);
                                                        } else
#line 409
                                                        if ((int const   )*(*(argv + k) + 0) == 0) {
                                                          {
#line 410
                                                          _glp_lib_xprintf("No time limit specified\n");
                                                          }
#line 411
                                                          return (1);
                                                        } else
#line 409
                                                        if ((int const   )*(*(argv + k) + 0) == 45) {
                                                          {
#line 410
                                                          _glp_lib_xprintf("No time limit specified\n");
                                                          }
#line 411
                                                          return (1);
                                                        }
                                                        {
#line 413
                                                        tmp = _glp_lib_str2int(*(argv + k),
                                                                               & tm_lim);
                                                        }
#line 413
                                                        if (tmp) {
                                                          {
#line 414
                                                          _glp_lib_xprintf("Invalid time limit `%s\'\n",
                                                                           *(argv + k));
                                                          }
#line 415
                                                          return (1);
                                                        } else
#line 413
                                                        if (tm_lim < 0) {
                                                          {
#line 414
                                                          _glp_lib_xprintf("Invalid time limit `%s\'\n",
                                                                           *(argv + k));
                                                          }
#line 415
                                                          return (1);
                                                        }
#line 417
                                                        if (tm_lim <= 2147483) {
#line 418
                                                          tmp___0 = 1000 * tm_lim;
#line 418
                                                          csa->iocp.tm_lim = tmp___0;
#line 418
                                                          csa->smcp.tm_lim = tmp___0;
                                                        } else {
#line 420
                                                          tmp___1 = 2147483647;
#line 420
                                                          csa->iocp.tm_lim = tmp___1;
#line 420
                                                          csa->smcp.tm_lim = tmp___1;
                                                        }
                                                      } else {
                                                        {
#line 422
                                                        tmp___61 = strcmp(*(argv + k),
                                                                          "--memlim");
                                                        }
#line 422
                                                        if (tmp___61 == 0) {
#line 424
                                                          k ++;
#line 425
                                                          if (k == argc) {
                                                            {
#line 426
                                                            _glp_lib_xprintf("No memory limit specified\n");
                                                            }
#line 427
                                                            return (1);
                                                          } else
#line 425
                                                          if ((int const   )*(*(argv + k) + 0) == 0) {
                                                            {
#line 426
                                                            _glp_lib_xprintf("No memory limit specified\n");
                                                            }
#line 427
                                                            return (1);
                                                          } else
#line 425
                                                          if ((int const   )*(*(argv + k) + 0) == 45) {
                                                            {
#line 426
                                                            _glp_lib_xprintf("No memory limit specified\n");
                                                            }
#line 427
                                                            return (1);
                                                          }
                                                          {
#line 429
                                                          tmp___2 = _glp_lib_str2int(*(argv + k),
                                                                                     & mem_lim);
                                                          }
#line 429
                                                          if (tmp___2) {
                                                            {
#line 430
                                                            _glp_lib_xprintf("Invalid memory limit `%s\'\n",
                                                                             *(argv + k));
                                                            }
#line 431
                                                            return (1);
                                                          } else
#line 429
                                                          if (mem_lim < 1) {
                                                            {
#line 430
                                                            _glp_lib_xprintf("Invalid memory limit `%s\'\n",
                                                                             *(argv + k));
                                                            }
#line 431
                                                            return (1);
                                                          }
                                                          {
#line 433
                                                          glp_mem_limit(mem_lim);
                                                          }
                                                        } else {
                                                          {
#line 435
                                                          tmp___60 = strcmp(*(argv + k),
                                                                            "--check");
                                                          }
#line 435
                                                          if (tmp___60 == 0) {
#line 436
                                                            csa->check = 1;
                                                          } else {
                                                            {
#line 437
                                                            tmp___59 = strcmp(*(argv + k),
                                                                              "--name");
                                                            }
#line 437
                                                            if (tmp___59 == 0) {
#line 438
                                                              k ++;
#line 439
                                                              if (k == argc) {
                                                                {
#line 440
                                                                _glp_lib_xprintf("No problem name specified\n");
                                                                }
#line 441
                                                                return (1);
                                                              } else
#line 439
                                                              if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                {
#line 440
                                                                _glp_lib_xprintf("No problem name specified\n");
                                                                }
#line 441
                                                                return (1);
                                                              } else
#line 439
                                                              if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                {
#line 440
                                                                _glp_lib_xprintf("No problem name specified\n");
                                                                }
#line 441
                                                                return (1);
                                                              }
#line 443
                                                              if ((unsigned long )csa->new_name != (unsigned long )((void *)0)) {
                                                                {
#line 444
                                                                _glp_lib_xprintf("Only one problem name allowed\n");
                                                                }
#line 445
                                                                return (1);
                                                              }
#line 447
                                                              csa->new_name = *(argv + k);
                                                            } else {
                                                              {
#line 449
                                                              tmp___58 = strcmp(*(argv + k),
                                                                                "--wmps");
                                                              }
#line 449
                                                              if (tmp___58 == 0) {
#line 450
                                                                k ++;
#line 451
                                                                if (k == argc) {
                                                                  {
#line 452
                                                                  _glp_lib_xprintf("No fixed MPS output file specified\n");
                                                                  }
#line 453
                                                                  return (1);
                                                                } else
#line 451
                                                                if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                  {
#line 452
                                                                  _glp_lib_xprintf("No fixed MPS output file specified\n");
                                                                  }
#line 453
                                                                  return (1);
                                                                } else
#line 451
                                                                if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                  {
#line 452
                                                                  _glp_lib_xprintf("No fixed MPS output file specified\n");
                                                                  }
#line 453
                                                                  return (1);
                                                                }
#line 455
                                                                if ((unsigned long )csa->out_mps != (unsigned long )((void *)0)) {
                                                                  {
#line 456
                                                                  _glp_lib_xprintf("Only one fixed MPS output file allowed\n");
                                                                  }
#line 457
                                                                  return (1);
                                                                }
#line 459
                                                                csa->out_mps = *(argv + k);
                                                              } else {
                                                                {
#line 461
                                                                tmp___57 = strcmp(*(argv + k),
                                                                                  "--wfreemps");
                                                                }
#line 461
                                                                if (tmp___57 == 0) {
#line 462
                                                                  k ++;
#line 463
                                                                  if (k == argc) {
                                                                    {
#line 464
                                                                    _glp_lib_xprintf("No free MPS output file specified\n");
                                                                    }
#line 465
                                                                    return (1);
                                                                  } else
#line 463
                                                                  if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                    {
#line 464
                                                                    _glp_lib_xprintf("No free MPS output file specified\n");
                                                                    }
#line 465
                                                                    return (1);
                                                                  } else
#line 463
                                                                  if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                    {
#line 464
                                                                    _glp_lib_xprintf("No free MPS output file specified\n");
                                                                    }
#line 465
                                                                    return (1);
                                                                  }
#line 467
                                                                  if ((unsigned long )csa->out_freemps != (unsigned long )((void *)0)) {
                                                                    {
#line 468
                                                                    _glp_lib_xprintf("Only one free MPS output file allowed\n");
                                                                    }
#line 469
                                                                    return (1);
                                                                  }
#line 471
                                                                  csa->out_freemps = *(argv + k);
                                                                } else {
                                                                  {
#line 473
                                                                  tmp___55 = strcmp(*(argv + k),
                                                                                    "--wcpxlp");
                                                                  }
#line 473
                                                                  if (tmp___55 == 0) {
#line 473
                                                                    goto _L___0;
                                                                  } else {
                                                                    {
#line 473
                                                                    tmp___56 = strcmp(*(argv + k),
                                                                                      "--wlpt");
                                                                    }
#line 473
                                                                    if (tmp___56 == 0) {
                                                                      _L___0: /* CIL Label */ 
#line 474
                                                                      k ++;
#line 475
                                                                      if (k == argc) {
                                                                        {
#line 476
                                                                        _glp_lib_xprintf("No CPLEX LP output file specified\n");
                                                                        }
#line 477
                                                                        return (1);
                                                                      } else
#line 475
                                                                      if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                        {
#line 476
                                                                        _glp_lib_xprintf("No CPLEX LP output file specified\n");
                                                                        }
#line 477
                                                                        return (1);
                                                                      } else
#line 475
                                                                      if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                        {
#line 476
                                                                        _glp_lib_xprintf("No CPLEX LP output file specified\n");
                                                                        }
#line 477
                                                                        return (1);
                                                                      }
#line 479
                                                                      if ((unsigned long )csa->out_cpxlp != (unsigned long )((void *)0)) {
                                                                        {
#line 480
                                                                        _glp_lib_xprintf("Only one CPLEX LP output file allowed\n");
                                                                        }
#line 481
                                                                        return (1);
                                                                      }
#line 483
                                                                      csa->out_cpxlp = *(argv + k);
                                                                    } else {
                                                                      {
#line 485
                                                                      tmp___54 = strcmp(*(argv + k),
                                                                                        "--wpb");
                                                                      }
#line 485
                                                                      if (tmp___54 == 0) {
#line 486
                                                                        k ++;
#line 487
                                                                        if (k == argc) {
                                                                          {
#line 488
                                                                          _glp_lib_xprintf("No problem output file specified\n");
                                                                          }
#line 489
                                                                          return (1);
                                                                        } else
#line 487
                                                                        if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                          {
#line 488
                                                                          _glp_lib_xprintf("No problem output file specified\n");
                                                                          }
#line 489
                                                                          return (1);
                                                                        } else
#line 487
                                                                        if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                          {
#line 488
                                                                          _glp_lib_xprintf("No problem output file specified\n");
                                                                          }
#line 489
                                                                          return (1);
                                                                        }
#line 491
                                                                        if ((unsigned long )csa->out_pb != (unsigned long )((void *)0)) {
                                                                          {
#line 492
                                                                          _glp_lib_xprintf("Only one OPB output file allowed\n");
                                                                          }
#line 493
                                                                          return (1);
                                                                        }
#line 495
                                                                        csa->out_pb = *(argv + k);
                                                                      } else {
                                                                        {
#line 497
                                                                        tmp___53 = strcmp(*(argv + k),
                                                                                          "--wnpb");
                                                                        }
#line 497
                                                                        if (tmp___53 == 0) {
#line 498
                                                                          k ++;
#line 499
                                                                          if (k == argc) {
                                                                            {
#line 500
                                                                            _glp_lib_xprintf("No problem output file specified\n");
                                                                            }
#line 501
                                                                            return (1);
                                                                          } else
#line 499
                                                                          if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                            {
#line 500
                                                                            _glp_lib_xprintf("No problem output file specified\n");
                                                                            }
#line 501
                                                                            return (1);
                                                                          } else
#line 499
                                                                          if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                            {
#line 500
                                                                            _glp_lib_xprintf("No problem output file specified\n");
                                                                            }
#line 501
                                                                            return (1);
                                                                          }
#line 503
                                                                          if ((unsigned long )csa->out_npb != (unsigned long )((void *)0)) {
                                                                            {
#line 504
                                                                            _glp_lib_xprintf("Only one normalized OPB output file allowed\n");
                                                                            }
#line 505
                                                                            return (1);
                                                                          }
#line 507
                                                                          csa->out_npb = *(argv + k);
                                                                        } else {
                                                                          {
#line 509
                                                                          tmp___52 = strcmp(*(argv + k),
                                                                                            "--log");
                                                                          }
#line 509
                                                                          if (tmp___52 == 0) {
#line 510
                                                                            k ++;
#line 511
                                                                            if (k == argc) {
                                                                              {
#line 512
                                                                              _glp_lib_xprintf("No log file specified\n");
                                                                              }
#line 513
                                                                              return (1);
                                                                            } else
#line 511
                                                                            if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                              {
#line 512
                                                                              _glp_lib_xprintf("No log file specified\n");
                                                                              }
#line 513
                                                                              return (1);
                                                                            } else
#line 511
                                                                            if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                              {
#line 512
                                                                              _glp_lib_xprintf("No log file specified\n");
                                                                              }
#line 513
                                                                              return (1);
                                                                            }
#line 515
                                                                            if ((unsigned long )csa->log_file != (unsigned long )((void *)0)) {
                                                                              {
#line 516
                                                                              _glp_lib_xprintf("Only one log file allowed\n");
                                                                              }
#line 517
                                                                              return (1);
                                                                            }
#line 519
                                                                            csa->log_file = *(argv + k);
                                                                          } else {
                                                                            {
#line 521
                                                                            tmp___50 = strcmp(*(argv + k),
                                                                                              "-h");
                                                                            }
#line 521
                                                                            if (tmp___50 == 0) {
                                                                              {
#line 522
                                                                              print_help(*(argv + 0));
                                                                              }
#line 523
                                                                              return (-1);
                                                                            } else {
                                                                              {
#line 521
                                                                              tmp___51 = strcmp(*(argv + k),
                                                                                                "--help");
                                                                              }
#line 521
                                                                              if (tmp___51 == 0) {
                                                                                {
#line 522
                                                                                print_help(*(argv + 0));
                                                                                }
#line 523
                                                                                return (-1);
                                                                              } else {
                                                                                {
#line 525
                                                                                tmp___48 = strcmp(*(argv + k),
                                                                                                  "-v");
                                                                                }
#line 525
                                                                                if (tmp___48 == 0) {
                                                                                  {
#line 526
                                                                                  print_version(0);
                                                                                  }
#line 527
                                                                                  return (-1);
                                                                                } else {
                                                                                  {
#line 525
                                                                                  tmp___49 = strcmp(*(argv + k),
                                                                                                    "--version");
                                                                                  }
#line 525
                                                                                  if (tmp___49 == 0) {
                                                                                    {
#line 526
                                                                                    print_version(0);
                                                                                    }
#line 527
                                                                                    return (-1);
                                                                                  } else {
                                                                                    {
#line 529
                                                                                    tmp___47 = strcmp(*(argv + k),
                                                                                                      "--luf");
                                                                                    }
#line 529
                                                                                    if (tmp___47 == 0) {
#line 530
                                                                                      csa->bfcp.type = 1;
                                                                                    } else {
                                                                                      {
#line 531
                                                                                      tmp___46 = strcmp(*(argv + k),
                                                                                                        "--cbg");
                                                                                      }
#line 531
                                                                                      if (tmp___46 == 0) {
#line 532
                                                                                        csa->bfcp.type = 2;
                                                                                      } else {
                                                                                        {
#line 533
                                                                                        tmp___45 = strcmp(*(argv + k),
                                                                                                          "--cgr");
                                                                                        }
#line 533
                                                                                        if (tmp___45 == 0) {
#line 534
                                                                                          csa->bfcp.type = 3;
                                                                                        } else {
                                                                                          {
#line 535
                                                                                          tmp___44 = strcmp(*(argv + k),
                                                                                                            "--primal");
                                                                                          }
#line 535
                                                                                          if (tmp___44 == 0) {
#line 536
                                                                                            csa->smcp.meth = 1;
                                                                                          } else {
                                                                                            {
#line 537
                                                                                            tmp___43 = strcmp(*(argv + k),
                                                                                                              "--dual");
                                                                                            }
#line 537
                                                                                            if (tmp___43 == 0) {
#line 538
                                                                                              csa->smcp.meth = 3;
                                                                                            } else {
                                                                                              {
#line 539
                                                                                              tmp___42 = strcmp(*(argv + k),
                                                                                                                "--std");
                                                                                              }
#line 539
                                                                                              if (tmp___42 == 0) {
#line 540
                                                                                                csa->crash = 1;
                                                                                              } else {
                                                                                                {
#line 541
                                                                                                tmp___41 = strcmp(*(argv + k),
                                                                                                                  "--adv");
                                                                                                }
#line 541
                                                                                                if (tmp___41 == 0) {
#line 542
                                                                                                  csa->crash = 2;
                                                                                                } else {
                                                                                                  {
#line 543
                                                                                                  tmp___40 = strcmp(*(argv + k),
                                                                                                                    "--bib");
                                                                                                  }
#line 543
                                                                                                  if (tmp___40 == 0) {
#line 544
                                                                                                    csa->crash = 3;
                                                                                                  } else {
                                                                                                    {
#line 545
                                                                                                    tmp___39 = strcmp(*(argv + k),
                                                                                                                      "--steep");
                                                                                                    }
#line 545
                                                                                                    if (tmp___39 == 0) {
#line 546
                                                                                                      csa->smcp.pricing = 34;
                                                                                                    } else {
                                                                                                      {
#line 547
                                                                                                      tmp___38 = strcmp(*(argv + k),
                                                                                                                        "--nosteep");
                                                                                                      }
#line 547
                                                                                                      if (tmp___38 == 0) {
#line 548
                                                                                                        csa->smcp.pricing = 17;
                                                                                                      } else {
                                                                                                        {
#line 549
                                                                                                        tmp___37 = strcmp(*(argv + k),
                                                                                                                          "--relax");
                                                                                                        }
#line 549
                                                                                                        if (tmp___37 == 0) {
#line 550
                                                                                                          csa->smcp.r_test = 34;
                                                                                                        } else {
                                                                                                          {
#line 551
                                                                                                          tmp___36 = strcmp(*(argv + k),
                                                                                                                            "--norelax");
                                                                                                          }
#line 551
                                                                                                          if (tmp___36 == 0) {
#line 552
                                                                                                            csa->smcp.r_test = 17;
                                                                                                          } else {
                                                                                                            {
#line 553
                                                                                                            tmp___35 = strcmp(*(argv + k),
                                                                                                                              "--presol");
                                                                                                            }
#line 553
                                                                                                            if (tmp___35 == 0) {
#line 554
                                                                                                              csa->smcp.presolve = 1;
                                                                                                            } else {
                                                                                                              {
#line 555
                                                                                                              tmp___34 = strcmp(*(argv + k),
                                                                                                                                "--nopresol");
                                                                                                              }
#line 555
                                                                                                              if (tmp___34 == 0) {
#line 556
                                                                                                                csa->smcp.presolve = 0;
                                                                                                              } else {
                                                                                                                {
#line 557
                                                                                                                tmp___33 = strcmp(*(argv + k),
                                                                                                                                  "--exact");
                                                                                                                }
#line 557
                                                                                                                if (tmp___33 == 0) {
#line 558
                                                                                                                  csa->exact = 1;
                                                                                                                } else {
                                                                                                                  {
#line 559
                                                                                                                  tmp___32 = strcmp(*(argv + k),
                                                                                                                                    "--xcheck");
                                                                                                                  }
#line 559
                                                                                                                  if (tmp___32 == 0) {
#line 560
                                                                                                                    csa->xcheck = 1;
                                                                                                                  } else {
                                                                                                                    {
#line 561
                                                                                                                    tmp___31 = strcmp(*(argv + k),
                                                                                                                                      "--nord");
                                                                                                                    }
#line 561
                                                                                                                    if (tmp___31 == 0) {
#line 562
                                                                                                                      csa->iptcp.ord_alg = 0;
                                                                                                                    } else {
                                                                                                                      {
#line 563
                                                                                                                      tmp___30 = strcmp(*(argv + k),
                                                                                                                                        "--qmd");
                                                                                                                      }
#line 563
                                                                                                                      if (tmp___30 == 0) {
#line 564
                                                                                                                        csa->iptcp.ord_alg = 1;
                                                                                                                      } else {
                                                                                                                        {
#line 565
                                                                                                                        tmp___29 = strcmp(*(argv + k),
                                                                                                                                          "--amd");
                                                                                                                        }
#line 565
                                                                                                                        if (tmp___29 == 0) {
#line 566
                                                                                                                          csa->iptcp.ord_alg = 2;
                                                                                                                        } else {
                                                                                                                          {
#line 567
                                                                                                                          tmp___28 = strcmp(*(argv + k),
                                                                                                                                            "--symamd");
                                                                                                                          }
#line 567
                                                                                                                          if (tmp___28 == 0) {
#line 568
                                                                                                                            csa->iptcp.ord_alg = 3;
                                                                                                                          } else {
                                                                                                                            {
#line 569
                                                                                                                            tmp___27 = strcmp(*(argv + k),
                                                                                                                                              "--nomip");
                                                                                                                            }
#line 569
                                                                                                                            if (tmp___27 == 0) {
#line 570
                                                                                                                              csa->nomip = 1;
                                                                                                                            } else {
                                                                                                                              {
#line 571
                                                                                                                              tmp___26 = strcmp(*(argv + k),
                                                                                                                                                "--first");
                                                                                                                              }
#line 571
                                                                                                                              if (tmp___26 == 0) {
#line 572
                                                                                                                                csa->iocp.br_tech = 1;
                                                                                                                              } else {
                                                                                                                                {
#line 573
                                                                                                                                tmp___25 = strcmp(*(argv + k),
                                                                                                                                                  "--last");
                                                                                                                                }
#line 573
                                                                                                                                if (tmp___25 == 0) {
#line 574
                                                                                                                                  csa->iocp.br_tech = 2;
                                                                                                                                } else {
                                                                                                                                  {
#line 575
                                                                                                                                  tmp___24 = strcmp(*(argv + k),
                                                                                                                                                    "--drtom");
                                                                                                                                  }
#line 575
                                                                                                                                  if (tmp___24 == 0) {
#line 576
                                                                                                                                    csa->iocp.br_tech = 4;
                                                                                                                                  } else {
                                                                                                                                    {
#line 577
                                                                                                                                    tmp___23 = strcmp(*(argv + k),
                                                                                                                                                      "--mostf");
                                                                                                                                    }
#line 577
                                                                                                                                    if (tmp___23 == 0) {
#line 578
                                                                                                                                      csa->iocp.br_tech = 3;
                                                                                                                                    } else {
                                                                                                                                      {
#line 579
                                                                                                                                      tmp___22 = strcmp(*(argv + k),
                                                                                                                                                        "--pcost");
                                                                                                                                      }
#line 579
                                                                                                                                      if (tmp___22 == 0) {
#line 580
                                                                                                                                        csa->iocp.br_tech = 5;
                                                                                                                                      } else {
                                                                                                                                        {
#line 581
                                                                                                                                        tmp___21 = strcmp(*(argv + k),
                                                                                                                                                          "--dfs");
                                                                                                                                        }
#line 581
                                                                                                                                        if (tmp___21 == 0) {
#line 582
                                                                                                                                          csa->iocp.bt_tech = 1;
                                                                                                                                        } else {
                                                                                                                                          {
#line 583
                                                                                                                                          tmp___20 = strcmp(*(argv + k),
                                                                                                                                                            "--bfs");
                                                                                                                                          }
#line 583
                                                                                                                                          if (tmp___20 == 0) {
#line 584
                                                                                                                                            csa->iocp.bt_tech = 2;
                                                                                                                                          } else {
                                                                                                                                            {
#line 585
                                                                                                                                            tmp___19 = strcmp(*(argv + k),
                                                                                                                                                              "--bestp");
                                                                                                                                            }
#line 585
                                                                                                                                            if (tmp___19 == 0) {
#line 586
                                                                                                                                              csa->iocp.bt_tech = 4;
                                                                                                                                            } else {
                                                                                                                                              {
#line 587
                                                                                                                                              tmp___18 = strcmp(*(argv + k),
                                                                                                                                                                "--bestb");
                                                                                                                                              }
#line 587
                                                                                                                                              if (tmp___18 == 0) {
#line 588
                                                                                                                                                csa->iocp.bt_tech = 3;
                                                                                                                                              } else {
                                                                                                                                                {
#line 589
                                                                                                                                                tmp___17 = strcmp(*(argv + k),
                                                                                                                                                                  "--intopt");
                                                                                                                                                }
#line 589
                                                                                                                                                if (tmp___17 == 0) {
#line 590
                                                                                                                                                  csa->iocp.presolve = 1;
                                                                                                                                                } else {
                                                                                                                                                  {
#line 591
                                                                                                                                                  tmp___16 = strcmp(*(argv + k),
                                                                                                                                                                    "--nointopt");
                                                                                                                                                  }
#line 591
                                                                                                                                                  if (tmp___16 == 0) {
#line 592
                                                                                                                                                    csa->iocp.presolve = 0;
                                                                                                                                                  } else {
                                                                                                                                                    {
#line 593
                                                                                                                                                    tmp___15 = strcmp(*(argv + k),
                                                                                                                                                                      "--binarize");
                                                                                                                                                    }
#line 593
                                                                                                                                                    if (tmp___15 == 0) {
#line 594
                                                                                                                                                      tmp___3 = 1;
#line 594
                                                                                                                                                      csa->iocp.binarize = tmp___3;
#line 594
                                                                                                                                                      csa->iocp.presolve = tmp___3;
                                                                                                                                                    } else {
                                                                                                                                                      {
#line 595
                                                                                                                                                      tmp___14 = strcmp(*(argv + k),
                                                                                                                                                                        "--fpump");
                                                                                                                                                      }
#line 595
                                                                                                                                                      if (tmp___14 == 0) {
#line 596
                                                                                                                                                        csa->iocp.fp_heur = 1;
                                                                                                                                                      } else {
                                                                                                                                                        {
#line 597
                                                                                                                                                        tmp___13 = strcmp(*(argv + k),
                                                                                                                                                                          "--gomory");
                                                                                                                                                        }
#line 597
                                                                                                                                                        if (tmp___13 == 0) {
#line 598
                                                                                                                                                          csa->iocp.gmi_cuts = 1;
                                                                                                                                                        } else {
                                                                                                                                                          {
#line 599
                                                                                                                                                          tmp___12 = strcmp(*(argv + k),
                                                                                                                                                                            "--mir");
                                                                                                                                                          }
#line 599
                                                                                                                                                          if (tmp___12 == 0) {
#line 600
                                                                                                                                                            csa->iocp.mir_cuts = 1;
                                                                                                                                                          } else {
                                                                                                                                                            {
#line 601
                                                                                                                                                            tmp___11 = strcmp(*(argv + k),
                                                                                                                                                                              "--cover");
                                                                                                                                                            }
#line 601
                                                                                                                                                            if (tmp___11 == 0) {
#line 602
                                                                                                                                                              csa->iocp.cov_cuts = 1;
                                                                                                                                                            } else {
                                                                                                                                                              {
#line 603
                                                                                                                                                              tmp___10 = strcmp(*(argv + k),
                                                                                                                                                                                "--clique");
                                                                                                                                                              }
#line 603
                                                                                                                                                              if (tmp___10 == 0) {
#line 604
                                                                                                                                                                csa->iocp.clq_cuts = 1;
                                                                                                                                                              } else {
                                                                                                                                                                {
#line 605
                                                                                                                                                                tmp___9 = strcmp(*(argv + k),
                                                                                                                                                                                 "--cuts");
                                                                                                                                                                }
#line 605
                                                                                                                                                                if (tmp___9 == 0) {
#line 606
                                                                                                                                                                  tmp___6 = 1;
#line 606
                                                                                                                                                                  csa->iocp.clq_cuts = tmp___6;
#line 606
                                                                                                                                                                  tmp___5 = tmp___6;
#line 606
                                                                                                                                                                  csa->iocp.cov_cuts = tmp___5;
#line 606
                                                                                                                                                                  tmp___4 = tmp___5;
#line 606
                                                                                                                                                                  csa->iocp.mir_cuts = tmp___4;
#line 606
                                                                                                                                                                  csa->iocp.gmi_cuts = tmp___4;
                                                                                                                                                                } else {
                                                                                                                                                                  {
#line 608
                                                                                                                                                                  tmp___8 = strcmp(*(argv + k),
                                                                                                                                                                                   "--mipgap");
                                                                                                                                                                  }
#line 608
                                                                                                                                                                  if (tmp___8 == 0) {
#line 610
                                                                                                                                                                    k ++;
#line 611
                                                                                                                                                                    if (k == argc) {
                                                                                                                                                                      {
#line 612
                                                                                                                                                                      _glp_lib_xprintf("No relative gap tolerance specified\n");
                                                                                                                                                                      }
#line 613
                                                                                                                                                                      return (1);
                                                                                                                                                                    } else
#line 611
                                                                                                                                                                    if ((int const   )*(*(argv + k) + 0) == 0) {
                                                                                                                                                                      {
#line 612
                                                                                                                                                                      _glp_lib_xprintf("No relative gap tolerance specified\n");
                                                                                                                                                                      }
#line 613
                                                                                                                                                                      return (1);
                                                                                                                                                                    } else
#line 611
                                                                                                                                                                    if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                                                                                                                      {
#line 612
                                                                                                                                                                      _glp_lib_xprintf("No relative gap tolerance specified\n");
                                                                                                                                                                      }
#line 613
                                                                                                                                                                      return (1);
                                                                                                                                                                    }
                                                                                                                                                                    {
#line 615
                                                                                                                                                                    tmp___7 = _glp_lib_str2num(*(argv + k),
                                                                                                                                                                                               & mip_gap);
                                                                                                                                                                    }
#line 615
                                                                                                                                                                    if (tmp___7) {
                                                                                                                                                                      {
#line 616
                                                                                                                                                                      _glp_lib_xprintf("Invalid relative mip gap tolerance `%s\'\n",
                                                                                                                                                                                       *(argv + k));
                                                                                                                                                                      }
#line 618
                                                                                                                                                                      return (1);
                                                                                                                                                                    } else
#line 615
                                                                                                                                                                    if (mip_gap < 0.0) {
                                                                                                                                                                      {
#line 616
                                                                                                                                                                      _glp_lib_xprintf("Invalid relative mip gap tolerance `%s\'\n",
                                                                                                                                                                                       *(argv + k));
                                                                                                                                                                      }
#line 618
                                                                                                                                                                      return (1);
                                                                                                                                                                    }
#line 620
                                                                                                                                                                    csa->iocp.mip_gap = mip_gap;
                                                                                                                                                                  } else
#line 622
                                                                                                                                                                  if ((int const   )*(*(argv + k) + 0) == 45) {
                                                                                                                                                                    {
#line 624
                                                                                                                                                                    _glp_lib_xprintf("Invalid option `%s\'; try %s --help\n",
                                                                                                                                                                                     *(argv + k),
                                                                                                                                                                                     *(argv + 0));
                                                                                                                                                                    }
#line 626
                                                                                                                                                                    return (1);
                                                                                                                                                                  } else
#line 622
                                                                                                                                                                  if ((int const   )*(*(argv + k) + 0) == 45) {
#line 622
                                                                                                                                                                    if ((int const   )*(*(argv + k) + 1) == 45) {
                                                                                                                                                                      {
#line 624
                                                                                                                                                                      _glp_lib_xprintf("Invalid option `%s\'; try %s --help\n",
                                                                                                                                                                                       *(argv + k),
                                                                                                                                                                                       *(argv + 0));
                                                                                                                                                                      }
#line 626
                                                                                                                                                                      return (1);
                                                                                                                                                                    } else {
#line 622
                                                                                                                                                                      goto _L;
                                                                                                                                                                    }
                                                                                                                                                                  } else {
                                                                                                                                                                    _L: /* CIL Label */ 
#line 629
                                                                                                                                                                    if ((unsigned long )csa->in_file != (unsigned long )((void *)0)) {
                                                                                                                                                                      {
#line 630
                                                                                                                                                                      _glp_lib_xprintf("Only one input problem file allowed\n");
                                                                                                                                                                      }
#line 631
                                                                                                                                                                      return (1);
                                                                                                                                                                    }
#line 633
                                                                                                                                                                    csa->in_file = *(argv + k);
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 308
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  return (0);
}
}
#line 643 "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c"
int glp_main(int argc , char const   **argv ) 
{ 
  struct csa___7 _csa ;
  struct csa___7 *csa ;
  int ret ;
  xlong_t start ;
  int tmp ;
  int k ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int s ;
  int t ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  xlong_t tmp___11 ;
  double tmp___12 ;
  xlong_t tpeak ;
  char buf[50] ;
  char *tmp___13 ;
  double tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int count ;
  xlong_t total ;
  xerror_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
  {
#line 645
  csa = & _csa;
#line 649
  csa->prob = glp_create_prob();
#line 650
  glp_get_bfcp(csa->prob, & csa->bfcp);
#line 651
  glp_init_smcp(& csa->smcp);
#line 652
  csa->smcp.presolve = 1;
#line 653
  glp_init_iptcp(& csa->iptcp);
#line 654
  glp_init_iocp(& csa->iocp);
#line 655
  csa->iocp.presolve = 1;
#line 656
  csa->tran = (glp_tran *)((void *)0);
#line 657
  csa->graph = (glp_graph *)((void *)0);
#line 658
  csa->format = 2;
#line 659
  csa->in_file = (char const   *)((void *)0);
#line 660
  csa->ndf = 0;
#line 661
  csa->out_dpy = (char const   *)((void *)0);
#line 662
  csa->solution = 1;
#line 663
  csa->in_res = (char const   *)((void *)0);
#line 664
  csa->dir = 0;
#line 665
  csa->scale = 1;
#line 666
  csa->out_sol = (char const   *)((void *)0);
#line 667
  csa->out_res = (char const   *)((void *)0);
#line 668
  csa->out_bnds = (char const   *)((void *)0);
#line 669
  csa->check = 0;
#line 670
  csa->new_name = (char const   *)((void *)0);
#line 671
  csa->out_mps = (char const   *)((void *)0);
#line 672
  csa->out_freemps = (char const   *)((void *)0);
#line 673
  csa->out_cpxlp = (char const   *)((void *)0);
#line 674
  csa->out_pb = (char const   *)((void *)0);
#line 675
  csa->out_npb = (char const   *)((void *)0);
#line 676
  csa->log_file = (char const   *)((void *)0);
#line 677
  csa->crash = 2;
#line 678
  csa->exact = 0;
#line 679
  csa->xcheck = 0;
#line 680
  csa->nomip = 0;
#line 682
  ret = parse_cmdline(csa, argc, argv);
  }
#line 683
  if (ret < 0) {
#line 684
    ret = 0;
#line 685
    goto done;
  }
#line 687
  if (ret > 0) {
#line 688
    ret = 1;
#line 689
    goto done;
  }
#line 693
  if ((unsigned long )csa->out_dpy != (unsigned long )((void *)0)) {
    {
#line 693
    remove(csa->out_dpy);
    }
  }
#line 694
  if ((unsigned long )csa->out_sol != (unsigned long )((void *)0)) {
    {
#line 694
    remove(csa->out_sol);
    }
  }
#line 695
  if ((unsigned long )csa->out_res != (unsigned long )((void *)0)) {
    {
#line 695
    remove(csa->out_res);
    }
  }
#line 696
  if ((unsigned long )csa->out_bnds != (unsigned long )((void *)0)) {
    {
#line 696
    remove(csa->out_bnds);
    }
  }
#line 697
  if ((unsigned long )csa->out_mps != (unsigned long )((void *)0)) {
    {
#line 697
    remove(csa->out_mps);
    }
  }
#line 698
  if ((unsigned long )csa->out_freemps != (unsigned long )((void *)0)) {
    {
#line 698
    remove(csa->out_freemps);
    }
  }
#line 699
  if ((unsigned long )csa->out_cpxlp != (unsigned long )((void *)0)) {
    {
#line 699
    remove(csa->out_cpxlp);
    }
  }
#line 700
  if ((unsigned long )csa->out_pb != (unsigned long )((void *)0)) {
    {
#line 700
    remove(csa->out_pb);
    }
  }
#line 701
  if ((unsigned long )csa->out_npb != (unsigned long )((void *)0)) {
    {
#line 701
    remove(csa->out_npb);
    }
  }
#line 702
  if ((unsigned long )csa->log_file != (unsigned long )((void *)0)) {
    {
#line 702
    remove(csa->log_file);
    }
  }
#line 705
  if ((unsigned long )csa->log_file != (unsigned long )((void *)0)) {
    {
#line 706
    tmp = _glp_lib_open_log(csa->log_file);
    }
#line 706
    if (tmp) {
      {
#line 707
      _glp_lib_xprintf("Unable to create log file\n");
#line 708
      ret = 1;
      }
#line 709
      goto done;
    }
  }
  {
#line 714
  print_version(1);
  }
#line 717
  if ((unsigned long )csa->in_file == (unsigned long )((void *)0)) {
    {
#line 718
    _glp_lib_xprintf("No input problem file specified; try %s --help\n", *(argv + 0));
#line 720
    ret = 1;
    }
#line 721
    goto done;
  }
#line 723
  if (csa->format == 1) {
    {
#line 724
    ret = glp_read_mps(csa->prob, 1, (glp_mpscp const   *)((void *)0), csa->in_file);
    }
#line 726
    if (ret != 0) {
      err1: 
      {
#line 727
      _glp_lib_xprintf("MPS file processing error\n");
#line 728
      ret = 1;
      }
#line 729
      goto done;
    }
  } else
#line 732
  if (csa->format == 2) {
    {
#line 733
    ret = glp_read_mps(csa->prob, 2, (glp_mpscp const   *)((void *)0), csa->in_file);
    }
#line 735
    if (ret != 0) {
#line 735
      goto err1;
    }
  } else
#line 737
  if (csa->format == 3) {
    {
#line 738
    ret = glp_read_lp(csa->prob, (void const   *)((void *)0), csa->in_file);
    }
#line 739
    if (ret != 0) {
      {
#line 740
      _glp_lib_xprintf("CPLEX LP file processing error\n");
#line 741
      ret = 1;
      }
#line 742
      goto done;
    }
  } else
#line 745
  if (csa->format == 4) {
    {
#line 748
    csa->tran = glp_mpl_alloc_wksp();
#line 750
    tmp___0 = glp_mpl_read_model(csa->tran, csa->in_file, csa->ndf > 0);
    }
#line 750
    if (tmp___0) {
      err2: 
      {
#line 751
      _glp_lib_xprintf("MathProg model processing error\n");
#line 752
      ret = 1;
      }
#line 753
      goto done;
    }
#line 756
    k = 1;
    {
#line 756
    while (1) {
      while_continue: /* CIL Label */ ;
#line 756
      if (! (k <= csa->ndf)) {
#line 756
        goto while_break;
      }
      {
#line 757
      tmp___1 = glp_mpl_read_data(csa->tran, csa->in_data[k]);
      }
#line 757
      if (tmp___1) {
#line 758
        goto err2;
      }
#line 756
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 761
    tmp___2 = glp_mpl_generate(csa->tran, csa->out_dpy);
    }
#line 761
    if (tmp___2) {
#line 761
      goto err2;
    }
    {
#line 763
    glp_mpl_build_prob(csa->tran, csa->prob);
    }
  } else
#line 765
  if (csa->format == 5) {
    {
#line 766
    csa->graph = glp_create_graph((int )sizeof(v_data ), (int )sizeof(a_data ));
#line 767
    ret = glp_read_mincost(csa->graph, (int )((unsigned long )(& ((v_data *)0)->rhs)),
                           (int )((unsigned long )(& ((a_data *)0)->low)), (int )((unsigned long )(& ((a_data *)0)->cap)),
                           (int )((unsigned long )(& ((a_data *)0)->cost)), csa->in_file);
    }
#line 770
    if (ret != 0) {
      {
#line 771
      _glp_lib_xprintf("DIMACS file processing error\n");
#line 772
      ret = 1;
      }
#line 773
      goto done;
    }
    {
#line 775
    glp_mincost_lp(csa->prob, csa->graph, 1, (int )((unsigned long )(& ((v_data *)0)->rhs)),
                   (int )((unsigned long )(& ((a_data *)0)->low)), (int )((unsigned long )(& ((a_data *)0)->cap)),
                   (int )((unsigned long )(& ((a_data *)0)->cost)));
#line 778
    glp_set_prob_name(csa->prob, csa->in_file);
    }
  } else
#line 780
  if (csa->format == 6) {
    {
#line 782
    csa->graph = glp_create_graph((int )sizeof(v_data ), (int )sizeof(a_data ));
#line 783
    ret = glp_read_maxflow(csa->graph, & s, & t, (int )((unsigned long )(& ((a_data *)0)->cap)),
                           csa->in_file);
    }
#line 785
    if (ret != 0) {
      {
#line 786
      _glp_lib_xprintf("DIMACS file processing error\n");
#line 787
      ret = 1;
      }
#line 788
      goto done;
    }
    {
#line 790
    glp_maxflow_lp(csa->prob, csa->graph, 1, s, t, (int )((unsigned long )(& ((a_data *)0)->cap)));
#line 792
    glp_set_prob_name(csa->prob, csa->in_file);
    }
  } else
#line 795
  if ((unsigned long )csa != (unsigned long )csa) {
#line 795
    tmp___3 = 1;
  } else {
    {
#line 795
    _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                     795);
#line 795
    tmp___3 = 1;
    }
  }
#line 798
  if ((unsigned long )csa->new_name != (unsigned long )((void *)0)) {
    {
#line 799
    glp_set_prob_name(csa->prob, csa->new_name);
    }
  }
#line 801
  if (csa->dir != 0) {
    {
#line 802
    glp_set_obj_dir(csa->prob, csa->dir);
    }
  }
  {
#line 804
  _glp_1px_order_matrix(csa->prob);
  }
#line 807
  if ((unsigned long )csa->out_mps != (unsigned long )((void *)0)) {
    {
#line 808
    ret = glp_write_mps(csa->prob, 1, (glp_mpscp const   *)((void *)0), csa->out_mps);
    }
#line 810
    if (ret != 0) {
      {
#line 811
      _glp_lib_xprintf("Unable to write problem in fixed MPS format\n");
#line 812
      ret = 1;
      }
#line 813
      goto done;
    }
  }
#line 817
  if ((unsigned long )csa->out_freemps != (unsigned long )((void *)0)) {
    {
#line 818
    ret = glp_write_mps(csa->prob, 2, (glp_mpscp const   *)((void *)0), csa->out_freemps);
    }
#line 820
    if (ret != 0) {
      {
#line 821
      _glp_lib_xprintf("Unable to write problem in free MPS format\n");
#line 822
      ret = 1;
      }
#line 823
      goto done;
    }
  }
#line 827
  if ((unsigned long )csa->out_cpxlp != (unsigned long )((void *)0)) {
    {
#line 828
    ret = glp_write_lp(csa->prob, (void const   *)((void *)0), csa->out_cpxlp);
    }
#line 829
    if (ret != 0) {
      {
#line 830
      _glp_lib_xprintf("Unable to write problem in CPLEX LP format\n");
#line 831
      ret = 1;
      }
#line 832
      goto done;
    }
  }
#line 836
  if ((unsigned long )csa->out_pb != (unsigned long )((void *)0)) {
    {
#line 837
    ret = _glp_lpx_write_pb(csa->prob, csa->out_pb, 0, 0);
    }
#line 838
    if (ret != 0) {
      {
#line 839
      _glp_lib_xprintf("Unable to write problem in OPB format\n");
#line 840
      ret = 1;
      }
#line 841
      goto done;
    }
  }
#line 845
  if ((unsigned long )csa->out_npb != (unsigned long )((void *)0)) {
    {
#line 846
    ret = _glp_lpx_write_pb(csa->prob, csa->out_npb, 1, 1);
    }
#line 847
    if (ret != 0) {
      {
#line 848
      _glp_lib_xprintf("Unable to write problem in normalized OPB format\n");
#line 850
      ret = 1;
      }
#line 851
      goto done;
    }
  }
#line 856
  if (csa->check) {
#line 857
    ret = 0;
#line 858
    goto done;
  }
#line 862
  if (! csa->nomip) {
    {
#line 862
    tmp___4 = glp_get_num_int(csa->prob);
#line 862
    tmp___5 = glp_get_num_bin(csa->prob);
    }
#line 862
    if (tmp___4 + tmp___5 > 0) {
#line 864
      if (csa->solution == 2) {
        {
#line 865
        _glp_lib_xprintf("Interior-point method is not able to solve MIP problem; use --simplex\n");
#line 867
        ret = 1;
        }
#line 868
        goto done;
      }
#line 870
      csa->solution = 3;
    }
  }
#line 874
  if ((unsigned long )csa->in_res != (unsigned long )((void *)0)) {
#line 875
    if (csa->solution == 1) {
      {
#line 876
      ret = glp_read_sol(csa->prob, csa->in_res);
      }
    } else
#line 877
    if (csa->solution == 2) {
      {
#line 878
      ret = glp_read_ipt(csa->prob, csa->in_res);
      }
    } else
#line 879
    if (csa->solution == 3) {
      {
#line 880
      ret = glp_read_mip(csa->prob, csa->in_res);
      }
    } else
#line 882
    if ((unsigned long )csa != (unsigned long )csa) {
#line 882
      tmp___6 = 1;
    } else {
      {
#line 882
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                       882);
#line 882
      tmp___6 = 1;
      }
    }
#line 883
    if (ret != 0) {
      {
#line 884
      _glp_lib_xprintf("Unable to read problem solution\n");
#line 885
      ret = 1;
      }
#line 886
      goto done;
    }
#line 888
    goto skip;
  }
#line 892
  if (csa->scale) {
#line 893
    if (csa->solution == 1) {
#line 893
      if (! csa->smcp.presolve) {
        {
#line 896
        glp_scale_prob(csa->prob, 128);
        }
      } else {
#line 893
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 893
    if (csa->solution == 2) {
      {
#line 896
      glp_scale_prob(csa->prob, 128);
      }
    } else
#line 893
    if (csa->solution == 3) {
#line 893
      if (! csa->iocp.presolve) {
        {
#line 896
        glp_scale_prob(csa->prob, 128);
        }
      }
    }
  }
#line 899
  if (csa->solution == 1) {
#line 899
    if (! csa->smcp.presolve) {
#line 899
      goto _L___0;
    } else {
#line 899
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 899
  if (csa->solution == 3) {
#line 899
    if (! csa->iocp.presolve) {
      _L___0: /* CIL Label */ 
#line 901
      if (csa->crash == 1) {
        {
#line 902
        glp_std_basis(csa->prob);
        }
      } else
#line 903
      if (csa->crash == 2) {
        {
#line 904
        glp_adv_basis(csa->prob, 0);
        }
      } else
#line 905
      if (csa->crash == 3) {
        {
#line 906
        glp_cpx_basis(csa->prob);
        }
      } else
#line 908
      if ((unsigned long )csa != (unsigned long )csa) {
#line 908
        tmp___7 = 1;
      } else {
        {
#line 908
        _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                         908);
#line 908
        tmp___7 = 1;
        }
      }
    }
  }
  {
#line 912
  start = _glp_lib_xtime();
  }
#line 913
  if (csa->solution == 1) {
#line 914
    if (! csa->exact) {
      {
#line 915
      glp_set_bfcp(csa->prob, (glp_bfcp const   *)(& csa->bfcp));
#line 916
      glp_simplex(csa->prob, (glp_smcp const   *)(& csa->smcp));
      }
#line 917
      if (csa->xcheck) {
#line 918
        if (csa->smcp.presolve) {
          {
#line 918
          tmp___8 = glp_get_status(csa->prob);
          }
#line 918
          if (tmp___8 != 5) {
            {
#line 920
            _glp_lib_xprintf("If you need to check final basis for non-optimal solution, use --nopresol\n");
            }
          } else {
            {
#line 923
            glp_exact(csa->prob, (glp_smcp const   *)(& csa->smcp));
            }
          }
        } else {
          {
#line 923
          glp_exact(csa->prob, (glp_smcp const   *)(& csa->smcp));
          }
        }
      }
#line 925
      if ((unsigned long )csa->out_sol != (unsigned long )((void *)0)) {
#line 925
        goto _L___2;
      } else
#line 925
      if ((unsigned long )csa->out_res != (unsigned long )((void *)0)) {
        _L___2: /* CIL Label */ 
#line 926
        if (csa->smcp.presolve) {
          {
#line 926
          tmp___9 = glp_get_status(csa->prob);
          }
#line 926
          if (tmp___9 != 5) {
            {
#line 928
            _glp_lib_xprintf("If you need actual output for non-optimal solution, use --nopresol\n");
            }
          }
        }
      }
    } else {
      {
#line 933
      glp_exact(csa->prob, (glp_smcp const   *)(& csa->smcp));
      }
    }
  } else
#line 935
  if (csa->solution == 2) {
    {
#line 936
    glp_interior(csa->prob, (glp_iptcp const   *)(& csa->iptcp));
    }
  } else
#line 937
  if (csa->solution == 3) {
#line 938
    if (! csa->iocp.presolve) {
      {
#line 939
      glp_set_bfcp(csa->prob, (glp_bfcp const   *)(& csa->bfcp));
#line 940
      glp_simplex(csa->prob, (glp_smcp const   *)(& csa->smcp));
      }
    }
    {
#line 942
    glp_intopt(csa->prob, (glp_iocp const   *)(& csa->iocp));
    }
  } else
#line 945
  if ((unsigned long )csa != (unsigned long )csa) {
#line 945
    tmp___10 = 1;
  } else {
    {
#line 945
    _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                     945);
#line 945
    tmp___10 = 1;
    }
  }
  {
#line 948
  tmp___11 = _glp_lib_xtime();
#line 948
  tmp___12 = _glp_lib_xdifftime(tmp___11, start);
#line 948
  _glp_lib_xprintf("Time used:   %.1f secs\n", tmp___12);
#line 951
  _glp_lib_mem_usage((int *)((void *)0), (int *)((void *)0), (xlong_t *)((void *)0),
                     & tpeak);
#line 952
  tmp___13 = _glp_lib_xltoa(tpeak, buf);
#line 952
  tmp___14 = _glp_lib_xltod(tpeak);
#line 952
  _glp_lib_xprintf("Memory used: %.1f Mb (%s bytes)\n", tmp___14 / 1048576.0, tmp___13);
  }
  skip: 
#line 957
  if ((unsigned long )csa->tran != (unsigned long )((void *)0)) {
#line 958
    if (csa->solution == 1) {
      {
#line 959
      ret = glp_mpl_postsolve(csa->tran, csa->prob, 1);
      }
    } else
#line 960
    if (csa->solution == 2) {
      {
#line 961
      ret = glp_mpl_postsolve(csa->tran, csa->prob, 2);
      }
    } else
#line 962
    if (csa->solution == 3) {
      {
#line 963
      ret = glp_mpl_postsolve(csa->tran, csa->prob, 3);
      }
    } else
#line 965
    if ((unsigned long )csa != (unsigned long )csa) {
#line 965
      tmp___15 = 1;
    } else {
      {
#line 965
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                       965);
#line 965
      tmp___15 = 1;
      }
    }
#line 966
    if (ret != 0) {
      {
#line 967
      _glp_lib_xprintf("Model postsolving error\n");
#line 968
      ret = 1;
      }
#line 969
      goto done;
    }
  }
#line 974
  if ((unsigned long )csa->out_sol != (unsigned long )((void *)0)) {
#line 975
    if (csa->solution == 1) {
      {
#line 976
      ret = _glp_lpx_print_sol(csa->prob, csa->out_sol);
      }
    } else
#line 977
    if (csa->solution == 2) {
      {
#line 978
      ret = _glp_lpx_print_ips(csa->prob, csa->out_sol);
      }
    } else
#line 979
    if (csa->solution == 3) {
      {
#line 980
      ret = _glp_lpx_print_mip(csa->prob, csa->out_sol);
      }
    } else
#line 982
    if ((unsigned long )csa != (unsigned long )csa) {
#line 982
      tmp___16 = 1;
    } else {
      {
#line 982
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                       982);
#line 982
      tmp___16 = 1;
      }
    }
#line 983
    if (ret != 0) {
      {
#line 984
      _glp_lib_xprintf("Unable to write problem solution\n");
#line 985
      ret = 1;
      }
#line 986
      goto done;
    }
  }
#line 990
  if ((unsigned long )csa->out_res != (unsigned long )((void *)0)) {
#line 991
    if (csa->solution == 1) {
      {
#line 992
      ret = glp_write_sol(csa->prob, csa->out_res);
      }
    } else
#line 993
    if (csa->solution == 2) {
      {
#line 994
      ret = glp_write_ipt(csa->prob, csa->out_res);
      }
    } else
#line 995
    if (csa->solution == 3) {
      {
#line 996
      ret = glp_write_mip(csa->prob, csa->out_res);
      }
    } else
#line 998
    if ((unsigned long )csa != (unsigned long )csa) {
#line 998
      tmp___17 = 1;
    } else {
      {
#line 998
      _glp_lib_xassert("csa != csa", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                       998);
#line 998
      tmp___17 = 1;
      }
    }
#line 999
    if (ret != 0) {
      {
#line 1000
      _glp_lib_xprintf("Unable to write problem solution\n");
#line 1001
      ret = 1;
      }
#line 1002
      goto done;
    }
  }
#line 1006
  if ((unsigned long )csa->out_bnds != (unsigned long )((void *)0)) {
#line 1007
    if (csa->solution == 1) {
      {
#line 1008
      ret = _glp_lpx_print_sens_bnds(csa->prob, csa->out_bnds);
      }
#line 1009
      if (ret != 0) {
        {
#line 1010
        _glp_lib_xprintf("Unable to write sensitivity bounds information \n");
#line 1012
        ret = 1;
        }
#line 1013
        goto done;
      }
    } else {
      {
#line 1017
      _glp_lib_xprintf("Cannot write sensitivity bounds information for interior-point or MIP solution\n");
      }
    }
  }
#line 1022
  ret = 0;
  done: 
#line 1025
  if ((unsigned long )csa->prob != (unsigned long )((void *)0)) {
    {
#line 1026
    glp_delete_prob(csa->prob);
    }
  }
#line 1028
  if ((unsigned long )csa->tran != (unsigned long )((void *)0)) {
    {
#line 1029
    glp_mpl_free_wksp(csa->tran);
    }
  }
#line 1031
  if ((unsigned long )csa->graph != (unsigned long )((void *)0)) {
    {
#line 1032
    glp_delete_graph(csa->graph);
    }
  }
  {
#line 1033
  tmp___18 = _glp_gmp_pool_count();
  }
#line 1033
  if (tmp___18 == 0) {
#line 1033
    tmp___19 = 1;
  } else {
    {
#line 1033
    _glp_lib_xassert("gmp_pool_count() == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                     1033);
#line 1033
    tmp___19 = 1;
    }
  }
  {
#line 1034
  _glp_gmp_free_mem();
  }
#line 1036
  if ((unsigned long )csa->log_file != (unsigned long )((void *)0)) {
    {
#line 1036
    _glp_lib_close_log();
    }
  }
  {
#line 1040
  _glp_lib_mem_usage(& count, (int *)((void *)0), & total, (xlong_t *)((void *)0));
  }
#line 1041
  if (count != 0) {
    {
#line 1042
    tmp___20 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                                1042);
#line 1042
    (*tmp___20)("Error: %d memory block(s) were lost\n", count);
    }
  }
#line 1043
  if (count == 0) {
#line 1043
    tmp___21 = 1;
  } else {
    {
#line 1043
    _glp_lib_xassert("count == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                     1043);
#line 1043
    tmp___21 = 1;
    }
  }
#line 1044
  if (total.lo == 0) {
#line 1044
    if (total.hi == 0) {
#line 1044
      tmp___22 = 1;
    } else {
      {
#line 1044
      _glp_lib_xassert("total.lo == 0 && total.hi == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                       1044);
#line 1044
      tmp___22 = 1;
      }
    }
  } else {
    {
#line 1044
    _glp_lib_xassert("total.lo == 0 && total.hi == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi20.c",
                     1044);
#line 1044
    tmp___22 = 1;
    }
  }
  {
#line 1047
  _glp_lib_free_env();
  }
#line 1049
  return (ret);
}
}
#line 808 "./../include/glpk.h"
int glp_mincost_okalg(glp_graph *G , int v_rhs , int a_low , int a_cap , int a_cost ,
                      double *sol , int a_x , int v_pi ) ;
#line 816
int glp_maxflow_ffalg(glp_graph *G , int s , int t , int a_cap , double *sol , int a_x ,
                      int v_cut ) ;
#line 42 "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c"
void glp_mincost_lp(glp_prob *lp , glp_graph *G , int names , int v_rhs , int a_low ,
                    int a_cap , int a_cost ) 
{ 
  glp_vertex *v ;
  glp_arc *a ;
  int i ;
  int j ;
  int type ;
  int ind[3] ;
  double rhs ;
  double low ;
  double cap ;
  double cost ;
  double val[3] ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  char name[51] ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 48
  if (! (names == 1)) {
#line 48
    if (! (names == 0)) {
      {
#line 49
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c", 49);
#line 49
      (*tmp)("glp_mincost_lp: names = %d; invalid parameter\n", names);
      }
    }
  }
#line 51
  if (v_rhs >= 0) {
#line 51
    if (v_rhs > G->v_size - (int )sizeof(double )) {
      {
#line 52
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 52);
#line 52
      (*tmp___0)("glp_mincost_lp: v_rhs = %d; invalid offset\n", v_rhs);
      }
    }
  }
#line 53
  if (a_low >= 0) {
#line 53
    if (a_low > G->a_size - (int )sizeof(double )) {
      {
#line 54
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 54);
#line 54
      (*tmp___1)("glp_mincost_lp: a_low = %d; invalid offset\n", a_low);
      }
    }
  }
#line 55
  if (a_cap >= 0) {
#line 55
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 56
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 56);
#line 56
      (*tmp___2)("glp_mincost_lp: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
#line 57
  if (a_cost >= 0) {
#line 57
    if (a_cost > G->a_size - (int )sizeof(double )) {
      {
#line 58
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 58);
#line 58
      (*tmp___3)("glp_mincost_lp: a_cost = %d; invalid offset\n", a_cost);
      }
    }
  }
  {
#line 60
  glp_erase_prob(lp);
  }
#line 61
  if (names) {
    {
#line 61
    glp_set_prob_name(lp, (char const   *)G->name);
    }
  }
#line 62
  if (G->nv > 0) {
    {
#line 62
    glp_add_rows(lp, G->nv);
    }
  }
#line 63
  i = 1;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i <= G->nv)) {
#line 63
      goto while_break;
    }
#line 64
    v = *(G->v + i);
#line 65
    if (names) {
      {
#line 65
      glp_set_row_name(lp, i, (char const   *)v->name);
      }
    }
#line 66
    if (v_rhs >= 0) {
      {
#line 67
      memcpy((void */* __restrict  */)(& rhs), (void const   */* __restrict  */)((char *)v->data + v_rhs),
             (size_t )sizeof(double ));
      }
    } else {
#line 69
      rhs = 0.0;
    }
    {
#line 70
    glp_set_row_bnds(lp, i, 5, rhs, rhs);
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (G->na > 0) {
    {
#line 72
    glp_add_cols(lp, G->na);
    }
  }
#line 73
  i = 1;
#line 73
  j = 0;
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 73
    if (! (i <= G->nv)) {
#line 73
      goto while_break___0;
    }
#line 74
    v = *(G->v + i);
#line 75
    a = v->out;
    {
#line 75
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 75
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 75
        goto while_break___1;
      }
#line 76
      j ++;
#line 77
      if (names) {
        {
#line 79
        sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"x[%d,%d]",
                (a->tail)->i, (a->head)->i);
#line 80
        tmp___4 = strlen((char const   *)(name));
        }
#line 80
        if ((unsigned long )tmp___4 < sizeof(name)) {
#line 80
          tmp___5 = 1;
        } else {
          {
#line 80
          _glp_lib_xassert("strlen(name) < sizeof(name)", "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                           80);
#line 80
          tmp___5 = 1;
          }
        }
        {
#line 81
        glp_set_col_name(lp, j, (char const   *)(name));
        }
      }
#line 83
      if ((a->tail)->i != (a->head)->i) {
        {
#line 84
        ind[1] = (a->tail)->i;
#line 84
        val[1] = 1.0;
#line 85
        ind[2] = (a->head)->i;
#line 85
        val[2] = - 1.0;
#line 86
        glp_set_mat_col(lp, j, 2, (int const   *)(ind), (double const   *)(val));
        }
      }
#line 88
      if (a_low >= 0) {
        {
#line 89
        memcpy((void */* __restrict  */)(& low), (void const   */* __restrict  */)((char *)a->data + a_low),
               (size_t )sizeof(double ));
        }
      } else {
#line 91
        low = 0.0;
      }
#line 92
      if (a_cap >= 0) {
        {
#line 93
        memcpy((void */* __restrict  */)(& cap), (void const   */* __restrict  */)((char *)a->data + a_cap),
               (size_t )sizeof(double ));
        }
      } else {
#line 95
        cap = 1.0;
      }
#line 96
      if (cap == 1.7976931348623157e+308) {
#line 97
        type = 2;
      } else
#line 98
      if (low != cap) {
#line 99
        type = 4;
      } else {
#line 101
        type = 5;
      }
      {
#line 102
      glp_set_col_bnds(lp, j, type, low, cap);
      }
#line 103
      if (a_cost >= 0) {
        {
#line 104
        memcpy((void */* __restrict  */)(& cost), (void const   */* __restrict  */)((char *)a->data + a_cost),
               (size_t )sizeof(double ));
        }
      } else {
#line 106
        cost = 0.0;
      }
      {
#line 107
      glp_set_obj_coef(lp, j, cost);
#line 75
      a = a->t_next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 73
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  if (j == G->na) {
#line 110
    tmp___6 = 1;
  } else {
    {
#line 110
    _glp_lib_xassert("j == G->na", "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                     110);
#line 110
    tmp___6 = 1;
    }
  }
#line 111
  return;
}
}
#line 116 "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c"
int glp_mincost_okalg(glp_graph *G , int v_rhs , int a_low , int a_cap , int a_cost ,
                      double *sol , int a_x , int v_pi ) 
{ 
  glp_vertex *v ;
  glp_arc *a ;
  int nv ;
  int na ;
  int i ;
  int k ;
  int s ;
  int t ;
  int *tail ;
  int *head ;
  int *low ;
  int *cap ;
  int *cost ;
  int *x ;
  int *pi ;
  int ret ;
  double sum ;
  double temp ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
#line 124
  if (v_rhs >= 0) {
#line 124
    if (v_rhs > G->v_size - (int )sizeof(double )) {
      {
#line 125
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c", 125);
#line 125
      (*tmp)("glp_mincost_okalg: v_rhs = %d; invalid offset\n", v_rhs);
      }
    }
  }
#line 127
  if (a_low >= 0) {
#line 127
    if (a_low > G->a_size - (int )sizeof(double )) {
      {
#line 128
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 128);
#line 128
      (*tmp___0)("glp_mincost_okalg: a_low = %d; invalid offset\n", a_low);
      }
    }
  }
#line 130
  if (a_cap >= 0) {
#line 130
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 131
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 131);
#line 131
      (*tmp___1)("glp_mincost_okalg: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
#line 133
  if (a_cost >= 0) {
#line 133
    if (a_cost > G->a_size - (int )sizeof(double )) {
      {
#line 134
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 134);
#line 134
      (*tmp___2)("glp_mincost_okalg: a_cost = %d; invalid offset\n", a_cost);
      }
    }
  }
#line 136
  if (a_x >= 0) {
#line 136
    if (a_x > G->a_size - (int )sizeof(double )) {
      {
#line 137
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 137);
#line 137
      (*tmp___3)("glp_mincost_okalg: a_x = %d; invalid offset\n", a_x);
      }
    }
  }
#line 138
  if (v_pi >= 0) {
#line 138
    if (v_pi > G->v_size - (int )sizeof(double )) {
      {
#line 139
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 139);
#line 139
      (*tmp___4)("glp_mincost_okalg: v_pi = %d; invalid offset\n", v_pi);
      }
    }
  }
#line 141
  s = G->nv + 1;
#line 143
  t = s + 1;
#line 145
  nv = t;
#line 147
  na = G->na + 1;
#line 148
  i = 1;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i <= G->nv)) {
#line 148
      goto while_break;
    }
#line 149
    v = *(G->v + i);
#line 150
    if (v_rhs >= 0) {
      {
#line 151
      memcpy((void */* __restrict  */)(& temp), (void const   */* __restrict  */)((char *)v->data + v_rhs),
             (size_t )sizeof(double ));
      }
    } else {
#line 153
      temp = 0.0;
    }
#line 154
    if (temp != 0.0) {
#line 154
      na ++;
    }
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  tmp___5 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 157
  tail = (int *)tmp___5;
#line 158
  tmp___6 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 158
  head = (int *)tmp___6;
#line 159
  tmp___7 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 159
  low = (int *)tmp___7;
#line 160
  tmp___8 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 160
  cap = (int *)tmp___8;
#line 161
  tmp___9 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 161
  cost = (int *)tmp___9;
#line 162
  tmp___10 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 162
  x = (int *)tmp___10;
#line 163
  tmp___11 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 163
  pi = (int *)tmp___11;
#line 165
  k = 0;
#line 167
  i = 1;
  }
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (i <= G->nv)) {
#line 167
      goto while_break___0;
    }
#line 168
    v = *(G->v + i);
#line 169
    a = v->out;
    {
#line 169
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 169
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 169
        goto while_break___1;
      }
#line 170
      k ++;
#line 171
      *(tail + k) = (a->tail)->i;
#line 172
      *(head + k) = (a->head)->i;
#line 173
      if (*(tail + k) == *(head + k)) {
#line 174
        ret = 18;
#line 175
        goto done;
      }
#line 177
      if (a_low >= 0) {
        {
#line 178
        memcpy((void */* __restrict  */)(& temp), (void const   */* __restrict  */)((char *)a->data + a_low),
               (size_t )sizeof(double ));
        }
      } else {
#line 180
        temp = 0.0;
      }
#line 181
      if (0.0 <= temp) {
#line 181
        if (temp <= (double )2147483647) {
          {
#line 181
          tmp___12 = floor(temp);
          }
#line 181
          if (! (temp == tmp___12)) {
#line 183
            ret = 18;
#line 184
            goto done;
          }
        } else {
#line 183
          ret = 18;
#line 184
          goto done;
        }
      } else {
#line 183
        ret = 18;
#line 184
        goto done;
      }
#line 186
      *(low + k) = (int )temp;
#line 187
      if (a_cap >= 0) {
        {
#line 188
        memcpy((void */* __restrict  */)(& temp), (void const   */* __restrict  */)((char *)a->data + a_cap),
               (size_t )sizeof(double ));
        }
      } else {
#line 190
        temp = 1.0;
      }
#line 191
      if ((double )*(low + k) <= temp) {
#line 191
        if (temp <= (double )2147483647) {
          {
#line 191
          tmp___13 = floor(temp);
          }
#line 191
          if (! (temp == tmp___13)) {
#line 193
            ret = 18;
#line 194
            goto done;
          }
        } else {
#line 193
          ret = 18;
#line 194
          goto done;
        }
      } else {
#line 193
        ret = 18;
#line 194
        goto done;
      }
#line 196
      *(cap + k) = (int )temp;
#line 197
      if (a_cost >= 0) {
        {
#line 198
        memcpy((void */* __restrict  */)(& temp), (void const   */* __restrict  */)((char *)a->data + a_cost),
               (size_t )sizeof(double ));
        }
      } else {
#line 200
        temp = 0.0;
      }
      {
#line 201
      tmp___14 = fabs(temp);
      }
#line 201
      if (tmp___14 <= (double )2147483647) {
        {
#line 201
        tmp___15 = floor(temp);
        }
#line 201
        if (! (temp == tmp___15)) {
#line 202
          ret = 18;
#line 203
          goto done;
        }
      } else {
#line 202
        ret = 18;
#line 203
        goto done;
      }
#line 205
      *(cost + k) = (int )temp;
#line 169
      a = a->t_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 167
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  sum = 0.0;
#line 210
  i = 1;
  {
#line 210
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 210
    if (! (i <= G->nv)) {
#line 210
      goto while_break___2;
    }
#line 211
    v = *(G->v + i);
#line 212
    if (v_rhs >= 0) {
      {
#line 213
      memcpy((void */* __restrict  */)(& temp), (void const   */* __restrict  */)((char *)v->data + v_rhs),
             (size_t )sizeof(double ));
      }
    } else {
#line 215
      temp = 0.0;
    }
    {
#line 216
    tmp___16 = fabs(temp);
    }
#line 216
    if (tmp___16 <= (double )2147483647) {
      {
#line 216
      tmp___17 = floor(temp);
      }
#line 216
      if (! (temp == tmp___17)) {
#line 217
        ret = 18;
#line 218
        goto done;
      }
    } else {
#line 217
      ret = 18;
#line 218
      goto done;
    }
#line 220
    if (temp > 0.0) {
#line 222
      k ++;
#line 223
      *(tail + k) = s;
#line 224
      *(head + k) = i;
#line 225
      tmp___18 = (int )temp;
#line 225
      *(cap + k) = tmp___18;
#line 225
      *(low + k) = tmp___18;
#line 226
      *(cost + k) = 0;
#line 227
      sum += temp;
    } else
#line 229
    if (temp < 0.0) {
#line 231
      k ++;
#line 232
      *(tail + k) = i;
#line 233
      *(head + k) = t;
#line 234
      tmp___19 = (int )(- temp);
#line 234
      *(cap + k) = tmp___19;
#line 234
      *(low + k) = tmp___19;
#line 235
      *(cost + k) = 0;
    }
#line 210
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 239
  k ++;
#line 240
  if (k == na) {
#line 240
    tmp___20 = 1;
  } else {
    {
#line 240
    _glp_lib_xassert("k == na", "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                     240);
#line 240
    tmp___20 = 1;
    }
  }
#line 241
  *(tail + k) = t;
#line 242
  *(head + k) = s;
#line 243
  if (sum > (double )2147483647) {
#line 244
    ret = 18;
#line 245
    goto done;
  }
  {
#line 247
  tmp___21 = (int )sum;
#line 247
  *(cap + k) = tmp___21;
#line 247
  *(low + k) = tmp___21;
#line 248
  *(cost + k) = 0;
#line 250
  ret = _glp_okalg(nv, na, (int const   *)tail, (int const   *)head, (int const   *)low,
                   (int const   *)cap, (int const   *)cost, x, pi);
  }
  {
#line 252
  if (ret == 0) {
#line 252
    goto case_0;
  }
#line 256
  if (ret == 1) {
#line 256
    goto case_1;
  }
#line 260
  if (ret == 2) {
#line 260
    goto case_2;
  }
#line 264
  if (ret == 3) {
#line 264
    goto case_3;
  }
#line 268
  goto switch_default;
  case_0: /* CIL Label */ 
#line 254
  ret = 0;
#line 255
  goto switch_break;
  case_1: /* CIL Label */ 
#line 258
  ret = 10;
#line 259
  goto switch_break;
  case_2: /* CIL Label */ 
#line 262
  ret = 19;
#line 263
  goto done;
  case_3: /* CIL Label */ 
#line 266
  ret = 5;
#line 267
  goto done;
  switch_default: /* CIL Label */ 
#line 269
  if (ret != ret) {
#line 269
    tmp___22 = 1;
  } else {
    {
#line 269
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                     269);
#line 269
    tmp___22 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 273
  if ((unsigned long )sol != (unsigned long )((void *)0)) {
#line 274
    temp = 0.0;
#line 275
    k = 1;
    {
#line 275
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 275
      if (! (k <= na)) {
#line 275
        goto while_break___3;
      }
#line 276
      temp += (double )*(cost + k) * (double )*(x + k);
#line 275
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 277
    *sol = temp;
  }
#line 280
  if (a_x >= 0) {
#line 281
    k = 0;
#line 282
    i = 1;
    {
#line 282
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 282
      if (! (i <= G->nv)) {
#line 282
        goto while_break___4;
      }
#line 283
      v = *(G->v + i);
#line 284
      a = v->out;
      {
#line 284
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 284
        if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 284
          goto while_break___5;
        }
        {
#line 285
        k ++;
#line 285
        temp = (double )*(x + k);
#line 286
        memcpy((void */* __restrict  */)((char *)a->data + a_x), (void const   */* __restrict  */)(& temp),
               (size_t )sizeof(double ));
#line 284
        a = a->t_next;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 282
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 291
  if (v_pi >= 0) {
#line 292
    i = 1;
    {
#line 292
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 292
      if (! (i <= G->nv)) {
#line 292
        goto while_break___6;
      }
      {
#line 293
      v = *(G->v + i);
#line 294
      temp = - ((double )*(pi + i));
#line 295
      memcpy((void */* __restrict  */)((char *)v->data + v_pi), (void const   */* __restrict  */)(& temp),
             (size_t )sizeof(double ));
#line 292
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  done: 
  {
#line 299
  _glp_lib_xfree((void *)tail);
#line 300
  _glp_lib_xfree((void *)head);
#line 301
  _glp_lib_xfree((void *)low);
#line 302
  _glp_lib_xfree((void *)cap);
#line 303
  _glp_lib_xfree((void *)cost);
#line 304
  _glp_lib_xfree((void *)x);
#line 305
  _glp_lib_xfree((void *)pi);
  }
#line 306
  return (ret);
}
}
#line 324 "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c"
void glp_maxflow_lp(glp_prob *lp , glp_graph *G , int names , int s , int t , int a_cap ) 
{ 
  glp_vertex *v ;
  glp_arc *a ;
  int i ;
  int j ;
  int type ;
  int ind[3] ;
  double cap ;
  double val[3] ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  char name[51] ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 330
  if (! (names == 1)) {
#line 330
    if (! (names == 0)) {
      {
#line 331
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c", 331);
#line 331
      (*tmp)("glp_maxflow_lp: names = %d; invalid parameter\n", names);
      }
    }
  }
#line 333
  if (1 <= s) {
#line 333
    if (! (s <= G->nv)) {
      {
#line 334
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 334);
#line 334
      (*tmp___0)("glp_maxflow_lp: s = %d; source node number out of range\n", s);
      }
    }
  } else {
    {
#line 334
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                               334);
#line 334
    (*tmp___0)("glp_maxflow_lp: s = %d; source node number out of range\n", s);
    }
  }
#line 336
  if (1 <= t) {
#line 336
    if (! (t <= G->nv)) {
      {
#line 337
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 337);
#line 337
      (*tmp___1)("glp_maxflow_lp: t = %d: sink node number out of range \n", t);
      }
    }
  } else {
    {
#line 337
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                               337);
#line 337
    (*tmp___1)("glp_maxflow_lp: t = %d: sink node number out of range \n", t);
    }
  }
#line 339
  if (s == t) {
    {
#line 340
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                               340);
#line 340
    (*tmp___2)("glp_maxflow_lp: s = t = %d; source and sink nodes must be distinct\n",
               s);
    }
  }
#line 342
  if (a_cap >= 0) {
#line 342
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 343
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 343);
#line 343
      (*tmp___3)("glp_maxflow_lp: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
  {
#line 344
  glp_erase_prob(lp);
  }
#line 345
  if (names) {
    {
#line 345
    glp_set_prob_name(lp, (char const   *)G->name);
    }
  }
  {
#line 346
  glp_set_obj_dir(lp, 2);
#line 347
  glp_add_rows(lp, G->nv);
#line 348
  i = 1;
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (i <= G->nv)) {
#line 348
      goto while_break;
    }
#line 349
    v = *(G->v + i);
#line 350
    if (names) {
      {
#line 350
      glp_set_row_name(lp, i, (char const   *)v->name);
      }
    }
#line 351
    if (i == s) {
#line 352
      type = 2;
    } else
#line 353
    if (i == t) {
#line 354
      type = 3;
    } else {
#line 356
      type = 5;
    }
    {
#line 357
    glp_set_row_bnds(lp, i, type, 0.0, 0.0);
#line 348
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if (G->na > 0) {
    {
#line 359
    glp_add_cols(lp, G->na);
    }
  }
#line 360
  i = 1;
#line 360
  j = 0;
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! (i <= G->nv)) {
#line 360
      goto while_break___0;
    }
#line 361
    v = *(G->v + i);
#line 362
    a = v->out;
    {
#line 362
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 362
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 362
        goto while_break___1;
      }
#line 363
      j ++;
#line 364
      if (names) {
        {
#line 366
        sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"x[%d,%d]",
                (a->tail)->i, (a->head)->i);
#line 367
        tmp___4 = strlen((char const   *)(name));
        }
#line 367
        if ((unsigned long )tmp___4 < sizeof(name)) {
#line 367
          tmp___5 = 1;
        } else {
          {
#line 367
          _glp_lib_xassert("strlen(name) < sizeof(name)", "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                           367);
#line 367
          tmp___5 = 1;
          }
        }
        {
#line 368
        glp_set_col_name(lp, j, (char const   *)(name));
        }
      }
#line 370
      if ((a->tail)->i != (a->head)->i) {
        {
#line 371
        ind[1] = (a->tail)->i;
#line 371
        val[1] = 1.0;
#line 372
        ind[2] = (a->head)->i;
#line 372
        val[2] = - 1.0;
#line 373
        glp_set_mat_col(lp, j, 2, (int const   *)(ind), (double const   *)(val));
        }
      }
#line 375
      if (a_cap >= 0) {
        {
#line 376
        memcpy((void */* __restrict  */)(& cap), (void const   */* __restrict  */)((char *)a->data + a_cap),
               (size_t )sizeof(double ));
        }
      } else {
#line 378
        cap = 1.0;
      }
#line 379
      if (cap == 1.7976931348623157e+308) {
#line 380
        type = 2;
      } else
#line 381
      if (cap != 0.0) {
#line 382
        type = 4;
      } else {
#line 384
        type = 5;
      }
      {
#line 385
      glp_set_col_bnds(lp, j, type, 0.0, cap);
      }
#line 386
      if ((a->tail)->i == s) {
        {
#line 387
        glp_set_obj_coef(lp, j, 1.0);
        }
      } else
#line 388
      if ((a->head)->i == s) {
        {
#line 389
        glp_set_obj_coef(lp, j, - 1.0);
        }
      }
#line 362
      a = a->t_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 360
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 392
  if (j == G->na) {
#line 392
    tmp___6 = 1;
  } else {
    {
#line 392
    _glp_lib_xassert("j == G->na", "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                     392);
#line 392
    tmp___6 = 1;
    }
  }
#line 393
  return;
}
}
#line 396 "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c"
int glp_maxflow_ffalg(glp_graph *G , int s , int t , int a_cap , double *sol , int a_x ,
                      int v_cut ) 
{ 
  glp_vertex *v ;
  glp_arc *a ;
  int nv ;
  int na ;
  int i ;
  int k ;
  int flag ;
  int *tail ;
  int *head ;
  int *cap ;
  int *x ;
  int ret ;
  char *cut ;
  double temp ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 404
  if (1 <= s) {
#line 404
    if (! (s <= G->nv)) {
      {
#line 405
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c", 405);
#line 405
      (*tmp)("glp_maxflow_ffalg: s = %d; source node number out of range\n", s);
      }
    }
  } else {
    {
#line 405
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c", 405);
#line 405
    (*tmp)("glp_maxflow_ffalg: s = %d; source node number out of range\n", s);
    }
  }
#line 407
  if (1 <= t) {
#line 407
    if (! (t <= G->nv)) {
      {
#line 408
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 408);
#line 408
      (*tmp___0)("glp_maxflow_ffalg: t = %d: sink node number out of range\n", t);
      }
    }
  } else {
    {
#line 408
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                               408);
#line 408
    (*tmp___0)("glp_maxflow_ffalg: t = %d: sink node number out of range\n", t);
    }
  }
#line 410
  if (s == t) {
    {
#line 411
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                               411);
#line 411
    (*tmp___1)("glp_maxflow_ffalg: s = t = %d; source and sink nodes must be distinct\n",
               s);
    }
  }
#line 413
  if (a_cap >= 0) {
#line 413
    if (a_cap > G->a_size - (int )sizeof(double )) {
      {
#line 414
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 414);
#line 414
      (*tmp___2)("glp_maxflow_ffalg: a_cap = %d; invalid offset\n", a_cap);
      }
    }
  }
#line 416
  if (v_cut >= 0) {
#line 416
    if (v_cut > G->v_size - (int )sizeof(int )) {
      {
#line 417
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                                 417);
#line 417
      (*tmp___3)("glp_maxflow_ffalg: v_cut = %d; invalid offset\n", v_cut);
      }
    }
  }
  {
#line 420
  nv = G->nv;
#line 421
  na = G->na;
#line 422
  tmp___4 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 422
  tail = (int *)tmp___4;
#line 423
  tmp___5 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 423
  head = (int *)tmp___5;
#line 424
  tmp___6 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 424
  cap = (int *)tmp___6;
#line 425
  tmp___7 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 425
  x = (int *)tmp___7;
  }
#line 426
  if (v_cut < 0) {
#line 427
    cut = (char *)((void *)0);
  } else {
    {
#line 429
    tmp___8 = _glp_lib_xcalloc(1 + nv, (int )sizeof(char ));
#line 429
    cut = (char *)tmp___8;
    }
  }
#line 431
  k = 0;
#line 432
  i = 1;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (i <= G->nv)) {
#line 432
      goto while_break;
    }
#line 433
    v = *(G->v + i);
#line 434
    a = v->out;
    {
#line 434
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 434
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 434
        goto while_break___0;
      }
#line 435
      k ++;
#line 436
      *(tail + k) = (a->tail)->i;
#line 437
      *(head + k) = (a->head)->i;
#line 438
      if (*(tail + k) == *(head + k)) {
#line 439
        ret = 18;
#line 440
        goto done;
      }
#line 442
      if (a_cap >= 0) {
        {
#line 443
        memcpy((void */* __restrict  */)(& temp), (void const   */* __restrict  */)((char *)a->data + a_cap),
               (size_t )sizeof(double ));
        }
      } else {
#line 445
        temp = 1.0;
      }
#line 446
      if (0.0 <= temp) {
#line 446
        if (temp <= (double )2147483647) {
          {
#line 446
          tmp___9 = floor(temp);
          }
#line 446
          if (! (temp == tmp___9)) {
#line 448
            ret = 18;
#line 449
            goto done;
          }
        } else {
#line 448
          ret = 18;
#line 449
          goto done;
        }
      } else {
#line 448
        ret = 18;
#line 449
        goto done;
      }
#line 451
      *(cap + k) = (int )temp;
#line 434
      a = a->t_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 432
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  if (k == na) {
#line 454
    tmp___10 = 1;
  } else {
    {
#line 454
    _glp_lib_xassert("k == na", "/home/wslee/benchmarks/glpk-4.38/src/glpapi19.c",
                     454);
#line 454
    tmp___10 = 1;
    }
  }
  {
#line 456
  _glp_ffalg(nv, na, (int const   *)tail, (int const   *)head, s, t, (int const   *)cap,
             x, cut);
#line 457
  ret = 0;
  }
#line 460
  if ((unsigned long )sol != (unsigned long )((void *)0)) {
#line 461
    temp = 0.0;
#line 462
    k = 1;
    {
#line 462
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 462
      if (! (k <= na)) {
#line 462
        goto while_break___1;
      }
#line 463
      if (*(tail + k) == s) {
#line 464
        temp += (double )*(x + k);
      } else
#line 465
      if (*(head + k) == s) {
#line 466
        temp -= (double )*(x + k);
      }
#line 462
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 468
    *sol = temp;
  }
#line 471
  if (a_x >= 0) {
#line 472
    k = 0;
#line 473
    i = 1;
    {
#line 473
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 473
      if (! (i <= G->nv)) {
#line 473
        goto while_break___2;
      }
#line 474
      v = *(G->v + i);
#line 475
      a = v->out;
      {
#line 475
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 475
        if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 475
          goto while_break___3;
        }
        {
#line 476
        k ++;
#line 476
        temp = (double )*(x + k);
#line 477
        memcpy((void */* __restrict  */)((char *)a->data + a_x), (void const   */* __restrict  */)(& temp),
               (size_t )sizeof(double ));
#line 475
        a = a->t_next;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 473
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 482
  if (v_cut >= 0) {
#line 483
    i = 1;
    {
#line 483
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 483
      if (! (i <= G->nv)) {
#line 483
        goto while_break___4;
      }
      {
#line 484
      v = *(G->v + i);
#line 485
      flag = (int )*(cut + i);
#line 486
      memcpy((void */* __restrict  */)((char *)v->data + v_cut), (void const   */* __restrict  */)(& flag),
             (size_t )sizeof(int ));
#line 483
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  done: 
  {
#line 490
  _glp_lib_xfree((void *)tail);
#line 491
  _glp_lib_xfree((void *)head);
#line 492
  _glp_lib_xfree((void *)cap);
#line 493
  _glp_lib_xfree((void *)x);
  }
#line 494
  if ((unsigned long )cut != (unsigned long )((void *)0)) {
    {
#line 494
    _glp_lib_xfree((void *)cut);
    }
  }
#line 495
  return (ret);
}
}
#line 848 "./../include/glpk.h"
int glp_weak_comp(glp_graph *G , int v_num ) ;
#line 851
int glp_strong_comp(glp_graph *G , int v_num ) ;
#line 53 "/home/wslee/benchmarks/glpk-4.38/src/glpapi18.c"
int glp_weak_comp(glp_graph *G , int v_num ) 
{ 
  glp_vertex *v ;
  glp_arc *a ;
  int f ;
  int i ;
  int j ;
  int nc ;
  int nv ;
  int pos1 ;
  int pos2 ;
  int *prev ;
  int *next ;
  int *list ;
  xerror_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 57
  if (v_num >= 0) {
#line 57
    if (v_num > G->v_size - (int )sizeof(int )) {
      {
#line 58
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi18.c", 58);
#line 58
      (*tmp)("glp_weak_comp: v_num = %d; invalid offset\n", v_num);
      }
    }
  }
#line 59
  nv = G->nv;
#line 60
  if (nv == 0) {
#line 61
    nc = 0;
#line 62
    goto done;
  }
  {
#line 65
  tmp___0 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 65
  prev = (int *)tmp___0;
#line 66
  tmp___1 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 66
  next = (int *)tmp___1;
#line 67
  tmp___2 = _glp_lib_xcalloc(1 + nv, (int )sizeof(int ));
#line 67
  list = (int *)tmp___2;
#line 73
  f = 1;
#line 74
  i = 1;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i <= nv)) {
#line 74
      goto while_break;
    }
#line 75
    *(prev + i) = i - 1;
#line 75
    *(next + i) = i + 1;
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  *(next + nv) = 0;
#line 78
  nc = 0;
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! (f != 0)) {
#line 79
      goto while_break___0;
    }
#line 81
    i = f;
#line 83
    f = *(next + i);
#line 84
    if (f != 0) {
#line 84
      *(prev + f) = 0;
    }
#line 86
    *(prev + i) = -1;
#line 86
    nc ++;
#line 86
    *(next + i) = nc;
#line 88
    *(list + 1) = i;
#line 88
    pos2 = 1;
#line 88
    pos1 = pos2;
    {
#line 89
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 89
      if (! (pos1 <= pos2)) {
#line 89
        goto while_break___1;
      }
#line 91
      tmp___3 = pos1;
#line 91
      pos1 ++;
#line 91
      i = *(list + tmp___3);
#line 93
      a = (*(G->v + i))->in;
      {
#line 93
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 93
        if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 93
          goto while_break___2;
        }
#line 95
        j = (a->tail)->i;
#line 96
        if (*(prev + j) >= 0) {
#line 99
          if (*(prev + j) == 0) {
#line 100
            f = *(next + j);
          } else {
#line 102
            *(next + *(prev + j)) = *(next + j);
          }
#line 103
          if (! (*(next + j) == 0)) {
#line 106
            *(prev + *(next + j)) = *(prev + j);
          }
#line 108
          *(prev + j) = -1;
#line 108
          *(next + j) = nc;
#line 110
          pos2 ++;
#line 110
          *(list + pos2) = j;
        }
#line 93
        a = a->h_next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 114
      a = (*(G->v + i))->out;
      {
#line 114
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 114
        if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 114
          goto while_break___3;
        }
#line 116
        j = (a->head)->i;
#line 117
        if (*(prev + j) >= 0) {
#line 120
          if (*(prev + j) == 0) {
#line 121
            f = *(next + j);
          } else {
#line 123
            *(next + *(prev + j)) = *(next + j);
          }
#line 124
          if (! (*(next + j) == 0)) {
#line 127
            *(prev + *(next + j)) = *(prev + j);
          }
#line 129
          *(prev + j) = -1;
#line 129
          *(next + j) = nc;
#line 131
          pos2 ++;
#line 131
          *(list + pos2) = j;
        }
#line 114
        a = a->t_next;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  if (v_num >= 0) {
#line 138
    i = 1;
    {
#line 138
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 138
      if (! (i <= nv)) {
#line 138
        goto while_break___4;
      }
      {
#line 139
      v = *(G->v + i);
#line 140
      memcpy((void */* __restrict  */)((char *)v->data + v_num), (void const   */* __restrict  */)(next + i),
             (size_t )sizeof(int ));
#line 138
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 144
  _glp_lib_xfree((void *)prev);
#line 145
  _glp_lib_xfree((void *)next);
#line 146
  _glp_lib_xfree((void *)list);
  }
  done: 
#line 147
  return (nc);
}
}
#line 178 "/home/wslee/benchmarks/glpk-4.38/src/glpapi18.c"
int glp_strong_comp(glp_graph *G , int v_num ) 
{ 
  glp_vertex *v ;
  glp_arc *a ;
  int i ;
  int k ;
  int last ;
  int n ;
  int na ;
  int nc ;
  int *icn ;
  int *ip ;
  int *lenr ;
  int *ior ;
  int *ib ;
  int *lowl ;
  int *numb ;
  int *prev ;
  xerror_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 183
  if (v_num >= 0) {
#line 183
    if (v_num > G->v_size - (int )sizeof(int )) {
      {
#line 184
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi18.c", 184);
#line 184
      (*tmp)("glp_strong_comp: v_num = %d; invalid offset\n", v_num);
      }
    }
  }
#line 186
  n = G->nv;
#line 187
  if (n == 0) {
#line 188
    nc = 0;
#line 189
    goto done;
  }
  {
#line 191
  na = G->na;
#line 192
  tmp___0 = _glp_lib_xcalloc(1 + na, (int )sizeof(int ));
#line 192
  icn = (int *)tmp___0;
#line 193
  tmp___1 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 193
  ip = (int *)tmp___1;
#line 194
  tmp___2 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 194
  lenr = (int *)tmp___2;
#line 195
  tmp___3 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 195
  ior = (int *)tmp___3;
#line 196
  tmp___4 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 196
  ib = (int *)tmp___4;
#line 197
  tmp___5 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 197
  lowl = (int *)tmp___5;
#line 198
  tmp___6 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 198
  numb = (int *)tmp___6;
#line 199
  tmp___7 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 199
  prev = (int *)tmp___7;
#line 200
  k = 1;
#line 201
  i = 1;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i <= n)) {
#line 201
      goto while_break;
    }
#line 202
    v = *(G->v + i);
#line 203
    *(ip + i) = k;
#line 204
    a = v->out;
    {
#line 204
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 204
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 204
        goto while_break___0;
      }
#line 205
      tmp___8 = k;
#line 205
      k ++;
#line 205
      *(icn + tmp___8) = (a->head)->i;
#line 204
      a = a->t_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 206
    *(lenr + i) = k - *(ip + i);
#line 201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  if (na == k - 1) {
#line 208
    tmp___9 = 1;
  } else {
    {
#line 208
    _glp_lib_xassert("na == k-1", "/home/wslee/benchmarks/glpk-4.38/src/glpapi18.c",
                     208);
#line 208
    tmp___9 = 1;
    }
  }
  {
#line 209
  nc = _glp_mc13d(n, (int const   *)icn, (int const   *)ip, (int const   *)lenr, ior,
                  ib, lowl, numb, prev);
  }
#line 210
  if (v_num >= 0) {
#line 211
    if (*(ib + 1) == 1) {
#line 211
      tmp___10 = 1;
    } else {
      {
#line 211
      _glp_lib_xassert("ib[1] == 1", "/home/wslee/benchmarks/glpk-4.38/src/glpapi18.c",
                       211);
#line 211
      tmp___10 = 1;
      }
    }
#line 212
    k = 1;
    {
#line 212
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 212
      if (! (k <= nc)) {
#line 212
        goto while_break___1;
      }
#line 213
      if (k < nc) {
#line 213
        last = *(ib + (k + 1));
      } else {
#line 213
        last = n + 1;
      }
#line 214
      if (*(ib + k) < last) {
#line 214
        tmp___11 = 1;
      } else {
        {
#line 214
        _glp_lib_xassert("ib[k] < last", "/home/wslee/benchmarks/glpk-4.38/src/glpapi18.c",
                         214);
#line 214
        tmp___11 = 1;
        }
      }
#line 215
      i = *(ib + k);
      {
#line 215
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 215
        if (! (i < last)) {
#line 215
          goto while_break___2;
        }
        {
#line 216
        v = *(G->v + *(ior + i));
#line 217
        memcpy((void */* __restrict  */)((char *)v->data + v_num), (void const   */* __restrict  */)(& k),
               (size_t )sizeof(int ));
#line 215
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 212
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 221
  _glp_lib_xfree((void *)icn);
#line 222
  _glp_lib_xfree((void *)ip);
#line 223
  _glp_lib_xfree((void *)lenr);
#line 224
  _glp_lib_xfree((void *)ior);
#line 225
  _glp_lib_xfree((void *)ib);
#line 226
  _glp_lib_xfree((void *)lowl);
#line 227
  _glp_lib_xfree((void *)numb);
#line 228
  _glp_lib_xfree((void *)prev);
  }
  done: 
#line 229
  return (nc);
}
}
#line 798 "./../include/glpk.h"
int glp_read_graph(glp_graph *G , char const   *fname ) ;
#line 801
int glp_write_graph(glp_graph *G , char const   *fname ) ;
#line 58 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
static void create_graph(glp_graph *G , int v_size , int a_size ) 
{ 
  DMP *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 59
  tmp = _glp_dmp_create_pool();
#line 59
  G->pool = (void *)tmp;
#line 60
  G->name = (char *)((void *)0);
#line 61
  G->nv_max = 50;
#line 62
  tmp___0 = 0;
#line 62
  G->na = tmp___0;
#line 62
  G->nv = tmp___0;
#line 63
  tmp___1 = _glp_lib_xcalloc(1 + G->nv_max, (int )sizeof(glp_vertex *));
#line 63
  G->v = (glp_vertex **)tmp___1;
#line 64
  G->index = (void *)0;
#line 65
  G->v_size = v_size;
#line 66
  G->a_size = a_size;
  }
#line 67
  return;
}
}
#line 70 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
glp_graph *glp_create_graph(int v_size , int a_size ) 
{ 
  glp_graph *G ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 72
  if (0 <= v_size) {
#line 72
    if (! (v_size <= 256)) {
      {
#line 73
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c", 73);
#line 73
      (*tmp)("glp_create_graph: v_size = %d; invalid size of vertex data\n", v_size);
      }
    }
  } else {
    {
#line 73
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c", 73);
#line 73
    (*tmp)("glp_create_graph: v_size = %d; invalid size of vertex data\n", v_size);
    }
  }
#line 75
  if (0 <= a_size) {
#line 75
    if (! (a_size <= 256)) {
      {
#line 76
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                                 76);
#line 76
      (*tmp___0)("glp_create_graph: a_size = %d; invalid size of arc data\n", a_size);
      }
    }
  } else {
    {
#line 76
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                               76);
#line 76
    (*tmp___0)("glp_create_graph: a_size = %d; invalid size of arc data\n", a_size);
    }
  }
  {
#line 78
  tmp___1 = _glp_lib_xmalloc((int )sizeof(glp_graph ));
#line 78
  G = (glp_graph *)tmp___1;
#line 79
  create_graph(G, v_size, a_size);
  }
#line 80
  return (G);
}
}
#line 100 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
void glp_set_graph_name(glp_graph *G , char const   *name ) 
{ 
  size_t tmp ;
  int j ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 101
  if ((unsigned long )G->name != (unsigned long )((void *)0)) {
    {
#line 102
    tmp = strlen((char const   *)G->name);
#line 102
    _glp_dmp_free_atom((DMP *)G->pool, (void *)G->name, (int )(tmp + 1U));
#line 103
    G->name = (char *)((void *)0);
    }
  }
#line 105
  if (! ((unsigned long )name == (unsigned long )((void *)0))) {
#line 105
    if (! ((int const   )*(name + 0) == 0)) {
#line 107
      j = 0;
      {
#line 107
      while (1) {
        while_continue: /* CIL Label */ ;
#line 107
        if (! ((int const   )*(name + j) != 0)) {
#line 107
          goto while_break;
        }
#line 108
        if (j == 256) {
          {
#line 109
          tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                                     109);
#line 109
          (*tmp___0)("glp_set_graph_name: graph name too long\n");
          }
        }
        {
#line 110
        tmp___2 = __ctype_b_loc();
        }
#line 110
        if ((int const   )*(*tmp___2 + (int )((unsigned char )*(name + j))) & 2) {
          {
#line 111
          tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                                     111);
#line 111
          (*tmp___1)("glp_set_graph_name: graph name contains invalid character(s)\n");
          }
        }
#line 107
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 114
      tmp___3 = strlen(name);
#line 114
      tmp___4 = _glp_dmp_get_atom((DMP *)G->pool, (int )(tmp___3 + 1U));
#line 114
      G->name = (char *)tmp___4;
#line 115
      strcpy((char */* __restrict  */)G->name, (char const   */* __restrict  */)name);
      }
    }
  }
#line 117
  return;
}
}
#line 142 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
int glp_add_vertices(glp_graph *G , int nadd ) 
{ 
  int i ;
  int nv_new ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  glp_vertex **save ;
  int tmp___1 ;
  void *tmp___2 ;
  glp_vertex *v ;
  void *tmp___3 ;
  glp_arc *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 144
  if (nadd < 1) {
    {
#line 145
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c", 145);
#line 145
    (*tmp)("glp_add_vertices: nadd = %d; invalid number of vertices\n", nadd);
    }
  }
#line 147
  if (nadd > 100000000 - G->nv) {
    {
#line 148
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                               148);
#line 148
    (*tmp___0)("glp_add_vertices: nadd = %d; too many vertices\n", nadd);
    }
  }
#line 151
  nv_new = G->nv + nadd;
#line 153
  if (G->nv_max < nv_new) {
#line 154
    save = G->v;
    {
#line 155
    while (1) {
      while_continue: /* CIL Label */ ;
#line 155
      if (! (G->nv_max < nv_new)) {
#line 155
        goto while_break;
      }
#line 156
      G->nv_max += G->nv_max;
#line 157
      if (G->nv_max > 0) {
#line 157
        tmp___1 = 1;
      } else {
        {
#line 157
        _glp_lib_xassert("G->nv_max > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                         157);
#line 157
        tmp___1 = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 159
    tmp___2 = _glp_lib_xcalloc(1 + G->nv_max, (int )sizeof(glp_vertex *));
#line 159
    G->v = (glp_vertex **)tmp___2;
#line 160
    memcpy((void */* __restrict  */)(G->v + 1), (void const   */* __restrict  */)(save + 1),
           (size_t )((unsigned long )G->nv * sizeof(glp_vertex *)));
#line 161
    _glp_lib_xfree((void *)save);
    }
  }
#line 164
  i = G->nv + 1;
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (i <= nv_new)) {
#line 164
      goto while_break___0;
    }
    {
#line 166
    tmp___3 = _glp_dmp_get_atom((DMP *)G->pool, (int )sizeof(glp_vertex ));
#line 166
    v = (glp_vertex *)tmp___3;
#line 166
    *(G->v + i) = v;
#line 167
    v->i = i;
#line 168
    v->name = (char *)((void *)0);
#line 169
    v->entry = (void *)0;
    }
#line 170
    if (G->v_size == 0) {
#line 171
      v->data = (void *)0;
    } else {
      {
#line 173
      v->data = _glp_dmp_get_atom((DMP *)G->pool, G->v_size);
#line 174
      memset(v->data, 0, (size_t )G->v_size);
      }
    }
#line 176
    v->temp = (void *)0;
#line 177
    tmp___4 = (glp_arc *)((void *)0);
#line 177
    v->out = tmp___4;
#line 177
    v->in = tmp___4;
#line 164
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 180
  G->nv = nv_new;
#line 182
  return ((nv_new - nadd) + 1);
}
}
#line 206 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
glp_arc *glp_add_arc(glp_graph *G , int i , int j ) 
{ 
  glp_arc *a ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  void *tmp___2 ;
  glp_arc *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 208
  if (1 <= i) {
#line 208
    if (! (i <= G->nv)) {
      {
#line 209
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c", 209);
#line 209
      (*tmp)("glp_add_arc: i = %d; tail vertex number out of range\n", i);
      }
    }
  } else {
    {
#line 209
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c", 209);
#line 209
    (*tmp)("glp_add_arc: i = %d; tail vertex number out of range\n", i);
    }
  }
#line 211
  if (1 <= j) {
#line 211
    if (! (j <= G->nv)) {
      {
#line 212
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                                 212);
#line 212
      (*tmp___0)("glp_add_arc: j = %d; head vertex number out of range\n", j);
      }
    }
  } else {
    {
#line 212
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                               212);
#line 212
    (*tmp___0)("glp_add_arc: j = %d; head vertex number out of range\n", j);
    }
  }
#line 214
  if (G->na == 500000000) {
    {
#line 215
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                               215);
#line 215
    (*tmp___1)("glp_add_arc: too many arcs\n");
    }
  }
  {
#line 216
  tmp___2 = _glp_dmp_get_atom((DMP *)G->pool, (int )sizeof(glp_arc ));
#line 216
  a = (glp_arc *)tmp___2;
#line 217
  a->tail = *(G->v + i);
#line 218
  a->head = *(G->v + j);
  }
#line 219
  if (G->a_size == 0) {
#line 220
    a->data = (void *)0;
  } else {
    {
#line 222
    a->data = _glp_dmp_get_atom((DMP *)G->pool, G->a_size);
#line 223
    memset(a->data, 0, (size_t )G->a_size);
    }
  }
#line 225
  a->temp = (void *)0;
#line 226
  a->t_prev = (glp_arc *)((void *)0);
#line 227
  a->t_next = (*(G->v + i))->out;
#line 228
  if ((unsigned long )a->t_next != (unsigned long )((void *)0)) {
#line 228
    (a->t_next)->t_prev = a;
  }
#line 229
  a->h_prev = (glp_arc *)((void *)0);
#line 230
  a->h_next = (*(G->v + j))->in;
#line 231
  if ((unsigned long )a->h_next != (unsigned long )((void *)0)) {
#line 231
    (a->h_next)->h_prev = a;
  }
#line 232
  tmp___3 = a;
#line 232
  (*(G->v + j))->in = tmp___3;
#line 232
  (*(G->v + i))->out = tmp___3;
#line 233
  (G->na) ++;
#line 234
  return (a);
}
}
#line 254 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
static void delete_graph(glp_graph *G ) 
{ 


  {
  {
#line 255
  _glp_dmp_delete_pool((DMP *)G->pool);
#line 256
  _glp_lib_xfree((void *)G->v);
  }
#line 257
  if ((unsigned long )G->index != (unsigned long )((void *)0)) {
    {
#line 257
    _glp_avl_delete_tree((AVL *)G->index);
    }
  }
#line 258
  return;
}
}
#line 261 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
void glp_erase_graph(glp_graph *G , int v_size , int a_size ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 262
  if (0 <= v_size) {
#line 262
    if (! (v_size <= 256)) {
      {
#line 263
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c", 263);
#line 263
      (*tmp)("glp_erase_graph: v_size = %d; invalid size of vertex data\n", v_size);
      }
    }
  } else {
    {
#line 263
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c", 263);
#line 263
    (*tmp)("glp_erase_graph: v_size = %d; invalid size of vertex data\n", v_size);
    }
  }
#line 265
  if (0 <= a_size) {
#line 265
    if (! (a_size <= 256)) {
      {
#line 266
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                                 266);
#line 266
      (*tmp___0)("glp_erase_graph: a_size = %d; invalid size of arc data\n", a_size);
      }
    }
  } else {
    {
#line 266
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c",
                               266);
#line 266
    (*tmp___0)("glp_erase_graph: a_size = %d; invalid size of arc data\n", a_size);
    }
  }
  {
#line 268
  delete_graph(G);
#line 269
  create_graph(G, v_size, a_size);
  }
#line 270
  return;
}
}
#line 287 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
void glp_delete_graph(glp_graph *G ) 
{ 


  {
  {
#line 288
  delete_graph(G);
#line 289
  _glp_lib_xfree((void *)G);
  }
#line 290
  return;
}
}
#line 311 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
int glp_read_graph(glp_graph *G , char const   *fname ) 
{ 
  _glp_data___0 *data ;
  jmp_buf jump ;
  int nv ;
  int na ;
  int i ;
  int j ;
  int k ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 315
  glp_erase_graph(G, G->v_size, G->a_size);
#line 316
  _glp_lib_xprintf("Reading graph from `%s\'...\n", fname);
#line 317
  data = _glp_sds_open(fname);
  }
#line 318
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 319
    ret = 1;
#line 320
    goto done;
  }
  {
#line 322
  tmp = _setjmp((struct __jmp_buf_tag *)(jump));
  }
#line 322
  if (tmp) {
#line 323
    ret = 1;
#line 324
    goto done;
  }
  {
#line 326
  _glp_sds_jump(data, (void *)(jump));
#line 327
  nv = _glp_sds_int(data);
  }
#line 328
  if (nv < 0) {
    {
#line 329
    _glp_sds_error(data, "invalid number of vertices\n");
    }
  }
  {
#line 330
  na = _glp_sds_int(data);
  }
#line 331
  if (na < 0) {
    {
#line 332
    _glp_sds_error(data, "invalid number of arcs\n");
    }
  }
#line 333
  if (na == 1) {
#line 333
    tmp___0 = "";
  } else {
#line 333
    tmp___0 = "s";
  }
#line 333
  if (nv == 1) {
#line 333
    tmp___1 = "ex";
  } else {
#line 333
    tmp___1 = "ices";
  }
  {
#line 333
  _glp_lib_xprintf("Graph has %d vert%s and %d arc%s\n", nv, tmp___1, na, tmp___0);
  }
#line 335
  if (nv > 0) {
    {
#line 335
    glp_add_vertices(G, nv);
    }
  }
#line 336
  k = 1;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (k <= na)) {
#line 336
      goto while_break;
    }
    {
#line 337
    i = _glp_sds_int(data);
    }
#line 338
    if (1 <= i) {
#line 338
      if (! (i <= nv)) {
        {
#line 339
        _glp_sds_error(data, "tail vertex number out of range\n");
        }
      }
    } else {
      {
#line 339
      _glp_sds_error(data, "tail vertex number out of range\n");
      }
    }
    {
#line 340
    j = _glp_sds_int(data);
    }
#line 341
    if (1 <= j) {
#line 341
      if (! (j <= nv)) {
        {
#line 342
        _glp_sds_error(data, "head vertex number out of range\n");
        }
      }
    } else {
      {
#line 342
      _glp_sds_error(data, "head vertex number out of range\n");
      }
    }
    {
#line 343
    glp_add_arc(G, i, j);
#line 336
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  tmp___2 = _glp_sds_line(data);
#line 345
  _glp_lib_xprintf("%d lines were read\n", tmp___2);
#line 346
  ret = 0;
  }
  done: 
#line 347
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    {
#line 347
    _glp_sds_close(data);
    }
  }
#line 348
  return (ret);
}
}
#line 370 "/home/wslee/benchmarks/glpk-4.38/src/glpapi17.c"
int glp_write_graph(glp_graph *G , char const   *fname ) 
{ 
  XFILE *fp ;
  glp_vertex *v ;
  glp_arc *a ;
  int i ;
  int count ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 375
  _glp_lib_xprintf("Writing graph to `%s\'...\n", fname);
#line 376
  fp = _glp_lib_xfopen(fname, "w");
#line 376
  count = 0;
  }
#line 377
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 378
    tmp = _glp_lib_xerrmsg();
#line 378
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp);
#line 379
    ret = 1;
    }
#line 380
    goto done;
  }
  {
#line 382
  _glp_lib_xfprintf(fp, "%d %d\n", G->nv, G->na);
#line 382
  count ++;
#line 383
  i = 1;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i <= G->nv)) {
#line 383
      goto while_break;
    }
#line 384
    v = *(G->v + i);
#line 385
    a = v->out;
    {
#line 385
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 385
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 385
        goto while_break___0;
      }
      {
#line 386
      _glp_lib_xfprintf(fp, "%d %d\n", (a->tail)->i, (a->head)->i);
#line 386
      count ++;
#line 385
      a = a->t_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 388
  _glp_lib_xfflush(fp);
#line 389
  tmp___1 = _glp_lib_xferror(fp);
  }
#line 389
  if (tmp___1) {
    {
#line 390
    tmp___0 = _glp_lib_xerrmsg();
#line 390
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___0);
#line 391
    ret = 1;
    }
#line 392
    goto done;
  }
  {
#line 394
  _glp_lib_xprintf("%d lines were written\n", count);
#line 395
  ret = 0;
  }
  done: 
#line 396
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 396
    _glp_lib_xfclose(fp);
    }
  }
#line 397
  return (ret);
}
}
#line 30 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
glp_tran___0 *glp_mpl_alloc_wksp(void) 
{ 
  glp_tran___0 *tran ;

  {
  {
#line 33
  tran = _glp_mpl_initialize();
  }
#line 34
  return (tran);
}
}
#line 37 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
int glp_mpl_read_model(glp_tran___0 *tran , char const   *fname , int skip ) 
{ 
  int ret ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 40
  if (tran->phase != 0) {
    {
#line 41
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c", 41);
#line 41
    (*tmp)("glp_mpl_read_model: invalid call sequence\n");
    }
  }
  {
#line 42
  ret = _glp_mpl_read_model(tran, (char *)fname, skip);
  }
#line 43
  if (ret == 1) {
#line 44
    ret = 0;
  } else
#line 43
  if (ret == 2) {
#line 44
    ret = 0;
  } else
#line 45
  if (ret == 4) {
#line 46
    ret = 1;
  } else
#line 48
  if (ret != ret) {
#line 48
    tmp___0 = 1;
  } else {
    {
#line 48
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                     48);
#line 48
    tmp___0 = 1;
    }
  }
#line 49
  return (ret);
}
}
#line 52 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
int glp_mpl_read_data(glp_tran___0 *tran , char const   *fname ) 
{ 
  int ret ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 55
  if (! (tran->phase == 1)) {
#line 55
    if (! (tran->phase == 2)) {
      {
#line 56
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c", 56);
#line 56
      (*tmp)("glp_mpl_read_data: invalid call sequence\n");
      }
    }
  }
  {
#line 57
  ret = _glp_mpl_read_data(tran, (char *)fname);
  }
#line 58
  if (ret == 2) {
#line 59
    ret = 0;
  } else
#line 60
  if (ret == 4) {
#line 61
    ret = 1;
  } else
#line 63
  if (ret != ret) {
#line 63
    tmp___0 = 1;
  } else {
    {
#line 63
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                     63);
#line 63
    tmp___0 = 1;
    }
  }
#line 64
  return (ret);
}
}
#line 67 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
int glp_mpl_generate(glp_tran___0 *tran , char const   *fname ) 
{ 
  int ret ;
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 70
  if (! (tran->phase == 1)) {
#line 70
    if (! (tran->phase == 2)) {
      {
#line 71
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c", 71);
#line 71
      (*tmp)("glp_mpl_generate: invalid call sequence\n");
      }
    }
  }
  {
#line 72
  ret = _glp_mpl_generate(tran, (char *)fname);
  }
#line 73
  if (ret == 3) {
#line 74
    ret = 0;
  } else
#line 75
  if (ret == 4) {
#line 76
    ret = 1;
  }
#line 77
  return (ret);
}
}
#line 80 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
void glp_mpl_build_prob(glp_tran___0 *tran , glp_prob *prob ) 
{ 
  int m ;
  int n ;
  int i ;
  int j ;
  int t ;
  int kind ;
  int type ;
  int len ;
  int *ind ;
  double lb ;
  double ub ;
  double *val ;
  xerror_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  char *tmp___8 ;
  double tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  double tmp___21 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 84
  if (tran->phase != 3) {
    {
#line 85
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c", 85);
#line 85
    (*tmp)("glp_mpl_build_prob: invalid call sequence\n");
    }
  }
  {
#line 87
  glp_erase_prob(prob);
#line 89
  tmp___0 = _glp_mpl_get_prob_name(tran);
#line 89
  glp_set_prob_name(prob, (char const   *)tmp___0);
#line 91
  m = _glp_mpl_get_num_rows(tran);
  }
#line 92
  if (m > 0) {
    {
#line 93
    glp_add_rows(prob, m);
    }
  }
#line 94
  i = 1;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i <= m)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = _glp_mpl_get_row_name(tran, i);
#line 96
    glp_set_row_name(prob, i, (char const   *)tmp___1);
#line 98
    type = _glp_mpl_get_row_bnds(tran, i, & lb, & ub);
    }
    {
#line 100
    if (type == 401) {
#line 100
      goto case_401;
    }
#line 101
    if (type == 402) {
#line 101
      goto case_402;
    }
#line 102
    if (type == 403) {
#line 102
      goto case_403;
    }
#line 103
    if (type == 404) {
#line 103
      goto case_404;
    }
#line 104
    if (type == 405) {
#line 104
      goto case_405;
    }
#line 105
    goto switch_default;
    case_401: /* CIL Label */ 
#line 100
    type = 1;
#line 100
    goto switch_break;
    case_402: /* CIL Label */ 
#line 101
    type = 2;
#line 101
    goto switch_break;
    case_403: /* CIL Label */ 
#line 102
    type = 3;
#line 102
    goto switch_break;
    case_404: /* CIL Label */ 
#line 103
    type = 4;
#line 103
    goto switch_break;
    case_405: /* CIL Label */ 
#line 104
    type = 5;
#line 104
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 105
    if (type != type) {
#line 105
      tmp___2 = 1;
    } else {
      {
#line 105
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                       105);
#line 105
      tmp___2 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 107
    if (type == 4) {
      {
#line 107
      tmp___5 = fabs(lb - ub);
#line 107
      tmp___6 = fabs(lb);
      }
#line 107
      if (tmp___5 < 1e-9 * (1.0 + tmp___6)) {
        {
#line 108
        type = 5;
#line 109
        tmp___3 = fabs(lb);
#line 109
        tmp___4 = fabs(ub);
        }
#line 109
        if (tmp___3 <= tmp___4) {
#line 109
          ub = lb;
        } else {
#line 109
          lb = ub;
        }
      }
    }
    {
#line 111
    glp_set_row_bnds(prob, i, type, lb, ub);
#line 113
    tmp___9 = _glp_mpl_get_row_c0(tran, i);
    }
#line 113
    if (tmp___9 != 0.0) {
      {
#line 114
      tmp___7 = _glp_mpl_get_row_c0(tran, i);
#line 114
      tmp___8 = _glp_mpl_get_row_name(tran, i);
#line 114
      _glp_lib_xprintf("glp_mpl_build_prob: row %s; constant term %.12g ignored\n",
                       tmp___8, tmp___7);
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  n = _glp_mpl_get_num_cols(tran);
  }
#line 120
  if (n > 0) {
    {
#line 121
    glp_add_cols(prob, n);
    }
  }
#line 122
  j = 1;
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (! (j <= n)) {
#line 122
      goto while_break___0;
    }
    {
#line 124
    tmp___10 = _glp_mpl_get_col_name(tran, j);
#line 124
    glp_set_col_name(prob, j, (char const   *)tmp___10);
#line 126
    kind = _glp_mpl_get_col_kind(tran, j);
    }
    {
#line 128
    if (kind == 421) {
#line 128
      goto case_421;
    }
#line 131
    if (kind == 423) {
#line 131
      goto case_423;
    }
#line 131
    if (kind == 422) {
#line 131
      goto case_423;
    }
#line 134
    goto switch_default___0;
    case_421: /* CIL Label */ 
#line 129
    goto switch_break___0;
    case_423: /* CIL Label */ 
    case_422: /* CIL Label */ 
    {
#line 132
    glp_set_col_kind(prob, j, 2);
    }
#line 133
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 135
    if (kind != kind) {
#line 135
      tmp___11 = 1;
    } else {
      {
#line 135
      _glp_lib_xassert("kind != kind", "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                       135);
#line 135
      tmp___11 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 138
    type = _glp_mpl_get_col_bnds(tran, j, & lb, & ub);
    }
    {
#line 140
    if (type == 401) {
#line 140
      goto case_401___0;
    }
#line 141
    if (type == 402) {
#line 141
      goto case_402___0;
    }
#line 142
    if (type == 403) {
#line 142
      goto case_403___0;
    }
#line 143
    if (type == 404) {
#line 143
      goto case_404___0;
    }
#line 144
    if (type == 405) {
#line 144
      goto case_405___0;
    }
#line 145
    goto switch_default___1;
    case_401___0: /* CIL Label */ 
#line 140
    type = 1;
#line 140
    goto switch_break___1;
    case_402___0: /* CIL Label */ 
#line 141
    type = 2;
#line 141
    goto switch_break___1;
    case_403___0: /* CIL Label */ 
#line 142
    type = 3;
#line 142
    goto switch_break___1;
    case_404___0: /* CIL Label */ 
#line 143
    type = 4;
#line 143
    goto switch_break___1;
    case_405___0: /* CIL Label */ 
#line 144
    type = 5;
#line 144
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 145
    if (type != type) {
#line 145
      tmp___12 = 1;
    } else {
      {
#line 145
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                       145);
#line 145
      tmp___12 = 1;
      }
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 147
    if (kind == 423) {
#line 148
      if (type == 1) {
#line 148
        lb = 0.0;
      } else
#line 148
      if (type == 3) {
#line 148
        lb = 0.0;
      } else
#line 148
      if (lb < 0.0) {
#line 148
        lb = 0.0;
      }
#line 149
      if (type == 1) {
#line 149
        ub = 1.0;
      } else
#line 149
      if (type == 2) {
#line 149
        ub = 1.0;
      } else
#line 149
      if (ub > 1.0) {
#line 149
        ub = 1.0;
      }
#line 150
      type = 4;
    }
#line 152
    if (type == 4) {
      {
#line 152
      tmp___15 = fabs(lb - ub);
#line 152
      tmp___16 = fabs(lb);
      }
#line 152
      if (tmp___15 < 1e-9 * (1.0 + tmp___16)) {
        {
#line 153
        type = 5;
#line 154
        tmp___13 = fabs(lb);
#line 154
        tmp___14 = fabs(ub);
        }
#line 154
        if (tmp___13 <= tmp___14) {
#line 154
          ub = lb;
        } else {
#line 154
          lb = ub;
        }
      }
    }
    {
#line 156
    glp_set_col_bnds(prob, j, type, lb, ub);
#line 122
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 159
  tmp___17 = _glp_lib_xcalloc(1 + n, (int )sizeof(int ));
#line 159
  ind = (int *)tmp___17;
#line 160
  tmp___18 = _glp_lib_xcalloc(1 + n, (int )sizeof(double ));
#line 160
  val = (double *)tmp___18;
#line 161
  i = 1;
  }
  {
#line 161
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 161
    if (! (i <= m)) {
#line 161
      goto while_break___1;
    }
    {
#line 162
    len = _glp_mpl_get_mat_row(tran, i, ind, val);
#line 163
    glp_set_mat_row(prob, i, len, (int const   *)ind, (double const   *)val);
#line 161
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 166
  i = 1;
  {
#line 166
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 166
    if (! (i <= m)) {
#line 166
      goto while_break___2;
    }
    {
#line 167
    kind = _glp_mpl_get_row_kind(tran, i);
    }
#line 168
    if (kind == 412) {
#line 168
      goto _L;
    } else
#line 168
    if (kind == 413) {
      _L: /* CIL Label */ 
      {
#line 170
      tmp___19 = _glp_mpl_get_row_name(tran, i);
#line 170
      glp_set_obj_name(prob, (char const   *)tmp___19);
      }
#line 172
      if (kind == 412) {
#line 172
        tmp___20 = 1;
      } else {
#line 172
        tmp___20 = 2;
      }
      {
#line 172
      glp_set_obj_dir(prob, tmp___20);
#line 174
      tmp___21 = _glp_mpl_get_row_c0(tran, i);
#line 174
      glp_set_obj_coef(prob, 0, tmp___21);
#line 176
      len = _glp_mpl_get_mat_row(tran, i, ind, val);
#line 177
      t = 1;
      }
      {
#line 177
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 177
        if (! (t <= len)) {
#line 177
          goto while_break___3;
        }
        {
#line 178
        glp_set_obj_coef(prob, *(ind + t), *(val + t));
#line 177
        t ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 179
      goto while_break___2;
    }
#line 166
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 183
  _glp_lib_xfree((void *)ind);
#line 184
  _glp_lib_xfree((void *)val);
  }
#line 185
  return;
}
}
#line 188 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
int glp_mpl_postsolve(glp_tran___0 *tran , glp_prob *prob , int sol ) 
{ 
  int j ;
  int m ;
  int n ;
  int ret ;
  double x ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 192
  if (tran->phase == 3) {
#line 192
    if (! (! tran->flag_p)) {
      {
#line 193
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c", 193);
#line 193
      (*tmp)("glp_mpl_postsolve: invalid call sequence\n");
      }
    }
  } else {
    {
#line 193
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c", 193);
#line 193
    (*tmp)("glp_mpl_postsolve: invalid call sequence\n");
    }
  }
#line 194
  if (! (sol == 1)) {
#line 194
    if (! (sol == 2)) {
#line 194
      if (! (sol == 3)) {
        {
#line 195
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                                   195);
#line 195
        (*tmp___0)("glp_mpl_postsolve: sol = %d; invalid parameter\n", sol);
        }
      }
    }
  }
  {
#line 197
  m = _glp_mpl_get_num_rows(tran);
#line 198
  n = _glp_mpl_get_num_cols(tran);
#line 199
  tmp___2 = glp_get_num_rows(prob);
  }
#line 199
  if (m == tmp___2) {
    {
#line 199
    tmp___3 = glp_get_num_cols(prob);
    }
#line 199
    if (! (n == tmp___3)) {
      {
#line 201
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                                 201);
#line 201
      (*tmp___1)("glp_mpl_postsolve: wrong problem object\n");
      }
    }
  } else {
    {
#line 201
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                               201);
#line 201
    (*tmp___1)("glp_mpl_postsolve: wrong problem object\n");
    }
  }
  {
#line 202
  tmp___4 = _glp_mpl_has_solve_stmt(tran);
  }
#line 202
  if (! tmp___4) {
#line 203
    ret = 0;
#line 204
    goto done;
  }
#line 206
  j = 1;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (j <= n)) {
#line 206
      goto while_break;
    }
#line 207
    if (sol == 1) {
      {
#line 208
      x = glp_get_col_prim(prob, j);
      }
    } else
#line 209
    if (sol == 2) {
      {
#line 210
      x = glp_ipt_col_prim(prob, j);
      }
    } else
#line 211
    if (sol == 3) {
      {
#line 212
      x = glp_mip_col_val(prob, j);
      }
    } else
#line 214
    if (sol != sol) {
#line 214
      tmp___5 = 1;
    } else {
      {
#line 214
      _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c",
                       214);
#line 214
      tmp___5 = 1;
      }
    }
    {
#line 215
    tmp___6 = fabs(x);
    }
#line 215
    if (tmp___6 < 1e-9) {
#line 215
      x = 0.0;
    }
    {
#line 216
    _glp_mpl_put_col_value(tran, j, x);
#line 206
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 218
  ret = _glp_mpl_postsolve(tran);
  }
#line 219
  if (ret == 3) {
#line 220
    ret = 0;
  } else
#line 221
  if (ret == 4) {
#line 222
    ret = 1;
  }
  done: 
#line 223
  return (ret);
}
}
#line 226 "/home/wslee/benchmarks/glpk-4.38/src/glpapi16.c"
void glp_mpl_free_wksp(glp_tran___0 *tran ) 
{ 


  {
  {
#line 228
  _glp_mpl_terminate(tran);
  }
#line 229
  return;
}
}
#line 55 "/home/wslee/benchmarks/glpk-4.38/src/glpapi15.c"
int glp_read_lp(glp_prob *lp , void const   *parm , char const   *fname ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 56
  if ((unsigned long )parm != (unsigned long )((void *)0)) {
    {
#line 57
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi15.c", 57);
#line 57
    (*tmp)("glp_read_lp: parm = %p; invalid parameter\n", parm);
    }
  }
  {
#line 58
  tmp___0 = _glp_read_cpxlp(lp, fname);
  }
#line 58
  return (tmp___0);
}
}
#line 86 "/home/wslee/benchmarks/glpk-4.38/src/glpapi15.c"
int glp_write_lp(glp_prob *lp , void const   *parm , char const   *fname ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 87
  if ((unsigned long )parm != (unsigned long )((void *)0)) {
    {
#line 88
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi15.c", 88);
#line 88
    (*tmp)("glp_write_lp: parm = %p; invalid parameter\n", parm);
    }
  }
  {
#line 89
  tmp___0 = _glp_write_cpxlp(lp, fname);
  }
#line 89
  return (tmp___0);
}
}
#line 862 "./../include/glpk.h"
void glp_printf(char const   *fmt___0  , ...) ;
#line 865
void glp_term_out(int flag ) ;
#line 868
void glp_term_hook(int (*func___0)(void *info , char const   *s ) , void *info ) ;
#line 871
void *glp_malloc(int size ) ;
#line 874
void *glp_calloc(int n , int size ) ;
#line 877
void glp_free(void *ptr ) ;
#line 880
void glp_mem_usage(int *count , int *cpeak , glp_long *total , glp_long *tpeak ) ;
#line 887
void glp_free_env(void) ;
#line 42 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
char const   *glp_version(void) 
{ 
  char const   *tmp ;

  {
  {
#line 43
  tmp = _glp_lib_version();
  }
#line 43
  return (tmp);
}
}
#line 49 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void glp_printf(char const   *fmt___0  , ...) 
{ 
  va_list arg ;

  {
  {
#line 52
  __builtin_va_start(arg, fmt___0);
#line 53
  _glp_lib_xvprintf(fmt___0, arg);
#line 54
  __builtin_va_end(arg);
  }
#line 55
  return;
}
}
#line 75 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void glp_term_out(int flag ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 76
  tmp = _glp_lib_link_env();
#line 76
  env = tmp;
#line 77
  env->term_out = 1;
  }
#line 78
  if (! (flag == 1)) {
#line 78
    if (! (flag == 0)) {
      {
#line 79
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c",
                                 79);
#line 79
      (*tmp___0)("glp_term_out: flag = %d; invalid value\n", flag);
      }
    }
  }
#line 80
  env->term_out = flag;
#line 81
  return;
}
}
#line 116 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void glp_term_hook(int (*func___0)(void *info , char const   *s ) , void *info ) 
{ 


  {
  {
#line 117
  _glp_lib_term_hook(func___0, info);
  }
#line 118
  return;
}
}
#line 142 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void *glp_malloc(int size ) 
{ 
  void *ptr ;

  {
  {
#line 144
  ptr = _glp_lib_xmalloc(size);
  }
#line 145
  return (ptr);
}
}
#line 170 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void *glp_calloc(int n , int size ) 
{ 
  void *ptr ;

  {
  {
#line 172
  ptr = _glp_lib_xcalloc(n, size);
  }
#line 173
  return (ptr);
}
}
#line 190 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void glp_free(void *ptr ) 
{ 


  {
  {
#line 191
  _glp_lib_xfree(ptr);
  }
#line 192
  return;
}
}
#line 226 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void glp_mem_usage(int *count , int *cpeak , glp_long *total , glp_long *tpeak ) 
{ 
  xlong_t total1 ;
  xlong_t tpeak1 ;

  {
  {
#line 229
  _glp_lib_mem_usage(count, cpeak, & total1, & tpeak1);
  }
#line 230
  if ((unsigned long )total != (unsigned long )((void *)0)) {
#line 230
    total->lo = total1.lo;
#line 230
    total->hi = total1.hi;
  }
#line 231
  if ((unsigned long )tpeak != (unsigned long )((void *)0)) {
#line 231
    tpeak->lo = tpeak1.lo;
#line 231
    tpeak->hi = tpeak1.hi;
  }
#line 232
  return;
}
}
#line 249 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void glp_mem_limit(int limit ) 
{ 
  xerror_t tmp ;
  xlong_t tmp___0 ;
  xlong_t tmp___1 ;
  xlong_t tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 250
  if (limit < 0) {
    {
#line 251
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c", 251);
#line 251
    (*tmp)("glp_mem_limit: limit = %d; invalid parameter\n", limit);
    }
  }
  {
#line 253
  tmp___0 = _glp_lib_xlset(1 << 20);
#line 253
  tmp___1 = _glp_lib_xlset(limit);
#line 253
  tmp___2 = _glp_lib_xlmul(tmp___1, tmp___0);
#line 253
  _glp_lib_mem_limit(tmp___2);
  }
#line 254
  return;
}
}
#line 331 "/home/wslee/benchmarks/glpk-4.38/src/glpapi14.c"
void glp_free_env(void) 
{ 


  {
  {
#line 332
  _glp_lib_free_env();
  }
#line 333
  return;
}
}
#line 599 "./../include/glpk.h"
int glp_ios_reason(glp_tree___0 *tree ) ;
#line 602
glp_prob *glp_ios_get_prob(glp_tree___0 *tree ) ;
#line 605
void glp_ios_tree_size(glp_tree___0 *tree , int *a_cnt , int *n_cnt , int *t_cnt ) ;
#line 609
int glp_ios_curr_node(glp_tree___0 *tree ) ;
#line 612
int glp_ios_next_node(glp_tree___0 *tree , int p ) ;
#line 615
int glp_ios_prev_node(glp_tree___0 *tree , int p ) ;
#line 618
int glp_ios_up_node(glp_tree___0 *tree , int p ) ;
#line 621
int glp_ios_node_level(glp_tree___0 *tree , int p ) ;
#line 624
double glp_ios_node_bound(glp_tree___0 *tree , int p ) ;
#line 627
int glp_ios_best_node(glp_tree___0 *tree ) ;
#line 630
double glp_ios_mip_gap(glp_tree___0 *tree ) ;
#line 633
void *glp_ios_node_data(glp_tree___0 *tree , int p ) ;
#line 636
void glp_ios_row_attr(glp_tree___0 *tree , int i , glp_attr *attr ) ;
#line 650
void glp_ios_clear_pool(glp_tree___0 *tree ) ;
#line 653
int glp_ios_can_branch(glp_tree___0 *tree , int j ) ;
#line 659
void glp_ios_select_node(glp_tree___0 *tree , int p ) ;
#line 665
void glp_ios_terminate(glp_tree___0 *tree ) ;
#line 40 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_reason(glp_tree___0 *tree ) 
{ 


  {
#line 41
  return (tree->reason);
}
}
#line 69 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
glp_prob *glp_ios_get_prob(glp_tree___0 *tree ) 
{ 


  {
#line 70
  return (tree->mip);
}
}
#line 101 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void glp_ios_tree_size(glp_tree___0 *tree , int *a_cnt , int *n_cnt , int *t_cnt ) 
{ 


  {
#line 103
  if ((unsigned long )a_cnt != (unsigned long )((void *)0)) {
#line 103
    *a_cnt = tree->a_cnt;
  }
#line 104
  if ((unsigned long )n_cnt != (unsigned long )((void *)0)) {
#line 104
    *n_cnt = tree->n_cnt;
  }
#line 105
  if ((unsigned long )t_cnt != (unsigned long )((void *)0)) {
#line 105
    *t_cnt = tree->t_cnt;
  }
#line 106
  return;
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_curr_node(glp_tree___0 *tree ) 
{ 
  IOSNPD *node ;
  int tmp ;

  {
#line 127
  node = tree->curr;
#line 129
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 129
    tmp = 0;
  } else {
#line 129
    tmp = node->p;
  }
#line 129
  return (tmp);
}
}
#line 155 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_next_node(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 157
  if (p == 0) {
#line 159
    node = tree->head;
  } else {
#line 163
    if (1 <= p) {
#line 163
      if (! (p <= tree->nslots)) {
#line 163
        goto err;
      }
    } else {
      err: 
      {
#line 164
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 164);
#line 164
      (*tmp)("glp_ios_next_node: p = %d; invalid subproblem reference number\n", p);
      }
    }
#line 166
    node = (tree->slot + p)->node;
#line 167
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 167
      goto err;
    }
#line 169
    if (node->count != 0) {
      {
#line 170
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                                 170);
#line 170
      (*tmp___0)("glp_ios_next_node: p = %d; subproblem not in the active list\n",
                 p);
      }
    }
#line 173
    node = node->next;
  }
#line 176
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 176
    tmp___1 = 0;
  } else {
#line 176
    tmp___1 = node->p;
  }
#line 176
  return (tmp___1);
}
}
#line 202 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_prev_node(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 204
  if (p == 0) {
#line 206
    node = tree->tail;
  } else {
#line 210
    if (1 <= p) {
#line 210
      if (! (p <= tree->nslots)) {
#line 210
        goto err;
      }
    } else {
      err: 
      {
#line 211
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 211);
#line 211
      (*tmp)("glp_ios_prev_node: p = %d; invalid subproblem reference number\n", p);
      }
    }
#line 213
    node = (tree->slot + p)->node;
#line 214
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 214
      goto err;
    }
#line 216
    if (node->count != 0) {
      {
#line 217
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                                 217);
#line 217
      (*tmp___0)("glp_ios_prev_node: p = %d; subproblem not in the active list\n",
                 p);
      }
    }
#line 220
    node = node->prev;
  }
#line 223
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 223
    tmp___1 = 0;
  } else {
#line 223
    tmp___1 = node->p;
  }
#line 223
  return (tmp___1);
}
}
#line 243 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_up_node(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 246
  if (1 <= p) {
#line 246
    if (! (p <= tree->nslots)) {
#line 246
      goto err;
    }
  } else {
    err: 
    {
#line 247
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 247);
#line 247
    (*tmp)("glp_ios_up_node: p = %d; invalid subproblem reference number\n", p);
    }
  }
#line 249
  node = (tree->slot + p)->node;
#line 250
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 250
    goto err;
  }
#line 252
  node = node->up;
#line 254
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 254
    tmp___0 = 0;
  } else {
#line 254
    tmp___0 = node->p;
  }
#line 254
  return (tmp___0);
}
}
#line 273 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_node_level(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 276
  if (1 <= p) {
#line 276
    if (! (p <= tree->nslots)) {
#line 276
      goto err;
    }
  } else {
    err: 
    {
#line 277
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 277);
#line 277
    (*tmp)("glp_ios_node_level: p = %d; invalid subproblem reference number\n", p);
    }
  }
#line 279
  node = (tree->slot + p)->node;
#line 280
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 280
    goto err;
  }
#line 282
  return (node->level);
}
}
#line 316 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
double glp_ios_node_bound(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 319
  if (1 <= p) {
#line 319
    if (! (p <= tree->nslots)) {
#line 319
      goto err;
    }
  } else {
    err: 
    {
#line 320
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 320);
#line 320
    (*tmp)("glp_ios_node_bound: p = %d; invalid subproblem reference number\n", p);
    }
  }
#line 322
  node = (tree->slot + p)->node;
#line 323
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 323
    goto err;
  }
#line 325
  return (node->bound);
}
}
#line 350 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_best_node(glp_tree___0 *tree ) 
{ 
  int tmp ;

  {
  {
#line 351
  tmp = _glp_ios_best_node(tree);
  }
#line 351
  return (tmp);
}
}
#line 379 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
double glp_ios_mip_gap(glp_tree___0 *tree ) 
{ 
  double tmp ;

  {
  {
#line 380
  tmp = _glp_ios_relative_gap(tree);
  }
#line 380
  return (tmp);
}
}
#line 413 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void *glp_ios_node_data(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 416
  if (1 <= p) {
#line 416
    if (! (p <= tree->nslots)) {
#line 416
      goto err;
    }
  } else {
    err: 
    {
#line 417
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 417);
#line 417
    (*tmp)("glp_ios_node_level: p = %d; invalid subproblem reference number\n", p);
    }
  }
#line 419
  node = (tree->slot + p)->node;
#line 420
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 420
    goto err;
  }
#line 422
  return (node->data);
}
}
#line 439 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void glp_ios_row_attr(glp_tree___0 *tree , int i , glp_attr *attr ) 
{ 
  GLPROW *row ;
  xerror_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 441
  if (1 <= i) {
#line 441
    if (! (i <= (tree->mip)->m)) {
      {
#line 442
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 442);
#line 442
      (*tmp)("glp_ios_row_attr: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 442
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 442);
#line 442
    (*tmp)("glp_ios_row_attr: i = %d; row number out of range\n", i);
    }
  }
#line 444
  row = *((tree->mip)->row + i);
#line 445
  attr->level = row->level;
#line 446
  attr->origin = (int )row->origin;
#line 447
  attr->klass = (int )row->klass;
#line 448
  return;
}
}
#line 453 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_pool_size(glp_tree___0 *tree ) 
{ 
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 455
  if (tree->reason != 4) {
    {
#line 456
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 456);
#line 456
    (*tmp)("glp_ios_pool_size: operation not allowed\n");
    }
  }
#line 457
  if ((unsigned long )tree->local != (unsigned long )((void *)0)) {
#line 457
    tmp___0 = 1;
  } else {
    {
#line 457
    _glp_lib_xassert("tree->local != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                     457);
#line 457
    tmp___0 = 1;
    }
  }
#line 458
  return ((tree->local)->size);
}
}
#line 463 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_add_row(glp_tree___0 *tree , char const   *name , int klass , int flags ,
                    int len , int const   *ind , double const   *val , int type ,
                    double rhs ) 
{ 
  int num ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 468
  if (tree->reason != 4) {
    {
#line 469
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 469);
#line 469
    (*tmp)("glp_ios_add_row: operation not allowed\n");
    }
  }
#line 470
  if ((unsigned long )tree->local != (unsigned long )((void *)0)) {
#line 470
    tmp___0 = 1;
  } else {
    {
#line 470
    _glp_lib_xassert("tree->local != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                     470);
#line 470
    tmp___0 = 1;
    }
  }
  {
#line 471
  num = _glp_ios_add_row(tree, tree->local, name, klass, flags, len, ind, val, type,
                         rhs);
  }
#line 473
  return (num);
}
}
#line 478 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void glp_ios_del_row(glp_tree___0 *tree , int i ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 480
  if (tree->reason != 4) {
    {
#line 481
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 481);
#line 481
    (*tmp)("glp_ios_del_row: operation not allowed\n");
    }
  }
  {
#line 482
  _glp_ios_del_row(tree, tree->local, i);
  }
#line 483
  return;
}
}
#line 488 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void glp_ios_clear_pool(glp_tree___0 *tree ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 490
  if (tree->reason != 4) {
    {
#line 491
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 491);
#line 491
    (*tmp)("glp_ios_clear_pool: operation not allowed\n");
    }
  }
  {
#line 492
  _glp_ios_clear_pool(tree, tree->local);
  }
#line 493
  return;
}
}
#line 510 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_can_branch(glp_tree___0 *tree , int j ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 511
  if (1 <= j) {
#line 511
    if (! (j <= (tree->mip)->n)) {
      {
#line 512
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 512);
#line 512
      (*tmp)("glp_ios_can_branch: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 512
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 512);
#line 512
    (*tmp)("glp_ios_can_branch: j = %d; column number out of range\n", j);
    }
  }
#line 514
  return (*(tree->non_int + j));
}
}
#line 541 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void glp_ios_branch_upon(glp_tree___0 *tree , int j , int sel ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 542
  if (1 <= j) {
#line 542
    if (! (j <= (tree->mip)->n)) {
      {
#line 543
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 543);
#line 543
      (*tmp)("glp_ios_branch_upon: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 543
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 543);
#line 543
    (*tmp)("glp_ios_branch_upon: j = %d; column number out of range\n", j);
    }
  }
#line 545
  if (! (sel == 1)) {
#line 545
    if (! (sel == 2)) {
#line 545
      if (! (sel == 0)) {
        {
#line 547
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                                   547);
#line 547
        (*tmp___0)("glp_ios_branch_upon: sel = %d: branch selection flag invalid\n",
                   sel);
        }
      }
    }
  }
#line 549
  if (! *(tree->non_int + j)) {
    {
#line 550
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                               550);
#line 550
    (*tmp___1)("glp_ios_branch_upon: j = %d; variable cannot be used to branch upon\n",
               j);
    }
  }
#line 552
  if (tree->br_var != 0) {
    {
#line 553
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                               553);
#line 553
    (*tmp___2)("glp_ios_branch_upon: branching variable already chosen\n");
    }
  }
#line 555
  tree->br_var = j;
#line 556
  tree->br_sel = sel;
#line 557
  return;
}
}
#line 576 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void glp_ios_select_node(glp_tree___0 *tree , int p ) 
{ 
  IOSNPD *node ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 579
  if (1 <= p) {
#line 579
    if (! (p <= tree->nslots)) {
#line 579
      goto err;
    }
  } else {
    err: 
    {
#line 580
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c", 580);
#line 580
    (*tmp)("glp_ios_select_node: p = %d; invalid subproblem reference number\n", p);
    }
  }
#line 582
  node = (tree->slot + p)->node;
#line 583
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 583
    goto err;
  }
#line 585
  if (node->count != 0) {
    {
#line 586
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                               586);
#line 586
    (*tmp___0)("glp_ios_select_node: p = %d; subproblem not in the active list\n",
               p);
    }
  }
#line 589
  if ((unsigned long )tree->btrack != (unsigned long )((void *)0)) {
    {
#line 590
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                               590);
#line 590
    (*tmp___1)("glp_ios_select_node: subproblem already selected\n");
    }
  }
#line 592
  tree->btrack = node;
#line 593
  return;
}
}
#line 629 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
int glp_ios_heur_sol(glp_tree___0 *tree , double const   *x ) 
{ 
  glp_prob *mip ;
  int m ;
  int n ;
  int i ;
  int j ;
  double obj ;
  int tmp ;
  int tmp___0 ;
  GLPCOL *col ;
  double tmp___1 ;
  int tmp___2 ;
  GLPROW *row ;
  GLPAIJ *aij ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 630
  mip = tree->mip;
#line 631
  m = tree->orig_m;
#line 632
  n = tree->n;
#line 635
  if (mip->m >= m) {
#line 635
    tmp = 1;
  } else {
    {
#line 635
    _glp_lib_xassert("mip->m >= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                     635);
#line 635
    tmp = 1;
    }
  }
#line 636
  if (mip->n == n) {
#line 636
    tmp___0 = 1;
  } else {
    {
#line 636
    _glp_lib_xassert("mip->n == n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                     636);
#line 636
    tmp___0 = 1;
    }
  }
#line 639
  obj = mip->c0;
#line 640
  j = 1;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! (j <= n)) {
#line 640
      goto while_break;
    }
#line 641
    col = *(mip->col + j);
#line 642
    if (col->kind == 2) {
      {
#line 644
      tmp___1 = floor((double )*(x + j));
      }
#line 644
      if (*(x + j) != (double const   )tmp___1) {
#line 644
        return (1);
      }
    }
#line 646
    obj += col->coef * (double )*(x + j);
#line 640
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 650
  if (mip->mip_stat == 2) {
    {
#line 652
    if (mip->dir == 1) {
#line 652
      goto case_1;
    }
#line 655
    if (mip->dir == 2) {
#line 655
      goto case_2;
    }
#line 658
    goto switch_default;
    case_1: /* CIL Label */ 
#line 653
    if (obj >= (tree->mip)->mip_obj) {
#line 653
      return (1);
    }
#line 654
    goto switch_break;
    case_2: /* CIL Label */ 
#line 656
    if (obj <= (tree->mip)->mip_obj) {
#line 656
      return (1);
    }
#line 657
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 659
    if ((unsigned long )mip != (unsigned long )mip) {
#line 659
      tmp___2 = 1;
    } else {
      {
#line 659
      _glp_lib_xassert("mip != mip", "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c",
                       659);
#line 659
      tmp___2 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 663
  if ((tree->parm)->msg_lev >= 2) {
    {
#line 664
    _glp_lib_xprintf("Solution found by heuristic: %.12g\n", obj);
    }
  }
#line 665
  mip->mip_stat = 2;
#line 666
  mip->mip_obj = obj;
#line 667
  j = 1;
  {
#line 667
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 667
    if (! (j <= n)) {
#line 667
      goto while_break___0;
    }
#line 668
    (*(mip->col + j))->mipx = (double )*(x + j);
#line 667
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 669
  i = 1;
  {
#line 669
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 669
    if (! (i <= m)) {
#line 669
      goto while_break___1;
    }
#line 670
    row = *(mip->row + i);
#line 672
    row->mipx = 0.0;
#line 673
    aij = row->ptr;
    {
#line 673
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 673
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 673
        goto while_break___2;
      }
#line 674
      row->mipx += aij->val * (aij->col)->mipx;
#line 673
      aij = aij->r_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 669
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 676
  return (0);
}
}
#line 693 "/home/wslee/benchmarks/glpk-4.38/src/glpapi13.c"
void glp_ios_terminate(glp_tree___0 *tree ) 
{ 
  char *__cil_tmp2 ;

  {
#line 694
  if ((tree->parm)->msg_lev >= 4) {
    {
#line 695
    _glp_lib_xprintf("The search is prematurely terminated due to application request\n");
    }
  }
#line 697
  tree->terminate = 1;
#line 698
  return;
}
}
#line 569 "./../include/glpk.h"
int glp_bf_updated(glp_prob___0 *lp ) ;
#line 43 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_bf_exists(glp_prob___0 *lp ) 
{ 
  int ret ;
  int tmp ;

  {
#line 45
  if (lp->m == 0) {
#line 45
    tmp = 1;
  } else
#line 45
  if (lp->valid) {
#line 45
    tmp = 1;
  } else {
#line 45
    tmp = 0;
  }
#line 45
  ret = tmp;
#line 46
  return (ret);
}
}
#line 78 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
static int b_col(void *info , int j , int *ind , double *val ) 
{ 
  glp_prob___0 *lp ;
  int m ;
  GLPAIJ *aij ;
  int k ;
  int len ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 79
  lp = (glp_prob___0 *)info;
#line 80
  m = lp->m;
#line 83
  if (1 <= j) {
#line 83
    if (j <= m) {
#line 83
      tmp = 1;
    } else {
      {
#line 83
      _glp_lib_xassert("1 <= j && j <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                       83);
#line 83
      tmp = 1;
      }
    }
  } else {
    {
#line 83
    _glp_lib_xassert("1 <= j && j <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                     83);
#line 83
    tmp = 1;
    }
  }
#line 86
  k = *(lp->head + j);
#line 89
  if (k <= m) {
#line 91
    len = 1;
#line 92
    *(ind + 1) = k;
#line 93
    *(val + 1) = 1.0;
  } else {
#line 97
    len = 0;
#line 98
    aij = (*(lp->col + (k - m)))->ptr;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 98
        goto while_break;
      }
#line 99
      len ++;
#line 100
      *(ind + len) = (aij->row)->i;
#line 101
      *(val + len) = (- (aij->row)->rii * aij->val) * (aij->col)->sjj;
#line 98
      aij = aij->c_next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 104
  return (len);
}
}
#line 107
static void copy_bfcp(glp_prob___0 *lp ) ;
#line 109 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_factorize(glp_prob___0 *lp ) 
{ 
  int m ;
  int n ;
  GLPROW **row ;
  GLPCOL **col ;
  int *head ;
  int j ;
  int k ;
  int stat ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 110
  m = lp->m;
#line 111
  n = lp->n;
#line 112
  row = lp->row;
#line 113
  col = lp->col;
#line 114
  head = lp->head;
#line 117
  lp->valid = 0;
#line 119
  j = 0;
#line 120
  k = 1;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (k <= m + n)) {
#line 120
      goto while_break;
    }
#line 121
    if (k <= m) {
#line 122
      stat = (*(row + k))->stat;
#line 123
      (*(row + k))->bind = 0;
    } else {
#line 126
      stat = (*(col + (k - m)))->stat;
#line 127
      (*(col + (k - m)))->bind = 0;
    }
#line 129
    if (stat == 1) {
#line 130
      j ++;
#line 131
      if (j > m) {
#line 133
        ret = 1;
#line 134
        goto fini;
      }
#line 136
      *(head + j) = k;
#line 137
      if (k <= m) {
#line 138
        (*(row + k))->bind = j;
      } else {
#line 140
        (*(col + (k - m)))->bind = j;
      }
    }
#line 120
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  if (j < m) {
#line 145
    ret = 1;
#line 146
    goto fini;
  }
#line 149
  if (m > 0) {
#line 150
    if ((unsigned long )lp->bfd == (unsigned long )((void *)0)) {
      {
#line 151
      lp->bfd = _glp_bfd_create_it();
#line 152
      copy_bfcp(lp);
      }
    }
    {
#line 154
    tmp = _glp_bfd_factorize(lp->bfd, m, (int const   *)lp->head, & b_col, (void *)lp);
    }
    {
#line 155
    if (tmp == 0) {
#line 155
      goto case_0;
    }
#line 158
    if (tmp == 1) {
#line 158
      goto case_1;
    }
#line 162
    if (tmp == 2) {
#line 162
      goto case_2;
    }
#line 166
    goto switch_default;
    case_0: /* CIL Label */ 
#line 157
    goto switch_break;
    case_1: /* CIL Label */ 
#line 160
    ret = 2;
#line 161
    goto fini;
    case_2: /* CIL Label */ 
#line 164
    ret = 3;
#line 165
    goto fini;
    switch_default: /* CIL Label */ 
#line 167
    if ((unsigned long )lp != (unsigned long )lp) {
#line 167
      tmp___0 = 1;
    } else {
      {
#line 167
      _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                       167);
#line 167
      tmp___0 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 169
    lp->valid = 1;
  }
#line 172
  ret = 0;
  fini: 
#line 174
  return (ret);
}
}
#line 192 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_bf_updated(glp_prob___0 *lp ) 
{ 
  int cnt ;
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 194
  if (! (lp->m == 0)) {
#line 194
    if (! lp->valid) {
      {
#line 195
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 195);
#line 195
      (*tmp)("glp_bf_update: basis factorization does not exist\n");
      }
    }
  }
#line 196
  if (lp->m == 0) {
#line 196
    cnt = 0;
  } else {
#line 196
    cnt = (lp->bfd)->upd_cnt;
  }
#line 197
  return (cnt);
}
}
#line 218 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
void glp_get_bfcp(glp_prob___0 *lp , glp_bfcp *parm ) 
{ 
  glp_bfcp *bfcp ;

  {
#line 219
  bfcp = lp->bfcp;
#line 220
  if ((unsigned long )bfcp == (unsigned long )((void *)0)) {
#line 221
    parm->type = 1;
#line 222
    parm->lu_size = 0;
#line 223
    parm->piv_tol = 0.10;
#line 224
    parm->piv_lim = 4;
#line 225
    parm->suhl = 1;
#line 226
    parm->eps_tol = 1e-15;
#line 227
    parm->max_gro = 1e+10;
#line 228
    parm->nfs_max = 50;
#line 229
    parm->upd_tol = 1e-6;
#line 230
    parm->nrs_max = 50;
#line 231
    parm->rs_size = 0;
  } else {
    {
#line 234
    memcpy((void */* __restrict  */)parm, (void const   */* __restrict  */)bfcp, (size_t )sizeof(glp_bfcp ));
    }
  }
#line 235
  return;
}
}
#line 259 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
static void copy_bfcp(glp_prob___0 *lp ) 
{ 
  glp_bfcp _parm ;
  glp_bfcp *parm ;
  BFD___0 *bfd ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 260
  parm = & _parm;
#line 261
  bfd = lp->bfd;
#line 262
  glp_get_bfcp(lp, parm);
  }
#line 263
  if ((unsigned long )bfd != (unsigned long )((void *)0)) {
#line 263
    tmp = 1;
  } else {
    {
#line 263
    _glp_lib_xassert("bfd != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                     263);
#line 263
    tmp = 1;
    }
  }
#line 264
  bfd->type = parm->type;
#line 265
  bfd->lu_size = parm->lu_size;
#line 266
  bfd->piv_tol = parm->piv_tol;
#line 267
  bfd->piv_lim = parm->piv_lim;
#line 268
  bfd->suhl = parm->suhl;
#line 269
  bfd->eps_tol = parm->eps_tol;
#line 270
  bfd->max_gro = parm->max_gro;
#line 271
  bfd->nfs_max = parm->nfs_max;
#line 272
  bfd->upd_tol = parm->upd_tol;
#line 273
  bfd->nrs_max = parm->nrs_max;
#line 274
  bfd->rs_size = parm->rs_size;
#line 275
  return;
}
}
#line 278 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
void glp_set_bfcp(glp_prob___0 *lp , glp_bfcp const   *parm ) 
{ 
  glp_bfcp *bfcp ;
  glp_bfcp *tmp ;
  void *tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  xerror_t tmp___6 ;
  xerror_t tmp___7 ;
  xerror_t tmp___8 ;
  xerror_t tmp___9 ;
  xerror_t tmp___10 ;
  xerror_t tmp___11 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 279
  bfcp = lp->bfcp;
#line 280
  if ((unsigned long )parm == (unsigned long )((void *)0)) {
#line 282
    if ((unsigned long )bfcp != (unsigned long )((void *)0)) {
      {
#line 283
      _glp_lib_xfree((void *)bfcp);
#line 283
      lp->bfcp = (glp_bfcp *)((void *)0);
      }
    }
  } else {
#line 287
    if ((unsigned long )bfcp == (unsigned long )((void *)0)) {
      {
#line 288
      tmp___0 = _glp_lib_xmalloc((int )sizeof(glp_bfcp ));
#line 288
      tmp = (glp_bfcp *)tmp___0;
#line 288
      lp->bfcp = tmp;
#line 288
      bfcp = tmp;
      }
    }
    {
#line 289
    memcpy((void */* __restrict  */)bfcp, (void const   */* __restrict  */)parm, (size_t )sizeof(glp_bfcp ));
    }
#line 290
    if (! (bfcp->type == 1)) {
#line 290
      if (! (bfcp->type == 2)) {
#line 290
        if (! (bfcp->type == 3)) {
          {
#line 292
          tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                     292);
#line 292
          (*tmp___1)("glp_set_bfcp: type = %d; invalid parameter\n", bfcp->type);
          }
        }
      }
    }
#line 294
    if (bfcp->lu_size < 0) {
      {
#line 295
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 295);
#line 295
      (*tmp___2)("glp_set_bfcp: lu_size = %d; invalid parameter\n", bfcp->lu_size);
      }
    }
#line 297
    if (0.0 < bfcp->piv_tol) {
#line 297
      if (! (bfcp->piv_tol < 1.0)) {
        {
#line 298
        tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                   298);
#line 298
        (*tmp___3)("glp_set_bfcp: piv_tol = %g; invalid parameter\n", bfcp->piv_tol);
        }
      }
    } else {
      {
#line 298
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 298);
#line 298
      (*tmp___3)("glp_set_bfcp: piv_tol = %g; invalid parameter\n", bfcp->piv_tol);
      }
    }
#line 300
    if (bfcp->piv_lim < 1) {
      {
#line 301
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 301);
#line 301
      (*tmp___4)("glp_set_bfcp: piv_lim = %d; invalid parameter\n", bfcp->piv_lim);
      }
    }
#line 303
    if (! (bfcp->suhl == 1)) {
#line 303
      if (! (bfcp->suhl == 0)) {
        {
#line 304
        tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                   304);
#line 304
        (*tmp___5)("glp_set_bfcp: suhl = %d; invalid parameter\n", bfcp->suhl);
        }
      }
    }
#line 306
    if (0.0 <= bfcp->eps_tol) {
#line 306
      if (! (bfcp->eps_tol <= 1e-6)) {
        {
#line 307
        tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                   307);
#line 307
        (*tmp___6)("glp_set_bfcp: eps_tol = %g; invalid parameter\n", bfcp->eps_tol);
        }
      }
    } else {
      {
#line 307
      tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 307);
#line 307
      (*tmp___6)("glp_set_bfcp: eps_tol = %g; invalid parameter\n", bfcp->eps_tol);
      }
    }
#line 309
    if (bfcp->max_gro < 1.0) {
      {
#line 310
      tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 310);
#line 310
      (*tmp___7)("glp_set_bfcp: max_gro = %g; invalid parameter\n", bfcp->max_gro);
      }
    }
#line 312
    if (1 <= bfcp->nfs_max) {
#line 312
      if (! (bfcp->nfs_max <= 32767)) {
        {
#line 313
        tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                   313);
#line 313
        (*tmp___8)("glp_set_bfcp: nfs_max = %d; invalid parameter\n", bfcp->nfs_max);
        }
      }
    } else {
      {
#line 313
      tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 313);
#line 313
      (*tmp___8)("glp_set_bfcp: nfs_max = %d; invalid parameter\n", bfcp->nfs_max);
      }
    }
#line 315
    if (0.0 < bfcp->upd_tol) {
#line 315
      if (! (bfcp->upd_tol < 1.0)) {
        {
#line 316
        tmp___9 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                   316);
#line 316
        (*tmp___9)("glp_set_bfcp: upd_tol = %g; invalid parameter\n", bfcp->upd_tol);
        }
      }
    } else {
      {
#line 316
      tmp___9 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 316);
#line 316
      (*tmp___9)("glp_set_bfcp: upd_tol = %g; invalid parameter\n", bfcp->upd_tol);
      }
    }
#line 318
    if (1 <= bfcp->nrs_max) {
#line 318
      if (! (bfcp->nrs_max <= 32767)) {
        {
#line 319
        tmp___10 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                    319);
#line 319
        (*tmp___10)("glp_set_bfcp: nrs_max = %d; invalid parameter\n", bfcp->nrs_max);
        }
      }
    } else {
      {
#line 319
      tmp___10 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                  319);
#line 319
      (*tmp___10)("glp_set_bfcp: nrs_max = %d; invalid parameter\n", bfcp->nrs_max);
      }
    }
#line 321
    if (bfcp->rs_size < 0) {
      {
#line 322
      tmp___11 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                  322);
#line 322
      (*tmp___11)("glp_set_bfcp: rs_size = %d; invalid parameter\n", bfcp->nrs_max);
      }
    }
#line 324
    if (bfcp->rs_size == 0) {
#line 325
      bfcp->rs_size = 20 * bfcp->nrs_max;
    }
  }
#line 327
  if ((unsigned long )lp->bfd != (unsigned long )((void *)0)) {
    {
#line 327
    copy_bfcp(lp);
    }
  }
#line 328
  return;
}
}
#line 352 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_get_bhead(glp_prob___0 *lp , int k ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 353
  if (! (lp->m == 0)) {
#line 353
    if (! lp->valid) {
      {
#line 354
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 354);
#line 354
      (*tmp)("glp_get_bhead: basis factorization does not exist\n");
      }
    }
  }
#line 355
  if (1 <= k) {
#line 355
    if (! (k <= lp->m)) {
      {
#line 356
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 356);
#line 356
      (*tmp___0)("glp_get_bhead: k = %d; index out of range\n", k);
      }
    }
  } else {
    {
#line 356
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                               356);
#line 356
    (*tmp___0)("glp_get_bhead: k = %d; index out of range\n", k);
    }
  }
#line 357
  return (*(lp->head + k));
}
}
#line 377 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_get_row_bind(glp_prob___0 *lp , int i ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 378
  if (! (lp->m == 0)) {
#line 378
    if (! lp->valid) {
      {
#line 379
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 379);
#line 379
      (*tmp)("glp_get_row_bind: basis factorization does not exist\n");
      }
    }
  }
#line 381
  if (1 <= i) {
#line 381
    if (! (i <= lp->m)) {
      {
#line 382
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 382);
#line 382
      (*tmp___0)("glp_get_row_bind: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 382
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                               382);
#line 382
    (*tmp___0)("glp_get_row_bind: i = %d; row number out of range\n", i);
    }
  }
#line 384
  return ((*(lp->row + i))->bind);
}
}
#line 404 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_get_col_bind(glp_prob___0 *lp , int j ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 405
  if (! (lp->m == 0)) {
#line 405
    if (! lp->valid) {
      {
#line 406
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 406);
#line 406
      (*tmp)("glp_get_col_bind: basis factorization does not exist\n");
      }
    }
  }
#line 408
  if (1 <= j) {
#line 408
    if (! (j <= lp->n)) {
      {
#line 409
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 409);
#line 409
      (*tmp___0)("glp_get_col_bind: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 409
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                               409);
#line 409
    (*tmp___0)("glp_get_col_bind: j = %d; column number out of range\n", j);
    }
  }
#line 411
  return ((*(lp->col + j))->bind);
}
}
#line 468 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
void glp_ftran(glp_prob___0 *lp , double *x ) 
{ 
  int m ;
  GLPROW **row ;
  GLPCOL **col ;
  int i ;
  int k ;
  xerror_t tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 469
  m = lp->m;
#line 470
  row = lp->row;
#line 471
  col = lp->col;
#line 475
  if (! (m == 0)) {
#line 475
    if (! lp->valid) {
      {
#line 476
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 476);
#line 476
      (*tmp)("glp_ftran: basis factorization does not exist\n");
      }
    }
  }
#line 478
  i = 1;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i <= m)) {
#line 478
      goto while_break;
    }
#line 479
    *(x + i) *= (*(row + i))->rii;
#line 478
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  if (m > 0) {
    {
#line 481
    _glp_bfd_ftran(lp->bfd, x);
    }
  }
#line 483
  i = 1;
  {
#line 483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 483
    if (! (i <= m)) {
#line 483
      goto while_break___0;
    }
#line 484
    k = *(lp->head + i);
#line 485
    if (k <= m) {
#line 486
      *(x + i) /= (*(row + k))->rii;
    } else {
#line 488
      *(x + i) *= (*(col + (k - m)))->sjj;
    }
#line 483
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 490
  return;
}
}
#line 518 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
void glp_btran(glp_prob___0 *lp , double *x ) 
{ 
  int m ;
  GLPROW **row ;
  GLPCOL **col ;
  int i ;
  int k ;
  xerror_t tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 519
  m = lp->m;
#line 520
  row = lp->row;
#line 521
  col = lp->col;
#line 525
  if (! (m == 0)) {
#line 525
    if (! lp->valid) {
      {
#line 526
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 526);
#line 526
      (*tmp)("glp_btran: basis factorization does not exist\n");
      }
    }
  }
#line 528
  i = 1;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i <= m)) {
#line 528
      goto while_break;
    }
#line 529
    k = *(lp->head + i);
#line 530
    if (k <= m) {
#line 531
      *(x + i) /= (*(row + k))->rii;
    } else {
#line 533
      *(x + i) *= (*(col + (k - m)))->sjj;
    }
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (m > 0) {
    {
#line 536
    _glp_bfd_btran(lp->bfd, x);
    }
  }
#line 538
  i = 1;
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 538
    if (! (i <= m)) {
#line 538
      goto while_break___0;
    }
#line 539
    *(x + i) *= (*(row + i))->rii;
#line 538
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 540
  return;
}
}
#line 637 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_eval_tab_row(glp_prob___0 *lp , int k , int *ind , double *val ) 
{ 
  int m ;
  int n ;
  int i ;
  int t ;
  int len ;
  int lll ;
  int *iii ;
  double alfa ;
  double *rho ;
  double *vvv ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 638
  m = lp->m;
#line 639
  n = lp->n;
#line 642
  if (! (m == 0)) {
#line 642
    if (! lp->valid) {
      {
#line 643
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 643);
#line 643
      (*tmp)("glp_eval_tab_row: basis factorization does not exist\n");
      }
    }
  }
#line 645
  if (1 <= k) {
#line 645
    if (! (k <= m + n)) {
      {
#line 646
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 646);
#line 646
      (*tmp___0)("glp_eval_tab_row: k = %d; variable number out of range", k);
      }
    }
  } else {
    {
#line 646
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                               646);
#line 646
    (*tmp___0)("glp_eval_tab_row: k = %d; variable number out of range", k);
    }
  }
#line 649
  if (k <= m) {
    {
#line 650
    i = glp_get_row_bind(lp, k);
    }
  } else {
    {
#line 652
    i = glp_get_col_bind(lp, k - m);
    }
  }
#line 653
  if (i == 0) {
    {
#line 654
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                               654);
#line 654
    (*tmp___1)("glp_eval_tab_row: k = %d; variable must be basic", k);
    }
  }
#line 655
  if (1 <= i) {
#line 655
    if (i <= m) {
#line 655
      tmp___2 = 1;
    } else {
      {
#line 655
      _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                       655);
#line 655
      tmp___2 = 1;
      }
    }
  } else {
    {
#line 655
    _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                     655);
#line 655
    tmp___2 = 1;
    }
  }
  {
#line 657
  tmp___3 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 657
  rho = (double *)tmp___3;
#line 658
  tmp___4 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 658
  iii = (int *)tmp___4;
#line 659
  tmp___5 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 659
  vvv = (double *)tmp___5;
#line 661
  t = 1;
  }
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (t <= m)) {
#line 661
      goto while_break;
    }
#line 661
    *(rho + t) = 0.0;
#line 661
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 662
  *(rho + i) = 1.0;
#line 663
  glp_btran(lp, rho);
#line 665
  len = 0;
#line 666
  k = 1;
  }
  {
#line 666
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 666
    if (! (k <= m + n)) {
#line 666
      goto while_break___0;
    }
#line 667
    if (k <= m) {
      {
#line 669
      tmp___6 = glp_get_row_stat(lp, k);
      }
#line 669
      if (tmp___6 == 1) {
#line 669
        goto __Cont;
      }
#line 671
      alfa = - *(rho + k);
    } else {
      {
#line 676
      tmp___7 = glp_get_col_stat(lp, k - m);
      }
#line 676
      if (tmp___7 == 1) {
#line 676
        goto __Cont;
      }
      {
#line 678
      lll = glp_get_mat_col(lp, k - m, iii, vvv);
#line 679
      alfa = 0.0;
#line 680
      t = 1;
      }
      {
#line 680
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 680
        if (! (t <= lll)) {
#line 680
          goto while_break___1;
        }
#line 680
        alfa += *(rho + *(iii + t)) * *(vvv + t);
#line 680
        t ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 683
    if (alfa != 0.0) {
#line 683
      len ++;
#line 683
      *(ind + len) = k;
#line 683
      *(val + len) = alfa;
    }
    __Cont: /* CIL Label */ 
#line 666
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 685
  if (len <= n) {
#line 685
    tmp___8 = 1;
  } else {
    {
#line 685
    _glp_lib_xassert("len <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                     685);
#line 685
    tmp___8 = 1;
    }
  }
  {
#line 687
  _glp_lib_xfree((void *)rho);
#line 688
  _glp_lib_xfree((void *)iii);
#line 689
  _glp_lib_xfree((void *)vvv);
  }
#line 691
  return (len);
}
}
#line 752 "/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c"
int glp_eval_tab_col(glp_prob___0 *lp , int k , int *ind , double *val ) 
{ 
  int m ;
  int n ;
  int t ;
  int len ;
  int stat ;
  double *col ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 753
  m = lp->m;
#line 754
  n = lp->n;
#line 757
  if (! (m == 0)) {
#line 757
    if (! lp->valid) {
      {
#line 758
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c", 758);
#line 758
      (*tmp)("glp_eval_tab_col: basis factorization does not exist\n");
      }
    }
  }
#line 760
  if (1 <= k) {
#line 760
    if (! (k <= m + n)) {
      {
#line 761
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                                 761);
#line 761
      (*tmp___0)("glp_eval_tab_col: k = %d; variable number out of range", k);
      }
    }
  } else {
    {
#line 761
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                               761);
#line 761
    (*tmp___0)("glp_eval_tab_col: k = %d; variable number out of range", k);
    }
  }
#line 763
  if (k <= m) {
    {
#line 764
    stat = glp_get_row_stat(lp, k);
    }
  } else {
    {
#line 766
    stat = glp_get_col_stat(lp, k - m);
    }
  }
#line 767
  if (stat == 1) {
    {
#line 768
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi12.c",
                               768);
#line 768
    (*tmp___1)("glp_eval_tab_col: k = %d; variable must be non-basic", k);
    }
  }
  {
#line 771
  tmp___2 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 771
  col = (double *)tmp___2;
#line 772
  t = 1;
  }
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 772
    if (! (t <= m)) {
#line 772
      goto while_break;
    }
#line 772
    *(col + t) = 0.0;
#line 772
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  if (k <= m) {
#line 775
    *(col + k) = - 1.0;
  } else {
    {
#line 780
    len = glp_get_mat_col(lp, k - m, ind, val);
#line 781
    t = 1;
    }
    {
#line 781
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 781
      if (! (t <= len)) {
#line 781
        goto while_break___0;
      }
#line 781
      *(col + *(ind + t)) = *(val + t);
#line 781
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 785
  glp_ftran(lp, col);
#line 786
  len = 0;
#line 787
  t = 1;
  }
  {
#line 787
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 787
    if (! (t <= m)) {
#line 787
      goto while_break___1;
    }
#line 788
    if (*(col + t) != 0.0) {
      {
#line 789
      len ++;
#line 790
      *(ind + len) = glp_get_bhead(lp, t);
#line 791
      *(val + len) = *(col + t);
      }
    }
#line 787
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 794
  _glp_lib_xfree((void *)col);
  }
#line 796
  return (len);
}
}
#line 47 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_print_sol(glp_prob *P , char const   *fname ) 
{ 
  XFILE *fp ;
  GLPROW *row ;
  GLPCOL *col ;
  int i ;
  int j ;
  int t ;
  int ae_ind ;
  int re_ind ;
  int ret ;
  double ae_max ;
  double re_max ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  double tmp___19 ;
  double tmp___20 ;
  char const   *tmp___21 ;
  double tmp___22 ;
  char const   *tmp___23 ;
  size_t tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  double tmp___31 ;
  double tmp___32 ;
  char const   *tmp___33 ;
  double tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  char const   *tmp___49 ;
  int tmp___50 ;
  char const   *tmp___51 ;
  int tmp___52 ;
  char const   *tmp___53 ;
  char const   *tmp___54 ;
  char const   *tmp___55 ;
  char const   *tmp___56 ;
  char const   *tmp___57 ;
  int tmp___58 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;

  {
  {
#line 54
  _glp_lib_xprintf("Writing basic solution to `%s\'...\n", fname);
#line 55
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 56
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 57
    tmp = _glp_lib_xerrmsg();
#line 57
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp);
#line 58
    ret = 1;
    }
#line 59
    goto done;
  }
#line 61
  if ((unsigned long )P->name == (unsigned long )((void *)0)) {
#line 61
    tmp___0 = "";
  } else {
#line 61
    tmp___0 = (char const   *)P->name;
  }
  {
#line 61
  _glp_lib_xfprintf(fp, "%-12s%s\n", "Problem:", tmp___0);
#line 63
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Rows:", P->m);
#line 64
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Columns:", P->n);
#line 65
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Non-zeros:", P->nnz);
#line 66
  t = glp_get_status(P);
  }
#line 67
  if (t == 5) {
#line 67
    tmp___6 = "OPTIMAL";
  } else {
#line 67
    if (t == 2) {
#line 67
      tmp___5 = "FEASIBLE";
    } else {
#line 67
      if (t == 3) {
#line 67
        tmp___4 = "INFEASIBLE (INTERMEDIATE)";
      } else {
#line 67
        if (t == 4) {
#line 67
          tmp___3 = "INFEASIBLE (FINAL)";
        } else {
#line 67
          if (t == 6) {
#line 67
            tmp___2 = "UNBOUNDED";
          } else {
#line 67
            if (t == 1) {
#line 67
              tmp___1 = "UNDEFINED";
            } else {
#line 67
              tmp___1 = "???";
            }
#line 67
            tmp___2 = tmp___1;
          }
#line 67
          tmp___3 = tmp___2;
        }
#line 67
        tmp___4 = tmp___3;
      }
#line 67
      tmp___5 = tmp___4;
    }
#line 67
    tmp___6 = tmp___5;
  }
  {
#line 67
  _glp_lib_xfprintf(fp, "%-12s%s\n", "Status:", tmp___6);
  }
#line 74
  if (P->dir == 1) {
#line 74
    tmp___8 = "MINimum";
  } else {
#line 74
    if (P->dir == 2) {
#line 74
      tmp___7 = "MAXimum";
    } else {
#line 74
      tmp___7 = "???";
    }
#line 74
    tmp___8 = tmp___7;
  }
#line 74
  if ((unsigned long )P->obj == (unsigned long )((void *)0)) {
#line 74
    tmp___9 = "";
  } else {
#line 74
    tmp___9 = " = ";
  }
#line 74
  if ((unsigned long )P->obj == (unsigned long )((void *)0)) {
#line 74
    tmp___10 = "";
  } else {
#line 74
    tmp___10 = (char const   *)P->obj;
  }
  {
#line 74
  _glp_lib_xfprintf(fp, "%-12s%s%s%.10g (%s)\n", "Objective:", tmp___10, tmp___9,
                    P->obj_val, tmp___8);
#line 79
  _glp_lib_xfprintf(fp, "\n");
#line 80
  _glp_lib_xfprintf(fp, "   No.   Row name   St   Activity     Lower bound   Upper bound    Marginal\n");
#line 82
  _glp_lib_xfprintf(fp, "------ ------------ -- ------------- ------------- ------------- -------------\n");
#line 84
  i = 1;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i <= P->m)) {
#line 84
      goto while_break;
    }
    {
#line 85
    row = *(P->row + i);
#line 86
    _glp_lib_xfprintf(fp, "%6d ", i);
    }
#line 87
    if ((unsigned long )row->name == (unsigned long )((void *)0)) {
#line 87
      goto _L;
    } else {
      {
#line 87
      tmp___12 = strlen((char const   *)row->name);
      }
#line 87
      if (tmp___12 <= 12U) {
        _L: /* CIL Label */ 
#line 88
        if ((unsigned long )row->name == (unsigned long )((void *)0)) {
#line 88
          tmp___11 = "";
        } else {
#line 88
          tmp___11 = (char const   *)row->name;
        }
        {
#line 88
        _glp_lib_xfprintf(fp, "%-12s ", tmp___11);
        }
      } else {
        {
#line 90
        _glp_lib_xfprintf(fp, "%s\n%20s", row->name, "");
        }
      }
    }
#line 91
    if (row->stat == 1) {
#line 91
      tmp___17 = "B ";
    } else {
#line 91
      if (row->stat == 2) {
#line 91
        tmp___16 = "NL";
      } else {
#line 91
        if (row->stat == 3) {
#line 91
          tmp___15 = "NU";
        } else {
#line 91
          if (row->stat == 4) {
#line 91
            tmp___14 = "NF";
          } else {
#line 91
            if (row->stat == 5) {
#line 91
              tmp___13 = "NS";
            } else {
#line 91
              tmp___13 = "??";
            }
#line 91
            tmp___14 = tmp___13;
          }
#line 91
          tmp___15 = tmp___14;
        }
#line 91
        tmp___16 = tmp___15;
      }
#line 91
      tmp___17 = tmp___16;
    }
    {
#line 91
    _glp_lib_xfprintf(fp, "%s ", tmp___17);
#line 97
    tmp___20 = fabs(row->prim);
    }
#line 97
    if (tmp___20 <= 1e-9) {
#line 97
      tmp___19 = 0.0;
    } else {
#line 97
      tmp___19 = row->prim;
    }
    {
#line 97
    _glp_lib_xfprintf(fp, "%13.6g ", tmp___19);
    }
#line 99
    if (row->type == 2) {
      {
#line 101
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else
#line 99
    if (row->type == 4) {
      {
#line 101
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else
#line 99
    if (row->type == 5) {
      {
#line 101
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else {
      {
#line 103
      _glp_lib_xfprintf(fp, "%13s ", "");
      }
    }
#line 104
    if (row->type == 3) {
      {
#line 105
      _glp_lib_xfprintf(fp, "%13.6g ", row->ub);
      }
    } else
#line 104
    if (row->type == 4) {
      {
#line 105
      _glp_lib_xfprintf(fp, "%13.6g ", row->ub);
      }
    } else {
#line 107
      if (row->type == 5) {
#line 107
        tmp___21 = "=";
      } else {
#line 107
        tmp___21 = "";
      }
      {
#line 107
      _glp_lib_xfprintf(fp, "%13s ", tmp___21);
      }
    }
#line 108
    if (row->stat != 1) {
      {
#line 109
      tmp___22 = fabs(row->dual);
      }
#line 109
      if (tmp___22 <= 1e-9) {
        {
#line 110
        _glp_lib_xfprintf(fp, "%13s", "< eps");
        }
      } else {
        {
#line 112
        _glp_lib_xfprintf(fp, "%13.6g ", row->dual);
        }
      }
    }
    {
#line 114
    _glp_lib_xfprintf(fp, "\n");
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  _glp_lib_xfprintf(fp, "\n");
#line 117
  _glp_lib_xfprintf(fp, "   No. Column name  St   Activity     Lower bound   Upper bound    Marginal\n");
#line 119
  _glp_lib_xfprintf(fp, "------ ------------ -- ------------- ------------- ------------- -------------\n");
#line 121
  j = 1;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (j <= P->n)) {
#line 121
      goto while_break___0;
    }
    {
#line 122
    col = *(P->col + j);
#line 123
    _glp_lib_xfprintf(fp, "%6d ", j);
    }
#line 124
    if ((unsigned long )col->name == (unsigned long )((void *)0)) {
#line 124
      goto _L___0;
    } else {
      {
#line 124
      tmp___24 = strlen((char const   *)col->name);
      }
#line 124
      if (tmp___24 <= 12U) {
        _L___0: /* CIL Label */ 
#line 125
        if ((unsigned long )col->name == (unsigned long )((void *)0)) {
#line 125
          tmp___23 = "";
        } else {
#line 125
          tmp___23 = (char const   *)col->name;
        }
        {
#line 125
        _glp_lib_xfprintf(fp, "%-12s ", tmp___23);
        }
      } else {
        {
#line 127
        _glp_lib_xfprintf(fp, "%s\n%20s", col->name, "");
        }
      }
    }
#line 128
    if (col->stat == 1) {
#line 128
      tmp___29 = "B ";
    } else {
#line 128
      if (col->stat == 2) {
#line 128
        tmp___28 = "NL";
      } else {
#line 128
        if (col->stat == 3) {
#line 128
          tmp___27 = "NU";
        } else {
#line 128
          if (col->stat == 4) {
#line 128
            tmp___26 = "NF";
          } else {
#line 128
            if (col->stat == 5) {
#line 128
              tmp___25 = "NS";
            } else {
#line 128
              tmp___25 = "??";
            }
#line 128
            tmp___26 = tmp___25;
          }
#line 128
          tmp___27 = tmp___26;
        }
#line 128
        tmp___28 = tmp___27;
      }
#line 128
      tmp___29 = tmp___28;
    }
    {
#line 128
    _glp_lib_xfprintf(fp, "%s ", tmp___29);
#line 134
    tmp___32 = fabs(col->prim);
    }
#line 134
    if (tmp___32 <= 1e-9) {
#line 134
      tmp___31 = 0.0;
    } else {
#line 134
      tmp___31 = col->prim;
    }
    {
#line 134
    _glp_lib_xfprintf(fp, "%13.6g ", tmp___31);
    }
#line 136
    if (col->type == 2) {
      {
#line 138
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else
#line 136
    if (col->type == 4) {
      {
#line 138
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else
#line 136
    if (col->type == 5) {
      {
#line 138
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else {
      {
#line 140
      _glp_lib_xfprintf(fp, "%13s ", "");
      }
    }
#line 141
    if (col->type == 3) {
      {
#line 142
      _glp_lib_xfprintf(fp, "%13.6g ", col->ub);
      }
    } else
#line 141
    if (col->type == 4) {
      {
#line 142
      _glp_lib_xfprintf(fp, "%13.6g ", col->ub);
      }
    } else {
#line 144
      if (col->type == 5) {
#line 144
        tmp___33 = "=";
      } else {
#line 144
        tmp___33 = "";
      }
      {
#line 144
      _glp_lib_xfprintf(fp, "%13s ", tmp___33);
      }
    }
#line 145
    if (col->stat != 1) {
      {
#line 146
      tmp___34 = fabs(col->dual);
      }
#line 146
      if (tmp___34 <= 1e-9) {
        {
#line 147
        _glp_lib_xfprintf(fp, "%13s", "< eps");
        }
      } else {
        {
#line 149
        _glp_lib_xfprintf(fp, "%13.6g ", col->dual);
        }
      }
    }
    {
#line 151
    _glp_lib_xfprintf(fp, "\n");
#line 121
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 153
  _glp_lib_xfprintf(fp, "\n");
#line 154
  _glp_lib_xfprintf(fp, "Karush-Kuhn-Tucker optimality conditions:\n");
#line 155
  _glp_lib_xfprintf(fp, "\n");
#line 156
  _glp_check_kkt(P, 1, 1, & ae_max, & ae_ind, & re_max, & re_ind);
#line 158
  _glp_lib_xfprintf(fp, "KKT.PE: max.abs.err = %.2e on row %d\n", ae_max, ae_ind);
#line 160
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on row %d\n", re_max, re_ind);
  }
#line 162
  if (re_max <= 1e-9) {
#line 162
    tmp___37 = "High quality";
  } else {
#line 162
    if (re_max <= 1e-6) {
#line 162
      tmp___36 = "Medium quality";
    } else {
#line 162
      if (re_max <= 1e-3) {
#line 162
        tmp___35 = "Low quality";
      } else {
#line 162
        tmp___35 = "PRIMAL SOLUTION IS WRONG";
      }
#line 162
      tmp___36 = tmp___35;
    }
#line 162
    tmp___37 = tmp___36;
  }
  {
#line 162
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___37);
#line 166
  _glp_lib_xfprintf(fp, "\n");
#line 167
  _glp_check_kkt(P, 1, 2, & ae_max, & ae_ind, & re_max, & re_ind);
  }
#line 169
  if (ae_ind <= P->m) {
#line 169
    tmp___38 = ae_ind;
  } else {
#line 169
    tmp___38 = ae_ind - P->m;
  }
#line 169
  if (ae_ind <= P->m) {
#line 169
    tmp___39 = "row";
  } else {
#line 169
    tmp___39 = "column";
  }
  {
#line 169
  _glp_lib_xfprintf(fp, "KKT.PB: max.abs.err = %.2e on %s %d\n", ae_max, tmp___39,
                    tmp___38);
  }
#line 172
  if (re_ind <= P->m) {
#line 172
    tmp___40 = re_ind;
  } else {
#line 172
    tmp___40 = re_ind - P->m;
  }
#line 172
  if (re_ind <= P->m) {
#line 172
    tmp___41 = "row";
  } else {
#line 172
    tmp___41 = "column";
  }
  {
#line 172
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on %s %d\n", re_max, tmp___41,
                    tmp___40);
  }
#line 175
  if (re_max <= 1e-9) {
#line 175
    tmp___44 = "High quality";
  } else {
#line 175
    if (re_max <= 1e-6) {
#line 175
      tmp___43 = "Medium quality";
    } else {
#line 175
      if (re_max <= 1e-3) {
#line 175
        tmp___42 = "Low quality";
      } else {
#line 175
        tmp___42 = "PRIMAL SOLUTION IS INFEASIBLE";
      }
#line 175
      tmp___43 = tmp___42;
    }
#line 175
    tmp___44 = tmp___43;
  }
  {
#line 175
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___44);
#line 180
  _glp_lib_xfprintf(fp, "\n");
#line 181
  _glp_check_kkt(P, 1, 3, & ae_max, & ae_ind, & re_max, & re_ind);
  }
#line 183
  if (ae_ind == 0) {
#line 183
    tmp___45 = 0;
  } else {
#line 183
    tmp___45 = ae_ind - P->m;
  }
  {
#line 183
  _glp_lib_xfprintf(fp, "KKT.DE: max.abs.err = %.2e on column %d\n", ae_max, tmp___45);
  }
#line 185
  if (re_ind == 0) {
#line 185
    tmp___46 = 0;
  } else {
#line 185
    tmp___46 = re_ind - P->m;
  }
  {
#line 185
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on column %d\n", re_max, tmp___46);
  }
#line 187
  if (re_max <= 1e-9) {
#line 187
    tmp___49 = "High quality";
  } else {
#line 187
    if (re_max <= 1e-6) {
#line 187
      tmp___48 = "Medium quality";
    } else {
#line 187
      if (re_max <= 1e-3) {
#line 187
        tmp___47 = "Low quality";
      } else {
#line 187
        tmp___47 = "DUAL SOLUTION IS WRONG";
      }
#line 187
      tmp___48 = tmp___47;
    }
#line 187
    tmp___49 = tmp___48;
  }
  {
#line 187
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___49);
#line 191
  _glp_lib_xfprintf(fp, "\n");
#line 192
  _glp_check_kkt(P, 1, 4, & ae_max, & ae_ind, & re_max, & re_ind);
  }
#line 194
  if (ae_ind <= P->m) {
#line 194
    tmp___50 = ae_ind;
  } else {
#line 194
    tmp___50 = ae_ind - P->m;
  }
#line 194
  if (ae_ind <= P->m) {
#line 194
    tmp___51 = "row";
  } else {
#line 194
    tmp___51 = "column";
  }
  {
#line 194
  _glp_lib_xfprintf(fp, "KKT.DB: max.abs.err = %.2e on %s %d\n", ae_max, tmp___51,
                    tmp___50);
  }
#line 197
  if (re_ind <= P->m) {
#line 197
    tmp___52 = re_ind;
  } else {
#line 197
    tmp___52 = re_ind - P->m;
  }
#line 197
  if (re_ind <= P->m) {
#line 197
    tmp___53 = "row";
  } else {
#line 197
    tmp___53 = "column";
  }
  {
#line 197
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on %s %d\n", re_max, tmp___53,
                    tmp___52);
  }
#line 200
  if (re_max <= 1e-9) {
#line 200
    tmp___56 = "High quality";
  } else {
#line 200
    if (re_max <= 1e-6) {
#line 200
      tmp___55 = "Medium quality";
    } else {
#line 200
      if (re_max <= 1e-3) {
#line 200
        tmp___54 = "Low quality";
      } else {
#line 200
        tmp___54 = "DUAL SOLUTION IS INFEASIBLE";
      }
#line 200
      tmp___55 = tmp___54;
    }
#line 200
    tmp___56 = tmp___55;
  }
  {
#line 200
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___56);
#line 205
  _glp_lib_xfprintf(fp, "\n");
#line 206
  _glp_lib_xfprintf(fp, "End of output\n");
#line 207
  _glp_lib_xfflush(fp);
#line 208
  tmp___58 = _glp_lib_xferror(fp);
  }
#line 208
  if (tmp___58) {
    {
#line 209
    tmp___57 = _glp_lib_xerrmsg();
#line 209
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___57);
#line 210
    ret = 1;
    }
#line 211
    goto done;
  }
#line 213
  ret = 0;
  done: 
#line 214
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 214
    _glp_lib_xfclose(fp);
    }
  }
#line 215
  return (ret);
}
}
#line 238 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_read_sol(glp_prob *lp , char const   *fname ) 
{ 
  _glp_data___0 *pds ;
  jmp_buf jump ;
  int i ;
  int j ;
  int k ;
  int ret ;
  int tmp ;
  GLPROW *row ;
  GLPCOL *col ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 241
  ret = 0;
#line 242
  _glp_lib_xprintf("Reading basic solution from `%s\'...\n", fname);
#line 243
  pds = _glp_sds_open(fname);
  }
#line 244
  if ((unsigned long )pds == (unsigned long )((void *)0)) {
#line 245
    ret = 1;
#line 246
    goto done;
  }
  {
#line 248
  tmp = _setjmp((struct __jmp_buf_tag *)(jump));
  }
#line 248
  if (tmp) {
#line 249
    ret = 1;
#line 250
    goto done;
  }
  {
#line 252
  _glp_sds_jump(pds, (void *)(jump));
#line 254
  k = _glp_sds_int(pds);
  }
#line 255
  if (k != lp->m) {
    {
#line 256
    _glp_sds_error(pds, "wrong number of rows\n");
    }
  }
  {
#line 257
  k = _glp_sds_int(pds);
  }
#line 258
  if (k != lp->n) {
    {
#line 259
    _glp_sds_error(pds, "wrong number of columns\n");
    }
  }
  {
#line 261
  k = _glp_sds_int(pds);
  }
#line 262
  if (! (k == 1)) {
#line 262
    if (! (k == 2)) {
#line 262
      if (! (k == 3)) {
#line 262
        if (! (k == 4)) {
          {
#line 264
          _glp_sds_error(pds, "invalid primal status\n");
          }
        }
      }
    }
  }
  {
#line 265
  lp->pbs_stat = k;
#line 266
  k = _glp_sds_int(pds);
  }
#line 267
  if (! (k == 1)) {
#line 267
    if (! (k == 2)) {
#line 267
      if (! (k == 3)) {
#line 267
        if (! (k == 4)) {
          {
#line 269
          _glp_sds_error(pds, "invalid dual status\n");
          }
        }
      }
    }
  }
  {
#line 270
  lp->dbs_stat = k;
#line 271
  lp->obj_val = _glp_sds_num(pds);
#line 273
  i = 1;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i <= lp->m)) {
#line 273
      goto while_break;
    }
    {
#line 274
    row = *(lp->row + i);
#line 276
    k = _glp_sds_int(pds);
    }
#line 277
    if (! (k == 1)) {
#line 277
      if (! (k == 2)) {
#line 277
        if (! (k == 3)) {
#line 277
          if (! (k == 4)) {
#line 277
            if (! (k == 5)) {
              {
#line 279
              _glp_sds_error(pds, "invalid row status\n");
              }
            }
          }
        }
      }
    }
    {
#line 280
    glp_set_row_stat(lp, i, k);
#line 281
    row->prim = _glp_sds_num(pds);
#line 282
    row->dual = _glp_sds_num(pds);
#line 273
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  j = 1;
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! (j <= lp->n)) {
#line 285
      goto while_break___0;
    }
    {
#line 286
    col = *(lp->col + j);
#line 288
    k = _glp_sds_int(pds);
    }
#line 289
    if (! (k == 1)) {
#line 289
      if (! (k == 2)) {
#line 289
        if (! (k == 3)) {
#line 289
          if (! (k == 4)) {
#line 289
            if (! (k == 5)) {
              {
#line 291
              _glp_sds_error(pds, "invalid column status\n");
              }
            }
          }
        }
      }
    }
    {
#line 292
    glp_set_col_stat(lp, j, k);
#line 293
    col->prim = _glp_sds_num(pds);
#line 294
    col->dual = _glp_sds_num(pds);
#line 285
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 296
  tmp___0 = _glp_sds_line(pds);
#line 296
  _glp_lib_xprintf("%d lines were read\n", tmp___0);
  }
  done: 
#line 297
  if (ret) {
#line 297
    tmp___1 = 1;
#line 297
    lp->dbs_stat = tmp___1;
#line 297
    lp->pbs_stat = tmp___1;
  }
#line 298
  if ((unsigned long )pds != (unsigned long )((void *)0)) {
    {
#line 298
    _glp_sds_close(pds);
    }
  }
#line 299
  return (ret);
}
}
#line 352 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_write_sol(glp_prob *lp , char const   *fname ) 
{ 
  XFILE *fp ;
  int i ;
  int j ;
  int ret ;
  char const   *tmp ;
  GLPROW *row ;
  GLPCOL *col ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 354
  ret = 0;
#line 355
  _glp_lib_xprintf("Writing basic solution to `%s\'...\n", fname);
#line 356
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 357
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 358
    tmp = _glp_lib_xerrmsg();
#line 358
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp);
#line 360
    ret = 1;
    }
#line 361
    goto done;
  }
  {
#line 364
  _glp_lib_xfprintf(fp, "%d %d\n", lp->m, lp->n);
#line 366
  _glp_lib_xfprintf(fp, "%d %d %.*g\n", lp->pbs_stat, lp->dbs_stat, 15, lp->obj_val);
#line 369
  i = 1;
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (i <= lp->m)) {
#line 369
      goto while_break;
    }
    {
#line 370
    row = *(lp->row + i);
#line 372
    _glp_lib_xfprintf(fp, "%d %.*g %.*g\n", row->stat, 15, row->prim, 15, row->dual);
#line 369
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  j = 1;
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! (j <= lp->n)) {
#line 376
      goto while_break___0;
    }
    {
#line 377
    col = *(lp->col + j);
#line 379
    _glp_lib_xfprintf(fp, "%d %.*g %.*g\n", col->stat, 15, col->prim, 15, col->dual);
#line 376
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 382
  _glp_lib_xfflush(fp);
#line 383
  tmp___1 = _glp_lib_xferror(fp);
  }
#line 383
  if (tmp___1) {
    {
#line 384
    tmp___0 = _glp_lib_xerrmsg();
#line 384
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___0);
#line 385
    ret = 1;
    }
#line 386
    goto done;
  }
  {
#line 388
  _glp_lib_xprintf("%d lines were written\n", (2 + lp->m) + lp->n);
  }
  done: 
#line 389
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 389
    _glp_lib_xfclose(fp);
    }
  }
#line 390
  return (ret);
}
}
#line 395 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_print_ipt(glp_prob *P , char const   *fname ) 
{ 
  XFILE *fp ;
  GLPROW *row ;
  GLPCOL *col ;
  int i ;
  int j ;
  int t ;
  int ae_ind ;
  int re_ind ;
  int ret ;
  double ae_max ;
  double re_max ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  double tmp___12 ;
  double tmp___13 ;
  char const   *tmp___14 ;
  double tmp___15 ;
  char const   *tmp___16 ;
  size_t tmp___17 ;
  double tmp___19 ;
  double tmp___20 ;
  char const   *tmp___21 ;
  double tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char const   *tmp___45 ;
  int tmp___46 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;

  {
  {
#line 402
  _glp_lib_xprintf("Writing interior-point solution to `%s\'...\n", fname);
#line 403
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 404
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 405
    tmp = _glp_lib_xerrmsg();
#line 405
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp);
#line 406
    ret = 1;
    }
#line 407
    goto done;
  }
#line 409
  if ((unsigned long )P->name == (unsigned long )((void *)0)) {
#line 409
    tmp___0 = "";
  } else {
#line 409
    tmp___0 = (char const   *)P->name;
  }
  {
#line 409
  _glp_lib_xfprintf(fp, "%-12s%s\n", "Problem:", tmp___0);
#line 411
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Rows:", P->m);
#line 412
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Columns:", P->n);
#line 413
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Non-zeros:", P->nnz);
#line 414
  t = glp_ipt_status(P);
  }
#line 415
  if (t == 5) {
#line 415
    tmp___4 = "OPTIMAL";
  } else {
#line 415
    if (t == 1) {
#line 415
      tmp___3 = "UNDEFINED";
    } else {
#line 415
      if (t == 3) {
#line 415
        tmp___2 = "INFEASIBLE (INTERMEDIATE)";
      } else {
#line 415
        if (t == 4) {
#line 415
          tmp___1 = "INFEASIBLE (FINAL)";
        } else {
#line 415
          tmp___1 = "???";
        }
#line 415
        tmp___2 = tmp___1;
      }
#line 415
      tmp___3 = tmp___2;
    }
#line 415
    tmp___4 = tmp___3;
  }
  {
#line 415
  _glp_lib_xfprintf(fp, "%-12s%s\n", "Status:", tmp___4);
  }
#line 420
  if (P->dir == 1) {
#line 420
    tmp___6 = "MINimum";
  } else {
#line 420
    if (P->dir == 2) {
#line 420
      tmp___5 = "MAXimum";
    } else {
#line 420
      tmp___5 = "???";
    }
#line 420
    tmp___6 = tmp___5;
  }
#line 420
  if ((unsigned long )P->obj == (unsigned long )((void *)0)) {
#line 420
    tmp___7 = "";
  } else {
#line 420
    tmp___7 = " = ";
  }
#line 420
  if ((unsigned long )P->obj == (unsigned long )((void *)0)) {
#line 420
    tmp___8 = "";
  } else {
#line 420
    tmp___8 = (char const   *)P->obj;
  }
  {
#line 420
  _glp_lib_xfprintf(fp, "%-12s%s%s%.10g (%s)\n", "Objective:", tmp___8, tmp___7, P->ipt_obj,
                    tmp___6);
#line 425
  _glp_lib_xfprintf(fp, "\n");
#line 426
  _glp_lib_xfprintf(fp, "   No.   Row name        Activity     Lower bound   Upper bound    Marginal\n");
#line 428
  _glp_lib_xfprintf(fp, "------ ------------    ------------- ------------- ------------- -------------\n");
#line 430
  i = 1;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i <= P->m)) {
#line 430
      goto while_break;
    }
    {
#line 431
    row = *(P->row + i);
#line 432
    _glp_lib_xfprintf(fp, "%6d ", i);
    }
#line 433
    if ((unsigned long )row->name == (unsigned long )((void *)0)) {
#line 433
      goto _L;
    } else {
      {
#line 433
      tmp___10 = strlen((char const   *)row->name);
      }
#line 433
      if (tmp___10 <= 12U) {
        _L: /* CIL Label */ 
#line 434
        if ((unsigned long )row->name == (unsigned long )((void *)0)) {
#line 434
          tmp___9 = "";
        } else {
#line 434
          tmp___9 = (char const   *)row->name;
        }
        {
#line 434
        _glp_lib_xfprintf(fp, "%-12s ", tmp___9);
        }
      } else {
        {
#line 436
        _glp_lib_xfprintf(fp, "%s\n%20s", row->name, "");
        }
      }
    }
    {
#line 437
    _glp_lib_xfprintf(fp, "%3s", "");
#line 438
    tmp___13 = fabs(row->pval);
    }
#line 438
    if (tmp___13 <= 1e-9) {
#line 438
      tmp___12 = 0.0;
    } else {
#line 438
      tmp___12 = row->pval;
    }
    {
#line 438
    _glp_lib_xfprintf(fp, "%13.6g ", tmp___12);
    }
#line 440
    if (row->type == 2) {
      {
#line 442
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else
#line 440
    if (row->type == 4) {
      {
#line 442
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else
#line 440
    if (row->type == 5) {
      {
#line 442
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else {
      {
#line 444
      _glp_lib_xfprintf(fp, "%13s ", "");
      }
    }
#line 445
    if (row->type == 3) {
      {
#line 446
      _glp_lib_xfprintf(fp, "%13.6g ", row->ub);
      }
    } else
#line 445
    if (row->type == 4) {
      {
#line 446
      _glp_lib_xfprintf(fp, "%13.6g ", row->ub);
      }
    } else {
#line 448
      if (row->type == 5) {
#line 448
        tmp___14 = "=";
      } else {
#line 448
        tmp___14 = "";
      }
      {
#line 448
      _glp_lib_xfprintf(fp, "%13s ", tmp___14);
      }
    }
    {
#line 449
    tmp___15 = fabs(row->dval);
    }
#line 449
    if (tmp___15 <= 1e-9) {
      {
#line 450
      _glp_lib_xfprintf(fp, "%13s", "< eps");
      }
    } else {
      {
#line 452
      _glp_lib_xfprintf(fp, "%13.6g ", row->dval);
      }
    }
    {
#line 453
    _glp_lib_xfprintf(fp, "\n");
#line 430
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 455
  _glp_lib_xfprintf(fp, "\n");
#line 456
  _glp_lib_xfprintf(fp, "   No. Column name       Activity     Lower bound   Upper bound    Marginal\n");
#line 458
  _glp_lib_xfprintf(fp, "------ ------------    ------------- ------------- ------------- -------------\n");
#line 460
  j = 1;
  }
  {
#line 460
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 460
    if (! (j <= P->n)) {
#line 460
      goto while_break___0;
    }
    {
#line 461
    col = *(P->col + j);
#line 462
    _glp_lib_xfprintf(fp, "%6d ", j);
    }
#line 463
    if ((unsigned long )col->name == (unsigned long )((void *)0)) {
#line 463
      goto _L___0;
    } else {
      {
#line 463
      tmp___17 = strlen((char const   *)col->name);
      }
#line 463
      if (tmp___17 <= 12U) {
        _L___0: /* CIL Label */ 
#line 464
        if ((unsigned long )col->name == (unsigned long )((void *)0)) {
#line 464
          tmp___16 = "";
        } else {
#line 464
          tmp___16 = (char const   *)col->name;
        }
        {
#line 464
        _glp_lib_xfprintf(fp, "%-12s ", tmp___16);
        }
      } else {
        {
#line 466
        _glp_lib_xfprintf(fp, "%s\n%20s", col->name, "");
        }
      }
    }
    {
#line 467
    _glp_lib_xfprintf(fp, "%3s", "");
#line 468
    tmp___20 = fabs(col->pval);
    }
#line 468
    if (tmp___20 <= 1e-9) {
#line 468
      tmp___19 = 0.0;
    } else {
#line 468
      tmp___19 = col->pval;
    }
    {
#line 468
    _glp_lib_xfprintf(fp, "%13.6g ", tmp___19);
    }
#line 470
    if (col->type == 2) {
      {
#line 472
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else
#line 470
    if (col->type == 4) {
      {
#line 472
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else
#line 470
    if (col->type == 5) {
      {
#line 472
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else {
      {
#line 474
      _glp_lib_xfprintf(fp, "%13s ", "");
      }
    }
#line 475
    if (col->type == 3) {
      {
#line 476
      _glp_lib_xfprintf(fp, "%13.6g ", col->ub);
      }
    } else
#line 475
    if (col->type == 4) {
      {
#line 476
      _glp_lib_xfprintf(fp, "%13.6g ", col->ub);
      }
    } else {
#line 478
      if (col->type == 5) {
#line 478
        tmp___21 = "=";
      } else {
#line 478
        tmp___21 = "";
      }
      {
#line 478
      _glp_lib_xfprintf(fp, "%13s ", tmp___21);
      }
    }
    {
#line 479
    tmp___22 = fabs(col->dval);
    }
#line 479
    if (tmp___22 <= 1e-9) {
      {
#line 480
      _glp_lib_xfprintf(fp, "%13s", "< eps");
      }
    } else {
      {
#line 482
      _glp_lib_xfprintf(fp, "%13.6g ", col->dval);
      }
    }
    {
#line 483
    _glp_lib_xfprintf(fp, "\n");
#line 460
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 485
  _glp_lib_xfprintf(fp, "\n");
#line 486
  _glp_lib_xfprintf(fp, "Karush-Kuhn-Tucker optimality conditions:\n");
#line 487
  _glp_lib_xfprintf(fp, "\n");
#line 488
  _glp_check_kkt(P, 2, 1, & ae_max, & ae_ind, & re_max, & re_ind);
#line 490
  _glp_lib_xfprintf(fp, "KKT.PE: max.abs.err = %.2e on row %d\n", ae_max, ae_ind);
#line 492
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on row %d\n", re_max, re_ind);
  }
#line 494
  if (re_max <= 1e-9) {
#line 494
    tmp___25 = "High quality";
  } else {
#line 494
    if (re_max <= 1e-6) {
#line 494
      tmp___24 = "Medium quality";
    } else {
#line 494
      if (re_max <= 1e-3) {
#line 494
        tmp___23 = "Low quality";
      } else {
#line 494
        tmp___23 = "PRIMAL SOLUTION IS WRONG";
      }
#line 494
      tmp___24 = tmp___23;
    }
#line 494
    tmp___25 = tmp___24;
  }
  {
#line 494
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___25);
#line 498
  _glp_lib_xfprintf(fp, "\n");
#line 499
  _glp_check_kkt(P, 2, 2, & ae_max, & ae_ind, & re_max, & re_ind);
  }
#line 501
  if (ae_ind <= P->m) {
#line 501
    tmp___26 = ae_ind;
  } else {
#line 501
    tmp___26 = ae_ind - P->m;
  }
#line 501
  if (ae_ind <= P->m) {
#line 501
    tmp___27 = "row";
  } else {
#line 501
    tmp___27 = "column";
  }
  {
#line 501
  _glp_lib_xfprintf(fp, "KKT.PB: max.abs.err = %.2e on %s %d\n", ae_max, tmp___27,
                    tmp___26);
  }
#line 504
  if (re_ind <= P->m) {
#line 504
    tmp___28 = re_ind;
  } else {
#line 504
    tmp___28 = re_ind - P->m;
  }
#line 504
  if (re_ind <= P->m) {
#line 504
    tmp___29 = "row";
  } else {
#line 504
    tmp___29 = "column";
  }
  {
#line 504
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on %s %d\n", re_max, tmp___29,
                    tmp___28);
  }
#line 507
  if (re_max <= 1e-9) {
#line 507
    tmp___32 = "High quality";
  } else {
#line 507
    if (re_max <= 1e-6) {
#line 507
      tmp___31 = "Medium quality";
    } else {
#line 507
      if (re_max <= 1e-3) {
#line 507
        tmp___30 = "Low quality";
      } else {
#line 507
        tmp___30 = "PRIMAL SOLUTION IS INFEASIBLE";
      }
#line 507
      tmp___31 = tmp___30;
    }
#line 507
    tmp___32 = tmp___31;
  }
  {
#line 507
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___32);
#line 512
  _glp_lib_xfprintf(fp, "\n");
#line 513
  _glp_check_kkt(P, 2, 3, & ae_max, & ae_ind, & re_max, & re_ind);
  }
#line 515
  if (ae_ind == 0) {
#line 515
    tmp___33 = 0;
  } else {
#line 515
    tmp___33 = ae_ind - P->m;
  }
  {
#line 515
  _glp_lib_xfprintf(fp, "KKT.DE: max.abs.err = %.2e on column %d\n", ae_max, tmp___33);
  }
#line 517
  if (re_ind == 0) {
#line 517
    tmp___34 = 0;
  } else {
#line 517
    tmp___34 = re_ind - P->m;
  }
  {
#line 517
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on column %d\n", re_max, tmp___34);
  }
#line 519
  if (re_max <= 1e-9) {
#line 519
    tmp___37 = "High quality";
  } else {
#line 519
    if (re_max <= 1e-6) {
#line 519
      tmp___36 = "Medium quality";
    } else {
#line 519
      if (re_max <= 1e-3) {
#line 519
        tmp___35 = "Low quality";
      } else {
#line 519
        tmp___35 = "DUAL SOLUTION IS WRONG";
      }
#line 519
      tmp___36 = tmp___35;
    }
#line 519
    tmp___37 = tmp___36;
  }
  {
#line 519
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___37);
#line 523
  _glp_lib_xfprintf(fp, "\n");
#line 524
  _glp_check_kkt(P, 2, 4, & ae_max, & ae_ind, & re_max, & re_ind);
  }
#line 526
  if (ae_ind <= P->m) {
#line 526
    tmp___38 = ae_ind;
  } else {
#line 526
    tmp___38 = ae_ind - P->m;
  }
#line 526
  if (ae_ind <= P->m) {
#line 526
    tmp___39 = "row";
  } else {
#line 526
    tmp___39 = "column";
  }
  {
#line 526
  _glp_lib_xfprintf(fp, "KKT.DB: max.abs.err = %.2e on %s %d\n", ae_max, tmp___39,
                    tmp___38);
  }
#line 529
  if (re_ind <= P->m) {
#line 529
    tmp___40 = re_ind;
  } else {
#line 529
    tmp___40 = re_ind - P->m;
  }
#line 529
  if (re_ind <= P->m) {
#line 529
    tmp___41 = "row";
  } else {
#line 529
    tmp___41 = "column";
  }
  {
#line 529
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on %s %d\n", re_max, tmp___41,
                    tmp___40);
  }
#line 532
  if (re_max <= 1e-9) {
#line 532
    tmp___44 = "High quality";
  } else {
#line 532
    if (re_max <= 1e-6) {
#line 532
      tmp___43 = "Medium quality";
    } else {
#line 532
      if (re_max <= 1e-3) {
#line 532
        tmp___42 = "Low quality";
      } else {
#line 532
        tmp___42 = "DUAL SOLUTION IS INFEASIBLE";
      }
#line 532
      tmp___43 = tmp___42;
    }
#line 532
    tmp___44 = tmp___43;
  }
  {
#line 532
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___44);
#line 537
  _glp_lib_xfprintf(fp, "\n");
#line 538
  _glp_lib_xfprintf(fp, "End of output\n");
#line 539
  _glp_lib_xfflush(fp);
#line 540
  tmp___46 = _glp_lib_xferror(fp);
  }
#line 540
  if (tmp___46) {
    {
#line 541
    tmp___45 = _glp_lib_xerrmsg();
#line 541
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___45);
#line 542
    ret = 1;
    }
#line 543
    goto done;
  }
#line 545
  ret = 0;
  done: 
#line 546
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 546
    _glp_lib_xfclose(fp);
    }
  }
#line 547
  return (ret);
}
}
#line 571 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_read_ipt(glp_prob *lp , char const   *fname ) 
{ 
  _glp_data___0 *pds ;
  jmp_buf jump ;
  int i ;
  int j ;
  int k ;
  int ret ;
  int tmp ;
  GLPROW *row ;
  GLPCOL *col ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 574
  ret = 0;
#line 575
  _glp_lib_xprintf("Reading interior-point solution from `%s\'...\n", fname);
#line 576
  pds = _glp_sds_open(fname);
  }
#line 577
  if ((unsigned long )pds == (unsigned long )((void *)0)) {
#line 578
    ret = 1;
#line 579
    goto done;
  }
  {
#line 581
  tmp = _setjmp((struct __jmp_buf_tag *)(jump));
  }
#line 581
  if (tmp) {
#line 582
    ret = 1;
#line 583
    goto done;
  }
  {
#line 585
  _glp_sds_jump(pds, (void *)(jump));
#line 587
  k = _glp_sds_int(pds);
  }
#line 588
  if (k != lp->m) {
    {
#line 589
    _glp_sds_error(pds, "wrong number of rows\n");
    }
  }
  {
#line 590
  k = _glp_sds_int(pds);
  }
#line 591
  if (k != lp->n) {
    {
#line 592
    _glp_sds_error(pds, "wrong number of columns\n");
    }
  }
  {
#line 594
  k = _glp_sds_int(pds);
  }
#line 595
  if (! (k == 1)) {
#line 595
    if (! (k == 5)) {
      {
#line 596
      _glp_sds_error(pds, "invalid solution status\n");
      }
    }
  }
  {
#line 597
  lp->ipt_stat = k;
#line 598
  lp->ipt_obj = _glp_sds_num(pds);
#line 600
  i = 1;
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (i <= lp->m)) {
#line 600
      goto while_break;
    }
    {
#line 601
    row = *(lp->row + i);
#line 603
    row->pval = _glp_sds_num(pds);
#line 604
    row->dval = _glp_sds_num(pds);
#line 600
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  j = 1;
  {
#line 607
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 607
    if (! (j <= lp->n)) {
#line 607
      goto while_break___0;
    }
    {
#line 608
    col = *(lp->col + j);
#line 610
    col->pval = _glp_sds_num(pds);
#line 611
    col->dval = _glp_sds_num(pds);
#line 607
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 613
  tmp___0 = _glp_sds_line(pds);
#line 613
  _glp_lib_xprintf("%d lines were read\n", tmp___0);
  }
  done: 
#line 614
  if (ret) {
#line 614
    lp->ipt_stat = 1;
  }
#line 615
  if ((unsigned long )pds != (unsigned long )((void *)0)) {
    {
#line 615
    _glp_sds_close(pds);
    }
  }
#line 616
  return (ret);
}
}
#line 662 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_write_ipt(glp_prob *lp , char const   *fname ) 
{ 
  XFILE *fp ;
  int i ;
  int j ;
  int ret ;
  char const   *tmp ;
  GLPROW *row ;
  GLPCOL *col ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 664
  ret = 0;
#line 665
  _glp_lib_xprintf("Writing interior-point solution to `%s\'...\n", fname);
#line 666
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 667
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 668
    tmp = _glp_lib_xerrmsg();
#line 668
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp);
#line 670
    ret = 1;
    }
#line 671
    goto done;
  }
  {
#line 674
  _glp_lib_xfprintf(fp, "%d %d\n", lp->m, lp->n);
#line 676
  _glp_lib_xfprintf(fp, "%d %.*g\n", lp->ipt_stat, 15, lp->ipt_obj);
#line 678
  i = 1;
  }
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 678
    if (! (i <= lp->m)) {
#line 678
      goto while_break;
    }
    {
#line 679
    row = *(lp->row + i);
#line 681
    _glp_lib_xfprintf(fp, "%.*g %.*g\n", 15, row->pval, 15, row->dval);
#line 678
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  j = 1;
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 685
    if (! (j <= lp->n)) {
#line 685
      goto while_break___0;
    }
    {
#line 686
    col = *(lp->col + j);
#line 688
    _glp_lib_xfprintf(fp, "%.*g %.*g\n", 15, col->pval, 15, col->dval);
#line 685
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 691
  _glp_lib_xfflush(fp);
#line 692
  tmp___1 = _glp_lib_xferror(fp);
  }
#line 692
  if (tmp___1) {
    {
#line 693
    tmp___0 = _glp_lib_xerrmsg();
#line 693
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___0);
#line 694
    ret = 1;
    }
#line 695
    goto done;
  }
  {
#line 697
  _glp_lib_xprintf("%d lines were written\n", (2 + lp->m) + lp->n);
  }
  done: 
#line 698
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 698
    _glp_lib_xfclose(fp);
    }
  }
#line 699
  return (ret);
}
}
#line 704 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_print_mip(glp_prob *P , char const   *fname ) 
{ 
  XFILE *fp ;
  GLPROW *row ;
  GLPCOL *col ;
  int i ;
  int j ;
  int t ;
  int ae_ind ;
  int re_ind ;
  int ret ;
  double ae_max ;
  double re_max ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  double tmp___14 ;
  double tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  double tmp___22 ;
  double tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  int tmp___36 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;

  {
  {
#line 711
  _glp_lib_xprintf("Writing MIP solution to `%s\'...\n", fname);
#line 712
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 713
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 714
    tmp = _glp_lib_xerrmsg();
#line 714
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp);
#line 715
    ret = 1;
    }
#line 716
    goto done;
  }
#line 718
  if ((unsigned long )P->name == (unsigned long )((void *)0)) {
#line 718
    tmp___0 = "";
  } else {
#line 718
    tmp___0 = (char const   *)P->name;
  }
  {
#line 718
  _glp_lib_xfprintf(fp, "%-12s%s\n", "Problem:", tmp___0);
#line 720
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Rows:", P->m);
#line 721
  tmp___1 = glp_get_num_bin(P);
#line 721
  tmp___2 = glp_get_num_int(P);
#line 721
  _glp_lib_xfprintf(fp, "%-12s%d (%d integer, %d binary)\n", "Columns:", P->n, tmp___2,
                    tmp___1);
#line 723
  _glp_lib_xfprintf(fp, "%-12s%d\n", "Non-zeros:", P->nnz);
#line 724
  t = glp_mip_status(P);
  }
#line 725
  if (t == 5) {
#line 725
    tmp___6 = "INTEGER OPTIMAL";
  } else {
#line 725
    if (t == 2) {
#line 725
      tmp___5 = "INTEGER NON-OPTIMAL";
    } else {
#line 725
      if (t == 4) {
#line 725
        tmp___4 = "INTEGER EMPTY";
      } else {
#line 725
        if (t == 1) {
#line 725
          tmp___3 = "INTEGER UNDEFINED";
        } else {
#line 725
          tmp___3 = "???";
        }
#line 725
        tmp___4 = tmp___3;
      }
#line 725
      tmp___5 = tmp___4;
    }
#line 725
    tmp___6 = tmp___5;
  }
  {
#line 725
  _glp_lib_xfprintf(fp, "%-12s%s\n", "Status:", tmp___6);
  }
#line 730
  if (P->dir == 1) {
#line 730
    tmp___8 = "MINimum";
  } else {
#line 730
    if (P->dir == 2) {
#line 730
      tmp___7 = "MAXimum";
    } else {
#line 730
      tmp___7 = "???";
    }
#line 730
    tmp___8 = tmp___7;
  }
#line 730
  if ((unsigned long )P->obj == (unsigned long )((void *)0)) {
#line 730
    tmp___9 = "";
  } else {
#line 730
    tmp___9 = " = ";
  }
#line 730
  if ((unsigned long )P->obj == (unsigned long )((void *)0)) {
#line 730
    tmp___10 = "";
  } else {
#line 730
    tmp___10 = (char const   *)P->obj;
  }
  {
#line 730
  _glp_lib_xfprintf(fp, "%-12s%s%s%.10g (%s)\n", "Objective:", tmp___10, tmp___9,
                    P->mip_obj, tmp___8);
#line 735
  _glp_lib_xfprintf(fp, "\n");
#line 736
  _glp_lib_xfprintf(fp, "   No.   Row name        Activity     Lower bound   Upper bound\n");
#line 738
  _glp_lib_xfprintf(fp, "------ ------------    ------------- ------------- -------------\n");
#line 740
  i = 1;
  }
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! (i <= P->m)) {
#line 740
      goto while_break;
    }
    {
#line 741
    row = *(P->row + i);
#line 742
    _glp_lib_xfprintf(fp, "%6d ", i);
    }
#line 743
    if ((unsigned long )row->name == (unsigned long )((void *)0)) {
#line 743
      goto _L;
    } else {
      {
#line 743
      tmp___12 = strlen((char const   *)row->name);
      }
#line 743
      if (tmp___12 <= 12U) {
        _L: /* CIL Label */ 
#line 744
        if ((unsigned long )row->name == (unsigned long )((void *)0)) {
#line 744
          tmp___11 = "";
        } else {
#line 744
          tmp___11 = (char const   *)row->name;
        }
        {
#line 744
        _glp_lib_xfprintf(fp, "%-12s ", tmp___11);
        }
      } else {
        {
#line 746
        _glp_lib_xfprintf(fp, "%s\n%20s", row->name, "");
        }
      }
    }
    {
#line 747
    _glp_lib_xfprintf(fp, "%3s", "");
#line 748
    tmp___15 = fabs(row->mipx);
    }
#line 748
    if (tmp___15 <= 1e-9) {
#line 748
      tmp___14 = 0.0;
    } else {
#line 748
      tmp___14 = row->mipx;
    }
    {
#line 748
    _glp_lib_xfprintf(fp, "%13.6g ", tmp___14);
    }
#line 750
    if (row->type == 2) {
      {
#line 752
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else
#line 750
    if (row->type == 4) {
      {
#line 752
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else
#line 750
    if (row->type == 5) {
      {
#line 752
      _glp_lib_xfprintf(fp, "%13.6g ", row->lb);
      }
    } else {
      {
#line 754
      _glp_lib_xfprintf(fp, "%13s ", "");
      }
    }
#line 755
    if (row->type == 3) {
      {
#line 756
      _glp_lib_xfprintf(fp, "%13.6g ", row->ub);
      }
    } else
#line 755
    if (row->type == 4) {
      {
#line 756
      _glp_lib_xfprintf(fp, "%13.6g ", row->ub);
      }
    } else {
#line 758
      if (row->type == 5) {
#line 758
        tmp___16 = "=";
      } else {
#line 758
        tmp___16 = "";
      }
      {
#line 758
      _glp_lib_xfprintf(fp, "%13s ", tmp___16);
      }
    }
    {
#line 759
    _glp_lib_xfprintf(fp, "\n");
#line 740
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 761
  _glp_lib_xfprintf(fp, "\n");
#line 762
  _glp_lib_xfprintf(fp, "   No. Column name       Activity     Lower bound   Upper bound\n");
#line 764
  _glp_lib_xfprintf(fp, "------ ------------    ------------- ------------- -------------\n");
#line 766
  j = 1;
  }
  {
#line 766
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 766
    if (! (j <= P->n)) {
#line 766
      goto while_break___0;
    }
    {
#line 767
    col = *(P->col + j);
#line 768
    _glp_lib_xfprintf(fp, "%6d ", j);
    }
#line 769
    if ((unsigned long )col->name == (unsigned long )((void *)0)) {
#line 769
      goto _L___0;
    } else {
      {
#line 769
      tmp___18 = strlen((char const   *)col->name);
      }
#line 769
      if (tmp___18 <= 12U) {
        _L___0: /* CIL Label */ 
#line 770
        if ((unsigned long )col->name == (unsigned long )((void *)0)) {
#line 770
          tmp___17 = "";
        } else {
#line 770
          tmp___17 = (char const   *)col->name;
        }
        {
#line 770
        _glp_lib_xfprintf(fp, "%-12s ", tmp___17);
        }
      } else {
        {
#line 772
        _glp_lib_xfprintf(fp, "%s\n%20s", col->name, "");
        }
      }
    }
#line 773
    if (col->kind == 1) {
#line 773
      tmp___20 = " ";
    } else {
#line 773
      if (col->kind == 2) {
#line 773
        tmp___19 = "*";
      } else {
#line 773
        tmp___19 = "?";
      }
#line 773
      tmp___20 = tmp___19;
    }
    {
#line 773
    _glp_lib_xfprintf(fp, "%s  ", tmp___20);
#line 776
    tmp___23 = fabs(col->mipx);
    }
#line 776
    if (tmp___23 <= 1e-9) {
#line 776
      tmp___22 = 0.0;
    } else {
#line 776
      tmp___22 = col->mipx;
    }
    {
#line 776
    _glp_lib_xfprintf(fp, "%13.6g ", tmp___22);
    }
#line 778
    if (col->type == 2) {
      {
#line 780
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else
#line 778
    if (col->type == 4) {
      {
#line 780
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else
#line 778
    if (col->type == 5) {
      {
#line 780
      _glp_lib_xfprintf(fp, "%13.6g ", col->lb);
      }
    } else {
      {
#line 782
      _glp_lib_xfprintf(fp, "%13s ", "");
      }
    }
#line 783
    if (col->type == 3) {
      {
#line 784
      _glp_lib_xfprintf(fp, "%13.6g ", col->ub);
      }
    } else
#line 783
    if (col->type == 4) {
      {
#line 784
      _glp_lib_xfprintf(fp, "%13.6g ", col->ub);
      }
    } else {
#line 786
      if (col->type == 5) {
#line 786
        tmp___24 = "=";
      } else {
#line 786
        tmp___24 = "";
      }
      {
#line 786
      _glp_lib_xfprintf(fp, "%13s ", tmp___24);
      }
    }
    {
#line 787
    _glp_lib_xfprintf(fp, "\n");
#line 766
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 789
  _glp_lib_xfprintf(fp, "\n");
#line 790
  _glp_lib_xfprintf(fp, "Integer feasibility conditions:\n");
#line 791
  _glp_lib_xfprintf(fp, "\n");
#line 792
  _glp_check_kkt(P, 3, 1, & ae_max, & ae_ind, & re_max, & re_ind);
#line 794
  _glp_lib_xfprintf(fp, "KKT.PE: max.abs.err = %.2e on row %d\n", ae_max, ae_ind);
#line 796
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on row %d\n", re_max, re_ind);
  }
#line 798
  if (re_max <= 1e-9) {
#line 798
    tmp___27 = "High quality";
  } else {
#line 798
    if (re_max <= 1e-6) {
#line 798
      tmp___26 = "Medium quality";
    } else {
#line 798
      if (re_max <= 1e-3) {
#line 798
        tmp___25 = "Low quality";
      } else {
#line 798
        tmp___25 = "SOLUTION IS WRONG";
      }
#line 798
      tmp___26 = tmp___25;
    }
#line 798
    tmp___27 = tmp___26;
  }
  {
#line 798
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___27);
#line 802
  _glp_lib_xfprintf(fp, "\n");
#line 803
  _glp_check_kkt(P, 3, 2, & ae_max, & ae_ind, & re_max, & re_ind);
  }
#line 805
  if (ae_ind <= P->m) {
#line 805
    tmp___28 = ae_ind;
  } else {
#line 805
    tmp___28 = ae_ind - P->m;
  }
#line 805
  if (ae_ind <= P->m) {
#line 805
    tmp___29 = "row";
  } else {
#line 805
    tmp___29 = "column";
  }
  {
#line 805
  _glp_lib_xfprintf(fp, "KKT.PB: max.abs.err = %.2e on %s %d\n", ae_max, tmp___29,
                    tmp___28);
  }
#line 808
  if (re_ind <= P->m) {
#line 808
    tmp___30 = re_ind;
  } else {
#line 808
    tmp___30 = re_ind - P->m;
  }
#line 808
  if (re_ind <= P->m) {
#line 808
    tmp___31 = "row";
  } else {
#line 808
    tmp___31 = "column";
  }
  {
#line 808
  _glp_lib_xfprintf(fp, "        max.rel.err = %.2e on %s %d\n", re_max, tmp___31,
                    tmp___30);
  }
#line 811
  if (re_max <= 1e-9) {
#line 811
    tmp___34 = "High quality";
  } else {
#line 811
    if (re_max <= 1e-6) {
#line 811
      tmp___33 = "Medium quality";
    } else {
#line 811
      if (re_max <= 1e-3) {
#line 811
        tmp___32 = "Low quality";
      } else {
#line 811
        tmp___32 = "SOLUTION IS INFEASIBLE";
      }
#line 811
      tmp___33 = tmp___32;
    }
#line 811
    tmp___34 = tmp___33;
  }
  {
#line 811
  _glp_lib_xfprintf(fp, "%8s%s\n", "", tmp___34);
#line 815
  _glp_lib_xfprintf(fp, "\n");
#line 816
  _glp_lib_xfprintf(fp, "End of output\n");
#line 817
  _glp_lib_xfflush(fp);
#line 818
  tmp___36 = _glp_lib_xferror(fp);
  }
#line 818
  if (tmp___36) {
    {
#line 819
    tmp___35 = _glp_lib_xerrmsg();
#line 819
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___35);
#line 820
    ret = 1;
    }
#line 821
    goto done;
  }
#line 823
  ret = 0;
  done: 
#line 824
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 824
    _glp_lib_xfclose(fp);
    }
  }
#line 825
  return (ret);
}
}
#line 848 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_read_mip(glp_prob *mip , char const   *fname ) 
{ 
  _glp_data___0 *pds ;
  jmp_buf jump ;
  int i ;
  int j ;
  int k ;
  int ret ;
  int tmp ;
  GLPROW *row ;
  GLPCOL *col ;
  double tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 851
  ret = 0;
#line 852
  _glp_lib_xprintf("Reading MIP solution from `%s\'...\n", fname);
#line 853
  pds = _glp_sds_open(fname);
  }
#line 854
  if ((unsigned long )pds == (unsigned long )((void *)0)) {
#line 855
    ret = 1;
#line 856
    goto done;
  }
  {
#line 858
  tmp = _setjmp((struct __jmp_buf_tag *)(jump));
  }
#line 858
  if (tmp) {
#line 859
    ret = 1;
#line 860
    goto done;
  }
  {
#line 862
  _glp_sds_jump(pds, (void *)(jump));
#line 864
  k = _glp_sds_int(pds);
  }
#line 865
  if (k != mip->m) {
    {
#line 866
    _glp_sds_error(pds, "wrong number of rows\n");
    }
  }
  {
#line 867
  k = _glp_sds_int(pds);
  }
#line 868
  if (k != mip->n) {
    {
#line 869
    _glp_sds_error(pds, "wrong number of columns\n");
    }
  }
  {
#line 871
  k = _glp_sds_int(pds);
  }
#line 872
  if (! (k == 1)) {
#line 872
    if (! (k == 5)) {
#line 872
      if (! (k == 2)) {
#line 872
        if (! (k == 4)) {
          {
#line 874
          _glp_sds_error(pds, "invalid solution status\n");
          }
        }
      }
    }
  }
  {
#line 875
  mip->mip_stat = k;
#line 876
  mip->mip_obj = _glp_sds_num(pds);
#line 878
  i = 1;
  }
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (! (i <= mip->m)) {
#line 878
      goto while_break;
    }
    {
#line 879
    row = *(mip->row + i);
#line 880
    row->mipx = _glp_sds_num(pds);
#line 878
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  j = 1;
  {
#line 883
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 883
    if (! (j <= mip->n)) {
#line 883
      goto while_break___0;
    }
    {
#line 884
    col = *(mip->col + j);
#line 885
    col->mipx = _glp_sds_num(pds);
    }
#line 886
    if (col->kind == 2) {
      {
#line 886
      tmp___0 = floor(col->mipx);
      }
#line 886
      if (col->mipx != tmp___0) {
        {
#line 887
        _glp_sds_error(pds, "non-integer column value");
        }
      }
    }
#line 883
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 889
  tmp___1 = _glp_sds_line(pds);
#line 889
  _glp_lib_xprintf("%d lines were read\n", tmp___1);
  }
  done: 
#line 890
  if (ret) {
#line 890
    mip->mip_stat = 1;
  }
#line 891
  if ((unsigned long )pds != (unsigned long )((void *)0)) {
    {
#line 891
    _glp_sds_close(pds);
    }
  }
#line 892
  return (ret);
}
}
#line 937 "/home/wslee/benchmarks/glpk-4.38/src/glpapi11.c"
int glp_write_mip(glp_prob *mip , char const   *fname ) 
{ 
  XFILE *fp ;
  int i ;
  int j ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 939
  ret = 0;
#line 940
  _glp_lib_xprintf("Writing MIP solution to `%s\'...\n", fname);
#line 941
  fp = _glp_lib_xfopen(fname, "w");
  }
#line 942
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 943
    tmp = _glp_lib_xerrmsg();
#line 943
    _glp_lib_xprintf("Unable to create `%s\' - %s\n", fname, tmp);
#line 945
    ret = 1;
    }
#line 946
    goto done;
  }
  {
#line 949
  _glp_lib_xfprintf(fp, "%d %d\n", mip->m, mip->n);
#line 951
  _glp_lib_xfprintf(fp, "%d %.*g\n", mip->mip_stat, 15, mip->mip_obj);
#line 953
  i = 1;
  }
  {
#line 953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 953
    if (! (i <= mip->m)) {
#line 953
      goto while_break;
    }
    {
#line 954
    _glp_lib_xfprintf(fp, "%.*g\n", 15, (*(mip->row + i))->mipx);
#line 953
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 956
  j = 1;
  {
#line 956
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 956
    if (! (j <= mip->n)) {
#line 956
      goto while_break___0;
    }
    {
#line 957
    _glp_lib_xfprintf(fp, "%.*g\n", 15, (*(mip->col + j))->mipx);
#line 956
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 958
  _glp_lib_xfflush(fp);
#line 959
  tmp___1 = _glp_lib_xferror(fp);
  }
#line 959
  if (tmp___1) {
    {
#line 960
    tmp___0 = _glp_lib_xerrmsg();
#line 960
    _glp_lib_xprintf("Write error on `%s\' - %s\n", fname, tmp___0);
#line 961
    ret = 1;
    }
#line 962
    goto done;
  }
  {
#line 964
  _glp_lib_xprintf("%d lines were written\n", (2 + mip->m) + mip->n);
  }
  done: 
#line 965
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 965
    _glp_lib_xfclose(fp);
    }
  }
#line 966
  return (ret);
}
}
#line 26 "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c"
void _glp_check_kkt(glp_prob *P , int sol , int cond , double *_ae_max , int *_ae_ind ,
                    double *_re_max , int *_re_ind ) 
{ 
  int m ;
  int n ;
  GLPROW *row ;
  GLPCOL *col ;
  GLPAIJ *aij ;
  int i ;
  int j ;
  int ae_ind ;
  int re_ind ;
  double e ;
  double sp ;
  double sn ;
  double t ;
  double ae_max ;
  double re_max ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 29
  m = P->m;
#line 30
  n = P->n;
#line 36
  if (! (sol == 1)) {
#line 36
    if (! (sol == 2)) {
#line 36
      if (! (sol == 3)) {
        {
#line 37
        tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                               37);
#line 37
        (*tmp)("glp_check_kkt: sol = %d; invalid solution indicator\n", sol);
        }
      }
    }
  }
#line 39
  if (! (cond == 1)) {
#line 39
    if (! (cond == 2)) {
#line 39
      if (! (cond == 3)) {
#line 39
        if (! (cond == 4)) {
#line 39
          if (! (cond == 5)) {
            {
#line 42
            tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                                       42);
#line 42
            (*tmp___0)("glp_check_kkt: cond = %d; invalid condition indicator \n",
                       cond);
            }
          }
        }
      }
    }
  }
#line 44
  re_max = 0.0;
#line 44
  ae_max = re_max;
#line 45
  re_ind = 0;
#line 45
  ae_ind = re_ind;
#line 46
  if (cond == 1) {
#line 48
    i = 1;
    {
#line 48
    while (1) {
      while_continue: /* CIL Label */ ;
#line 48
      if (! (i <= m)) {
#line 48
        goto while_break;
      }
#line 49
      row = *(P->row + i);
#line 50
      sn = 0.0;
#line 50
      sp = sn;
#line 52
      if (sol == 1) {
#line 53
        t = row->prim;
      } else
#line 54
      if (sol == 2) {
#line 55
        t = row->pval;
      } else
#line 56
      if (sol == 3) {
#line 57
        t = row->mipx;
      } else
#line 59
      if (sol != sol) {
#line 59
        tmp___1 = 1;
      } else {
        {
#line 59
        _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         59);
#line 59
        tmp___1 = 1;
        }
      }
#line 60
      if (t >= 0.0) {
#line 60
        sp += t;
      } else {
#line 60
        sn -= t;
      }
#line 61
      aij = row->ptr;
      {
#line 61
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 61
        if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 61
          goto while_break___0;
        }
#line 62
        col = aij->col;
#line 64
        if (sol == 1) {
#line 65
          t = - aij->val * col->prim;
        } else
#line 66
        if (sol == 2) {
#line 67
          t = - aij->val * col->pval;
        } else
#line 68
        if (sol == 3) {
#line 69
          t = - aij->val * col->mipx;
        } else
#line 71
        if (sol != sol) {
#line 71
          tmp___2 = 1;
        } else {
          {
#line 71
          _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                           71);
#line 71
          tmp___2 = 1;
          }
        }
#line 72
        if (t >= 0.0) {
#line 72
          sp += t;
        } else {
#line 72
          sn -= t;
        }
#line 61
        aij = aij->r_next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 75
      e = fabs(sp - sn);
      }
#line 76
      if (ae_max < e) {
#line 77
        ae_max = e;
#line 77
        ae_ind = i;
      }
#line 79
      e /= (1.0 + sp) + sn;
#line 80
      if (re_max < e) {
#line 81
        re_max = e;
#line 81
        re_ind = i;
      }
#line 48
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 84
  if (cond == 2) {
#line 86
    i = 1;
    {
#line 86
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 86
      if (! (i <= m)) {
#line 86
        goto while_break___1;
      }
#line 87
      row = *(P->row + i);
#line 89
      if (sol == 1) {
#line 90
        t = row->prim;
      } else
#line 91
      if (sol == 2) {
#line 92
        t = row->pval;
      } else
#line 93
      if (sol == 3) {
#line 94
        t = row->mipx;
      } else
#line 96
      if (sol != sol) {
#line 96
        tmp___3 = 1;
      } else {
        {
#line 96
        _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         96);
#line 96
        tmp___3 = 1;
        }
      }
#line 98
      if (row->type == 2) {
#line 98
        goto _L;
      } else
#line 98
      if (row->type == 4) {
#line 98
        goto _L;
      } else
#line 98
      if (row->type == 5) {
        _L: /* CIL Label */ 
#line 100
        if (t < row->lb) {
#line 102
          e = row->lb - t;
#line 103
          if (ae_max < e) {
#line 104
            ae_max = e;
#line 104
            ae_ind = i;
          }
          {
#line 106
          tmp___4 = fabs(row->lb);
#line 106
          e /= 1.0 + tmp___4;
          }
#line 107
          if (re_max < e) {
#line 108
            re_max = e;
#line 108
            re_ind = i;
          }
        }
      }
#line 112
      if (row->type == 3) {
#line 112
        goto _L___0;
      } else
#line 112
      if (row->type == 4) {
#line 112
        goto _L___0;
      } else
#line 112
      if (row->type == 5) {
        _L___0: /* CIL Label */ 
#line 114
        if (t > row->ub) {
#line 116
          e = t - row->ub;
#line 117
          if (ae_max < e) {
#line 118
            ae_max = e;
#line 118
            ae_ind = i;
          }
          {
#line 120
          tmp___5 = fabs(row->ub);
#line 120
          e /= 1.0 + tmp___5;
          }
#line 121
          if (re_max < e) {
#line 122
            re_max = e;
#line 122
            re_ind = i;
          }
        }
      }
#line 86
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 127
    j = 1;
    {
#line 127
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 127
      if (! (j <= n)) {
#line 127
        goto while_break___2;
      }
#line 128
      col = *(P->col + j);
#line 130
      if (sol == 1) {
#line 131
        t = col->prim;
      } else
#line 132
      if (sol == 2) {
#line 133
        t = col->pval;
      } else
#line 134
      if (sol == 3) {
#line 135
        t = col->mipx;
      } else
#line 137
      if (sol != sol) {
#line 137
        tmp___6 = 1;
      } else {
        {
#line 137
        _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         137);
#line 137
        tmp___6 = 1;
        }
      }
#line 139
      if (col->type == 2) {
#line 139
        goto _L___1;
      } else
#line 139
      if (col->type == 4) {
#line 139
        goto _L___1;
      } else
#line 139
      if (col->type == 5) {
        _L___1: /* CIL Label */ 
#line 141
        if (t < col->lb) {
#line 143
          e = col->lb - t;
#line 144
          if (ae_max < e) {
#line 145
            ae_max = e;
#line 145
            ae_ind = m + j;
          }
          {
#line 147
          tmp___7 = fabs(col->lb);
#line 147
          e /= 1.0 + tmp___7;
          }
#line 148
          if (re_max < e) {
#line 149
            re_max = e;
#line 149
            re_ind = m + j;
          }
        }
      }
#line 153
      if (col->type == 3) {
#line 153
        goto _L___2;
      } else
#line 153
      if (col->type == 4) {
#line 153
        goto _L___2;
      } else
#line 153
      if (col->type == 5) {
        _L___2: /* CIL Label */ 
#line 155
        if (t > col->ub) {
#line 157
          e = t - col->ub;
#line 158
          if (ae_max < e) {
#line 159
            ae_max = e;
#line 159
            ae_ind = m + j;
          }
          {
#line 161
          tmp___8 = fabs(col->ub);
#line 161
          e /= 1.0 + tmp___8;
          }
#line 162
          if (re_max < e) {
#line 163
            re_max = e;
#line 163
            re_ind = m + j;
          }
        }
      }
#line 127
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 168
  if (cond == 3) {
#line 170
    j = 1;
    {
#line 170
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 170
      if (! (j <= n)) {
#line 170
        goto while_break___3;
      }
#line 171
      col = *(P->col + j);
#line 172
      sn = 0.0;
#line 172
      sp = sn;
#line 174
      if (sol == 1) {
#line 175
        t = col->dual - col->coef;
      } else
#line 176
      if (sol == 2) {
#line 177
        t = col->dval - col->coef;
      } else
#line 179
      if (sol != sol) {
#line 179
        tmp___9 = 1;
      } else {
        {
#line 179
        _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         179);
#line 179
        tmp___9 = 1;
        }
      }
#line 180
      if (t >= 0.0) {
#line 180
        sp += t;
      } else {
#line 180
        sn -= t;
      }
#line 181
      aij = col->ptr;
      {
#line 181
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 181
        if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 181
          goto while_break___4;
        }
#line 182
        row = aij->row;
#line 184
        if (sol == 1) {
#line 185
          t = aij->val * row->dual;
        } else
#line 186
        if (sol == 2) {
#line 187
          t = aij->val * row->dval;
        } else
#line 189
        if (sol != sol) {
#line 189
          tmp___10 = 1;
        } else {
          {
#line 189
          _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                           189);
#line 189
          tmp___10 = 1;
          }
        }
#line 190
        if (t >= 0.0) {
#line 190
          sp += t;
        } else {
#line 190
          sn -= t;
        }
#line 181
        aij = aij->c_next;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 193
      e = fabs(sp - sn);
      }
#line 194
      if (ae_max < e) {
#line 195
        ae_max = e;
#line 195
        ae_ind = m + j;
      }
#line 197
      e /= (1.0 + sp) + sn;
#line 198
      if (re_max < e) {
#line 199
        re_max = e;
#line 199
        re_ind = m + j;
      }
#line 170
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 202
  if (cond == 4) {
#line 204
    i = 1;
    {
#line 204
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 204
      if (! (i <= m)) {
#line 204
        goto while_break___5;
      }
#line 205
      row = *(P->row + i);
#line 207
      if (sol == 1) {
#line 208
        t = row->dual;
      } else
#line 209
      if (sol == 2) {
#line 210
        t = row->dval;
      } else
#line 212
      if (sol != sol) {
#line 212
        tmp___11 = 1;
      } else {
        {
#line 212
        _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         212);
#line 212
        tmp___11 = 1;
        }
      }
#line 214
      if (P->dir == 1) {
#line 215
        t = t;
      } else
#line 216
      if (P->dir == 2) {
#line 217
        t = - t;
      } else
#line 219
      if ((unsigned long )P != (unsigned long )P) {
#line 219
        tmp___12 = 1;
      } else {
        {
#line 219
        _glp_lib_xassert("P != P", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         219);
#line 219
        tmp___12 = 1;
        }
      }
#line 221
      if (row->type == 1) {
#line 221
        goto _L___3;
      } else
#line 221
      if (row->type == 2) {
        _L___3: /* CIL Label */ 
#line 222
        if (t < 0.0) {
#line 223
          e = - t;
#line 224
          if (ae_max < e) {
#line 225
            re_max = e;
#line 225
            ae_max = re_max;
#line 225
            re_ind = i;
#line 225
            ae_ind = re_ind;
          }
        }
      }
#line 229
      if (row->type == 1) {
#line 229
        goto _L___4;
      } else
#line 229
      if (row->type == 3) {
        _L___4: /* CIL Label */ 
#line 230
        if (t > 0.0) {
#line 231
          e = t;
#line 232
          if (ae_max < e) {
#line 233
            re_max = e;
#line 233
            ae_max = re_max;
#line 233
            re_ind = i;
#line 233
            ae_ind = re_ind;
          }
        }
      }
#line 204
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 238
    j = 1;
    {
#line 238
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 238
      if (! (j <= n)) {
#line 238
        goto while_break___6;
      }
#line 239
      col = *(P->col + j);
#line 241
      if (sol == 1) {
#line 242
        t = col->dual;
      } else
#line 243
      if (sol == 2) {
#line 244
        t = col->dval;
      } else
#line 246
      if (sol != sol) {
#line 246
        tmp___13 = 1;
      } else {
        {
#line 246
        _glp_lib_xassert("sol != sol", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         246);
#line 246
        tmp___13 = 1;
        }
      }
#line 248
      if (P->dir == 1) {
#line 249
        t = t;
      } else
#line 250
      if (P->dir == 2) {
#line 251
        t = - t;
      } else
#line 253
      if ((unsigned long )P != (unsigned long )P) {
#line 253
        tmp___14 = 1;
      } else {
        {
#line 253
        _glp_lib_xassert("P != P", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                         253);
#line 253
        tmp___14 = 1;
        }
      }
#line 255
      if (col->type == 1) {
#line 255
        goto _L___5;
      } else
#line 255
      if (col->type == 2) {
        _L___5: /* CIL Label */ 
#line 256
        if (t < 0.0) {
#line 257
          e = - t;
#line 258
          if (ae_max < e) {
#line 259
            re_max = e;
#line 259
            ae_max = re_max;
#line 259
            re_ind = m + j;
#line 259
            ae_ind = re_ind;
          }
        }
      }
#line 263
      if (col->type == 1) {
#line 263
        goto _L___6;
      } else
#line 263
      if (col->type == 3) {
        _L___6: /* CIL Label */ 
#line 264
        if (t > 0.0) {
#line 265
          e = t;
#line 266
          if (ae_max < e) {
#line 267
            re_max = e;
#line 267
            ae_max = re_max;
#line 267
            re_ind = m + j;
#line 267
            ae_ind = re_ind;
          }
        }
      }
#line 238
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else
#line 273
  if (cond != cond) {
#line 273
    tmp___15 = 1;
  } else {
    {
#line 273
    _glp_lib_xassert("cond != cond", "/home/wslee/benchmarks/glpk-4.38/src/glpapi10.c",
                     273);
#line 273
    tmp___15 = 1;
    }
  }
#line 274
  if ((unsigned long )_ae_max != (unsigned long )((void *)0)) {
#line 274
    *_ae_max = ae_max;
  }
#line 275
  if ((unsigned long )_ae_ind != (unsigned long )((void *)0)) {
#line 275
    *_ae_ind = ae_ind;
  }
#line 276
  if ((unsigned long )_re_max != (unsigned long )((void *)0)) {
#line 276
    *_re_max = re_max;
  }
#line 277
  if ((unsigned long )_re_ind != (unsigned long )((void *)0)) {
#line 277
    *_re_ind = re_ind;
  }
#line 278
  return;
}
}
#line 45 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
void glp_set_col_kind(glp_prob *mip , int j , int kind ) 
{ 
  GLPCOL *col ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 47
  if (1 <= j) {
#line 47
    if (! (j <= mip->n)) {
      {
#line 48
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 48);
#line 48
      (*tmp)("glp_set_col_kind: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 48
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 48);
#line 48
    (*tmp)("glp_set_col_kind: j = %d; column number out of range\n", j);
    }
  }
#line 50
  col = *(mip->col + j);
  {
#line 52
  if (kind == 1) {
#line 52
    goto case_1;
  }
#line 55
  if (kind == 2) {
#line 55
    goto case_2;
  }
#line 58
  if (kind == 3) {
#line 58
    goto case_3;
  }
#line 63
  goto switch_default;
  case_1: /* CIL Label */ 
#line 53
  col->kind = 1;
#line 54
  goto switch_break;
  case_2: /* CIL Label */ 
#line 56
  col->kind = 2;
#line 57
  goto switch_break;
  case_3: /* CIL Label */ 
#line 59
  col->kind = 2;
#line 60
  if (col->type == 4) {
#line 60
    if (col->lb == 0.0) {
#line 60
      if (! (col->ub == 1.0)) {
        {
#line 61
        glp_set_col_bnds(mip, j, 4, 0.0, 1.0);
        }
      }
    } else {
      {
#line 61
      glp_set_col_bnds(mip, j, 4, 0.0, 1.0);
      }
    }
  } else {
    {
#line 61
    glp_set_col_bnds(mip, j, 4, 0.0, 1.0);
    }
  }
#line 62
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 64
  tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 64);
#line 64
  (*tmp___0)("glp_set_col_kind: j = %d; kind = %d; invalid column kind\n", j, kind);
  }
  switch_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 88 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
int glp_get_col_kind(glp_prob *mip , int j ) 
{ 
  GLPCOL *col ;
  int kind ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 91
  if (1 <= j) {
#line 91
    if (! (j <= mip->n)) {
      {
#line 92
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 92);
#line 92
      (*tmp)("glp_get_col_kind: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 92
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 92);
#line 92
    (*tmp)("glp_get_col_kind: j = %d; column number out of range\n", j);
    }
  }
#line 94
  col = *(mip->col + j);
#line 95
  kind = col->kind;
  {
#line 97
  if (kind == 1) {
#line 97
    goto case_1;
  }
#line 99
  if (kind == 2) {
#line 99
    goto case_2;
  }
#line 103
  goto switch_default;
  case_1: /* CIL Label */ 
#line 98
  goto switch_break;
  case_2: /* CIL Label */ 
#line 100
  if (col->type == 4) {
#line 100
    if (col->lb == 0.0) {
#line 100
      if (col->ub == 1.0) {
#line 101
        kind = 3;
      }
    }
  }
#line 102
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 104
  if (kind != kind) {
#line 104
    tmp___0 = 1;
  } else {
    {
#line 104
    _glp_lib_xassert("kind != kind", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                     104);
#line 104
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 106
  return (kind);
}
}
#line 123 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
int glp_get_num_int(glp_prob *mip ) 
{ 
  GLPCOL *col ;
  int j ;
  int count ;

  {
#line 125
  count = 0;
#line 126
  j = 1;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (j <= mip->n)) {
#line 126
      goto while_break;
    }
#line 127
    col = *(mip->col + j);
#line 128
    if (col->kind == 2) {
#line 128
      count ++;
    }
#line 126
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (count);
}
}
#line 147 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
int glp_get_num_bin(glp_prob *mip ) 
{ 
  GLPCOL *col ;
  int j ;
  int count ;

  {
#line 149
  count = 0;
#line 150
  j = 1;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (j <= mip->n)) {
#line 150
      goto while_break;
    }
#line 151
    col = *(mip->col + j);
#line 152
    if (col->kind == 2) {
#line 152
      if (col->type == 4) {
#line 152
        if (col->lb == 0.0) {
#line 152
          if (col->ub == 1.0) {
#line 153
            count ++;
          }
        }
      }
    }
#line 150
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return (count);
}
}
#line 219 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
static int driver1(glp_prob *mip , glp_iocp___0 const   *parm ) 
{ 
  glp_tree___0 *tree ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 224
  tmp = glp_get_status(mip);
  }
#line 224
  if (tmp != 5) {
#line 225
    if (parm->msg_lev >= 1) {
      {
#line 226
      _glp_lib_xprintf("glp_intopt: optimal basis to initial LP relaxation not provided\n");
      }
    }
#line 228
    ret = 12;
#line 229
    goto done;
  }
#line 232
  if (parm->msg_lev >= 3) {
    {
#line 233
    _glp_lib_xprintf("Integer optimization begins...\n");
    }
  }
  {
#line 238
  tree = _glp_ios_create_tree(mip, parm);
#line 240
  ret = _glp_ios_driver(tree);
  }
  {
#line 243
  if (ret == 0) {
#line 243
    goto case_0;
  }
#line 255
  if (ret == 14) {
#line 255
    goto case_14;
  }
#line 260
  if (ret == 9) {
#line 260
    goto case_9;
  }
#line 264
  if (ret == 5) {
#line 264
    goto case_5;
  }
#line 269
  if (ret == 13) {
#line 269
    goto case_13;
  }
#line 273
  goto switch_default;
  case_0: /* CIL Label */ 
#line 244
  if ((tree->mip)->mip_stat == 2) {
#line 245
    if (parm->msg_lev >= 3) {
      {
#line 246
      _glp_lib_xprintf("INTEGER OPTIMAL SOLUTION FOUND\n");
      }
    }
#line 247
    (tree->mip)->mip_stat = 5;
  } else {
#line 250
    if (parm->msg_lev >= 3) {
      {
#line 251
      _glp_lib_xprintf("PROBLEM HAS NO INTEGER FEASIBLE SOLUTION\n");
      }
    }
#line 252
    (tree->mip)->mip_stat = 4;
  }
#line 254
  goto switch_break;
  case_14: /* CIL Label */ 
#line 256
  if (parm->msg_lev >= 3) {
    {
#line 257
    _glp_lib_xprintf("RELATIVE MIP GAP TOLERANCE REACHED; SEARCH TERMINATED\n");
    }
  }
#line 259
  goto switch_break;
  case_9: /* CIL Label */ 
#line 261
  if (parm->msg_lev >= 3) {
    {
#line 262
    _glp_lib_xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
    }
  }
#line 263
  goto switch_break;
  case_5: /* CIL Label */ 
#line 265
  if (parm->msg_lev >= 1) {
    {
#line 266
    _glp_lib_xprintf("glp_intopt: cannot solve current LP relaxation \n");
    }
  }
#line 268
  goto switch_break;
  case_13: /* CIL Label */ 
#line 270
  if (parm->msg_lev >= 3) {
    {
#line 271
    _glp_lib_xprintf("SEARCH TERMINATED BY APPLICATION\n");
    }
  }
#line 272
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 274
  if (ret != ret) {
#line 274
    tmp___0 = 1;
  } else {
    {
#line 274
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                     274);
#line 274
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 277
  _glp_ios_delete_tree(tree);
  }
  done: 
#line 278
  return (ret);
}
}
#line 281 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
static int driver2(glp_prob *orig , glp_iocp___0 const   *parm ) 
{ 
  LIBENV *env ;
  LIBENV *tmp ;
  int term_out ;
  IPP *ipp ;
  glp_prob *prob ;
  int j ;
  int i_stat ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  glp_bfcp bfcp ;
  int m ;
  int tmp___9 ;
  int n ;
  int tmp___10 ;
  int nnz ;
  int tmp___11 ;
  int ni ;
  int tmp___12 ;
  int nb ;
  int tmp___13 ;
  char s[50] ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  glp_smcp smcp ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;

  {
  {
#line 283
  tmp = _glp_lib_link_env();
#line 283
  env = tmp;
#line 284
  term_out = env->term_out;
#line 286
  prob = (glp_prob *)((void *)0);
  }
#line 289
  if (orig->m > 0) {
#line 289
    if (orig->n > 0) {
#line 289
      tmp___0 = 1;
    } else {
      {
#line 289
      _glp_lib_xassert("orig->m > 0 && orig->n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                       289);
#line 289
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 289
    _glp_lib_xassert("orig->m > 0 && orig->n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                     289);
#line 289
    tmp___0 = 1;
    }
  }
  {
#line 291
  orig->mip_stat = 1;
#line 293
  ipp = _glp_ipp_create_wksp();
#line 295
  _glp_ipp_load_orig(ipp, orig);
  }
#line 297
  if (! term_out) {
#line 298
    env->term_out = 0;
  } else
#line 297
  if (parm->msg_lev < 3) {
#line 298
    env->term_out = 0;
  } else {
#line 300
    env->term_out = 1;
  }
  {
#line 301
  ret = _glp_ipp_basic_tech(ipp);
#line 302
  env->term_out = term_out;
  }
  {
#line 304
  if (ret == 0) {
#line 304
    goto case_0;
  }
#line 307
  if (ret == 1) {
#line 307
    goto nopfs;
  }
#line 313
  if (ret == 2) {
#line 313
    goto nodfs;
  }
#line 319
  goto switch_default;
  case_0: /* CIL Label */ 
#line 306
  goto switch_break;
  nopfs: 
  case_1: /* CIL Label */ 
#line 309
  if (parm->msg_lev >= 3) {
    {
#line 310
    _glp_lib_xprintf("PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\n");
    }
  }
#line 311
  ret = 10;
#line 312
  goto done;
  nodfs: 
  case_2: /* CIL Label */ 
#line 315
  if (parm->msg_lev >= 3) {
    {
#line 316
    _glp_lib_xprintf("LP RELAXATION HAS NO DUAL FEASIBLE SOLUTION\n");
    }
  }
#line 317
  ret = 11;
#line 318
  goto done;
  switch_default: /* CIL Label */ 
#line 320
  if ((unsigned long )ipp != (unsigned long )ipp) {
#line 320
    tmp___1 = 1;
  } else {
    {
#line 320
    _glp_lib_xassert("ipp != ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                     320);
#line 320
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 323
  if (! term_out) {
#line 324
    env->term_out = 0;
  } else
#line 323
  if (parm->msg_lev < 3) {
#line 324
    env->term_out = 0;
  } else {
#line 326
    env->term_out = 1;
  }
  {
#line 327
  ret = _glp_ipp_reduce_bnds(ipp);
#line 328
  env->term_out = term_out;
  }
  {
#line 330
  if (ret == 0) {
#line 330
    goto case_0___0;
  }
#line 331
  if (ret == 1) {
#line 331
    goto case_1___0;
  }
#line 332
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 330
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 331
  goto nopfs;
  switch_default___0: /* CIL Label */ 
#line 332
  if ((unsigned long )ipp != (unsigned long )ipp) {
#line 332
    tmp___2 = 1;
  } else {
    {
#line 332
    _glp_lib_xassert("ipp != ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                     332);
#line 332
    tmp___2 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 335
  if (! term_out) {
#line 336
    env->term_out = 0;
  } else
#line 335
  if (parm->msg_lev < 3) {
#line 336
    env->term_out = 0;
  } else {
#line 338
    env->term_out = 1;
  }
  {
#line 339
  ret = _glp_ipp_basic_tech(ipp);
#line 340
  env->term_out = term_out;
  }
  {
#line 342
  if (ret == 0) {
#line 342
    goto case_0___1;
  }
#line 343
  if (ret == 1) {
#line 343
    goto case_1___1;
  }
#line 344
  if (ret == 2) {
#line 344
    goto case_2___0;
  }
#line 345
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 342
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 343
  goto nopfs;
  case_2___0: /* CIL Label */ 
#line 344
  goto nodfs;
  switch_default___1: /* CIL Label */ 
#line 345
  if ((unsigned long )ipp != (unsigned long )ipp) {
#line 345
    tmp___3 = 1;
  } else {
    {
#line 345
    _glp_lib_xassert("ipp != ipp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                     345);
#line 345
    tmp___3 = 1;
    }
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 349
  if (parm->binarize) {
#line 350
    if (! term_out) {
#line 351
      env->term_out = 0;
    } else
#line 350
    if (parm->msg_lev < 3) {
#line 351
      env->term_out = 0;
    } else {
#line 353
      env->term_out = 1;
    }
    {
#line 354
    _glp_ipp_binarize(ipp);
#line 355
    env->term_out = term_out;
    }
  }
#line 358
  if (! term_out) {
#line 359
    env->term_out = 0;
  } else
#line 358
  if (parm->msg_lev < 3) {
#line 359
    env->term_out = 0;
  } else {
#line 361
    env->term_out = 1;
  }
  {
#line 362
  _glp_ipp_reduction(ipp);
#line 363
  env->term_out = term_out;
  }
#line 366
  if ((unsigned long )ipp->row_ptr == (unsigned long )((void *)0)) {
#line 366
    goto _L;
  } else
#line 366
  if ((unsigned long )ipp->col_ptr == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 367
    if ((unsigned long )ipp->row_ptr == (unsigned long )((void *)0)) {
#line 367
      tmp___4 = 1;
    } else {
      {
#line 367
      _glp_lib_xassert("ipp->row_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                       367);
#line 367
      tmp___4 = 1;
      }
    }
#line 368
    if ((unsigned long )ipp->col_ptr == (unsigned long )((void *)0)) {
#line 368
      tmp___5 = 1;
    } else {
      {
#line 368
      _glp_lib_xassert("ipp->col_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                       368);
#line 368
      tmp___5 = 1;
      }
    }
#line 369
    if (parm->msg_lev >= 3) {
#line 370
      if (ipp->orig_dir == 120) {
#line 370
        tmp___6 = ipp->c0;
      } else {
#line 370
        tmp___6 = - ipp->c0;
      }
      {
#line 370
      _glp_lib_xprintf("Objective value = %.10g\n", tmp___6);
#line 372
      _glp_lib_xprintf("INTEGER OPTIMAL SOLUTION FOUND BY MIP PRESOLVER\n");
      }
    }
    {
#line 376
    tmp___7 = _glp_lib_xcalloc(1 + ipp->ncols, (int )sizeof(int ));
#line 376
    ipp->col_stat = (int *)tmp___7;
#line 377
    tmp___8 = _glp_lib_xcalloc(1 + ipp->ncols, (int )sizeof(double ));
#line 377
    ipp->col_mipx = (double *)tmp___8;
#line 378
    j = 1;
    }
    {
#line 378
    while (1) {
      while_continue: /* CIL Label */ ;
#line 378
      if (! (j <= ipp->ncols)) {
#line 378
        goto while_break;
      }
#line 378
      *(ipp->col_stat + j) = 0;
#line 378
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 380
    _glp_ipp_postsolve(ipp);
#line 383
    _glp_ipp_unload_sol(ipp, orig, 171);
#line 384
    ret = 0;
    }
#line 385
    goto done;
  }
  {
#line 388
  prob = _glp_ipp_build_prob(ipp);
#line 390
  glp_get_bfcp(orig, & bfcp);
#line 391
  glp_set_bfcp(prob, (glp_bfcp const   *)(& bfcp));
  }
#line 394
  if (parm->msg_lev >= 3) {
    {
#line 395
    tmp___9 = _glp_lpx_get_num_rows(prob);
#line 395
    m = tmp___9;
#line 396
    tmp___10 = _glp_lpx_get_num_cols(prob);
#line 396
    n = tmp___10;
#line 397
    tmp___11 = _glp_lpx_get_num_nz(prob);
#line 397
    nnz = tmp___11;
#line 398
    tmp___12 = _glp_lpx_get_num_int(prob);
#line 398
    ni = tmp___12;
#line 399
    tmp___13 = _glp_lpx_get_num_bin(prob);
#line 399
    nb = tmp___13;
    }
#line 401
    if (nnz == 1) {
#line 401
      tmp___14 = "";
    } else {
#line 401
      tmp___14 = "s";
    }
#line 401
    if (n == 1) {
#line 401
      tmp___15 = "";
    } else {
#line 401
      tmp___15 = "s";
    }
#line 401
    if (m == 1) {
#line 401
      tmp___16 = "";
    } else {
#line 401
      tmp___16 = "s";
    }
    {
#line 401
    _glp_lib_xprintf("glp_intopt: presolved MIP has %d row%s, %d column%s, %d non-zero%s\n",
                     m, tmp___16, n, tmp___15, nnz, tmp___14);
    }
#line 405
    if (nb == 0) {
      {
#line 406
      strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"none of");
      }
    } else
#line 407
    if (ni == 1) {
#line 407
      if (nb == 1) {
        {
#line 408
        strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"");
        }
      } else {
#line 407
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 409
    if (nb == 1) {
      {
#line 410
      strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"one of");
      }
    } else
#line 411
    if (nb == ni) {
      {
#line 412
      strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"all of");
      }
    } else {
      {
#line 414
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d of",
              nb);
      }
    }
#line 415
    if (nb == 1) {
#line 415
      tmp___17 = "is";
    } else {
#line 415
      tmp___17 = "are";
    }
#line 415
    if (ni == 1) {
#line 415
      tmp___18 = "";
    } else {
#line 415
      tmp___18 = "s";
    }
    {
#line 415
    _glp_lib_xprintf("glp_intopt: %d integer column%s, %s which %s binary\n", ni,
                     tmp___18, s, tmp___17);
    }
  }
#line 420
  if (! term_out) {
#line 421
    env->term_out = 0;
  } else
#line 420
  if (parm->msg_lev < 3) {
#line 421
    env->term_out = 0;
  } else {
#line 423
    env->term_out = 1;
  }
  {
#line 424
  glp_scale_prob(prob, 113);
#line 426
  glp_adv_basis(prob, 0);
#line 427
  env->term_out = term_out;
  }
#line 428
  if (parm->msg_lev >= 3) {
    {
#line 429
    _glp_lib_xprintf("Solving LP relaxation...\n");
    }
  }
  {
#line 430
  prob->it_cnt = orig->it_cnt;
#line 432
  glp_init_smcp(& smcp);
#line 433
  smcp.msg_lev = (int )parm->msg_lev;
#line 434
  ret = glp_simplex(prob, (glp_smcp const   *)(& smcp));
#line 436
  orig->it_cnt = prob->it_cnt;
  }
#line 437
  if (ret != 0) {
#line 438
    if (parm->msg_lev >= 1) {
      {
#line 439
      _glp_lib_xprintf("glp_intopt: cannot solve LP relaxation\n");
      }
    }
#line 440
    ret = 5;
#line 441
    goto done;
  }
  {
#line 444
  tmp___19 = glp_get_status(prob);
  }
  {
#line 445
  if (tmp___19 == 5) {
#line 445
    goto case_5;
  }
#line 447
  if (tmp___19 == 4) {
#line 447
    goto case_4;
  }
#line 450
  if (tmp___19 == 6) {
#line 450
    goto case_6;
  }
#line 453
  goto switch_default___2;
  case_5: /* CIL Label */ 
#line 446
  goto switch_break___2;
  case_4: /* CIL Label */ 
#line 448
  ret = 10;
#line 449
  goto done;
  case_6: /* CIL Label */ 
#line 451
  ret = 11;
#line 452
  goto done;
  switch_default___2: /* CIL Label */ 
#line 454
  if ((unsigned long )prob != (unsigned long )prob) {
#line 454
    tmp___20 = 1;
  } else {
    {
#line 454
    _glp_lib_xassert("prob != prob", "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                     454);
#line 454
    tmp___20 = 1;
    }
  }
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 457
  prob->it_cnt = orig->it_cnt;
#line 458
  ret = driver1(prob, parm);
#line 459
  orig->it_cnt = prob->it_cnt;
#line 461
  i_stat = glp_mip_status(prob);
  }
#line 462
  if (i_stat == 5) {
#line 462
    goto _L___1;
  } else
#line 462
  if (i_stat == 2) {
    _L___1: /* CIL Label */ 
    {
#line 465
    _glp_ipp_load_sol(ipp, prob);
#line 467
    _glp_ipp_postsolve(ipp);
    }
#line 470
    if (i_stat == 5) {
#line 470
      tmp___21 = 171;
    } else {
#line 470
      tmp___21 = 172;
    }
    {
#line 470
    _glp_ipp_unload_sol(ipp, orig, tmp___21);
    }
  } else {
#line 475
    orig->mip_stat = i_stat;
  }
  done: 
#line 478
  if ((unsigned long )prob != (unsigned long )((void *)0)) {
    {
#line 478
    _glp_lpx_delete_prob(prob);
    }
  }
#line 480
  if ((unsigned long )ipp != (unsigned long )((void *)0)) {
    {
#line 480
    _glp_ipp_delete_wksp(ipp);
    }
  }
#line 481
  return (ret);
}
}
#line 484 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
int glp_intopt(glp_prob *mip , glp_iocp___0 const   *parm ) 
{ 
  glp_iocp___0 _parm ;
  int m ;
  int n ;
  int i ;
  int j ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  xerror_t tmp___6 ;
  xerror_t tmp___7 ;
  xerror_t tmp___8 ;
  xerror_t tmp___9 ;
  xerror_t tmp___10 ;
  xerror_t tmp___11 ;
  xerror_t tmp___12 ;
  xerror_t tmp___13 ;
  xerror_t tmp___14 ;
  xerror_t tmp___15 ;
  xerror_t tmp___16 ;
  xerror_t tmp___17 ;
  GLPROW *row ;
  GLPCOL *col ;
  GLPCOL *col___0 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 486
  m = mip->m;
#line 487
  n = mip->n;
#line 489
  if ((unsigned long )mip->tree != (unsigned long )((void *)0)) {
    {
#line 490
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 490);
#line 490
    (*tmp)("glp_intopt: problem object is already used by the MIP solver\n");
    }
  }
#line 492
  if ((unsigned long )parm == (unsigned long )((void *)0)) {
    {
#line 493
    glp_init_iocp(& _parm);
    }
  } else {
    {
#line 495
    memcpy((void */* __restrict  */)(& _parm), (void const   */* __restrict  */)parm,
           (size_t )sizeof(glp_iocp___0 ));
    }
  }
#line 496
  parm = (glp_iocp___0 const   *)(& _parm);
#line 498
  if (! (parm->msg_lev == 0)) {
#line 498
    if (! (parm->msg_lev == 1)) {
#line 498
      if (! (parm->msg_lev == 2)) {
#line 498
        if (! (parm->msg_lev == 3)) {
#line 498
          if (! (parm->msg_lev == 4)) {
            {
#line 503
            tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                       503);
#line 503
            (*tmp___0)("glp_intopt: msg_lev = %d; invalid parameter\n", parm->msg_lev);
            }
          }
        }
      }
    }
  }
#line 505
  if (! (parm->br_tech == 1)) {
#line 505
    if (! (parm->br_tech == 2)) {
#line 505
      if (! (parm->br_tech == 3)) {
#line 505
        if (! (parm->br_tech == 4)) {
#line 505
          if (! (parm->br_tech == 5)) {
            {
#line 510
            tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                       510);
#line 510
            (*tmp___1)("glp_intopt: br_tech = %d; invalid parameter\n", parm->br_tech);
            }
          }
        }
      }
    }
  }
#line 512
  if (! (parm->bt_tech == 1)) {
#line 512
    if (! (parm->bt_tech == 2)) {
#line 512
      if (! (parm->bt_tech == 3)) {
#line 512
        if (! (parm->bt_tech == 4)) {
          {
#line 516
          tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                     516);
#line 516
          (*tmp___2)("glp_intopt: bt_tech = %d; invalid parameter\n", parm->bt_tech);
          }
        }
      }
    }
  }
#line 518
  if (0.0 < (double )parm->tol_int) {
#line 518
    if (! (parm->tol_int < (double const   )1.0)) {
      {
#line 519
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                 519);
#line 519
      (*tmp___3)("glp_intopt: tol_int = %g; invalid parameter\n", parm->tol_int);
      }
    }
  } else {
    {
#line 519
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                               519);
#line 519
    (*tmp___3)("glp_intopt: tol_int = %g; invalid parameter\n", parm->tol_int);
    }
  }
#line 521
  if (0.0 < (double )parm->tol_obj) {
#line 521
    if (! (parm->tol_obj < (double const   )1.0)) {
      {
#line 522
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                 522);
#line 522
      (*tmp___4)("glp_intopt: tol_obj = %g; invalid parameter\n", parm->tol_obj);
      }
    }
  } else {
    {
#line 522
    tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                               522);
#line 522
    (*tmp___4)("glp_intopt: tol_obj = %g; invalid parameter\n", parm->tol_obj);
    }
  }
#line 524
  if (parm->tm_lim < 0) {
    {
#line 525
    tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                               525);
#line 525
    (*tmp___5)("glp_intopt: tm_lim = %d; invalid parameter\n", parm->tm_lim);
    }
  }
#line 527
  if (parm->out_frq < 0) {
    {
#line 528
    tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                               528);
#line 528
    (*tmp___6)("glp_intopt: out_frq = %d; invalid parameter\n", parm->out_frq);
    }
  }
#line 530
  if (parm->out_dly < 0) {
    {
#line 531
    tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                               531);
#line 531
    (*tmp___7)("glp_intopt: out_dly = %d; invalid parameter\n", parm->out_dly);
    }
  }
#line 533
  if (0 <= (int )parm->cb_size) {
#line 533
    if (! (parm->cb_size <= 256)) {
      {
#line 534
      tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                 534);
#line 534
      (*tmp___8)("glp_intopt: cb_size = %d; invalid parameter\n", parm->cb_size);
      }
    }
  } else {
    {
#line 534
    tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                               534);
#line 534
    (*tmp___8)("glp_intopt: cb_size = %d; invalid parameter\n", parm->cb_size);
    }
  }
#line 536
  if (! (parm->pp_tech == 0)) {
#line 536
    if (! (parm->pp_tech == 1)) {
#line 536
      if (! (parm->pp_tech == 2)) {
        {
#line 539
        tmp___9 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                   539);
#line 539
        (*tmp___9)("glp_intopt: pp_tech = %d; invalid parameter\n", parm->pp_tech);
        }
      }
    }
  }
#line 541
  if (parm->mip_gap < (double const   )0.0) {
    {
#line 542
    tmp___10 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                542);
#line 542
    (*tmp___10)("glp_intopt: mip_gap = %g; invalid parameter\n", parm->mip_gap);
    }
  }
#line 544
  if (! (parm->mir_cuts == 1)) {
#line 544
    if (! (parm->mir_cuts == 0)) {
      {
#line 545
      tmp___11 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                  545);
#line 545
      (*tmp___11)("glp_intopt: mir_cuts = %d; invalid parameter\n", parm->mir_cuts);
      }
    }
  }
#line 547
  if (! (parm->gmi_cuts == 1)) {
#line 547
    if (! (parm->gmi_cuts == 0)) {
      {
#line 548
      tmp___12 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                  548);
#line 548
      (*tmp___12)("glp_intopt: gmi_cuts = %d; invalid parameter\n", parm->gmi_cuts);
      }
    }
  }
#line 550
  if (! (parm->cov_cuts == 1)) {
#line 550
    if (! (parm->cov_cuts == 0)) {
      {
#line 551
      tmp___13 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                  551);
#line 551
      (*tmp___13)("glp_intopt: cov_cuts = %d; invalid parameter\n", parm->cov_cuts);
      }
    }
  }
#line 553
  if (! (parm->clq_cuts == 1)) {
#line 553
    if (! (parm->clq_cuts == 0)) {
      {
#line 554
      tmp___14 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                  554);
#line 554
      (*tmp___14)("glp_intopt: clq_cuts = %d; invalid parameter\n", parm->clq_cuts);
      }
    }
  }
#line 556
  if (! (parm->presolve == 1)) {
#line 556
    if (! (parm->presolve == 0)) {
      {
#line 557
      tmp___15 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                  557);
#line 557
      (*tmp___15)("glp_intopt: presolve = %d; invalid parameter\n", parm->presolve);
      }
    }
  }
#line 559
  if (! (parm->binarize == 1)) {
#line 559
    if (! (parm->binarize == 0)) {
      {
#line 560
      tmp___16 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                  560);
#line 560
      (*tmp___16)("glp_intopt: binarize = %d; invalid parameter\n", parm->binarize);
      }
    }
  }
#line 562
  if (! (parm->fp_heur == 1)) {
#line 562
    if (! (parm->fp_heur == 0)) {
      {
#line 563
      tmp___17 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c",
                                  563);
#line 563
      (*tmp___17)("glp_intopt: fp_heur = %d; invalid parameter\n", parm->fp_heur);
      }
    }
  }
#line 566
  mip->mip_stat = 1;
#line 567
  mip->mip_obj = 0.0;
#line 569
  i = 1;
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 569
    if (! (i <= m)) {
#line 569
      goto while_break;
    }
#line 570
    row = *(mip->row + i);
#line 571
    if (row->type == 4) {
#line 571
      if (row->lb >= row->ub) {
#line 572
        if (parm->msg_lev >= 1) {
          {
#line 573
          _glp_lib_xprintf("glp_intopt: row %d: lb = %g, ub = %g; incorrect bounds\n",
                           i, row->lb, row->ub);
          }
        }
#line 575
        ret = 4;
#line 576
        goto done;
      }
    }
#line 569
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  j = 1;
  {
#line 579
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 579
    if (! (j <= n)) {
#line 579
      goto while_break___0;
    }
#line 580
    col = *(mip->col + j);
#line 581
    if (col->type == 4) {
#line 581
      if (col->lb >= col->ub) {
#line 582
        if (parm->msg_lev >= 1) {
          {
#line 583
          _glp_lib_xprintf("glp_intopt: column %d: lb = %g, ub = %g; incorrect bounds\n",
                           j, col->lb, col->ub);
          }
        }
#line 585
        ret = 4;
#line 586
        goto done;
      }
    }
#line 579
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 590
  j = 1;
  {
#line 590
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 590
    if (! (j <= n)) {
#line 590
      goto while_break___1;
    }
#line 591
    col___0 = *(mip->col + j);
#line 592
    if (col___0->kind != 2) {
#line 592
      goto __Cont;
    }
#line 593
    if (col___0->type == 2) {
#line 593
      goto _L;
    } else
#line 593
    if (col___0->type == 4) {
      _L: /* CIL Label */ 
      {
#line 594
      tmp___18 = floor(col___0->lb);
      }
#line 594
      if (col___0->lb != tmp___18) {
#line 595
        if (parm->msg_lev >= 1) {
          {
#line 596
          _glp_lib_xprintf("glp_intopt: integer column %d has non-integer lower bound %g\n",
                           j, col___0->lb);
          }
        }
#line 598
        ret = 4;
#line 599
        goto done;
      }
    }
#line 602
    if (col___0->type == 3) {
#line 602
      goto _L___0;
    } else
#line 602
    if (col___0->type == 4) {
      _L___0: /* CIL Label */ 
      {
#line 603
      tmp___19 = floor(col___0->ub);
      }
#line 603
      if (col___0->ub != tmp___19) {
#line 604
        if (parm->msg_lev >= 1) {
          {
#line 605
          _glp_lib_xprintf("glp_intopt: integer column %d has non-integer upper bound %g\n",
                           j, col___0->ub);
          }
        }
#line 607
        ret = 4;
#line 608
        goto done;
      }
    }
#line 611
    if (col___0->type == 5) {
      {
#line 612
      tmp___20 = floor(col___0->lb);
      }
#line 612
      if (col___0->lb != tmp___20) {
#line 613
        if (parm->msg_lev >= 1) {
          {
#line 614
          _glp_lib_xprintf("glp_intopt: integer column %d has non-integer fixed value %g\n",
                           j, col___0->lb);
          }
        }
#line 616
        ret = 4;
#line 617
        goto done;
      }
    }
    __Cont: /* CIL Label */ 
#line 590
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 622
  if (! parm->presolve) {
    {
#line 623
    ret = driver1(mip, parm);
    }
  } else {
    {
#line 625
    ret = driver2(mip, parm);
    }
  }
  done: 
#line 627
  return (ret);
}
}
#line 647 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
void glp_init_iocp(glp_iocp___0 *parm ) 
{ 


  {
#line 648
  parm->msg_lev = 3;
#line 649
  parm->br_tech = 4;
#line 650
  parm->bt_tech = 3;
#line 651
  parm->tol_int = 1e-5;
#line 652
  parm->tol_obj = 1e-7;
#line 653
  parm->tm_lim = 2147483647;
#line 654
  parm->out_frq = 5000;
#line 655
  parm->out_dly = 10000;
#line 656
  parm->cb_func = (void (*)(glp_tree___0 *T , void *info ))((void *)0);
#line 657
  parm->cb_info = (void *)0;
#line 658
  parm->cb_size = 0;
#line 659
  parm->pp_tech = 2;
#line 660
  parm->mip_gap = 0.0;
#line 661
  parm->mir_cuts = 0;
#line 662
  parm->gmi_cuts = 0;
#line 663
  parm->cov_cuts = 0;
#line 664
  parm->clq_cuts = 0;
#line 665
  parm->presolve = 0;
#line 666
  parm->binarize = 0;
#line 667
  parm->fp_heur = 0;
#line 668
  return;
}
}
#line 693 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
int glp_mip_status(glp_prob *mip ) 
{ 
  int mip_stat ;

  {
#line 694
  mip_stat = mip->mip_stat;
#line 695
  return (mip_stat);
}
}
#line 712 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
double glp_mip_obj_val(glp_prob *mip ) 
{ 
  struct LPXCPS *cps ;
  double z ;
  double tmp ;

  {
#line 713
  cps = (struct LPXCPS *)mip->cps;
#line 715
  z = mip->mip_obj;
#line 716
  if (cps->round) {
    {
#line 716
    tmp = fabs(z);
    }
#line 716
    if (tmp < 1e-9) {
#line 716
      z = 0.0;
    }
  }
#line 717
  return (z);
}
}
#line 734 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
double glp_mip_row_val(glp_prob *mip , int i ) 
{ 
  struct LPXCPS *cps ;
  double mipx ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 735
  cps = (struct LPXCPS *)mip->cps;
#line 737
  if (1 <= i) {
#line 737
    if (! (i <= mip->m)) {
      {
#line 738
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 738);
#line 738
      (*tmp)("glp_mip_row_val: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 738
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 738);
#line 738
    (*tmp)("glp_mip_row_val: i = %d; row number out of range\n", i);
    }
  }
#line 740
  mipx = (*(mip->row + i))->mipx;
#line 741
  if (cps->round) {
    {
#line 741
    tmp___0 = fabs(mipx);
    }
#line 741
    if (tmp___0 < 1e-9) {
#line 741
      mipx = 0.0;
    }
  }
#line 742
  return (mipx);
}
}
#line 759 "/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c"
double glp_mip_col_val(glp_prob *mip , int j ) 
{ 
  struct LPXCPS *cps ;
  double mipx ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 760
  cps = (struct LPXCPS *)mip->cps;
#line 762
  if (1 <= j) {
#line 762
    if (! (j <= mip->n)) {
      {
#line 763
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 763);
#line 763
      (*tmp)("glp_mip_col_val: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 763
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi09.c", 763);
#line 763
    (*tmp)("glp_mip_col_val: j = %d; column number out of range\n", j);
    }
  }
#line 765
  mipx = (*(mip->col + j))->mipx;
#line 766
  if (cps->round) {
    {
#line 766
    tmp___0 = fabs(mipx);
    }
#line 766
    if (tmp___0 < 1e-9) {
#line 766
      mipx = 0.0;
    }
  }
#line 767
  return (mipx);
}
}
#line 71 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
static void transform___0(NPP *npp ) 
{ 
  NPPROW *row ;
  NPPROW *prev_row ;
  NPPCOL *col ;
  NPPCOL *prev_col ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 75
  row = npp->r_tail;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 75
      goto while_break;
    }
#line 76
    prev_row = row->prev;
#line 77
    if (row->lb == - 1.7976931348623157e+308) {
#line 77
      if (row->ub == 1.7976931348623157e+308) {
        {
#line 78
        _glp_npp_free_row(npp, row);
        }
      } else {
#line 77
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 79
    if (row->lb == - 1.7976931348623157e+308) {
      {
#line 80
      _glp_npp_lteq_row(npp, row);
      }
    } else
#line 81
    if (row->ub == 1.7976931348623157e+308) {
      {
#line 82
      _glp_npp_gteq_row(npp, row);
      }
    } else
#line 83
    if (row->lb != row->ub) {
      {
#line 84
      tmp = fabs(row->lb);
#line 84
      tmp___0 = fabs(row->ub);
      }
#line 84
      if (tmp < tmp___0) {
        {
#line 85
        _glp_npp_gteq_row(npp, row);
        }
      } else {
        {
#line 87
        _glp_npp_lteq_row(npp, row);
        }
      }
    }
#line 75
    row = prev_row;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  col = npp->c_tail;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 90
      goto while_break___0;
    }
#line 91
    prev_col = col->prev;
#line 92
    if (col->lb == - 1.7976931348623157e+308) {
#line 92
      if (col->ub == 1.7976931348623157e+308) {
        {
#line 93
        _glp_npp_free_col(npp, col);
        }
      } else {
#line 92
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 94
    if (col->lb == - 1.7976931348623157e+308) {
      {
#line 95
      _glp_npp_ubnd_col(npp, col);
      }
    } else
#line 96
    if (col->ub == 1.7976931348623157e+308) {
#line 97
      if (col->lb != 0.0) {
        {
#line 98
        _glp_npp_lbnd_col(npp, col);
        }
      }
    } else
#line 100
    if (col->lb != col->ub) {
      {
#line 101
      tmp___1 = fabs(col->lb);
#line 101
      tmp___2 = fabs(col->ub);
      }
#line 101
      if (tmp___1 < tmp___2) {
        {
#line 102
        _glp_npp_lbnd_col(npp, col);
        }
      } else {
        {
#line 104
        _glp_npp_ubnd_col(npp, col);
        }
      }
      {
#line 105
      _glp_npp_dbnd_col(npp, col);
      }
    } else {
      {
#line 108
      _glp_npp_fixed_col(npp, col);
      }
    }
#line 90
    col = prev_col;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  row = npp->r_head;
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 110
    if (! ((unsigned long )row != (unsigned long )((void *)0))) {
#line 110
      goto while_break___1;
    }
#line 111
    if (row->lb == row->ub) {
#line 111
      tmp___3 = 1;
    } else {
      {
#line 111
      _glp_lib_xassert("row->lb == row->ub", "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c",
                       111);
#line 111
      tmp___3 = 1;
      }
    }
#line 110
    row = row->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 112
  col = npp->c_head;
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )col != (unsigned long )((void *)0))) {
#line 112
      goto while_break___2;
    }
#line 113
    if (col->lb == 0.0) {
#line 113
      if (col->ub == 1.7976931348623157e+308) {
#line 113
        tmp___4 = 1;
      } else {
        {
#line 113
        _glp_lib_xassert("col->lb == 0.0 && col->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c",
                         113);
#line 113
        tmp___4 = 1;
        }
      }
    } else {
      {
#line 113
      _glp_lib_xassert("col->lb == 0.0 && col->ub == +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c",
                       113);
#line 113
      tmp___4 = 1;
      }
    }
#line 112
    col = col->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 117 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
int glp_interior(glp_prob *P , glp_iptcp const   *parm ) 
{ 
  glp_iptcp _parm ;
  GLPROW *row ;
  GLPCOL *col ;
  NPP *npp ;
  glp_prob *prob ;
  int i ;
  int j ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  LIBENV *env ;
  LIBENV *tmp___1 ;
  int term_out ;
  int len ;
  int cnt ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 121
  npp = (NPP *)((void *)0);
#line 122
  prob = (glp_prob *)((void *)0);
#line 125
  if ((unsigned long )parm == (unsigned long )((void *)0)) {
    {
#line 126
    glp_init_iptcp(& _parm);
#line 126
    parm = (glp_iptcp const   *)(& _parm);
    }
  }
#line 127
  if (! (parm->msg_lev == 0)) {
#line 127
    if (! (parm->msg_lev == 1)) {
#line 127
      if (! (parm->msg_lev == 2)) {
#line 127
        if (! (parm->msg_lev == 3)) {
          {
#line 131
          tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c",
                                 131);
#line 131
          (*tmp)("glp_interior: msg_lev = %d; invalid parameter\n", parm->msg_lev);
          }
        }
      }
    }
  }
#line 133
  if (! (parm->ord_alg == 0)) {
#line 133
    if (! (parm->ord_alg == 1)) {
#line 133
      if (! (parm->ord_alg == 2)) {
#line 133
        if (! (parm->ord_alg == 3)) {
          {
#line 137
          tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c",
                                     137);
#line 137
          (*tmp___0)("glp_interior: ord_alg = %d; invalid parameter\n", parm->ord_alg);
          }
        }
      }
    }
  }
#line 140
  P->ipt_stat = 1;
#line 141
  P->ipt_obj = 0.0;
#line 143
  i = 1;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i <= P->m)) {
#line 143
      goto while_break;
    }
#line 144
    row = *(P->row + i);
#line 145
    if (row->type == 4) {
#line 145
      if (row->lb >= row->ub) {
#line 146
        if (parm->msg_lev >= 1) {
          {
#line 147
          _glp_lib_xprintf("glp_interior: row %d: lb = %g, ub = %g; incorrect bounds\n",
                           i, row->lb, row->ub);
          }
        }
#line 149
        ret = 4;
#line 150
        goto done;
      }
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  j = 1;
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (! (j <= P->n)) {
#line 153
      goto while_break___0;
    }
#line 154
    col = *(P->col + j);
#line 155
    if (col->type == 4) {
#line 155
      if (col->lb >= col->ub) {
#line 156
        if (parm->msg_lev >= 1) {
          {
#line 157
          _glp_lib_xprintf("glp_interior: column %d: lb = %g, ub = %g; incorrect bounds\n",
                           j, col->lb, col->ub);
          }
        }
#line 159
        ret = 4;
#line 160
        goto done;
      }
    }
#line 153
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 164
  if (parm->msg_lev >= 3) {
    {
#line 165
    _glp_lib_xprintf("Original LP has %d row(s), %d column(s), and %d non-zero(s)\n",
                     P->m, P->n, P->nnz);
    }
  }
  {
#line 167
  npp = _glp_npp_create_wksp();
#line 168
  _glp_npp_load_prob(npp, P, 0, 2, 1);
#line 169
  transform___0(npp);
#line 170
  prob = glp_create_prob();
#line 171
  _glp_npp_build_prob(npp, prob);
  }
#line 172
  if (parm->msg_lev >= 3) {
    {
#line 173
    _glp_lib_xprintf("Working LP has %d row(s), %d column(s), and %d non-zero(s)\n",
                     prob->m, prob->n, prob->nnz);
    }
  }
#line 177
  if (prob->m > 0) {
#line 177
    if (! (prob->n > 0)) {
#line 177
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 178
    if (parm->msg_lev >= 1) {
      {
#line 179
      _glp_lib_xprintf("glp_interior: unable to solve empty problem\n");
      }
    }
#line 180
    ret = 5;
#line 181
    goto done;
  }
  {
#line 185
  tmp___1 = _glp_lib_link_env();
#line 185
  env = tmp___1;
#line 186
  term_out = env->term_out;
#line 187
  env->term_out = 0;
#line 188
  glp_scale_prob(prob, 16);
#line 189
  env->term_out = term_out;
  }
#line 192
  if (parm->msg_lev >= 2) {
#line 192
    if (prob->m >= 200) {
#line 193
      cnt = 0;
#line 194
      j = 1;
      {
#line 194
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 194
        if (! (j <= prob->n)) {
#line 194
          goto while_break___1;
        }
        {
#line 195
        len = glp_get_mat_col(prob, j, (int *)((void *)0), (double *)((void *)0));
        }
#line 196
        if ((double )len >= 0.20 * (double )prob->m) {
#line 196
          cnt ++;
        }
#line 194
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 198
      if (cnt == 1) {
        {
#line 199
        _glp_lib_xprintf("WARNING: PROBLEM HAS ONE DENSE COLUMN\n");
        }
      } else
#line 200
      if (cnt > 0) {
        {
#line 201
        _glp_lib_xprintf("WARNING: PROBLEM HAS %d DENSE COLUMNS\n", cnt);
        }
      }
    }
  }
  {
#line 204
  ret = _glp_ipm_solve(prob, parm);
#line 206
  _glp_npp_postprocess(npp, prob);
#line 208
  _glp_npp_unload_sol(npp, P);
  }
  done: 
#line 210
  if ((unsigned long )npp != (unsigned long )((void *)0)) {
    {
#line 210
    _glp_npp_delete_wksp(npp);
    }
  }
#line 211
  if ((unsigned long )prob != (unsigned long )((void *)0)) {
    {
#line 211
    glp_delete_prob(prob);
    }
  }
#line 213
  return (ret);
}
}
#line 233 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
void glp_init_iptcp(glp_iptcp *parm ) 
{ 


  {
#line 234
  parm->msg_lev = 3;
#line 235
  parm->ord_alg = 2;
#line 236
  return;
}
}
#line 258 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
int glp_ipt_status(glp_prob *lp ) 
{ 
  int ipt_stat ;

  {
#line 259
  ipt_stat = lp->ipt_stat;
#line 260
  return (ipt_stat);
}
}
#line 277 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
double glp_ipt_obj_val(glp_prob *lp ) 
{ 
  struct LPXCPS *cps ;
  double z ;
  double tmp ;

  {
#line 278
  cps = (struct LPXCPS *)lp->cps;
#line 280
  z = lp->ipt_obj;
#line 281
  if (cps->round) {
    {
#line 281
    tmp = fabs(z);
    }
#line 281
    if (tmp < 1e-9) {
#line 281
      z = 0.0;
    }
  }
#line 282
  return (z);
}
}
#line 299 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
double glp_ipt_row_prim(glp_prob *lp , int i ) 
{ 
  struct LPXCPS *cps ;
  double pval ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 300
  cps = (struct LPXCPS *)lp->cps;
#line 302
  if (1 <= i) {
#line 302
    if (! (i <= lp->m)) {
      {
#line 303
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 303);
#line 303
      (*tmp)("glp_ipt_row_prim: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 303
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 303);
#line 303
    (*tmp)("glp_ipt_row_prim: i = %d; row number out of range\n", i);
    }
  }
#line 305
  pval = (*(lp->row + i))->pval;
#line 306
  if (cps->round) {
    {
#line 306
    tmp___0 = fabs(pval);
    }
#line 306
    if (tmp___0 < 1e-9) {
#line 306
      pval = 0.0;
    }
  }
#line 307
  return (pval);
}
}
#line 324 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
double glp_ipt_row_dual(glp_prob *lp , int i ) 
{ 
  struct LPXCPS *cps ;
  double dval ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 325
  cps = (struct LPXCPS *)lp->cps;
#line 327
  if (1 <= i) {
#line 327
    if (! (i <= lp->m)) {
      {
#line 328
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 328);
#line 328
      (*tmp)("glp_ipt_row_dual: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 328
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 328);
#line 328
    (*tmp)("glp_ipt_row_dual: i = %d; row number out of range\n", i);
    }
  }
#line 330
  dval = (*(lp->row + i))->dval;
#line 331
  if (cps->round) {
    {
#line 331
    tmp___0 = fabs(dval);
    }
#line 331
    if (tmp___0 < 1e-9) {
#line 331
      dval = 0.0;
    }
  }
#line 332
  return (dval);
}
}
#line 349 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
double glp_ipt_col_prim(glp_prob *lp , int j ) 
{ 
  struct LPXCPS *cps ;
  double pval ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 350
  cps = (struct LPXCPS *)lp->cps;
#line 352
  if (1 <= j) {
#line 352
    if (! (j <= lp->n)) {
      {
#line 353
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 353);
#line 353
      (*tmp)("glp_ipt_col_prim: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 353
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 353);
#line 353
    (*tmp)("glp_ipt_col_prim: j = %d; column number out of range\n", j);
    }
  }
#line 355
  pval = (*(lp->col + j))->pval;
#line 356
  if (cps->round) {
    {
#line 356
    tmp___0 = fabs(pval);
    }
#line 356
    if (tmp___0 < 1e-9) {
#line 356
      pval = 0.0;
    }
  }
#line 357
  return (pval);
}
}
#line 375 "/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c"
double glp_ipt_col_dual(glp_prob *lp , int j ) 
{ 
  struct LPXCPS *cps ;
  double dval ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 376
  cps = (struct LPXCPS *)lp->cps;
#line 378
  if (1 <= j) {
#line 378
    if (! (j <= lp->n)) {
      {
#line 379
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 379);
#line 379
      (*tmp)("glp_ipt_col_dual: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 379
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi08.c", 379);
#line 379
    (*tmp)("glp_ipt_col_dual: j = %d; column number out of range\n", j);
    }
  }
#line 381
  dval = (*(lp->col + j))->dval;
#line 382
  if (cps->round) {
    {
#line 382
    tmp___0 = fabs(dval);
    }
#line 382
    if (tmp___0 < 1e-9) {
#line 382
      dval = 0.0;
    }
  }
#line 383
  return (dval);
}
}
#line 766 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 79 "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c"
static void set_d_eps(mpq_t x , double val ) 
{ 
  int s ;
  int n ;
  int j ;
  double f ;
  double p ;
  double q ;
  double eps ;
  mpq_t temp ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 88
  eps = 1e-9;
#line 90
  if (- 1.7976931348623157e+308 <= val) {
#line 90
    if (val <= 1.7976931348623157e+308) {
#line 90
      tmp = 1;
    } else {
      {
#line 90
      _glp_lib_xassert("-DBL_MAX <= val && val <= +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       90);
#line 90
      tmp = 1;
      }
    }
  } else {
    {
#line 90
    _glp_lib_xassert("-DBL_MAX <= val && val <= +DBL_MAX", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     90);
#line 90
    tmp = 1;
    }
  }
  {
#line 92
  tmp___0 = floor(val);
  }
#line 92
  if (val == tmp___0) {
    {
#line 94
    _glp_mpq_set_d(x, val);
    }
#line 95
    goto done;
  }
#line 98
  if (val > 0.0) {
#line 99
    s = 1;
  } else
#line 100
  if (val < 0.0) {
#line 101
    s = -1;
  } else {
    {
#line 103
    _glp_mpq_set_si(x, 0, 1U);
    }
#line 104
    goto done;
  }
  {
#line 106
  tmp___1 = fabs(val);
#line 106
  f = frexp(tmp___1, & n);
#line 108
  _glp_lib_fp2rat(f, 0.1 * eps, & p, & q);
#line 110
  temp = _glp_mpq_init();
#line 111
  _glp_mpq_set_d(x, p);
#line 112
  _glp_mpq_set_d(temp, q);
#line 113
  _glp_mpq_div(x, x, temp);
#line 114
  _glp_mpq_set_si(temp, 1, 1U);
#line 115
  j = 1;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    tmp___2 = abs(n);
    }
#line 115
    if (! (j <= tmp___2)) {
#line 115
      goto while_break;
    }
    {
#line 116
    _glp_mpq_add(temp, temp, temp);
#line 115
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (n > 0) {
    {
#line 118
    _glp_mpq_mul(x, x, temp);
    }
  } else
#line 119
  if (n < 0) {
    {
#line 120
    _glp_mpq_div(x, x, temp);
    }
  }
  {
#line 121
  _glp_mpq_clear(temp);
  }
#line 122
  if (s < 0) {
    {
#line 122
    _glp_mpq_neg(x, x);
    }
  }
  {
#line 124
  tmp___3 = _glp_mpq_get_d(x);
#line 124
  tmp___4 = fabs(val - tmp___3);
#line 124
  tmp___5 = fabs(val);
  }
#line 124
  if (tmp___4 <= eps * (1.0 + tmp___5)) {
#line 124
    tmp___6 = 1;
  } else {
    {
#line 124
    _glp_lib_xassert("fabs(val - mpq_get_d(x)) <= eps * (1.0 + fabs(val))", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     124);
#line 124
    tmp___6 = 1;
    }
  }
  done: 
#line 125
  return;
}
}
#line 128 "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c"
static void load_data(SSX *ssx , glp_prob *lp ) 
{ 
  int m ;
  int n ;
  int nnz ;
  int j ;
  int k ;
  int type ;
  int loc ;
  int len ;
  int *ind ;
  double lb ;
  double ub ;
  double coef ;
  double *val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 130
  m = ssx->m;
#line 131
  n = ssx->n;
#line 132
  nnz = *(ssx->A_ptr + (n + 1)) - 1;
#line 135
  tmp = _glp_lpx_get_num_rows(lp);
  }
#line 135
  if (tmp == m) {
#line 135
    tmp___0 = 1;
  } else {
    {
#line 135
    _glp_lib_xassert("lpx_get_num_rows(lp) == m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     135);
#line 135
    tmp___0 = 1;
    }
  }
  {
#line 136
  tmp___1 = _glp_lpx_get_num_cols(lp);
  }
#line 136
  if (tmp___1 == n) {
#line 136
    tmp___2 = 1;
  } else {
    {
#line 136
    _glp_lib_xassert("lpx_get_num_cols(lp) == n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     136);
#line 136
    tmp___2 = 1;
    }
  }
  {
#line 137
  tmp___3 = _glp_lpx_get_num_nz(lp);
  }
#line 137
  if (tmp___3 == nnz) {
#line 137
    tmp___4 = 1;
  } else {
    {
#line 137
    _glp_lib_xassert("lpx_get_num_nz(lp) == nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     137);
#line 137
    tmp___4 = 1;
    }
  }
#line 139
  k = 1;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (k <= m + n)) {
#line 139
      goto while_break;
    }
#line 140
    if (k <= m) {
      {
#line 141
      type = _glp_lpx_get_row_type(lp, k);
#line 142
      lb = _glp_lpx_get_row_lb(lp, k);
#line 143
      ub = _glp_lpx_get_row_ub(lp, k);
      }
    } else {
      {
#line 146
      type = _glp_lpx_get_col_type(lp, k - m);
#line 147
      lb = _glp_lpx_get_col_lb(lp, k - m);
#line 148
      ub = _glp_lpx_get_col_ub(lp, k - m);
      }
    }
    {
#line 151
    if (type == 110) {
#line 151
      goto case_110;
    }
#line 152
    if (type == 111) {
#line 152
      goto case_111;
    }
#line 153
    if (type == 112) {
#line 153
      goto case_112;
    }
#line 154
    if (type == 113) {
#line 154
      goto case_113;
    }
#line 155
    if (type == 114) {
#line 155
      goto case_114;
    }
#line 156
    goto switch_default;
    case_110: /* CIL Label */ 
#line 151
    type = 0;
#line 151
    goto switch_break;
    case_111: /* CIL Label */ 
#line 152
    type = 1;
#line 152
    goto switch_break;
    case_112: /* CIL Label */ 
#line 153
    type = 2;
#line 153
    goto switch_break;
    case_113: /* CIL Label */ 
#line 154
    type = 3;
#line 154
    goto switch_break;
    case_114: /* CIL Label */ 
#line 155
    type = 4;
#line 155
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 156
    if (type != type) {
#line 156
      tmp___5 = 1;
    } else {
      {
#line 156
      _glp_lib_xassert("type != type", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       156);
#line 156
      tmp___5 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 158
    *(ssx->type + k) = type;
#line 159
    set_d_eps(*(ssx->lb + k), lb);
#line 160
    set_d_eps(*(ssx->ub + k), ub);
#line 139
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  tmp___6 = _glp_lpx_get_obj_dir(lp);
  }
  {
#line 164
  if (tmp___6 == 120) {
#line 164
    goto case_120;
  }
#line 165
  if (tmp___6 == 121) {
#line 165
    goto case_121;
  }
#line 166
  goto switch_default___0;
  case_120: /* CIL Label */ 
#line 164
  ssx->dir = 0;
#line 164
  goto switch_break___0;
  case_121: /* CIL Label */ 
#line 165
  ssx->dir = 1;
#line 165
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 166
  if ((unsigned long )lp != (unsigned long )lp) {
#line 166
    tmp___7 = 1;
  } else {
    {
#line 166
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     166);
#line 166
    tmp___7 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 169
  k = 0;
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 169
    if (! (k <= m + n)) {
#line 169
      goto while_break___0;
    }
#line 170
    if (k == 0) {
      {
#line 171
      coef = _glp_lpx_get_obj_coef(lp, 0);
      }
    } else
#line 172
    if (k <= m) {
#line 173
      coef = 0.0;
    } else {
      {
#line 175
      coef = _glp_lpx_get_obj_coef(lp, k - m);
      }
    }
    {
#line 176
    set_d_eps(*(ssx->coef + k), coef);
#line 169
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 179
  tmp___8 = _glp_lib_xcalloc(1 + m, (int )sizeof(int ));
#line 179
  ind = (int *)tmp___8;
#line 180
  tmp___9 = _glp_lib_xcalloc(1 + m, (int )sizeof(double ));
#line 180
  val = (double *)tmp___9;
#line 181
  loc = 0;
#line 182
  j = 1;
  }
  {
#line 182
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 182
    if (! (j <= n)) {
#line 182
      goto while_break___1;
    }
    {
#line 183
    *(ssx->A_ptr + j) = loc + 1;
#line 184
    len = _glp_lpx_get_mat_col(lp, j, ind, val);
#line 185
    k = 1;
    }
    {
#line 185
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 185
      if (! (k <= len)) {
#line 185
        goto while_break___2;
      }
      {
#line 186
      loc ++;
#line 187
      *(ssx->A_ind + loc) = *(ind + k);
#line 188
      set_d_eps(*(ssx->A_val + loc), *(val + k));
#line 185
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 182
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 191
  if (loc == nnz) {
#line 191
    tmp___10 = 1;
  } else {
    {
#line 191
    _glp_lib_xassert("loc == nnz", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     191);
#line 191
    tmp___10 = 1;
    }
  }
  {
#line 192
  _glp_lib_xfree((void *)ind);
#line 193
  _glp_lib_xfree((void *)val);
  }
#line 194
  return;
}
}
#line 197 "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c"
static int load_basis(SSX *ssx , glp_prob *lp ) 
{ 
  int m ;
  int n ;
  int *type ;
  int *stat ;
  int *Q_row ;
  int *Q_col ;
  int i ;
  int j ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 199
  m = ssx->m;
#line 200
  n = ssx->n;
#line 201
  type = ssx->type;
#line 202
  stat = ssx->stat;
#line 203
  Q_row = ssx->Q_row;
#line 204
  Q_col = ssx->Q_col;
#line 206
  tmp = _glp_lpx_get_num_rows(lp);
  }
#line 206
  if (tmp == m) {
#line 206
    tmp___0 = 1;
  } else {
    {
#line 206
    _glp_lib_xassert("lpx_get_num_rows(lp) == m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     206);
#line 206
    tmp___0 = 1;
    }
  }
  {
#line 207
  tmp___1 = _glp_lpx_get_num_cols(lp);
  }
#line 207
  if (tmp___1 == n) {
#line 207
    tmp___2 = 1;
  } else {
    {
#line 207
    _glp_lib_xassert("lpx_get_num_cols(lp) == n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     207);
#line 207
    tmp___2 = 1;
    }
  }
#line 209
  k = 1;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (k <= m + n)) {
#line 209
      goto while_break;
    }
#line 210
    if (k <= m) {
      {
#line 211
      *(stat + k) = _glp_lpx_get_row_stat(lp, k);
      }
    } else {
      {
#line 213
      *(stat + k) = _glp_lpx_get_col_stat(lp, k - m);
      }
    }
    {
#line 215
    if (*(stat + k) == 140) {
#line 215
      goto case_140;
    }
#line 218
    if (*(stat + k) == 141) {
#line 218
      goto case_141;
    }
#line 222
    if (*(stat + k) == 142) {
#line 222
      goto case_142;
    }
#line 226
    if (*(stat + k) == 143) {
#line 226
      goto case_143;
    }
#line 230
    if (*(stat + k) == 144) {
#line 230
      goto case_144;
    }
#line 234
    goto switch_default;
    case_140: /* CIL Label */ 
#line 216
    *(stat + k) = 0;
#line 217
    goto switch_break;
    case_141: /* CIL Label */ 
#line 219
    *(stat + k) = 1;
#line 220
    if (*(type + k) == 1) {
#line 220
      tmp___3 = 1;
    } else
#line 220
    if (*(type + k) == 3) {
#line 220
      tmp___3 = 1;
    } else {
      {
#line 220
      _glp_lib_xassert("type[k] == SSX_LO || type[k] == SSX_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       220);
#line 220
      tmp___3 = 1;
      }
    }
#line 221
    goto switch_break;
    case_142: /* CIL Label */ 
#line 223
    *(stat + k) = 2;
#line 224
    if (*(type + k) == 2) {
#line 224
      tmp___4 = 1;
    } else
#line 224
    if (*(type + k) == 3) {
#line 224
      tmp___4 = 1;
    } else {
      {
#line 224
      _glp_lib_xassert("type[k] == SSX_UP || type[k] == SSX_DB", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       224);
#line 224
      tmp___4 = 1;
      }
    }
#line 225
    goto switch_break;
    case_143: /* CIL Label */ 
#line 227
    *(stat + k) = 3;
#line 228
    if (*(type + k) == 0) {
#line 228
      tmp___5 = 1;
    } else {
      {
#line 228
      _glp_lib_xassert("type[k] == SSX_FR", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       228);
#line 228
      tmp___5 = 1;
      }
    }
#line 229
    goto switch_break;
    case_144: /* CIL Label */ 
#line 231
    *(stat + k) = 4;
#line 232
    if (*(type + k) == 4) {
#line 232
      tmp___6 = 1;
    } else {
      {
#line 232
      _glp_lib_xassert("type[k] == SSX_FX", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       232);
#line 232
      tmp___6 = 1;
      }
    }
#line 233
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 235
    if ((unsigned long )stat != (unsigned long )stat) {
#line 235
      tmp___7 = 1;
    } else {
      {
#line 235
      _glp_lib_xassert("stat != stat", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       235);
#line 235
      tmp___7 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 209
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  j = 0;
#line 239
  i = j;
#line 240
  k = 1;
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    if (! (k <= m + n)) {
#line 240
      goto while_break___0;
    }
#line 241
    if (*(stat + k) == 0) {
#line 242
      i ++;
#line 243
      if (i > m) {
#line 243
        return (1);
      }
#line 244
      *(Q_row + k) = i;
#line 244
      *(Q_col + i) = k;
    } else {
#line 247
      j ++;
#line 248
      if (j > n) {
#line 248
        return (1);
      }
#line 249
      *(Q_row + k) = m + j;
#line 249
      *(Q_col + (m + j)) = k;
    }
#line 240
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 252
  if (i == m) {
#line 252
    if (j == n) {
#line 252
      tmp___8 = 1;
    } else {
      {
#line 252
      _glp_lib_xassert("i == m && j == n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       252);
#line 252
      tmp___8 = 1;
      }
    }
  } else {
    {
#line 252
    _glp_lib_xassert("i == m && j == n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     252);
#line 252
    tmp___8 = 1;
    }
  }
#line 253
  return (0);
}
}
#line 256 "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c"
int glp_exact(glp_prob *lp , glp_smcp const   *parm ) 
{ 
  glp_smcp _parm ;
  SSX *ssx ;
  int m ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int nnz ;
  int tmp___1 ;
  int i ;
  int j ;
  int k ;
  int type ;
  int pst ;
  int dst ;
  int ret ;
  int *stat ;
  double lb ;
  double ub ;
  double *prim ;
  double *dual ;
  double sum ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  double tmp___17 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
  {
#line 259
  tmp = _glp_lpx_get_num_rows(lp);
#line 259
  m = tmp;
#line 260
  tmp___0 = _glp_lpx_get_num_cols(lp);
#line 260
  n = tmp___0;
#line 261
  tmp___1 = _glp_lpx_get_num_nz(lp);
#line 261
  nnz = tmp___1;
  }
#line 264
  if ((unsigned long )parm == (unsigned long )((void *)0)) {
    {
#line 265
    parm = (glp_smcp const   *)(& _parm);
#line 265
    glp_init_smcp((glp_smcp *)parm);
    }
  }
#line 267
  if (parm->it_lim < 0) {
    {
#line 268
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                               268);
#line 268
    (*tmp___2)("glp_exact: it_lim = %d; invalid parameter\n", parm->it_lim);
    }
  }
#line 270
  if (parm->tm_lim < 0) {
    {
#line 271
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                               271);
#line 271
    (*tmp___3)("glp_exact: tm_lim = %d; invalid parameter\n", parm->tm_lim);
    }
  }
#line 274
  if (m > 0) {
#line 274
    if (! (n > 0)) {
      {
#line 275
      _glp_lib_xprintf("glp_exact: problem has no rows/columns\n");
      }
#line 276
      return (5);
    }
  } else {
    {
#line 275
    _glp_lib_xprintf("glp_exact: problem has no rows/columns\n");
    }
#line 276
    return (5);
  }
#line 280
  tmp___4 = 1;
#line 280
  lp->dbs_stat = tmp___4;
#line 280
  lp->pbs_stat = tmp___4;
#line 281
  lp->obj_val = 0.0;
#line 282
  lp->some = 0;
#line 285
  k = 1;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (k <= m + n)) {
#line 285
      goto while_break;
    }
#line 286
    if (k <= m) {
      {
#line 287
      type = _glp_lpx_get_row_type(lp, k);
#line 288
      lb = _glp_lpx_get_row_lb(lp, k);
#line 289
      ub = _glp_lpx_get_row_ub(lp, k);
      }
    } else {
      {
#line 292
      type = _glp_lpx_get_col_type(lp, k - m);
#line 293
      lb = _glp_lpx_get_col_lb(lp, k - m);
#line 294
      ub = _glp_lpx_get_col_ub(lp, k - m);
      }
    }
#line 296
    if (type == 113) {
#line 296
      if (lb >= ub) {
#line 297
        if (k <= m) {
#line 297
          tmp___5 = k;
        } else {
#line 297
          tmp___5 = k - m;
        }
#line 297
        if (k <= m) {
#line 297
          tmp___6 = "row";
        } else {
#line 297
          tmp___6 = "column";
        }
        {
#line 297
        _glp_lib_xprintf("glp_exact: %s %d has invalid bounds\n", tmp___6, tmp___5);
        }
#line 299
        return (4);
      }
    }
#line 285
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  _glp_lib_xprintf("glp_exact: %d rows, %d columns, %d non-zeros\n", m, n, nnz);
#line 308
  _glp_lib_xprintf("GLPK bignum module is being used\n");
#line 309
  _glp_lib_xprintf("(Consider installing GNU MP to attain a much better performance.)\n");
#line 312
  ssx = _glp_ssx_create(m, n, nnz);
#line 314
  load_data(ssx, lp);
#line 316
  tmp___7 = load_basis(ssx, lp);
  }
#line 316
  if (tmp___7) {
    {
#line 317
    _glp_lib_xprintf("glp_exact: initial LP basis is invalid\n");
#line 318
    ret = 1;
    }
#line 319
    goto done;
  }
  {
#line 327
  ssx->it_lim = (int )parm->it_lim;
#line 328
  ssx->it_cnt = lp->it_cnt;
#line 329
  ssx->tm_lim = (double )parm->tm_lim / 1000.0;
#line 331
  ssx->out_frq = 5.0;
#line 332
  ssx->tm_beg = _glp_lib_xtime();
#line 333
  ssx->tm_lag = _glp_lib_xlset(0);
#line 335
  ret = _glp_ssx_driver(ssx);
#line 342
  lp->it_cnt = ssx->it_cnt;
  }
  {
#line 346
  if (ret == 0) {
#line 346
    goto case_0;
  }
#line 351
  if (ret == 1) {
#line 351
    goto case_1;
  }
#line 356
  if (ret == 2) {
#line 356
    goto case_2;
  }
#line 366
  if (ret == 3) {
#line 366
    goto case_3;
  }
#line 371
  if (ret == 4) {
#line 371
    goto case_4;
  }
#line 376
  if (ret == 5) {
#line 376
    goto case_5;
  }
#line 381
  if (ret == 6) {
#line 381
    goto case_6;
  }
#line 386
  if (ret == 7) {
#line 386
    goto case_7;
  }
#line 390
  goto switch_default;
  case_0: /* CIL Label */ 
#line 348
  ret = 0;
#line 349
  pst = 133;
#line 349
  dst = 137;
#line 350
  goto switch_break;
  case_1: /* CIL Label */ 
#line 353
  ret = 0;
#line 354
  pst = 135;
#line 354
  dst = 138;
#line 355
  goto switch_break;
  case_2: /* CIL Label */ 
#line 358
  ret = 0;
#line 359
  pst = 133;
#line 359
  dst = 139;
#line 361
  if (1 <= ssx->q) {
#line 361
    if (ssx->q <= n) {
#line 361
      tmp___8 = 1;
    } else {
      {
#line 361
      _glp_lib_xassert("1 <= ssx->q && ssx->q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       361);
#line 361
      tmp___8 = 1;
      }
    }
  } else {
    {
#line 361
    _glp_lib_xassert("1 <= ssx->q && ssx->q <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     361);
#line 361
    tmp___8 = 1;
    }
  }
#line 362
  lp->some = *(ssx->Q_col + (m + ssx->q));
#line 363
  if (1 <= lp->some) {
#line 363
    if (lp->some <= m + n) {
#line 363
      tmp___9 = 1;
    } else {
      {
#line 363
      _glp_lib_xassert("1 <= lp->some && lp->some <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                       363);
#line 363
      tmp___9 = 1;
      }
    }
  } else {
    {
#line 363
    _glp_lib_xassert("1 <= lp->some && lp->some <= m+n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     363);
#line 363
    tmp___9 = 1;
    }
  }
#line 365
  goto switch_break;
  case_3: /* CIL Label */ 
#line 368
  ret = 8;
#line 369
  pst = 134;
#line 369
  dst = 138;
#line 370
  goto switch_break;
  case_4: /* CIL Label */ 
#line 373
  ret = 8;
#line 374
  pst = 133;
#line 374
  dst = 138;
#line 375
  goto switch_break;
  case_5: /* CIL Label */ 
#line 378
  ret = 9;
#line 379
  pst = 134;
#line 379
  dst = 138;
#line 380
  goto switch_break;
  case_6: /* CIL Label */ 
#line 383
  ret = 9;
#line 384
  pst = 133;
#line 384
  dst = 138;
#line 385
  goto switch_break;
  case_7: /* CIL Label */ 
#line 388
  ret = 2;
#line 389
  goto done;
  switch_default: /* CIL Label */ 
#line 391
  if (ret != ret) {
#line 391
    tmp___10 = 1;
  } else {
    {
#line 391
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                     391);
#line 391
    tmp___10 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  tmp___11 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(int ));
#line 394
  stat = (int *)tmp___11;
#line 395
  tmp___12 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 395
  prim = (double *)tmp___12;
#line 396
  tmp___13 = _glp_lib_xcalloc((1 + m) + n, (int )sizeof(double ));
#line 396
  dual = (double *)tmp___13;
#line 397
  k = 1;
  }
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (! (k <= m + n)) {
#line 397
      goto while_break___0;
    }
#line 398
    if (*(ssx->stat + k) == 0) {
#line 399
      i = *(ssx->Q_row + k);
#line 400
      if (1 <= i) {
#line 400
        if (i <= m) {
#line 400
          tmp___14 = 1;
        } else {
          {
#line 400
          _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                           400);
#line 400
          tmp___14 = 1;
          }
        }
      } else {
        {
#line 400
        _glp_lib_xassert("1 <= i && i <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                         400);
#line 400
        tmp___14 = 1;
        }
      }
      {
#line 401
      *(stat + k) = 140;
#line 402
      *(prim + k) = _glp_mpq_get_d(*(ssx->bbar + i));
#line 403
      *(dual + k) = 0.0;
      }
    } else {
#line 406
      j = *(ssx->Q_row + k) - m;
#line 407
      if (1 <= j) {
#line 407
        if (j <= n) {
#line 407
          tmp___15 = 1;
        } else {
          {
#line 407
          _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                           407);
#line 407
          tmp___15 = 1;
          }
        }
      } else {
        {
#line 407
        _glp_lib_xassert("1 <= j && j <= n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                         407);
#line 407
        tmp___15 = 1;
        }
      }
      {
#line 409
      if (*(ssx->stat + k) == 3) {
#line 409
        goto case_3___0;
      }
#line 413
      if (*(ssx->stat + k) == 1) {
#line 413
        goto case_1___0;
      }
#line 417
      if (*(ssx->stat + k) == 2) {
#line 417
        goto case_2___0;
      }
#line 421
      if (*(ssx->stat + k) == 4) {
#line 421
        goto case_4___0;
      }
#line 425
      goto switch_default___0;
      case_3___0: /* CIL Label */ 
#line 410
      *(stat + k) = 143;
#line 411
      *(prim + k) = 0.0;
#line 412
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 414
      *(stat + k) = 141;
#line 415
      *(prim + k) = _glp_mpq_get_d(*(ssx->lb + k));
      }
#line 416
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 418
      *(stat + k) = 142;
#line 419
      *(prim + k) = _glp_mpq_get_d(*(ssx->ub + k));
      }
#line 420
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 422
      *(stat + k) = 144;
#line 423
      *(prim + k) = _glp_mpq_get_d(*(ssx->lb + k));
      }
#line 424
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 426
      if ((unsigned long )ssx != (unsigned long )ssx) {
#line 426
        tmp___16 = 1;
      } else {
        {
#line 426
        _glp_lib_xassert("ssx != ssx", "/home/wslee/benchmarks/glpk-4.38/src/glpapi07.c",
                         426);
#line 426
        tmp___16 = 1;
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 428
      *(dual + k) = _glp_mpq_get_d(*(ssx->cbar + j));
      }
    }
#line 397
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 432
  pst = (pst - 132) + 1;
#line 433
  dst = (dst - 136) + 1;
#line 434
  k = 1;
  {
#line 434
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 434
    if (! (k <= m + n)) {
#line 434
      goto while_break___1;
    }
#line 435
    *(stat + k) = (*(stat + k) - 140) + 1;
#line 434
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 436
  sum = _glp_lpx_get_obj_coef(lp, 0);
#line 437
  j = 1;
  }
  {
#line 437
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 437
    if (! (j <= n)) {
#line 437
      goto while_break___2;
    }
    {
#line 438
    tmp___17 = _glp_lpx_get_obj_coef(lp, j);
#line 438
    sum += tmp___17 * *(prim + (m + j));
#line 437
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 439
  _glp_1px_put_solution(lp, 1, (int const   *)(& pst), (int const   *)(& dst), (double const   *)(& sum),
                        (int const   *)(stat + 0), (double const   *)(prim + 0), (double const   *)(dual + 0),
                        (int const   *)(stat + m), (double const   *)(prim + m), (double const   *)(dual + m));
#line 441
  _glp_lib_xfree((void *)stat);
#line 442
  _glp_lib_xfree((void *)prim);
#line 443
  _glp_lib_xfree((void *)dual);
  }
  done: 
  {
#line 445
  _glp_ssx_delete(ssx);
  }
#line 447
  return (ret);
}
}
#line 106 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
static void trivial1(glp_prob *lp , glp_smcp const   *parm ) 
{ 
  int j ;
  double dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  GLPCOL *col ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 110
  if (lp->m == 0) {
#line 110
    tmp = 1;
  } else {
    {
#line 110
    _glp_lib_xassert("lp->m == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     110);
#line 110
    tmp = 1;
    }
  }
  {
#line 112
  if (lp->dir == 1) {
#line 112
    goto case_1;
  }
#line 113
  if (lp->dir == 2) {
#line 113
    goto case_2;
  }
#line 114
  goto switch_default;
  case_1: /* CIL Label */ 
#line 112
  dir = 1.0;
#line 112
  goto switch_break;
  case_2: /* CIL Label */ 
#line 113
  dir = - 1.0;
#line 113
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 114
  if ((unsigned long )lp != (unsigned long )lp) {
#line 114
    tmp___0 = 1;
  } else {
    {
#line 114
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     114);
#line 114
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 116
  tmp___1 = 2;
#line 116
  lp->dbs_stat = tmp___1;
#line 116
  lp->pbs_stat = tmp___1;
#line 117
  lp->obj_val = lp->c0;
#line 118
  lp->some = 0;
#line 119
  j = 1;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (j <= lp->n)) {
#line 119
      goto while_break;
    }
#line 120
    col = *(lp->col + j);
#line 121
    col->dual = col->coef;
    {
#line 123
    if (col->type == 1) {
#line 123
      goto case_1___0;
    }
#line 131
    if (col->type == 2) {
#line 131
      goto case_2___0;
    }
#line 137
    if (col->type == 3) {
#line 137
      goto case_3;
    }
#line 143
    if (col->type == 4) {
#line 143
      goto case_4;
    }
#line 150
    if (col->type == 5) {
#line 150
      goto case_5;
    }
#line 154
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 124
    if (dir * col->dual < - 1e-7) {
#line 125
      lp->dbs_stat = 4;
    }
#line 126
    if (dir * col->dual > 1e-7) {
#line 127
      lp->dbs_stat = 4;
    }
#line 128
    col->stat = 4;
#line 129
    col->prim = 0.0;
#line 130
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 132
    if (dir * col->dual < - 1e-7) {
#line 133
      lp->dbs_stat = 4;
    }
    lo: 
#line 134
    col->stat = 2;
#line 135
    col->prim = col->lb;
#line 136
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 138
    if (dir * col->dual > 1e-7) {
#line 139
      lp->dbs_stat = 4;
    }
    up: 
#line 140
    col->stat = 3;
#line 141
    col->prim = col->ub;
#line 142
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 144
    if (dir * col->dual < 0.0) {
#line 144
      goto up;
    }
#line 145
    if (dir * col->dual > 0.0) {
#line 145
      goto lo;
    }
    {
#line 146
    tmp___2 = fabs(col->lb);
#line 146
    tmp___3 = fabs(col->ub);
    }
#line 146
    if (tmp___2 <= tmp___3) {
#line 147
      goto lo;
    } else {
#line 149
      goto up;
    }
    case_5: /* CIL Label */ 
#line 151
    col->stat = 5;
#line 152
    col->prim = col->lb;
#line 153
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 155
    if ((unsigned long )lp != (unsigned long )lp) {
#line 155
      tmp___4 = 1;
    } else {
      {
#line 155
      _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                       155);
#line 155
      tmp___4 = 1;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 157
    lp->obj_val += col->coef * col->prim;
#line 158
    if (lp->dbs_stat == 4) {
#line 158
      if (lp->some == 0) {
#line 159
        lp->some = j;
      }
    }
#line 119
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (parm->msg_lev >= 2) {
#line 161
    if (parm->out_dly == 0) {
      {
#line 162
      _glp_lib_xprintf("~%6d:   objval = %17.9e   infeas = %17.9e\n", lp->it_cnt,
                       lp->obj_val, 0.0);
      }
#line 164
      if (parm->msg_lev >= 3) {
#line 165
        if (lp->dbs_stat == 2) {
          {
#line 166
          _glp_lib_xprintf("OPTIMAL SOLUTION FOUND\n");
          }
        } else {
          {
#line 168
          _glp_lib_xprintf("PROBLEM HAS UNBOUNDED SOLUTION\n");
          }
        }
      }
    }
  }
#line 171
  return;
}
}
#line 174 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
static void trivial2(glp_prob *lp , glp_smcp const   *parm ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  GLPROW *row ;
  double tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 177
  if (lp->n == 0) {
#line 177
    tmp = 1;
  } else {
    {
#line 177
    _glp_lib_xassert("lp->n == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     177);
#line 177
    tmp = 1;
    }
  }
#line 178
  tmp___0 = 2;
#line 178
  lp->dbs_stat = tmp___0;
#line 178
  lp->pbs_stat = tmp___0;
#line 179
  lp->obj_val = lp->c0;
#line 180
  lp->some = 0;
#line 181
  i = 1;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i <= lp->m)) {
#line 181
      goto while_break;
    }
#line 182
    row = *(lp->row + i);
#line 183
    row->stat = 1;
#line 184
    tmp___1 = 0.0;
#line 184
    row->dual = tmp___1;
#line 184
    row->prim = tmp___1;
    {
#line 186
    if (row->type == 1) {
#line 186
      goto case_1;
    }
#line 188
    if (row->type == 2) {
#line 188
      goto case_2;
    }
#line 192
    if (row->type == 3) {
#line 192
      goto case_3;
    }
#line 197
    if (row->type == 5) {
#line 197
      goto case_5;
    }
#line 197
    if (row->type == 4) {
#line 197
      goto case_5;
    }
#line 203
    goto switch_default;
    case_1: /* CIL Label */ 
#line 187
    goto switch_break;
    case_2: /* CIL Label */ 
#line 189
    if (row->lb > 1e-8) {
#line 190
      lp->pbs_stat = 4;
    }
#line 191
    goto switch_break;
    case_3: /* CIL Label */ 
#line 193
    if (row->ub < - 1e-8) {
#line 194
      lp->pbs_stat = 4;
    }
#line 195
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 198
    if (row->lb > 1e-8) {
#line 199
      lp->pbs_stat = 4;
    }
#line 200
    if (row->ub < - 1e-8) {
#line 201
      lp->pbs_stat = 4;
    }
#line 202
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 204
    if ((unsigned long )lp != (unsigned long )lp) {
#line 204
      tmp___2 = 1;
    } else {
      {
#line 204
      _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                       204);
#line 204
      tmp___2 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  if (parm->msg_lev >= 2) {
#line 207
    if (parm->out_dly == 0) {
      {
#line 208
      _glp_lib_xprintf("~%6d:   objval = %17.9e   infeas = %17.9e\n", lp->it_cnt,
                       lp->obj_val);
      }
#line 210
      if (parm->msg_lev >= 3) {
#line 211
        if (lp->pbs_stat == 2) {
          {
#line 212
          _glp_lib_xprintf("OPTIMAL SOLUTION FOUND\n");
          }
        } else {
          {
#line 214
          _glp_lib_xprintf("PROBLEM HAS NO FEASIBLE SOLUTION\n");
          }
        }
      }
    }
  }
#line 217
  return;
}
}
#line 221 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
static int simplex1(glp_prob *lp , glp_smcp const   *parm ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  glp_smcp parm1 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 224
  tmp___0 = glp_bf_exists(lp);
  }
#line 224
  if (! tmp___0) {
    {
#line 225
    ret = glp_factorize(lp);
    }
    {
#line 227
    if (ret == 0) {
#line 227
      goto case_0;
    }
#line 229
    if (ret == 1) {
#line 229
      goto case_1;
    }
#line 233
    if (ret == 2) {
#line 233
      goto case_2;
    }
#line 237
    if (ret == 3) {
#line 237
      goto case_3;
    }
#line 242
    goto switch_default;
    case_0: /* CIL Label */ 
#line 228
    goto switch_break;
    case_1: /* CIL Label */ 
#line 230
    if (parm->msg_lev >= 1) {
      {
#line 231
      _glp_lib_xprintf("glp_simplex: initial basis is invalid\n");
      }
    }
#line 232
    goto done;
    case_2: /* CIL Label */ 
#line 234
    if (parm->msg_lev >= 1) {
      {
#line 235
      _glp_lib_xprintf("glp_simplex: initial basis is singular\n");
      }
    }
#line 236
    goto done;
    case_3: /* CIL Label */ 
#line 238
    if (parm->msg_lev >= 1) {
      {
#line 239
      _glp_lib_xprintf("glp_simplex: initial basis is ill-conditioned\n");
      }
    }
#line 241
    goto done;
    switch_default: /* CIL Label */ 
#line 243
    if (ret != ret) {
#line 243
      tmp = 1;
    } else {
      {
#line 243
      _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                       243);
#line 243
      tmp = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 247
  if (parm->meth == 1) {
#line 247
    goto case_1___0;
  }
#line 250
  if (parm->meth == 2) {
#line 250
    goto case_2___0;
  }
#line 264
  if (parm->meth == 3) {
#line 264
    goto case_3___0;
  }
#line 267
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 248
  ret = _glp_spx_primal(lp, parm);
  }
#line 249
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 251
  parm1 = *parm;
#line 257
  ret = _glp_spx_dual(lp, (glp_smcp const   *)(& parm1));
  }
#line 259
  if (ret == 5) {
#line 259
    if (lp->valid) {
      {
#line 260
      ret = _glp_spx_primal(lp, parm);
      }
    }
  }
#line 263
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 265
  ret = _glp_spx_dual(lp, parm);
  }
#line 266
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 268
  if ((unsigned long )parm != (unsigned long )parm) {
#line 268
    tmp___1 = 1;
  } else {
    {
#line 268
    _glp_lib_xassert("parm != parm", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     268);
#line 268
    tmp___1 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  done: 
#line 270
  return (ret);
}
}
#line 274 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
static int simplex2(glp_prob *orig , glp_smcp const   *parm ) 
{ 
  LPP *lpp ;
  glp_prob *prob ;
  glp_bfcp bfcp ;
  int orig_m ;
  int orig_n ;
  int orig_nnz ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int m ;
  int tmp___7 ;
  int n ;
  int tmp___8 ;
  int nnz ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  LIBENV *env ;
  LIBENV *tmp___13 ;
  int term_out ;
  LIBENV *env___0 ;
  LIBENV *tmp___14 ;
  int term_out___0 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 280
  orig_m = glp_get_num_rows(orig);
#line 281
  orig_n = glp_get_num_cols(orig);
#line 282
  orig_nnz = glp_get_num_nz(orig);
  }
#line 283
  if (parm->msg_lev >= 3) {
#line 284
    if (orig_nnz == 1) {
#line 284
      tmp = "";
    } else {
#line 284
      tmp = "s";
    }
#line 284
    if (orig_n == 1) {
#line 284
      tmp___0 = "";
    } else {
#line 284
      tmp___0 = "s";
    }
#line 284
    if (orig_m == 1) {
#line 284
      tmp___1 = "";
    } else {
#line 284
      tmp___1 = "s";
    }
    {
#line 284
    _glp_lib_xprintf("glp_simplex: original LP has %d row%s, %d column%s, %d non-zero%s\n",
                     orig_m, tmp___1, orig_n, tmp___0, orig_nnz, tmp);
    }
  }
#line 291
  if (orig_m > 0) {
#line 291
    if (orig_n > 0) {
#line 291
      tmp___2 = 1;
    } else {
      {
#line 291
      _glp_lib_xassert("orig_m > 0 && orig_n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                       291);
#line 291
      tmp___2 = 1;
      }
    }
  } else {
    {
#line 291
    _glp_lib_xassert("orig_m > 0 && orig_n > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     291);
#line 291
    tmp___2 = 1;
    }
  }
  {
#line 293
  lpp = _glp_lpp_create_wksp();
#line 295
  _glp_lpp_load_orig(lpp, orig);
#line 297
  ret = _glp_lpp_presolve(lpp);
  }
  {
#line 299
  if (ret == 0) {
#line 299
    goto case_0;
  }
#line 302
  if (ret == 1) {
#line 302
    goto case_1;
  }
#line 308
  if (ret == 2) {
#line 308
    goto case_2;
  }
#line 314
  goto switch_default;
  case_0: /* CIL Label */ 
#line 301
  goto switch_break;
  case_1: /* CIL Label */ 
#line 304
  if (parm->msg_lev >= 3) {
    {
#line 305
    _glp_lib_xprintf("PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\n");
    }
  }
  {
#line 306
  _glp_lpp_delete_wksp(lpp);
  }
#line 307
  return (10);
  case_2: /* CIL Label */ 
#line 310
  if (parm->msg_lev >= 3) {
    {
#line 311
    _glp_lib_xprintf("PROBLEM HAS NO DUAL FEASIBLE SOLUTION\n");
    }
  }
  {
#line 312
  _glp_lpp_delete_wksp(lpp);
  }
#line 313
  return (11);
  switch_default: /* CIL Label */ 
#line 315
  if (ret != ret) {
#line 315
    tmp___3 = 1;
  } else {
    {
#line 315
    _glp_lib_xassert("ret != ret", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     315);
#line 315
    tmp___3 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 319
  if ((unsigned long )lpp->row_ptr == (unsigned long )((void *)0)) {
#line 319
    goto _L;
  } else
#line 319
  if ((unsigned long )lpp->col_ptr == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 320
    if ((unsigned long )lpp->row_ptr == (unsigned long )((void *)0)) {
#line 320
      tmp___4 = 1;
    } else {
      {
#line 320
      _glp_lib_xassert("lpp->row_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                       320);
#line 320
      tmp___4 = 1;
      }
    }
#line 321
    if ((unsigned long )lpp->col_ptr == (unsigned long )((void *)0)) {
#line 321
      tmp___5 = 1;
    } else {
      {
#line 321
      _glp_lib_xassert("lpp->col_ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                       321);
#line 321
      tmp___5 = 1;
      }
    }
#line 322
    if (parm->msg_lev >= 3) {
#line 323
      if (lpp->orig_dir == 120) {
#line 323
        tmp___6 = lpp->c0;
      } else {
#line 323
        tmp___6 = - lpp->c0;
      }
      {
#line 323
      _glp_lib_xprintf("Objective value = %.10g\n", tmp___6);
#line 325
      _glp_lib_xprintf("OPTIMAL SOLUTION FOUND BY LP PRESOLVER\n");
      }
    }
    {
#line 328
    _glp_lpp_alloc_sol(lpp);
    }
#line 329
    goto post;
  }
  {
#line 332
  prob = _glp_lpp_build_prob(lpp);
  }
#line 333
  if (parm->msg_lev >= 3) {
    {
#line 334
    tmp___7 = glp_get_num_rows(prob);
#line 334
    m = tmp___7;
#line 335
    tmp___8 = glp_get_num_cols(prob);
#line 335
    n = tmp___8;
#line 336
    tmp___9 = glp_get_num_nz(prob);
#line 336
    nnz = tmp___9;
    }
#line 337
    if (nnz == 1) {
#line 337
      tmp___10 = "";
    } else {
#line 337
      tmp___10 = "s";
    }
#line 337
    if (n == 1) {
#line 337
      tmp___11 = "";
    } else {
#line 337
      tmp___11 = "s";
    }
#line 337
    if (m == 1) {
#line 337
      tmp___12 = "";
    } else {
#line 337
      tmp___12 = "s";
    }
    {
#line 337
    _glp_lib_xprintf("glp_simplex: presolved LP has %d row%s, %d column%s, %d non-zero%s\n",
                     m, tmp___12, n, tmp___11, nnz, tmp___10);
    }
  }
  {
#line 342
  glp_get_bfcp(orig, & bfcp);
#line 343
  glp_set_bfcp(prob, (glp_bfcp const   *)(& bfcp));
#line 345
  tmp___13 = _glp_lib_link_env();
#line 345
  env = tmp___13;
#line 346
  term_out = env->term_out;
  }
#line 347
  if (! term_out) {
#line 348
    env->term_out = 0;
  } else
#line 347
  if (parm->msg_lev < 3) {
#line 348
    env->term_out = 0;
  } else {
#line 350
    env->term_out = 1;
  }
  {
#line 351
  glp_scale_prob(prob, 128);
#line 352
  env->term_out = term_out;
#line 355
  tmp___14 = _glp_lib_link_env();
#line 355
  env___0 = tmp___14;
#line 356
  term_out___0 = env___0->term_out;
  }
#line 357
  if (! term_out___0) {
#line 358
    env___0->term_out = 0;
  } else
#line 357
  if (parm->msg_lev < 3) {
#line 358
    env___0->term_out = 0;
  } else {
#line 360
    env___0->term_out = 1;
  }
  {
#line 361
  _glp_lpx_adv_basis(prob);
#line 362
  env___0->term_out = term_out___0;
#line 365
  prob->it_cnt = orig->it_cnt;
#line 366
  ret = simplex1(prob, parm);
#line 367
  orig->it_cnt = prob->it_cnt;
#line 369
  tmp___17 = glp_get_status(prob);
  }
#line 369
  if (tmp___17 != 5) {
#line 370
    if (parm->msg_lev >= 1) {
      {
#line 371
      _glp_lib_xprintf("glp_simplex: cannot recover undefined or non-optimal solution\n");
      }
    }
#line 373
    if (ret == 0) {
      {
#line 374
      tmp___16 = glp_get_prim_stat(prob);
      }
#line 374
      if (tmp___16 == 4) {
#line 375
        ret = 10;
      } else {
        {
#line 376
        tmp___15 = glp_get_dual_stat(prob);
        }
#line 376
        if (tmp___15 == 4) {
#line 377
          ret = 11;
        }
      }
    }
    {
#line 379
    glp_delete_prob(prob);
#line 380
    _glp_lpp_delete_wksp(lpp);
    }
#line 381
    return (ret);
  }
  {
#line 384
  _glp_lpp_alloc_sol(lpp);
#line 387
  _glp_lpp_load_sol(lpp, prob);
#line 389
  glp_delete_prob(prob);
  }
  post: 
  {
#line 391
  _glp_lpp_postsolve(lpp);
#line 394
  _glp_lpp_unload_sol(lpp, orig);
#line 396
  _glp_lpp_delete_wksp(lpp);
  }
#line 398
  return (0);
}
}
#line 401 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
int glp_simplex(glp_prob *lp , glp_smcp const   *parm ) 
{ 
  glp_smcp _parm ;
  int i ;
  int j ;
  int ret ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  xerror_t tmp___6 ;
  xerror_t tmp___7 ;
  xerror_t tmp___8 ;
  xerror_t tmp___9 ;
  xerror_t tmp___10 ;
  int tmp___11 ;
  GLPROW *row ;
  GLPCOL *col ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 404
  if ((unsigned long )parm == (unsigned long )((void *)0)) {
    {
#line 405
    parm = (glp_smcp const   *)(& _parm);
#line 405
    glp_init_smcp((glp_smcp *)parm);
    }
  }
#line 407
  if (! (parm->msg_lev == 0)) {
#line 407
    if (! (parm->msg_lev == 1)) {
#line 407
      if (! (parm->msg_lev == 2)) {
#line 407
        if (! (parm->msg_lev == 3)) {
          {
#line 411
          tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                 411);
#line 411
          (*tmp)("glp_simplex: msg_lev = %d; invalid parameter\n", parm->msg_lev);
          }
        }
      }
    }
  }
#line 413
  if (! (parm->meth == 1)) {
#line 413
    if (! (parm->meth == 2)) {
#line 413
      if (! (parm->meth == 3)) {
        {
#line 416
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                   416);
#line 416
        (*tmp___0)("glp_simplex: meth = %d; invalid parameter\n", parm->meth);
        }
      }
    }
  }
#line 418
  if (! (parm->pricing == 17)) {
#line 418
    if (! (parm->pricing == 34)) {
      {
#line 420
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                 420);
#line 420
      (*tmp___1)("glp_simplex: pricing = %d; invalid parameter\n", parm->pricing);
      }
    }
  }
#line 422
  if (! (parm->r_test == 17)) {
#line 422
    if (! (parm->r_test == 34)) {
      {
#line 424
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                 424);
#line 424
      (*tmp___2)("glp_simplex: r_test = %d; invalid parameter\n", parm->r_test);
      }
    }
  }
#line 426
  if (0.0 < (double )parm->tol_bnd) {
#line 426
    if (! (parm->tol_bnd < (double const   )1.0)) {
      {
#line 427
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                 427);
#line 427
      (*tmp___3)("glp_simplex: tol_bnd = %g; invalid parameter\n", parm->tol_bnd);
      }
    }
  } else {
    {
#line 427
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                               427);
#line 427
    (*tmp___3)("glp_simplex: tol_bnd = %g; invalid parameter\n", parm->tol_bnd);
    }
  }
#line 429
  if (0.0 < (double )parm->tol_dj) {
#line 429
    if (! (parm->tol_dj < (double const   )1.0)) {
      {
#line 430
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                 430);
#line 430
      (*tmp___4)("glp_simplex: tol_dj = %g; invalid parameter\n", parm->tol_dj);
      }
    }
  } else {
    {
#line 430
    tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                               430);
#line 430
    (*tmp___4)("glp_simplex: tol_dj = %g; invalid parameter\n", parm->tol_dj);
    }
  }
#line 432
  if (0.0 < (double )parm->tol_piv) {
#line 432
    if (! (parm->tol_piv < (double const   )1.0)) {
      {
#line 433
      tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                 433);
#line 433
      (*tmp___5)("glp_simplex: tol_piv = %g; invalid parameter\n", parm->tol_piv);
      }
    }
  } else {
    {
#line 433
    tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                               433);
#line 433
    (*tmp___5)("glp_simplex: tol_piv = %g; invalid parameter\n", parm->tol_piv);
    }
  }
#line 435
  if (parm->it_lim < 0) {
    {
#line 436
    tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                               436);
#line 436
    (*tmp___6)("glp_simplex: it_lim = %d; invalid parameter\n", parm->it_lim);
    }
  }
#line 438
  if (parm->tm_lim < 0) {
    {
#line 439
    tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                               439);
#line 439
    (*tmp___7)("glp_simplex: tm_lim = %d; invalid parameter\n", parm->tm_lim);
    }
  }
#line 441
  if (parm->out_frq < 1) {
    {
#line 442
    tmp___8 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                               442);
#line 442
    (*tmp___8)("glp_simplex: out_frq = %d; invalid parameter\n", parm->out_frq);
    }
  }
#line 444
  if (parm->out_dly < 0) {
    {
#line 445
    tmp___9 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                               445);
#line 445
    (*tmp___9)("glp_simplex: out_dly = %d; invalid parameter\n", parm->out_dly);
    }
  }
#line 447
  if (! (parm->presolve == 1)) {
#line 447
    if (! (parm->presolve == 0)) {
      {
#line 448
      tmp___10 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                                  448);
#line 448
      (*tmp___10)("glp_simplex: presolve = %d; invalid parameter\n", parm->presolve);
      }
    }
  }
#line 451
  tmp___11 = 1;
#line 451
  lp->dbs_stat = tmp___11;
#line 451
  lp->pbs_stat = tmp___11;
#line 452
  lp->obj_val = 0.0;
#line 453
  lp->some = 0;
#line 455
  i = 1;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (! (i <= lp->m)) {
#line 455
      goto while_break;
    }
#line 456
    row = *(lp->row + i);
#line 457
    if (row->type == 4) {
#line 457
      if (row->lb >= row->ub) {
#line 458
        if (parm->msg_lev >= 1) {
          {
#line 459
          _glp_lib_xprintf("glp_simplex: row %d: lb = %g, ub = %g; incorrect bounds\n",
                           i, row->lb, row->ub);
          }
        }
#line 461
        ret = 4;
#line 462
        goto done;
      }
    }
#line 455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  j = 1;
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 465
    if (! (j <= lp->n)) {
#line 465
      goto while_break___0;
    }
#line 466
    col = *(lp->col + j);
#line 467
    if (col->type == 4) {
#line 467
      if (col->lb >= col->ub) {
#line 468
        if (parm->msg_lev >= 1) {
          {
#line 469
          _glp_lib_xprintf("glp_simplex: column %d: lb = %g, ub = %g; incorrect bounds\n",
                           j, col->lb, col->ub);
          }
        }
#line 471
        ret = 4;
#line 472
        goto done;
      }
    }
#line 465
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 476
  if (lp->m == 0) {
    {
#line 477
    trivial1(lp, parm);
#line 477
    ret = 0;
    }
  } else
#line 478
  if (lp->n == 0) {
    {
#line 479
    trivial2(lp, parm);
#line 479
    ret = 0;
    }
  } else
#line 480
  if (! parm->presolve) {
    {
#line 481
    ret = simplex1(lp, parm);
    }
  } else {
    {
#line 483
    ret = simplex2(lp, parm);
    }
  }
  done: 
#line 485
  return (ret);
}
}
#line 505 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
void glp_init_smcp(glp_smcp *parm ) 
{ 


  {
#line 506
  parm->msg_lev = 3;
#line 507
  parm->meth = 1;
#line 508
  parm->pricing = 34;
#line 509
  parm->r_test = 34;
#line 510
  parm->tol_bnd = 1e-7;
#line 511
  parm->tol_dj = 1e-7;
#line 512
  parm->tol_piv = 1e-10;
#line 513
  parm->obj_ll = - 1.7976931348623157e+308;
#line 514
  parm->obj_ul = 1.7976931348623157e+308;
#line 515
  parm->it_lim = 2147483647;
#line 516
  parm->tm_lim = 2147483647;
#line 517
  parm->out_frq = 200;
#line 518
  parm->out_dly = 0;
#line 519
  parm->presolve = 0;
#line 520
  return;
}
}
#line 544 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
int glp_get_status(glp_prob *lp ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 546
  status = glp_get_prim_stat(lp);
  }
  {
#line 548
  if (status == 2) {
#line 548
    goto case_2;
  }
#line 566
  if (status == 4) {
#line 566
    goto case_4___0;
  }
#line 566
  if (status == 3) {
#line 566
    goto case_4___0;
  }
#line 566
  if (status == 1) {
#line 566
    goto case_4___0;
  }
#line 569
  goto switch_default___0;
  case_2: /* CIL Label */ 
  {
#line 549
  tmp = glp_get_dual_stat(lp);
  }
  {
#line 550
  if (tmp == 2) {
#line 550
    goto case_2___0;
  }
#line 553
  if (tmp == 4) {
#line 553
    goto case_4;
  }
#line 557
  if (tmp == 3) {
#line 557
    goto case_3;
  }
#line 557
  if (tmp == 1) {
#line 557
    goto case_3;
  }
#line 560
  goto switch_default;
  case_2___0: /* CIL Label */ 
#line 551
  status = 5;
#line 552
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 554
  status = 6;
#line 555
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 558
  status = status;
#line 559
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 561
  if ((unsigned long )lp != (unsigned long )lp) {
#line 561
    tmp___0 = 1;
  } else {
    {
#line 561
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     561);
#line 561
    tmp___0 = 1;
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 563
  goto switch_break;
  case_4___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 567
  status = status;
#line 568
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 570
  if ((unsigned long )lp != (unsigned long )lp) {
#line 570
    tmp___1 = 1;
  } else {
    {
#line 570
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     570);
#line 570
    tmp___1 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 572
  return (status);
}
}
#line 594 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
int glp_get_prim_stat(glp_prob *lp ) 
{ 
  int pbs_stat ;

  {
#line 595
  pbs_stat = lp->pbs_stat;
#line 596
  return (pbs_stat);
}
}
#line 618 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
int glp_get_dual_stat(glp_prob *lp ) 
{ 
  int dbs_stat ;

  {
#line 619
  dbs_stat = lp->dbs_stat;
#line 620
  return (dbs_stat);
}
}
#line 637 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
double glp_get_obj_val(glp_prob *lp ) 
{ 
  struct LPXCPS *cps ;
  double z ;
  double tmp ;

  {
#line 638
  cps = (struct LPXCPS *)lp->cps;
#line 640
  z = lp->obj_val;
#line 641
  if (cps->round) {
    {
#line 641
    tmp = fabs(z);
    }
#line 641
    if (tmp < 1e-9) {
#line 641
      z = 0.0;
    }
  }
#line 642
  return (z);
}
}
#line 665 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
int glp_get_row_stat(glp_prob *lp , int i ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 666
  if (1 <= i) {
#line 666
    if (! (i <= lp->m)) {
      {
#line 667
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 667);
#line 667
      (*tmp)("glp_get_row_stat: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 667
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 667);
#line 667
    (*tmp)("glp_get_row_stat: i = %d; row number out of range\n", i);
    }
  }
#line 669
  return ((*(lp->row + i))->stat);
}
}
#line 686 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
double glp_get_row_prim(glp_prob *lp , int i ) 
{ 
  struct LPXCPS *cps ;
  double prim ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 687
  cps = (struct LPXCPS *)lp->cps;
#line 689
  if (1 <= i) {
#line 689
    if (! (i <= lp->m)) {
      {
#line 690
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 690);
#line 690
      (*tmp)("glp_get_row_prim: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 690
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 690);
#line 690
    (*tmp)("glp_get_row_prim: i = %d; row number out of range\n", i);
    }
  }
#line 692
  prim = (*(lp->row + i))->prim;
#line 693
  if (cps->round) {
    {
#line 693
    tmp___0 = fabs(prim);
    }
#line 693
    if (tmp___0 < 1e-9) {
#line 693
      prim = 0.0;
    }
  }
#line 694
  return (prim);
}
}
#line 711 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
double glp_get_row_dual(glp_prob *lp , int i ) 
{ 
  struct LPXCPS *cps ;
  double dual ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 712
  cps = (struct LPXCPS *)lp->cps;
#line 714
  if (1 <= i) {
#line 714
    if (! (i <= lp->m)) {
      {
#line 715
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 715);
#line 715
      (*tmp)("glp_get_row_dual: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 715
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 715);
#line 715
    (*tmp)("glp_get_row_dual: i = %d; row number out of range\n", i);
    }
  }
#line 717
  dual = (*(lp->row + i))->dual;
#line 718
  if (cps->round) {
    {
#line 718
    tmp___0 = fabs(dual);
    }
#line 718
    if (tmp___0 < 1e-9) {
#line 718
      dual = 0.0;
    }
  }
#line 719
  return (dual);
}
}
#line 742 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
int glp_get_col_stat(glp_prob *lp , int j ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 743
  if (1 <= j) {
#line 743
    if (! (j <= lp->n)) {
      {
#line 744
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 744);
#line 744
      (*tmp)("glp_get_col_stat: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 744
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 744);
#line 744
    (*tmp)("glp_get_col_stat: j = %d; column number out of range\n", j);
    }
  }
#line 746
  return ((*(lp->col + j))->stat);
}
}
#line 763 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
double glp_get_col_prim(glp_prob *lp , int j ) 
{ 
  struct LPXCPS *cps ;
  double prim ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 764
  cps = (struct LPXCPS *)lp->cps;
#line 766
  if (1 <= j) {
#line 766
    if (! (j <= lp->n)) {
      {
#line 767
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 767);
#line 767
      (*tmp)("glp_get_col_prim: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 767
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 767);
#line 767
    (*tmp)("glp_get_col_prim: j = %d; column number out of range\n", j);
    }
  }
#line 769
  prim = (*(lp->col + j))->prim;
#line 770
  if (cps->round) {
    {
#line 770
    tmp___0 = fabs(prim);
    }
#line 770
    if (tmp___0 < 1e-9) {
#line 770
      prim = 0.0;
    }
  }
#line 771
  return (prim);
}
}
#line 788 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
double glp_get_col_dual(glp_prob *lp , int j ) 
{ 
  struct LPXCPS *cps ;
  double dual ;
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 789
  cps = (struct LPXCPS *)lp->cps;
#line 791
  if (1 <= j) {
#line 791
    if (! (j <= lp->n)) {
      {
#line 792
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 792);
#line 792
      (*tmp)("glp_get_col_dual: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 792
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c", 792);
#line 792
    (*tmp)("glp_get_col_dual: j = %d; column number out of range\n", j);
    }
  }
#line 794
  dual = (*(lp->col + j))->dual;
#line 795
  if (cps->round) {
    {
#line 795
    tmp___0 = fabs(dual);
    }
#line 795
    if (tmp___0 < 1e-9) {
#line 795
      dual = 0.0;
    }
  }
#line 796
  return (dual);
}
}
#line 827 "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c"
int glp_get_unbnd_ray(glp_prob *lp ) 
{ 
  int k ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 829
  k = lp->some;
#line 830
  if (k >= 0) {
#line 830
    tmp = 1;
  } else {
    {
#line 830
    _glp_lib_xassert("k >= 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi06.c",
                     830);
#line 830
    tmp = 1;
    }
  }
#line 831
  if (k > lp->m + lp->n) {
#line 831
    k = 0;
  }
#line 832
  return (k);
}
}
#line 52 "/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c"
void glp_set_row_stat(glp_prob *lp , int i , int stat ) 
{ 
  GLPROW *row ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 54
  if (1 <= i) {
#line 54
    if (! (i <= lp->m)) {
      {
#line 55
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c", 55);
#line 55
      (*tmp)("glp_set_row_stat: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 55
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c", 55);
#line 55
    (*tmp)("glp_set_row_stat: i = %d; row number out of range\n", i);
    }
  }
#line 57
  if (! (stat == 1)) {
#line 57
    if (! (stat == 2)) {
#line 57
      if (! (stat == 3)) {
#line 57
        if (! (stat == 4)) {
#line 57
          if (! (stat == 5)) {
            {
#line 59
            tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c",
                                       59);
#line 59
            (*tmp___0)("glp_set_row_stat: i = %d; stat = %d; invalid status\n", i,
                       stat);
            }
          }
        }
      }
    }
  }
#line 61
  row = *(lp->row + i);
#line 62
  if (stat != 1) {
    {
#line 64
    if (row->type == 1) {
#line 64
      goto case_1;
    }
#line 65
    if (row->type == 2) {
#line 65
      goto case_2;
    }
#line 66
    if (row->type == 3) {
#line 66
      goto case_3;
    }
#line 67
    if (row->type == 4) {
#line 67
      goto case_4;
    }
#line 68
    if (row->type == 5) {
#line 68
      goto case_5;
    }
#line 69
    goto switch_default;
    case_1: /* CIL Label */ 
#line 64
    stat = 4;
#line 64
    goto switch_break;
    case_2: /* CIL Label */ 
#line 65
    stat = 2;
#line 65
    goto switch_break;
    case_3: /* CIL Label */ 
#line 66
    stat = 3;
#line 66
    goto switch_break;
    case_4: /* CIL Label */ 
#line 67
    if (stat != 3) {
#line 67
      stat = 2;
    }
#line 67
    goto switch_break;
    case_5: /* CIL Label */ 
#line 68
    stat = 5;
#line 68
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 69
    if ((unsigned long )row != (unsigned long )row) {
#line 69
      tmp___1 = 1;
    } else {
      {
#line 69
      _glp_lib_xassert("row != row", "/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c",
                       69);
#line 69
      tmp___1 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 72
  if (row->stat == 1) {
#line 72
    if (stat != 1) {
#line 75
      lp->valid = 0;
    } else {
#line 72
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 72
  if (row->stat != 1) {
#line 72
    if (stat == 1) {
#line 75
      lp->valid = 0;
    }
  }
#line 77
  row->stat = stat;
#line 78
  return;
}
}
#line 106 "/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c"
void glp_set_col_stat(glp_prob *lp , int j , int stat ) 
{ 
  GLPCOL *col ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 108
  if (1 <= j) {
#line 108
    if (! (j <= lp->n)) {
      {
#line 109
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c", 109);
#line 109
      (*tmp)("glp_set_col_stat: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 109
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c", 109);
#line 109
    (*tmp)("glp_set_col_stat: j = %d; column number out of range\n", j);
    }
  }
#line 111
  if (! (stat == 1)) {
#line 111
    if (! (stat == 2)) {
#line 111
      if (! (stat == 3)) {
#line 111
        if (! (stat == 4)) {
#line 111
          if (! (stat == 5)) {
            {
#line 113
            tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c",
                                       113);
#line 113
            (*tmp___0)("glp_set_col_stat: j = %d; stat = %d; invalid status\n", j,
                       stat);
            }
          }
        }
      }
    }
  }
#line 115
  col = *(lp->col + j);
#line 116
  if (stat != 1) {
    {
#line 118
    if (col->type == 1) {
#line 118
      goto case_1;
    }
#line 119
    if (col->type == 2) {
#line 119
      goto case_2;
    }
#line 120
    if (col->type == 3) {
#line 120
      goto case_3;
    }
#line 121
    if (col->type == 4) {
#line 121
      goto case_4;
    }
#line 122
    if (col->type == 5) {
#line 122
      goto case_5;
    }
#line 123
    goto switch_default;
    case_1: /* CIL Label */ 
#line 118
    stat = 4;
#line 118
    goto switch_break;
    case_2: /* CIL Label */ 
#line 119
    stat = 2;
#line 119
    goto switch_break;
    case_3: /* CIL Label */ 
#line 120
    stat = 3;
#line 120
    goto switch_break;
    case_4: /* CIL Label */ 
#line 121
    if (stat != 3) {
#line 121
      stat = 2;
    }
#line 121
    goto switch_break;
    case_5: /* CIL Label */ 
#line 122
    stat = 5;
#line 122
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 123
    if ((unsigned long )col != (unsigned long )col) {
#line 123
      tmp___1 = 1;
    } else {
      {
#line 123
      _glp_lib_xassert("col != col", "/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c",
                       123);
#line 123
      tmp___1 = 1;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 126
  if (col->stat == 1) {
#line 126
    if (stat != 1) {
#line 129
      lp->valid = 0;
    } else {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 126
  if (col->stat != 1) {
#line 126
    if (stat == 1) {
#line 129
      lp->valid = 0;
    }
  }
#line 131
  col->stat = stat;
#line 132
  return;
}
}
#line 152 "/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c"
void glp_std_basis(glp_prob *lp ) 
{ 
  int i ;
  int j ;
  GLPCOL *col ;
  double tmp ;
  double tmp___0 ;

  {
#line 155
  i = 1;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i <= lp->m)) {
#line 155
      goto while_break;
    }
    {
#line 156
    glp_set_row_stat(lp, i, 1);
#line 155
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  j = 1;
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 158
    if (! (j <= lp->n)) {
#line 158
      goto while_break___0;
    }
#line 159
    col = *(lp->col + j);
#line 160
    if (col->type == 4) {
      {
#line 160
      tmp = fabs(col->lb);
#line 160
      tmp___0 = fabs(col->ub);
      }
#line 160
      if (tmp > tmp___0) {
        {
#line 161
        glp_set_col_stat(lp, j, 3);
        }
      } else {
        {
#line 163
        glp_set_col_stat(lp, j, 2);
        }
      }
    } else {
      {
#line 163
      glp_set_col_stat(lp, j, 2);
      }
    }
#line 158
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  return;
}
}
#line 185 "/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c"
void glp_adv_basis(glp_prob *lp , int flags ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 186
  if (flags != 0) {
    {
#line 187
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c", 187);
#line 187
    (*tmp)("glp_adv_basis: flags = %d; invalid flags\n", flags);
    }
  }
#line 188
  if (lp->m == 0) {
    {
#line 189
    glp_std_basis(lp);
    }
  } else
#line 188
  if (lp->n == 0) {
    {
#line 189
    glp_std_basis(lp);
    }
  } else {
    {
#line 191
    _glp_adv_basis(lp);
    }
  }
#line 192
  return;
}
}
#line 214 "/home/wslee/benchmarks/glpk-4.38/src/glpapi05.c"
void glp_cpx_basis(glp_prob *lp ) 
{ 


  {
#line 215
  if (lp->m == 0) {
    {
#line 216
    glp_std_basis(lp);
    }
  } else
#line 215
  if (lp->n == 0) {
    {
#line 216
    glp_std_basis(lp);
    }
  } else {
    {
#line 218
    _glp_cpx_basis(lp);
    }
  }
#line 219
  return;
}
}
#line 41 "/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c"
void glp_set_rii(glp_prob *lp , int i , double rii ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  GLPAIJ *aij ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 42
  if (1 <= i) {
#line 42
    if (! (i <= lp->m)) {
      {
#line 43
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 43);
#line 43
      (*tmp)("glp_set_rii: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 43
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 43);
#line 43
    (*tmp)("glp_set_rii: i = %d; row number out of range\n", i);
    }
  }
#line 44
  if (rii <= 0.0) {
    {
#line 45
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c",
                               45);
#line 45
    (*tmp___0)("glp_set_rii: i = %d; rii = %g; invalid scale factor\n", i, rii);
    }
  }
#line 47
  if (lp->valid) {
#line 47
    if ((*(lp->row + i))->rii != rii) {
#line 49
      aij = (*(lp->row + i))->ptr;
      {
#line 49
      while (1) {
        while_continue: /* CIL Label */ ;
#line 49
        if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 49
          goto while_break;
        }
#line 50
        if ((aij->col)->stat == 1) {
#line 52
          lp->valid = 0;
#line 53
          goto while_break;
        }
#line 49
        aij = aij->r_next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 57
  (*(lp->row + i))->rii = rii;
#line 58
  return;
}
}
#line 75 "/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c"
void glp_set_sjj(glp_prob *lp , int j , double sjj ) 
{ 
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 76
  if (1 <= j) {
#line 76
    if (! (j <= lp->n)) {
      {
#line 77
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 77);
#line 77
      (*tmp)("glp_set_sjj: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 77
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 77);
#line 77
    (*tmp)("glp_set_sjj: j = %d; column number out of range\n", j);
    }
  }
#line 78
  if (sjj <= 0.0) {
    {
#line 79
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c",
                               79);
#line 79
    (*tmp___0)("glp_set_sjj: j = %d; sjj = %g; invalid scale factor\n", j, sjj);
    }
  }
#line 81
  if (lp->valid) {
#line 81
    if ((*(lp->col + j))->sjj != sjj) {
#line 81
      if ((*(lp->col + j))->stat == 1) {
#line 84
        lp->valid = 0;
      }
    }
  }
#line 86
  (*(lp->col + j))->sjj = sjj;
#line 87
  return;
}
}
#line 104 "/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c"
double glp_get_rii(glp_prob *lp , int i ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 105
  if (1 <= i) {
#line 105
    if (! (i <= lp->m)) {
      {
#line 106
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 106);
#line 106
      (*tmp)("glp_get_rii: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 106
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 106);
#line 106
    (*tmp)("glp_get_rii: i = %d; row number out of range\n", i);
    }
  }
#line 107
  return ((*(lp->row + i))->rii);
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c"
double glp_get_sjj(glp_prob *lp , int j ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 125
  if (1 <= j) {
#line 125
    if (! (j <= lp->n)) {
      {
#line 126
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 126);
#line 126
      (*tmp)("glp_get_sjj: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 126
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 126);
#line 126
    (*tmp)("glp_get_sjj: j = %d; column number out of range\n", j);
    }
  }
#line 127
  return ((*(lp->col + j))->sjj);
}
}
#line 156 "/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c"
void glp_scale_prob(glp_prob *lp , int flags ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 157
  if (flags & -242) {
    {
#line 159
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c", 159);
#line 159
    (*tmp)("glp_scale_prob: flags = 0x%02X; invalid scaling options\n", flags);
    }
  }
#line 161
  if (flags & 128) {
#line 162
    flags = 81;
  }
  {
#line 163
  _glp_scale_prob(lp, flags);
  }
#line 164
  return;
}
}
#line 184 "/home/wslee/benchmarks/glpk-4.38/src/glpapi04.c"
void glp_unscale_prob(glp_prob *lp ) 
{ 
  int m ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int i ;
  int j ;

  {
  {
#line 185
  tmp = glp_get_num_rows(lp);
#line 185
  m = tmp;
#line 186
  tmp___0 = glp_get_num_cols(lp);
#line 186
  n = tmp___0;
#line 188
  i = 1;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (i <= m)) {
#line 188
      goto while_break;
    }
    {
#line 188
    glp_set_rii(lp, i, 1.0);
#line 188
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  j = 1;
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 189
    if (! (j <= n)) {
#line 189
      goto while_break___0;
    }
    {
#line 189
    glp_set_sjj(lp, j, 1.0);
#line 189
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 45 "/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c"
void glp_create_index(glp_prob *lp ) 
{ 
  GLPROW *row ;
  GLPCOL *col ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 50
  if ((unsigned long )lp->r_tree == (unsigned long )((void *)0)) {
    {
#line 51
    lp->r_tree = _glp_avl_create_tree(& _glp_avl_strcmp, (void *)0);
#line 52
    i = 1;
    }
    {
#line 52
    while (1) {
      while_continue: /* CIL Label */ ;
#line 52
      if (! (i <= lp->m)) {
#line 52
        goto while_break;
      }
#line 53
      row = *(lp->row + i);
#line 54
      if ((unsigned long )row->node == (unsigned long )((void *)0)) {
#line 54
        tmp = 1;
      } else {
        {
#line 54
        _glp_lib_xassert("row->node == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c",
                         54);
#line 54
        tmp = 1;
        }
      }
#line 55
      if ((unsigned long )row->name != (unsigned long )((void *)0)) {
        {
#line 56
        row->node = _glp_avl_insert_node(lp->r_tree, (void const   *)row->name);
#line 57
        _glp_avl_set_node_link(row->node, (void *)row);
        }
      }
#line 52
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 62
  if ((unsigned long )lp->c_tree == (unsigned long )((void *)0)) {
    {
#line 63
    lp->c_tree = _glp_avl_create_tree(& _glp_avl_strcmp, (void *)0);
#line 64
    j = 1;
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if (! (j <= lp->n)) {
#line 64
        goto while_break___0;
      }
#line 65
      col = *(lp->col + j);
#line 66
      if ((unsigned long )col->node == (unsigned long )((void *)0)) {
#line 66
        tmp___0 = 1;
      } else {
        {
#line 66
        _glp_lib_xassert("col->node == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c",
                         66);
#line 66
        tmp___0 = 1;
        }
      }
#line 67
      if ((unsigned long )col->name != (unsigned long )((void *)0)) {
        {
#line 68
        col->node = _glp_avl_insert_node(lp->c_tree, (void const   *)col->name);
#line 69
        _glp_avl_set_node_link(col->node, (void *)col);
        }
      }
#line 64
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 73
  return;
}
}
#line 91 "/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c"
int glp_find_row(glp_prob *lp , char const   *name ) 
{ 
  AVLNODE *node ;
  int i ;
  xerror_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 93
  i = 0;
#line 94
  if ((unsigned long )lp->r_tree == (unsigned long )((void *)0)) {
    {
#line 95
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c", 95);
#line 95
    (*tmp)("glp_find_row: row name index does not exist\n");
    }
  }
#line 96
  if (! ((unsigned long )name == (unsigned long )((void *)0))) {
#line 96
    if (! ((int const   )*(name + 0) == 0)) {
      {
#line 96
      tmp___1 = strlen(name);
      }
#line 96
      if (! (tmp___1 > 255U)) {
        {
#line 97
        node = _glp_avl_find_node(lp->r_tree, (void const   *)name);
        }
#line 98
        if ((unsigned long )node != (unsigned long )((void *)0)) {
          {
#line 99
          tmp___0 = _glp_avl_get_node_link(node);
#line 99
          i = ((GLPROW *)tmp___0)->i;
          }
        }
      }
    }
  }
#line 101
  return (i);
}
}
#line 119 "/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c"
int glp_find_col(glp_prob *lp , char const   *name ) 
{ 
  AVLNODE *node ;
  int j ;
  xerror_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 121
  j = 0;
#line 122
  if ((unsigned long )lp->c_tree == (unsigned long )((void *)0)) {
    {
#line 123
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c", 123);
#line 123
    (*tmp)("glp_find_col: column name index does not exist\n");
    }
  }
#line 124
  if (! ((unsigned long )name == (unsigned long )((void *)0))) {
#line 124
    if (! ((int const   )*(name + 0) == 0)) {
      {
#line 124
      tmp___1 = strlen(name);
      }
#line 124
      if (! (tmp___1 > 255U)) {
        {
#line 125
        node = _glp_avl_find_node(lp->c_tree, (void const   *)name);
        }
#line 126
        if ((unsigned long )node != (unsigned long )((void *)0)) {
          {
#line 127
          tmp___0 = _glp_avl_get_node_link(node);
#line 127
          j = ((GLPCOL *)tmp___0)->j;
          }
        }
      }
    }
  }
#line 129
  return (j);
}
}
#line 150 "/home/wslee/benchmarks/glpk-4.38/src/glpapi03.c"
void glp_delete_index(glp_prob *lp ) 
{ 
  int i ;
  int j ;

  {
#line 153
  if ((unsigned long )lp->r_tree != (unsigned long )((void *)0)) {
#line 154
    i = 1;
    {
#line 154
    while (1) {
      while_continue: /* CIL Label */ ;
#line 154
      if (! (i <= lp->m)) {
#line 154
        goto while_break;
      }
#line 154
      (*(lp->row + i))->node = (AVLNODE *)((void *)0);
#line 154
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 155
    _glp_avl_delete_tree(lp->r_tree);
#line 155
    lp->r_tree = (AVL *)((void *)0);
    }
  }
#line 158
  if ((unsigned long )lp->c_tree != (unsigned long )((void *)0)) {
#line 159
    j = 1;
    {
#line 159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 159
      if (! (j <= lp->n)) {
#line 159
        goto while_break___0;
      }
#line 159
      (*(lp->col + j))->node = (AVLNODE *)((void *)0);
#line 159
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 160
    _glp_avl_delete_tree(lp->c_tree);
#line 160
    lp->c_tree = (AVL *)((void *)0);
    }
  }
#line 162
  return;
}
}
#line 41 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
char const   *glp_get_prob_name(glp_prob *lp ) 
{ 
  char *name ;

  {
#line 43
  name = lp->name;
#line 44
  return ((char const   *)name);
}
}
#line 63 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
char const   *glp_get_obj_name(glp_prob *lp ) 
{ 
  char *name ;

  {
#line 65
  name = lp->obj;
#line 66
  return ((char const   *)name);
}
}
#line 86 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_obj_dir(glp_prob *lp ) 
{ 
  int dir ;

  {
#line 87
  dir = lp->dir;
#line 88
  return (dir);
}
}
#line 105 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_num_rows(glp_prob *lp ) 
{ 
  int m ;

  {
#line 106
  m = lp->m;
#line 107
  return (m);
}
}
#line 124 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_num_cols(glp_prob *lp ) 
{ 
  int n ;

  {
#line 125
  n = lp->n;
#line 126
  return (n);
}
}
#line 144 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
char const   *glp_get_row_name(glp_prob *lp , int i ) 
{ 
  char *name ;
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 146
  if (1 <= i) {
#line 146
    if (! (i <= lp->m)) {
      {
#line 147
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 147);
#line 147
      (*tmp)("glp_get_row_name: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 147
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 147);
#line 147
    (*tmp)("glp_get_row_name: i = %d; row number out of range\n", i);
    }
  }
#line 149
  name = (*(lp->row + i))->name;
#line 150
  return ((char const   *)name);
}
}
#line 168 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
char const   *glp_get_col_name(glp_prob *lp , int j ) 
{ 
  char *name ;
  xerror_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 170
  if (1 <= j) {
#line 170
    if (! (j <= lp->n)) {
      {
#line 171
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 171);
#line 171
      (*tmp)("glp_get_col_name: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 171
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 171);
#line 171
    (*tmp)("glp_get_col_name: j = %d; column number out of range\n", j);
    }
  }
#line 173
  name = (*(lp->col + j))->name;
#line 174
  return ((char const   *)name);
}
}
#line 197 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_row_type(glp_prob *lp , int i ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 198
  if (1 <= i) {
#line 198
    if (! (i <= lp->m)) {
      {
#line 199
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 199);
#line 199
      (*tmp)("glp_get_row_type: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 199
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 199);
#line 199
    (*tmp)("glp_get_row_type: i = %d; row number out of range\n", i);
    }
  }
#line 201
  return ((*(lp->row + i))->type);
}
}
#line 219 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
double glp_get_row_lb(glp_prob *lp , int i ) 
{ 
  double lb ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 221
  if (1 <= i) {
#line 221
    if (! (i <= lp->m)) {
      {
#line 222
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 222);
#line 222
      (*tmp)("glp_get_row_lb: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 222
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 222);
#line 222
    (*tmp)("glp_get_row_lb: i = %d; row number out of range\n", i);
    }
  }
  {
#line 225
  if ((*(lp->row + i))->type == 3) {
#line 225
    goto case_3;
  }
#line 225
  if ((*(lp->row + i))->type == 1) {
#line 225
    goto case_3;
  }
#line 229
  if ((*(lp->row + i))->type == 5) {
#line 229
    goto case_5;
  }
#line 229
  if ((*(lp->row + i))->type == 4) {
#line 229
    goto case_5;
  }
#line 229
  if ((*(lp->row + i))->type == 2) {
#line 229
    goto case_5;
  }
#line 231
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 226
  lb = - 1.7976931348623157e+308;
#line 226
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 230
  lb = (*(lp->row + i))->lb;
#line 230
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 232
  if ((unsigned long )lp != (unsigned long )lp) {
#line 232
    tmp___0 = 1;
  } else {
    {
#line 232
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c",
                     232);
#line 232
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 234
  return (lb);
}
}
#line 252 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
double glp_get_row_ub(glp_prob *lp , int i ) 
{ 
  double ub ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 254
  if (1 <= i) {
#line 254
    if (! (i <= lp->m)) {
      {
#line 255
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 255);
#line 255
      (*tmp)("glp_get_row_ub: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 255
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 255);
#line 255
    (*tmp)("glp_get_row_ub: i = %d; row number out of range\n", i);
    }
  }
  {
#line 258
  if ((*(lp->row + i))->type == 2) {
#line 258
    goto case_2;
  }
#line 258
  if ((*(lp->row + i))->type == 1) {
#line 258
    goto case_2;
  }
#line 262
  if ((*(lp->row + i))->type == 5) {
#line 262
    goto case_5;
  }
#line 262
  if ((*(lp->row + i))->type == 4) {
#line 262
    goto case_5;
  }
#line 262
  if ((*(lp->row + i))->type == 3) {
#line 262
    goto case_5;
  }
#line 264
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 259
  ub = 1.7976931348623157e+308;
#line 259
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 263
  ub = (*(lp->row + i))->ub;
#line 263
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 265
  if ((unsigned long )lp != (unsigned long )lp) {
#line 265
    tmp___0 = 1;
  } else {
    {
#line 265
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c",
                     265);
#line 265
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 267
  return (ub);
}
}
#line 290 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_col_type(glp_prob *lp , int j ) 
{ 
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 291
  if (1 <= j) {
#line 291
    if (! (j <= lp->n)) {
      {
#line 292
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 292);
#line 292
      (*tmp)("glp_get_col_type: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 292
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 292);
#line 292
    (*tmp)("glp_get_col_type: j = %d; column number out of range\n", j);
    }
  }
#line 294
  return ((*(lp->col + j))->type);
}
}
#line 312 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
double glp_get_col_lb(glp_prob *lp , int j ) 
{ 
  double lb ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 314
  if (1 <= j) {
#line 314
    if (! (j <= lp->n)) {
      {
#line 315
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 315);
#line 315
      (*tmp)("glp_get_col_lb: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 315
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 315);
#line 315
    (*tmp)("glp_get_col_lb: j = %d; column number out of range\n", j);
    }
  }
  {
#line 319
  if ((*(lp->col + j))->type == 3) {
#line 319
    goto case_3;
  }
#line 319
  if ((*(lp->col + j))->type == 1) {
#line 319
    goto case_3;
  }
#line 323
  if ((*(lp->col + j))->type == 5) {
#line 323
    goto case_5;
  }
#line 323
  if ((*(lp->col + j))->type == 4) {
#line 323
    goto case_5;
  }
#line 323
  if ((*(lp->col + j))->type == 2) {
#line 323
    goto case_5;
  }
#line 325
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 320
  lb = - 1.7976931348623157e+308;
#line 320
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 324
  lb = (*(lp->col + j))->lb;
#line 324
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 326
  if ((unsigned long )lp != (unsigned long )lp) {
#line 326
    tmp___0 = 1;
  } else {
    {
#line 326
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c",
                     326);
#line 326
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 328
  return (lb);
}
}
#line 346 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
double glp_get_col_ub(glp_prob *lp , int j ) 
{ 
  double ub ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 348
  if (1 <= j) {
#line 348
    if (! (j <= lp->n)) {
      {
#line 349
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 349);
#line 349
      (*tmp)("glp_get_col_ub: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 349
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 349);
#line 349
    (*tmp)("glp_get_col_ub: j = %d; column number out of range\n", j);
    }
  }
  {
#line 353
  if ((*(lp->col + j))->type == 2) {
#line 353
    goto case_2;
  }
#line 353
  if ((*(lp->col + j))->type == 1) {
#line 353
    goto case_2;
  }
#line 357
  if ((*(lp->col + j))->type == 5) {
#line 357
    goto case_5;
  }
#line 357
  if ((*(lp->col + j))->type == 4) {
#line 357
    goto case_5;
  }
#line 357
  if ((*(lp->col + j))->type == 3) {
#line 357
    goto case_5;
  }
#line 359
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 354
  ub = 1.7976931348623157e+308;
#line 354
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 358
  ub = (*(lp->col + j))->ub;
#line 358
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 360
  if ((unsigned long )lp != (unsigned long )lp) {
#line 360
    tmp___0 = 1;
  } else {
    {
#line 360
    _glp_lib_xassert("lp != lp", "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c",
                     360);
#line 360
    tmp___0 = 1;
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 362
  return (ub);
}
}
#line 382 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
double glp_get_obj_coef(glp_prob *lp , int j ) 
{ 
  xerror_t tmp ;
  double tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 383
  if (0 <= j) {
#line 383
    if (! (j <= lp->n)) {
      {
#line 384
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 384);
#line 384
      (*tmp)("glp_get_obj_coef: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 384
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 384);
#line 384
    (*tmp)("glp_get_obj_coef: j = %d; column number out of range\n", j);
    }
  }
#line 386
  if (j == 0) {
#line 386
    tmp___0 = lp->c0;
  } else {
#line 386
    tmp___0 = (*(lp->col + j))->coef;
  }
#line 386
  return (tmp___0);
}
}
#line 403 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_num_nz(glp_prob *lp ) 
{ 
  int nnz ;

  {
#line 404
  nnz = lp->nnz;
#line 405
  return (nnz);
}
}
#line 433 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_mat_row(glp_prob *lp , int i , int *ind , double *val ) 
{ 
  GLPAIJ *aij ;
  int len ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 436
  if (1 <= i) {
#line 436
    if (! (i <= lp->m)) {
      {
#line 437
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 437);
#line 437
      (*tmp)("glp_get_mat_row: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 437
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 437);
#line 437
    (*tmp)("glp_get_mat_row: i = %d; row number out of range\n", i);
    }
  }
#line 439
  len = 0;
#line 440
  aij = (*(lp->row + i))->ptr;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 440
      goto while_break;
    }
#line 441
    len ++;
#line 442
    if ((unsigned long )ind != (unsigned long )((void *)0)) {
#line 442
      *(ind + len) = (aij->col)->j;
    }
#line 443
    if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 443
      *(val + len) = aij->val;
    }
#line 440
    aij = aij->r_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  if (len <= lp->n) {
#line 445
    tmp___0 = 1;
  } else {
    {
#line 445
    _glp_lib_xassert("len <= lp->n", "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c",
                     445);
#line 445
    tmp___0 = 1;
    }
  }
#line 446
  return (len);
}
}
#line 474 "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c"
int glp_get_mat_col(glp_prob *lp , int j , int *ind , double *val ) 
{ 
  GLPAIJ *aij ;
  int len ;
  xerror_t tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 477
  if (1 <= j) {
#line 477
    if (! (j <= lp->n)) {
      {
#line 478
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 478);
#line 478
      (*tmp)("glp_get_mat_col: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 478
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c", 478);
#line 478
    (*tmp)("glp_get_mat_col: j = %d; column number out of range\n", j);
    }
  }
#line 480
  len = 0;
#line 481
  aij = (*(lp->col + j))->ptr;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 481
      goto while_break;
    }
#line 482
    len ++;
#line 483
    if ((unsigned long )ind != (unsigned long )((void *)0)) {
#line 483
      *(ind + len) = (aij->row)->i;
    }
#line 484
    if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 484
      *(val + len) = aij->val;
    }
#line 481
    aij = aij->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  if (len <= lp->m) {
#line 486
    tmp___0 = 1;
  } else {
    {
#line 486
    _glp_lib_xassert("len <= lp->m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi02.c",
                     486);
#line 486
    tmp___0 = 1;
    }
  }
#line 487
  return (len);
}
}
#line 56 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
static void create_prob(glp_prob *lp ) 
{ 
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  AVL *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 57
  lp->pool = _glp_dmp_create_pool();
#line 58
  lp->cps = _glp_lib_xmalloc((int )sizeof(struct LPXCPS ));
#line 59
  _glp_lpx_reset_parms(lp);
#line 60
  lp->tree = (void *)0;
#line 61
  lp->lwa = 0;
#line 62
  lp->cwa = (char *)((void *)0);
#line 64
  lp->name = (char *)((void *)0);
#line 65
  lp->obj = (char *)((void *)0);
#line 66
  lp->dir = 1;
#line 67
  lp->c0 = 0.0;
#line 68
  lp->m_max = 100;
#line 69
  lp->n_max = 200;
#line 70
  tmp = 0;
#line 70
  lp->n = tmp;
#line 70
  lp->m = tmp;
#line 71
  lp->nnz = 0;
#line 72
  tmp___0 = _glp_lib_xcalloc(1 + lp->m_max, (int )sizeof(GLPROW *));
#line 72
  lp->row = (GLPROW **)tmp___0;
#line 73
  tmp___1 = _glp_lib_xcalloc(1 + lp->n_max, (int )sizeof(GLPCOL *));
#line 73
  lp->col = (GLPCOL **)tmp___1;
#line 74
  tmp___2 = (AVL *)((void *)0);
#line 74
  lp->c_tree = tmp___2;
#line 74
  lp->r_tree = tmp___2;
#line 76
  lp->valid = 0;
#line 77
  tmp___3 = _glp_lib_xcalloc(1 + lp->m_max, (int )sizeof(int ));
#line 77
  lp->head = (int *)tmp___3;
#line 78
  lp->bfcp = (glp_bfcp *)((void *)0);
#line 79
  lp->bfd = (BFD *)((void *)0);
#line 81
  tmp___4 = 1;
#line 81
  lp->dbs_stat = tmp___4;
#line 81
  lp->pbs_stat = tmp___4;
#line 82
  lp->obj_val = 0.0;
#line 83
  lp->it_cnt = 0;
#line 84
  lp->some = 0;
#line 86
  lp->ipt_stat = 1;
#line 87
  lp->ipt_obj = 0.0;
#line 89
  lp->mip_stat = 1;
#line 90
  lp->mip_obj = 0.0;
  }
#line 91
  return;
}
}
#line 94 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
glp_prob *glp_create_prob(void) 
{ 
  glp_prob *lp ;
  void *tmp ;

  {
  {
#line 96
  tmp = _glp_lib_xmalloc((int )sizeof(glp_prob ));
#line 96
  lp = (glp_prob *)tmp;
#line 97
  create_prob(lp);
  }
#line 98
  return (lp);
}
}
#line 118 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_prob_name(glp_prob *lp , char const   *name ) 
{ 
  glp_tree___0 *tree ;
  xerror_t tmp ;
  size_t tmp___0 ;
  int k ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 119
  tree = (glp_tree___0 *)lp->tree;
#line 120
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 120
    if (tree->reason != 0) {
      {
#line 121
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 121);
#line 121
      (*tmp)("glp_set_prob_name: operation not allowed\n");
      }
    }
  }
#line 122
  if ((unsigned long )lp->name != (unsigned long )((void *)0)) {
    {
#line 123
    tmp___0 = strlen((char const   *)lp->name);
#line 123
    _glp_dmp_free_atom(lp->pool, (void *)lp->name, (int )(tmp___0 + 1U));
#line 124
    lp->name = (char *)((void *)0);
    }
  }
#line 126
  if (! ((unsigned long )name == (unsigned long )((void *)0))) {
#line 126
    if (! ((int const   )*(name + 0) == 0)) {
#line 128
      k = 0;
      {
#line 128
      while (1) {
        while_continue: /* CIL Label */ ;
#line 128
        if (! ((int const   )*(name + k) != 0)) {
#line 128
          goto while_break;
        }
#line 129
        if (k == 256) {
          {
#line 130
          tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     130);
#line 130
          (*tmp___1)("glp_set_prob_name: problem name too long\n");
          }
        }
        {
#line 131
        tmp___3 = __ctype_b_loc();
        }
#line 131
        if ((int const   )*(*tmp___3 + (int )((unsigned char )*(name + k))) & 2) {
          {
#line 132
          tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     132);
#line 132
          (*tmp___2)("glp_set_prob_name: problem name contains invalid character(s)\n");
          }
        }
#line 128
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 135
      tmp___4 = strlen(name);
#line 135
      tmp___5 = _glp_dmp_get_atom(lp->pool, (int )(tmp___4 + 1U));
#line 135
      lp->name = (char *)tmp___5;
#line 136
      strcpy((char */* __restrict  */)lp->name, (char const   */* __restrict  */)name);
      }
    }
  }
#line 138
  return;
}
}
#line 159 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_obj_name(glp_prob *lp , char const   *name ) 
{ 
  glp_tree___0 *tree ;
  xerror_t tmp ;
  size_t tmp___0 ;
  int k ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 160
  tree = (glp_tree___0 *)lp->tree;
#line 161
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 161
    if (tree->reason != 0) {
      {
#line 162
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 162);
#line 162
      (*tmp)("glp_set_obj_name: operation not allowed\n");
      }
    }
  }
#line 163
  if ((unsigned long )lp->obj != (unsigned long )((void *)0)) {
    {
#line 164
    tmp___0 = strlen((char const   *)lp->obj);
#line 164
    _glp_dmp_free_atom(lp->pool, (void *)lp->obj, (int )(tmp___0 + 1U));
#line 165
    lp->obj = (char *)((void *)0);
    }
  }
#line 167
  if (! ((unsigned long )name == (unsigned long )((void *)0))) {
#line 167
    if (! ((int const   )*(name + 0) == 0)) {
#line 169
      k = 0;
      {
#line 169
      while (1) {
        while_continue: /* CIL Label */ ;
#line 169
        if (! ((int const   )*(name + k) != 0)) {
#line 169
          goto while_break;
        }
#line 170
        if (k == 256) {
          {
#line 171
          tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     171);
#line 171
          (*tmp___1)("glp_set_obj_name: objective name too long\n");
          }
        }
        {
#line 172
        tmp___3 = __ctype_b_loc();
        }
#line 172
        if ((int const   )*(*tmp___3 + (int )((unsigned char )*(name + k))) & 2) {
          {
#line 173
          tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     173);
#line 173
          (*tmp___2)("glp_set_obj_name: objective name contains invalid character(s)\n");
          }
        }
#line 169
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 176
      tmp___4 = strlen(name);
#line 176
      tmp___5 = _glp_dmp_get_atom(lp->pool, (int )(tmp___4 + 1U));
#line 176
      lp->obj = (char *)tmp___5;
#line 177
      strcpy((char */* __restrict  */)lp->obj, (char const   */* __restrict  */)name);
      }
    }
  }
#line 179
  return;
}
}
#line 200 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_obj_dir(glp_prob *lp , int dir ) 
{ 
  glp_tree___0 *tree ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 201
  tree = (glp_tree___0 *)lp->tree;
#line 202
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 202
    if (tree->reason != 0) {
      {
#line 203
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 203);
#line 203
      (*tmp)("glp_set_obj_dir: operation not allowed\n");
      }
    }
  }
#line 204
  if (! (dir == 1)) {
#line 204
    if (! (dir == 2)) {
      {
#line 205
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 205);
#line 205
      (*tmp___0)("glp_set_obj_dir: dir = %d; invalid direction flag\n", dir);
      }
    }
  }
#line 207
  lp->dir = dir;
#line 208
  return;
}
}
#line 234 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
int glp_add_rows(glp_prob *lp , int nrs ) 
{ 
  glp_tree___0 *tree ;
  GLPROW *row ;
  int m_new ;
  int i ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  GLPROW **save ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 235
  tree = (glp_tree___0 *)lp->tree;
#line 239
  if (nrs < 1) {
    {
#line 240
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 240);
#line 240
    (*tmp)("glp_add_rows: nrs = %d; invalid number of rows\n", nrs);
    }
  }
#line 242
  if (nrs > 100000000 - lp->m) {
    {
#line 243
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               243);
#line 243
    (*tmp___0)("glp_add_rows: nrs = %d; too many rows\n", nrs);
    }
  }
#line 244
  m_new = lp->m + nrs;
#line 246
  if (lp->m_max < m_new) {
#line 247
    save = lp->row;
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      if (! (lp->m_max < m_new)) {
#line 248
        goto while_break;
      }
#line 249
      lp->m_max += lp->m_max;
#line 250
      if (lp->m_max > 0) {
#line 250
        tmp___1 = 1;
      } else {
        {
#line 250
        _glp_lib_xassert("lp->m_max > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         250);
#line 250
        tmp___1 = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 252
    tmp___2 = _glp_lib_xcalloc(1 + lp->m_max, (int )sizeof(GLPROW *));
#line 252
    lp->row = (GLPROW **)tmp___2;
#line 253
    memcpy((void */* __restrict  */)(lp->row + 1), (void const   */* __restrict  */)(save + 1),
           (size_t )((unsigned long )lp->m * sizeof(GLPROW *)));
#line 254
    _glp_lib_xfree((void *)save);
#line 256
    _glp_lib_xfree((void *)lp->head);
#line 257
    tmp___3 = _glp_lib_xcalloc(1 + lp->m_max, (int )sizeof(int ));
#line 257
    lp->head = (int *)tmp___3;
    }
  }
#line 260
  i = lp->m + 1;
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! (i <= m_new)) {
#line 260
      goto while_break___0;
    }
    {
#line 262
    tmp___4 = _glp_dmp_get_atom(lp->pool, (int )sizeof(GLPROW ));
#line 262
    row = (GLPROW *)tmp___4;
#line 262
    *(lp->row + i) = row;
#line 263
    row->i = i;
#line 264
    row->name = (char *)((void *)0);
#line 265
    row->node = (AVLNODE *)((void *)0);
#line 267
    row->level = 0;
#line 268
    row->origin = (unsigned char)0;
#line 269
    row->klass = (unsigned char)0;
    }
#line 270
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
      {
#line 272
      if (tree->reason == 0) {
#line 272
        goto case_0;
      }
#line 274
      if (tree->reason == 1) {
#line 274
        goto case_1;
      }
#line 279
      if (tree->reason == 4) {
#line 279
        goto case_4;
      }
#line 284
      goto switch_default;
      case_0: /* CIL Label */ 
#line 273
      goto switch_break;
      case_1: /* CIL Label */ 
#line 275
      if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 275
        tmp___5 = 1;
      } else {
        {
#line 275
        _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         275);
#line 275
        tmp___5 = 1;
        }
      }
#line 276
      row->level = (tree->curr)->level;
#line 277
      row->origin = (unsigned char)1;
#line 278
      goto switch_break;
      case_4: /* CIL Label */ 
#line 280
      if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 280
        tmp___6 = 1;
      } else {
        {
#line 280
        _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         280);
#line 280
        tmp___6 = 1;
        }
      }
#line 281
      row->level = (tree->curr)->level;
#line 282
      row->origin = (unsigned char)2;
#line 283
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 285
      if ((unsigned long )tree != (unsigned long )tree) {
#line 285
        tmp___7 = 1;
      } else {
        {
#line 285
        _glp_lib_xassert("tree != tree", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         285);
#line 285
        tmp___7 = 1;
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 289
    row->type = 1;
#line 290
    tmp___8 = 0.0;
#line 290
    row->ub = tmp___8;
#line 290
    row->lb = tmp___8;
#line 291
    row->ptr = (GLPAIJ *)((void *)0);
#line 292
    row->rii = 1.0;
#line 293
    row->stat = 1;
#line 297
    row->bind = 0;
#line 299
    tmp___9 = 0.0;
#line 299
    row->dual = tmp___9;
#line 299
    row->prim = tmp___9;
#line 300
    tmp___10 = 0.0;
#line 300
    row->dval = tmp___10;
#line 300
    row->pval = tmp___10;
#line 301
    row->mipx = 0.0;
#line 260
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 304
  lp->m = m_new;
#line 306
  lp->valid = 0;
#line 308
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 308
    if (tree->reason != 0) {
#line 308
      tree->reopt = 1;
    }
  }
#line 311
  return ((m_new - nrs) + 1);
}
}
#line 338 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
int glp_add_cols(glp_prob *lp , int ncs ) 
{ 
  glp_tree___0 *tree ;
  GLPCOL *col ;
  int n_new ;
  int j ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  GLPCOL **save ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 339
  tree = (glp_tree___0 *)lp->tree;
#line 342
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 342
    if (tree->reason != 0) {
      {
#line 343
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 343);
#line 343
      (*tmp)("glp_add_cols: operation not allowed\n");
      }
    }
  }
#line 345
  if (ncs < 1) {
    {
#line 346
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               346);
#line 346
    (*tmp___0)("glp_add_cols: ncs = %d; invalid number of columns\n", ncs);
    }
  }
#line 348
  if (ncs > 100000000 - lp->n) {
    {
#line 349
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               349);
#line 349
    (*tmp___1)("glp_add_cols: ncs = %d; too many columns\n", ncs);
    }
  }
#line 350
  n_new = lp->n + ncs;
#line 352
  if (lp->n_max < n_new) {
#line 353
    save = lp->col;
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 354
      if (! (lp->n_max < n_new)) {
#line 354
        goto while_break;
      }
#line 355
      lp->n_max += lp->n_max;
#line 356
      if (lp->n_max > 0) {
#line 356
        tmp___2 = 1;
      } else {
        {
#line 356
        _glp_lib_xassert("lp->n_max > 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         356);
#line 356
        tmp___2 = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 358
    tmp___3 = _glp_lib_xcalloc(1 + lp->n_max, (int )sizeof(GLPCOL *));
#line 358
    lp->col = (GLPCOL **)tmp___3;
#line 359
    memcpy((void */* __restrict  */)(lp->col + 1), (void const   */* __restrict  */)(save + 1),
           (size_t )((unsigned long )lp->n * sizeof(GLPCOL *)));
#line 360
    _glp_lib_xfree((void *)save);
    }
  }
#line 363
  j = lp->n + 1;
  {
#line 363
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 363
    if (! (j <= n_new)) {
#line 363
      goto while_break___0;
    }
    {
#line 365
    tmp___4 = _glp_dmp_get_atom(lp->pool, (int )sizeof(GLPCOL ));
#line 365
    col = (GLPCOL *)tmp___4;
#line 365
    *(lp->col + j) = col;
#line 366
    col->j = j;
#line 367
    col->name = (char *)((void *)0);
#line 368
    col->node = (AVLNODE *)((void *)0);
#line 369
    col->kind = 1;
#line 370
    col->type = 5;
#line 371
    tmp___5 = 0.0;
#line 371
    col->ub = tmp___5;
#line 371
    col->lb = tmp___5;
#line 372
    col->coef = 0.0;
#line 373
    col->ptr = (GLPAIJ *)((void *)0);
#line 374
    col->sjj = 1.0;
#line 375
    col->stat = 5;
#line 379
    col->bind = 0;
#line 381
    tmp___6 = 0.0;
#line 381
    col->dual = tmp___6;
#line 381
    col->prim = tmp___6;
#line 382
    tmp___7 = 0.0;
#line 382
    col->dval = tmp___7;
#line 382
    col->pval = tmp___7;
#line 383
    col->mipx = 0.0;
#line 363
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 386
  lp->n = n_new;
#line 388
  return ((n_new - ncs) + 1);
}
}
#line 409 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_row_name(glp_prob *lp , int i , char const   *name ) 
{ 
  glp_tree___0 *tree ;
  GLPROW *row ;
  xerror_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int k ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  unsigned short const   **tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 410
  tree = (glp_tree___0 *)lp->tree;
#line 412
  if (1 <= i) {
#line 412
    if (! (i <= lp->m)) {
      {
#line 413
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 413);
#line 413
      (*tmp)("glp_set_row_name: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 413
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 413);
#line 413
    (*tmp)("glp_set_row_name: i = %d; row number out of range\n", i);
    }
  }
#line 415
  row = *(lp->row + i);
#line 416
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 416
    if (tree->reason != 0) {
#line 417
      if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 417
        tmp___0 = 1;
      } else {
        {
#line 417
        _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         417);
#line 417
        tmp___0 = 1;
        }
      }
#line 418
      if (row->level == (tree->curr)->level) {
#line 418
        tmp___1 = 1;
      } else {
        {
#line 418
        _glp_lib_xassert("row->level == tree->curr->level", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         418);
#line 418
        tmp___1 = 1;
        }
      }
    }
  }
#line 420
  if ((unsigned long )row->name != (unsigned long )((void *)0)) {
#line 421
    if ((unsigned long )row->node != (unsigned long )((void *)0)) {
#line 422
      if ((unsigned long )lp->r_tree != (unsigned long )((void *)0)) {
#line 422
        tmp___2 = 1;
      } else {
        {
#line 422
        _glp_lib_xassert("lp->r_tree != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         422);
#line 422
        tmp___2 = 1;
        }
      }
      {
#line 423
      _glp_avl_delete_node(lp->r_tree, row->node);
#line 424
      row->node = (AVLNODE *)((void *)0);
      }
    }
    {
#line 426
    tmp___3 = strlen((char const   *)row->name);
#line 426
    _glp_dmp_free_atom(lp->pool, (void *)row->name, (int )(tmp___3 + 1U));
#line 427
    row->name = (char *)((void *)0);
    }
  }
#line 429
  if (! ((unsigned long )name == (unsigned long )((void *)0))) {
#line 429
    if (! ((int const   )*(name + 0) == 0)) {
#line 431
      k = 0;
      {
#line 431
      while (1) {
        while_continue: /* CIL Label */ ;
#line 431
        if (! ((int const   )*(name + k) != 0)) {
#line 431
          goto while_break;
        }
#line 432
        if (k == 256) {
          {
#line 433
          tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     433);
#line 433
          (*tmp___4)("glp_set_row_name: i = %d; row name too long\n", i);
          }
        }
        {
#line 435
        tmp___6 = __ctype_b_loc();
        }
#line 435
        if ((int const   )*(*tmp___6 + (int )((unsigned char )*(name + k))) & 2) {
          {
#line 436
          tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     436);
#line 436
          (*tmp___5)("glp_set_row_name: i = %d: row name contains invalid character(s)\n",
                     i);
          }
        }
#line 431
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 439
      tmp___7 = strlen(name);
#line 439
      tmp___8 = _glp_dmp_get_atom(lp->pool, (int )(tmp___7 + 1U));
#line 439
      row->name = (char *)tmp___8;
#line 440
      strcpy((char */* __restrict  */)row->name, (char const   */* __restrict  */)name);
      }
#line 441
      if ((unsigned long )lp->r_tree != (unsigned long )((void *)0)) {
#line 442
        if ((unsigned long )row->node == (unsigned long )((void *)0)) {
#line 442
          tmp___9 = 1;
        } else {
          {
#line 442
          _glp_lib_xassert("row->node == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                           442);
#line 442
          tmp___9 = 1;
          }
        }
        {
#line 443
        row->node = _glp_avl_insert_node(lp->r_tree, (void const   *)row->name);
#line 444
        _glp_avl_set_node_link(row->node, (void *)row);
        }
      }
    }
  }
#line 447
  return;
}
}
#line 468 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_col_name(glp_prob *lp , int j , char const   *name ) 
{ 
  glp_tree___0 *tree ;
  GLPCOL *col ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int k ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 469
  tree = (glp_tree___0 *)lp->tree;
#line 471
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 471
    if (tree->reason != 0) {
      {
#line 472
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 472);
#line 472
      (*tmp)("glp_set_col_name: operation not allowed\n");
      }
    }
  }
#line 473
  if (1 <= j) {
#line 473
    if (! (j <= lp->n)) {
      {
#line 474
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 474);
#line 474
      (*tmp___0)("glp_set_col_name: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 474
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               474);
#line 474
    (*tmp___0)("glp_set_col_name: j = %d; column number out of range\n", j);
    }
  }
#line 476
  col = *(lp->col + j);
#line 477
  if ((unsigned long )col->name != (unsigned long )((void *)0)) {
#line 478
    if ((unsigned long )col->node != (unsigned long )((void *)0)) {
#line 479
      if ((unsigned long )lp->c_tree != (unsigned long )((void *)0)) {
#line 479
        tmp___1 = 1;
      } else {
        {
#line 479
        _glp_lib_xassert("lp->c_tree != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         479);
#line 479
        tmp___1 = 1;
        }
      }
      {
#line 480
      _glp_avl_delete_node(lp->c_tree, col->node);
#line 481
      col->node = (AVLNODE *)((void *)0);
      }
    }
    {
#line 483
    tmp___2 = strlen((char const   *)col->name);
#line 483
    _glp_dmp_free_atom(lp->pool, (void *)col->name, (int )(tmp___2 + 1U));
#line 484
    col->name = (char *)((void *)0);
    }
  }
#line 486
  if (! ((unsigned long )name == (unsigned long )((void *)0))) {
#line 486
    if (! ((int const   )*(name + 0) == 0)) {
#line 488
      k = 0;
      {
#line 488
      while (1) {
        while_continue: /* CIL Label */ ;
#line 488
        if (! ((int const   )*(name + k) != 0)) {
#line 488
          goto while_break;
        }
#line 489
        if (k == 256) {
          {
#line 490
          tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     490);
#line 490
          (*tmp___3)("glp_set_col_name: j = %d; column name too long\n", j);
          }
        }
        {
#line 492
        tmp___5 = __ctype_b_loc();
        }
#line 492
        if ((int const   )*(*tmp___5 + (int )((unsigned char )*(name + k))) & 2) {
          {
#line 493
          tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     493);
#line 493
          (*tmp___4)("glp_set_col_name: j = %d: column name contains invalid character(s)\n",
                     j);
          }
        }
#line 488
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 496
      tmp___6 = strlen(name);
#line 496
      tmp___7 = _glp_dmp_get_atom(lp->pool, (int )(tmp___6 + 1U));
#line 496
      col->name = (char *)tmp___7;
#line 497
      strcpy((char */* __restrict  */)col->name, (char const   */* __restrict  */)name);
      }
#line 498
      if ((unsigned long )lp->c_tree != (unsigned long )((void *)0)) {
#line 498
        if ((unsigned long )col->name != (unsigned long )((void *)0)) {
#line 499
          if ((unsigned long )col->node == (unsigned long )((void *)0)) {
#line 499
            tmp___8 = 1;
          } else {
            {
#line 499
            _glp_lib_xassert("col->node == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                             499);
#line 499
            tmp___8 = 1;
            }
          }
          {
#line 500
          col->node = _glp_avl_insert_node(lp->c_tree, (void const   *)col->name);
#line 501
          _glp_avl_set_node_link(col->node, (void *)col);
          }
        }
      }
    }
  }
#line 504
  return;
}
}
#line 541 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_row_bnds(glp_prob *lp , int i , int type , double lb , double ub ) 
{ 
  GLPROW *row ;
  xerror_t tmp ;
  double tmp___0 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  xerror_t tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 544
  if (1 <= i) {
#line 544
    if (! (i <= lp->m)) {
      {
#line 545
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 545);
#line 545
      (*tmp)("glp_set_row_bnds: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 545
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 545);
#line 545
    (*tmp)("glp_set_row_bnds: i = %d; row number out of range\n", i);
    }
  }
#line 547
  row = *(lp->row + i);
#line 548
  row->type = type;
  {
#line 550
  if (type == 1) {
#line 550
    goto case_1;
  }
#line 554
  if (type == 2) {
#line 554
    goto case_2;
  }
#line 558
  if (type == 3) {
#line 558
    goto case_3;
  }
#line 562
  if (type == 4) {
#line 562
    goto case_4;
  }
#line 568
  if (type == 5) {
#line 568
    goto case_5;
  }
#line 572
  goto switch_default;
  case_1: /* CIL Label */ 
#line 551
  tmp___0 = 0.0;
#line 551
  row->ub = tmp___0;
#line 551
  row->lb = tmp___0;
#line 552
  if (row->stat != 1) {
#line 552
    row->stat = 4;
  }
#line 553
  goto switch_break;
  case_2: /* CIL Label */ 
#line 555
  row->lb = lb;
#line 555
  row->ub = 0.0;
#line 556
  if (row->stat != 1) {
#line 556
    row->stat = 2;
  }
#line 557
  goto switch_break;
  case_3: /* CIL Label */ 
#line 559
  row->lb = 0.0;
#line 559
  row->ub = ub;
#line 560
  if (row->stat != 1) {
#line 560
    row->stat = 3;
  }
#line 561
  goto switch_break;
  case_4: /* CIL Label */ 
#line 563
  row->lb = lb;
#line 563
  row->ub = ub;
#line 564
  if (! (row->stat == 1)) {
#line 564
    if (! (row->stat == 2)) {
#line 564
      if (! (row->stat == 3)) {
        {
#line 566
        tmp___3 = fabs(lb);
#line 566
        tmp___4 = fabs(ub);
        }
#line 566
        if (tmp___3 <= tmp___4) {
#line 566
          row->stat = 2;
        } else {
#line 566
          row->stat = 3;
        }
      }
    }
  }
#line 567
  goto switch_break;
  case_5: /* CIL Label */ 
#line 569
  tmp___5 = lb;
#line 569
  row->ub = tmp___5;
#line 569
  row->lb = tmp___5;
#line 570
  if (row->stat != 1) {
#line 570
    row->stat = 5;
  }
#line 571
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 573
  tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 573);
#line 573
  (*tmp___6)("glp_set_row_bnds: i = %d; type = %d; invalid row type\n", i, type);
  }
  switch_break: /* CIL Label */ ;
  }
#line 576
  return;
}
}
#line 612 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_col_bnds(glp_prob *lp , int j , int type , double lb , double ub ) 
{ 
  GLPCOL *col ;
  xerror_t tmp ;
  double tmp___0 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  xerror_t tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 615
  if (1 <= j) {
#line 615
    if (! (j <= lp->n)) {
      {
#line 616
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 616);
#line 616
      (*tmp)("glp_set_col_bnds: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 616
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 616);
#line 616
    (*tmp)("glp_set_col_bnds: j = %d; column number out of range\n", j);
    }
  }
#line 618
  col = *(lp->col + j);
#line 619
  col->type = type;
  {
#line 621
  if (type == 1) {
#line 621
    goto case_1;
  }
#line 625
  if (type == 2) {
#line 625
    goto case_2;
  }
#line 629
  if (type == 3) {
#line 629
    goto case_3;
  }
#line 633
  if (type == 4) {
#line 633
    goto case_4;
  }
#line 639
  if (type == 5) {
#line 639
    goto case_5;
  }
#line 643
  goto switch_default;
  case_1: /* CIL Label */ 
#line 622
  tmp___0 = 0.0;
#line 622
  col->ub = tmp___0;
#line 622
  col->lb = tmp___0;
#line 623
  if (col->stat != 1) {
#line 623
    col->stat = 4;
  }
#line 624
  goto switch_break;
  case_2: /* CIL Label */ 
#line 626
  col->lb = lb;
#line 626
  col->ub = 0.0;
#line 627
  if (col->stat != 1) {
#line 627
    col->stat = 2;
  }
#line 628
  goto switch_break;
  case_3: /* CIL Label */ 
#line 630
  col->lb = 0.0;
#line 630
  col->ub = ub;
#line 631
  if (col->stat != 1) {
#line 631
    col->stat = 3;
  }
#line 632
  goto switch_break;
  case_4: /* CIL Label */ 
#line 634
  col->lb = lb;
#line 634
  col->ub = ub;
#line 635
  if (! (col->stat == 1)) {
#line 635
    if (! (col->stat == 2)) {
#line 635
      if (! (col->stat == 3)) {
        {
#line 637
        tmp___3 = fabs(lb);
#line 637
        tmp___4 = fabs(ub);
        }
#line 637
        if (tmp___3 <= tmp___4) {
#line 637
          col->stat = 2;
        } else {
#line 637
          col->stat = 3;
        }
      }
    }
  }
#line 638
  goto switch_break;
  case_5: /* CIL Label */ 
#line 640
  tmp___5 = lb;
#line 640
  col->ub = tmp___5;
#line 640
  col->lb = tmp___5;
#line 641
  if (col->stat != 1) {
#line 641
    col->stat = 5;
  }
#line 642
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 644
  tmp___6 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 644);
#line 644
  (*tmp___6)("glp_set_col_bnds: j = %d; type = %d; invalid column type\n", j, type);
  }
  switch_break: /* CIL Label */ ;
  }
#line 647
  return;
}
}
#line 667 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_obj_coef(glp_prob *lp , int j , double coef ) 
{ 
  glp_tree___0 *tree ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 668
  tree = (glp_tree___0 *)lp->tree;
#line 669
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 669
    if (tree->reason != 0) {
      {
#line 670
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 670);
#line 670
      (*tmp)("glp_set_obj_coef: operation not allowed\n");
      }
    }
  }
#line 671
  if (0 <= j) {
#line 671
    if (! (j <= lp->n)) {
      {
#line 672
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 672);
#line 672
      (*tmp___0)("glp_set_obj_coef: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 672
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               672);
#line 672
    (*tmp___0)("glp_set_obj_coef: j = %d; column number out of range\n", j);
    }
  }
#line 674
  if (j == 0) {
#line 675
    lp->c0 = coef;
  } else {
#line 677
    (*(lp->col + j))->coef = coef;
  }
#line 678
  return;
}
}
#line 706 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_mat_row(glp_prob *lp , int i , int len , int const   *ind , double const   *val ) 
{ 
  glp_tree___0 *tree ;
  GLPROW *row ;
  GLPCOL *col ;
  GLPAIJ *aij ;
  GLPAIJ *next ;
  int j ;
  int k ;
  xerror_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  xerror_t tmp___5 ;
  void *tmp___6 ;
  GLPAIJ *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 708
  tree = (glp_tree___0 *)lp->tree;
#line 714
  if (1 <= i) {
#line 714
    if (! (i <= lp->m)) {
      {
#line 715
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 715);
#line 715
      (*tmp)("glp_set_mat_row: i = %d; row number out of range\n", i);
      }
    }
  } else {
    {
#line 715
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 715);
#line 715
    (*tmp)("glp_set_mat_row: i = %d; row number out of range\n", i);
    }
  }
#line 717
  row = *(lp->row + i);
#line 718
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 718
    if (tree->reason != 0) {
#line 719
      if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 719
        tmp___0 = 1;
      } else {
        {
#line 719
        _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         719);
#line 719
        tmp___0 = 1;
        }
      }
#line 720
      if (row->level == (tree->curr)->level) {
#line 720
        tmp___1 = 1;
      } else {
        {
#line 720
        _glp_lib_xassert("row->level == tree->curr->level", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         720);
#line 720
        tmp___1 = 1;
        }
      }
    }
  }
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! ((unsigned long )row->ptr != (unsigned long )((void *)0))) {
#line 723
      goto while_break;
    }
#line 725
    aij = row->ptr;
#line 727
    row->ptr = aij->r_next;
#line 729
    col = aij->col;
#line 731
    if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 732
      col->ptr = aij->c_next;
    } else {
#line 734
      (aij->c_prev)->c_next = aij->c_next;
    }
#line 735
    if (! ((unsigned long )aij->c_next == (unsigned long )((void *)0))) {
#line 738
      (aij->c_next)->c_prev = aij->c_prev;
    }
    {
#line 740
    _glp_dmp_free_atom(lp->pool, (void *)aij, (int )sizeof(GLPAIJ ));
#line 740
    (lp->nnz) --;
    }
#line 743
    if (col->stat == 1) {
#line 743
      lp->valid = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  if (0 <= len) {
#line 746
    if (! (len <= lp->n)) {
      {
#line 747
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 747);
#line 747
      (*tmp___2)("glp_set_mat_row: i = %d; len = %d; invalid row length \n", i, len);
      }
    }
  } else {
    {
#line 747
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               747);
#line 747
    (*tmp___2)("glp_set_mat_row: i = %d; len = %d; invalid row length \n", i, len);
    }
  }
#line 749
  if (len > 500000000 - lp->nnz) {
    {
#line 750
    tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               750);
#line 750
    (*tmp___3)("glp_set_mat_row: i = %d; len = %d; too many constraint coefficients\n",
               i, len);
    }
  }
#line 752
  k = 1;
  {
#line 752
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 752
    if (! (k <= len)) {
#line 752
      goto while_break___0;
    }
#line 754
    j = (int )*(ind + k);
#line 756
    if (1 <= j) {
#line 756
      if (! (j <= lp->n)) {
        {
#line 757
        tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   757);
#line 757
        (*tmp___4)("glp_set_mat_row: i = %d; ind[%d] = %d; column index out of range\n",
                   i, k, j);
        }
      }
    } else {
      {
#line 757
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 757);
#line 757
      (*tmp___4)("glp_set_mat_row: i = %d; ind[%d] = %d; column index out of range\n",
                 i, k, j);
      }
    }
#line 759
    col = *(lp->col + j);
#line 762
    if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 762
      if (((col->ptr)->row)->i == i) {
        {
#line 763
        tmp___5 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   763);
#line 763
        (*tmp___5)("glp_set_mat_row: i = %d; ind[%d] = %d; duplicate column indices not allowed\n",
                   i, k, j);
        }
      }
    }
    {
#line 766
    tmp___6 = _glp_dmp_get_atom(lp->pool, (int )sizeof(GLPAIJ ));
#line 766
    aij = (GLPAIJ *)tmp___6;
#line 766
    (lp->nnz) ++;
#line 767
    aij->row = row;
#line 768
    aij->col = col;
#line 769
    aij->val = (double )*(val + k);
#line 772
    aij->r_prev = (GLPAIJ *)((void *)0);
#line 773
    aij->r_next = row->ptr;
#line 774
    aij->c_prev = (GLPAIJ *)((void *)0);
#line 775
    aij->c_next = col->ptr;
    }
#line 776
    if ((unsigned long )aij->r_next != (unsigned long )((void *)0)) {
#line 776
      (aij->r_next)->r_prev = aij;
    }
#line 777
    if ((unsigned long )aij->c_next != (unsigned long )((void *)0)) {
#line 777
      (aij->c_next)->c_prev = aij;
    }
#line 778
    tmp___7 = aij;
#line 778
    col->ptr = tmp___7;
#line 778
    row->ptr = tmp___7;
#line 781
    if (col->stat == 1) {
#line 781
      if (aij->val != 0.0) {
#line 781
        lp->valid = 0;
      }
    }
#line 752
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 784
  aij = row->ptr;
  {
#line 784
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 784
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 784
      goto while_break___1;
    }
#line 785
    next = aij->r_next;
#line 786
    if (aij->val == 0.0) {
#line 788
      if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 789
        row->ptr = next;
      } else {
#line 791
        (aij->r_prev)->r_next = next;
      }
#line 792
      if (! ((unsigned long )next == (unsigned long )((void *)0))) {
#line 795
        next->r_prev = aij->r_prev;
      }
#line 797
      if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 797
        tmp___8 = 1;
      } else {
        {
#line 797
        _glp_lib_xassert("aij->c_prev == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         797);
#line 797
        tmp___8 = 1;
        }
      }
#line 798
      (aij->col)->ptr = aij->c_next;
#line 799
      if ((unsigned long )aij->c_next != (unsigned long )((void *)0)) {
#line 799
        (aij->c_next)->c_prev = (GLPAIJ *)((void *)0);
      }
      {
#line 801
      _glp_dmp_free_atom(lp->pool, (void *)aij, (int )sizeof(GLPAIJ ));
#line 801
      (lp->nnz) --;
      }
    }
#line 784
    aij = next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 804
  return;
}
}
#line 832 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_set_mat_col(glp_prob *lp , int j , int len , int const   *ind , double const   *val ) 
{ 
  glp_tree___0 *tree ;
  GLPROW *row ;
  GLPCOL *col ;
  GLPAIJ *aij ;
  GLPAIJ *next ;
  int i ;
  int k ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  void *tmp___5 ;
  GLPAIJ *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 834
  tree = (glp_tree___0 *)lp->tree;
#line 839
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 839
    if (tree->reason != 0) {
      {
#line 840
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 840);
#line 840
      (*tmp)("glp_set_mat_col: operation not allowed\n");
      }
    }
  }
#line 842
  if (1 <= j) {
#line 842
    if (! (j <= lp->n)) {
      {
#line 843
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 843);
#line 843
      (*tmp___0)("glp_set_mat_col: j = %d; column number out of range\n", j);
      }
    }
  } else {
    {
#line 843
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               843);
#line 843
    (*tmp___0)("glp_set_mat_col: j = %d; column number out of range\n", j);
    }
  }
#line 845
  col = *(lp->col + j);
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (! ((unsigned long )col->ptr != (unsigned long )((void *)0))) {
#line 847
      goto while_break;
    }
#line 849
    aij = col->ptr;
#line 851
    col->ptr = aij->c_next;
#line 853
    row = aij->row;
#line 855
    if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 856
      row->ptr = aij->r_next;
    } else {
#line 858
      (aij->r_prev)->r_next = aij->r_next;
    }
#line 859
    if (! ((unsigned long )aij->r_next == (unsigned long )((void *)0))) {
#line 862
      (aij->r_next)->r_prev = aij->r_prev;
    }
    {
#line 864
    _glp_dmp_free_atom(lp->pool, (void *)aij, (int )sizeof(GLPAIJ ));
#line 864
    (lp->nnz) --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 867
  if (0 <= len) {
#line 867
    if (! (len <= lp->m)) {
      {
#line 868
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 868);
#line 868
      (*tmp___1)("glp_set_mat_col: j = %d; len = %d; invalid column length\n", j,
                 len);
      }
    }
  } else {
    {
#line 868
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               868);
#line 868
    (*tmp___1)("glp_set_mat_col: j = %d; len = %d; invalid column length\n", j, len);
    }
  }
#line 870
  if (len > 500000000 - lp->nnz) {
    {
#line 871
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               871);
#line 871
    (*tmp___2)("glp_set_mat_col: j = %d; len = %d; too many constraint coefficients\n",
               j, len);
    }
  }
#line 873
  k = 1;
  {
#line 873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 873
    if (! (k <= len)) {
#line 873
      goto while_break___0;
    }
#line 875
    i = (int )*(ind + k);
#line 877
    if (1 <= i) {
#line 877
      if (! (i <= lp->m)) {
        {
#line 878
        tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   878);
#line 878
        (*tmp___3)("glp_set_mat_col: j = %d; ind[%d] = %d; row index out of range\n",
                   j, k, i);
        }
      }
    } else {
      {
#line 878
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 878);
#line 878
      (*tmp___3)("glp_set_mat_col: j = %d; ind[%d] = %d; row index out of range\n",
                 j, k, i);
      }
    }
#line 880
    row = *(lp->row + i);
#line 883
    if ((unsigned long )row->ptr != (unsigned long )((void *)0)) {
#line 883
      if (((row->ptr)->col)->j == j) {
        {
#line 884
        tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   884);
#line 884
        (*tmp___4)("glp_set_mat_col: j = %d; ind[%d] = %d; duplicate row indices not allowed\n",
                   j, k, i);
        }
      }
    }
    {
#line 887
    tmp___5 = _glp_dmp_get_atom(lp->pool, (int )sizeof(GLPAIJ ));
#line 887
    aij = (GLPAIJ *)tmp___5;
#line 887
    (lp->nnz) ++;
#line 888
    aij->row = row;
#line 889
    aij->col = col;
#line 890
    aij->val = (double )*(val + k);
#line 893
    aij->r_prev = (GLPAIJ *)((void *)0);
#line 894
    aij->r_next = row->ptr;
#line 895
    aij->c_prev = (GLPAIJ *)((void *)0);
#line 896
    aij->c_next = col->ptr;
    }
#line 897
    if ((unsigned long )aij->r_next != (unsigned long )((void *)0)) {
#line 897
      (aij->r_next)->r_prev = aij;
    }
#line 898
    if ((unsigned long )aij->c_next != (unsigned long )((void *)0)) {
#line 898
      (aij->c_next)->c_prev = aij;
    }
#line 899
    tmp___6 = aij;
#line 899
    col->ptr = tmp___6;
#line 899
    row->ptr = tmp___6;
#line 873
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 902
  aij = col->ptr;
  {
#line 902
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 902
    if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 902
      goto while_break___1;
    }
#line 903
    next = aij->c_next;
#line 904
    if (aij->val == 0.0) {
#line 906
      if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 906
        tmp___7 = 1;
      } else {
        {
#line 906
        _glp_lib_xassert("aij->r_prev == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                         906);
#line 906
        tmp___7 = 1;
        }
      }
#line 907
      (aij->row)->ptr = aij->r_next;
#line 908
      if ((unsigned long )aij->r_next != (unsigned long )((void *)0)) {
#line 908
        (aij->r_next)->r_prev = (GLPAIJ *)((void *)0);
      }
#line 910
      if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 911
        col->ptr = next;
      } else {
#line 913
        (aij->c_prev)->c_next = next;
      }
#line 914
      if (! ((unsigned long )next == (unsigned long )((void *)0))) {
#line 917
        next->c_prev = aij->c_prev;
      }
      {
#line 919
      _glp_dmp_free_atom(lp->pool, (void *)aij, (int )sizeof(GLPAIJ ));
#line 919
      (lp->nnz) --;
      }
    }
#line 902
    aij = next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 923
  if (col->stat == 1) {
#line 923
    lp->valid = 0;
  }
#line 924
  return;
}
}
#line 955 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_load_matrix(glp_prob *lp , int ne , int const   *ia , int const   *ja , double const   *ar ) 
{ 
  glp_tree___0 *tree ;
  GLPROW *row ;
  GLPCOL *col ;
  GLPAIJ *aij ;
  GLPAIJ *next ;
  int i ;
  int j ;
  int k ;
  xerror_t tmp ;
  int tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  xerror_t tmp___3 ;
  xerror_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  xerror_t tmp___7 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 957
  tree = (glp_tree___0 *)lp->tree;
#line 962
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 962
    if (tree->reason != 0) {
      {
#line 963
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 963);
#line 963
      (*tmp)("glp_load_matrix: operation not allowed\n");
      }
    }
  }
#line 965
  i = 1;
  {
#line 965
  while (1) {
    while_continue: /* CIL Label */ ;
#line 965
    if (! (i <= lp->m)) {
#line 965
      goto while_break;
    }
#line 966
    row = *(lp->row + i);
    {
#line 967
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 967
      if (! ((unsigned long )row->ptr != (unsigned long )((void *)0))) {
#line 967
        goto while_break___0;
      }
      {
#line 968
      aij = row->ptr;
#line 969
      row->ptr = aij->r_next;
#line 970
      _glp_dmp_free_atom(lp->pool, (void *)aij, (int )sizeof(GLPAIJ ));
#line 970
      (lp->nnz) --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 965
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  if (lp->nnz == 0) {
#line 973
    tmp___0 = 1;
  } else {
    {
#line 973
    _glp_lib_xassert("lp->nnz == 0", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                     973);
#line 973
    tmp___0 = 1;
    }
  }
#line 974
  j = 1;
  {
#line 974
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 974
    if (! (j <= lp->n)) {
#line 974
      goto while_break___1;
    }
#line 974
    (*(lp->col + j))->ptr = (GLPAIJ *)((void *)0);
#line 974
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 977
  if (ne < 0) {
    {
#line 978
    tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               978);
#line 978
    (*tmp___1)("glp_load_matrix: ne = %d; invalid number of constraint coefficients\n",
               ne);
    }
  }
#line 980
  if (ne > 500000000) {
    {
#line 981
    tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               981);
#line 981
    (*tmp___2)("glp_load_matrix: ne = %d; too many constraint coefficients\n", ne);
    }
  }
#line 983
  k = 1;
  {
#line 983
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 983
    if (! (k <= ne)) {
#line 983
      goto while_break___2;
    }
#line 985
    i = (int )*(ia + k);
#line 985
    j = (int )*(ja + k);
#line 987
    if (1 <= i) {
#line 987
      if (! (i <= lp->m)) {
        {
#line 988
        tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   988);
#line 988
        (*tmp___3)("glp_load_matrix: ia[%d] = %d; row index out of range\n", k, i);
        }
      }
    } else {
      {
#line 988
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 988);
#line 988
      (*tmp___3)("glp_load_matrix: ia[%d] = %d; row index out of range\n", k, i);
      }
    }
#line 990
    row = *(lp->row + i);
#line 992
    if (1 <= j) {
#line 992
      if (! (j <= lp->n)) {
        {
#line 993
        tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   993);
#line 993
        (*tmp___4)("glp_load_matrix: ja[%d] = %d; column index out of range\n", k,
                   j);
        }
      }
    } else {
      {
#line 993
      tmp___4 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 993);
#line 993
      (*tmp___4)("glp_load_matrix: ja[%d] = %d; column index out of range\n", k, j);
      }
    }
    {
#line 995
    col = *(lp->col + j);
#line 997
    tmp___5 = _glp_dmp_get_atom(lp->pool, (int )sizeof(GLPAIJ ));
#line 997
    aij = (GLPAIJ *)tmp___5;
#line 997
    (lp->nnz) ++;
#line 998
    aij->row = row;
#line 999
    aij->col = col;
#line 1000
    aij->val = (double )*(ar + k);
#line 1002
    aij->r_prev = (GLPAIJ *)((void *)0);
#line 1003
    aij->r_next = row->ptr;
    }
#line 1004
    if ((unsigned long )aij->r_next != (unsigned long )((void *)0)) {
#line 1004
      (aij->r_next)->r_prev = aij;
    }
#line 1005
    row->ptr = aij;
#line 983
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1007
  if (lp->nnz == ne) {
#line 1007
    tmp___6 = 1;
  } else {
    {
#line 1007
    _glp_lib_xassert("lp->nnz == ne", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                     1007);
#line 1007
    tmp___6 = 1;
    }
  }
#line 1010
  i = 1;
  {
#line 1010
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1010
    if (! (i <= lp->m)) {
#line 1010
      goto while_break___3;
    }
#line 1011
    aij = (*(lp->row + i))->ptr;
    {
#line 1011
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1011
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1011
        goto while_break___4;
      }
#line 1013
      col = aij->col;
#line 1016
      if ((unsigned long )col->ptr != (unsigned long )((void *)0)) {
#line 1016
        if (((col->ptr)->row)->i == i) {
#line 1017
          k = 1;
          {
#line 1017
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1017
            if (! (k <= ne)) {
#line 1017
              goto while_break___5;
            }
#line 1018
            if (*(ia + k) == (int const   )i) {
#line 1018
              if (*(ja + k) == (int const   )col->j) {
#line 1018
                goto while_break___5;
              }
            }
#line 1017
            k ++;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 1019
          tmp___7 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                     1019);
#line 1019
          (*tmp___7)("glp_load_mat: ia[%d] = %d; ja[%d] = %d; duplicate indices not allowed\n",
                     k, i, k, col->j);
          }
        }
      }
#line 1023
      aij->c_prev = (GLPAIJ *)((void *)0);
#line 1024
      aij->c_next = col->ptr;
#line 1025
      if ((unsigned long )aij->c_next != (unsigned long )((void *)0)) {
#line 1025
        (aij->c_next)->c_prev = aij;
      }
#line 1026
      col->ptr = aij;
#line 1011
      aij = aij->r_next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1010
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1030
  i = 1;
  {
#line 1030
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1030
    if (! (i <= lp->m)) {
#line 1030
      goto while_break___6;
    }
#line 1031
    row = *(lp->row + i);
#line 1032
    aij = row->ptr;
    {
#line 1032
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1032
      if (! ((unsigned long )aij != (unsigned long )((void *)0))) {
#line 1032
        goto while_break___7;
      }
#line 1033
      next = aij->r_next;
#line 1034
      if (aij->val == 0.0) {
#line 1036
        if ((unsigned long )aij->r_prev == (unsigned long )((void *)0)) {
#line 1037
          row->ptr = next;
        } else {
#line 1039
          (aij->r_prev)->r_next = next;
        }
#line 1040
        if (! ((unsigned long )next == (unsigned long )((void *)0))) {
#line 1043
          next->r_prev = aij->r_prev;
        }
#line 1045
        if ((unsigned long )aij->c_prev == (unsigned long )((void *)0)) {
#line 1046
          (aij->col)->ptr = aij->c_next;
        } else {
#line 1048
          (aij->c_prev)->c_next = aij->c_next;
        }
#line 1049
        if (! ((unsigned long )aij->c_next == (unsigned long )((void *)0))) {
#line 1052
          (aij->c_next)->c_prev = aij->c_prev;
        }
        {
#line 1054
        _glp_dmp_free_atom(lp->pool, (void *)aij, (int )sizeof(GLPAIJ ));
#line 1054
        (lp->nnz) --;
        }
      }
#line 1032
      aij = next;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1030
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1059
  lp->valid = 0;
#line 1060
  return;
}
}
#line 1083 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_del_rows(glp_prob *lp , int nrs , int const   *num ) 
{ 
  glp_tree___0 *tree ;
  GLPROW *row ;
  int i ;
  int k ;
  int m_new ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  xerror_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 1084
  tree = (glp_tree___0 *)lp->tree;
#line 1088
  if (1 <= nrs) {
#line 1088
    if (! (nrs <= lp->m)) {
      {
#line 1089
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 1089);
#line 1089
      (*tmp)("glp_del_rows: nrs = %d; invalid number of rows\n", nrs);
      }
    }
  } else {
    {
#line 1089
    tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 1089);
#line 1089
    (*tmp)("glp_del_rows: nrs = %d; invalid number of rows\n", nrs);
    }
  }
#line 1091
  k = 1;
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1091
    if (! (k <= nrs)) {
#line 1091
      goto while_break;
    }
#line 1093
    i = (int )*(num + k);
#line 1095
    if (1 <= i) {
#line 1095
      if (! (i <= lp->m)) {
        {
#line 1096
        tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   1096);
#line 1096
        (*tmp___0)("glp_del_rows: num[%d] = %d; row number out of range\n", k, i);
        }
      }
    } else {
      {
#line 1096
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 1096);
#line 1096
      (*tmp___0)("glp_del_rows: num[%d] = %d; row number out of range\n", k, i);
      }
    }
#line 1098
    row = *(lp->row + i);
#line 1099
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 1099
      if (tree->reason != 0) {
#line 1100
        if ((unsigned long )tree->curr != (unsigned long )((void *)0)) {
#line 1100
          tmp___1 = 1;
        } else {
          {
#line 1100
          _glp_lib_xassert("tree->curr != NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                           1100);
#line 1100
          tmp___1 = 1;
          }
        }
#line 1101
        if (row->level == (tree->curr)->level) {
#line 1101
          tmp___2 = 1;
        } else {
          {
#line 1101
          _glp_lib_xassert("row->level == tree->curr->level", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                           1101);
#line 1101
          tmp___2 = 1;
          }
        }
      }
    }
#line 1104
    if (row->i == 0) {
      {
#line 1105
      tmp___3 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 1105);
#line 1105
      (*tmp___3)("glp_del_rows: num[%d] = %d; duplicate row numbers not allowed\n",
                 k, i);
      }
    }
    {
#line 1108
    glp_set_row_name(lp, i, (char const   *)((void *)0));
    }
#line 1109
    if ((unsigned long )row->node == (unsigned long )((void *)0)) {
#line 1109
      tmp___4 = 1;
    } else {
      {
#line 1109
      _glp_lib_xassert("row->node == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                       1109);
#line 1109
      tmp___4 = 1;
      }
    }
    {
#line 1111
    glp_set_mat_row(lp, i, 0, (int const   *)((void *)0), (double const   *)((void *)0));
    }
#line 1112
    if ((unsigned long )row->ptr == (unsigned long )((void *)0)) {
#line 1112
      tmp___5 = 1;
    } else {
      {
#line 1112
      _glp_lib_xassert("row->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                       1112);
#line 1112
      tmp___5 = 1;
      }
    }
#line 1114
    row->i = 0;
#line 1091
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  m_new = 0;
#line 1118
  i = 1;
  {
#line 1118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1118
    if (! (i <= lp->m)) {
#line 1118
      goto while_break___0;
    }
#line 1120
    row = *(lp->row + i);
#line 1122
    if (row->i == 0) {
      {
#line 1124
      _glp_dmp_free_atom(lp->pool, (void *)row, (int )sizeof(GLPROW ));
      }
    } else {
#line 1128
      m_new ++;
#line 1128
      row->i = m_new;
#line 1129
      *(lp->row + row->i) = row;
    }
#line 1118
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1133
  lp->m = m_new;
#line 1135
  lp->valid = 0;
#line 1136
  return;
}
}
#line 1159 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_del_cols(glp_prob *lp , int ncs , int const   *num ) 
{ 
  glp_tree___0 *tree ;
  GLPCOL *col ;
  int j ;
  int k ;
  int n_new ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  xerror_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int m ;
  int *head ;
  int tmp___5 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 1160
  tree = (glp_tree___0 *)lp->tree;
#line 1163
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 1163
    if (tree->reason != 0) {
      {
#line 1164
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 1164);
#line 1164
      (*tmp)("glp_del_cols: operation not allowed\n");
      }
    }
  }
#line 1166
  if (1 <= ncs) {
#line 1166
    if (! (ncs <= lp->n)) {
      {
#line 1167
      tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 1167);
#line 1167
      (*tmp___0)("glp_del_cols: ncs = %d; invalid number of columns\n", ncs);
      }
    }
  } else {
    {
#line 1167
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               1167);
#line 1167
    (*tmp___0)("glp_del_cols: ncs = %d; invalid number of columns\n", ncs);
    }
  }
#line 1169
  k = 1;
  {
#line 1169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1169
    if (! (k <= ncs)) {
#line 1169
      goto while_break;
    }
#line 1171
    j = (int )*(num + k);
#line 1173
    if (1 <= j) {
#line 1173
      if (! (j <= lp->n)) {
        {
#line 1174
        tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                   1174);
#line 1174
        (*tmp___1)("glp_del_cols: num[%d] = %d; column number out of range", k, j);
        }
      }
    } else {
      {
#line 1174
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 1174);
#line 1174
      (*tmp___1)("glp_del_cols: num[%d] = %d; column number out of range", k, j);
      }
    }
#line 1176
    col = *(lp->col + j);
#line 1178
    if (col->j == 0) {
      {
#line 1179
      tmp___2 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 1179);
#line 1179
      (*tmp___2)("glp_del_cols: num[%d] = %d; duplicate column numbers not allowed\n",
                 k, j);
      }
    }
    {
#line 1182
    glp_set_col_name(lp, j, (char const   *)((void *)0));
    }
#line 1183
    if ((unsigned long )col->node == (unsigned long )((void *)0)) {
#line 1183
      tmp___3 = 1;
    } else {
      {
#line 1183
      _glp_lib_xassert("col->node == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                       1183);
#line 1183
      tmp___3 = 1;
      }
    }
    {
#line 1185
    glp_set_mat_col(lp, j, 0, (int const   *)((void *)0), (double const   *)((void *)0));
    }
#line 1186
    if ((unsigned long )col->ptr == (unsigned long )((void *)0)) {
#line 1186
      tmp___4 = 1;
    } else {
      {
#line 1186
      _glp_lib_xassert("col->ptr == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                       1186);
#line 1186
      tmp___4 = 1;
      }
    }
#line 1188
    col->j = 0;
#line 1190
    if (col->stat == 1) {
#line 1190
      lp->valid = 0;
    }
#line 1169
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1193
  n_new = 0;
#line 1194
  j = 1;
  {
#line 1194
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1194
    if (! (j <= lp->n)) {
#line 1194
      goto while_break___0;
    }
#line 1196
    col = *(lp->col + j);
#line 1198
    if (col->j == 0) {
      {
#line 1200
      _glp_dmp_free_atom(lp->pool, (void *)col, (int )sizeof(GLPCOL ));
      }
    } else {
#line 1204
      n_new ++;
#line 1204
      col->j = n_new;
#line 1205
      *(lp->col + col->j) = col;
    }
#line 1194
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1209
  lp->n = n_new;
#line 1211
  if (lp->valid) {
#line 1212
    m = lp->m;
#line 1213
    head = lp->head;
#line 1214
    j = 1;
    {
#line 1214
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1214
      if (! (j <= n_new)) {
#line 1214
        goto while_break___1;
      }
#line 1215
      k = (*(lp->col + j))->bind;
#line 1216
      if (k != 0) {
#line 1217
        if (1 <= k) {
#line 1217
          if (k <= m) {
#line 1217
            tmp___5 = 1;
          } else {
            {
#line 1217
            _glp_lib_xassert("1 <= k && k <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                             1217);
#line 1217
            tmp___5 = 1;
            }
          }
        } else {
          {
#line 1217
          _glp_lib_xassert("1 <= k && k <= m", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                           1217);
#line 1217
          tmp___5 = 1;
          }
        }
#line 1218
        *(head + k) = m + j;
      }
#line 1214
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1222
  return;
}
}
#line 1243 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_copy_prob(glp_prob *dest , glp_prob *prob , int names ) 
{ 
  glp_tree___0 *tree ;
  glp_bfcp bfcp ;
  int i ;
  int j ;
  int len ;
  int *ind ;
  double *val ;
  xerror_t tmp ;
  xerror_t tmp___0 ;
  xerror_t tmp___1 ;
  GLPROW *to ;
  GLPROW *from ;
  void *tmp___2 ;
  void *tmp___3 ;
  GLPCOL *to___0 ;
  GLPCOL *from___0 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1244
  tree = (glp_tree___0 *)dest->tree;
#line 1248
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 1248
    if (tree->reason != 0) {
      {
#line 1249
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 1249);
#line 1249
      (*tmp)("glp_copy_prob: operation not allowed\n");
      }
    }
  }
#line 1250
  if ((unsigned long )dest == (unsigned long )prob) {
    {
#line 1251
    tmp___0 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                               1251);
#line 1251
    (*tmp___0)("glp_copy_prob: copying problem object to itself not allowed\n");
    }
  }
#line 1253
  if (! (names == 1)) {
#line 1253
    if (! (names == 0)) {
      {
#line 1254
      tmp___1 = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                                 1254);
#line 1254
      (*tmp___1)("glp_copy_prob: names = %d; invalid parameter\n", names);
      }
    }
  }
  {
#line 1256
  glp_erase_prob(dest);
  }
#line 1257
  if (names) {
#line 1257
    if ((unsigned long )prob->name != (unsigned long )((void *)0)) {
      {
#line 1258
      glp_set_prob_name(dest, (char const   *)prob->name);
      }
    }
  }
#line 1259
  if (names) {
#line 1259
    if ((unsigned long )prob->obj != (unsigned long )((void *)0)) {
      {
#line 1260
      glp_set_obj_name(dest, (char const   *)prob->obj);
      }
    }
  }
#line 1261
  dest->dir = prob->dir;
#line 1262
  dest->c0 = prob->c0;
#line 1263
  if (prob->m > 0) {
    {
#line 1264
    glp_add_rows(dest, prob->m);
    }
  }
#line 1265
  if (prob->n > 0) {
    {
#line 1266
    glp_add_cols(dest, prob->n);
    }
  }
  {
#line 1267
  glp_get_bfcp(prob, & bfcp);
#line 1268
  glp_set_bfcp(dest, (glp_bfcp const   *)(& bfcp));
#line 1269
  dest->pbs_stat = prob->pbs_stat;
#line 1270
  dest->dbs_stat = prob->dbs_stat;
#line 1271
  dest->obj_val = prob->obj_val;
#line 1272
  dest->some = prob->some;
#line 1273
  dest->ipt_stat = prob->ipt_stat;
#line 1274
  dest->ipt_obj = prob->ipt_obj;
#line 1275
  dest->mip_stat = prob->mip_stat;
#line 1276
  dest->mip_obj = prob->mip_obj;
#line 1277
  i = 1;
  }
  {
#line 1277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1277
    if (! (i <= prob->m)) {
#line 1277
      goto while_break;
    }
#line 1278
    to = *(dest->row + i);
#line 1279
    from = *(prob->row + i);
#line 1280
    if (names) {
#line 1280
      if ((unsigned long )from->name != (unsigned long )((void *)0)) {
        {
#line 1281
        glp_set_row_name(dest, i, (char const   *)from->name);
        }
      }
    }
#line 1282
    to->type = from->type;
#line 1283
    to->lb = from->lb;
#line 1284
    to->ub = from->ub;
#line 1285
    to->rii = from->rii;
#line 1286
    to->stat = from->stat;
#line 1287
    to->prim = from->prim;
#line 1288
    to->dual = from->dual;
#line 1289
    to->pval = from->pval;
#line 1290
    to->dval = from->dval;
#line 1291
    to->mipx = from->mipx;
#line 1277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1293
  tmp___2 = _glp_lib_xcalloc(1 + prob->m, (int )sizeof(int ));
#line 1293
  ind = (int *)tmp___2;
#line 1294
  tmp___3 = _glp_lib_xcalloc(1 + prob->m, (int )sizeof(double ));
#line 1294
  val = (double *)tmp___3;
#line 1295
  j = 1;
  }
  {
#line 1295
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1295
    if (! (j <= prob->n)) {
#line 1295
      goto while_break___0;
    }
#line 1296
    to___0 = *(dest->col + j);
#line 1297
    from___0 = *(prob->col + j);
#line 1298
    if (names) {
#line 1298
      if ((unsigned long )from___0->name != (unsigned long )((void *)0)) {
        {
#line 1299
        glp_set_col_name(dest, j, (char const   *)from___0->name);
        }
      }
    }
    {
#line 1300
    to___0->kind = from___0->kind;
#line 1301
    to___0->type = from___0->type;
#line 1302
    to___0->lb = from___0->lb;
#line 1303
    to___0->ub = from___0->ub;
#line 1304
    to___0->coef = from___0->coef;
#line 1305
    len = glp_get_mat_col(prob, j, ind, val);
#line 1306
    glp_set_mat_col(dest, j, len, (int const   *)ind, (double const   *)val);
#line 1307
    to___0->sjj = from___0->sjj;
#line 1308
    to___0->stat = from___0->stat;
#line 1309
    to___0->prim = from___0->prim;
#line 1310
    to___0->dual = from___0->dual;
#line 1311
    to___0->pval = from___0->pval;
#line 1312
    to___0->dval = from___0->dval;
#line 1313
    to___0->mipx = from___0->mipx;
#line 1295
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1315
  _glp_lib_xfree((void *)ind);
#line 1316
  _glp_lib_xfree((void *)val);
  }
#line 1317
  return;
}
}
#line 1337
static void delete_prob(glp_prob *lp ) ;
#line 1339 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_erase_prob(glp_prob *lp ) 
{ 
  glp_tree___0 *tree ;
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1340
  tree = (glp_tree___0 *)lp->tree;
#line 1341
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 1341
    if (tree->reason != 0) {
      {
#line 1342
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 1342);
#line 1342
      (*tmp)("glp_erase_prob: operation not allowed\n");
      }
    }
  }
  {
#line 1343
  delete_prob(lp);
#line 1344
  create_prob(lp);
  }
#line 1345
  return;
}
}
#line 1362 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
static void delete_prob(glp_prob *lp ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1363
  _glp_dmp_delete_pool(lp->pool);
#line 1364
  _glp_lib_xfree(lp->cps);
  }
#line 1365
  if ((unsigned long )lp->tree == (unsigned long )((void *)0)) {
#line 1365
    tmp = 1;
  } else {
    {
#line 1365
    _glp_lib_xassert("lp->tree == NULL", "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c",
                     1365);
#line 1365
    tmp = 1;
    }
  }
#line 1366
  if ((unsigned long )lp->cwa != (unsigned long )((void *)0)) {
    {
#line 1366
    _glp_lib_xfree((void *)lp->cwa);
    }
  }
  {
#line 1367
  _glp_lib_xfree((void *)lp->row);
#line 1368
  _glp_lib_xfree((void *)lp->col);
  }
#line 1369
  if ((unsigned long )lp->r_tree != (unsigned long )((void *)0)) {
    {
#line 1369
    _glp_avl_delete_tree(lp->r_tree);
    }
  }
#line 1370
  if ((unsigned long )lp->c_tree != (unsigned long )((void *)0)) {
    {
#line 1370
    _glp_avl_delete_tree(lp->c_tree);
    }
  }
  {
#line 1371
  _glp_lib_xfree((void *)lp->head);
  }
#line 1372
  if ((unsigned long )lp->bfcp != (unsigned long )((void *)0)) {
    {
#line 1372
    _glp_lib_xfree((void *)lp->bfcp);
    }
  }
#line 1373
  if ((unsigned long )lp->bfd != (unsigned long )((void *)0)) {
    {
#line 1373
    _glp_bfd_delete_it(lp->bfd);
    }
  }
#line 1374
  return;
}
}
#line 1377 "/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c"
void glp_delete_prob(glp_prob *lp ) 
{ 
  glp_tree___0 *tree ;
  xerror_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1378
  tree = (glp_tree___0 *)lp->tree;
#line 1379
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 1379
    if (tree->reason != 0) {
      {
#line 1380
      tmp = _glp_lib_xerror1("/home/wslee/benchmarks/glpk-4.38/src/glpapi01.c", 1380);
#line 1380
      (*tmp)("glp_delete_prob: operation not allowed\n");
      }
    }
  }
  {
#line 1381
  delete_prob(lp);
#line 1382
  _glp_lib_xfree((void *)lp);
  }
#line 1383
  return;
}
}
#line 5 "/home/wslee/benchmarks/glpk-4.38/examples/glpsol.c"
int main(int argc , char const   **argv ) 
{ 
  int tmp ;

  {
  {
#line 7
  tmp = glp_main(argc, argv);
  }
#line 7
  return (tmp);
}
}
