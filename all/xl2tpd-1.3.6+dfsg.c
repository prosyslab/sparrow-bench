/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/scheduler.h"
struct schedule_entry {
   struct timeval tv ;
   void (*func)(void * ) ;
   void *data ;
   struct schedule_entry *next ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 20 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.h"
struct tunnel;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.h"
struct buffer {
   int type ;
   void *rstart ;
   void *rend ;
   void *start ;
   int len ;
   int maxlen ;
   struct sockaddr_in peer ;
   struct tunnel *tunnel ;
   int retries ;
};
#line 28 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct iprange {
   unsigned int start ;
   unsigned int end ;
   int sense ;
   struct iprange *next ;
};
#line 36 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct host {
   char hostname[80] ;
   int port ;
   struct host *next ;
};
#line 63 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct lns {
   struct lns *next ;
   int exclusive ;
   int active ;
   unsigned int localaddr ;
   int tun_rws ;
   int call_rws ;
   int rxspeed ;
   int txspeed ;
   int hbit ;
   int lbit ;
   int challenge ;
   int authpeer ;
   int authself ;
   char authname[80] ;
   char peername[80] ;
   char hostname[80] ;
   char entname[80] ;
   struct iprange *lacs ;
   struct iprange *range ;
   int assign_ip ;
   int passwdauth ;
   int pap_require ;
   int chap_require ;
   int pap_refuse ;
   int chap_refuse ;
   int idle ;
   unsigned int pridns ;
   unsigned int secdns ;
   unsigned int priwins ;
   unsigned int secwins ;
   int proxyarp ;
   int proxyauth ;
   int debug ;
   int pass_peer ;
   char pppoptfile[80] ;
   struct tunnel *t ;
};
#line 103
struct call;
#line 103 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct lac {
   struct lac *next ;
   struct host *lns ;
   struct schedule_entry *rsched ;
   int tun_rws ;
   int call_rws ;
   int rxspeed ;
   int txspeed ;
   int active ;
   int hbit ;
   int lbit ;
   int challenge ;
   unsigned int localaddr ;
   unsigned int remoteaddr ;
   char authname[80] ;
   char password[80] ;
   char peername[80] ;
   char hostname[80] ;
   char entname[80] ;
   int authpeer ;
   int authself ;
   int pap_require ;
   int chap_require ;
   int pap_refuse ;
   int chap_refuse ;
   int idle ;
   int autodial ;
   int defaultroute ;
   int redial ;
   int rmax ;
   int rtries ;
   int rtimeout ;
   int pass_peer ;
   char pppoptfile[80] ;
   int debug ;
   struct tunnel *t ;
   struct call *c ;
};
#line 13 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/common.h"
typedef unsigned short _u16;
#line 14 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/common.h"
typedef unsigned long long _u64;
#line 12 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/ipsecmast.h"
typedef uint32_t IPsecSAref_t;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.h"
struct call {
   int lbit ;
   int seq_reqd ;
   int tx_pkts ;
   int rx_pkts ;
   int tx_bytes ;
   int rx_bytes ;
   struct schedule_entry *zlb_xmit ;
   int prx ;
   int state ;
   int frame ;
   struct call *next ;
   int debug ;
   int msgtype ;
   int ourcid ;
   int cid ;
   int qcid ;
   int bearer ;
   unsigned int serno ;
   unsigned int addr ;
   int txspeed ;
   int rxspeed ;
   int ppd ;
   int physchan ;
   char dialed[120] ;
   char dialing[120] ;
   char subaddy[120] ;
   int needclose ;
   int closing ;
   struct tunnel *container ;
   int fd ;
   struct termios *oldptyconf ;
   int die ;
   int nego ;
   int pppd ;
   int result ;
   int error ;
   int fbit ;
   int ourfbit ;
   int cnu ;
   int pnu ;
   char errormsg[120] ;
   struct timeval lastsent ;
   _u16 data_seq_num ;
   _u16 data_rec_seq_num ;
   _u16 closeSs ;
   int pLr ;
   struct lns *lns ;
   struct lac *lac ;
   char dial_no[128] ;
};
#line 18 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.h"
struct avp_hdr {
   _u16 length ;
   _u16 vendorid ;
   _u16 attr ;
} __attribute__((__packed__)) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/md5.h"
typedef unsigned long uint32;
#line 10 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/md5.h"
struct MD5Context {
   uint32 buf[4] ;
   uint32 bits[2] ;
   unsigned char in[64] ;
};
#line 35 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.h"
struct challenge {
   struct MD5Context md5 ;
   unsigned char ss ;
   unsigned char secret[120] ;
   unsigned char *challenge ;
   unsigned int chal_len ;
   unsigned char response[16] ;
   unsigned char reply[16] ;
   unsigned char *vector ;
   unsigned int vector_len ;
   int state ;
};
#line 126 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
struct tunnel {
   struct call *call_head ;
   struct tunnel *next ;
   int fc ;
   struct schedule_entry *hello ;
   int ourfc ;
   int bc ;
   int hbit ;
   int ourbc ;
   _u64 tb ;
   _u64 ourtb ;
   int tid ;
   IPsecSAref_t refme ;
   IPsecSAref_t refhim ;
   int ourtid ;
   int qtid ;
   int firmware ;
   struct sockaddr_in peer ;
   int debug ;
   int nego ;
   int count ;
   int state ;
   _u16 control_seq_num ;
   _u16 control_rec_seq_num ;
   int cLr ;
   char hostname[120] ;
   char vendor[120] ;
   struct challenge chal_us ;
   struct challenge chal_them ;
   char secret[120] ;
   int sanity ;
   int rws ;
   int ourrws ;
   int rxspeed ;
   int txspeed ;
   int udp_fd ;
   int pppox_fd ;
   struct call *self ;
   struct lns *lns ;
   struct lac *lac ;
   struct in_pktinfo my_addr ;
};
#line 21 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
struct half_words {
   _u16 s0 ;
   _u16 s1 ;
   _u16 s2 ;
   _u16 s3 ;
} __attribute__((__packed__)) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 39 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.h"
struct ppp_opts {
   char option[120] ;
   struct ppp_opts *next ;
};
#line 143 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct global {
   unsigned int listenaddr ;
   int port ;
   char authfile[80] ;
   char altauthfile[80] ;
   char configfile[80] ;
   char altconfigfile[80] ;
   char pidfile[80] ;
   char controlfile[80] ;
   int daemon ;
   int accesscontrol ;
   int forceuserspace ;
   int packet_dump ;
   int debug_avp ;
   int debug_network ;
   int debug_tunnel ;
   int debug_state ;
   int ipsecsaref ;
   int sarefnum ;
};
#line 192 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
struct hw {
   _u16 s ;
} __attribute__((__packed__)) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 178 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
struct tunnel_list {
   struct tunnel *head ;
   int count ;
   int calls ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 27 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 24 "/usr/include/linux/if_pppol2tp.h"
struct pppol2tp_addr {
   __kernel_pid_t pid ;
   int fd ;
   struct sockaddr_in addr ;
   __u16 s_tunnel ;
   __u16 s_session ;
   __u16 d_tunnel ;
   __u16 d_session ;
};
#line 75 "/usr/include/linux/if_pppox.h"
struct sockaddr_pppol2tp {
   __kernel_sa_family_t sa_family ;
   unsigned int sa_protocol ;
   struct pppol2tp_addr pppol2tp ;
} __attribute__((__packed__)) ;
#line 234 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 239 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 237 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 232 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_7 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_7 fd_set;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 54 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
struct control_hdr {
   _u16 ver ;
   _u16 length ;
   _u16 tid ;
   _u16 cid ;
   _u16 Ns ;
   _u16 Nr ;
} __attribute__((__packed__)) ;
#line 77 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
struct payload_hdr {
   _u16 ver ;
   _u16 length ;
   _u16 tid ;
   _u16 cid ;
   _u16 Ns ;
   _u16 Nr ;
   _u16 o_size ;
} __attribute__((__packed__)) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.h"
struct avp {
   int num ;
   int m ;
   int (*handler)(struct tunnel * , struct call * , void * , int  ) ;
   char *description ;
};
#line 127 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
struct unaligned_u16 {
   _u16 s ;
} __attribute__((__packed__)) ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct keyword {
   char *keyword ;
   int (*handler)(char *word , char *value , int context , void *item ) ;
};
#line 29 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.h"
struct addr_ent {
   unsigned int addr ;
   struct addr_ent *next ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/scheduler.h"
struct schedule_entry *events  ;
#line 38
struct schedule_entry *schedule(struct timeval tv , void (*func)(void * ) , void *data ) ;
#line 43
__inline struct schedule_entry *aschedule(struct timeval tv , void (*func)(void * ) ,
                                          void *data ) ;
#line 48
void deschedule(struct schedule_entry *s ) ;
#line 51
void init_scheduler(void) ;
#line 54
struct timeval *process_schedule(struct timeval *ptv ) ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.h"
void l2tp_log(int level , char const   *fmt  , ...) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/scheduler.c"
void init_scheduler(void) 
{ 


  {
#line 25
  events = (struct schedule_entry *)((void *)0);
#line 26
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/scheduler.c"
struct timeval *process_schedule(struct timeval *ptv ) 
{ 
  struct schedule_entry *p ;
  struct timeval now ;
  struct timeval then ;
  int tmp ;

  {
#line 34
  p = events;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! events) {
#line 37
      goto while_break;
    }
    {
#line 39
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 40
    p = events;
    }
#line 41
    if (p->tv.tv_sec == now.tv_sec) {
#line 41
      tmp = p->tv.tv_usec <= now.tv_usec;
    } else {
#line 41
      tmp = p->tv.tv_sec <= now.tv_sec;
    }
#line 41
    if (tmp) {
      {
#line 43
      events = events->next;
#line 47
      (*(p->func))(p->data);
#line 48
      free((void *)p);
      }
    } else {
#line 51
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (events) {
#line 58
    then.tv_sec = events->tv.tv_sec - now.tv_sec;
#line 59
    then.tv_usec = events->tv.tv_usec - now.tv_usec;
#line 60
    if (then.tv_usec < 0L) {
#line 62
      (then.tv_sec) --;
#line 63
      then.tv_usec += 1000000L;
    }
#line 65
    if (then.tv_sec <= 0L) {
#line 65
      if (then.tv_usec <= 0L) {
        {
#line 67
        l2tp_log(4, "%s: Whoa...  Scheduling for <=0 time???\n", "process_schedule");
#line 69
        then.tv_sec = (__time_t )1;
#line 70
        then.tv_usec = (__suseconds_t )0;
        }
      }
    }
#line 72
    *ptv = then;
#line 73
    return (ptv);
  } else {
#line 77
    return ((struct timeval *)((void *)0));
  }
}
}
#line 81 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/scheduler.c"
struct schedule_entry *schedule(struct timeval tv , void (*func)(void * ) , void *data ) 
{ 
  struct schedule_entry *p ;
  struct schedule_entry *q ;
  struct timeval diff ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 88
  p = events;
#line 88
  q = (struct schedule_entry *)((void *)0);
#line 90
  diff = tv;
#line 91
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 92
  tv.tv_sec += diff.tv_sec;
#line 93
  tv.tv_usec += diff.tv_usec;
  }
#line 94
  if (tv.tv_usec > 1000000L) {
#line 96
    (tv.tv_sec) ++;
#line 97
    tv.tv_usec -= 1000000L;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
#line 101
    if (tv.tv_sec == p->tv.tv_sec) {
#line 101
      tmp = tv.tv_usec < p->tv.tv_usec;
    } else {
#line 101
      tmp = tv.tv_sec < p->tv.tv_sec;
    }
#line 101
    if (tmp) {
#line 102
      goto while_break;
    }
#line 103
    q = p;
#line 104
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (q) {
    {
#line 108
    tmp___0 = malloc(sizeof(struct schedule_entry ));
#line 108
    q->next = (struct schedule_entry *)tmp___0;
#line 110
    q = q->next;
    }
  } else {
    {
#line 114
    tmp___1 = malloc(sizeof(struct schedule_entry ));
#line 114
    q = (struct schedule_entry *)tmp___1;
#line 115
    events = q;
    }
  }
#line 117
  q->tv = tv;
#line 118
  q->func = func;
#line 119
  q->data = data;
#line 120
  q->next = p;
#line 121
  return (q);
}
}
#line 125 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/scheduler.c"
__inline struct schedule_entry *aschedule(struct timeval tv , void (*func)(void * ) ,
                                          void *data ) 
{ 
  struct timeval now ;
  struct schedule_entry *tmp ;

  {
  {
#line 131
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 132
  tv.tv_usec -= now.tv_usec;
  }
#line 133
  if (tv.tv_usec < 0L) {
#line 135
    tv.tv_usec += 1000000L;
#line 136
    (tv.tv_sec) --;
  }
  {
#line 138
  tv.tv_sec -= now.tv_sec;
#line 139
  tmp = schedule(tv, func, data);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/scheduler.c"
void deschedule(struct schedule_entry *s ) 
{ 
  struct schedule_entry *p ;
  struct schedule_entry *q ;

  {
#line 144
  p = events;
#line 144
  q = (struct schedule_entry *)((void *)0);
#line 145
  if (! s) {
#line 146
    return;
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! p) {
#line 147
      goto while_break;
    }
#line 149
    if ((unsigned long )p == (unsigned long )s) {
#line 151
      if (q) {
#line 153
        q->next = p->next;
      } else {
#line 157
        events = events->next;
      }
      {
#line 159
      free((void *)p);
      }
#line 160
      goto while_break;
    }
#line 162
    q = p;
#line 163
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 117 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.h"
int add_challenge_avp(struct buffer *buf , unsigned char *c , int len ) ;
#line 118
int add_avp_rws(struct buffer *buf , _u16 rws ) ;
#line 119
int add_tunnelid_avp(struct buffer *buf , _u16 tid ) ;
#line 120
int add_vendor_avp(struct buffer *buf ) ;
#line 121
int add_hostname_avp(struct buffer *buf , char const   *hostname___0 ) ;
#line 122
int add_firmware_avp(struct buffer *buf ) ;
#line 123
int add_bearer_caps_avp(struct buffer *buf , _u16 caps ) ;
#line 124
int add_frame_caps_avp(struct buffer *buf , _u16 caps ) ;
#line 125
int add_protocol_avp(struct buffer *buf ) ;
#line 126
int add_message_type_avp(struct buffer *buf , _u16 type ) ;
#line 127
int add_result_code_avp(struct buffer *buf , _u16 result , _u16 error , char *msg ,
                        int len ) ;
#line 128
int add_bearer_avp(struct buffer *buf , int bearer ) ;
#line 129
int add_frame_avp(struct buffer *buf , int frame ) ;
#line 130
int add_rxspeed_avp(struct buffer *buf , int speed ) ;
#line 131
int add_txspeed_avp(struct buffer *buf , int speed ) ;
#line 132
int add_serno_avp(struct buffer *buf , unsigned int serno ) ;
#line 136
int add_callid_avp(struct buffer *buf , _u16 callid ) ;
#line 138
int add_ppd_avp(struct buffer *buf , _u16 ppd___0 ) ;
#line 139
int add_seqreqd_avp(struct buffer *buf ) ;
#line 140
int add_chalresp_avp(struct buffer *buf , unsigned char *c , int len ) ;
#line 141
int add_randvect_avp(struct buffer *buf , unsigned char *c , int len ) ;
#line 142
int add_minbps_avp(struct buffer *buf , int speed ) ;
#line 143
int add_maxbps_avp(struct buffer *buf , int speed ) ;
#line 144
int add_number_avp(struct buffer *buf , char *no ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
void add_nonmandatory_header(struct buffer *buf , _u16 length , _u16 type ) 
{ 
  struct avp_hdr *avp ;

  {
  {
#line 30
  avp = (struct avp_hdr *)(buf->start + buf->len);
#line 31
  avp->length = htons(length);
#line 32
  avp->vendorid = htons((uint16_t )0);
#line 33
  avp->attr = htons(type);
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
void add_header(struct buffer *buf , _u16 length , _u16 type ) 
{ 


  {
  {
#line 37
  add_nonmandatory_header(buf, (_u16 )((int )length | 32768), type);
  }
#line 38
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_message_type_avp(struct buffer *buf , _u16 type ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 49
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 50
  add_header(buf, (_u16 )8, (_u16 )0);
#line 51
  ptr->s0 = htons(type);
#line 52
  buf->len += 8;
  }
#line 53
  return (0);
}
}
#line 56 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_protocol_avp(struct buffer *buf ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 58
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 59
  add_header(buf, (_u16 )8, (_u16 )2);
#line 60
  ptr->s0 = htons((uint16_t )256);
#line 61
  buf->len += 8;
  }
#line 62
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_frame_caps_avp(struct buffer *buf , _u16 caps ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 67
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 68
  add_header(buf, (_u16 )10, (_u16 )3);
#line 69
  ptr->s0 = (_u16 )0;
#line 70
  ptr->s1 = htons(caps);
#line 71
  buf->len += 10;
  }
#line 72
  return (0);
}
}
#line 75 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_bearer_caps_avp(struct buffer *buf , _u16 caps ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 77
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 78
  add_header(buf, (_u16 )10, (_u16 )4);
#line 79
  ptr->s0 = (_u16 )0;
#line 80
  ptr->s1 = htons(caps);
#line 81
  buf->len += 10;
  }
#line 82
  return (0);
}
}
#line 87 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_firmware_avp(struct buffer *buf ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 89
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 90
  add_nonmandatory_header(buf, (_u16 )8, (_u16 )6);
#line 91
  ptr->s0 = htons((uint16_t )1680);
#line 92
  buf->len += 8;
  }
#line 93
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_hostname_avp(struct buffer *buf , char const   *hostname___0 ) 
{ 
  size_t namelen ;
  size_t tmp ;

  {
  {
#line 98
  tmp = strlen(hostname___0);
#line 98
  namelen = tmp;
  }
#line 99
  if (namelen > 1017UL) {
#line 100
    namelen = (size_t )1017;
  }
  {
#line 102
  add_header(buf, (_u16 )(6UL + namelen), (_u16 )7);
#line 103
  strncpy((char */* __restrict  */)((char *)((buf->start + buf->len) + sizeof(struct avp_hdr ))),
          (char const   */* __restrict  */)hostname___0, namelen);
#line 105
  buf->len = (int )((size_t )buf->len + (6UL + namelen));
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_vendor_avp(struct buffer *buf ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 111
  tmp = strlen("xelerance.com");
#line 111
  add_nonmandatory_header(buf, (_u16 )(6UL + tmp), (_u16 )8);
#line 112
  strcpy((char */* __restrict  */)((char *)((buf->start + buf->len) + sizeof(struct avp_hdr ))),
         (char const   */* __restrict  */)"xelerance.com");
#line 113
  tmp___0 = strlen("xelerance.com");
#line 113
  buf->len = (int )((size_t )buf->len + (6UL + tmp___0));
  }
#line 114
  return (0);
}
}
#line 117 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_tunnelid_avp(struct buffer *buf , _u16 tid ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 119
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 120
  add_header(buf, (_u16 )8, (_u16 )9);
#line 121
  ptr->s0 = htons(tid);
#line 122
  buf->len += 8;
  }
#line 123
  return (0);
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_avp_rws(struct buffer *buf , _u16 rws ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 128
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 129
  add_header(buf, (_u16 )8, (_u16 )10);
#line 130
  ptr->s0 = htons(rws);
#line 131
  buf->len += 8;
  }
#line 132
  return (0);
}
}
#line 135 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_challenge_avp(struct buffer *buf , unsigned char *c , int len ) 
{ 


  {
  {
#line 137
  add_header(buf, (_u16 )(6 + len), (_u16 )11);
#line 138
  memcpy((void */* __restrict  */)((char *)((buf->start + buf->len) + sizeof(struct avp_hdr ))),
         (void const   */* __restrict  */)c, (size_t )len);
#line 139
  buf->len += 6 + len;
  }
#line 140
  return (0);
}
}
#line 143 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_chalresp_avp(struct buffer *buf , unsigned char *c , int len ) 
{ 


  {
  {
#line 145
  add_header(buf, (_u16 )(6 + len), (_u16 )13);
#line 146
  memcpy((void */* __restrict  */)((char *)((buf->start + buf->len) + sizeof(struct avp_hdr ))),
         (void const   */* __restrict  */)c, (size_t )len);
#line 147
  buf->len += 6 + len;
  }
#line 148
  return (0);
}
}
#line 151 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_randvect_avp(struct buffer *buf , unsigned char *c , int len ) 
{ 


  {
  {
#line 153
  add_header(buf, (_u16 )(6 + len), (_u16 )36);
#line 154
  memcpy((void */* __restrict  */)((char *)((buf->start + buf->len) + sizeof(struct avp_hdr ))),
         (void const   */* __restrict  */)c, (size_t )len);
#line 155
  buf->len += 6 + len;
  }
#line 156
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_result_code_avp(struct buffer *buf , _u16 result , _u16 error , char *msg ,
                        int len ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 162
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 163
  add_header(buf, (_u16 )(10 + len), (_u16 )1);
#line 164
  ptr->s0 = htons(result);
#line 165
  ptr->s1 = htons(error);
#line 166
  memcpy((void */* __restrict  */)((char *)(& ptr->s2)), (void const   */* __restrict  */)msg,
         (size_t )len);
#line 167
  buf->len += 10 + len;
  }
#line 168
  return (0);
}
}
#line 175 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_callid_avp(struct buffer *buf , _u16 callid ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 178
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 183
  add_header(buf, (_u16 )8, (_u16 )14);
#line 184
  ptr->s0 = htons(callid);
#line 185
  buf->len += 8;
  }
#line 190
  return (0);
}
}
#line 193 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_serno_avp(struct buffer *buf , unsigned int serno ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 195
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 196
  add_header(buf, (_u16 )10, (_u16 )15);
#line 197
  ptr->s0 = htons((uint16_t )((serno >> 16) & 65535U));
#line 198
  ptr->s1 = htons((uint16_t )(serno & 65535U));
#line 199
  buf->len += 10;
  }
#line 200
  return (0);
}
}
#line 203 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_bearer_avp(struct buffer *buf , int bearer ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 205
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 206
  add_header(buf, (_u16 )10, (_u16 )18);
#line 207
  ptr->s0 = htons((uint16_t )((bearer >> 16) & 65535));
#line 208
  ptr->s1 = htons((uint16_t )(bearer & 65535));
#line 209
  buf->len += 10;
  }
#line 210
  return (0);
}
}
#line 213 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_frame_avp(struct buffer *buf , int frame ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 215
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 216
  add_header(buf, (_u16 )10, (_u16 )19);
#line 217
  ptr->s0 = htons((uint16_t )((frame >> 16) & 65535));
#line 218
  ptr->s1 = htons((uint16_t )(frame & 65535));
#line 219
  buf->len += 10;
  }
#line 220
  return (0);
}
}
#line 223 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_txspeed_avp(struct buffer *buf , int speed ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 225
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 226
  add_header(buf, (_u16 )10, (_u16 )24);
#line 227
  ptr->s0 = htons((uint16_t )((speed >> 16) & 65535));
#line 228
  ptr->s1 = htons((uint16_t )(speed & 65535));
#line 229
  buf->len += 10;
  }
#line 230
  return (0);
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_rxspeed_avp(struct buffer *buf , int speed ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 235
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 236
  add_nonmandatory_header(buf, (_u16 )10, (_u16 )38);
#line 237
  ptr->s0 = htons((uint16_t )((speed >> 16) & 65535));
#line 238
  ptr->s1 = htons((uint16_t )(speed & 65535));
#line 239
  buf->len += 10;
  }
#line 240
  return (0);
}
}
#line 243 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_physchan_avp(struct buffer *buf , unsigned int physchan ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 245
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 246
  add_nonmandatory_header(buf, (_u16 )10, (_u16 )25);
#line 247
  ptr->s0 = htons((uint16_t )((physchan >> 16) & 65535U));
#line 248
  ptr->s1 = htons((uint16_t )(physchan & 65535U));
#line 249
  buf->len += 10;
  }
#line 250
  return (0);
}
}
#line 253 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_ppd_avp(struct buffer *buf , _u16 ppd___0 ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 255
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 256
  add_header(buf, (_u16 )8, (_u16 )20);
#line 257
  ptr->s0 = htons(ppd___0);
#line 258
  buf->len += 8;
  }
#line 259
  return (0);
}
}
#line 262 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_seqreqd_avp(struct buffer *buf ) 
{ 


  {
  {
#line 264
  add_header(buf, (_u16 )6, (_u16 )39);
#line 265
  buf->len += 6;
  }
#line 266
  return (0);
}
}
#line 272 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_minbps_avp(struct buffer *buf , int speed ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 274
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 275
  add_header(buf, (_u16 )10, (_u16 )16);
#line 276
  ptr->s0 = htons((uint16_t )((speed >> 16) & 65535));
#line 277
  ptr->s1 = htons((uint16_t )(speed & 65535));
#line 278
  buf->len += 10;
  }
#line 279
  return (0);
}
}
#line 283 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_maxbps_avp(struct buffer *buf , int speed ) 
{ 
  struct half_words *ptr ;

  {
  {
#line 285
  ptr = (struct half_words *)((buf->start + buf->len) + sizeof(struct avp_hdr ));
#line 286
  add_header(buf, (_u16 )10, (_u16 )17);
#line 287
  ptr->s0 = htons((uint16_t )((speed >> 16) & 65535));
#line 288
  ptr->s1 = htons((uint16_t )(speed & 65535));
#line 289
  buf->len += 10;
  }
#line 290
  return (0);
}
}
#line 294 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avpsend.c"
int add_number_avp(struct buffer *buf , char *no ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 296
  tmp = strlen((char const   *)no);
#line 296
  add_header(buf, (_u16 )(6UL + tmp), (_u16 )21);
#line 297
  tmp___0 = strlen((char const   *)no);
#line 297
  strncpy((char */* __restrict  */)((char *)((buf->start + buf->len) + sizeof(struct avp_hdr ))),
          (char const   */* __restrict  */)no, tmp___0);
#line 298
  tmp___1 = strlen((char const   *)no);
#line 298
  buf->len = (int )((size_t )buf->len + (6UL + tmp___1));
  }
#line 299
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 580
extern int putchar(int __c ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 65 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.h"
struct buffer *new_buf(int size ) ;
#line 68
__inline void swaps(void *buf_v , int len ) ;
#line 69
void do_packet_dump(struct buffer *buf ) ;
#line 74
__inline void recycle_buf(struct buffer *b ) ;
#line 75
__inline void safe_copy(char *a , char *b , int size ) ;
#line 76
void opt_destroy(struct ppp_opts *option ) ;
#line 77
struct ppp_opts *add_opt(struct ppp_opts *option , char *fmt  , ...) ;
#line 167 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct global gconfig ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/common.h"
int rand_source ;
#line 99 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.h"
__inline void toss(struct buffer *buf ) ;
#line 106
void set_error(struct call *c , int error , char const   *fmt  , ...) ;
#line 231 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
int get_entropy(unsigned char *buf , int count ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
static int syslog_nesting  =    0;
#line 44
void init_log(void) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
static int logopen  =    0;
#line 42 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
void init_log(void) 
{ 


  {
#line 46
  if (! logopen) {
    {
#line 47
    while (1) {
      while_continue: /* CIL Label */ ;
#line 47
      syslog_nesting ++;
#line 47
      if (syslog_nesting < 2) {
        {
#line 47
        openlog("xl2tpd", 1, 3 << 3);
        }
      }
#line 47
      syslog_nesting --;
#line 47
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 48
    logopen = 1;
  }
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
void l2tp_log(int level , char const   *fmt  , ...) 
{ 
  char buf[2048] ;
  va_list args___0 ;
  __pid_t tmp ;

  {
  {
#line 56
  __builtin_va_start(args___0, fmt);
#line 57
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
            args___0);
#line 58
  __builtin_va_end(args___0);
  }
#line 60
  if (gconfig.daemon) {
    {
#line 61
    init_log();
    }
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 62
      syslog_nesting ++;
#line 62
      if (syslog_nesting < 2) {
        {
#line 62
        syslog(level, "%s", buf);
        }
      }
#line 62
      syslog_nesting --;
#line 62
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 64
    tmp = getpid();
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xl2tpd[%d]: %s",
            tmp, buf);
    }
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
void set_error(struct call *c , int error , char const   *fmt  , ...) 
{ 
  va_list args___0 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 71
  __builtin_va_start(args___0, fmt);
#line 72
  c->error = error;
#line 73
  c->result = 2;
#line 74
  c->needclose = -1;
#line 75
  vsnprintf((char */* __restrict  */)(c->errormsg), sizeof(c->errormsg), (char const   */* __restrict  */)fmt,
            args___0);
#line 76
  tmp___0 = strlen((char const   *)(c->errormsg));
  }
#line 76
  if ((int )c->errormsg[tmp___0 - 1UL] == 10) {
    {
#line 77
    tmp = strlen((char const   *)(c->errormsg));
#line 77
    c->errormsg[tmp - 1UL] = (char)0;
    }
  }
  {
#line 78
  __builtin_va_end(args___0);
  }
#line 79
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
struct buffer *new_buf(int size ) 
{ 
  struct buffer *b ;
  void *tmp ;

  {
  {
#line 83
  tmp = malloc(sizeof(struct buffer ));
#line 83
  b = (struct buffer *)tmp;
  }
#line 85
  if (! b) {
#line 86
    return ((struct buffer *)((void *)0));
  } else
#line 85
  if (! size) {
#line 86
    return ((struct buffer *)((void *)0));
  } else
#line 85
  if (size < 0) {
#line 86
    return ((struct buffer *)((void *)0));
  }
  {
#line 87
  b->rstart = malloc((size_t )size);
  }
#line 88
  if (! b->rstart) {
    {
#line 90
    free((void *)b);
    }
#line 91
    return ((struct buffer *)((void *)0));
  }
#line 93
  b->start = b->rstart;
#line 94
  b->rend = (b->rstart + size) - 1;
#line 95
  b->len = size;
#line 96
  b->maxlen = size;
#line 97
  return (b);
}
}
#line 100 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
__inline void recycle_buf(struct buffer *b ) 
{ 


  {
#line 102
  b->start = b->rstart;
#line 103
  b->len = b->maxlen;
#line 104
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
void bufferDump(unsigned char *buf , int buflen ) 
{ 
  int i ;
  int j ;
  char line[33] ;
  char *c ;

  {
#line 109
  i = 0;
#line 109
  j = 0;
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < buflen / 16)) {
#line 113
      goto while_break;
    }
#line 115
    c = line;
#line 116
    j = 0;
    {
#line 116
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 116
      if (! (j < 16)) {
#line 116
        goto while_break___0;
      }
      {
#line 118
      sprintf((char */* __restrict  */)c, (char const   */* __restrict  */)"%02x",
              (int )*(buf + (i * 16 + j)) & 255);
#line 119
      c ++;
#line 120
      c ++;
#line 116
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 122
    *c = (char )'\000';
#line 123
    l2tp_log(4, "%s: buflen=%d, buffer[%d]: *%s*\n", "bufferDump", buflen, i, line);
#line 113
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  c = line;
#line 129
  j = 0;
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 129
    if (! (j < buflen % 16)) {
#line 129
      goto while_break___1;
    }
    {
#line 131
    sprintf((char */* __restrict  */)c, (char const   */* __restrict  */)"%02x", (int )*(buf + ((buflen / 16) * 16 + j)) & 255);
#line 134
    c ++;
#line 135
    c ++;
#line 129
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 137
  if ((unsigned long )c != (unsigned long )(line)) {
    {
#line 139
    *c = (char )'\000';
#line 140
    l2tp_log(4, "%s:             buffer[%d]: *%s*\n", "bufferDump", i, line);
    }
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
void do_packet_dump(struct buffer *buf ) 
{ 
  int x ;
  unsigned char *c ;

  {
  {
#line 149
  c = (unsigned char *)buf->start;
#line 150
  printf((char const   */* __restrict  */)"packet dump: \nHEX: { ");
#line 151
  x = 0;
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (x < buf->len)) {
#line 151
      goto while_break;
    }
    {
#line 153
    printf((char const   */* __restrict  */)"%.2X ", (int )*c);
#line 154
    c ++;
#line 151
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  printf((char const   */* __restrict  */)"}\nASCII: { ");
#line 157
  c = (unsigned char *)buf->start;
#line 158
  x = 0;
  }
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 158
    if (! (x < buf->len)) {
#line 158
      goto while_break___0;
    }
#line 160
    if ((int )*c > 31) {
#line 160
      if ((int )*c < 127) {
        {
#line 162
        putchar((int )*c);
        }
      } else {
        {
#line 166
        putchar(' ');
        }
      }
    } else {
      {
#line 166
      putchar(' ');
      }
    }
#line 168
    c ++;
#line 158
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 170
  printf((char const   */* __restrict  */)"}\n");
  }
#line 171
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
__inline void swaps(void *buf_v , int len ) 
{ 
  int x ;
  struct hw *p ;

  {
#line 192
  p = (struct hw *)buf_v;
#line 193
  x = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (x < len / 2)) {
#line 193
      goto while_break;
    }
    {
#line 194
    p->s = ntohs(p->s);
#line 193
    x ++;
#line 193
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
__inline void toss(struct buffer *buf ) 
{ 


  {
  {
#line 206
  free(buf->rstart);
#line 207
  free((void *)buf);
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
__inline void safe_copy(char *a , char *b , int size ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 214
  if (size < 119) {
#line 214
    tmp = size;
  } else {
#line 214
    tmp = 119;
  }
  {
#line 214
  strncpy((char */* __restrict  */)a, (char const   */* __restrict  */)b, (size_t )tmp);
  }
#line 215
  if (size < 119) {
#line 215
    tmp___0 = size;
  } else {
#line 215
    tmp___0 = 119;
  }
#line 215
  *(a + tmp___0) = (char )'\000';
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
struct ppp_opts *add_opt(struct ppp_opts *option , char *fmt  , ...) 
{ 
  va_list args___0 ;
  struct ppp_opts *new ;
  struct ppp_opts *last ;
  void *tmp ;

  {
  {
#line 222
  tmp = malloc(sizeof(struct ppp_opts ));
#line 222
  new = (struct ppp_opts *)tmp;
  }
#line 223
  if (! new) {
    {
#line 225
    l2tp_log(4, "%s : Unable to allocate ppp option memory.  Expect a crash\n", "add_opt");
    }
#line 228
    return ((struct ppp_opts *)((void *)0));
  }
  {
#line 230
  new->next = (struct ppp_opts *)((void *)0);
#line 231
  __builtin_va_start(args___0, fmt);
#line 232
  vsnprintf((char */* __restrict  */)(new->option), sizeof(new->option), (char const   */* __restrict  */)fmt,
            args___0);
#line 233
  __builtin_va_end(args___0);
  }
#line 234
  if (option) {
#line 236
    last = option;
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
#line 237
      if (! last->next) {
#line 237
        goto while_break;
      }
#line 238
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 239
    last->next = new;
#line 240
    return (option);
  } else {
#line 243
    return (new);
  }
}
}
#line 245 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
void opt_destroy(struct ppp_opts *option ) 
{ 
  struct ppp_opts *tmp ;

  {
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! option) {
#line 248
      goto while_break;
    }
    {
#line 250
    tmp = option->next;
#line 251
    free((void *)option);
#line 252
    option = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
int get_egd_entropy(char *buf , int count ) 
{ 


  {
#line 258
  return (-1);
}
}
#line 261 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
int get_sys_entropy(unsigned char *buf , int count ) 
{ 
  int counter ;
  int tmp ;

  {
#line 272
  counter = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (counter < count)) {
#line 272
      goto while_break;
    }
    {
#line 274
    tmp = rand();
#line 274
    *(buf + counter) = (unsigned char )((char )tmp);
#line 272
    counter ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return (count);
}
}
#line 282 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
int get_dev_entropy(unsigned char *buf , int count ) 
{ 
  int devrandom ;
  ssize_t entropy_amount ;
  int tmp ;

  {
  {
#line 287
  devrandom = open("/dev/urandom", 2048);
  }
#line 288
  if (devrandom == -1) {
    {
#line 295
    tmp = get_sys_entropy(buf, count);
    }
#line 295
    return (tmp);
  }
  {
#line 297
  entropy_amount = read(devrandom, (void *)buf, (size_t )count);
#line 298
  close(devrandom);
  }
#line 299
  return ((int )entropy_amount);
}
}
#line 302 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.c"
int get_entropy(unsigned char *buf , int count ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 304
  if (rand_source == 1) {
    {
#line 306
    tmp = get_sys_entropy(buf, count);
    }
#line 306
    return (tmp);
  } else
#line 308
  if (rand_source == 0) {
    {
#line 310
    tmp___0 = get_dev_entropy(buf, count);
    }
#line 310
    return (tmp___0);
  } else
#line 312
  if (rand_source == 2) {
    {
#line 314
    l2tp_log(4, "%s: EGD Randomness source not yet implemented\n", "get_entropy");
    }
#line 317
    return (-1);
  } else {
    {
#line 321
    l2tp_log(4, "%s: Invalid Randomness source specified (%d)\n", "get_entropy", rand_source);
    }
#line 324
    return (-1);
  }
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 350 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 63 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.h"
char hostname[256] ;
#line 71
void status_handler(int sig ) ;
#line 72
int getPtyMaster(char *ttybuf , int ttybuflen ) ;
#line 73
void do_control(void) ;
#line 78
void process_signal(void) ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct lns *lnslist ;
#line 170
struct lac *laclist ;
#line 172
struct lac *deflac ;
#line 173
int init_config(void) ;
#line 176
int parse_one_option(char *word , char *value , int context , void *item ) ;
#line 178
struct lac *new_lac(void) ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/common.h"
int rand_source  ;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.h"
struct call *get_call(int tunnel , int call , struct in_addr addr , int port , IPsecSAref_t refme ,
                      IPsecSAref_t refhim ) ;
#line 104
void destroy_call(struct call *c ) ;
#line 105
struct call *new_call(struct tunnel *parent ) ;
#line 108
void call_close(struct call *c ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.h"
int control_finish(struct tunnel *t , struct call *c ) ;
#line 63
void hello(void *tun ) ;
#line 64
void send_zlb(void *data ) ;
#line 65
void dethrottle(void *call ) ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.h"
void init_addr(void) ;
#line 208 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
struct tunnel_list tunnels  ;
#line 210
void network_thread(void) ;
#line 211
int init_network(void) ;
#line 212
int server_socket ;
#line 213
struct tunnel *new_tunnel(void) ;
#line 215
void destroy_tunnel(struct tunnel *t ) ;
#line 221
void control_xmit(void *b ) ;
#line 222
int ppd ;
#line 223
int switch_io ;
#line 224 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
int control_fd  ;
#line 226
int kernel_support ;
#line 229
int start_pppd(struct call *c , struct ppp_opts *opts ) ;
#line 230
void magic_lac_dial(void *data ) ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
int ppd  =    1;
#line 59 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
char *args  ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
char *dial_no_tmp  ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
int switch_io  =    0;
#line 64
static void open_controlfd(void) ;
#line 66 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
sig_atomic_t volatile   sigterm_received  ;
#line 67 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
sig_atomic_t volatile   sigint_received  ;
#line 68 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
sig_atomic_t volatile   sigchld_received  ;
#line 69 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
sig_atomic_t volatile   sigusr1_received  ;
#line 70 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
sig_atomic_t volatile   sighup_received  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void init_tunnel_list(struct tunnel_list *t ) 
{ 


  {
#line 74
  t->head = (struct tunnel *)((void *)0);
#line 75
  t->count = 0;
#line 76
  t->calls = 0;
#line 77
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void show_status(void) 
{ 
  struct schedule_entry *se ;
  struct tunnel *t ;
  struct call *c ;
  struct lns *tlns ;
  struct lac *tlac ;
  struct host *h ;
  unsigned long cnt ;
  int s ;
  uint16_t tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 88
  cnt = 0UL;
#line 90
  s = 0;
#line 91
  l2tp_log(4, "====== xl2tpd statistics ========\n");
#line 92
  l2tp_log(4, " Scheduler entries:\n");
#line 93
  se = events;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! se) {
#line 94
      goto while_break;
    }
#line 96
    s ++;
#line 97
    t = (struct tunnel *)se->data;
#line 98
    tlac = (struct lac *)se->data;
#line 99
    c = (struct call *)se->data;
#line 100
    if ((unsigned long )se->func == (unsigned long )(& hello)) {
      {
#line 102
      l2tp_log(4, "%d: HELLO to %d\n", s, t->tid);
      }
    } else
#line 104
    if ((unsigned long )se->func == (unsigned long )(& magic_lac_dial)) {
      {
#line 106
      l2tp_log(4, "%d: Magic dial on %s\n", s, tlac->entname);
      }
    } else
#line 108
    if ((unsigned long )se->func == (unsigned long )(& send_zlb)) {
      {
#line 110
      l2tp_log(4, "%d: Send payload ZLB on call %d:%d\n", s, (c->container)->tid,
               c->cid);
      }
    } else
#line 113
    if ((unsigned long )se->func == (unsigned long )(& dethrottle)) {
      {
#line 115
      l2tp_log(4, "%d: Dethrottle call %d:%d\n", s, (c->container)->tid, c->cid);
      }
    } else
#line 118
    if ((unsigned long )se->func == (unsigned long )(& control_xmit)) {
      {
#line 120
      l2tp_log(4, "%d: Control xmit on %d\n", s, (((struct buffer *)se->data)->tunnel)->tid);
      }
    } else {
      {
#line 123
      l2tp_log(4, "%d: Unknown event\n", s);
      }
    }
#line 124
    se = se->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  l2tp_log(4, "Total Events scheduled: %d\n", s);
#line 127
  l2tp_log(4, "Number of tunnels open: %d\n", tunnels.count);
#line 128
  t = tunnels.head;
  }
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 129
    if (! t) {
#line 129
      goto while_break___0;
    }
    {
#line 131
    tmp = ntohs(t->peer.sin_port);
#line 131
    tmp___0 = inet_ntoa(t->peer.sin_addr);
    }
#line 131
    if (t->lac) {
#line 131
      tmp___2 = (char const   *)((t->lac)->entname);
    } else {
#line 131
      if (t->lns) {
#line 131
        tmp___1 = (char const   *)((t->lns)->entname);
      } else {
#line 131
        tmp___1 = "";
      }
#line 131
      tmp___2 = tmp___1;
    }
    {
#line 131
    l2tp_log(4, "Tunnel %s, ID = %d (local), %d (remote) to %s:%d, control_seq_num = %d, control_rec_seq_num = %d, cLr = %d, call count = %d ref=%u/refhim=%u",
             tmp___2, t->ourtid, t->tid, tmp___0, (int )tmp, (int )t->control_seq_num,
             (int )t->control_rec_seq_num, t->cLr, t->count, t->refme, t->refhim);
#line 139
    c = t->call_head;
    }
    {
#line 140
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 140
      if (! c) {
#line 140
        goto while_break___1;
      }
#line 142
      cnt ++;
#line 143
      if (c->lac) {
#line 143
        tmp___4 = (char const   *)((c->lac)->entname);
      } else {
#line 143
        if (c->lns) {
#line 143
          tmp___3 = (char const   *)((c->lns)->entname);
        } else {
#line 143
          tmp___3 = "";
        }
#line 143
        tmp___4 = tmp___3;
      }
      {
#line 143
      l2tp_log(4, "Call %s # %lu, ID = %d (local), %d (remote), serno = %u, data_seq_num = %d, data_rec_seq_num = %d, pLr = %d, tx = %u bytes (%u), rx= %u bytes (%u)",
               tmp___4, cnt, c->ourcid, c->cid, c->serno, (int )c->data_seq_num, (int )c->data_rec_seq_num,
               c->pLr, c->tx_bytes, c->tx_pkts, c->rx_bytes, c->rx_pkts);
#line 152
      c = c->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 154
    t = t->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 156
  l2tp_log(4, "==========Config File===========\n");
#line 157
  tlns = lnslist;
  }
  {
#line 158
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 158
    if (! tlns) {
#line 158
      goto while_break___2;
    }
#line 160
    if (tlns->entname[0]) {
#line 160
      tmp___5 = (char const   *)(tlns->entname);
    } else {
#line 160
      tmp___5 = "(unnamed)";
    }
    {
#line 160
    l2tp_log(4, "LNS entry %s\n", tmp___5);
#line 162
    tlns = tlns->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 164
  tlac = laclist;
  {
#line 165
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 165
    if (! tlac) {
#line 165
      goto while_break___3;
    }
#line 167
    if (tlac->entname[0]) {
#line 167
      tmp___6 = (char const   *)(tlac->entname);
    } else {
#line 167
      tmp___6 = "(unnamed)";
    }
    {
#line 167
    l2tp_log(4, "LAC entry %s, LNS is/are:", tmp___6);
#line 169
    h = tlac->lns;
    }
#line 170
    if (h) {
      {
#line 172
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 172
        if (! h) {
#line 172
          goto while_break___4;
        }
        {
#line 174
        l2tp_log(4, " %s", h->hostname);
#line 175
        h = h->next;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 179
      l2tp_log(4, " [none]");
      }
    }
#line 180
    tlac = tlac->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 182
  l2tp_log(4, "================================\n");
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void null_handler(int sig ) 
{ 


  {
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void status_handler(int sig ) 
{ 


  {
  {
#line 195
  show_status();
  }
#line 196
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void child_handler(int signal___0 ) 
{ 
  struct tunnel *t ;
  struct call *c ;
  pid_t pid ;
  int status___0 ;
  union __anonunion_73 __constr_expr_0 ;
  union __anonunion_74 __constr_expr_1 ;
  union __anonunion_75 __constr_expr_2 ;
  union __anonunion_76 __constr_expr_3 ;

  {
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    pid = waitpid(-1, & status___0, 1);
    }
#line 214
    if (pid < 1) {
#line 220
      return;
    }
#line 223
    t = tunnels.head;
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 224
      if (! t) {
#line 224
        goto while_break___0;
      }
#line 226
      c = t->call_head;
#line 227
      t = t->next;
      {
#line 228
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 228
        if (! c) {
#line 228
          goto while_break___1;
        }
#line 230
        if (c->pppd == pid) {
#line 232
          __constr_expr_3.__in = status___0;
#line 232
          if ((__constr_expr_3.__i & 127) == 0) {
            {
#line 234
            __constr_expr_0.__in = status___0;
#line 234
            l2tp_log(7, "%s : pppd exited for call %d with code %d\n", "child_handler",
                     c->cid, (__constr_expr_0.__i & 65280) >> 8);
            }
          } else {
#line 237
            __constr_expr_2.__in = status___0;
#line 237
            if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
              {
#line 239
              __constr_expr_1.__in = status___0;
#line 239
              l2tp_log(7, "%s : pppd terminated for call %d by signal %d\n", "child_handler",
                       c->cid, __constr_expr_1.__i & 127);
              }
            } else {
              {
#line 244
              l2tp_log(7, "%s : pppd exited for call %d for unknown reason\n", "child_handler",
                       c->cid);
              }
            }
          }
#line 247
          c->needclose = -1;
#line 253
          if (! kernel_support) {
            {
#line 255
            close(c->fd);
            }
          }
#line 256
          c->fd = -1;
#line 261
          t = (struct tunnel *)((void *)0);
#line 262
          goto while_break___1;
        }
#line 264
        c = c->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 270 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void death_handler(int signal___0 ) 
{ 
  struct tunnel *st ;
  struct tunnel *st2 ;
  int sec ;

  {
  {
#line 280
  l2tp_log(2, "%s: Fatal signal %d received\n", "death_handler", signal___0);
  }
#line 282
  if (kernel_support) {
#line 282
    goto _L;
  } else
#line 282
  if (signal___0 != 15) {
    _L: /* CIL Label */ 
#line 286
    st = tunnels.head;
    {
#line 287
    while (1) {
      while_continue: /* CIL Label */ ;
#line 287
      if (! st) {
#line 287
        goto while_break;
      }
      {
#line 289
      st2 = st->next;
#line 290
      strcpy((char */* __restrict  */)((st->self)->errormsg), (char const   */* __restrict  */)"Server closing");
#line 291
      sec = (st->self)->closing;
      }
#line 292
      if (st->lac) {
#line 293
        (st->lac)->redial = 0;
      }
      {
#line 294
      call_close(st->self);
      }
#line 295
      if (! sec) {
        {
#line 297
        (st->self)->closing = -1;
#line 298
        call_close(st->self);
        }
      }
#line 300
      st = st2;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 305
  unlink((char const   *)(gconfig.pidfile));
#line 306
  unlink((char const   *)(gconfig.controlfile));
#line 308
  exit(1);
  }
}
}
#line 311 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void sigterm_handler(int sig ) 
{ 


  {
#line 313
  sigterm_received = (sig_atomic_t volatile   )1;
#line 314
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void sigint_handler(int sig ) 
{ 


  {
#line 318
  sigint_received = (sig_atomic_t volatile   )1;
#line 319
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void sigchld_handler(int sig ) 
{ 


  {
#line 323
  sigchld_received = (sig_atomic_t volatile   )1;
#line 324
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void sigusr1_handler(int sig ) 
{ 


  {
#line 328
  sigusr1_received = (sig_atomic_t volatile   )1;
#line 329
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void sighup_handler(int sig ) 
{ 


  {
#line 333
  sighup_received = (sig_atomic_t volatile   )1;
#line 334
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void process_signal(void) 
{ 


  {
#line 338
  if (sigterm_received) {
    {
#line 338
    sigterm_received = (sig_atomic_t volatile   )0;
#line 338
    death_handler(15);
    }
  }
#line 339
  if (sigint_received) {
    {
#line 339
    sigint_received = (sig_atomic_t volatile   )0;
#line 339
    death_handler(2);
    }
  }
#line 340
  if (sigchld_received) {
    {
#line 340
    sigchld_received = (sig_atomic_t volatile   )0;
#line 340
    child_handler(17);
    }
  }
#line 341
  if (sigusr1_received) {
    {
#line 341
    sigusr1_received = (sig_atomic_t volatile   )0;
#line 341
    status_handler(10);
    }
  }
#line 342
  if (sighup_received) {
    {
#line 342
    sighup_received = (sig_atomic_t volatile   )0;
#line 342
    null_handler(1);
    }
  }
#line 343
  return;
}
}
#line 345 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
int start_pppd(struct call *c , struct ppp_opts *opts ) 
{ 
  char tty[512] ;
  char *stropt[80] ;
  struct ppp_opts *p ;
  struct sockaddr_pppol2tp sax ;
  int flags ;
  int pos___0 ;
  int fd2 ;
  int x ;
  struct termios ptyconf ;
  struct call *sc ;
  struct tunnel *st ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 355
  pos___0 = 1;
#line 356
  fd2 = -1;
#line 364
  p = opts;
#line 365
  stropt[0] = strdup("/usr/sbin/pppd");
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! p) {
#line 366
      goto while_break;
    }
    {
#line 368
    tmp = strlen((char const   *)(p->option));
#line 368
    tmp___0 = malloc(tmp + 1UL);
#line 368
    stropt[pos___0] = (char *)tmp___0;
#line 369
    tmp___1 = strlen((char const   *)(p->option));
#line 369
    strncpy((char */* __restrict  */)stropt[pos___0], (char const   */* __restrict  */)(p->option),
            tmp___1 + 1UL);
#line 370
    pos___0 ++;
#line 371
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  stropt[pos___0] = (char *)((void *)0);
#line 374
  if (c->pppd > 0) {
    {
#line 376
    l2tp_log(4, "%s: PPP already started on call!\n", "start_pppd");
    }
#line 377
    return (-22);
  }
#line 379
  if (c->fd > -1) {
    {
#line 381
    l2tp_log(4, "%s: file descriptor already assigned!\n", "start_pppd");
    }
#line 383
    return (-22);
  }
#line 387
  if (kernel_support) {
    {
#line 389
    fd2 = socket(24, 2, 1);
    }
#line 390
    if (fd2 < 0) {
      {
#line 391
      l2tp_log(4, "%s: Unable to allocate PPPoL2TP socket.\n", "start_pppd");
      }
#line 393
      return (-22);
    }
    {
#line 395
    flags = fcntl(fd2, 3);
    }
#line 396
    if (flags == -1) {
      {
#line 397
      l2tp_log(4, "%s: Unable to set PPPoL2TP socket nonblock.\n", "start_pppd");
      }
#line 399
      return (-22);
    } else {
      {
#line 396
      tmp___2 = fcntl(fd2, 4, flags | 2048);
      }
#line 396
      if (tmp___2 == -1) {
        {
#line 397
        l2tp_log(4, "%s: Unable to set PPPoL2TP socket nonblock.\n", "start_pppd");
        }
#line 399
        return (-22);
      }
    }
    {
#line 401
    memset((void *)(& sax), 0, sizeof(sax));
#line 402
    sax.sa_family = (__kernel_sa_family_t )24;
#line 403
    sax.sa_protocol = 1U;
#line 404
    sax.pppol2tp.fd = (c->container)->udp_fd;
#line 405
    sax.pppol2tp.addr.sin_addr.s_addr = (c->container)->peer.sin_addr.s_addr;
#line 406
    sax.pppol2tp.addr.sin_port = (c->container)->peer.sin_port;
#line 407
    sax.pppol2tp.addr.sin_family = (sa_family_t )2;
#line 408
    sax.pppol2tp.s_tunnel = (__u16 )(c->container)->ourtid;
#line 409
    sax.pppol2tp.s_session = (__u16 )c->ourcid;
#line 410
    sax.pppol2tp.d_tunnel = (__u16 )(c->container)->tid;
#line 411
    sax.pppol2tp.d_session = (__u16 )c->cid;
#line 412
    tmp___3 = connect(fd2, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sax)),
                      (socklen_t )sizeof(sax));
    }
#line 412
    if (tmp___3 < 0) {
      {
#line 413
      l2tp_log(4, "%s: Unable to connect PPPoL2TP socket.\n", "start_pppd");
#line 415
      close(fd2);
      }
#line 416
      return (-22);
    }
    {
#line 418
    tmp___4 = pos___0;
#line 418
    pos___0 ++;
#line 418
    stropt[tmp___4] = strdup("plugin");
#line 419
    tmp___5 = pos___0;
#line 419
    pos___0 ++;
#line 419
    stropt[tmp___5] = strdup("pppol2tp.so");
#line 420
    tmp___6 = pos___0;
#line 420
    pos___0 ++;
#line 420
    stropt[tmp___6] = strdup("pppol2tp");
#line 421
    tmp___7 = malloc((size_t )10);
#line 421
    stropt[pos___0] = (char *)tmp___7;
#line 422
    snprintf((char */* __restrict  */)stropt[pos___0], (size_t )10, (char const   */* __restrict  */)"%d",
             fd2);
#line 423
    pos___0 ++;
    }
#line 424
    if ((c->container)->lns) {
      {
#line 425
      tmp___8 = pos___0;
#line 425
      pos___0 ++;
#line 425
      stropt[tmp___8] = strdup("pppol2tp_lns_mode");
#line 426
      tmp___9 = pos___0;
#line 426
      pos___0 ++;
#line 426
      stropt[tmp___9] = strdup("pppol2tp_tunnel_id");
#line 427
      tmp___10 = malloc((size_t )10);
#line 427
      stropt[pos___0] = (char *)tmp___10;
#line 428
      snprintf((char */* __restrict  */)stropt[pos___0], (size_t )10, (char const   */* __restrict  */)"%d",
               (c->container)->ourtid);
#line 429
      pos___0 ++;
#line 430
      tmp___11 = pos___0;
#line 430
      pos___0 ++;
#line 430
      stropt[tmp___11] = strdup("pppol2tp_session_id");
#line 431
      tmp___12 = malloc((size_t )10);
#line 431
      stropt[pos___0] = (char *)tmp___12;
#line 432
      snprintf((char */* __restrict  */)stropt[pos___0], (size_t )10, (char const   */* __restrict  */)"%d",
               c->ourcid);
#line 433
      pos___0 ++;
      }
    }
#line 435
    stropt[pos___0] = (char *)((void *)0);
  } else {
    {
#line 440
    tmp___13 = getPtyMaster(tty, (int )sizeof(tty));
#line 440
    c->fd = tmp___13;
    }
#line 440
    if (tmp___13 < 0) {
      {
#line 442
      l2tp_log(4, "%s: unable to allocate pty, abandoning!\n", "start_pppd");
      }
#line 444
      return (-22);
    }
    {
#line 449
    tcgetattr(c->fd, & ptyconf);
#line 450
    *(c->oldptyconf) = ptyconf;
#line 451
    ptyconf.c_cflag &= 4294967285U;
#line 452
    ptyconf.c_lflag &= 4294967287U;
#line 453
    tcsetattr(c->fd, 0, (struct termios  const  *)(& ptyconf));
#line 454
    tmp___16 = fcntl(c->fd, 4, 2048);
    }
#line 454
    if (tmp___16 != 0) {
      {
#line 455
      tmp___14 = __errno_location();
#line 455
      tmp___15 = strerror(*tmp___14);
#line 455
      l2tp_log(4, "failed to set nonblock: %s\n", tmp___15);
      }
#line 456
      return (-22);
    }
    {
#line 459
    fd2 = open((char const   *)(tty), 2);
    }
#line 460
    if (fd2 < 0) {
      {
#line 461
      l2tp_log(4, "unable to open tty %s, cannot start pppd", tty);
      }
#line 462
      return (-22);
    }
    {
#line 464
    tmp___17 = pos___0;
#line 464
    pos___0 ++;
#line 464
    stropt[tmp___17] = strdup((char const   *)(tty));
#line 465
    stropt[pos___0] = (char *)((void *)0);
    }
  }
  {
#line 469
  l2tp_log(7, "%s: I\'m running: \n", "start_pppd");
#line 470
  x = 0;
  }
  {
#line 470
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 470
    if (! stropt[x]) {
#line 470
      goto while_break___0;
    }
    {
#line 472
    l2tp_log(7, "\"%s\" \n", stropt[x]);
#line 470
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 478
  c->pppd = fork();
  }
#line 481
  if (c->pppd < 0) {
    {
#line 484
    l2tp_log(4, "%s: unable to fork(), abandoning!\n", "start_pppd");
    }
#line 485
    return (-22);
  } else
#line 487
  if (! c->pppd) {
    {
#line 491
    close(0);
#line 492
    close(1);
    }
#line 495
    if (! kernel_support) {
      {
#line 500
      dup2(fd2, 0);
#line 501
      dup2(fd2, 1);
#line 502
      close(fd2);
      }
    }
#line 505
    st = tunnels.head;
    {
#line 506
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 506
      if (! st) {
#line 506
        goto while_break___1;
      }
#line 508
      sc = st->call_head;
      {
#line 509
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 509
        if (! sc) {
#line 509
          goto while_break___2;
        }
#line 512
        if (kernel_support) {
          {
#line 513
          close(st->udp_fd);
#line 514
          close(st->pppox_fd);
          }
        } else {
          {
#line 517
          close(sc->fd);
          }
        }
#line 518
        sc = sc->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 520
      st = st->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 524
    close(server_socket);
#line 527
    close(control_fd);
    }
#line 529
    if (c->dialing[0]) {
      {
#line 531
      setenv("CALLER_ID", (char const   *)(c->dialing), 1);
      }
    }
    {
#line 533
    execv("/usr/sbin/pppd", (char * const  *)(stropt));
#line 534
    l2tp_log(4, "%s: Exec of %s failed!\n", "start_pppd", "/usr/sbin/pppd");
#line 535
    _exit(1);
    }
  }
  {
#line 537
  close(fd2);
#line 538
  pos___0 = 0;
  }
  {
#line 539
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 539
    if (! stropt[pos___0]) {
#line 539
      goto while_break___3;
    }
    {
#line 541
    free((void *)stropt[pos___0]);
#line 542
    pos___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 544
  return (0);
}
}
#line 547 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void destroy_tunnel(struct tunnel *t ) 
{ 
  struct call *c ;
  struct call *me ;
  struct tunnel *p ;
  struct timeval tv ;

  {
#line 559
  if (! t) {
#line 560
    return;
  }
#line 569
  me = t->self;
#line 574
  c = t->call_head;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (! c) {
#line 575
      goto while_break;
    }
    {
#line 577
    destroy_call(c);
#line 578
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  if ((unsigned long )tunnels.head == (unsigned long )t) {
#line 586
    tunnels.head = t->next;
#line 587
    (tunnels.count) --;
  } else {
#line 591
    p = tunnels.head;
#line 592
    if (p) {
      {
#line 594
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 594
        if (p->next) {
#line 594
          if (! ((unsigned long )p->next != (unsigned long )t)) {
#line 594
            goto while_break___0;
          }
        } else {
#line 594
          goto while_break___0;
        }
#line 595
        p = p->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 596
      if (p->next) {
#line 598
        p->next = t->next;
#line 599
        (tunnels.count) --;
      } else {
        {
#line 603
        l2tp_log(4, "%s: unable to locate tunnel in tunnel list\n", "destroy_tunnel");
        }
      }
    } else {
      {
#line 610
      l2tp_log(4, "%s: tunnel list is empty!\n", "destroy_tunnel");
      }
    }
  }
#line 613
  if (t->lac) {
#line 615
    (t->lac)->t = (struct tunnel *)((void *)0);
#line 616
    if ((t->lac)->redial) {
#line 616
      if ((t->lac)->rtimeout > 0) {
#line 616
        if (! (t->lac)->rsched) {
#line 616
          if ((t->lac)->active) {
            {
#line 619
            l2tp_log(6, "Will redial in %d seconds\n", (t->lac)->rtimeout);
#line 621
            tv.tv_sec = (__time_t )(t->lac)->rtimeout;
#line 622
            tv.tv_usec = (__suseconds_t )0;
#line 623
            (t->lac)->rsched = schedule(tv, & magic_lac_dial, (void *)t->lac);
            }
          }
        }
      }
    }
  }
#line 629
  if (t->lns) {
#line 630
    (t->lns)->t = (struct tunnel *)((void *)0);
  }
#line 631
  if (t->chal_us.challenge) {
    {
#line 632
    free((void *)t->chal_us.challenge);
    }
  }
#line 633
  if (t->chal_them.challenge) {
    {
#line 634
    free((void *)t->chal_them.challenge);
    }
  }
#line 637
  if (t->chal_them.vector) {
    {
#line 638
    free((void *)t->chal_them.vector);
    }
  }
#line 639
  if (t->pppox_fd > -1) {
    {
#line 640
    close(t->pppox_fd);
    }
  }
#line 641
  if (t->udp_fd > -1) {
    {
#line 642
    close(t->udp_fd);
    }
  }
  {
#line 643
  free((void *)t);
#line 644
  free((void *)me);
  }
#line 645
  return;
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
struct tunnel *l2tp_call(char *host , int port , struct lac *lac , struct lns *lns ) 
{ 
  struct call *tmp ;
  struct hostent *hp ;
  struct in_addr addr ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;

  {
  {
#line 654
  tmp = (struct call *)((void *)0);
#line 657
  tmp___0 = htons((uint16_t )port);
#line 657
  port = (int )tmp___0;
#line 658
  hp = gethostbyname((char const   *)host);
  }
#line 659
  if (! hp) {
    {
#line 661
    l2tp_log(4, "Host name lookup failed for %s.\n", host);
    }
#line 663
    return ((struct tunnel *)((void *)0));
  }
  {
#line 665
  bcopy((void const   *)*(hp->h_addr_list + 0), (void *)(& addr.s_addr), (size_t )hp->h_length);
#line 673
  tmp = get_call(0, 0, addr, port, (IPsecSAref_t )0, (IPsecSAref_t )0);
  }
#line 674
  if (! tmp) {
    {
#line 676
    l2tp_log(4, "%s: Unable to create tunnel to %s.\n", "l2tp_call", host);
    }
#line 678
    return ((struct tunnel *)((void *)0));
  }
#line 680
  (tmp->container)->tid = 0;
#line 681
  (tmp->container)->lac = lac;
#line 682
  (tmp->container)->lns = lns;
#line 683
  tmp->lac = lac;
#line 684
  tmp->lns = lns;
#line 685
  if (lac) {
#line 686
    lac->t = tmp->container;
  }
#line 687
  if (lns) {
#line 688
    lns->t = tmp->container;
  }
  {
#line 692
  tmp___1 = ntohs((uint16_t )port);
#line 692
  l2tp_log(5, "Connecting to host %s, port %d\n", host, (int )tmp___1);
#line 694
  control_finish(tmp->container, tmp);
  }
#line 695
  return (tmp->container);
}
}
#line 698 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void magic_lac_tunnel(void *data ) 
{ 
  struct lac *lac ;

  {
#line 701
  lac = (struct lac *)data;
#line 702
  if (! lac) {
    {
#line 704
    l2tp_log(4, "%s: magic_lac_tunnel: called on NULL lac!\n", "magic_lac_tunnel");
    }
#line 706
    return;
  }
#line 708
  if (lac->lns) {
    {
#line 711
    l2tp_call((lac->lns)->hostname, (lac->lns)->port, lac, (struct lns *)((void *)0));
    }
#line 712
    return;
  } else
#line 714
  if (deflac) {
#line 714
    if (deflac->lns) {
      {
#line 716
      l2tp_call((deflac->lns)->hostname, (deflac->lns)->port, lac, (struct lns *)((void *)0));
      }
#line 717
      return;
    } else {
      {
#line 721
      l2tp_log(4, "%s: Unable to find hostname to dial for \'%s\'\n", "magic_lac_tunnel",
               lac->entname);
      }
#line 723
      return;
    }
  } else {
    {
#line 721
    l2tp_log(4, "%s: Unable to find hostname to dial for \'%s\'\n", "magic_lac_tunnel",
             lac->entname);
    }
#line 723
    return;
  }
}
}
#line 727 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
struct call *lac_call(int tid , struct lac *lac , struct lns *lns ) 
{ 
  struct tunnel *t ;
  struct call *tmp ;

  {
#line 729
  t = tunnels.head;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    if (! t) {
#line 731
      goto while_break;
    }
#line 733
    if (t->ourtid == tid) {
      {
#line 735
      tmp = new_call(t);
      }
#line 736
      if (! tmp) {
        {
#line 738
        l2tp_log(4, "%s: unable to create new call\n", "lac_call");
        }
#line 740
        return ((struct call *)((void *)0));
      }
#line 742
      tmp->next = t->call_head;
#line 743
      t->call_head = tmp;
#line 744
      (t->count) ++;
#line 745
      tmp->cid = 0;
#line 746
      tmp->lac = lac;
#line 747
      tmp->lns = lns;
#line 748
      if (lac) {
#line 749
        lac->c = tmp;
      }
      {
#line 750
      l2tp_log(5, "Calling on tunnel %d\n", tid);
#line 751
      strcpy((char */* __restrict  */)(tmp->dial_no), (char const   */* __restrict  */)dial_no_tmp);
#line 752
      control_finish(t, tmp);
      }
#line 753
      return (tmp);
    }
#line 755
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 757
  l2tp_log(7, "%s: No such tunnel %d to generate call.\n", "lac_call", tid);
  }
#line 759
  return ((struct call *)((void *)0));
}
}
#line 762 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void magic_lac_dial(void *data ) 
{ 
  struct lac *lac ;

  {
#line 765
  lac = (struct lac *)data;
#line 766
  if (! lac) {
    {
#line 768
    l2tp_log(4, "%s : called on NULL lac!\n", "magic_lac_dial");
    }
#line 769
    return;
  }
#line 771
  if (! lac->active) {
    {
#line 773
    l2tp_log(7, "%s: LAC %s not active", "magic_lac_dial", lac->entname);
    }
#line 774
    return;
  }
#line 776
  lac->rsched = (struct schedule_entry *)((void *)0);
#line 777
  (lac->rtries) ++;
#line 778
  if (lac->rmax) {
#line 778
    if (lac->rtries > lac->rmax) {
      {
#line 780
      l2tp_log(6, "%s: maximum retries exceeded.\n", "magic_lac_dial");
      }
#line 781
      return;
    }
  }
#line 783
  if (! lac->t) {
    {
#line 788
    magic_lac_tunnel((void *)lac);
    }
#line 789
    return;
  }
  {
#line 791
  lac_call((lac->t)->ourtid, lac, (struct lns *)((void *)0));
  }
#line 792
  return;
}
}
#line 794 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void lac_hangup(int cid ) 
{ 
  struct tunnel *t ;
  struct call *tmp ;

  {
#line 796
  t = tunnels.head;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! t) {
#line 798
      goto while_break;
    }
#line 800
    tmp = t->call_head;
    {
#line 801
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 801
      if (! tmp) {
#line 801
        goto while_break___0;
      }
#line 803
      if (tmp->ourcid == cid) {
        {
#line 805
        l2tp_log(6, "%s :Hanging up call %d, Local: %d, Remote: %d\n", "lac_hangup",
                 tmp->serno, tmp->ourcid, tmp->cid);
#line 808
        strcpy((char */* __restrict  */)(tmp->errormsg), (char const   */* __restrict  */)"Goodbye!");
#line 810
        kill(tmp->pppd, 15);
        }
#line 811
        return;
      }
#line 813
      tmp = tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 815
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 817
  l2tp_log(7, "%s : No such call %d to hang up.\n", "lac_hangup", cid);
  }
#line 818
  return;
}
}
#line 821 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void lac_disconnect(int tid ) 
{ 
  struct tunnel *t ;
  char *tmp ;

  {
#line 823
  t = tunnels.head;
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! t) {
#line 824
      goto while_break;
    }
#line 826
    if (t->ourtid == tid) {
      {
#line 828
      tmp = inet_ntoa(t->peer.sin_addr);
#line 828
      l2tp_log(6, "Disconnecting from %s, Local: %d, Remote: %d\n", tmp, t->ourtid,
               t->tid);
#line 831
      (t->self)->needclose = -1;
#line 832
      strcpy((char */* __restrict  */)((t->self)->errormsg), (char const   */* __restrict  */)"Goodbye!");
#line 833
      call_close(t->self);
      }
#line 834
      return;
    }
#line 836
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 838
  l2tp_log(7, "No such tunnel %d to hang up.\n", tid);
  }
#line 839
  return;
}
}
#line 842 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
struct tunnel *new_tunnel(void) 
{ 
  struct tunnel *tmp ;
  void *tmp___0 ;
  unsigned char entropy_buf[2] ;
  unsigned short *temp ;
  int tmp___1 ;
  int tmp___2 ;
  struct call *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 844
  tmp___0 = calloc((size_t )1, sizeof(struct tunnel ));
#line 844
  tmp = (struct tunnel *)tmp___0;
#line 845
  entropy_buf[0] = (unsigned char )'\000';
#line 845
  entropy_buf[1] = (unsigned char )'\000';
  }
#line 846
  if (! tmp) {
#line 847
    return ((struct tunnel *)((void *)0));
  }
  {
#line 848
  tmp->debug = -1;
#line 849
  tmp->tid = -1;
#line 854
  get_entropy(entropy_buf, 2);
#line 857
  temp = (unsigned short *)(entropy_buf);
#line 858
  tmp->ourtid = (int )*temp & 65535;
#line 867
  tmp->peer.sin_family = (sa_family_t )2;
#line 868
  bzero((void *)(& tmp->peer.sin_addr), sizeof(tmp->peer.sin_addr));
#line 870
  tmp->sanity = -1;
#line 872
  tmp->qtid = -1;
#line 873
  tmp->ourfc = 3;
#line 874
  tmp___1 = rand();
#line 874
  tmp___2 = rand();
#line 874
  tmp->ourtb = ((_u64 )tmp___1 << 32) | (_u64 )tmp___2;
#line 875
  tmp->fc = -1;
#line 876
  tmp->bc = -1;
#line 877
  tmp___3 = new_call(tmp);
#line 877
  tmp->self = tmp___3;
  }
#line 877
  if (! tmp___3) {
    {
#line 879
    free((void *)tmp);
    }
#line 880
    return ((struct tunnel *)((void *)0));
  }
  {
#line 882
  tmp->ourrws = 4;
#line 883
  (tmp->self)->ourfbit = 2048;
#line 884
  tmp->rxspeed = 10000000;
#line 885
  tmp->txspeed = 10000000;
#line 886
  memset((void *)(tmp->chal_us.reply), 0, (size_t )16);
#line 887
  memset((void *)(tmp->chal_them.reply), 0, (size_t )16);
#line 888
  tmp___4 = malloc((size_t )16);
#line 888
  tmp->chal_them.vector = (unsigned char *)tmp___4;
  }
#line 889
  return (tmp);
}
}
#line 892 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void write_res(FILE *res_file , char const   *fmt  , ...) 
{ 
  int tmp ;
  int tmp___0 ;
  va_list args___0 ;

  {
#line 894
  if (! res_file) {
#line 895
    return;
  } else {
    {
#line 894
    tmp = ferror(res_file);
    }
#line 894
    if (tmp) {
#line 895
      return;
    } else {
      {
#line 894
      tmp___0 = feof(res_file);
      }
#line 894
      if (tmp___0) {
#line 895
        return;
      }
    }
  }
  {
#line 897
  __builtin_va_start(args___0, fmt);
#line 898
  vfprintf((FILE */* __restrict  */)res_file, (char const   */* __restrict  */)fmt,
           args___0);
#line 899
  __builtin_va_end(args___0);
  }
#line 900
  return;
}
}
#line 902 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
int parse_one_line_lac(char *bufp , struct lac *tc ) 
{ 
  char *s ;
  char *d ;
  char *t ;
  int linenum ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 906
  linenum = 0;
#line 908
  s = strtok((char */* __restrict  */)bufp, (char const   */* __restrict  */)";");
  }
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 910
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 910
      goto while_break;
    }
#line 912
    linenum ++;
    {
#line 914
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 914
      if ((int )*s < 33) {
#line 914
        if (! *s) {
#line 914
          goto while_break___0;
        }
      } else {
#line 914
        goto while_break___0;
      }
#line 915
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 916
    tmp = strlen((char const   *)s);
#line 916
    t = s + tmp;
    }
    {
#line 917
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 917
      if ((unsigned long )t >= (unsigned long )s) {
#line 917
        if (! ((int )*t < 33)) {
#line 917
          goto while_break___1;
        }
      } else {
#line 917
        goto while_break___1;
      }
#line 918
      tmp___0 = t;
#line 918
      t --;
#line 918
      *tmp___0 = (char)0;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 919
    tmp___1 = strlen((char const   *)s);
    }
#line 919
    if (! tmp___1) {
#line 920
      goto while_continue;
    }
    {
#line 921
    t = strchr((char const   *)s, '=');
    }
#line 921
    if (! t) {
      {
#line 923
      l2tp_log(4, "%s: token %d: no \'=\' in data\n", "parse_one_line_lac", linenum);
      }
#line 925
      return (-1);
    }
#line 927
    d = t;
#line 928
    d --;
#line 929
    t ++;
    {
#line 930
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 930
      if ((unsigned long )d >= (unsigned long )s) {
#line 930
        if (! ((int )*d < 33)) {
#line 930
          goto while_break___2;
        }
      } else {
#line 930
        goto while_break___2;
      }
#line 931
      d --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 932
    d ++;
#line 933
    *d = (char)0;
    {
#line 934
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 934
      if (*t) {
#line 934
        if (! ((int )*t < 33)) {
#line 934
          goto while_break___3;
        }
      } else {
#line 934
        goto while_break___3;
      }
#line 935
      t ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 942
    tmp___2 = parse_one_option(s, t, 3, (void *)tc);
    }
    {
#line 944
    if (tmp___2 == -1) {
#line 944
      goto case_neg_1;
    }
#line 948
    if (tmp___2 == -2) {
#line 948
      goto case_neg_2;
    }
#line 942
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 945
    l2tp_log(4, "%s: error token %d\n", "parse_one_line_lac", linenum);
    }
#line 947
    return (-1);
    case_neg_2: /* CIL Label */ 
    {
#line 949
    l2tp_log(2, "%s: token %d: Unknown field \'%s\'\n", "parse_one_line_lac", linenum,
             s);
    }
#line 951
    return (-1);
    switch_break: /* CIL Label */ ;
    }
    {
#line 954
    s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)";");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 956
  return (0);
}
}
#line 959 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void do_control(void) 
{ 
  char buf[1024] ;
  char *bufp ;
  char *host ;
  char *tunstr ;
  char *callstr ;
  char *authname ;
  char *password ;
  char delims[2] ;
  char *sub_str ;
  char *tmp_ptr ;
  struct lac *lac ;
  struct lac *prev_lac ;
  int call ;
  int tunl ;
  int cnt ;
  int done ;
  char *res_filename ;
  FILE *resf ;
  ssize_t tmp ;
  int *tmp___0 ;
  int fnlength ;
  size_t tmp___1 ;
  char *tmp___2 ;
  struct tunnel *tmp___3 ;
  int tmp___4 ;
  struct call *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  struct call *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int create_new_lac ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
  {
#line 967
  authname = (char *)((void *)0);
#line 968
  password = (char *)((void *)0);
#line 969
  delims[0] = (char )' ';
#line 969
  delims[1] = (char )'\000';
#line 976
  cnt = -1;
#line 977
  done = 0;
#line 979
  bzero((void *)(buf), sizeof(buf));
#line 980
  buf[0] = (char )'\000';
  }
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    if (! (! done)) {
#line 985
      goto while_break;
    }
    {
#line 987
    tmp = read(control_fd, (void *)(buf), sizeof(buf));
#line 987
    cnt = (int )tmp;
    }
#line 988
    if (cnt <= 0) {
#line 990
      if (cnt < 0) {
        {
#line 990
        tmp___0 = __errno_location();
        }
#line 990
        if (*tmp___0 != 4) {
          {
#line 991
          perror("controlfd");
          }
        }
      }
#line 993
      done = 1;
#line 994
      goto while_break;
    }
#line 997
    if ((int )buf[cnt - 1] == 10) {
#line 998
      cnt --;
#line 998
      buf[cnt] = (char)0;
    }
#line 1003
    bufp = buf;
#line 1005
    if ((int )*(bufp + 0) == 64) {
      {
#line 1008
      res_filename = bufp + 1;
#line 1009
      tmp___1 = strcspn((char const   *)res_filename, " ");
#line 1009
      fnlength = (int )tmp___1;
      }
#line 1010
      if (fnlength == 0) {
        {
#line 1011
        l2tp_log(7, "%s: Can\'t parse result filename or command\n", "do_control");
        }
#line 1015
        goto while_continue;
      } else
#line 1010
      if ((int )*(res_filename + fnlength) == 0) {
        {
#line 1011
        l2tp_log(7, "%s: Can\'t parse result filename or command\n", "do_control");
        }
#line 1015
        goto while_continue;
      }
      {
#line 1017
      *(res_filename + fnlength) = (char )'\000';
#line 1018
      bufp = res_filename + (fnlength + 1);
#line 1024
      resf = fopen((char const   */* __restrict  */)res_filename, (char const   */* __restrict  */)"w");
      }
#line 1025
      if (! resf) {
        {
#line 1026
        l2tp_log(7, "%s: Can\'t open result file %s\n", "do_control", res_filename);
        }
#line 1028
        goto while_continue;
      }
    } else {
#line 1031
      resf = (FILE *)((void *)0);
    }
    {
#line 1035
    if ((int )*(bufp + 0) == 116) {
#line 1035
      goto case_116;
    }
#line 1046
    if ((int )*(bufp + 0) == 99) {
#line 1046
      goto case_99;
    }
#line 1099
    if ((int )*(bufp + 0) == 111) {
#line 1099
      goto case_111;
    }
#line 1147
    if ((int )*(bufp + 0) == 104) {
#line 1147
      goto case_104;
    }
#line 1158
    if ((int )*(bufp + 0) == 100) {
#line 1158
      goto case_100;
    }
#line 1197
    if ((int )*(bufp + 0) == 115) {
#line 1197
      goto case_115;
    }
#line 1200
    if ((int )*(bufp + 0) == 97) {
#line 1200
      goto case_97;
    }
#line 1262
    if ((int )*(bufp + 0) == 114) {
#line 1262
      goto case_114;
    }
#line 1295
    goto switch_default;
    case_116: /* CIL Label */ 
    {
#line 1036
    tmp___2 = strchr((char const   *)bufp, ' ');
#line 1036
    host = tmp___2 + 1;
#line 1041
    tmp___3 = l2tp_call(host, 1701, (struct lac *)((void *)0), (struct lns *)((void *)0));
    }
#line 1041
    if (tmp___3) {
      {
#line 1042
      write_res(resf, "%02i OK\n", 0);
      }
    } else {
      {
#line 1044
      write_res(resf, "%02i Error\n", 1);
      }
    }
#line 1045
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 1047
    switch_io = 1;
#line 1049
    tunstr = strtok((char */* __restrict  */)(bufp + 1), (char const   */* __restrict  */)(delims));
#line 1052
    authname = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(delims));
#line 1053
    password = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(delims));
#line 1055
    lac = laclist;
    }
    {
#line 1056
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1056
      if (lac) {
        {
#line 1056
        tmp___4 = strcasecmp((char const   *)(lac->entname), (char const   *)tunstr);
        }
#line 1056
        if (! (tmp___4 != 0)) {
#line 1056
          goto while_break___0;
        }
      } else {
#line 1056
        goto while_break___0;
      }
#line 1058
      lac = lac->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1061
    if (lac) {
#line 1062
      lac->active = -1;
#line 1063
      lac->rtries = 0;
#line 1064
      if ((unsigned long )authname != (unsigned long )((void *)0)) {
        {
#line 1065
        strncpy((char */* __restrict  */)(lac->authname), (char const   */* __restrict  */)authname,
                (size_t )80);
        }
      }
#line 1066
      if ((unsigned long )password != (unsigned long )((void *)0)) {
        {
#line 1067
        strncpy((char */* __restrict  */)(lac->password), (char const   */* __restrict  */)password,
                (size_t )80);
        }
      }
#line 1068
      if (! lac->c) {
        {
#line 1070
        magic_lac_dial((void *)lac);
#line 1071
        write_res(resf, "%02i OK\n", 0);
        }
      } else {
        {
#line 1073
        l2tp_log(7, "Session \'%s\' already active!\n", lac->entname);
#line 1075
        write_res(resf, "%02i Session \'%s\' already active!\n", 1, lac->entname);
        }
      }
#line 1078
      goto switch_break;
    }
    {
#line 1082
    tunl = atoi((char const   *)tunstr);
    }
#line 1083
    if (! tunl) {
      {
#line 1085
      l2tp_log(7, "No such tunnel \'%s\'\n", tunstr);
#line 1086
      write_res(resf, "%02i No such tunnel \'%s\'\n", 1, tunstr);
      }
#line 1087
      goto switch_break;
    }
    {
#line 1093
    tmp___5 = lac_call(tunl, (struct lac *)((void *)0), (struct lns *)((void *)0));
    }
#line 1093
    if (tmp___5) {
      {
#line 1094
      write_res(resf, "%02i OK\n", 0);
      }
    } else {
      {
#line 1096
      write_res(resf, "%02i Error\n", 1);
      }
    }
#line 1097
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 1100
    switch_io = 0;
#line 1102
    tmp___6 = strchr((char const   *)bufp, ' ');
#line 1102
    sub_str = tmp___6 + 1;
#line 1103
    tunstr = strtok((char */* __restrict  */)sub_str, (char const   */* __restrict  */)" ");
#line 1104
    tmp_ptr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 1105
    strcpy((char */* __restrict  */)dial_no_tmp, (char const   */* __restrict  */)tmp_ptr);
#line 1107
    lac = laclist;
    }
    {
#line 1108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1108
      if (lac) {
        {
#line 1108
        tmp___7 = strcasecmp((char const   *)(lac->entname), (char const   *)tunstr);
        }
#line 1108
        if (! (tmp___7 != 0)) {
#line 1108
          goto while_break___1;
        }
      } else {
#line 1108
        goto while_break___1;
      }
#line 1110
      lac = lac->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1113
    if (lac) {
#line 1114
      lac->active = -1;
#line 1115
      lac->rtries = 0;
#line 1116
      if (! lac->c) {
        {
#line 1118
        magic_lac_dial((void *)lac);
#line 1119
        write_res(resf, "%02i OK\n", 0);
        }
      } else {
        {
#line 1121
        l2tp_log(7, "Session \'%s\' already active!\n", lac->entname);
#line 1123
        write_res(resf, "%02i Session \'%s\' already active!\n", 1, lac->entname);
        }
      }
#line 1126
      goto switch_break;
    }
    {
#line 1130
    tunl = atoi((char const   *)tunstr);
    }
#line 1131
    if (! tunl) {
      {
#line 1133
      l2tp_log(7, "No such tunnel \'%s\'\n", tunstr);
#line 1134
      write_res(resf, "%02i No such tunnel \'%s\'\n", 1, tunstr);
      }
#line 1135
      goto switch_break;
    }
    {
#line 1141
    tmp___8 = lac_call(tunl, (struct lac *)((void *)0), (struct lns *)((void *)0));
    }
#line 1141
    if (tmp___8) {
      {
#line 1142
      write_res(resf, "%02i OK\n", 0);
      }
    } else {
      {
#line 1144
      write_res(resf, "%02i Error\n", 1);
      }
    }
#line 1145
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1148
    tmp___9 = strchr((char const   *)bufp, ' ');
#line 1148
    callstr = tmp___9 + 1;
#line 1149
    call = atoi((char const   *)callstr);
#line 1154
    lac_hangup(call);
#line 1155
    write_res(resf, "%02i OK\n", 0);
    }
#line 1156
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 1159
    tmp___10 = strchr((char const   *)bufp, ' ');
#line 1159
    tunstr = tmp___10 + 1;
#line 1160
    lac = laclist;
    }
    {
#line 1161
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1161
      if (! lac) {
#line 1161
        goto while_break___2;
      }
      {
#line 1163
      tmp___11 = strcasecmp((char const   *)(lac->entname), (char const   *)tunstr);
      }
#line 1163
      if (! tmp___11) {
#line 1165
        lac->active = 0;
#line 1166
        lac->rtries = 0;
#line 1167
        if (lac->t) {
          {
#line 1169
          lac_disconnect((lac->t)->ourtid);
#line 1170
          write_res(resf, "%02i OK\n", 0);
          }
        } else {
          {
#line 1172
          l2tp_log(7, "Session \'%s\' not up\n", lac->entname);
#line 1174
          write_res(resf, "%02i Session \'%s\' not up\n", 1, lac->entname);
          }
        }
#line 1177
        goto while_break___2;
      }
#line 1179
      lac = lac->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1181
    if (lac) {
#line 1182
      goto switch_break;
    }
    {
#line 1183
    tunl = atoi((char const   *)tunstr);
    }
#line 1184
    if (! tunl) {
      {
#line 1186
      l2tp_log(7, "No such tunnel \'%s\'\n", tunstr);
#line 1187
      write_res(resf, "%02i No such tunnel \'%s\'\n", 1, tunstr);
      }
#line 1188
      goto switch_break;
    }
    {
#line 1194
    lac_disconnect(tunl);
#line 1195
    write_res(resf, "%02i OK\n", 0);
    }
#line 1196
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1198
    show_status();
    }
#line 1199
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 1203
    create_new_lac = 0;
#line 1204
    tunstr = strtok((char */* __restrict  */)(bufp + 1), (char const   */* __restrict  */)(delims));
    }
#line 1205
    if (! tunstr) {
      {
#line 1207
      write_res(resf, "%02i Configuration parse error: lac-name expected\n", 1);
#line 1209
      l2tp_log(2, "%s: lac-name expected\n", "do_control");
      }
#line 1210
      goto switch_break;
    } else {
      {
#line 1205
      tmp___12 = strlen((char const   *)tunstr);
      }
#line 1205
      if (! tmp___12) {
        {
#line 1207
        write_res(resf, "%02i Configuration parse error: lac-name expected\n", 1);
#line 1209
        l2tp_log(2, "%s: lac-name expected\n", "do_control");
        }
#line 1210
        goto switch_break;
      }
    }
    {
#line 1213
    tmp___13 = strlen((char const   *)tunstr);
#line 1213
    bufp = (tunstr + tmp___13) + 1;
#line 1215
    lac = laclist;
    }
    {
#line 1216
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1216
      if (! lac) {
#line 1216
        goto while_break___3;
      }
      {
#line 1218
      tmp___14 = strcasecmp((char const   *)tunstr, (char const   *)(lac->entname));
      }
#line 1218
      if (! tmp___14) {
#line 1219
        goto while_break___3;
      }
#line 1220
      lac = lac->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1222
    if (! lac) {
      {
#line 1225
      lac = new_lac();
      }
#line 1226
      if (! lac) {
        {
#line 1228
        write_res(resf, "%02i Could\'t create new lac: no memory\n", 2);
#line 1230
        l2tp_log(2, "%s: Couldn\'t create new lac\n", "do_control");
        }
#line 1232
        goto switch_break;
      }
#line 1234
      create_new_lac = 1;
    }
    {
#line 1236
    strncpy((char */* __restrict  */)(lac->entname), (char const   */* __restrict  */)tunstr,
            sizeof(lac->entname));
#line 1238
    tmp___15 = parse_one_line_lac(bufp, lac);
    }
#line 1238
    if (tmp___15) {
      {
#line 1240
      write_res(resf, "%02i Configuration parse error\n", 3);
      }
#line 1241
      goto switch_break;
    }
#line 1243
    if (create_new_lac) {
#line 1245
      lac->next = laclist;
#line 1246
      laclist = lac;
    }
#line 1248
    if (lac->autodial) {
      {
#line 1254
      lac->active = -1;
#line 1255
      switch_io = 1;
#line 1256
      magic_lac_dial((void *)lac);
      }
    }
    {
#line 1259
    write_res(resf, "%02i OK\n", 0);
    }
#line 1261
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1264
    tmp___16 = strchr((char const   *)bufp, ' ');
#line 1264
    tunstr = tmp___16 + 1;
#line 1265
    lac = laclist;
#line 1266
    prev_lac = (struct lac *)((void *)0);
    }
    {
#line 1267
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1267
      if (lac) {
        {
#line 1267
        tmp___17 = strcasecmp((char const   *)(lac->entname), (char const   *)tunstr);
        }
#line 1267
        if (! (tmp___17 != 0)) {
#line 1267
          goto while_break___4;
        }
      } else {
#line 1267
        goto while_break___4;
      }
#line 1269
      prev_lac = lac;
#line 1270
      lac = lac->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1272
    if (! lac) {
      {
#line 1274
      l2tp_log(7, "No such tunnel \'%s\'\n", tunstr);
#line 1276
      write_res(resf, "%02i No such tunnel \'%s\'\n", 1, tunstr);
      }
#line 1277
      goto switch_break;
    }
#line 1280
    lac->active = 0;
#line 1281
    lac->rtries = 0;
#line 1282
    if (lac->t) {
      {
#line 1284
      lac_disconnect((lac->t)->ourtid);
      }
    }
#line 1287
    if ((unsigned long )prev_lac == (unsigned long )((void *)0)) {
#line 1288
      laclist = lac->next;
    } else {
#line 1290
      prev_lac->next = lac->next;
    }
    {
#line 1291
    free((void *)lac);
#line 1292
    lac = (struct lac *)((void *)0);
#line 1293
    write_res(resf, "%02i OK\n", 0);
    }
#line 1294
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1296
    l2tp_log(7, "Unknown command %c\n", (int )*(bufp + 0));
#line 1297
    write_res(resf, "%02i Unknown command %c\n", 1, (int )*(bufp + 0));
    }
    switch_break: /* CIL Label */ ;
    }
#line 1300
    if (resf) {
      {
#line 1302
      fclose(resf);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1307
  close(control_fd);
#line 1308
  open_controlfd();
  }
#line 1309
  return;
}
}
#line 1312 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void usage(void) 
{ 


  {
  {
#line 1313
  printf((char const   */* __restrict  */)"\nxl2tpd version:  %s\n", "xl2tpd-1.3.6");
#line 1314
  printf((char const   */* __restrict  */)"Usage: xl2tpd [-c <config file>] [-s <secret file>] [-p <pid file>]\n              [-C <control file>] [-D]\n              [-v, --version]\n");
#line 1317
  printf((char const   */* __restrict  */)"\n");
#line 1318
  exit(1);
  }
}
}
#line 1321 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void init_args(int argc , char **argv ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1323
  i = 0;
#line 1325
  gconfig.daemon = 1;
#line 1326
  memset((void *)(gconfig.altauthfile), 0, (size_t )80);
#line 1327
  memset((void *)(gconfig.altconfigfile), 0, (size_t )80);
#line 1328
  memset((void *)(gconfig.authfile), 0, (size_t )80);
#line 1329
  memset((void *)(gconfig.configfile), 0, (size_t )80);
#line 1330
  memset((void *)(gconfig.pidfile), 0, (size_t )80);
#line 1331
  memset((void *)(gconfig.controlfile), 0, (size_t )80);
#line 1332
  strncpy((char */* __restrict  */)(gconfig.altauthfile), (char const   */* __restrict  */)"/etc/l2tpd/l2tp-secrets",
          sizeof(gconfig.altauthfile) - 1UL);
#line 1334
  strncpy((char */* __restrict  */)(gconfig.altconfigfile), (char const   */* __restrict  */)"/etc/l2tp/l2tpd.conf",
          sizeof(gconfig.altconfigfile) - 1UL);
#line 1336
  strncpy((char */* __restrict  */)(gconfig.authfile), (char const   */* __restrict  */)"/etc/xl2tpd/l2tp-secrets",
          sizeof(gconfig.authfile) - 1UL);
#line 1338
  strncpy((char */* __restrict  */)(gconfig.configfile), (char const   */* __restrict  */)"/etc/xl2tpd/xl2tpd.conf",
          sizeof(gconfig.configfile) - 1UL);
#line 1340
  strncpy((char */* __restrict  */)(gconfig.pidfile), (char const   */* __restrict  */)"/var/run/xl2tpd.pid",
          sizeof(gconfig.pidfile) - 1UL);
#line 1342
  strncpy((char */* __restrict  */)(gconfig.controlfile), (char const   */* __restrict  */)"/var/run/xl2tpd/l2tp-control",
          sizeof(gconfig.controlfile) - 1UL);
#line 1344
  gconfig.ipsecsaref = 0;
#line 1346
  i = 1;
  }
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! (i < argc)) {
#line 1346
      goto while_break;
    }
    {
#line 1347
    tmp = strncmp((char const   *)*(argv + i), "--version", (size_t )9);
    }
#line 1347
    if (tmp) {
      {
#line 1347
      tmp___0 = strncmp((char const   *)*(argv + i), "-v", (size_t )2);
      }
#line 1347
      if (! tmp___0) {
        {
#line 1349
        printf((char const   */* __restrict  */)"\nxl2tpd version:  %s\n", "xl2tpd-1.3.6");
#line 1350
        exit(1);
        }
      }
    } else {
      {
#line 1349
      printf((char const   */* __restrict  */)"\nxl2tpd version:  %s\n", "xl2tpd-1.3.6");
#line 1350
      exit(1);
      }
    }
    {
#line 1353
    tmp___5 = strncmp((char const   *)*(argv + i), "-c", (size_t )2);
    }
#line 1353
    if (tmp___5) {
      {
#line 1360
      tmp___4 = strncmp((char const   *)*(argv + i), "-D", (size_t )2);
      }
#line 1360
      if (tmp___4) {
        {
#line 1363
        tmp___3 = strncmp((char const   *)*(argv + i), "-s", (size_t )2);
        }
#line 1363
        if (tmp___3) {
          {
#line 1370
          tmp___2 = strncmp((char const   *)*(argv + i), "-p", (size_t )2);
          }
#line 1370
          if (tmp___2) {
            {
#line 1377
            tmp___1 = strncmp((char const   *)*(argv + i), "-C", (size_t )2);
            }
#line 1377
            if (tmp___1) {
              {
#line 1385
              usage();
              }
            } else {
#line 1378
              i ++;
#line 1378
              if (i == argc) {
                {
#line 1379
                usage();
                }
              } else {
                {
#line 1381
                strncpy((char */* __restrict  */)(gconfig.controlfile), (char const   */* __restrict  */)*(argv + i),
                        sizeof(gconfig.controlfile) - 1UL);
                }
              }
            }
          } else {
#line 1371
            i ++;
#line 1371
            if (i == argc) {
              {
#line 1372
              usage();
              }
            } else {
              {
#line 1374
              strncpy((char */* __restrict  */)(gconfig.pidfile), (char const   */* __restrict  */)*(argv + i),
                      sizeof(gconfig.pidfile) - 1UL);
              }
            }
          }
        } else {
#line 1364
          i ++;
#line 1364
          if (i == argc) {
            {
#line 1365
            usage();
            }
          } else {
            {
#line 1367
            strncpy((char */* __restrict  */)(gconfig.authfile), (char const   */* __restrict  */)*(argv + i),
                    sizeof(gconfig.authfile) - 1UL);
            }
          }
        }
      } else {
#line 1361
        gconfig.daemon = 0;
      }
    } else {
#line 1354
      i ++;
#line 1354
      if (i == argc) {
        {
#line 1355
        usage();
        }
      } else {
        {
#line 1357
        strncpy((char */* __restrict  */)(gconfig.configfile), (char const   */* __restrict  */)*(argv + i),
                sizeof(gconfig.configfile) - 1UL);
        }
      }
    }
#line 1346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1388
  return;
}
}
#line 1391 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void daemonize(void) 
{ 
  int pid ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1392
  pid = 0;
#line 1396
  pid = fork();
  }
#line 1396
  if (pid < 0) {
    {
#line 1397
    l2tp_log(6, "%s: Unable to fork ()\n", "daemonize");
#line 1398
    close(server_socket);
#line 1399
    exit(1);
    }
  } else
#line 1401
  if (pid) {
    {
#line 1402
    exit(0);
    }
  }
  {
#line 1404
  close(0);
#line 1405
  i = open("/dev/null", 2);
  }
#line 1406
  if (i != 0) {
    {
#line 1407
    l2tp_log(6, "Redirect of stdin to /dev/null failed\n");
    }
  } else {
    {
#line 1409
    tmp = dup2(0, 1);
    }
#line 1409
    if (tmp == -1) {
      {
#line 1410
      l2tp_log(6, "Redirect of stdout to /dev/null failed\n");
      }
    }
    {
#line 1411
    tmp___0 = dup2(0, 2);
    }
#line 1411
    if (tmp___0 == -1) {
      {
#line 1412
      l2tp_log(6, "Redirect of stderr to /dev/null failed\n");
      }
    }
  }
#line 1415
  return;
}
}
#line 1417 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
static void consider_pidfile(void) 
{ 
  int pid ;
  int i ;
  int l ;
  char buf[80] ;
  ssize_t tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 1418
  pid = 0;
#line 1423
  i = open((char const   *)(gconfig.pidfile), 0);
  }
#line 1424
  if (! (i < 0)) {
    {
#line 1430
    tmp = read(i, (void *)(buf), sizeof(buf) - 1UL);
#line 1430
    l = (int )tmp;
#line 1431
    close(i);
    }
#line 1432
    if (l >= 0) {
      {
#line 1434
      buf[l] = (char )'\000';
#line 1435
      pid = atoi((char const   *)(buf));
      }
    }
#line 1440
    if (pid) {
      {
#line 1440
      tmp___0 = getpid();
      }
#line 1440
      if (pid != tmp___0) {
        {
#line 1440
        tmp___1 = kill(pid, 0);
        }
#line 1440
        if (tmp___1 == 0) {
          {
#line 1442
          l2tp_log(6, "%s: There\'s already a xl2tpd server running.\n", "consider_pidfile");
#line 1445
          close(server_socket);
#line 1446
          exit(1);
          }
        }
      }
    }
  }
  {
#line 1450
  pid = setsid();
#line 1452
  unlink((char const   *)(gconfig.pidfile));
#line 1453
  i = open((char const   *)(gconfig.pidfile), 65, 416);
  }
#line 1453
  if (i >= 0) {
    {
#line 1454
    tmp___2 = getpid();
#line 1454
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d\n",
             tmp___2);
#line 1455
    tmp___3 = strlen((char const   *)(buf));
#line 1455
    tmp___4 = write(i, (void const   *)(buf), tmp___3);
    }
#line 1455
    if (-1L == tmp___4) {
      {
#line 1457
      l2tp_log(2, "%s: Unable to write to %s.\n", "consider_pidfile", gconfig.pidfile);
#line 1459
      close(i);
#line 1460
      exit(1);
      }
    }
    {
#line 1462
    close(i);
    }
  }
#line 1464
  return;
}
}
#line 1466 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
static void open_controlfd(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1468
  control_fd = open((char const   *)(gconfig.controlfile), 2048, 384);
  }
#line 1469
  if (control_fd < 0) {
    {
#line 1471
    l2tp_log(2, "%s: Unable to open %s for reading.\n", "open_controlfd", gconfig.controlfile);
#line 1473
    exit(1);
    }
  }
  {
#line 1477
  tmp___1 = fcntl(control_fd, 4, 0);
  }
#line 1477
  if (tmp___1 == -1) {
    {
#line 1478
    tmp = __errno_location();
#line 1478
    tmp___0 = strerror(*tmp);
#line 1478
    l2tp_log(2, "Can not turn off nonblocking mode for controlfd: %s\n", tmp___0);
#line 1480
    exit(1);
    }
  }
#line 1482
  return;
}
}
#line 1484 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
void init(int argc , char **argv ) 
{ 
  struct lac *lac ;
  struct in_addr listenaddr ;
  struct utsname uts ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1490
  init_args(argc, argv);
#line 1491
  tmp = time((time_t *)((void *)0));
#line 1491
  srand((unsigned int )tmp);
#line 1492
  rand_source = 0;
#line 1493
  init_addr();
#line 1494
  tmp___0 = init_config();
  }
#line 1494
  if (tmp___0) {
    {
#line 1496
    l2tp_log(2, "%s: Unable to load config file\n", "init");
#line 1497
    exit(1);
    }
  }
  {
#line 1499
  tmp___1 = uname(& uts);
  }
#line 1499
  if (tmp___1 < 0) {
    {
#line 1501
    l2tp_log(2, "%s : Unable to determine host system\n", "init");
#line 1503
    exit(1);
    }
  }
  {
#line 1505
  init_tunnel_list(& tunnels);
#line 1506
  tmp___2 = init_network();
  }
#line 1506
  if (tmp___2) {
    {
#line 1507
    exit(1);
    }
  }
#line 1509
  if (gconfig.daemon) {
    {
#line 1510
    daemonize();
    }
  }
  {
#line 1512
  consider_pidfile();
#line 1514
  signal(15, & sigterm_handler);
#line 1515
  signal(2, & sigint_handler);
#line 1516
  signal(17, & sigchld_handler);
#line 1517
  signal(10, & sigusr1_handler);
#line 1518
  signal(1, & sighup_handler);
#line 1519
  init_scheduler();
#line 1521
  unlink((char const   *)(gconfig.controlfile));
#line 1522
  mkfifo((char const   *)(gconfig.controlfile), (__mode_t )384);
#line 1524
  open_controlfd();
#line 1526
  tmp___3 = getpid();
#line 1526
  l2tp_log(6, "xl2tpd version xl2tpd-1.3.6 started on %s PID:%d\n", hostname, tmp___3);
#line 1528
  l2tp_log(6, "Written by Mark Spencer, Copyright (C) 1998, Adtran, Inc.\n");
#line 1530
  l2tp_log(6, "Forked by Scott Balmos and David Stipp, (C) 2001\n");
#line 1531
  l2tp_log(6, "Inherited by Jeff McAdams, (C) 2002\n");
#line 1532
  l2tp_log(6, "Forked again by Xelerance (www.xelerance.com) (C) 2006\n");
#line 1533
  listenaddr.s_addr = gconfig.listenaddr;
#line 1534
  tmp___4 = inet_ntoa(listenaddr);
#line 1534
  l2tp_log(6, "Listening on IP address %s, port %d\n", tmp___4, gconfig.port);
#line 1536
  lac = laclist;
  }
  {
#line 1537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1537
    if (! lac) {
#line 1537
      goto while_break;
    }
#line 1539
    if (lac->autodial) {
      {
#line 1545
      lac->active = -1;
#line 1546
      switch_io = 1;
#line 1547
      magic_lac_dial((void *)lac);
      }
    }
#line 1549
    lac = lac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1551
  return;
}
}
#line 1553 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/xl2tpd.c"
int main(int argc , char **argv ) 
{ 
  void *tmp ;

  {
  {
#line 1555
  init(argc, argv);
#line 1556
  tmp = calloc((size_t )128, sizeof(char ));
#line 1556
  dial_no_tmp = (char *)tmp;
#line 1557
  network_thread();
  }
#line 1558
  return (0);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 63 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/misc.h"
char hostname[256]  ;
#line 103 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.h"
struct call *get_tunnel(int tunnel , unsigned int addr , int port ) ;
#line 55 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.h"
int handle_packet(struct buffer *buf , struct tunnel *t , struct call *c ) ;
#line 60
void control_zlb(struct buffer *buf , struct tunnel *t , struct call *c ) ;
#line 62
void handle_special(struct buffer *buf , struct call *c , _u16 call ) ;
#line 212 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
int server_socket  ;
#line 217
void recycle_payload(struct buffer *buf , struct sockaddr_in peer ) ;
#line 218
void add_payload_hdr(struct tunnel *t , struct call *c , struct buffer *buf ) ;
#line 219
int read_packet(struct buffer *buf , int fd , int convert ) ;
#line 220
void udp_xmit(struct buffer *buf , struct tunnel *t ) ;
#line 226 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
int kernel_support  ;
#line 227
int connect_pppol2tp(struct tunnel *t ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
struct sockaddr_in server  ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
struct sockaddr_in from  ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
int init_network(void) 
{ 
  long arg ;
  unsigned int length ;
  int flags ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int kernel_fd ;
  int tmp___11 ;
  int tmp___12 ;
  uint16_t tmp___13 ;

  {
  {
#line 43
  length = (unsigned int )sizeof(server);
#line 44
  gethostname(hostname, sizeof(hostname));
#line 45
  server.sin_family = (sa_family_t )2;
#line 46
  server.sin_addr.s_addr = gconfig.listenaddr;
#line 47
  server.sin_port = htons((uint16_t )gconfig.port);
#line 49
  server_socket = socket(2, 2, 0);
  }
#line 49
  if (server_socket < 0) {
    {
#line 51
    l2tp_log(2, "%s: Unable to allocate socket. Terminating.\n", "init_network");
    }
#line 53
    return (-22);
  }
  {
#line 56
  flags = 1;
#line 57
  setsockopt(server_socket, 1, 2, (void const   *)(& flags), (socklen_t )sizeof(flags));
#line 59
  setsockopt(server_socket, 1, 11, (void const   *)(& flags), (socklen_t )sizeof(flags));
#line 62
  tmp___2 = bind(server_socket, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                 (socklen_t )sizeof(server));
  }
#line 62
  if (tmp___2) {
    {
#line 64
    close(server_socket);
#line 65
    tmp = __errno_location();
#line 65
    tmp___0 = __errno_location();
#line 65
    tmp___1 = strerror(*tmp___0);
#line 65
    l2tp_log(2, "%s: Unable to bind socket: %s. Terminating.\n", "init_network", tmp___1,
             *tmp);
    }
#line 67
    return (-22);
  }
  {
#line 69
  tmp___3 = getsockname(server_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& server)),
                        (socklen_t */* __restrict  */)(& length));
  }
#line 69
  if (tmp___3) {
    {
#line 71
    l2tp_log(2, "%s: Unable to read socket name.Terminating.\n", "init_network");
    }
#line 73
    return (-22);
  }
  {
#line 81
  arg = 1L;
#line 82
  tmp___6 = setsockopt(server_socket, 0, gconfig.sarefnum, (void const   *)(& arg),
                       (socklen_t )sizeof(arg));
  }
#line 82
  if (tmp___6 != 0) {
    {
#line 84
    tmp___4 = __errno_location();
#line 84
    tmp___5 = strerror(*tmp___4);
#line 84
    l2tp_log(2, "setsockopt recvref[%d]: %s\n", gconfig.sarefnum, tmp___5);
#line 86
    gconfig.ipsecsaref = 0;
    }
  }
  {
#line 89
  arg = 1L;
#line 90
  tmp___9 = setsockopt(server_socket, 0, 8, (void const   *)((char *)(& arg)), (socklen_t )sizeof(arg));
  }
#line 90
  if (tmp___9 != 0) {
    {
#line 91
    tmp___7 = __errno_location();
#line 91
    tmp___8 = strerror(*tmp___7);
#line 91
    l2tp_log(2, "setsockopt IP_PKTINFO: %s\n", tmp___8);
    }
  }
  {
#line 101
  arg = 1L;
#line 102
  tmp___10 = setsockopt(server_socket, 1, 11, (void const   *)((void *)(& arg)), (socklen_t )sizeof(arg));
  }
#line 102
  if (tmp___10 == -1) {
    {
#line 104
    l2tp_log(6, "unable to turn off UDP checksums");
    }
  }
#line 108
  if (gconfig.forceuserspace) {
    {
#line 110
    l2tp_log(6, "Not looking for kernel support.\n");
#line 111
    kernel_support = 0;
    }
  } else {
    {
#line 115
    tmp___11 = socket(24, 2, 1);
#line 115
    kernel_fd = tmp___11;
    }
#line 116
    if (kernel_fd < 0) {
      {
#line 118
      l2tp_log(6, "L2TP kernel support not detected (try modprobing l2tp_ppp and pppol2tp)\n");
#line 119
      kernel_support = 0;
      }
    } else {
      {
#line 123
      close(kernel_fd);
#line 124
      l2tp_log(6, "Using l2tp kernel support.\n");
#line 125
      kernel_support = -1;
      }
    }
  }
  {
#line 131
  tmp___12 = fcntl(server_socket, 3);
#line 131
  arg = (long )tmp___12;
#line 132
  arg |= 2048L;
#line 133
  fcntl(server_socket, 4, arg);
#line 134
  tmp___13 = ntohs(server.sin_port);
#line 134
  gconfig.port = (int )tmp___13;
  }
#line 135
  return (0);
}
}
#line 138 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
__inline void extract(void *buf , int *tunnel , int *call ) 
{ 
  struct payload_hdr *p ;

  {
#line 145
  p = (struct payload_hdr *)buf;
#line 146
  if ((int )p->ver & 16384) {
#line 148
    *tunnel = (int )p->tid;
#line 149
    *call = (int )p->cid;
  } else {
#line 153
    *tunnel = (int )p->length;
#line 154
    *call = (int )p->tid;
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
__inline void fix_hdr(void *buf ) 
{ 
  struct payload_hdr *p ;
  _u16 ver ;
  uint16_t tmp ;
  int len ;

  {
  {
#line 164
  p = (struct payload_hdr *)buf;
#line 165
  tmp = ntohs(p->ver);
#line 165
  ver = tmp;
  }
#line 166
  if ((int )p->ver & 32768) {
    {
#line 172
    swaps(buf, 12);
    }
  } else {
#line 176
    len = 6;
#line 177
    if ((int )ver & 512) {
#line 178
      len += 2;
    }
#line 179
    if ((int )ver & 16384) {
#line 180
      len += 2;
    }
#line 181
    if ((int )ver & 2048) {
#line 182
      len += 4;
    }
    {
#line 183
    swaps(buf, len);
    }
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
void dethrottle(void *call ) 
{ 


  {
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
void control_xmit(void *b ) 
{ 
  struct buffer *buf ;
  struct tunnel *t ;
  struct timeval tv ;
  int ns ;
  uint16_t tmp ;

  {
#line 202
  buf = (struct buffer *)b;
#line 207
  if (! buf) {
    {
#line 209
    l2tp_log(4, "%s: called on NULL buffer!\n", "control_xmit");
    }
#line 210
    return;
  }
  {
#line 213
  t = buf->tunnel;
#line 222
  (buf->retries) ++;
#line 223
  tmp = ntohs(((struct control_hdr *)buf->start)->Ns);
#line 223
  ns = (int )tmp;
  }
#line 224
  if (t) {
#line 226
    if (ns < t->cLr) {
      {
#line 232
      toss(buf);
      }
#line 233
      return;
    }
  }
#line 236
  if (buf->retries > 5) {
#line 242
    if (t) {
#line 244
      if ((t->self)->needclose) {
        {
#line 246
        l2tp_log(7, "Unable to deliver closing message for tunnel %d. Destroying anyway.\n",
                 t->ourtid);
#line 249
        (t->self)->needclose = 0;
#line 250
        (t->self)->closing = -1;
        }
      } else {
        {
#line 254
        l2tp_log(5, "Maximum retries exceeded for tunnel %d.  Closing.\n", t->ourtid);
#line 257
        strcpy((char */* __restrict  */)((t->self)->errormsg), (char const   */* __restrict  */)"Timeout");
#line 258
        (t->self)->needclose = -1;
        }
      }
      {
#line 260
      call_close(t->self);
      }
    }
    {
#line 262
    toss(buf);
    }
  } else {
    {
#line 269
    tv.tv_sec = (__time_t )1;
#line 270
    tv.tv_usec = (__suseconds_t )0;
#line 271
    schedule(tv, & control_xmit, (void *)buf);
#line 276
    udp_xmit(buf, t);
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
void udp_xmit(struct buffer *buf , struct tunnel *t ) 
{ 
  struct cmsghdr *cmsg ;
  char cbuf[((((sizeof(unsigned int ) + sizeof(struct in_pktinfo )) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  unsigned int *refp ;
  struct msghdr msgh ;
  int err ;
  struct iovec iov ;
  struct in_pktinfo *pktinfo ;
  int finallen ;
  int *tmp ;
  char *tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 294
  memset((void *)(& msgh), 0, sizeof(struct msghdr ));
#line 296
  cmsg = (struct cmsghdr *)((void *)0);
#line 297
  msgh.msg_control = (void *)(cbuf);
#line 298
  msgh.msg_controllen = sizeof(cbuf);
#line 299
  finallen = 0;
  }
#line 301
  if (gconfig.ipsecsaref) {
#line 301
    if (t->refhim != 0U) {
#line 302
      if (msgh.msg_controllen >= sizeof(struct cmsghdr )) {
#line 302
        cmsg = (struct cmsghdr *)msgh.msg_control;
      } else {
#line 302
        cmsg = (struct cmsghdr *)0;
      }
#line 303
      cmsg->cmsg_level = 0;
#line 304
      cmsg->cmsg_type = gconfig.sarefnum;
#line 305
      cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(unsigned int );
#line 307
      if (gconfig.debug_network) {
        {
#line 308
        l2tp_log(7, "sending with saref=%d using sarefnum=%d\n", t->refhim, gconfig.sarefnum);
        }
      }
#line 310
      refp = (unsigned int *)(cmsg->__cmsg_data);
#line 311
      *refp = t->refhim;
#line 313
      finallen = (int )cmsg->cmsg_len;
    }
  }
#line 316
  if (t->my_addr.ipi_addr.s_addr) {
#line 318
    if (! cmsg) {
#line 319
      if (msgh.msg_controllen >= sizeof(struct cmsghdr )) {
#line 319
        cmsg = (struct cmsghdr *)msgh.msg_control;
      } else {
#line 319
        cmsg = (struct cmsghdr *)0;
      }
    } else {
      {
#line 322
      cmsg = __cmsg_nxthdr(& msgh, cmsg);
      }
    }
#line 325
    cmsg->cmsg_level = 0;
#line 326
    cmsg->cmsg_type = 8;
#line 327
    cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct in_pktinfo );
#line 329
    pktinfo = (struct in_pktinfo *)(cmsg->__cmsg_data);
#line 330
    *pktinfo = t->my_addr;
#line 332
    finallen = (int )((size_t )finallen + cmsg->cmsg_len);
  }
  {
#line 335
  msgh.msg_controllen = (size_t )finallen;
#line 337
  iov.iov_base = buf->start;
#line 338
  iov.iov_len = (size_t )buf->len;
#line 341
  msgh.msg_name = (void *)(& buf->peer);
#line 342
  msgh.msg_namelen = (socklen_t )sizeof(buf->peer);
#line 344
  msgh.msg_iov = & iov;
#line 345
  msgh.msg_iovlen = (size_t )1;
#line 346
  msgh.msg_flags = 0;
#line 350
  tmp___3 = sendmsg(server_socket, (struct msghdr  const  *)(& msgh), 0);
#line 350
  err = (int )tmp___3;
  }
#line 350
  if (err < 0) {
    {
#line 351
    tmp = __errno_location();
#line 351
    tmp___0 = strerror(*tmp);
#line 351
    tmp___1 = ntohs(t->peer.sin_port);
#line 351
    tmp___2 = inet_ntoa(t->peer.sin_addr);
#line 351
    l2tp_log(3, "udp_xmit failed to %s:%d with err=%d:%s\n", tmp___2, (int )tmp___1,
             err, tmp___0);
    }
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
int build_fdset(fd_set *readfds ) 
{ 
  struct tunnel *tun ;
  struct call *call ;
  int max___0 ;
  int __d0 ;
  int __d1 ;

  {
#line 361
  max___0 = 0;
#line 363
  tun = tunnels.head;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds->__fds_bits[0]): "memory");
#line 364
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 366
    if (! tun) {
#line 366
      goto while_break___0;
    }
#line 368
    if (tun->udp_fd > -1) {
#line 369
      if (tun->udp_fd > max___0) {
#line 370
        max___0 = tun->udp_fd;
      }
#line 371
      readfds->__fds_bits[tun->udp_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << tun->udp_fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 373
    call = tun->call_head;
    {
#line 374
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 374
      if (! call) {
#line 374
        goto while_break___1;
      }
#line 376
      if (call->needclose ^ call->closing) {
        {
#line 378
        call_close(call);
#line 379
        call = tun->call_head;
        }
#line 380
        if (! call) {
#line 381
          goto while_break___1;
        }
#line 382
        goto while_continue___1;
      }
#line 384
      if (call->fd > -1) {
#line 386
        if (! call->needclose) {
#line 386
          if (! call->closing) {
#line 388
            if (call->fd > max___0) {
#line 389
              max___0 = call->fd;
            }
#line 390
            readfds->__fds_bits[call->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << call->fd % (8 * (int )sizeof(__fd_mask ));
          }
        }
      }
#line 393
      call = call->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 398
    if ((tun->self)->needclose ^ (tun->self)->closing) {
#line 400
      if (gconfig.debug_tunnel) {
        {
#line 401
        l2tp_log(7, "%s: closing down tunnel %d\n", "build_fdset", tun->ourtid);
        }
      }
      {
#line 403
      call_close(tun->self);
#line 406
      tun = tunnels.head;
      }
#line 407
      if (! tun) {
#line 408
        goto while_break___0;
      }
#line 409
      goto while_continue___0;
    }
#line 411
    tun = tun->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 413
  readfds->__fds_bits[server_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << server_socket % (8 * (int )sizeof(__fd_mask ));
#line 414
  if (server_socket > max___0) {
#line 415
    max___0 = server_socket;
  }
#line 416
  readfds->__fds_bits[control_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << control_fd % (8 * (int )sizeof(__fd_mask ));
#line 417
  if (control_fd > max___0) {
#line 418
    max___0 = control_fd;
  }
#line 419
  return (max___0);
}
}
#line 422 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
void network_thread(void) 
{ 
  struct sockaddr_in from___0 ;
  struct in_pktinfo to ;
  unsigned int fromlen ;
  int tunnel ;
  int call ;
  int recvsize ;
  struct buffer *buf ;
  struct call *c ;
  struct call *sc ;
  struct tunnel *st ;
  fd_set readfds ;
  int max___0 ;
  struct timeval tv ;
  struct timeval *ptv ;
  struct msghdr msgh ;
  struct iovec iov ;
  char cbuf[256] ;
  unsigned int refme ;
  unsigned int refhim ;
  int *currentfd ;
  int server_socket_processed ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  struct cmsghdr *cmsg ;
  struct in_pktinfo *pktInfo ;
  unsigned int *refp ;
  char *tmp___10 ;
  int tmp___11 ;
  int result ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 447
  buf = new_buf(4096);
#line 449
  tunnel = 0;
#line 450
  call = 0;
  }
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 455
    process_signal();
#line 456
    max___0 = build_fdset(& readfds);
#line 457
    ptv = process_schedule(& tv);
#line 458
    ret = select(max___0 + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)ptv);
    }
#line 459
    if (ret <= 0) {
#line 461
      if (ret == 0) {
#line 463
        if (gconfig.debug_network) {
          {
#line 465
          l2tp_log(7, "%s: select timeout\n", "network_thread");
          }
        }
      } else
#line 470
      if (gconfig.debug_network) {
        {
#line 472
        tmp = __errno_location();
#line 472
        tmp___0 = strerror(*tmp);
#line 472
        tmp___1 = __errno_location();
#line 472
        l2tp_log(7, "%s: select returned error %d (%s)\n", "network_thread", *tmp___1,
                 tmp___0);
        }
      }
#line 477
      goto __Cont;
    }
#line 479
    if ((readfds.__fds_bits[control_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << control_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 481
      do_control();
      }
    }
#line 483
    server_socket_processed = 0;
#line 484
    currentfd = (int *)((void *)0);
#line 485
    st = tunnels.head;
    {
#line 486
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 486
      if (! st) {
#line 486
        if (! (! server_socket_processed)) {
#line 486
          goto while_break___0;
        }
      }
#line 487
      if (st) {
#line 487
        if (st->udp_fd == -1) {
#line 488
          st = st->next;
#line 489
          goto while_continue___0;
        }
      }
#line 491
      if (st) {
#line 492
        currentfd = & st->udp_fd;
      } else {
#line 494
        currentfd = & server_socket;
#line 495
        server_socket_processed = 1;
      }
#line 497
      if ((readfds.__fds_bits[*currentfd / (8 * (int )sizeof(__fd_mask ))] & (1L << *currentfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 502
        recycle_buf(buf);
#line 505
        buf->start += 10;
#line 506
        buf->len -= 10;
#line 508
        memset((void *)(& from___0), 0, sizeof(from___0));
#line 509
        memset((void *)(& to), 0, sizeof(to));
#line 511
        fromlen = (unsigned int )sizeof(from___0);
#line 513
        memset((void *)(& msgh), 0, sizeof(struct msghdr ));
#line 514
        iov.iov_base = buf->start;
#line 515
        iov.iov_len = (size_t )buf->len;
#line 516
        msgh.msg_control = (void *)(cbuf);
#line 517
        msgh.msg_controllen = sizeof(cbuf);
#line 518
        msgh.msg_name = (void *)(& from___0);
#line 519
        msgh.msg_namelen = fromlen;
#line 520
        msgh.msg_iov = & iov;
#line 521
        msgh.msg_iovlen = (size_t )1;
#line 522
        msgh.msg_flags = 0;
#line 525
        tmp___2 = recvmsg(*currentfd, & msgh, 0);
#line 525
        recvsize = (int )tmp___2;
        }
#line 527
        if (recvsize < 6) {
#line 529
          if (recvsize < 0) {
            {
#line 531
            tmp___3 = __errno_location();
            }
#line 531
            if (*tmp___3 == 111) {
              {
#line 532
              close(*currentfd);
              }
            }
            {
#line 534
            tmp___4 = __errno_location();
            }
#line 534
            if (*tmp___4 == 111) {
#line 536
              *currentfd = -1;
            } else {
              {
#line 534
              tmp___5 = __errno_location();
              }
#line 534
              if (*tmp___5 == 9) {
#line 536
                *currentfd = -1;
              }
            }
            {
#line 538
            tmp___9 = __errno_location();
            }
#line 538
            if (*tmp___9 != 11) {
              {
#line 539
              tmp___6 = __errno_location();
#line 539
              tmp___7 = strerror(*tmp___6);
#line 539
              tmp___8 = __errno_location();
#line 539
              l2tp_log(4, "%s: recvfrom returned error %d (%s)\n", "network_thread",
                       *tmp___8, tmp___7);
              }
            }
          } else {
            {
#line 545
            l2tp_log(4, "%s: received too small a packet\n", "network_thread");
            }
          }
#line 548
          goto while_continue___0;
        }
#line 552
        refhim = 0U;
#line 552
        refme = refhim;
#line 557
        if (msgh.msg_controllen >= sizeof(struct cmsghdr )) {
#line 557
          cmsg = (struct cmsghdr *)msgh.msg_control;
        } else {
#line 557
          cmsg = (struct cmsghdr *)0;
        }
        {
#line 557
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 557
          if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 557
            goto while_break___1;
          }
#line 561
          if (cmsg->cmsg_level == 0) {
#line 561
            if (cmsg->cmsg_type == 8) {
#line 562
              pktInfo = (struct in_pktinfo *)(cmsg->__cmsg_data);
#line 563
              to = *pktInfo;
            } else {
#line 561
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 566
          if (gconfig.ipsecsaref) {
#line 566
            if (cmsg->cmsg_level == 0) {
#line 566
              if (cmsg->cmsg_type == gconfig.sarefnum) {
#line 570
                refp = (unsigned int *)(cmsg->__cmsg_data);
#line 571
                refme = *(refp + 0);
#line 572
                refhim = *(refp + 1);
              }
            }
          }
          {
#line 557
          cmsg = __cmsg_nxthdr(& msgh, cmsg);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 581
        buf->len = recvsize;
#line 582
        fix_hdr(buf->start);
#line 583
        extract(buf->start, & tunnel, & call);
        }
#line 585
        if (gconfig.debug_network) {
          {
#line 587
          tmp___10 = inet_ntoa(from___0.sin_addr);
#line 587
          l2tp_log(7, "%s: recv packet from %s, size = %d, tunnel = %d, call = %d ref=%u refhim=%u\n",
                   "network_thread", tmp___10, recvsize, tunnel, call, refme, refhim);
          }
        }
#line 593
        if (gconfig.packet_dump) {
          {
#line 595
          do_packet_dump(buf);
          }
        }
        {
#line 597
        c = get_call(tunnel, call, from___0.sin_addr, (int )from___0.sin_port, refme,
                     refhim);
        }
#line 597
        if (c) {
#line 630
          if (c->container) {
#line 631
            (c->container)->my_addr = to;
          }
          {
#line 634
          buf->peer = from___0;
#line 636
          (c->container)->chal_us.vector = (unsigned char *)((void *)0);
#line 637
          tmp___11 = handle_packet(buf, c->container, c);
          }
#line 637
          if (tmp___11) {
#line 639
            if (gconfig.debug_tunnel) {
              {
#line 640
              l2tp_log(7, "%s: bad packet\n", "network_thread");
              }
            }
          }
#line 642
          if (c->cnu) {
            {
#line 645
            control_zlb(buf, c->container, c);
#line 646
            c->cnu = 0;
            }
          }
        } else {
          {
#line 601
          c = get_tunnel(tunnel, from___0.sin_addr.s_addr, (int )from___0.sin_port);
          }
#line 601
          if (c) {
#line 613
            if (gconfig.debug_tunnel) {
              {
#line 614
              l2tp_log(7, "%s: no such call %d on tunnel %d.  Sending special ZLB\n",
                       "network_thread");
              }
            }
            {
#line 617
            handle_special(buf, c, (_u16 )call);
#line 620
            buf = new_buf(4096);
            }
          } else {
            {
#line 623
            l2tp_log(7, "%s: unable to find call or tunnel to handle packet.  call = %d, tunnel = %d Dumping.\n",
                     "network_thread", call, tunnel);
            }
          }
        }
      }
#line 650
      if (st) {
#line 650
        st = st->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 656
    st = tunnels.head;
    {
#line 657
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 657
      if (! st) {
#line 657
        goto while_break___2;
      }
#line 659
      sc = st->call_head;
      {
#line 660
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 660
        if (! sc) {
#line 660
          goto while_break___3;
        }
#line 662
        if (sc->fd >= 0) {
#line 662
          if ((readfds.__fds_bits[sc->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << sc->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
            {
#line 666
            recycle_payload(buf, (sc->container)->peer);
            }
            {
#line 687
            while (1) {
              while_continue___4: /* CIL Label */ ;
              {
#line 687
              result = read_packet(buf, sc->fd, 1);
              }
#line 687
              if (! (result > 0)) {
#line 687
                goto while_break___4;
              }
              {
#line 690
              add_payload_hdr(sc->container, sc, buf);
              }
#line 691
              if (gconfig.packet_dump) {
                {
#line 693
                do_packet_dump(buf);
                }
              }
#line 697
              sc->prx = (int )sc->data_rec_seq_num;
#line 698
              if (sc->zlb_xmit) {
                {
#line 700
                deschedule(sc->zlb_xmit);
#line 701
                sc->zlb_xmit = (struct schedule_entry *)((void *)0);
                }
              }
              {
#line 703
              sc->tx_bytes += buf->len;
#line 704
              (sc->tx_pkts) ++;
#line 705
              udp_xmit(buf, st);
#line 706
              recycle_payload(buf, (sc->container)->peer);
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 708
            if (result != 0) {
              {
#line 710
              tmp___12 = strerror(- result);
#line 710
              l2tp_log(4, "%s: tossing read packet, error = %s (%d).  Closing call.\n",
                       "network_thread", tmp___12, - result);
#line 713
              tmp___13 = strerror(- result);
#line 713
              strcpy((char */* __restrict  */)(sc->errormsg), (char const   */* __restrict  */)tmp___13);
#line 714
              sc->needclose = -1;
              }
            }
          }
        }
#line 717
        sc = sc->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 719
      st = st->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 726 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/network.c"
int connect_pppol2tp(struct tunnel *t ) 
{ 
  int ufd ;
  int fd2 ;
  int flags ;
  struct sockaddr_pppol2tp sax ;
  struct sockaddr_in server___0 ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
#line 727
  if (kernel_support) {
    {
#line 728
    ufd = -1;
#line 728
    fd2 = -1;
#line 733
    server___0.sin_family = (sa_family_t )2;
#line 734
    server___0.sin_addr.s_addr = gconfig.listenaddr;
#line 735
    server___0.sin_port = htons((uint16_t )gconfig.port);
#line 736
    ufd = socket(2, 2, 0);
    }
#line 736
    if (ufd < 0) {
      {
#line 738
      l2tp_log(2, "%s: Unable to allocate UDP socket. Terminating.\n", "connect_pppol2tp");
      }
#line 740
      return (-22);
    }
    {
#line 743
    flags = 1;
#line 744
    setsockopt(ufd, 1, 2, (void const   *)(& flags), (socklen_t )sizeof(flags));
#line 746
    setsockopt(ufd, 1, 11, (void const   *)(& flags), (socklen_t )sizeof(flags));
#line 749
    tmp___2 = bind(ufd, (struct sockaddr  const  *)((struct sockaddr *)(& server___0)),
                   (socklen_t )sizeof(server___0));
    }
#line 749
    if (tmp___2) {
      {
#line 751
      close(ufd);
#line 752
      tmp = __errno_location();
#line 752
      tmp___0 = __errno_location();
#line 752
      tmp___1 = strerror(*tmp___0);
#line 752
      l2tp_log(2, "%s: Unable to bind UDP socket: %s. Terminating.\n", "connect_pppol2tp",
               tmp___1, *tmp);
      }
#line 754
      return (-22);
    }
    {
#line 756
    server___0 = t->peer;
#line 757
    flags = fcntl(ufd, 3);
    }
#line 758
    if (flags == -1) {
      {
#line 759
      l2tp_log(4, "%s: Unable to set UDP socket nonblock.\n", "connect_pppol2tp");
      }
#line 761
      return (-22);
    } else {
      {
#line 758
      tmp___3 = fcntl(ufd, 4, flags | 2048);
      }
#line 758
      if (tmp___3 == -1) {
        {
#line 759
        l2tp_log(4, "%s: Unable to set UDP socket nonblock.\n", "connect_pppol2tp");
        }
#line 761
        return (-22);
      }
    }
    {
#line 763
    tmp___4 = connect(ufd, (struct sockaddr  const  *)((struct sockaddr *)(& server___0)),
                      (socklen_t )sizeof(server___0));
    }
#line 763
    if (tmp___4 < 0) {
      {
#line 764
      l2tp_log(2, "%s: Unable to connect UDP peer. Terminating.\n", "connect_pppol2tp");
      }
#line 766
      return (-22);
    }
    {
#line 769
    t->udp_fd = ufd;
#line 771
    fd2 = socket(24, 2, 1);
    }
#line 772
    if (fd2 < 0) {
      {
#line 773
      l2tp_log(4, "%s: Unable to allocate PPPoL2TP socket.\n", "connect_pppol2tp");
      }
#line 775
      return (-22);
    }
    {
#line 777
    flags = fcntl(fd2, 3);
    }
#line 778
    if (flags == -1) {
      {
#line 779
      l2tp_log(4, "%s: Unable to set PPPoL2TP socket nonblock.\n", "connect_pppol2tp");
      }
#line 781
      return (-22);
    } else {
      {
#line 778
      tmp___5 = fcntl(fd2, 4, flags | 2048);
      }
#line 778
      if (tmp___5 == -1) {
        {
#line 779
        l2tp_log(4, "%s: Unable to set PPPoL2TP socket nonblock.\n", "connect_pppol2tp");
        }
#line 781
        return (-22);
      }
    }
    {
#line 783
    memset((void *)(& sax), 0, sizeof(sax));
#line 784
    sax.sa_family = (__kernel_sa_family_t )24;
#line 785
    sax.sa_protocol = 1U;
#line 786
    sax.pppol2tp.fd = t->udp_fd;
#line 787
    sax.pppol2tp.addr.sin_addr.s_addr = t->peer.sin_addr.s_addr;
#line 788
    sax.pppol2tp.addr.sin_port = t->peer.sin_port;
#line 789
    sax.pppol2tp.addr.sin_family = (sa_family_t )2;
#line 790
    sax.pppol2tp.s_tunnel = (__u16 )t->ourtid;
#line 791
    sax.pppol2tp.d_tunnel = (__u16 )t->tid;
#line 792
    tmp___9 = connect(fd2, (struct sockaddr  const  *)((struct sockaddr *)(& sax)),
                      (socklen_t )sizeof(sax));
    }
#line 792
    if (tmp___9 < 0) {
      {
#line 793
      tmp___6 = __errno_location();
#line 793
      tmp___7 = strerror(*tmp___6);
#line 793
      tmp___8 = __errno_location();
#line 793
      l2tp_log(4, "%s: Unable to connect PPPoL2TP socket. %d %s\n", "connect_pppol2tp",
               *tmp___8, tmp___7);
#line 795
      close(fd2);
      }
#line 796
      return (-22);
    }
#line 798
    t->pppox_fd = fd2;
  }
#line 800
  return (0);
}
}
#line 928 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) unlockpt)(int __fd ) ;
#line 933
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ptsname)(int __fd ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 55 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/pty.c"
int getPtyMaster_pty(char *tty10 , char *tty01 ) ;
#line 55 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/pty.c"
static char dev[11]  = 
#line 55
  {      (char )'/',      (char )'d',      (char )'e',      (char )'v', 
        (char )'/',      (char )'p',      (char )'t',      (char )'y', 
        (char )'X',      (char )'X',      (char )'\000'};
#line 51 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/pty.c"
int getPtyMaster_pty(char *tty10 , char *tty01 ) 
{ 
  char *p10 ;
  char *p01 ;
  int fd ;

  {
#line 58
  p10 = (char *)"pqrstuvwxyzabcde";
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! *p10) {
#line 58
      goto while_break;
    }
#line 60
    dev[8] = *p10;
#line 61
    p01 = (char *)"0123456789abcdef";
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 61
      if (! *p01) {
#line 61
        goto while_break___0;
      }
      {
#line 63
      dev[9] = *p01;
#line 64
      fd = open((char const   *)(dev), 2050);
      }
#line 65
      if (fd >= 0) {
#line 67
        *tty10 = *p10;
#line 68
        *tty01 = *p01;
#line 69
        return (fd);
      }
#line 61
      p01 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 58
    p10 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  l2tp_log(2, "%s: No more free pseudo-tty\'s\n", "getPtyMaster_pty");
  }
#line 74
  return (-1);
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/pty.c"
int getPtyMaster_ptmx(char *ttybuf , int ttybuflen ) 
{ 
  int fd ;
  char *tty ;
  int tmp ;

  {
  {
#line 82
  fd = open("/dev/ptmx", 2);
  }
#line 83
  if (fd == -1) {
    {
#line 85
    l2tp_log(4, "%s: unable to open /dev/ptmx to allocate pty\n", "getPtyMaster_ptmx");
    }
#line 87
    return (-22);
  }
  {
#line 92
  tmp = unlockpt(fd);
  }
#line 92
  if (tmp) {
    {
#line 94
    l2tp_log(4, "%s: unable to unlockpt() on pty\n", "getPtyMaster_ptmx");
#line 96
    close(fd);
    }
#line 97
    return (-22);
  }
  {
#line 100
  tty = ptsname(fd);
  }
#line 101
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
    {
#line 103
    l2tp_log(4, "%s: unable to obtain name of slave tty\n", "getPtyMaster_ptmx");
#line 105
    close(fd);
    }
#line 106
    return (-22);
  }
  {
#line 108
  *(ttybuf + 0) = (char )'\000';
#line 109
  strncat((char */* __restrict  */)ttybuf, (char const   */* __restrict  */)tty, (size_t )ttybuflen);
  }
#line 111
  return (fd);
}
}
#line 137 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/pty.c"
int getPtyMaster(char *ttybuf , int ttybuflen ) 
{ 
  int fd ;
  char a ;
  char b ;

  {
  {
#line 141
  fd = getPtyMaster_ptmx(ttybuf, ttybuflen);
  }
#line 144
  if (fd >= 0) {
#line 145
    return (fd);
  }
  {
#line 148
  l2tp_log(4, "%s: failed to use pts -- using legacy ptys\n", "getPtyMaster");
#line 149
  fd = getPtyMaster_pty(& a, & b);
  }
#line 151
  if (fd >= 0) {
    {
#line 152
    snprintf((char */* __restrict  */)ttybuf, (size_t )ttybuflen, (char const   */* __restrict  */)"/dev/tty%c%c",
             (int )a, (int )b);
    }
#line 153
    return (fd);
  }
#line 164
  return (-22);
}
}
#line 17 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/md5.h"
void MD5Init(struct MD5Context *ctx ) ;
#line 18
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) ;
#line 20
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) ;
#line 21
void MD5Transform(uint32 *buf , uint32 const   *in ) ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/md5.c"
void MD5Init(struct MD5Context *ctx ) 
{ 


  {
#line 64
  ctx->buf[0] = (uint32 )1732584193;
#line 65
  ctx->buf[1] = (uint32 )4023233417U;
#line 66
  ctx->buf[2] = (uint32 )2562383102U;
#line 67
  ctx->buf[3] = (uint32 )271733878;
#line 69
  ctx->bits[0] = (uint32 )0;
#line 70
  ctx->bits[1] = (uint32 )0;
#line 71
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/md5.c"
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) 
{ 
  uint32 t ;
  uint32 tmp ;
  unsigned char *p ;

  {
#line 84
  t = ctx->bits[0];
#line 85
  tmp = t + ((uint32 )len << 3);
#line 85
  ctx->bits[0] = tmp;
#line 85
  if (tmp < t) {
#line 86
    (ctx->bits[1]) ++;
  }
#line 87
  ctx->bits[1] += (uint32 )(len >> 29);
#line 89
  t = (t >> 3) & 63UL;
#line 93
  if (t) {
#line 95
    p = ctx->in + t;
#line 97
    t = 64UL - t;
#line 98
    if ((uint32 )len < t) {
      {
#line 100
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf, (size_t )len);
      }
#line 101
      return;
    }
    {
#line 103
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf, t);
#line 105
    MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 106
    buf += t;
#line 107
    len = (unsigned int )((uint32 )len - t);
    }
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (len >= 64U)) {
#line 111
      goto while_break;
    }
    {
#line 113
    memcpy((void */* __restrict  */)(ctx->in), (void const   */* __restrict  */)buf,
           (size_t )64);
#line 115
    MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 116
    buf += 64;
#line 117
    len -= 64U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  memcpy((void */* __restrict  */)(ctx->in), (void const   */* __restrict  */)buf,
         (size_t )len);
  }
#line 123
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/md5.c"
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) 
{ 
  unsigned int count ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 135
  count = (unsigned int )((ctx->bits[0] >> 3) & 63UL);
#line 139
  p = ctx->in + count;
#line 140
  tmp = p;
#line 140
  p ++;
#line 140
  *tmp = (unsigned char)128;
#line 143
  count = 63U - count;
#line 146
  if (count < 8U) {
    {
#line 149
    memset((void *)p, 0, (size_t )count);
#line 151
    MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 154
    memset((void *)(ctx->in), 0, (size_t )56);
    }
  } else {
    {
#line 159
    memset((void *)p, 0, (size_t )(count - 8U));
    }
  }
  {
#line 164
  memcpy((void */* __restrict  */)(ctx->in + 14UL * sizeof(uint32 )), (void const   */* __restrict  */)(ctx->bits),
         sizeof(ctx->bits));
#line 166
  MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 168
  memcpy((void */* __restrict  */)digest, (void const   */* __restrict  */)(ctx->buf),
         (size_t )16);
#line 169
  memset((void *)ctx, 0, sizeof(ctx));
  }
#line 170
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/md5.c"
void MD5Transform(uint32 *buf , uint32 const   *in ) 
{ 
  register uint32 a ;
  register uint32 b ;
  register uint32 c ;
  register uint32 d ;

  {
#line 195
  a = *(buf + 0);
#line 196
  b = *(buf + 1);
#line 197
  c = *(buf + 2);
#line 198
  d = *(buf + 3);
#line 200
  a += ((d ^ (b & (c ^ d))) + (unsigned long )*(in + 0)) + 3614090360UL;
#line 200
  a = (a << 7) | (a >> 25);
#line 200
  a += b;
#line 201
  d += ((c ^ (a & (b ^ c))) + (unsigned long )*(in + 1)) + 3905402710UL;
#line 201
  d = (d << 12) | (d >> 20);
#line 201
  d += a;
#line 202
  c += ((b ^ (d & (a ^ b))) + (unsigned long )*(in + 2)) + 606105819UL;
#line 202
  c = (c << 17) | (c >> 15);
#line 202
  c += d;
#line 203
  b += ((a ^ (c & (d ^ a))) + (unsigned long )*(in + 3)) + 3250441966UL;
#line 203
  b = (b << 22) | (b >> 10);
#line 203
  b += c;
#line 204
  a += ((d ^ (b & (c ^ d))) + (unsigned long )*(in + 4)) + 4118548399UL;
#line 204
  a = (a << 7) | (a >> 25);
#line 204
  a += b;
#line 205
  d += ((c ^ (a & (b ^ c))) + (unsigned long )*(in + 5)) + 1200080426UL;
#line 205
  d = (d << 12) | (d >> 20);
#line 205
  d += a;
#line 206
  c += ((b ^ (d & (a ^ b))) + (unsigned long )*(in + 6)) + 2821735955UL;
#line 206
  c = (c << 17) | (c >> 15);
#line 206
  c += d;
#line 207
  b += ((a ^ (c & (d ^ a))) + (unsigned long )*(in + 7)) + 4249261313UL;
#line 207
  b = (b << 22) | (b >> 10);
#line 207
  b += c;
#line 208
  a += ((d ^ (b & (c ^ d))) + (unsigned long )*(in + 8)) + 1770035416UL;
#line 208
  a = (a << 7) | (a >> 25);
#line 208
  a += b;
#line 209
  d += ((c ^ (a & (b ^ c))) + (unsigned long )*(in + 9)) + 2336552879UL;
#line 209
  d = (d << 12) | (d >> 20);
#line 209
  d += a;
#line 210
  c += ((b ^ (d & (a ^ b))) + (unsigned long )*(in + 10)) + 4294925233UL;
#line 210
  c = (c << 17) | (c >> 15);
#line 210
  c += d;
#line 211
  b += ((a ^ (c & (d ^ a))) + (unsigned long )*(in + 11)) + 2304563134UL;
#line 211
  b = (b << 22) | (b >> 10);
#line 211
  b += c;
#line 212
  a += ((d ^ (b & (c ^ d))) + (unsigned long )*(in + 12)) + 1804603682UL;
#line 212
  a = (a << 7) | (a >> 25);
#line 212
  a += b;
#line 213
  d += ((c ^ (a & (b ^ c))) + (unsigned long )*(in + 13)) + 4254626195UL;
#line 213
  d = (d << 12) | (d >> 20);
#line 213
  d += a;
#line 214
  c += ((b ^ (d & (a ^ b))) + (unsigned long )*(in + 14)) + 2792965006UL;
#line 214
  c = (c << 17) | (c >> 15);
#line 214
  c += d;
#line 215
  b += ((a ^ (c & (d ^ a))) + (unsigned long )*(in + 15)) + 1236535329UL;
#line 215
  b = (b << 22) | (b >> 10);
#line 215
  b += c;
#line 217
  a += ((c ^ (d & (b ^ c))) + (unsigned long )*(in + 1)) + 4129170786UL;
#line 217
  a = (a << 5) | (a >> 27);
#line 217
  a += b;
#line 218
  d += ((b ^ (c & (a ^ b))) + (unsigned long )*(in + 6)) + 3225465664UL;
#line 218
  d = (d << 9) | (d >> 23);
#line 218
  d += a;
#line 219
  c += ((a ^ (b & (d ^ a))) + (unsigned long )*(in + 11)) + 643717713UL;
#line 219
  c = (c << 14) | (c >> 18);
#line 219
  c += d;
#line 220
  b += ((d ^ (a & (c ^ d))) + (unsigned long )*(in + 0)) + 3921069994UL;
#line 220
  b = (b << 20) | (b >> 12);
#line 220
  b += c;
#line 221
  a += ((c ^ (d & (b ^ c))) + (unsigned long )*(in + 5)) + 3593408605UL;
#line 221
  a = (a << 5) | (a >> 27);
#line 221
  a += b;
#line 222
  d += ((b ^ (c & (a ^ b))) + (unsigned long )*(in + 10)) + 38016083UL;
#line 222
  d = (d << 9) | (d >> 23);
#line 222
  d += a;
#line 223
  c += ((a ^ (b & (d ^ a))) + (unsigned long )*(in + 15)) + 3634488961UL;
#line 223
  c = (c << 14) | (c >> 18);
#line 223
  c += d;
#line 224
  b += ((d ^ (a & (c ^ d))) + (unsigned long )*(in + 4)) + 3889429448UL;
#line 224
  b = (b << 20) | (b >> 12);
#line 224
  b += c;
#line 225
  a += ((c ^ (d & (b ^ c))) + (unsigned long )*(in + 9)) + 568446438UL;
#line 225
  a = (a << 5) | (a >> 27);
#line 225
  a += b;
#line 226
  d += ((b ^ (c & (a ^ b))) + (unsigned long )*(in + 14)) + 3275163606UL;
#line 226
  d = (d << 9) | (d >> 23);
#line 226
  d += a;
#line 227
  c += ((a ^ (b & (d ^ a))) + (unsigned long )*(in + 3)) + 4107603335UL;
#line 227
  c = (c << 14) | (c >> 18);
#line 227
  c += d;
#line 228
  b += ((d ^ (a & (c ^ d))) + (unsigned long )*(in + 8)) + 1163531501UL;
#line 228
  b = (b << 20) | (b >> 12);
#line 228
  b += c;
#line 229
  a += ((c ^ (d & (b ^ c))) + (unsigned long )*(in + 13)) + 2850285829UL;
#line 229
  a = (a << 5) | (a >> 27);
#line 229
  a += b;
#line 230
  d += ((b ^ (c & (a ^ b))) + (unsigned long )*(in + 2)) + 4243563512UL;
#line 230
  d = (d << 9) | (d >> 23);
#line 230
  d += a;
#line 231
  c += ((a ^ (b & (d ^ a))) + (unsigned long )*(in + 7)) + 1735328473UL;
#line 231
  c = (c << 14) | (c >> 18);
#line 231
  c += d;
#line 232
  b += ((d ^ (a & (c ^ d))) + (unsigned long )*(in + 12)) + 2368359562UL;
#line 232
  b = (b << 20) | (b >> 12);
#line 232
  b += c;
#line 234
  a += (((b ^ c) ^ d) + (unsigned long )*(in + 5)) + 4294588738UL;
#line 234
  a = (a << 4) | (a >> 28);
#line 234
  a += b;
#line 235
  d += (((a ^ b) ^ c) + (unsigned long )*(in + 8)) + 2272392833UL;
#line 235
  d = (d << 11) | (d >> 21);
#line 235
  d += a;
#line 236
  c += (((d ^ a) ^ b) + (unsigned long )*(in + 11)) + 1839030562UL;
#line 236
  c = (c << 16) | (c >> 16);
#line 236
  c += d;
#line 237
  b += (((c ^ d) ^ a) + (unsigned long )*(in + 14)) + 4259657740UL;
#line 237
  b = (b << 23) | (b >> 9);
#line 237
  b += c;
#line 238
  a += (((b ^ c) ^ d) + (unsigned long )*(in + 1)) + 2763975236UL;
#line 238
  a = (a << 4) | (a >> 28);
#line 238
  a += b;
#line 239
  d += (((a ^ b) ^ c) + (unsigned long )*(in + 4)) + 1272893353UL;
#line 239
  d = (d << 11) | (d >> 21);
#line 239
  d += a;
#line 240
  c += (((d ^ a) ^ b) + (unsigned long )*(in + 7)) + 4139469664UL;
#line 240
  c = (c << 16) | (c >> 16);
#line 240
  c += d;
#line 241
  b += (((c ^ d) ^ a) + (unsigned long )*(in + 10)) + 3200236656UL;
#line 241
  b = (b << 23) | (b >> 9);
#line 241
  b += c;
#line 242
  a += (((b ^ c) ^ d) + (unsigned long )*(in + 13)) + 681279174UL;
#line 242
  a = (a << 4) | (a >> 28);
#line 242
  a += b;
#line 243
  d += (((a ^ b) ^ c) + (unsigned long )*(in + 0)) + 3936430074UL;
#line 243
  d = (d << 11) | (d >> 21);
#line 243
  d += a;
#line 244
  c += (((d ^ a) ^ b) + (unsigned long )*(in + 3)) + 3572445317UL;
#line 244
  c = (c << 16) | (c >> 16);
#line 244
  c += d;
#line 245
  b += (((c ^ d) ^ a) + (unsigned long )*(in + 6)) + 76029189UL;
#line 245
  b = (b << 23) | (b >> 9);
#line 245
  b += c;
#line 246
  a += (((b ^ c) ^ d) + (unsigned long )*(in + 9)) + 3654602809UL;
#line 246
  a = (a << 4) | (a >> 28);
#line 246
  a += b;
#line 247
  d += (((a ^ b) ^ c) + (unsigned long )*(in + 12)) + 3873151461UL;
#line 247
  d = (d << 11) | (d >> 21);
#line 247
  d += a;
#line 248
  c += (((d ^ a) ^ b) + (unsigned long )*(in + 15)) + 530742520UL;
#line 248
  c = (c << 16) | (c >> 16);
#line 248
  c += d;
#line 249
  b += (((c ^ d) ^ a) + (unsigned long )*(in + 2)) + 3299628645UL;
#line 249
  b = (b << 23) | (b >> 9);
#line 249
  b += c;
#line 251
  a += ((c ^ (b | ~ d)) + (unsigned long )*(in + 0)) + 4096336452UL;
#line 251
  a = (a << 6) | (a >> 26);
#line 251
  a += b;
#line 252
  d += ((b ^ (a | ~ c)) + (unsigned long )*(in + 7)) + 1126891415UL;
#line 252
  d = (d << 10) | (d >> 22);
#line 252
  d += a;
#line 253
  c += ((a ^ (d | ~ b)) + (unsigned long )*(in + 14)) + 2878612391UL;
#line 253
  c = (c << 15) | (c >> 17);
#line 253
  c += d;
#line 254
  b += ((d ^ (c | ~ a)) + (unsigned long )*(in + 5)) + 4237533241UL;
#line 254
  b = (b << 21) | (b >> 11);
#line 254
  b += c;
#line 255
  a += ((c ^ (b | ~ d)) + (unsigned long )*(in + 12)) + 1700485571UL;
#line 255
  a = (a << 6) | (a >> 26);
#line 255
  a += b;
#line 256
  d += ((b ^ (a | ~ c)) + (unsigned long )*(in + 3)) + 2399980690UL;
#line 256
  d = (d << 10) | (d >> 22);
#line 256
  d += a;
#line 257
  c += ((a ^ (d | ~ b)) + (unsigned long )*(in + 10)) + 4293915773UL;
#line 257
  c = (c << 15) | (c >> 17);
#line 257
  c += d;
#line 258
  b += ((d ^ (c | ~ a)) + (unsigned long )*(in + 1)) + 2240044497UL;
#line 258
  b = (b << 21) | (b >> 11);
#line 258
  b += c;
#line 259
  a += ((c ^ (b | ~ d)) + (unsigned long )*(in + 8)) + 1873313359UL;
#line 259
  a = (a << 6) | (a >> 26);
#line 259
  a += b;
#line 260
  d += ((b ^ (a | ~ c)) + (unsigned long )*(in + 15)) + 4264355552UL;
#line 260
  d = (d << 10) | (d >> 22);
#line 260
  d += a;
#line 261
  c += ((a ^ (d | ~ b)) + (unsigned long )*(in + 6)) + 2734768916UL;
#line 261
  c = (c << 15) | (c >> 17);
#line 261
  c += d;
#line 262
  b += ((d ^ (c | ~ a)) + (unsigned long )*(in + 13)) + 1309151649UL;
#line 262
  b = (b << 21) | (b >> 11);
#line 262
  b += c;
#line 263
  a += ((c ^ (b | ~ d)) + (unsigned long )*(in + 4)) + 4149444226UL;
#line 263
  a = (a << 6) | (a >> 26);
#line 263
  a += b;
#line 264
  d += ((b ^ (a | ~ c)) + (unsigned long )*(in + 11)) + 3174756917UL;
#line 264
  d = (d << 10) | (d >> 22);
#line 264
  d += a;
#line 265
  c += ((a ^ (d | ~ b)) + (unsigned long )*(in + 2)) + 718787259UL;
#line 265
  c = (c << 15) | (c >> 17);
#line 265
  c += d;
#line 266
  b += ((d ^ (c | ~ a)) + (unsigned long )*(in + 9)) + 3951481745UL;
#line 266
  b = (b << 21) | (b >> 11);
#line 266
  b += c;
#line 268
  *(buf + 0) += a;
#line 269
  *(buf + 1) += b;
#line 270
  *(buf + 2) += c;
#line 271
  *(buf + 3) += d;
#line 272
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.h"
int handle_avps(struct buffer *buf , struct tunnel *t , struct call *c ) ;
#line 40
char *msgtypes[17] ;
#line 88
int decrypt_avp(char *buf , struct tunnel *t ) ;
#line 89
int message_type_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 90
int protocol_version_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 91
int framing_caps_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 92
int bearer_caps_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 93
int firmware_rev_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 94
int hostname_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 95
int vendor_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 96
int assigned_tunnel_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 97
int receive_window_size_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 99
int result_code_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 100
int assigned_call_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 101
int call_serno_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 102
int bearer_type_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 103
int call_physchan_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 104
int dialed_number_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 105
int dialing_number_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 106
int sub_address_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 107
int frame_type_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 108
int rx_speed_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 109
int tx_speed_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 110
int packet_delay_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 111
int ignore_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 112
int seq_reqd_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 113
int challenge_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 114
int chalresp_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 115
int rand_vector_avp(struct tunnel *t , struct call *c , void *data , int datalen ) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
struct avp avps[40]  = 
#line 23 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
  {      {0, 1, & message_type_avp, (char *)"Message Type"}, 
        {1, 1, & result_code_avp, (char *)"Result Code"}, 
        {2, 1, & protocol_version_avp, (char *)"Protocol Version"}, 
        {3, 1, & framing_caps_avp, (char *)"Framing Capabilities"}, 
        {4, 1, & bearer_caps_avp, (char *)"Bearer Capabilities"}, 
        {5, 0, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Tie Breaker"}, 
        {6, 0, & firmware_rev_avp, (char *)"Firmware Revision"}, 
        {7, 0, & hostname_avp, (char *)"Host Name"}, 
        {8, 1, & vendor_avp, (char *)"Vendor Name"}, 
        {9, 1, & assigned_tunnel_avp, (char *)"Assigned Tunnel ID"}, 
        {10, 1, & receive_window_size_avp, (char *)"Receive Window Size"}, 
        {11, 1, & challenge_avp, (char *)"Challenge"}, 
        {12, 0, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Q.931 Cause Code"}, 
        {13, 1, & chalresp_avp, (char *)"Challenge Response"}, 
        {14, 1, & assigned_call_avp, (char *)"Assigned Call ID"}, 
        {15, 1, & call_serno_avp, (char *)"Call Serial Number"}, 
        {16, 1, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Minimum BPS"}, 
        {17, 1, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Maximum BPS"}, 
        {18, 1, & bearer_type_avp, (char *)"Bearer Type"}, 
        {19, 1, & frame_type_avp, (char *)"Framing Type"}, 
        {20, 1, & packet_delay_avp, (char *)"Packet Processing Delay"}, 
        {21, 1, & dialed_number_avp, (char *)"Dialed Number"}, 
        {22, 1, & dialing_number_avp, (char *)"Dialing Number"}, 
        {23, 1, & sub_address_avp, (char *)"Sub-Address"}, 
        {24, 1, & tx_speed_avp, (char *)"Transmit Connect Speed"}, 
        {25, 1, & call_physchan_avp, (char *)"Physical channel ID"}, 
        {26, 0, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Initial Received LCP Confreq"}, 
        {27, 0, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Last Sent LCP Confreq"}, 
        {28, 0, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Last Received LCP Confreq"}, 
        {29, 1, & ignore_avp, (char *)"Proxy Authen Type"}, 
        {30, 0, & ignore_avp, (char *)"Proxy Authen Name"}, 
        {31, 0, & ignore_avp, (char *)"Proxy Authen Challenge"}, 
        {32, 0, & ignore_avp, (char *)"Proxy Authen ID"}, 
        {33, 1, & ignore_avp, (char *)"Proxy Authen Response"}, 
        {34, 1, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Call Errors"}, 
        {35, 1, & ignore_avp, (char *)"ACCM"}, 
        {36, 1, & rand_vector_avp, (char *)"Random Vector"}, 
        {37, 1, (int (*)(struct tunnel * , struct call * , void * , int  ))((void *)0),
      (char *)"Private Group ID"}, 
        {38, 0, & rx_speed_avp, (char *)"Receive Connect Speed"}, 
        {39, 1, & seq_reqd_avp, (char *)"Sequencing Required"}};
#line 67 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
char *msgtypes[17]  = 
#line 67
  {      (char *)((void *)0),      (char *)"Start-Control-Connection-Request",      (char *)"Start-Control-Connection-Reply",      (char *)"Start-Control-Connection-Connected", 
        (char *)"Stop-Control-Connection-Notification",      (char *)((void *)0),      (char *)"Hello",      (char *)"Outgoing-Call-Request", 
        (char *)"Outgoing-Call-Reply",      (char *)"Outgoing-Call-Connected",      (char *)"Incoming-Call-Request",      (char *)"Incoming-Call-Reply", 
        (char *)"Incoming-Call-Connected",      (char *)((void *)0),      (char *)"Call-Disconnect-Notify",      (char *)"WAN-Error-Notify", 
        (char *)"Set-Link-Info"};
#line 87 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
char *stopccn_result_codes[8]  = 
#line 87
  {      (char *)"Reserved",      (char *)"General request to clear control connection",      (char *)"General error--Error Code indicates the problem",      (char *)"Control channel already exists", 
        (char *)"Requester is not authorized to establish a control channel",      (char *)"The protocol version of the requester is not supported--Error Code indicates the highest version supported",      (char *)"Requester is being shut down",      (char *)"Finite State Machine error"};
#line 98 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
char *cdn_result_codes[11]  = 
#line 98
  {      (char *)"Reserved",      (char *)"Call disconnected due to loss of carrier",      (char *)"Call disconnected for the reason indicated in error code",      (char *)"Call disconnected for administrative reasons", 
        (char *)"Call failed due to lack of appropriate facilities being available (temporary condition)",      (char *)"Call failed due to lack of appropriate facilities being available (permanent condition)",      (char *)"Invalid destination",      (char *)"Call failed due to no carrier detected", 
        (char *)"Call failed due to lack of a dial tone",      (char *)"Call was no established within time allotted by LAC",      (char *)"Call was connected but no appropriate framing was detect"};
#line 112 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
void wrong_length(struct call *c , char *field , int expected , int found , int min ) 
{ 


  {
#line 115
  if (min) {
    {
#line 116
    snprintf((char */* __restrict  */)(c->errormsg), sizeof(c->errormsg), (char const   */* __restrict  */)"%s: expected at least %d, got %d",
             field, expected, found);
    }
  } else {
    {
#line 119
    snprintf((char */* __restrict  */)(c->errormsg), sizeof(c->errormsg), (char const   */* __restrict  */)"%s: expected %d, got %d",
             field, expected, found);
    }
  }
#line 122
  c->error = 2;
#line 123
  c->result = 2;
#line 124
  c->needclose = -1;
#line 125
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int message_type_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  struct call *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
  {
#line 144
  raw = (struct unaligned_u16 *)data;
#line 145
  tmp = ntohs((raw + 3)->s);
#line 145
  c->msgtype = (int )tmp;
  }
#line 146
  if (datalen != 8) {
#line 148
    if (c) {
#line 148
      if (c->debug) {
#line 148
        tmp___0 = 1;
      } else
#line 148
      if (t->debug) {
#line 148
        tmp___0 = 1;
      } else {
#line 148
        tmp___0 = 0;
      }
#line 148
      tmp___1 = tmp___0;
    } else {
#line 148
      tmp___1 = t->debug;
    }
#line 148
    if (tmp___1) {
      {
#line 149
      l2tp_log(7, "%s: wrong size (%d != 8)\n", "message_type_avp", datalen);
      }
    }
    {
#line 151
    wrong_length(c, (char *)"Message Type", 8, datalen, 0);
    }
#line 152
    return (-22);
  }
#line 154
  if (c->msgtype > 16) {
#line 154
    goto _L;
  } else
#line 154
  if (! msgtypes[c->msgtype]) {
    _L: /* CIL Label */ 
#line 156
    if (c) {
#line 156
      if (c->debug) {
#line 156
        tmp___2 = 1;
      } else
#line 156
      if (t->debug) {
#line 156
        tmp___2 = 1;
      } else {
#line 156
        tmp___2 = 0;
      }
#line 156
      tmp___3 = tmp___2;
    } else {
#line 156
      tmp___3 = t->debug;
    }
#line 156
    if (tmp___3) {
      {
#line 157
      l2tp_log(7, "%s: unknown message type %d\n", "message_type_avp", c->msgtype);
      }
    }
#line 159
    return (-22);
  }
#line 161
  if (gconfig.debug_avp) {
#line 162
    if (c) {
#line 162
      if (c->debug) {
#line 162
        tmp___4 = 1;
      } else
#line 162
      if (t->debug) {
#line 162
        tmp___4 = 1;
      } else {
#line 162
        tmp___4 = 0;
      }
#line 162
      tmp___5 = tmp___4;
    } else {
#line 162
      tmp___5 = t->debug;
    }
#line 162
    if (tmp___5) {
      {
#line 163
      l2tp_log(7, "%s: message type %d (%s)\n", "message_type_avp", c->msgtype, msgtypes[c->msgtype]);
      }
    }
  }
#line 166
  if (t->sanity) {
#line 172
    if ((unsigned long )c != (unsigned long )t->self) {
#line 172
      if (c->msgtype < 6) {
#line 174
        if (c) {
#line 174
          if (c->debug) {
#line 174
            tmp___6 = 1;
          } else
#line 174
          if (t->debug) {
#line 174
            tmp___6 = 1;
          } else {
#line 174
            tmp___6 = 0;
          }
#line 174
          tmp___7 = tmp___6;
        } else {
#line 174
          tmp___7 = t->debug;
        }
#line 174
        if (tmp___7) {
          {
#line 175
          l2tp_log(7, "%s: attempting to negotiate tunnel inside a call!\n", "message_type_avp");
          }
        }
#line 178
        return (-22);
      }
    }
    {
#line 183
    if (c->msgtype == 1) {
#line 183
      goto case_1;
    }
#line 198
    if (c->msgtype == 2) {
#line 198
      goto case_2;
    }
#line 208
    if (c->msgtype == 3) {
#line 208
      goto case_3;
    }
#line 218
    if (c->msgtype == 10) {
#line 218
      goto case_10;
    }
#line 236
    if (c->msgtype == 11) {
#line 236
      goto case_11;
    }
#line 254
    if (c->msgtype == 12) {
#line 254
      goto case_12;
    }
#line 264
    if (c->msgtype == 16) {
#line 264
      goto case_16;
    }
#line 274
    if (c->msgtype == 8) {
#line 274
      goto case_8;
    }
#line 292
    if (c->msgtype == 9) {
#line 292
      goto case_9;
    }
#line 305
    if (c->msgtype == 6) {
#line 305
      goto case_6;
    }
#line 305
    if (c->msgtype == 14) {
#line 305
      goto case_6;
    }
#line 305
    if (c->msgtype == 4) {
#line 305
      goto case_6;
    }
#line 307
    goto switch_default;
    case_1: /* CIL Label */ 
#line 184
    if (t->state != 0) {
#line 184
      if (t->state != 1) {
#line 191
        if (c) {
#line 191
          if (c->debug) {
#line 191
            tmp___8 = 1;
          } else
#line 191
          if (t->debug) {
#line 191
            tmp___8 = 1;
          } else {
#line 191
            tmp___8 = 0;
          }
#line 191
          tmp___9 = tmp___8;
        } else {
#line 191
          tmp___9 = t->debug;
        }
#line 191
        if (tmp___9) {
          {
#line 192
          l2tp_log(7, "%s: attempting to negotiate SCCRQ with state != 0\n", "message_type_avp");
          }
        }
#line 195
        return (-22);
      }
    }
#line 197
    goto switch_break;
    case_2: /* CIL Label */ 
#line 199
    if (t->state != 1) {
#line 201
      if (c) {
#line 201
        if (c->debug) {
#line 201
          tmp___10 = 1;
        } else
#line 201
        if (t->debug) {
#line 201
          tmp___10 = 1;
        } else {
#line 201
          tmp___10 = 0;
        }
#line 201
        tmp___11 = tmp___10;
      } else {
#line 201
        tmp___11 = t->debug;
      }
#line 201
      if (tmp___11) {
        {
#line 202
        l2tp_log(7, "%s: attempting to negotiate SCCRP with state != SCCRQ!\n", "message_type_avp");
        }
      }
#line 205
      return (-22);
    }
#line 207
    goto switch_break;
    case_3: /* CIL Label */ 
#line 209
    if (t->state != 2) {
#line 211
      if (c) {
#line 211
        if (c->debug) {
#line 211
          tmp___12 = 1;
        } else
#line 211
        if (t->debug) {
#line 211
          tmp___12 = 1;
        } else {
#line 211
          tmp___12 = 0;
        }
#line 211
        tmp___13 = tmp___12;
      } else {
#line 211
        tmp___13 = t->debug;
      }
#line 211
      if (tmp___13) {
        {
#line 212
        l2tp_log(7, "%s: attempting to negotiate SCCCN with state != SCCRP!\n", "message_type_avp");
        }
      }
#line 215
      return (-22);
    }
#line 217
    goto switch_break;
    case_10: /* CIL Label */ 
#line 219
    if (t->state != 3) {
#line 221
      if (c) {
#line 221
        if (c->debug) {
#line 221
          tmp___14 = 1;
        } else
#line 221
        if (t->debug) {
#line 221
          tmp___14 = 1;
        } else {
#line 221
          tmp___14 = 0;
        }
#line 221
        tmp___15 = tmp___14;
      } else {
#line 221
        tmp___15 = t->debug;
      }
#line 221
      if (tmp___15) {
        {
#line 222
        l2tp_log(7, "%s: attempting to negotiate ICRQ when state != SCCCN\n", "message_type_avp");
        }
      }
#line 225
      return (-22);
    }
#line 227
    if ((unsigned long )c != (unsigned long )t->self) {
#line 229
      if (c) {
#line 229
        if (c->debug) {
#line 229
          tmp___16 = 1;
        } else
#line 229
        if (t->debug) {
#line 229
          tmp___16 = 1;
        } else {
#line 229
          tmp___16 = 0;
        }
#line 229
        tmp___17 = tmp___16;
      } else {
#line 229
        tmp___17 = t->debug;
      }
#line 229
      if (tmp___17) {
        {
#line 230
        l2tp_log(7, "%s: attempting to negotiate ICRQ on a call!\n", "message_type_avp");
        }
      }
#line 233
      return (-22);
    }
#line 235
    goto switch_break;
    case_11: /* CIL Label */ 
#line 237
    if (t->state != 3) {
#line 239
      if (c) {
#line 239
        if (c->debug) {
#line 239
          tmp___18 = 1;
        } else
#line 239
        if (t->debug) {
#line 239
          tmp___18 = 1;
        } else {
#line 239
          tmp___18 = 0;
        }
#line 239
        tmp___19 = tmp___18;
      } else {
#line 239
        tmp___19 = t->debug;
      }
#line 239
      if (tmp___19) {
        {
#line 240
        l2tp_log(7, "%s: attempting to negotiate ICRP on tunnel!=SCCCN\n", "message_type_avp");
        }
      }
#line 243
      return (-22);
    }
#line 245
    if (c->state != 10) {
#line 247
      if (c) {
#line 247
        if (c->debug) {
#line 247
          tmp___20 = 1;
        } else
#line 247
        if (t->debug) {
#line 247
          tmp___20 = 1;
        } else {
#line 247
          tmp___20 = 0;
        }
#line 247
        tmp___21 = tmp___20;
      } else {
#line 247
        tmp___21 = t->debug;
      }
#line 247
      if (tmp___21) {
        {
#line 248
        l2tp_log(7, "%s: attempting to negotiate ICRP when state != ICRQ\n", "message_type_avp");
        }
      }
#line 251
      return (-22);
    }
#line 253
    goto switch_break;
    case_12: /* CIL Label */ 
#line 255
    if (c->state != 11) {
#line 257
      if (c) {
#line 257
        if (c->debug) {
#line 257
          tmp___22 = 1;
        } else
#line 257
        if (t->debug) {
#line 257
          tmp___22 = 1;
        } else {
#line 257
          tmp___22 = 0;
        }
#line 257
        tmp___23 = tmp___22;
      } else {
#line 257
        tmp___23 = t->debug;
      }
#line 257
      if (tmp___23) {
        {
#line 258
        l2tp_log(7, "%s: attempting to negotiate ICCN when state != ICRP\n", "message_type_avp");
        }
      }
#line 261
      return (-22);
    }
#line 263
    goto switch_break;
    case_16: /* CIL Label */ 
#line 265
    if (c->state != 12) {
#line 267
      if (c) {
#line 267
        if (c->debug) {
#line 267
          tmp___24 = 1;
        } else
#line 267
        if (t->debug) {
#line 267
          tmp___24 = 1;
        } else {
#line 267
          tmp___24 = 0;
        }
#line 267
        tmp___25 = tmp___24;
      } else {
#line 267
        tmp___25 = t->debug;
      }
#line 267
      if (tmp___25) {
        {
#line 268
        l2tp_log(7, "%s: attempting to negotiate SLI when state != ICCN\n", "message_type_avp");
        }
      }
#line 271
      return (-22);
    }
#line 273
    goto switch_break;
    case_8: /* CIL Label */ 
#line 275
    if (t->state != 3) {
#line 277
      if (c) {
#line 277
        if (c->debug) {
#line 277
          tmp___26 = 1;
        } else
#line 277
        if (t->debug) {
#line 277
          tmp___26 = 1;
        } else {
#line 277
          tmp___26 = 0;
        }
#line 277
        tmp___27 = tmp___26;
      } else {
#line 277
        tmp___27 = t->debug;
      }
#line 277
      if (tmp___27) {
        {
#line 278
        l2tp_log(7, "%s: attempting to negotiate OCRP on tunnel!=SCCCN\n", "message_type_avp");
        }
      }
#line 281
      return (-22);
    }
#line 283
    if (c->state != 7) {
#line 285
      if (c) {
#line 285
        if (c->debug) {
#line 285
          tmp___28 = 1;
        } else
#line 285
        if (t->debug) {
#line 285
          tmp___28 = 1;
        } else {
#line 285
          tmp___28 = 0;
        }
#line 285
        tmp___29 = tmp___28;
      } else {
#line 285
        tmp___29 = t->debug;
      }
#line 285
      if (tmp___29) {
        {
#line 286
        l2tp_log(7, "%s: attempting to negotiate OCRP when state != OCRQ\n", "message_type_avp");
        }
      }
#line 289
      return (-22);
    }
#line 291
    goto switch_break;
    case_9: /* CIL Label */ 
#line 294
    if (c->state != 7) {
#line 296
      if (c) {
#line 296
        if (c->debug) {
#line 296
          tmp___30 = 1;
        } else
#line 296
        if (t->debug) {
#line 296
          tmp___30 = 1;
        } else {
#line 296
          tmp___30 = 0;
        }
#line 296
        tmp___31 = tmp___30;
      } else {
#line 296
        tmp___31 = t->debug;
      }
#line 296
      if (tmp___31) {
        {
#line 297
        l2tp_log(7, "%s: attempting to negotiate OCCN when state != OCRQ\n", "message_type_avp");
        }
      }
#line 300
      return (-22);
    }
#line 302
    goto switch_break;
    case_6: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 306
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 308
    l2tp_log(4, "%s: i don\'t know how to handle %s messages\n", "message_type_avp",
             msgtypes[c->msgtype]);
    }
#line 310
    return (-22);
    switch_break: /* CIL Label */ ;
    }
  }
#line 314
  if (c->msgtype == 10) {
#line 317
    if (gconfig.debug_avp) {
#line 319
      if (c) {
#line 319
        if (c->debug) {
#line 319
          tmp___33 = 1;
        } else
#line 319
        if (t->debug) {
#line 319
          tmp___33 = 1;
        } else {
#line 319
          tmp___33 = 0;
        }
#line 319
        tmp___34 = tmp___33;
      } else {
#line 319
        tmp___34 = t->debug;
      }
#line 319
      if (tmp___34) {
        {
#line 320
        l2tp_log(7, "%s: new incoming call\n", "message_type_avp");
        }
      }
    }
    {
#line 322
    tmp___32 = new_call(t);
    }
#line 323
    if (! tmp___32) {
      {
#line 325
      l2tp_log(4, "%s: unable to create new call\n", "message_type_avp");
      }
#line 326
      return (-22);
    }
#line 328
    tmp___32->next = t->call_head;
#line 329
    t->call_head = tmp___32;
#line 330
    (t->count) ++;
  }
#line 338
  return (0);
}
}
#line 341 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int rand_vector_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int size ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 345
  raw = (struct unaligned_u16 *)data;
#line 346
  size = (int )(raw + 0)->s & 1023;
#line 347
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 349
  if (t->sanity) {
#line 351
    if (size < 0) {
#line 353
      if (c) {
#line 353
        if (c->debug) {
#line 353
          tmp = 1;
        } else
#line 353
        if (t->debug) {
#line 353
          tmp = 1;
        } else {
#line 353
          tmp = 0;
        }
#line 353
        tmp___0 = tmp;
      } else {
#line 353
        tmp___0 = t->debug;
      }
#line 353
      if (tmp___0) {
        {
#line 354
        l2tp_log(7, "%s: Random vector too small (%d < 0)\n", "rand_vector_avp", size);
        }
      }
      {
#line 356
      wrong_length(c, (char *)"Random Vector", 6, datalen, 1);
      }
#line 357
      return (-22);
    }
#line 359
    if (size > 1024) {
#line 361
      if (c) {
#line 361
        if (c->debug) {
#line 361
          tmp___1 = 1;
        } else
#line 361
        if (t->debug) {
#line 361
          tmp___1 = 1;
        } else {
#line 361
          tmp___1 = 0;
        }
#line 361
        tmp___2 = tmp___1;
      } else {
#line 361
        tmp___2 = t->debug;
      }
#line 361
      if (tmp___2) {
        {
#line 362
        l2tp_log(7, "%s: Random vector too large (%d > %d)\n", "rand_vector_avp",
                 datalen, 1024);
        }
      }
      {
#line 364
      wrong_length(c, (char *)"Random Vector", 6, datalen, 1);
      }
#line 365
      return (-22);
    }
  }
#line 369
  if (gconfig.debug_avp) {
    {
#line 370
    l2tp_log(7, "%s: Random Vector of %d octets\n", "rand_vector_avp", size);
    }
  }
#line 372
  t->chal_us.vector = (unsigned char *)(& (raw + 3)->s);
#line 373
  t->chal_us.vector_len = (unsigned int )size;
#line 374
  return (0);
}
}
#line 377 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int ignore_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 390
  if (gconfig.debug_avp) {
#line 392
    if (c) {
#line 392
      if (c->debug) {
#line 392
        tmp = 1;
      } else
#line 392
      if (t->debug) {
#line 392
        tmp = 1;
      } else {
#line 392
        tmp = 0;
      }
#line 392
      tmp___0 = tmp;
    } else {
#line 392
      tmp___0 = t->debug;
    }
#line 392
    if (tmp___0) {
      {
#line 393
      l2tp_log(7, "%s : Ignoring AVP\n", "ignore_avp");
      }
    }
  }
#line 395
  return (0);
}
}
#line 398 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int seq_reqd_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 401
  if (t->sanity) {
#line 403
    if (datalen != 6) {
#line 405
      if (c) {
#line 405
        if (c->debug) {
#line 405
          tmp = 1;
        } else
#line 405
        if (t->debug) {
#line 405
          tmp = 1;
        } else {
#line 405
          tmp = 0;
        }
#line 405
        tmp___0 = tmp;
      } else {
#line 405
        tmp___0 = t->debug;
      }
#line 405
      if (tmp___0) {
        {
#line 406
        l2tp_log(7, "%s: avp is incorrect size.  %d != 6\n", "seq_reqd_avp", datalen);
        }
      }
      {
#line 409
      wrong_length(c, (char *)"Sequencing Required", 6, datalen, 1);
      }
#line 410
      return (-22);
    }
    {
#line 414
    if (c->msgtype == 12) {
#line 414
      goto case_12;
    }
#line 416
    goto switch_default;
    case_12: /* CIL Label */ 
#line 415
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 417
    if (c) {
#line 417
      if (c->debug) {
#line 417
        tmp___1 = 1;
      } else
#line 417
      if (t->debug) {
#line 417
        tmp___1 = 1;
      } else {
#line 417
        tmp___1 = 0;
      }
#line 417
      tmp___2 = tmp___1;
    } else {
#line 417
      tmp___2 = t->debug;
    }
#line 417
    if (tmp___2) {
      {
#line 418
      l2tp_log(7, "%s: sequencing required not appropriate for %s!\n", "seq_reqd_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 421
    return (-22);
    switch_break: /* CIL Label */ ;
    }
  }
#line 425
  if (gconfig.debug_avp) {
#line 427
    if (c) {
#line 427
      if (c->debug) {
#line 427
        tmp___3 = 1;
      } else
#line 427
      if (t->debug) {
#line 427
        tmp___3 = 1;
      } else {
#line 427
        tmp___3 = 0;
      }
#line 427
      tmp___4 = tmp___3;
    } else {
#line 427
      tmp___4 = t->debug;
    }
#line 427
    if (tmp___4) {
      {
#line 428
      l2tp_log(7, "%s: peer requires sequencing.\n", "seq_reqd_avp");
      }
    }
  }
#line 430
  c->seq_reqd = -1;
#line 431
  return (0);
}
}
#line 434 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int result_code_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int error ;
  int result ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 444
  raw = (struct unaligned_u16 *)data;
#line 446
  if (t->sanity) {
#line 448
    if (datalen < 10) {
#line 450
      if (c) {
#line 450
        if (c->debug) {
#line 450
          tmp = 1;
        } else
#line 450
        if (t->debug) {
#line 450
          tmp = 1;
        } else {
#line 450
          tmp = 0;
        }
#line 450
        tmp___0 = tmp;
      } else {
#line 450
        tmp___0 = t->debug;
      }
#line 450
      if (tmp___0) {
        {
#line 451
        l2tp_log(7, "%s: avp is incorrect size.  %d < 10\n", "result_code_avp", datalen);
        }
      }
      {
#line 454
      wrong_length(c, (char *)"Result Code", 10, datalen, 1);
      }
#line 455
      return (-22);
    }
    {
#line 460
    if (c->msgtype == 4) {
#line 460
      goto case_4;
    }
#line 460
    if (c->msgtype == 14) {
#line 460
      goto case_4;
    }
#line 462
    goto switch_default;
    case_4: /* CIL Label */ 
    case_14: /* CIL Label */ 
#line 461
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 463
    if (c) {
#line 463
      if (c->debug) {
#line 463
        tmp___1 = 1;
      } else
#line 463
      if (t->debug) {
#line 463
        tmp___1 = 1;
      } else {
#line 463
        tmp___1 = 0;
      }
#line 463
      tmp___2 = tmp___1;
    } else {
#line 463
      tmp___2 = t->debug;
    }
#line 463
    if (tmp___2) {
      {
#line 464
      l2tp_log(7, "%s: result code not appropriate for %s.  Ignoring.\n", "result_code_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 467
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 471
  tmp___3 = ntohs((raw + 3)->s);
#line 471
  result = (int )tmp___3;
#line 472
  tmp___4 = ntohs((raw + 4)->s);
#line 472
  error = (int )tmp___4;
  }
#line 478
  if ((result & 255) == 0) {
#line 478
    if (result >> 8 != 0) {
#line 480
      if (c) {
#line 480
        if (c->debug) {
#line 480
          tmp___5 = 1;
        } else
#line 480
        if (t->debug) {
#line 480
          tmp___5 = 1;
        } else {
#line 480
          tmp___5 = 0;
        }
#line 480
        tmp___6 = tmp___5;
      } else {
#line 480
        tmp___6 = t->debug;
      }
#line 480
      if (tmp___6) {
        {
#line 481
        l2tp_log(7, "%s: result code endianness fix for buggy Apple client. network=%d, le=%d\n",
                 "result_code_avp", result, result >> 8);
        }
      }
#line 484
      result >>= 8;
    }
  }
#line 487
  if ((error & 255) == 0) {
#line 487
    if (error >> 8 != 0) {
#line 489
      if (c) {
#line 489
        if (c->debug) {
#line 489
          tmp___7 = 1;
        } else
#line 489
        if (t->debug) {
#line 489
          tmp___7 = 1;
        } else {
#line 489
          tmp___7 = 0;
        }
#line 489
        tmp___8 = tmp___7;
      } else {
#line 489
        tmp___8 = t->debug;
      }
#line 489
      if (tmp___8) {
        {
#line 490
        l2tp_log(7, "%s: error code endianness fix for buggy Apple client. network=%d, le=%d\n",
                 "result_code_avp", error, error >> 8);
        }
      }
#line 493
      error >>= 8;
    }
  }
#line 496
  if (c->msgtype == 4) {
#line 496
    if (result > 7) {
#line 496
      goto _L;
    } else
#line 496
    if (result < 1) {
      _L: /* CIL Label */ 
#line 498
      if (c) {
#line 498
        if (c->debug) {
#line 498
          tmp___9 = 1;
        } else
#line 498
        if (t->debug) {
#line 498
          tmp___9 = 1;
        } else {
#line 498
          tmp___9 = 0;
        }
#line 498
        tmp___10 = tmp___9;
      } else {
#line 498
        tmp___10 = t->debug;
      }
#line 498
      if (tmp___10) {
        {
#line 499
        l2tp_log(7, "%s: result code out of range (%d %d %d).  Ignoring.\n", "result_code_avp",
                 result, error, datalen);
        }
      }
#line 502
      return (0);
    }
  }
#line 505
  if (c->msgtype == 14) {
#line 505
    if (result > 11) {
#line 505
      goto _L___0;
    } else
#line 505
    if (result < 1) {
      _L___0: /* CIL Label */ 
#line 507
      if (c) {
#line 507
        if (c->debug) {
#line 507
          tmp___11 = 1;
        } else
#line 507
        if (t->debug) {
#line 507
          tmp___11 = 1;
        } else {
#line 507
          tmp___11 = 0;
        }
#line 507
        tmp___12 = tmp___11;
      } else {
#line 507
        tmp___12 = t->debug;
      }
#line 507
      if (tmp___12) {
        {
#line 508
        l2tp_log(7, "%s: result code out of range (%d %d %d).  Ignoring.\n", "result_code_avp",
                 result, error, datalen);
        }
      }
#line 511
      return (0);
    }
  }
  {
#line 514
  c->error = error;
#line 515
  c->result = result;
#line 516
  safe_copy(c->errormsg, (char *)(& (raw + 5)->s), datalen - 10);
  }
#line 517
  if (gconfig.debug_avp) {
#line 519
    if (c) {
#line 519
      if (c->debug) {
#line 519
        tmp___13 = 1;
      } else
#line 519
      if (t->debug) {
#line 519
        tmp___13 = 1;
      } else {
#line 519
        tmp___13 = 0;
      }
#line 519
      tmp___15 = tmp___13;
    } else {
#line 519
      if (t->debug) {
#line 519
        if (c->msgtype == 4) {
#line 519
          tmp___14 = 1;
        } else {
#line 519
          tmp___14 = 0;
        }
      } else {
#line 519
        tmp___14 = 0;
      }
#line 519
      tmp___15 = tmp___14;
    }
#line 519
    if (tmp___15) {
      {
#line 521
      l2tp_log(7, "%s: peer closing for reason %d (%s), error = %d (%s)\n", "result_code_avp",
               result, stopccn_result_codes[result], error, c->errormsg);
      }
    } else {
      {
#line 528
      l2tp_log(7, "%s: peer closing for reason %d (%s), error = %d (%s)\n", "result_code_avp",
               result, cdn_result_codes[result], error, c->errormsg);
      }
    }
  }
#line 534
  return (0);
}
}
#line 537 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int protocol_version_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int ver ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 546
  raw = (struct unaligned_u16 *)data;
#line 548
  if (t->sanity) {
#line 550
    if (datalen != 8) {
#line 552
      if (c) {
#line 552
        if (c->debug) {
#line 552
          tmp = 1;
        } else
#line 552
        if (t->debug) {
#line 552
          tmp = 1;
        } else {
#line 552
          tmp = 0;
        }
#line 552
        tmp___0 = tmp;
      } else {
#line 552
        tmp___0 = t->debug;
      }
#line 552
      if (tmp___0) {
        {
#line 553
        l2tp_log(7, "%s: avp is incorrect size.  %d != 8\n", "protocol_version_avp",
                 datalen);
        }
      }
      {
#line 556
      wrong_length(c, (char *)"Protocol Version", 8, datalen, 1);
      }
#line 557
      return (-22);
    }
    {
#line 562
    if (c->msgtype == 1) {
#line 562
      goto case_1;
    }
#line 562
    if (c->msgtype == 2) {
#line 562
      goto case_1;
    }
#line 564
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 563
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 565
    if (c) {
#line 565
      if (c->debug) {
#line 565
        tmp___1 = 1;
      } else
#line 565
      if (t->debug) {
#line 565
        tmp___1 = 1;
      } else {
#line 565
        tmp___1 = 0;
      }
#line 565
      tmp___2 = tmp___1;
    } else {
#line 565
      tmp___2 = t->debug;
    }
#line 565
    if (tmp___2) {
      {
#line 566
      l2tp_log(7, "%s: protocol version not appropriate for %s.  Ignoring.\n", "protocol_version_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 569
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 573
  tmp___3 = ntohs((raw + 3)->s);
#line 573
  ver = (int )tmp___3;
  }
#line 574
  if (gconfig.debug_avp) {
#line 576
    if (c) {
#line 576
      if (c->debug) {
#line 576
        tmp___4 = 1;
      } else
#line 576
      if (t->debug) {
#line 576
        tmp___4 = 1;
      } else {
#line 576
        tmp___4 = 0;
      }
#line 576
      tmp___5 = tmp___4;
    } else {
#line 576
      tmp___5 = t->debug;
    }
#line 576
    if (tmp___5) {
      {
#line 577
      l2tp_log(7, "%s: peer is using version %d, revision %d.\n", "protocol_version_avp",
               ver >> 8, ver & 255);
      }
    }
  }
#line 581
  return (0);
}
}
#line 584 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int framing_caps_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int caps ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 593
  raw = (struct unaligned_u16 *)data;
#line 596
  if (t->sanity) {
    {
#line 601
    if (c->msgtype == 1) {
#line 601
      goto case_1;
    }
#line 601
    if (c->msgtype == 2) {
#line 601
      goto case_1;
    }
#line 603
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 602
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 604
    if (c) {
#line 604
      if (c->debug) {
#line 604
        tmp = 1;
      } else
#line 604
      if (t->debug) {
#line 604
        tmp = 1;
      } else {
#line 604
        tmp = 0;
      }
#line 604
      tmp___0 = tmp;
    } else {
#line 604
      tmp___0 = t->debug;
    }
#line 604
    if (tmp___0) {
      {
#line 605
      l2tp_log(7, "%s: framing capabilities not appropriate for %s.  Ignoring.\n",
               "framing_caps_avp", msgtypes[c->msgtype]);
      }
    }
#line 608
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 610
    if (datalen != 10) {
#line 612
      if (c) {
#line 612
        if (c->debug) {
#line 612
          tmp___1 = 1;
        } else
#line 612
        if (t->debug) {
#line 612
          tmp___1 = 1;
        } else {
#line 612
          tmp___1 = 0;
        }
#line 612
        tmp___2 = tmp___1;
      } else {
#line 612
        tmp___2 = t->debug;
      }
#line 612
      if (tmp___2) {
        {
#line 613
        l2tp_log(7, "%s: avp is incorrect size.  %d != 10\n", "framing_caps_avp",
                 datalen);
        }
      }
      {
#line 616
      wrong_length(c, (char *)"Framming Capabilities", 10, datalen, 0);
      }
#line 617
      return (-22);
    }
  }
  {
#line 621
  tmp___3 = ntohs((raw + 4)->s);
#line 621
  caps = (int )tmp___3;
  }
#line 622
  if (gconfig.debug_avp) {
#line 623
    if (c) {
#line 623
      if (c->debug) {
#line 623
        tmp___6 = 1;
      } else
#line 623
      if (t->debug) {
#line 623
        tmp___6 = 1;
      } else {
#line 623
        tmp___6 = 0;
      }
#line 623
      tmp___7 = tmp___6;
    } else {
#line 623
      tmp___7 = t->debug;
    }
#line 623
    if (tmp___7) {
#line 624
      if (caps & 1) {
#line 624
        tmp___4 = " sync";
      } else {
#line 624
        tmp___4 = "";
      }
#line 624
      if (caps & 2) {
#line 624
        tmp___5 = " async";
      } else {
#line 624
        tmp___5 = "";
      }
      {
#line 624
      l2tp_log(7, "%s: supported peer frames:%s%s\n", "framing_caps_avp", tmp___5,
               tmp___4);
      }
    }
  }
#line 628
  t->fc = caps & 3;
#line 629
  return (0);
}
}
#line 632 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int bearer_caps_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int caps ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 639
  raw = (struct unaligned_u16 *)data;
#line 642
  if (t->sanity) {
    {
#line 647
    if (c->msgtype == 1) {
#line 647
      goto case_1;
    }
#line 647
    if (c->msgtype == 2) {
#line 647
      goto case_1;
    }
#line 649
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 648
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 650
    if (c) {
#line 650
      if (c->debug) {
#line 650
        tmp = 1;
      } else
#line 650
      if (t->debug) {
#line 650
        tmp = 1;
      } else {
#line 650
        tmp = 0;
      }
#line 650
      tmp___0 = tmp;
    } else {
#line 650
      tmp___0 = t->debug;
    }
#line 650
    if (tmp___0) {
      {
#line 651
      l2tp_log(7, "%s: bearer capabilities not appropriate for message %s.  Ignoring.\n",
               "bearer_caps_avp", msgtypes[c->msgtype]);
      }
    }
#line 654
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 656
    if (datalen != 10) {
#line 658
      if (c) {
#line 658
        if (c->debug) {
#line 658
          tmp___1 = 1;
        } else
#line 658
        if (t->debug) {
#line 658
          tmp___1 = 1;
        } else {
#line 658
          tmp___1 = 0;
        }
#line 658
        tmp___2 = tmp___1;
      } else {
#line 658
        tmp___2 = t->debug;
      }
#line 658
      if (tmp___2) {
        {
#line 659
        l2tp_log(7, "%s: avp is incorrect size.  %d != 10\n", "bearer_caps_avp", datalen);
        }
      }
      {
#line 662
      wrong_length(c, (char *)"Bearer Capabilities", 10, datalen, 0);
      }
#line 663
      return (-22);
    }
  }
  {
#line 667
  tmp___3 = ntohs((raw + 4)->s);
#line 667
  caps = (int )tmp___3;
  }
#line 668
  if (gconfig.debug_avp) {
#line 670
    if (c) {
#line 670
      if (c->debug) {
#line 670
        tmp___6 = 1;
      } else
#line 670
      if (t->debug) {
#line 670
        tmp___6 = 1;
      } else {
#line 670
        tmp___6 = 0;
      }
#line 670
      tmp___7 = tmp___6;
    } else {
#line 670
      tmp___7 = t->debug;
    }
#line 670
    if (tmp___7) {
#line 672
      if (caps & 1) {
#line 672
        tmp___4 = " digital";
      } else {
#line 672
        tmp___4 = "";
      }
#line 672
      if (caps & 2) {
#line 672
        tmp___5 = " analog";
      } else {
#line 672
        tmp___5 = "";
      }
      {
#line 672
      l2tp_log(7, "%s: supported peer bearers:%s%s\n", "bearer_caps_avp", tmp___5,
               tmp___4);
      }
    }
  }
#line 680
  t->bc = caps & 3;
#line 681
  return (0);
}
}
#line 687 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int firmware_rev_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int ver ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 694
  raw = (struct unaligned_u16 *)data;
#line 697
  if (t->sanity) {
    {
#line 702
    if (c->msgtype == 1) {
#line 702
      goto case_1;
    }
#line 702
    if (c->msgtype == 2) {
#line 702
      goto case_1;
    }
#line 704
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 703
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 705
    if (c) {
#line 705
      if (c->debug) {
#line 705
        tmp = 1;
      } else
#line 705
      if (t->debug) {
#line 705
        tmp = 1;
      } else {
#line 705
        tmp = 0;
      }
#line 705
      tmp___0 = tmp;
    } else {
#line 705
      tmp___0 = t->debug;
    }
#line 705
    if (tmp___0) {
      {
#line 706
      l2tp_log(7, "%s: firmware revision not appropriate for message %s.  Ignoring.\n",
               "firmware_rev_avp", msgtypes[c->msgtype]);
      }
    }
#line 709
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 711
    if (datalen != 8) {
#line 713
      if (c) {
#line 713
        if (c->debug) {
#line 713
          tmp___1 = 1;
        } else
#line 713
        if (t->debug) {
#line 713
          tmp___1 = 1;
        } else {
#line 713
          tmp___1 = 0;
        }
#line 713
        tmp___2 = tmp___1;
      } else {
#line 713
        tmp___2 = t->debug;
      }
#line 713
      if (tmp___2) {
        {
#line 714
        l2tp_log(7, "%s: avp is incorrect size.  %d != 8\n", "firmware_rev_avp", datalen);
        }
      }
      {
#line 717
      wrong_length(c, (char *)"Firmware Revision", 8, datalen, 0);
      }
#line 718
      return (-22);
    }
  }
  {
#line 722
  tmp___3 = ntohs((raw + 3)->s);
#line 722
  ver = (int )tmp___3;
  }
#line 723
  if (gconfig.debug_avp) {
#line 725
    if (c) {
#line 725
      if (c->debug) {
#line 725
        tmp___4 = 1;
      } else
#line 725
      if (t->debug) {
#line 725
        tmp___4 = 1;
      } else {
#line 725
        tmp___4 = 0;
      }
#line 725
      tmp___5 = tmp___4;
    } else {
#line 725
      tmp___5 = t->debug;
    }
#line 725
    if (tmp___5) {
      {
#line 726
      l2tp_log(7, "%s: peer reports firmware version %d (0x%.4x)\n", "firmware_rev_avp",
               ver, ver);
      }
    }
  }
#line 730
  t->firmware = ver;
#line 731
  return (0);
}
}
#line 734 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int bearer_type_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int b ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 741
  raw = (struct unaligned_u16 *)data;
#line 744
  if (t->sanity) {
    {
#line 749
    if (c->msgtype == 7) {
#line 749
      goto case_7;
    }
#line 749
    if (c->msgtype == 10) {
#line 749
      goto case_7;
    }
#line 751
    goto switch_default;
    case_7: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 750
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 752
    if (c) {
#line 752
      if (c->debug) {
#line 752
        tmp = 1;
      } else
#line 752
      if (t->debug) {
#line 752
        tmp = 1;
      } else {
#line 752
        tmp = 0;
      }
#line 752
      tmp___0 = tmp;
    } else {
#line 752
      tmp___0 = t->debug;
    }
#line 752
    if (tmp___0) {
      {
#line 753
      l2tp_log(7, "%s: bearer type not appropriate for message %s.  Ignoring.\n",
               "bearer_type_avp", msgtypes[c->msgtype]);
      }
    }
#line 756
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 758
    if (datalen != 10) {
#line 760
      if (c) {
#line 760
        if (c->debug) {
#line 760
          tmp___1 = 1;
        } else
#line 760
        if (t->debug) {
#line 760
          tmp___1 = 1;
        } else {
#line 760
          tmp___1 = 0;
        }
#line 760
        tmp___2 = tmp___1;
      } else {
#line 760
        tmp___2 = t->debug;
      }
#line 760
      if (tmp___2) {
        {
#line 761
        l2tp_log(7, "%s: avp is incorrect size.  %d != 10\n", "bearer_type_avp", datalen);
        }
      }
      {
#line 764
      wrong_length(c, (char *)"Bearer Type", 10, datalen, 0);
      }
#line 765
      return (-22);
    }
  }
  {
#line 769
  tmp___3 = ntohs((raw + 4)->s);
#line 769
  b = (int )tmp___3;
  }
#line 770
  if (gconfig.debug_avp) {
#line 772
    if (c) {
#line 772
      if (c->debug) {
#line 772
        tmp___5 = 1;
      } else
#line 772
      if (t->debug) {
#line 772
        tmp___5 = 1;
      } else {
#line 772
        tmp___5 = 0;
      }
#line 772
      tmp___6 = tmp___5;
    } else {
#line 772
      tmp___6 = t->debug;
    }
#line 772
    if (tmp___6) {
#line 773
      if (b & 2) {
#line 773
        tmp___4 = " analog";
      } else {
#line 773
        tmp___4 = "digital";
      }
      {
#line 773
      l2tp_log(7, "%s: peer bears:%s\n", "bearer_type_avp", tmp___4);
      }
    }
  }
#line 777
  (t->call_head)->bearer = b;
#line 778
  return (0);
}
}
#line 781 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int frame_type_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int b ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 787
  raw = (struct unaligned_u16 *)data;
#line 790
  if (t->sanity) {
    {
#line 796
    if (c->msgtype == 9) {
#line 796
      goto case_9;
    }
#line 796
    if (c->msgtype == 7) {
#line 796
      goto case_9;
    }
#line 796
    if (c->msgtype == 12) {
#line 796
      goto case_9;
    }
#line 798
    goto switch_default;
    case_9: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 797
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 799
    if (c) {
#line 799
      if (c->debug) {
#line 799
        tmp = 1;
      } else
#line 799
      if (t->debug) {
#line 799
        tmp = 1;
      } else {
#line 799
        tmp = 0;
      }
#line 799
      tmp___0 = tmp;
    } else {
#line 799
      tmp___0 = t->debug;
    }
#line 799
    if (tmp___0) {
      {
#line 800
      l2tp_log(7, "%s: frame type not appropriate for message %s.  Ignoring.\n", "frame_type_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 803
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 805
    if (datalen != 10) {
#line 807
      if (c) {
#line 807
        if (c->debug) {
#line 807
          tmp___1 = 1;
        } else
#line 807
        if (t->debug) {
#line 807
          tmp___1 = 1;
        } else {
#line 807
          tmp___1 = 0;
        }
#line 807
        tmp___2 = tmp___1;
      } else {
#line 807
        tmp___2 = t->debug;
      }
#line 807
      if (tmp___2) {
        {
#line 808
        l2tp_log(7, "%s: avp is incorrect size.  %d != 10\n", "frame_type_avp", datalen);
        }
      }
      {
#line 811
      wrong_length(c, (char *)"Frame Type", 10, datalen, 0);
      }
#line 812
      return (-22);
    }
  }
  {
#line 816
  tmp___3 = ntohs((raw + 4)->s);
#line 816
  b = (int )tmp___3;
  }
#line 817
  if (gconfig.debug_avp) {
#line 819
    if (c) {
#line 819
      if (c->debug) {
#line 819
        tmp___5 = 1;
      } else
#line 819
      if (t->debug) {
#line 819
        tmp___5 = 1;
      } else {
#line 819
        tmp___5 = 0;
      }
#line 819
      tmp___6 = tmp___5;
    } else {
#line 819
      tmp___6 = t->debug;
    }
#line 819
    if (tmp___6) {
#line 820
      if (b & 2) {
#line 820
        tmp___4 = " async";
      } else {
#line 820
        tmp___4 = "sync";
      }
      {
#line 820
      l2tp_log(7, "%s: peer uses:%s frames\n", "frame_type_avp", tmp___4);
      }
    }
  }
#line 824
  c->frame = b;
#line 825
  return (0);
}
}
#line 828 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int hostname_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int size ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 834
  raw = (struct unaligned_u16 *)data;
#line 837
  if (t->sanity) {
    {
#line 842
    if (c->msgtype == 1) {
#line 842
      goto case_1;
    }
#line 842
    if (c->msgtype == 2) {
#line 842
      goto case_1;
    }
#line 844
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 843
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 845
    if (c) {
#line 845
      if (c->debug) {
#line 845
        tmp = 1;
      } else
#line 845
      if (t->debug) {
#line 845
        tmp = 1;
      } else {
#line 845
        tmp = 0;
      }
#line 845
      tmp___0 = tmp;
    } else {
#line 845
      tmp___0 = t->debug;
    }
#line 845
    if (tmp___0) {
      {
#line 846
      l2tp_log(7, "%s: hostname not appropriate for message %s.  Ignoring.\n", "hostname_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 849
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 851
    if (datalen < 6) {
#line 853
      if (c) {
#line 853
        if (c->debug) {
#line 853
          tmp___1 = 1;
        } else
#line 853
        if (t->debug) {
#line 853
          tmp___1 = 1;
        } else {
#line 853
          tmp___1 = 0;
        }
#line 853
        tmp___2 = tmp___1;
      } else {
#line 853
        tmp___2 = t->debug;
      }
#line 853
      if (tmp___2) {
        {
#line 854
        l2tp_log(7, "%s: avp is too small.  %d < 6\n", "hostname_avp", datalen);
        }
      }
      {
#line 857
      wrong_length(c, (char *)"Hostname", 6, datalen, 1);
      }
#line 858
      return (-22);
    }
  }
#line 862
  size = (int )(raw + 0)->s & 1023;
#line 863
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 864
  if (size > 119) {
#line 866
    if (c) {
#line 866
      if (c->debug) {
#line 866
        tmp___3 = 1;
      } else
#line 866
      if (t->debug) {
#line 866
        tmp___3 = 1;
      } else {
#line 866
        tmp___3 = 0;
      }
#line 866
      tmp___4 = tmp___3;
    } else {
#line 866
      tmp___4 = t->debug;
    }
#line 866
    if (tmp___4) {
      {
#line 867
      l2tp_log(7, "%s: truncating reported hostname (size is %d)\n", "hostname_avp",
               size);
      }
    }
#line 869
    size = 119;
  }
  {
#line 871
  safe_copy(t->hostname, (char *)(& (raw + 3)->s), size);
  }
#line 872
  if (gconfig.debug_avp) {
#line 874
    if (c) {
#line 874
      if (c->debug) {
#line 874
        tmp___5 = 1;
      } else
#line 874
      if (t->debug) {
#line 874
        tmp___5 = 1;
      } else {
#line 874
        tmp___5 = 0;
      }
#line 874
      tmp___6 = tmp___5;
    } else {
#line 874
      tmp___6 = t->debug;
    }
#line 874
    if (tmp___6) {
      {
#line 875
      l2tp_log(7, "%s: peer reports hostname \'%s\'\n", "hostname_avp", t->hostname);
      }
    }
  }
#line 879
  return (0);
}
}
#line 882 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int dialing_number_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int size ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 889
  raw = (struct unaligned_u16 *)data;
#line 892
  if (t->sanity) {
    {
#line 896
    if (c->msgtype == 10) {
#line 896
      goto case_10;
    }
#line 898
    goto switch_default;
    case_10: /* CIL Label */ 
#line 897
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 899
    if (c) {
#line 899
      if (c->debug) {
#line 899
        tmp = 1;
      } else
#line 899
      if (t->debug) {
#line 899
        tmp = 1;
      } else {
#line 899
        tmp = 0;
      }
#line 899
      tmp___0 = tmp;
    } else {
#line 899
      tmp___0 = t->debug;
    }
#line 899
    if (tmp___0) {
      {
#line 900
      l2tp_log(7, "%s: dialing number not appropriate for message %s.  Ignoring.\n",
               "dialing_number_avp", msgtypes[c->msgtype]);
      }
    }
#line 903
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 905
    if (datalen < 6) {
#line 907
      if (c) {
#line 907
        if (c->debug) {
#line 907
          tmp___1 = 1;
        } else
#line 907
        if (t->debug) {
#line 907
          tmp___1 = 1;
        } else {
#line 907
          tmp___1 = 0;
        }
#line 907
        tmp___2 = tmp___1;
      } else {
#line 907
        tmp___2 = t->debug;
      }
#line 907
      if (tmp___2) {
        {
#line 908
        l2tp_log(7, "%s: avp is too small.  %d < 6\n", "dialing_number_avp", datalen);
        }
      }
      {
#line 911
      wrong_length(c, (char *)"Dialing Number", 6, datalen, 1);
      }
#line 912
      return (-22);
    }
  }
#line 916
  size = (int )(raw + 0)->s & 1023;
#line 917
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 918
  if (size > 119) {
#line 920
    if (c) {
#line 920
      if (c->debug) {
#line 920
        tmp___3 = 1;
      } else
#line 920
      if (t->debug) {
#line 920
        tmp___3 = 1;
      } else {
#line 920
        tmp___3 = 0;
      }
#line 920
      tmp___4 = tmp___3;
    } else {
#line 920
      tmp___4 = t->debug;
    }
#line 920
    if (tmp___4) {
      {
#line 921
      l2tp_log(7, "%s: truncating reported dialing number (size is %d)\n", "dialing_number_avp",
               size);
      }
    }
#line 924
    size = 119;
  }
  {
#line 926
  safe_copy((t->call_head)->dialing, (char *)(& (raw + 3)->s), size);
  }
#line 927
  if (gconfig.debug_avp) {
#line 929
    if (c) {
#line 929
      if (c->debug) {
#line 929
        tmp___5 = 1;
      } else
#line 929
      if (t->debug) {
#line 929
        tmp___5 = 1;
      } else {
#line 929
        tmp___5 = 0;
      }
#line 929
      tmp___6 = tmp___5;
    } else {
#line 929
      tmp___6 = t->debug;
    }
#line 929
    if (tmp___6) {
      {
#line 930
      l2tp_log(7, "%s: peer reports dialing number \'%s\'\n", "dialing_number_avp",
               (t->call_head)->dialing);
      }
    }
  }
#line 934
  return (0);
}
}
#line 937 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int dialed_number_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int size ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 944
  raw = (struct unaligned_u16 *)data;
#line 947
  if (t->sanity) {
    {
#line 952
    if (c->msgtype == 10) {
#line 952
      goto case_10;
    }
#line 952
    if (c->msgtype == 7) {
#line 952
      goto case_10;
    }
#line 954
    goto switch_default;
    case_10: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 953
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 955
    if (c) {
#line 955
      if (c->debug) {
#line 955
        tmp = 1;
      } else
#line 955
      if (t->debug) {
#line 955
        tmp = 1;
      } else {
#line 955
        tmp = 0;
      }
#line 955
      tmp___0 = tmp;
    } else {
#line 955
      tmp___0 = t->debug;
    }
#line 955
    if (tmp___0) {
      {
#line 956
      l2tp_log(7, "%s: dialed number not appropriate for message %s.  Ignoring.\n",
               "dialed_number_avp", msgtypes[c->msgtype]);
      }
    }
#line 959
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 961
    if (datalen < 6) {
#line 963
      if (c) {
#line 963
        if (c->debug) {
#line 963
          tmp___1 = 1;
        } else
#line 963
        if (t->debug) {
#line 963
          tmp___1 = 1;
        } else {
#line 963
          tmp___1 = 0;
        }
#line 963
        tmp___2 = tmp___1;
      } else {
#line 963
        tmp___2 = t->debug;
      }
#line 963
      if (tmp___2) {
        {
#line 964
        l2tp_log(7, "%s: avp is too small.  %d < 6\n", "dialed_number_avp", datalen);
        }
      }
      {
#line 967
      wrong_length(c, (char *)"Dialed Number", 6, datalen, 1);
      }
#line 968
      return (-22);
    }
  }
#line 972
  size = (int )(raw + 0)->s & 1023;
#line 973
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 974
  if (size > 119) {
#line 976
    if (c) {
#line 976
      if (c->debug) {
#line 976
        tmp___3 = 1;
      } else
#line 976
      if (t->debug) {
#line 976
        tmp___3 = 1;
      } else {
#line 976
        tmp___3 = 0;
      }
#line 976
      tmp___4 = tmp___3;
    } else {
#line 976
      tmp___4 = t->debug;
    }
#line 976
    if (tmp___4) {
      {
#line 977
      l2tp_log(7, "%s: truncating reported dialed number (size is %d)\n", "dialed_number_avp",
               size);
      }
    }
#line 980
    size = 119;
  }
  {
#line 982
  safe_copy((t->call_head)->dialed, (char *)(& (raw + 3)->s), size);
  }
#line 983
  if (gconfig.debug_avp) {
#line 985
    if (c) {
#line 985
      if (c->debug) {
#line 985
        tmp___5 = 1;
      } else
#line 985
      if (t->debug) {
#line 985
        tmp___5 = 1;
      } else {
#line 985
        tmp___5 = 0;
      }
#line 985
      tmp___6 = tmp___5;
    } else {
#line 985
      tmp___6 = t->debug;
    }
#line 985
    if (tmp___6) {
      {
#line 986
      l2tp_log(7, "%s: peer reports dialed number \'%s\'\n", "dialed_number_avp",
               (t->call_head)->dialed);
      }
    }
  }
#line 990
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int sub_address_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int size ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1000
  raw = (struct unaligned_u16 *)data;
#line 1003
  if (t->sanity) {
    {
#line 1008
    if (c->msgtype == 10) {
#line 1008
      goto case_10;
    }
#line 1008
    if (c->msgtype == 8) {
#line 1008
      goto case_10;
    }
#line 1010
    goto switch_default;
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 1009
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1011
    if (c) {
#line 1011
      if (c->debug) {
#line 1011
        tmp = 1;
      } else
#line 1011
      if (t->debug) {
#line 1011
        tmp = 1;
      } else {
#line 1011
        tmp = 0;
      }
#line 1011
      tmp___0 = tmp;
    } else {
#line 1011
      tmp___0 = t->debug;
    }
#line 1011
    if (tmp___0) {
      {
#line 1012
      l2tp_log(7, "%s: sub_address not appropriate for message %s.  Ignoring.\n",
               "sub_address_avp", msgtypes[c->msgtype]);
      }
    }
#line 1015
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1017
    if (datalen < 6) {
#line 1019
      if (c) {
#line 1019
        if (c->debug) {
#line 1019
          tmp___1 = 1;
        } else
#line 1019
        if (t->debug) {
#line 1019
          tmp___1 = 1;
        } else {
#line 1019
          tmp___1 = 0;
        }
#line 1019
        tmp___2 = tmp___1;
      } else {
#line 1019
        tmp___2 = t->debug;
      }
#line 1019
      if (tmp___2) {
        {
#line 1020
        l2tp_log(7, "%s: avp is too small.  %d < 6\n", "sub_address_avp", datalen);
        }
      }
      {
#line 1023
      wrong_length(c, (char *)"Sub-address", 6, datalen, 1);
      }
#line 1024
      return (-22);
    }
  }
#line 1028
  size = (int )(raw + 0)->s & 1023;
#line 1029
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 1030
  if (size > 119) {
#line 1032
    if (c) {
#line 1032
      if (c->debug) {
#line 1032
        tmp___3 = 1;
      } else
#line 1032
      if (t->debug) {
#line 1032
        tmp___3 = 1;
      } else {
#line 1032
        tmp___3 = 0;
      }
#line 1032
      tmp___4 = tmp___3;
    } else {
#line 1032
      tmp___4 = t->debug;
    }
#line 1032
    if (tmp___4) {
      {
#line 1033
      l2tp_log(7, "%s: truncating reported sub address (size is %d)\n", "sub_address_avp",
               size);
      }
    }
#line 1036
    size = 119;
  }
  {
#line 1038
  safe_copy((t->call_head)->subaddy, (char *)(& (raw + 3)->s), size);
  }
#line 1039
  if (gconfig.debug_avp) {
#line 1041
    if (c) {
#line 1041
      if (c->debug) {
#line 1041
        tmp___5 = 1;
      } else
#line 1041
      if (t->debug) {
#line 1041
        tmp___5 = 1;
      } else {
#line 1041
        tmp___5 = 0;
      }
#line 1041
      tmp___6 = tmp___5;
    } else {
#line 1041
      tmp___6 = t->debug;
    }
#line 1041
    if (tmp___6) {
      {
#line 1042
      l2tp_log(7, "%s: peer reports subaddress \'%s\'\n", "sub_address_avp", (t->call_head)->subaddy);
      }
    }
  }
#line 1046
  return (0);
}
}
#line 1049 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int vendor_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  int size ;
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1055
  raw = (struct unaligned_u16 *)data;
#line 1058
  if (t->sanity) {
    {
#line 1063
    if (c->msgtype == 1) {
#line 1063
      goto case_1;
    }
#line 1063
    if (c->msgtype == 2) {
#line 1063
      goto case_1;
    }
#line 1065
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1064
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1066
    if (c) {
#line 1066
      if (c->debug) {
#line 1066
        tmp = 1;
      } else
#line 1066
      if (t->debug) {
#line 1066
        tmp = 1;
      } else {
#line 1066
        tmp = 0;
      }
#line 1066
      tmp___0 = tmp;
    } else {
#line 1066
      tmp___0 = t->debug;
    }
#line 1066
    if (tmp___0) {
      {
#line 1067
      l2tp_log(7, "%s: vendor not appropriate for message %s.  Ignoring.\n", "vendor_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 1070
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1072
    if (datalen < 6) {
#line 1074
      if (c) {
#line 1074
        if (c->debug) {
#line 1074
          tmp___1 = 1;
        } else
#line 1074
        if (t->debug) {
#line 1074
          tmp___1 = 1;
        } else {
#line 1074
          tmp___1 = 0;
        }
#line 1074
        tmp___2 = tmp___1;
      } else {
#line 1074
        tmp___2 = t->debug;
      }
#line 1074
      if (tmp___2) {
        {
#line 1075
        l2tp_log(7, "%s: avp is too small.  %d < 6\n", "vendor_avp", datalen);
        }
      }
      {
#line 1078
      wrong_length(c, (char *)"Vendor", 6, datalen, 1);
      }
#line 1079
      return (-22);
    }
  }
#line 1083
  size = (int )(raw + 0)->s & 1023;
#line 1084
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 1085
  if (size > 119) {
#line 1087
    if (c) {
#line 1087
      if (c->debug) {
#line 1087
        tmp___3 = 1;
      } else
#line 1087
      if (t->debug) {
#line 1087
        tmp___3 = 1;
      } else {
#line 1087
        tmp___3 = 0;
      }
#line 1087
      tmp___4 = tmp___3;
    } else {
#line 1087
      tmp___4 = t->debug;
    }
#line 1087
    if (tmp___4) {
      {
#line 1088
      l2tp_log(7, "%s: truncating reported vendor (size is %d)\n", "vendor_avp", size);
      }
    }
#line 1090
    size = 119;
  }
  {
#line 1092
  safe_copy(t->vendor, (char *)(& (raw + 3)->s), size);
  }
#line 1093
  if (gconfig.debug_avp) {
#line 1095
    if (c) {
#line 1095
      if (c->debug) {
#line 1095
        tmp___5 = 1;
      } else
#line 1095
      if (t->debug) {
#line 1095
        tmp___5 = 1;
      } else {
#line 1095
        tmp___5 = 0;
      }
#line 1095
      tmp___6 = tmp___5;
    } else {
#line 1095
      tmp___6 = t->debug;
    }
#line 1095
    if (tmp___6) {
      {
#line 1096
      l2tp_log(7, "%s: peer reports vendor \'%s\'\n", "vendor_avp", t->vendor);
      }
    }
  }
#line 1099
  return (0);
}
}
#line 1102 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int challenge_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 1107
  raw = (struct unaligned_u16 *)data;
#line 1110
  if (t->sanity) {
    {
#line 1115
    if (c->msgtype == 1) {
#line 1115
      goto case_1;
    }
#line 1115
    if (c->msgtype == 2) {
#line 1115
      goto case_1;
    }
#line 1117
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1116
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1118
    if (c) {
#line 1118
      if (c->debug) {
#line 1118
        tmp = 1;
      } else
#line 1118
      if (t->debug) {
#line 1118
        tmp = 1;
      } else {
#line 1118
        tmp = 0;
      }
#line 1118
      tmp___0 = tmp;
    } else {
#line 1118
      tmp___0 = t->debug;
    }
#line 1118
    if (tmp___0) {
      {
#line 1119
      l2tp_log(7, "%s: challenge not appropriate for message %s.  Ignoring.\n", "challenge_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 1122
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1124
    if (datalen < 6) {
#line 1126
      if (c) {
#line 1126
        if (c->debug) {
#line 1126
          tmp___1 = 1;
        } else
#line 1126
        if (t->debug) {
#line 1126
          tmp___1 = 1;
        } else {
#line 1126
          tmp___1 = 0;
        }
#line 1126
        tmp___2 = tmp___1;
      } else {
#line 1126
        tmp___2 = t->debug;
      }
#line 1126
      if (tmp___2) {
        {
#line 1127
        l2tp_log(7, "%s: avp is too small.  %d < 6\n", "challenge_avp", datalen);
        }
      }
      {
#line 1130
      wrong_length(c, (char *)"challenge", 6, datalen, 1);
      }
#line 1131
      return (-22);
    }
  }
#line 1137
  size = (int )(raw + 0)->s & 1023;
#line 1138
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 1145
  if (t->chal_us.challenge) {
    {
#line 1146
    free((void *)t->chal_us.challenge);
    }
  }
  {
#line 1147
  tmp___3 = malloc((size_t )size);
#line 1147
  t->chal_us.challenge = (unsigned char *)tmp___3;
  }
#line 1148
  if ((unsigned long )t->chal_us.challenge == (unsigned long )((void *)0)) {
#line 1150
    return (-12);
  }
  {
#line 1152
  bcopy((void const   *)(& (raw + 3)->s), (void *)t->chal_us.challenge, (size_t )size);
#line 1153
  t->chal_us.chal_len = (unsigned int )size;
#line 1154
  t->chal_us.state = 1;
  }
#line 1155
  if (gconfig.debug_avp) {
    {
#line 1157
    l2tp_log(7, "%s: challenge avp found\n", "challenge_avp");
    }
  }
#line 1159
  return (0);
}
}
#line 1162 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int chalresp_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1167
  raw = (struct unaligned_u16 *)data;
#line 1170
  if (t->sanity) {
    {
#line 1175
    if (c->msgtype == 3) {
#line 1175
      goto case_3;
    }
#line 1175
    if (c->msgtype == 2) {
#line 1175
      goto case_3;
    }
#line 1177
    goto switch_default;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1176
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1178
    if (c) {
#line 1178
      if (c->debug) {
#line 1178
        tmp = 1;
      } else
#line 1178
      if (t->debug) {
#line 1178
        tmp = 1;
      } else {
#line 1178
        tmp = 0;
      }
#line 1178
      tmp___0 = tmp;
    } else {
#line 1178
      tmp___0 = t->debug;
    }
#line 1178
    if (tmp___0) {
      {
#line 1179
      l2tp_log(7, "%s: challenge response not appropriate for message %s.  Ignoring.\n",
               "chalresp_avp", msgtypes[c->msgtype]);
      }
    }
#line 1182
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1184
    if (datalen < 6) {
#line 1186
      if (c) {
#line 1186
        if (c->debug) {
#line 1186
          tmp___1 = 1;
        } else
#line 1186
        if (t->debug) {
#line 1186
          tmp___1 = 1;
        } else {
#line 1186
          tmp___1 = 0;
        }
#line 1186
        tmp___2 = tmp___1;
      } else {
#line 1186
        tmp___2 = t->debug;
      }
#line 1186
      if (tmp___2) {
        {
#line 1187
        l2tp_log(7, "%s: avp is too small.  %d < 6\n", "chalresp_avp", datalen);
        }
      }
      {
#line 1190
      wrong_length(c, (char *)"challenge", 6, datalen, 1);
      }
#line 1191
      return (-22);
    }
  }
#line 1195
  size = (int )(raw + 0)->s & 1023;
#line 1196
  size = (int )((unsigned long )size - sizeof(struct avp_hdr ));
#line 1197
  if (size != 16) {
    {
#line 1199
    l2tp_log(7, "%s: Challenge is not the right length (%d != %d)\n", "chalresp_avp",
             size, 16);
    }
#line 1201
    return (-22);
  }
  {
#line 1204
  bcopy((void const   *)(& (raw + 3)->s), (void *)(t->chal_them.reply), (size_t )16);
  }
#line 1205
  if (gconfig.debug_avp) {
    {
#line 1207
    l2tp_log(7, "%s: Challenge reply found\n", "chalresp_avp");
    }
  }
#line 1209
  return (0);
}
}
#line 1212 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int assigned_tunnel_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1218
  raw = (struct unaligned_u16 *)data;
#line 1221
  if (t->sanity) {
    {
#line 1227
    if (c->msgtype == 4) {
#line 1227
      goto case_4;
    }
#line 1227
    if (c->msgtype == 1) {
#line 1227
      goto case_4;
    }
#line 1227
    if (c->msgtype == 2) {
#line 1227
      goto case_4;
    }
#line 1229
    goto switch_default;
    case_4: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1228
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1230
    if (c) {
#line 1230
      if (c->debug) {
#line 1230
        tmp = 1;
      } else
#line 1230
      if (t->debug) {
#line 1230
        tmp = 1;
      } else {
#line 1230
        tmp = 0;
      }
#line 1230
      tmp___0 = tmp;
    } else {
#line 1230
      tmp___0 = t->debug;
    }
#line 1230
    if (tmp___0) {
      {
#line 1231
      l2tp_log(7, "%s: tunnel ID not appropriate for message %s.  Ignoring.\n", "assigned_tunnel_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 1234
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1236
    if (datalen != 8) {
#line 1238
      if (c) {
#line 1238
        if (c->debug) {
#line 1238
          tmp___1 = 1;
        } else
#line 1238
        if (t->debug) {
#line 1238
          tmp___1 = 1;
        } else {
#line 1238
          tmp___1 = 0;
        }
#line 1238
        tmp___2 = tmp___1;
      } else {
#line 1238
        tmp___2 = t->debug;
      }
#line 1238
      if (tmp___2) {
        {
#line 1239
        l2tp_log(7, "%s: avp is wrong size.  %d != 8\n", "assigned_tunnel_avp", datalen);
        }
      }
      {
#line 1242
      wrong_length(c, (char *)"Assigned Tunnel ID", 8, datalen, 0);
      }
#line 1243
      return (-22);
    }
  }
#line 1247
  if (c->msgtype == 4) {
    {
#line 1249
    tmp___3 = ntohs((raw + 3)->s);
#line 1249
    t->qtid = (int )tmp___3;
    }
  } else {
    {
#line 1253
    tmp___4 = ntohs((raw + 3)->s);
#line 1253
    t->tid = (int )tmp___4;
    }
  }
#line 1255
  if (gconfig.debug_avp) {
#line 1257
    if (c) {
#line 1257
      if (c->debug) {
#line 1257
        tmp___6 = 1;
      } else
#line 1257
      if (t->debug) {
#line 1257
        tmp___6 = 1;
      } else {
#line 1257
        tmp___6 = 0;
      }
#line 1257
      tmp___7 = tmp___6;
    } else {
#line 1257
      tmp___7 = t->debug;
    }
#line 1257
    if (tmp___7) {
      {
#line 1258
      tmp___5 = ntohs((raw + 3)->s);
#line 1258
      l2tp_log(7, "%s: using peer\'s tunnel %d\n", "assigned_tunnel_avp", (int )tmp___5);
      }
    }
  }
#line 1262
  return (0);
}
}
#line 1265 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int assigned_call_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1271
  raw = (struct unaligned_u16 *)data;
#line 1274
  if (t->sanity) {
    {
#line 1281
    if (c->msgtype == 8) {
#line 1281
      goto case_8;
    }
#line 1281
    if (c->msgtype == 10) {
#line 1281
      goto case_8;
    }
#line 1281
    if (c->msgtype == 11) {
#line 1281
      goto case_8;
    }
#line 1281
    if (c->msgtype == 14) {
#line 1281
      goto case_8;
    }
#line 1284
    goto switch_default;
    case_8: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_14: /* CIL Label */ 
#line 1282
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1285
    if (c) {
#line 1285
      if (c->debug) {
#line 1285
        tmp = 1;
      } else
#line 1285
      if (t->debug) {
#line 1285
        tmp = 1;
      } else {
#line 1285
        tmp = 0;
      }
#line 1285
      tmp___0 = tmp;
    } else {
#line 1285
      tmp___0 = t->debug;
    }
#line 1285
    if (tmp___0) {
      {
#line 1286
      l2tp_log(7, "%s: call ID not appropriate for message %s.  Ignoring.\n", "assigned_call_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 1289
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1291
    if (datalen != 8) {
#line 1293
      if (c) {
#line 1293
        if (c->debug) {
#line 1293
          tmp___1 = 1;
        } else
#line 1293
        if (t->debug) {
#line 1293
          tmp___1 = 1;
        } else {
#line 1293
          tmp___1 = 0;
        }
#line 1293
        tmp___2 = tmp___1;
      } else {
#line 1293
        tmp___2 = t->debug;
      }
#line 1293
      if (tmp___2) {
        {
#line 1294
        l2tp_log(7, "%s: avp is wrong size.  %d != 8\n", "assigned_call_avp", datalen);
        }
      }
      {
#line 1297
      wrong_length(c, (char *)"Assigned Call ID", 8, datalen, 0);
      }
#line 1298
      return (-22);
    }
  }
#line 1302
  if (c->msgtype == 14) {
    {
#line 1304
    tmp___3 = ntohs((raw + 3)->s);
#line 1304
    c->qcid = (int )tmp___3;
    }
  } else
#line 1306
  if (c->msgtype == 10) {
    {
#line 1308
    tmp___4 = ntohs((raw + 3)->s);
#line 1308
    (t->call_head)->cid = (int )tmp___4;
    }
  } else
#line 1310
  if (c->msgtype == 11) {
    {
#line 1312
    tmp___5 = ntohs((raw + 3)->s);
#line 1312
    c->cid = (int )tmp___5;
    }
  } else
#line 1314
  if (c->msgtype == 8) {
    {
#line 1316
    tmp___6 = ntohs((raw + 3)->s);
#line 1316
    c->cid = (int )tmp___6;
    }
  } else {
    {
#line 1320
    l2tp_log(7, "%s:  Dunno what to do when it\'s state %s!\n", "assigned_call_avp",
             msgtypes[c->msgtype]);
    }
  }
#line 1323
  if (gconfig.debug_avp) {
#line 1325
    if (c) {
#line 1325
      if (c->debug) {
#line 1325
        tmp___8 = 1;
      } else
#line 1325
      if (t->debug) {
#line 1325
        tmp___8 = 1;
      } else {
#line 1325
        tmp___8 = 0;
      }
#line 1325
      tmp___9 = tmp___8;
    } else {
#line 1325
      tmp___9 = t->debug;
    }
#line 1325
    if (tmp___9) {
      {
#line 1326
      tmp___7 = ntohs((raw + 3)->s);
#line 1326
      l2tp_log(7, "%s: using peer\'s call %d\n", "assigned_call_avp", (int )tmp___7);
      }
    }
  }
#line 1329
  return (0);
}
}
#line 1332 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int packet_delay_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1338
  raw = (struct unaligned_u16 *)data;
#line 1341
  if (t->sanity) {
    {
#line 1349
    if (c->msgtype == 9) {
#line 1349
      goto case_9;
    }
#line 1349
    if (c->msgtype == 8) {
#line 1349
      goto case_9;
    }
#line 1349
    if (c->msgtype == 12) {
#line 1349
      goto case_9;
    }
#line 1349
    if (c->msgtype == 7) {
#line 1349
      goto case_9;
    }
#line 1349
    if (c->msgtype == 11) {
#line 1349
      goto case_9;
    }
#line 1351
    goto switch_default;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1350
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1352
    if (c) {
#line 1352
      if (c->debug) {
#line 1352
        tmp = 1;
      } else
#line 1352
      if (t->debug) {
#line 1352
        tmp = 1;
      } else {
#line 1352
        tmp = 0;
      }
#line 1352
      tmp___0 = tmp;
    } else {
#line 1352
      tmp___0 = t->debug;
    }
#line 1352
    if (tmp___0) {
      {
#line 1353
      l2tp_log(7, "%s: packet delay not appropriate for message %s.  Ignoring.\n",
               "packet_delay_avp", msgtypes[c->msgtype]);
      }
    }
#line 1356
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1358
    if (datalen != 8) {
#line 1360
      if (c) {
#line 1360
        if (c->debug) {
#line 1360
          tmp___1 = 1;
        } else
#line 1360
        if (t->debug) {
#line 1360
          tmp___1 = 1;
        } else {
#line 1360
          tmp___1 = 0;
        }
#line 1360
        tmp___2 = tmp___1;
      } else {
#line 1360
        tmp___2 = t->debug;
      }
#line 1360
      if (tmp___2) {
        {
#line 1361
        l2tp_log(7, "%s: avp is wrong size.  %d != 8\n", "packet_delay_avp", datalen);
        }
      }
      {
#line 1364
      wrong_length(c, (char *)"Assigned Call ID", 8, datalen, 0);
      }
#line 1365
      return (-22);
    }
  }
  {
#line 1369
  tmp___3 = ntohs((raw + 3)->s);
#line 1369
  c->ppd = (int )tmp___3;
  }
#line 1370
  if (gconfig.debug_avp) {
#line 1372
    if (c) {
#line 1372
      if (c->debug) {
#line 1372
        tmp___5 = 1;
      } else
#line 1372
      if (t->debug) {
#line 1372
        tmp___5 = 1;
      } else {
#line 1372
        tmp___5 = 0;
      }
#line 1372
      tmp___6 = tmp___5;
    } else {
#line 1372
      tmp___6 = t->debug;
    }
#line 1372
    if (tmp___6) {
      {
#line 1373
      tmp___4 = ntohs((raw + 3)->s);
#line 1373
      l2tp_log(7, "%s: peer\'s delay is %d 1/10\'s of a second\n", "packet_delay_avp",
               (int )tmp___4);
      }
    }
  }
#line 1377
  return (0);
}
}
#line 1380 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int call_serno_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1385
  raw = (struct unaligned_u16 *)data;
#line 1388
  if (t->sanity) {
    {
#line 1393
    if (c->msgtype == 7) {
#line 1393
      goto case_7;
    }
#line 1393
    if (c->msgtype == 10) {
#line 1393
      goto case_7;
    }
#line 1395
    goto switch_default;
    case_7: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1394
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1396
    if (c) {
#line 1396
      if (c->debug) {
#line 1396
        tmp = 1;
      } else
#line 1396
      if (t->debug) {
#line 1396
        tmp = 1;
      } else {
#line 1396
        tmp = 0;
      }
#line 1396
      tmp___0 = tmp;
    } else {
#line 1396
      tmp___0 = t->debug;
    }
#line 1396
    if (tmp___0) {
      {
#line 1397
      l2tp_log(7, "%s: call ID not appropriate for message %s.  Ignoring.\n", "call_serno_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 1400
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1402
    if (datalen != 10) {
      {
#line 1412
      l2tp_log(7, "%s: peer is using old style serial number.  Will be invalid.\n",
               "call_serno_avp");
      }
    }
  }
  {
#line 1420
  tmp___1 = ntohs((raw + 3)->s);
#line 1420
  tmp___2 = ntohs((raw + 4)->s);
#line 1420
  (t->call_head)->serno = ((unsigned int )tmp___1 << 16) | (unsigned int )tmp___2;
  }
#line 1422
  if (gconfig.debug_avp) {
#line 1424
    if (c) {
#line 1424
      if (c->debug) {
#line 1424
        tmp___3 = 1;
      } else
#line 1424
      if (t->debug) {
#line 1424
        tmp___3 = 1;
      } else {
#line 1424
        tmp___3 = 0;
      }
#line 1424
      tmp___4 = tmp___3;
    } else {
#line 1424
      tmp___4 = t->debug;
    }
#line 1424
    if (tmp___4) {
      {
#line 1425
      l2tp_log(7, "%s: serial number is %d\n", "call_serno_avp", (t->call_head)->serno);
      }
    }
  }
#line 1429
  return (0);
}
}
#line 1432 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int rx_speed_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1437
  raw = (struct unaligned_u16 *)data;
#line 1440
  if (t->sanity) {
    {
#line 1446
    if (c->msgtype == 8) {
#line 1446
      goto case_8;
    }
#line 1446
    if (c->msgtype == 9) {
#line 1446
      goto case_8;
    }
#line 1446
    if (c->msgtype == 12) {
#line 1446
      goto case_8;
    }
#line 1448
    goto switch_default;
    case_8: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 1447
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1449
    if (c) {
#line 1449
      if (c->debug) {
#line 1449
        tmp = 1;
      } else
#line 1449
      if (t->debug) {
#line 1449
        tmp = 1;
      } else {
#line 1449
        tmp = 0;
      }
#line 1449
      tmp___0 = tmp;
    } else {
#line 1449
      tmp___0 = t->debug;
    }
#line 1449
    if (tmp___0) {
      {
#line 1450
      l2tp_log(7, "%s: rx connect speed not appropriate for message %s.  Ignoring.\n",
               "rx_speed_avp", msgtypes[c->msgtype]);
      }
    }
#line 1453
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1455
    if (datalen != 10) {
#line 1457
      if (c) {
#line 1457
        if (c->debug) {
#line 1457
          tmp___1 = 1;
        } else
#line 1457
        if (t->debug) {
#line 1457
          tmp___1 = 1;
        } else {
#line 1457
          tmp___1 = 0;
        }
#line 1457
        tmp___2 = tmp___1;
      } else {
#line 1457
        tmp___2 = t->debug;
      }
#line 1457
      if (tmp___2) {
        {
#line 1458
        l2tp_log(7, "%s: avp is wrong size.  %d != 10\n", "rx_speed_avp", datalen);
        }
      }
      {
#line 1461
      wrong_length(c, (char *)"Connect Speed (RX)", 10, datalen, 0);
      }
#line 1462
      return (-22);
    }
  }
  {
#line 1466
  tmp___3 = ntohs((raw + 3)->s);
#line 1466
  tmp___4 = ntohs((raw + 4)->s);
#line 1466
  c->rxspeed = (int )(((unsigned int )tmp___3 << 16) | (unsigned int )tmp___4);
  }
#line 1468
  if (gconfig.debug_avp) {
#line 1470
    if (c) {
#line 1470
      if (c->debug) {
#line 1470
        tmp___5 = 1;
      } else
#line 1470
      if (t->debug) {
#line 1470
        tmp___5 = 1;
      } else {
#line 1470
        tmp___5 = 0;
      }
#line 1470
      tmp___6 = tmp___5;
    } else {
#line 1470
      tmp___6 = t->debug;
    }
#line 1470
    if (tmp___6) {
      {
#line 1471
      l2tp_log(7, "%s: receive baud rate is %d\n", "rx_speed_avp", c->rxspeed);
      }
    }
  }
#line 1474
  return (0);
}
}
#line 1477 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int tx_speed_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1482
  raw = (struct unaligned_u16 *)data;
#line 1485
  if (t->sanity) {
    {
#line 1491
    if (c->msgtype == 8) {
#line 1491
      goto case_8;
    }
#line 1491
    if (c->msgtype == 9) {
#line 1491
      goto case_8;
    }
#line 1491
    if (c->msgtype == 12) {
#line 1491
      goto case_8;
    }
#line 1493
    goto switch_default;
    case_8: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 1492
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1494
    if (c) {
#line 1494
      if (c->debug) {
#line 1494
        tmp = 1;
      } else
#line 1494
      if (t->debug) {
#line 1494
        tmp = 1;
      } else {
#line 1494
        tmp = 0;
      }
#line 1494
      tmp___0 = tmp;
    } else {
#line 1494
      tmp___0 = t->debug;
    }
#line 1494
    if (tmp___0) {
      {
#line 1495
      l2tp_log(7, "%s: tx connect speed not appropriate for message %s.  Ignoring.\n",
               "tx_speed_avp", msgtypes[c->msgtype]);
      }
    }
#line 1498
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1500
    if (datalen != 10) {
#line 1502
      if (c) {
#line 1502
        if (c->debug) {
#line 1502
          tmp___1 = 1;
        } else
#line 1502
        if (t->debug) {
#line 1502
          tmp___1 = 1;
        } else {
#line 1502
          tmp___1 = 0;
        }
#line 1502
        tmp___2 = tmp___1;
      } else {
#line 1502
        tmp___2 = t->debug;
      }
#line 1502
      if (tmp___2) {
        {
#line 1503
        l2tp_log(7, "%s: avp is wrong size.  %d != 10\n", "tx_speed_avp", datalen);
        }
      }
      {
#line 1506
      wrong_length(c, (char *)"Connect Speed (tx)", 10, datalen, 0);
      }
#line 1507
      return (-22);
    }
  }
  {
#line 1511
  tmp___3 = ntohs((raw + 3)->s);
#line 1511
  tmp___4 = ntohs((raw + 4)->s);
#line 1511
  c->txspeed = (int )(((unsigned int )tmp___3 << 16) | (unsigned int )tmp___4);
  }
#line 1513
  if (gconfig.debug_avp) {
#line 1515
    if (c) {
#line 1515
      if (c->debug) {
#line 1515
        tmp___5 = 1;
      } else
#line 1515
      if (t->debug) {
#line 1515
        tmp___5 = 1;
      } else {
#line 1515
        tmp___5 = 0;
      }
#line 1515
      tmp___6 = tmp___5;
    } else {
#line 1515
      tmp___6 = t->debug;
    }
#line 1515
    if (tmp___6) {
      {
#line 1516
      l2tp_log(7, "%s: transmit baud rate is %d\n", "tx_speed_avp", c->txspeed);
      }
    }
  }
#line 1519
  return (0);
}
}
#line 1521 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int call_physchan_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1527
  raw = (struct unaligned_u16 *)data;
#line 1530
  if (t->sanity) {
    {
#line 1537
    if (c->msgtype == 9) {
#line 1537
      goto case_9;
    }
#line 1537
    if (c->msgtype == 8) {
#line 1537
      goto case_9;
    }
#line 1537
    if (c->msgtype == 7) {
#line 1537
      goto case_9;
    }
#line 1537
    if (c->msgtype == 10) {
#line 1537
      goto case_9;
    }
#line 1539
    goto switch_default;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1538
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1540
    if (c) {
#line 1540
      if (c->debug) {
#line 1540
        tmp = 1;
      } else
#line 1540
      if (t->debug) {
#line 1540
        tmp = 1;
      } else {
#line 1540
        tmp = 0;
      }
#line 1540
      tmp___0 = tmp;
    } else {
#line 1540
      tmp___0 = t->debug;
    }
#line 1540
    if (tmp___0) {
      {
#line 1541
      l2tp_log(7, "%s: physical channel not appropriate for message %s.  Ignoring.\n",
               "call_physchan_avp", msgtypes[c->msgtype]);
      }
    }
#line 1544
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1546
    if (datalen != 10) {
#line 1548
      if (c) {
#line 1548
        if (c->debug) {
#line 1548
          tmp___1 = 1;
        } else
#line 1548
        if (t->debug) {
#line 1548
          tmp___1 = 1;
        } else {
#line 1548
          tmp___1 = 0;
        }
#line 1548
        tmp___2 = tmp___1;
      } else {
#line 1548
        tmp___2 = t->debug;
      }
#line 1548
      if (tmp___2) {
        {
#line 1549
        l2tp_log(7, "%s: avp is wrong size.  %d != 10\n", "call_physchan_avp", datalen);
        }
      }
      {
#line 1552
      wrong_length(c, (char *)"Physical Channel", 10, datalen, 0);
      }
#line 1553
      return (-22);
    }
  }
  {
#line 1557
  tmp___3 = ntohs((raw + 3)->s);
#line 1557
  tmp___4 = ntohs((raw + 4)->s);
#line 1557
  (t->call_head)->physchan = (int )(((unsigned int )tmp___3 << 16) | (unsigned int )tmp___4);
  }
#line 1559
  if (gconfig.debug_avp) {
#line 1561
    if (c) {
#line 1561
      if (c->debug) {
#line 1561
        tmp___5 = 1;
      } else
#line 1561
      if (t->debug) {
#line 1561
        tmp___5 = 1;
      } else {
#line 1561
        tmp___5 = 0;
      }
#line 1561
      tmp___6 = tmp___5;
    } else {
#line 1561
      tmp___6 = t->debug;
    }
#line 1561
    if (tmp___6) {
      {
#line 1562
      l2tp_log(7, "%s: physical channel is %d\n", "call_physchan_avp", (t->call_head)->physchan);
      }
    }
  }
#line 1566
  return (0);
}
}
#line 1569 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int receive_window_size_avp(struct tunnel *t , struct call *c , void *data , int datalen ) 
{ 
  struct unaligned_u16 *raw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1575
  raw = (struct unaligned_u16 *)data;
#line 1578
  if (t->sanity) {
    {
#line 1586
    if (c->msgtype == 4) {
#line 1586
      goto case_4;
    }
#line 1586
    if (c->msgtype == 9) {
#line 1586
      goto case_4;
    }
#line 1586
    if (c->msgtype == 8) {
#line 1586
      goto case_4;
    }
#line 1586
    if (c->msgtype == 1) {
#line 1586
      goto case_4;
    }
#line 1586
    if (c->msgtype == 2) {
#line 1586
      goto case_4;
    }
#line 1590
    goto switch_default;
    case_4: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1589
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1591
    if (c) {
#line 1591
      if (c->debug) {
#line 1591
        tmp = 1;
      } else
#line 1591
      if (t->debug) {
#line 1591
        tmp = 1;
      } else {
#line 1591
        tmp = 0;
      }
#line 1591
      tmp___0 = tmp;
    } else {
#line 1591
      tmp___0 = t->debug;
    }
#line 1591
    if (tmp___0) {
      {
#line 1592
      l2tp_log(7, "%s: RWS not appropriate for message %s.  Ignoring.\n", "receive_window_size_avp",
               msgtypes[c->msgtype]);
      }
    }
#line 1595
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1597
    if (datalen != 8) {
#line 1599
      if (c) {
#line 1599
        if (c->debug) {
#line 1599
          tmp___1 = 1;
        } else
#line 1599
        if (t->debug) {
#line 1599
          tmp___1 = 1;
        } else {
#line 1599
          tmp___1 = 0;
        }
#line 1599
        tmp___2 = tmp___1;
      } else {
#line 1599
        tmp___2 = t->debug;
      }
#line 1599
      if (tmp___2) {
        {
#line 1600
        l2tp_log(7, "%s: avp is wrong size.  %d != 8\n", "receive_window_size_avp",
                 datalen);
        }
      }
      {
#line 1603
      wrong_length(c, (char *)"Receive Window Size", 8, datalen, 0);
      }
#line 1604
      return (-22);
    }
  }
  {
#line 1608
  tmp___3 = ntohs((raw + 3)->s);
#line 1608
  t->rws = (int )tmp___3;
  }
#line 1611
  if (gconfig.debug_avp) {
#line 1613
    if (c) {
#line 1613
      if (c->debug) {
#line 1613
        tmp___4 = 1;
      } else
#line 1613
      if (t->debug) {
#line 1613
        tmp___4 = 1;
      } else {
#line 1613
        tmp___4 = 0;
      }
#line 1613
      tmp___5 = tmp___4;
    } else {
#line 1613
      tmp___5 = t->debug;
    }
#line 1613
    if (tmp___5) {
      {
#line 1614
      l2tp_log(7, "%s: peer wants RWS of %d.  Will use flow control.\n", "receive_window_size_avp",
               t->rws);
      }
    }
  }
#line 1618
  return (0);
}
}
#line 1622 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.c"
int handle_avps(struct buffer *buf , struct tunnel *t , struct call *c ) 
{ 
  struct avp_hdr *avp ;
  int len ;
  int firstavp ;
  int hidlen ;
  char *data ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1631
  len = (int )((unsigned long )buf->len - sizeof(struct control_hdr ));
#line 1632
  firstavp = -1;
#line 1633
  hidlen = 0;
#line 1634
  data = (char *)(buf->start + sizeof(struct control_hdr ));
#line 1635
  avp = (struct avp_hdr *)data;
#line 1636
  if (gconfig.debug_avp) {
    {
#line 1637
    l2tp_log(7, "%s: handling avp\'s for tunnel %d, call %d\n", "handle_avps", t->ourtid,
             c->ourcid);
    }
  }
  {
#line 1639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1639
    if (! (len > 0)) {
#line 1639
      goto while_break;
    }
    {
#line 1642
    swaps((void *)avp, (int )sizeof(struct avp_hdr ));
    }
#line 1643
    if ((int )avp->attr > 39) {
#line 1645
      if ((int )avp->length & 32768) {
#line 1647
        if ((unsigned long )c != (unsigned long )t->self) {
#line 1647
          tmp = "call";
        } else {
#line 1647
          tmp = "tunnel";
        }
        {
#line 1647
        l2tp_log(4, "%s:  don\'t know how to handle mandatory attribute %d.  Closing %s.\n",
                 "handle_avps", (int )avp->attr, tmp);
#line 1651
        set_error(c, 6, "mandatory attribute %d cannot be handled", (int )avp->attr);
#line 1654
        c->needclose = -1;
        }
#line 1655
        return (-22);
      } else {
#line 1659
        if (c) {
#line 1659
          if (c->debug) {
#line 1659
            tmp___0 = 1;
          } else
#line 1659
          if (t->debug) {
#line 1659
            tmp___0 = 1;
          } else {
#line 1659
            tmp___0 = 0;
          }
#line 1659
          tmp___1 = tmp___0;
        } else {
#line 1659
          tmp___1 = t->debug;
        }
#line 1659
        if (tmp___1) {
          {
#line 1660
          l2tp_log(4, "%s:  don\'t know how to handle atribute %d.\n", "handle_avps",
                   (int )avp->attr);
          }
        }
#line 1663
        goto next;
      }
    }
#line 1666
    if (((int )avp->length & 1023) > len) {
      {
#line 1668
      l2tp_log(4, "%s: AVP received with length > remaining packet length!\n", "handle_avps");
#line 1671
      set_error(c, 2, "Invalid AVP length");
#line 1672
      c->needclose = -1;
      }
#line 1673
      return (-22);
    }
#line 1675
    if (avp->attr) {
#line 1675
      if (firstavp) {
        {
#line 1677
        l2tp_log(4, "%s: First AVP was not message type.\n", "handle_avps");
#line 1679
        set_error(c, 6, "First AVP must be message type");
#line 1680
        c->needclose = -1;
        }
#line 1681
        return (-22);
      }
    }
#line 1683
    if ((unsigned long )((int )avp->length & 1023) < sizeof(struct avp_hdr )) {
      {
#line 1685
      l2tp_log(4, "%s: AVP with too small of size (%d).\n", "handle_avps", (int )avp->length & 1023);
#line 1687
      set_error(c, 2, "AVP too small");
#line 1688
      c->needclose = -1;
      }
#line 1689
      return (-22);
    }
#line 1691
    if ((int )avp->length & 15360) {
#line 1693
      if ((int )avp->length & 32768) {
#line 1693
        tmp___2 = "Mandatory ";
      } else {
#line 1693
        tmp___2 = "";
      }
      {
#line 1693
      l2tp_log(4, "%s: %sAVP has reserved bits set.\n", "handle_avps", tmp___2);
      }
#line 1695
      if ((int )avp->length & 32768) {
        {
#line 1697
        set_error(c, 3, "reserved bits set in AVP");
#line 1698
        c->needclose = -1;
        }
#line 1699
        return (-22);
      }
#line 1701
      goto next;
    }
#line 1703
    if ((int )avp->length & 16384) {
      {
#line 1711
      hidlen = (int )avp->length;
#line 1712
      tmp___4 = decrypt_avp(data, t);
      }
#line 1712
      if (tmp___4) {
#line 1714
        if (gconfig.debug_avp) {
#line 1715
          if ((int )avp->length & 32768) {
#line 1715
            tmp___3 = "mandatory ";
          } else {
#line 1715
            tmp___3 = "";
          }
          {
#line 1715
          l2tp_log(4, "%s: Unable to handle hidden %sAVP\n:", "handle_avps", tmp___3);
          }
        }
#line 1718
        if ((int )avp->length & 32768) {
          {
#line 1720
          set_error(c, 6, "Invalid Hidden AVP");
#line 1721
          c->needclose = -1;
          }
#line 1722
          return (-22);
        }
#line 1724
        goto next;
      }
#line 1726
      len -= 2;
#line 1727
      hidlen -= 2;
#line 1728
      data += 2;
#line 1729
      avp = (struct avp_hdr *)data;
    } else {
#line 1733
      hidlen = 0;
    }
#line 1734
    if (avps[avp->attr].handler) {
      {
#line 1736
      tmp___7 = (*(avps[avp->attr].handler))(t, c, (void *)avp, (int )avp->length & 1023);
      }
#line 1736
      if (tmp___7) {
#line 1738
        if ((int )avp->length & 32768) {
          {
#line 1740
          l2tp_log(4, "%s: Bad exit status handling attribute %d (%s) on mandatory packet.\n",
                   "handle_avps", (int )avp->attr, avps[avp->attr].description);
#line 1744
          c->needclose = -1;
          }
#line 1745
          return (-22);
        } else {
#line 1749
          if (c) {
#line 1749
            if (c->debug) {
#line 1749
              tmp___5 = 1;
            } else
#line 1749
            if (t->debug) {
#line 1749
              tmp___5 = 1;
            } else {
#line 1749
              tmp___5 = 0;
            }
#line 1749
            tmp___6 = tmp___5;
          } else {
#line 1749
            tmp___6 = t->debug;
          }
#line 1749
          if (tmp___6) {
            {
#line 1750
            l2tp_log(7, "%s: Bad exit status handling attribute %d (%s).\n", "handle_avps",
                     (int )avp->attr, avps[avp->attr].description);
            }
          }
        }
      }
    } else
#line 1759
    if ((int )avp->length & 32768) {
#line 1761
      if ((unsigned long )c != (unsigned long )t->self) {
#line 1761
        tmp___8 = "call";
      } else {
#line 1761
        tmp___8 = "tunnel";
      }
      {
#line 1761
      l2tp_log(4, "%s:  No handler for mandatory attribute %d (%s).  Closing %s.\n",
               "handle_avps", (int )avp->attr, avps[avp->attr].description, tmp___8);
#line 1765
      set_error(c, 6, "No handler for attr %d (%s)\n", (int )avp->attr, avps[avp->attr].description);
      }
#line 1767
      return (-22);
    } else {
#line 1771
      if (c) {
#line 1771
        if (c->debug) {
#line 1771
          tmp___9 = 1;
        } else
#line 1771
        if (t->debug) {
#line 1771
          tmp___9 = 1;
        } else {
#line 1771
          tmp___9 = 0;
        }
#line 1771
        tmp___10 = tmp___9;
      } else {
#line 1771
        tmp___10 = t->debug;
      }
#line 1771
      if (tmp___10) {
        {
#line 1772
        l2tp_log(4, "%s:  no handler for atribute %d (%s).\n", "handle_avps", (int )avp->attr,
                 avps[avp->attr].description);
        }
      }
    }
    next: 
#line 1778
    if (hidlen) {
#line 1781
      len -= hidlen & 1023;
#line 1782
      data += hidlen & 1023;
    } else {
#line 1786
      len -= (int )avp->length & 1023;
#line 1787
      data += (int )avp->length & 1023;
    }
#line 1789
    avp = (struct avp_hdr *)data;
#line 1790
    firstavp = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1792
  if (len != 0) {
    {
#line 1794
    l2tp_log(4, "%s: negative overall packet length\n", "handle_avps");
    }
#line 1795
    return (-22);
  }
#line 1797
  return (0);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 167 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct global gconfig  ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct lns *lnslist  ;
#line 170 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct lac *laclist  ;
#line 171 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct lns *deflns  ;
#line 172 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.h"
struct lac *deflac  ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
char filerr[80]  ;
#line 35
int parse_config(FILE *f ) ;
#line 36
struct keyword words[52] ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int init_config(void) 
{ 
  FILE *f ;
  int returnedValue ;
  void *tmp ;

  {
  {
#line 43
  gconfig.port = 1701;
#line 44
  gconfig.sarefnum = 30;
#line 45
  gconfig.listenaddr = htonl((in_addr_t )0);
#line 46
  gconfig.debug_avp = 0;
#line 47
  gconfig.debug_network = 0;
#line 48
  gconfig.packet_dump = 0;
#line 49
  gconfig.debug_tunnel = 0;
#line 50
  gconfig.debug_state = 0;
#line 51
  lnslist = (struct lns *)((void *)0);
#line 52
  laclist = (struct lac *)((void *)0);
#line 53
  tmp = calloc((size_t )1, sizeof(struct lac ));
#line 53
  deflac = (struct lac *)tmp;
#line 55
  f = fopen((char const   */* __restrict  */)(gconfig.configfile), (char const   */* __restrict  */)"r");
  }
#line 56
  if (! f) {
    {
#line 58
    f = fopen((char const   */* __restrict  */)(gconfig.altconfigfile), (char const   */* __restrict  */)"r");
    }
#line 59
    if (f) {
      {
#line 61
      l2tp_log(4, "%s: Using old style config files %s and %s\n", "init_config", gconfig.altconfigfile,
               gconfig.altauthfile);
#line 63
      strncpy((char */* __restrict  */)(gconfig.authfile), (char const   */* __restrict  */)(gconfig.altauthfile),
              sizeof(gconfig.authfile));
      }
    } else {
      {
#line 68
      l2tp_log(2, "%s: Unable to open config file %s or %s\n", "init_config", gconfig.configfile,
               gconfig.altconfigfile);
      }
#line 70
      return (-1);
    }
  }
  {
#line 74
  returnedValue = parse_config(f);
#line 75
  fclose(f);
  }
#line 76
  return (returnedValue);
#line 77
  filerr[0] = (char)0;
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
struct lns *new_lns(void) 
{ 
  struct lns *tmp ;
  void *tmp___0 ;

  {
  {
#line 83
  tmp___0 = calloc((size_t )1, sizeof(struct lns ));
#line 83
  tmp = (struct lns *)tmp___0;
  }
#line 84
  if (! tmp) {
    {
#line 86
    l2tp_log(2, "%s: Unable to allocate memory for new LNS\n", "new_lns");
    }
#line 88
    return ((struct lns *)((void *)0));
  }
#line 90
  tmp->next = (struct lns *)((void *)0);
#line 91
  tmp->exclusive = 0;
#line 92
  tmp->localaddr = 0U;
#line 93
  tmp->tun_rws = 4;
#line 94
  tmp->call_rws = 4;
#line 95
  tmp->rxspeed = 10000000;
#line 96
  tmp->txspeed = 10000000;
#line 97
  tmp->hbit = 0;
#line 98
  tmp->lbit = 0;
#line 99
  tmp->authpeer = 0;
#line 100
  tmp->authself = -1;
#line 101
  tmp->authname[0] = (char)0;
#line 102
  tmp->peername[0] = (char)0;
#line 103
  tmp->hostname[0] = (char)0;
#line 104
  tmp->entname[0] = (char)0;
#line 105
  tmp->range = (struct iprange *)((void *)0);
#line 106
  tmp->assign_ip = 1;
#line 107
  tmp->lacs = (struct iprange *)((void *)0);
#line 108
  tmp->passwdauth = 0;
#line 109
  tmp->pap_require = 0;
#line 110
  tmp->pap_refuse = 0;
#line 111
  tmp->chap_require = 0;
#line 112
  tmp->chap_refuse = 0;
#line 113
  tmp->idle = 0;
#line 114
  tmp->pridns = 0U;
#line 115
  tmp->secdns = 0U;
#line 116
  tmp->priwins = 0U;
#line 117
  tmp->secwins = 0U;
#line 118
  tmp->proxyarp = 0;
#line 119
  tmp->proxyauth = 0;
#line 120
  tmp->challenge = 0;
#line 121
  tmp->debug = 0;
#line 122
  tmp->pass_peer = 0;
#line 123
  tmp->pppoptfile[0] = (char)0;
#line 124
  tmp->t = (struct tunnel *)((void *)0);
#line 125
  return (tmp);
}
}
#line 128 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
struct lac *new_lac(void) 
{ 
  struct lac *tmp ;
  void *tmp___0 ;

  {
  {
#line 131
  tmp___0 = calloc((size_t )1, sizeof(struct lac ));
#line 131
  tmp = (struct lac *)tmp___0;
  }
#line 132
  if (! tmp) {
    {
#line 134
    l2tp_log(2, "%s: Unable to allocate memory for lac entry!\n", "new_lac");
    }
#line 136
    return ((struct lac *)((void *)0));
  }
#line 138
  tmp->next = (struct lac *)((void *)0);
#line 139
  tmp->rsched = (struct schedule_entry *)((void *)0);
#line 140
  tmp->localaddr = 0U;
#line 141
  tmp->remoteaddr = 0U;
#line 142
  tmp->lns = (struct host *)0;
#line 143
  tmp->tun_rws = 4;
#line 144
  tmp->call_rws = 4;
#line 145
  tmp->hbit = 0;
#line 146
  tmp->lbit = 0;
#line 147
  tmp->authpeer = 0;
#line 148
  tmp->authself = -1;
#line 149
  tmp->authname[0] = (char)0;
#line 150
  tmp->peername[0] = (char)0;
#line 151
  tmp->hostname[0] = (char)0;
#line 152
  tmp->entname[0] = (char)0;
#line 153
  tmp->pap_require = 0;
#line 154
  tmp->pap_refuse = 0;
#line 155
  tmp->chap_require = 0;
#line 156
  tmp->chap_refuse = 0;
#line 157
  tmp->t = (struct tunnel *)((void *)0);
#line 158
  tmp->redial = 0;
#line 159
  tmp->rtries = 0;
#line 160
  tmp->rmax = 0;
#line 161
  tmp->challenge = 0;
#line 162
  tmp->autodial = 0;
#line 163
  tmp->rtimeout = 30;
#line 164
  tmp->active = 0;
#line 165
  tmp->debug = 0;
#line 166
  tmp->pass_peer = 0;
#line 167
  tmp->pppoptfile[0] = (char)0;
#line 168
  tmp->defaultroute = 0;
#line 169
  return (tmp);
}
}
#line 172 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int yesno(char *value ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 174
  tmp___2 = strcasecmp((char const   *)value, "yes");
  }
#line 174
  if (tmp___2) {
    {
#line 174
    tmp___3 = strcasecmp((char const   *)value, "y");
    }
#line 174
    if (tmp___3) {
      {
#line 174
      tmp___4 = strcasecmp((char const   *)value, "true");
      }
#line 174
      if (tmp___4) {
        {
#line 177
        tmp = strcasecmp((char const   *)value, "no");
        }
#line 177
        if (tmp) {
          {
#line 177
          tmp___0 = strcasecmp((char const   *)value, "n");
          }
#line 177
          if (tmp___0) {
            {
#line 177
            tmp___1 = strcasecmp((char const   *)value, "false");
            }
#line 177
            if (tmp___1) {
#line 181
              return (-1);
            } else {
#line 179
              return (0);
            }
          } else {
#line 179
            return (0);
          }
        } else {
#line 179
          return (0);
        }
      } else {
#line 176
        return (1);
      }
    } else {
#line 176
      return (1);
    }
  } else {
#line 176
    return (1);
  }
}
}
#line 184 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_boolean(char *word , char *value , int *ptr ) 
{ 
  int val ;

  {
  {
#line 190
  val = yesno(value);
  }
#line 190
  if (val < 0) {
    {
#line 192
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"%s must be \'yes\' or \'no\'\n",
             word);
    }
#line 194
    return (-1);
  }
#line 196
  *ptr = val;
#line 197
  return (0);
}
}
#line 200 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_int(char *word , char *value , int *ptr ) 
{ 
  int val ;

  {
  {
#line 206
  val = atoi((char const   *)value);
  }
#line 206
  if (val < 0) {
    {
#line 208
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"%s must be a number\n",
             word);
    }
#line 209
    return (-1);
  }
#line 211
  *ptr = val;
#line 212
  return (0);
}
}
#line 215 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_string(char *word , char *value , char *ptr , int len ) 
{ 


  {
  {
#line 220
  strncpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)value, (size_t )len);
  }
#line 221
  return (0);
}
}
#line 224 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_port(char *word , char *value , int context , void *item ) 
{ 


  {
  {
#line 228
  if ((context & -257) == 1) {
#line 228
    goto case_1;
  }
#line 235
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 233
  set_int(word, value, & ((struct global *)item)->port);
  }
#line 234
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 236
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 238
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 240
  return (0);
}
}
#line 243 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_rtimeout(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 245
  tmp = atoi((char const   *)value);
  }
#line 245
  if (tmp < 1) {
    {
#line 247
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"rtimeout value must be at least 1\n");
    }
#line 249
    return (-1);
  }
  {
#line 253
  if ((context & -257) == 3) {
#line 253
    goto case_3;
  }
#line 260
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 258
  set_int(word, value, & ((struct lac *)item)->rtimeout);
  }
#line 259
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 261
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 263
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 265
  return (0);
}
}
#line 268 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_rws(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 270
  tmp = atoi((char const   *)value);
  }
#line 270
  if (tmp < -1) {
    {
#line 272
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"receive window size must be at least -1\n");
    }
#line 274
    return (-1);
  }
  {
#line 278
  if ((context & -257) == 3) {
#line 278
    goto case_3;
  }
#line 292
  if ((context & -257) == 2) {
#line 292
    goto case_2;
  }
#line 306
  goto switch_default;
  case_3: /* CIL Label */ 
#line 279
  if ((int )*(word + 0) == 99) {
    {
#line 280
    set_int(word, value, & ((struct lac *)item)->call_rws);
    }
  }
#line 281
  if ((int )*(word + 0) == 116) {
    {
#line 283
    set_int(word, value, & ((struct lac *)item)->tun_rws);
    }
#line 284
    if (((struct lac *)item)->tun_rws < 1) {
      {
#line 286
      snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"receive window size for tunnels must be at least 1\n");
      }
#line 288
      return (-1);
    }
  }
#line 291
  goto switch_break;
  case_2: /* CIL Label */ 
#line 293
  if ((int )*(word + 0) == 99) {
    {
#line 294
    set_int(word, value, & ((struct lns *)item)->call_rws);
    }
  }
#line 295
  if ((int )*(word + 0) == 116) {
    {
#line 297
    set_int(word, value, & ((struct lns *)item)->tun_rws);
    }
#line 298
    if (((struct lns *)item)->tun_rws < 1) {
      {
#line 300
      snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"receive window size for tunnels must be at least 1\n");
      }
#line 302
      return (-1);
    }
  }
#line 305
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 307
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 309
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 314 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_speed(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 316
  tmp = atoi((char const   *)value);
  }
#line 316
  if (tmp < 1) {
    {
#line 318
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"bps must be greater than zero\n");
    }
#line 320
    return (-1);
  }
  {
#line 324
  if ((context & -257) == 3) {
#line 324
    goto case_3;
  }
#line 335
  if ((context & -257) == 2) {
#line 335
    goto case_2;
  }
#line 346
  goto switch_default;
  case_3: /* CIL Label */ 
#line 325
  if ((int )*(word + 0) == 116) {
    {
#line 326
    set_int(word, value, & ((struct lac *)item)->txspeed);
    }
  } else
#line 327
  if ((int )*(word + 0) == 114) {
    {
#line 328
    set_int(word, value, & ((struct lac *)item)->rxspeed);
    }
  } else {
    {
#line 331
    set_int(word, value, & ((struct lac *)item)->rxspeed);
#line 332
    set_int(word, value, & ((struct lac *)item)->txspeed);
    }
  }
#line 334
  goto switch_break;
  case_2: /* CIL Label */ 
#line 336
  if ((int )*(word + 0) == 116) {
    {
#line 337
    set_int(word, value, & ((struct lns *)item)->txspeed);
    }
  } else
#line 338
  if ((int )*(word + 0) == 114) {
    {
#line 339
    set_int(word, value, & ((struct lns *)item)->rxspeed);
    }
  } else {
    {
#line 342
    set_int(word, value, & ((struct lns *)item)->rxspeed);
#line 343
    set_int(word, value, & ((struct lns *)item)->txspeed);
    }
  }
#line 345
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 347
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 349
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 351
  return (0);
}
}
#line 354 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_rmax(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 356
  tmp = atoi((char const   *)value);
  }
#line 356
  if (tmp < 1) {
    {
#line 358
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"rmax value must be at least 1\n");
    }
#line 359
    return (-1);
  }
  {
#line 363
  if ((context & -257) == 3) {
#line 363
    goto case_3;
  }
#line 369
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 367
  set_int(word, value, & ((struct lac *)item)->rmax);
  }
#line 368
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 370
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 372
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 374
  return (0);
}
}
#line 377 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_authfile(char *word , char *value , int context , void *item ) 
{ 
  size_t tmp ;

  {
  {
#line 379
  tmp = strlen((char const   *)value);
  }
#line 379
  if (! tmp) {
    {
#line 381
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"no filename specified for authentication\n");
    }
#line 383
    return (-1);
  }
  {
#line 387
  if ((context & -257) == 1) {
#line 387
    goto case_1;
  }
#line 395
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 392
  strncpy((char */* __restrict  */)(((struct global *)item)->authfile), (char const   */* __restrict  */)value,
          sizeof(((struct global *)item)->authfile));
  }
#line 394
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 396
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 398
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 400
  return (0);
}
}
#line 403 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_autodial(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 407
  if ((context & -257) == 3) {
#line 407
    goto case_3;
  }
#line 411
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 408
  tmp = set_boolean(word, value, & ((struct lac *)item)->autodial);
  }
#line 408
  if (tmp) {
#line 409
    return (-1);
  }
#line 410
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 412
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 414
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 416
  return (0);
}
}
#line 419 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_flow(char *word , char *value , int context , void *item ) 
{ 
  int v ;

  {
  {
#line 422
  set_boolean(word, value, & v);
  }
#line 423
  if (v < 0) {
#line 424
    return (-1);
  }
  {
#line 427
  if ((context & -257) == 3) {
#line 427
    goto case_3;
  }
#line 438
  if ((context & -257) == 2) {
#line 438
    goto case_2;
  }
#line 449
  goto switch_default;
  case_3: /* CIL Label */ 
#line 428
  if (v) {
#line 430
    if (((struct lac *)item)->call_rws < 0) {
#line 431
      ((struct lac *)item)->call_rws = 0;
    }
  } else {
#line 435
    ((struct lac *)item)->call_rws = -1;
  }
#line 437
  goto switch_break;
  case_2: /* CIL Label */ 
#line 439
  if (v) {
#line 441
    if (((struct lns *)item)->call_rws < 0) {
#line 442
      ((struct lns *)item)->call_rws = 0;
    }
  } else {
#line 446
    ((struct lns *)item)->call_rws = -1;
  }
#line 448
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 450
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 452
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 454
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_defaultroute(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 461
  if ((context & -257) == 3) {
#line 461
    goto case_3;
  }
#line 465
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 462
  tmp = set_boolean(word, value, & ((struct lac *)item)->defaultroute);
  }
#line 462
  if (tmp) {
#line 463
    return (-1);
  }
#line 464
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 466
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 468
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 470
  return (0);
}
}
#line 473 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_authname(char *word , char *value , int context , void *item ) 
{ 
  struct lac *l ;
  struct lns *n ;
  int tmp ;
  int tmp___0 ;

  {
#line 475
  l = (struct lac *)item;
#line 476
  n = (struct lns *)item;
  {
#line 479
  if ((context & -257) == 2) {
#line 479
    goto case_2;
  }
#line 483
  if ((context & -257) == 3) {
#line 483
    goto case_3;
  }
#line 487
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 480
  tmp = set_string(word, value, n->authname, (int )sizeof(n->authname));
  }
#line 480
  if (tmp) {
#line 481
    return (-1);
  }
#line 482
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 484
  tmp___0 = set_string(word, value, l->authname, (int )sizeof(l->authname));
  }
#line 484
  if (tmp___0) {
#line 485
    return (-1);
  }
#line 486
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 488
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 490
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 492
  return (0);
}
}
#line 495 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_hostname(char *word , char *value , int context , void *item ) 
{ 
  struct lac *l ;
  struct lns *n ;
  int tmp ;
  int tmp___0 ;

  {
#line 497
  l = (struct lac *)item;
#line 498
  n = (struct lns *)item;
  {
#line 501
  if ((context & -257) == 2) {
#line 501
    goto case_2;
  }
#line 505
  if ((context & -257) == 3) {
#line 505
    goto case_3;
  }
#line 509
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 502
  tmp = set_string(word, value, n->hostname, (int )sizeof(n->hostname));
  }
#line 502
  if (tmp) {
#line 503
    return (-1);
  }
#line 504
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 506
  tmp___0 = set_string(word, value, l->hostname, (int )sizeof(l->hostname));
  }
#line 506
  if (tmp___0) {
#line 507
    return (-1);
  }
#line 508
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 510
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 512
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 514
  return (0);
}
}
#line 517 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_passwdauth(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 521
  if ((context & -257) == 2) {
#line 521
    goto case_2;
  }
#line 525
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 522
  tmp = set_boolean(word, value, & ((struct lns *)item)->passwdauth);
  }
#line 522
  if (tmp) {
#line 523
    return (-1);
  }
#line 524
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 526
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 528
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 530
  return (0);
}
}
#line 533 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_hbit(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 537
  if ((context & -257) == 3) {
#line 537
    goto case_3;
  }
#line 541
  if ((context & -257) == 2) {
#line 541
    goto case_2;
  }
#line 545
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 538
  tmp = set_boolean(word, value, & ((struct lac *)item)->hbit);
  }
#line 538
  if (tmp) {
#line 539
    return (-1);
  }
#line 540
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 542
  tmp___0 = set_boolean(word, value, & ((struct lns *)item)->hbit);
  }
#line 542
  if (tmp___0) {
#line 543
    return (-1);
  }
#line 544
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 546
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 548
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 550
  return (0);
}
}
#line 553 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_challenge(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 557
  if ((context & -257) == 3) {
#line 557
    goto case_3;
  }
#line 561
  if ((context & -257) == 2) {
#line 561
    goto case_2;
  }
#line 565
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 558
  tmp = set_boolean(word, value, & ((struct lac *)item)->challenge);
  }
#line 558
  if (tmp) {
#line 559
    return (-1);
  }
#line 560
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 562
  tmp___0 = set_boolean(word, value, & ((struct lns *)item)->challenge);
  }
#line 562
  if (tmp___0) {
#line 563
    return (-1);
  }
#line 564
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 566
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 568
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 573 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_lbit(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 577
  if ((context & -257) == 3) {
#line 577
    goto case_3;
  }
#line 581
  if ((context & -257) == 2) {
#line 581
    goto case_2;
  }
#line 585
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 578
  tmp = set_boolean(word, value, & ((struct lac *)item)->lbit);
  }
#line 578
  if (tmp) {
#line 579
    return (-1);
  }
#line 580
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 582
  tmp___0 = set_boolean(word, value, & ((struct lns *)item)->lbit);
  }
#line 582
  if (tmp___0) {
#line 583
    return (-1);
  }
#line 584
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 586
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 588
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 590
  return (0);
}
}
#line 594 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_debug(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 598
  if ((context & -257) == 3) {
#line 598
    goto case_3;
  }
#line 602
  if ((context & -257) == 2) {
#line 602
    goto case_2;
  }
#line 606
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 599
  tmp = set_boolean(word, value, & ((struct lac *)item)->debug);
  }
#line 599
  if (tmp) {
#line 600
    return (-1);
  }
#line 601
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 603
  tmp___0 = set_boolean(word, value, & ((struct lns *)item)->debug);
  }
#line 603
  if (tmp___0) {
#line 604
    return (-1);
  }
#line 605
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 607
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 609
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 611
  return (0);
}
}
#line 614 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_pass_peer(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 618
  if ((context & -257) == 3) {
#line 618
    goto case_3;
  }
#line 622
  if ((context & -257) == 2) {
#line 622
    goto case_2;
  }
#line 626
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 619
  tmp = set_boolean(word, value, & ((struct lac *)item)->pass_peer);
  }
#line 619
  if (tmp) {
#line 620
    return (-1);
  }
#line 621
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 623
  tmp___0 = set_boolean(word, value, & ((struct lns *)item)->pass_peer);
  }
#line 623
  if (tmp___0) {
#line 624
    return (-1);
  }
#line 625
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 627
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 629
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 631
  return (0);
}
}
#line 634 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_pppoptfile(char *word , char *value , int context , void *item ) 
{ 
  struct lac *l ;
  struct lns *n ;
  int tmp ;
  int tmp___0 ;

  {
#line 636
  l = (struct lac *)item;
#line 637
  n = (struct lns *)item;
  {
#line 640
  if ((context & -257) == 2) {
#line 640
    goto case_2;
  }
#line 644
  if ((context & -257) == 3) {
#line 644
    goto case_3;
  }
#line 648
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 641
  tmp = set_string(word, value, n->pppoptfile, (int )sizeof(n->pppoptfile));
  }
#line 641
  if (tmp) {
#line 642
    return (-1);
  }
#line 643
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 645
  tmp___0 = set_string(word, value, l->pppoptfile, (int )sizeof(l->pppoptfile));
  }
#line 645
  if (tmp___0) {
#line 646
    return (-1);
  }
#line 647
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 649
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 651
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 653
  return (0);
}
}
#line 656 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_papchap(char *word , char *value , int context , void *item ) 
{ 
  int result ;
  char *c ;
  struct lac *l ;
  struct lns *n ;
  int tmp ;

  {
  {
#line 660
  l = (struct lac *)item;
#line 661
  n = (struct lns *)item;
#line 662
  tmp = set_boolean(word, value, & result);
  }
#line 662
  if (tmp) {
#line 663
    return (-1);
  }
  {
#line 664
  c = strchr((char const   *)word, ' ');
#line 665
  c ++;
  }
  {
#line 668
  if ((context & -257) == 3) {
#line 668
    goto case_3;
  }
#line 684
  if ((context & -257) == 2) {
#line 684
    goto case_2;
  }
#line 700
  goto switch_default;
  case_3: /* CIL Label */ 
#line 669
  if ((int )*(c + 0) == 112) {
#line 670
    if ((int )*(word + 2) == 102) {
#line 671
      l->pap_refuse = result;
    } else {
#line 673
      l->pap_require = result;
    }
  } else
#line 674
  if ((int )*(c + 0) == 97) {
#line 675
    if ((int )*(word + 2) == 102) {
#line 676
      l->authself = ! result;
    } else {
#line 678
      l->authpeer = result;
    }
  } else
#line 679
  if ((int )*(word + 2) == 102) {
#line 680
    l->chap_refuse = result;
  } else {
#line 682
    l->chap_require = result;
  }
#line 683
  goto switch_break;
  case_2: /* CIL Label */ 
#line 685
  if ((int )*(c + 0) == 112) {
#line 686
    if ((int )*(word + 2) == 102) {
#line 687
      n->pap_refuse = result;
    } else {
#line 689
      n->pap_require = result;
    }
  } else
#line 690
  if ((int )*(c + 0) == 97) {
#line 691
    if ((int )*(word + 2) == 102) {
#line 692
      n->authself = ! result;
    } else {
#line 694
      n->authpeer = result;
    }
  } else
#line 695
  if ((int )*(word + 2) == 102) {
#line 696
    n->chap_refuse = result;
  } else {
#line 698
    n->chap_require = result;
  }
#line 699
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 701
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 703
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 705
  return (0);
}
}
#line 708 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_redial(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 712
  if ((context & -257) == 3) {
#line 712
    goto case_3;
  }
#line 716
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 713
  tmp = set_boolean(word, value, & ((struct lac *)item)->redial);
  }
#line 713
  if (tmp) {
#line 714
    return (-1);
  }
#line 715
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 717
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 719
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 721
  return (0);
}
}
#line 724 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_accesscontrol(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 728
  if ((context & -257) == 1) {
#line 728
    goto case_1;
  }
#line 733
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 729
  tmp = set_boolean(word, value, & ((struct global *)item)->accesscontrol);
  }
#line 729
  if (tmp) {
#line 731
    return (-1);
  }
#line 732
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 734
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 736
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 738
  return (0);
}
}
#line 741 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_userspace(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 745
  if ((context & -257) == 1) {
#line 745
    goto case_1;
  }
#line 750
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 746
  tmp = set_boolean(word, value, & ((struct global *)item)->forceuserspace);
  }
#line 746
  if (tmp) {
#line 748
    return (-1);
  }
#line 749
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 751
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 753
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 755
  return (0);
}
}
#line 758 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_debugavp(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 762
  if ((context & -257) == 1) {
#line 762
    goto case_1;
  }
#line 767
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 763
  tmp = set_boolean(word, value, & ((struct global *)item)->debug_avp);
  }
#line 763
  if (tmp) {
#line 765
    return (-1);
  }
#line 766
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 768
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 770
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 772
  return (0);
}
}
#line 775 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_debugnetwork(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 779
  if ((context & -257) == 1) {
#line 779
    goto case_1;
  }
#line 784
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 780
  tmp = set_boolean(word, value, & ((struct global *)item)->debug_network);
  }
#line 780
  if (tmp) {
#line 782
    return (-1);
  }
#line 783
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 785
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 787
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 789
  return (0);
}
}
#line 792 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_debugpacket(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 796
  if ((context & -257) == 1) {
#line 796
    goto case_1;
  }
#line 801
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 797
  tmp = set_boolean(word, value, & ((struct global *)item)->packet_dump);
  }
#line 797
  if (tmp) {
#line 799
    return (-1);
  }
#line 800
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 802
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 804
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 806
  return (0);
}
}
#line 809 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_debugtunnel(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 813
  if ((context & -257) == 1) {
#line 813
    goto case_1;
  }
#line 818
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 814
  tmp = set_boolean(word, value, & ((struct global *)item)->debug_tunnel);
  }
#line 814
  if (tmp) {
#line 816
    return (-1);
  }
#line 817
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 819
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 821
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 823
  return (0);
}
}
#line 826 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_debugstate(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 830
  if ((context & -257) == 1) {
#line 830
    goto case_1;
  }
#line 835
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 831
  tmp = set_boolean(word, value, & ((struct global *)item)->debug_state);
  }
#line 831
  if (tmp) {
#line 833
    return (-1);
  }
#line 834
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 836
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 838
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 840
  return (0);
}
}
#line 843 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_assignip(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 847
  if ((context & -257) == 2) {
#line 847
    goto case_2;
  }
#line 851
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 848
  tmp = set_boolean(word, value, & ((struct lns *)item)->assign_ip);
  }
#line 848
  if (tmp) {
#line 849
    return (-1);
  }
#line 850
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 852
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 854
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 856
  return (0);
}
}
#line 859 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
struct iprange *set_range(char *word , char *value , struct iprange *in ) 
{ 
  char *c ;
  char *d ;
  char *e ;
  struct iprange *ipr ;
  struct iprange *p ;
  struct hostent *hp ;
  int count ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char ip_hi[16] ;
  char *tmp___3 ;
  size_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
  {
#line 861
  d = (char *)((void *)0);
#line 861
  e = (char *)((void *)0);
#line 864
  count = 0;
#line 865
  c = strchr((char const   *)value, '-');
  }
#line 866
  if (c) {
#line 868
    d = c + 1;
#line 869
    *c = (char)0;
    {
#line 870
    while (1) {
      while_continue: /* CIL Label */ ;
#line 870
      if ((unsigned long )c >= (unsigned long )value) {
#line 870
        if (! ((int )*c < 33)) {
#line 870
          goto while_break;
        }
      } else {
#line 870
        goto while_break;
      }
#line 871
      tmp = c;
#line 871
      c --;
#line 871
      *tmp = (char)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 872
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 872
      if (*d) {
#line 872
        if (! ((int )*d < 33)) {
#line 872
          goto while_break___0;
        }
      } else {
#line 872
        goto while_break___0;
      }
#line 873
      d ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 875
  tmp___0 = strlen((char const   *)value);
  }
#line 875
  if (tmp___0) {
#line 875
    if (c) {
      {
#line 875
      tmp___1 = strlen((char const   *)d);
      }
#line 875
      if (! tmp___1) {
        {
#line 877
        snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"format is \'%s <host or ip> - <host or ip>\'\n",
                 word);
        }
#line 879
        return ((struct iprange *)((void *)0));
      }
    }
  } else {
    {
#line 877
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"format is \'%s <host or ip> - <host or ip>\'\n",
             word);
    }
#line 879
    return ((struct iprange *)((void *)0));
  }
  {
#line 881
  tmp___2 = malloc(sizeof(struct iprange ));
#line 881
  ipr = (struct iprange *)tmp___2;
#line 882
  ipr->next = (struct iprange *)((void *)0);
#line 883
  hp = gethostbyname((char const   *)value);
  }
#line 884
  if (! hp) {
    {
#line 886
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"Unknown host %s\n",
             value);
#line 887
    free((void *)ipr);
    }
#line 888
    return ((struct iprange *)((void *)0));
  }
  {
#line 890
  bcopy((void const   *)*(hp->h_addr_list + 0), (void *)(& ipr->start), sizeof(unsigned int ));
  }
#line 891
  if (c) {
#line 895
    e = d;
    {
#line 896
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 896
      if (! ((int )*e != 0)) {
#line 896
        goto while_break___1;
      }
#line 897
      tmp___3 = e;
#line 897
      e ++;
#line 897
      if ((int )*tmp___3 == 46) {
#line 898
        count ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 900
    if (count < 3) {
      {
#line 901
      strcpy((char */* __restrict  */)(ip_hi), (char const   */* __restrict  */)value);
#line 902
      e = ip_hi + sizeof(ip_hi);
      }
      {
#line 902
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 902
        if (! ((unsigned long )e >= (unsigned long )(ip_hi))) {
#line 902
          goto while_break___2;
        }
#line 903
        if ((int )*e == 46) {
#line 903
          count --;
        }
#line 904
        if (count < 0) {
#line 905
          e ++;
#line 906
          goto while_break___2;
        }
#line 902
        e --;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 910
      tmp___4 = strlen((char const   *)d);
      }
#line 910
      if ((size_t )((ip_hi + sizeof(ip_hi)) - e) > tmp___4) {
        {
#line 911
        strcpy((char */* __restrict  */)e, (char const   */* __restrict  */)d);
#line 912
        d = ip_hi;
        }
      }
    }
    {
#line 915
    hp = gethostbyname((char const   *)d);
    }
#line 916
    if (! hp) {
      {
#line 918
      snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"Unknown host %s\n",
               d);
#line 919
      free((void *)ipr);
      }
#line 920
      return ((struct iprange *)((void *)0));
    }
    {
#line 922
    bcopy((void const   *)*(hp->h_addr_list + 0), (void *)(& ipr->end), sizeof(unsigned int ));
    }
  } else {
#line 925
    ipr->end = ipr->start;
  }
  {
#line 926
  tmp___5 = ntohl(ipr->start);
#line 926
  tmp___6 = ntohl(ipr->end);
  }
#line 926
  if (tmp___5 > tmp___6) {
    {
#line 928
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"start is greater than end!\n");
#line 929
    free((void *)ipr);
    }
#line 930
    return ((struct iprange *)((void *)0));
  }
#line 932
  if ((int )*(word + 0) == 110) {
#line 933
    ipr->sense = 0;
  } else {
#line 935
    ipr->sense = -1;
  }
#line 936
  p = in;
#line 937
  if (p) {
    {
#line 939
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 939
      if (! p->next) {
#line 939
        goto while_break___3;
      }
#line 940
      p = p->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 941
    p->next = ipr;
#line 942
    return (in);
  } else {
#line 945
    return (ipr);
  }
}
}
#line 948 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_iprange(char *word , char *value , int context , void *item ) 
{ 
  struct lns *lns ;

  {
#line 950
  lns = (struct lns *)item;
  {
#line 953
  if ((context & -257) == 2) {
#line 953
    goto case_2;
  }
#line 955
  goto switch_default;
  case_2: /* CIL Label */ 
#line 954
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 956
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 958
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 960
  lns->range = set_range(word, value, lns->range);
  }
#line 961
  if (! lns->range) {
#line 962
    return (-1);
  }
#line 967
  return (0);
}
}
#line 970 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_lac(char *word , char *value , int context , void *item ) 
{ 
  struct lns *lns ;

  {
#line 972
  lns = (struct lns *)item;
  {
#line 975
  if ((context & -257) == 2) {
#line 975
    goto case_2;
  }
#line 977
  goto switch_default;
  case_2: /* CIL Label */ 
#line 976
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 978
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 980
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 982
  lns->lacs = set_range(word, value, lns->lacs);
  }
#line 983
  if (! lns->lacs) {
#line 984
    return (-1);
  }
#line 989
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_exclusive(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 996
  if ((context & -257) == 2) {
#line 996
    goto case_2;
  }
#line 1000
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 997
  tmp = set_boolean(word, value, & ((struct lns *)item)->exclusive);
  }
#line 997
  if (tmp) {
#line 998
    return (-1);
  }
#line 999
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1001
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 1003
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1005
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_ip(char *word , char *value , unsigned int *addr ) 
{ 
  struct hostent *hp ;

  {
  {
#line 1011
  hp = gethostbyname((char const   *)value);
  }
#line 1012
  if (! hp) {
    {
#line 1014
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"%s: host \'%s\' not found\n",
             "set_ip", value);
    }
#line 1016
    return (-1);
  }
  {
#line 1018
  bcopy((void const   *)*(hp->h_addr_list + 0), (void *)addr, sizeof(unsigned int ));
  }
#line 1019
  return (0);
}
}
#line 1022 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_listenaddr(char *word , char *value , int context , void *item ) 
{ 
  int tmp ;

  {
  {
#line 1026
  if ((context & -257) == 1) {
#line 1026
    goto case_1;
  }
#line 1034
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1031
  tmp = set_ip(word, value, & ((struct global *)item)->listenaddr);
  }
#line 1031
  if (tmp) {
#line 1032
    return (-1);
  }
#line 1033
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1035
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 1037
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 1042 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_localaddr(char *word , char *value , int context , void *item ) 
{ 
  struct lac *l ;
  struct lns *n ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1048
  if ((context & -257) == 3) {
#line 1048
    goto case_3;
  }
#line 1051
  if ((context & -257) == 2) {
#line 1051
    goto case_2;
  }
#line 1054
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 1049
  l = (struct lac *)item;
#line 1050
  tmp = set_ip(word, value, & l->localaddr);
  }
#line 1050
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 1052
  n = (struct lns *)item;
#line 1053
  tmp___0 = set_ip(word, value, & n->localaddr);
  }
#line 1053
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 1055
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 1057
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1059
  return (0);
}
}
#line 1062 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_remoteaddr(char *word , char *value , int context , void *item ) 
{ 
  struct lac *l ;
  int tmp ;

  {
  {
#line 1067
  if ((context & -257) == 3) {
#line 1067
    goto case_3;
  }
#line 1070
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 1068
  l = (struct lac *)item;
#line 1069
  tmp = set_ip(word, value, & l->remoteaddr);
  }
#line 1069
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 1071
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 1073
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1075
  return (0);
}
}
#line 1078 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_lns(char *word , char *value , int context , void *item ) 
{ 
  struct lac *l ;
  struct host *ipr ;
  struct host *pos___0 ;
  char *d ;
  void *tmp ;

  {
  {
#line 1088
  if ((context & -257) == 3) {
#line 1088
    goto case_3;
  }
#line 1127
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 1092
  l = (struct lac *)item;
#line 1093
  d = strchr((char const   *)value, ':');
  }
#line 1094
  if (d) {
#line 1096
    *(d + 0) = (char)0;
#line 1097
    d ++;
  }
  {
#line 1108
  tmp = malloc(sizeof(struct host ));
#line 1108
  ipr = (struct host *)tmp;
#line 1109
  ipr->next = (struct host *)((void *)0);
#line 1110
  pos___0 = l->lns;
  }
#line 1111
  if (! pos___0) {
#line 1113
    l->lns = ipr;
  } else {
    {
#line 1117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1117
      if (! pos___0->next) {
#line 1117
        goto while_break;
      }
#line 1118
      pos___0 = pos___0->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1119
    pos___0->next = ipr;
  }
  {
#line 1121
  strncpy((char */* __restrict  */)(ipr->hostname), (char const   */* __restrict  */)value,
          sizeof(ipr->hostname));
  }
#line 1122
  if (d) {
    {
#line 1123
    ipr->port = atoi((char const   *)d);
    }
  } else {
#line 1125
    ipr->port = 1701;
  }
#line 1126
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1128
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 1130
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1132
  return (0);
}
}
#line 1135 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_rand_sys(void) 
{ 


  {
  {
#line 1137
  l2tp_log(4, "The \"rand()\" function call is not a very good sourceof randomness\n");
#line 1139
  rand_source = 1;
  }
#line 1140
  return (0);
}
}
#line 1143 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_ipsec_saref(char *word , char *value , int context , void *item ) 
{ 
  struct global *g ;
  int tmp ;

  {
#line 1145
  g = (struct global *)item;
  {
#line 1148
  if ((context & -257) == 1) {
#line 1148
    goto case_1;
  }
#line 1160
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1149
  tmp = set_boolean(word, value, & g->ipsecsaref);
  }
#line 1149
  if (tmp) {
#line 1151
    return (-1);
  }
#line 1152
  if (g->ipsecsaref) {
    {
#line 1153
    l2tp_log(6, "Enabling IPsec SAref processing for L2TP transport mode SAs\n");
    }
  }
#line 1155
  if (g->forceuserspace != 1) {
    {
#line 1156
    l2tp_log(4, "IPsec SAref does not work with L2TP kernel mode yet, enabling force userspace=yes\n");
#line 1157
    g->forceuserspace = 1;
    }
  }
#line 1159
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1161
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 1163
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1165
  return (0);
}
}
#line 1168 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_saref_num(char *word , char *value , int context , void *item ) 
{ 


  {
  {
#line 1172
  if ((context & -257) == 1) {
#line 1172
    goto case_1;
  }
#line 1176
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1173
  l2tp_log(6, "Setting SAref IP_IPSEC_REFINFO number to %s\n", value);
#line 1174
  set_int(word, value, & ((struct global *)item)->sarefnum);
  }
#line 1175
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1177
  snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"\'%s\' not valid in this context\n",
           word);
  }
#line 1178
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1180
  return (0);
}
}
#line 1183 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_rand_dev(void) 
{ 


  {
#line 1185
  rand_source = 0;
#line 1186
  return (0);
}
}
#line 1189 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_rand_egd(char *value ) 
{ 


  {
  {
#line 1191
  l2tp_log(4, "%s: not yet implemented!\n", "set_rand_egd");
#line 1192
  rand_source = 2;
  }
#line 1193
  return (-1);
}
}
#line 1196 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int set_rand_source(char *word , char *value , int context , void *item ) 
{ 
  time_t seconds ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1214
  seconds = time((time_t *)((void *)0));
#line 1215
  srand((unsigned int )seconds);
  }
#line 1217
  if (context != 1) {
    {
#line 1219
    l2tp_log(4, "%s: %s not valid in context %d\n", "set_rand_source", word, context);
    }
#line 1221
    return (-1);
  }
  {
#line 1224
  tmp = strlen((char const   *)value);
  }
#line 1224
  if (tmp == 0UL) {
    {
#line 1226
    snprintf((char */* __restrict  */)(filerr), sizeof(filerr), (char const   */* __restrict  */)"no randomness source specified\n");
    }
#line 1227
    return (-1);
  }
  {
#line 1229
  tmp___5 = strncmp((char const   *)value, "egd", (size_t )3);
  }
#line 1229
  if (tmp___5 == 0) {
    {
#line 1231
    tmp___0 = set_rand_egd(value);
    }
#line 1231
    return (tmp___0);
  } else {
    {
#line 1233
    tmp___4 = strncmp((char const   *)value, "dev", (size_t )3);
    }
#line 1233
    if (tmp___4 == 0) {
      {
#line 1235
      tmp___1 = set_rand_dev();
      }
#line 1235
      return (tmp___1);
    } else {
      {
#line 1237
      tmp___3 = strncmp((char const   *)value, "sys", (size_t )3);
      }
#line 1237
      if (tmp___3 == 0) {
        {
#line 1239
        tmp___2 = set_rand_sys();
        }
#line 1239
        return (tmp___2);
      } else {
        {
#line 1243
        l2tp_log(4, "%s: %s is not a valid randomness source\n", "set_rand_source",
                 value);
        }
#line 1245
        return (-1);
      }
    }
  }
}
}
#line 1250 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int parse_config(FILE *f ) 
{ 
  int context ;
  char buf[1024] ;
  char *s ;
  char *d ;
  char *t ;
  int linenum ;
  int def ;
  int in_comment ;
  int has_lf ;
  void *data ;
  struct lns *tl ;
  struct lac *tc ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct lns *tmp___7 ;
  int tmp___8 ;
  struct lac *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1254
  context = 0;
#line 1257
  linenum = 0;
#line 1258
  def = 0;
#line 1259
  in_comment = 0;
#line 1261
  data = (void *)0;
  {
#line 1264
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1264
    tmp___14 = feof(f);
    }
#line 1264
    if (tmp___14) {
#line 1264
      goto while_break;
    }
    {
#line 1266
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
    }
#line 1266
    if ((unsigned long )((void *)0) == (unsigned long )tmp) {
#line 1269
      goto while_break;
    }
    {
#line 1272
    tmp___0 = strlen((char const   *)(buf));
#line 1272
    has_lf = (int )buf[tmp___0 - 1UL] == 10;
    }
#line 1273
    if (in_comment) {
#line 1275
      in_comment = ! has_lf;
#line 1276
      goto while_continue;
    }
#line 1278
    linenum ++;
#line 1279
    s = buf;
    {
#line 1281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1281
      if (*s) {
#line 1281
        if (! ((int )*s != 59)) {
#line 1281
          goto while_break___0;
        }
      } else {
#line 1281
        goto while_break___0;
      }
#line 1282
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1283
    if ((int )*s == 59) {
#line 1283
      if (! has_lf) {
#line 1284
        in_comment = 1;
      }
    }
    {
#line 1285
    *s = (char)0;
#line 1286
    s = buf;
#line 1287
    tmp___1 = strlen((char const   *)(buf));
    }
#line 1287
    if (! tmp___1) {
#line 1288
      goto while_continue;
    }
    {
#line 1289
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1289
      if ((int )*s < 33) {
#line 1289
        if (! *s) {
#line 1289
          goto while_break___1;
        }
      } else {
#line 1289
        goto while_break___1;
      }
#line 1290
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1291
    tmp___2 = strlen((char const   *)s);
#line 1291
    t = s + tmp___2;
    }
    {
#line 1292
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1292
      if ((unsigned long )t >= (unsigned long )s) {
#line 1292
        if (! ((int )*t < 33)) {
#line 1292
          goto while_break___2;
        }
      } else {
#line 1292
        goto while_break___2;
      }
#line 1293
      tmp___3 = t;
#line 1293
      t --;
#line 1293
      *tmp___3 = (char)0;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1294
    tmp___4 = strlen((char const   *)s);
    }
#line 1294
    if (! tmp___4) {
#line 1295
      goto while_continue;
    }
#line 1296
    if ((int )*(s + 0) == 91) {
      {
#line 1299
      t = strchr((char const   *)s, ']');
      }
#line 1299
      if (! t) {
        {
#line 1301
        l2tp_log(2, "parse_config: line %d: No closing bracket\n", linenum);
        }
#line 1303
        return (-1);
      }
      {
#line 1305
      *(t + 0) = (char)0;
#line 1306
      s ++;
#line 1307
      d = strchr((char const   *)s, ' ');
      }
#line 1307
      if (d) {
#line 1310
        *(d + 0) = (char)0;
#line 1311
        d ++;
      }
#line 1313
      if (d) {
        {
#line 1313
        tmp___5 = strcasecmp((char const   *)d, "default");
        }
#line 1313
        if (tmp___5) {
#line 1316
          def = 0;
        } else {
#line 1314
          def = 256;
        }
      } else {
#line 1316
        def = 0;
      }
      {
#line 1317
      tmp___12 = strcasecmp((char const   *)s, "global");
      }
#line 1317
      if (tmp___12) {
        {
#line 1327
        tmp___11 = strcasecmp((char const   *)s, "lns");
        }
#line 1327
        if (tmp___11) {
          {
#line 1370
          tmp___10 = strcasecmp((char const   *)s, "lac");
          }
#line 1370
          if (tmp___10) {
            {
#line 1415
            l2tp_log(4, "parse_config: line %d: unknown context \'%s\'\n", linenum,
                     s);
            }
#line 1418
            return (-1);
          } else {
#line 1372
            context = 3;
#line 1373
            if (def) {
#line 1375
              if (! deflac) {
                {
#line 1377
                deflac = new_lac();
#line 1378
                strncpy((char */* __restrict  */)(deflac->entname), (char const   */* __restrict  */)"default",
                        sizeof(deflac->entname));
                }
              }
#line 1381
              data = (void *)deflac;
#line 1382
              goto while_continue;
            }
#line 1384
            data = (void *)0;
#line 1385
            tc = laclist;
#line 1386
            if (d) {
              {
#line 1388
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1388
                if (! tc) {
#line 1388
                  goto while_break___3;
                }
                {
#line 1390
                tmp___8 = strcasecmp((char const   *)d, (char const   *)(tc->entname));
                }
#line 1390
                if (! tmp___8) {
#line 1391
                  goto while_break___3;
                }
#line 1392
                tc = tc->next;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 1394
              if (tc) {
#line 1395
                data = (void *)tc;
              }
            }
#line 1397
            if (! data) {
              {
#line 1399
              tmp___9 = new_lac();
#line 1399
              data = (void *)tmp___9;
              }
#line 1400
              if (! data) {
#line 1401
                return (-1);
              }
#line 1402
              ((struct lac *)data)->next = laclist;
#line 1403
              laclist = (struct lac *)data;
            }
#line 1405
            if (d) {
              {
#line 1406
              strncpy((char */* __restrict  */)(((struct lac *)data)->entname), (char const   */* __restrict  */)d,
                      sizeof(((struct lac *)data)->entname));
              }
            }
          }
        } else {
#line 1329
          context = 2;
#line 1330
          if (def) {
#line 1332
            if (! deflns) {
              {
#line 1334
              deflns = new_lns();
#line 1335
              strncpy((char */* __restrict  */)(deflns->entname), (char const   */* __restrict  */)"default",
                      sizeof(deflns->entname));
              }
            }
#line 1338
            data = (void *)deflns;
#line 1339
            goto while_continue;
          }
#line 1341
          data = (void *)0;
#line 1342
          tl = lnslist;
#line 1343
          if (d) {
            {
#line 1345
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1345
              if (! tl) {
#line 1345
                goto while_break___4;
              }
              {
#line 1347
              tmp___6 = strcasecmp((char const   *)d, (char const   *)(tl->entname));
              }
#line 1347
              if (! tmp___6) {
#line 1348
                goto while_break___4;
              }
#line 1349
              tl = tl->next;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1351
            if (tl) {
#line 1352
              data = (void *)tl;
            }
          }
#line 1354
          if (! data) {
            {
#line 1356
            tmp___7 = new_lns();
#line 1356
            data = (void *)tmp___7;
            }
#line 1357
            if (! data) {
#line 1358
              return (-1);
            }
#line 1359
            ((struct lns *)data)->next = lnslist;
#line 1360
            lnslist = (struct lns *)data;
          }
#line 1362
          if (d) {
            {
#line 1363
            strncpy((char */* __restrict  */)(((struct lns *)data)->entname), (char const   */* __restrict  */)d,
                    sizeof(((struct lns *)data)->entname));
            }
          }
        }
      } else {
#line 1319
        context = 1;
#line 1325
        data = (void *)(& gconfig);
      }
    } else {
#line 1423
      if (! context) {
        {
#line 1425
        l2tp_log(4, "parse_config: line %d: data \'%s\' occurs with no context\n",
                 linenum, s);
        }
#line 1428
        return (-1);
      }
      {
#line 1430
      t = strchr((char const   *)s, '=');
      }
#line 1430
      if (! t) {
        {
#line 1432
        l2tp_log(4, "parse_config: line %d: line too long or no \'=\' in data\n",
                 linenum);
        }
#line 1434
        return (-1);
      }
#line 1436
      d = t;
#line 1437
      d --;
#line 1438
      t ++;
      {
#line 1439
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1439
        if ((unsigned long )d >= (unsigned long )s) {
#line 1439
          if (! ((int )*d < 33)) {
#line 1439
            goto while_break___5;
          }
        } else {
#line 1439
          goto while_break___5;
        }
#line 1440
        d --;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1441
      d ++;
#line 1442
      *d = (char)0;
      {
#line 1443
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1443
        if (*t) {
#line 1443
          if (! ((int )*t < 33)) {
#line 1443
            goto while_break___6;
          }
        } else {
#line 1443
          goto while_break___6;
        }
#line 1444
        t ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1450
      tmp___13 = parse_one_option(s, t, context | def, data);
      }
      {
#line 1452
      if (tmp___13 == -1) {
#line 1452
        goto case_neg_1;
      }
#line 1456
      if (tmp___13 == -2) {
#line 1456
        goto case_neg_2;
      }
#line 1450
      goto switch_break;
      case_neg_1: /* CIL Label */ 
      {
#line 1453
      l2tp_log(4, "parse_config: line %d: %s", linenum, filerr);
      }
#line 1455
      return (-1);
      case_neg_2: /* CIL Label */ 
      {
#line 1457
      l2tp_log(2, "parse_config: line %d: Unknown field \'%s\'\n", linenum, s);
      }
#line 1459
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1463
  return (0);
}
}
#line 1466 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
int parse_one_option(char *word , char *value , int context , void *item ) 
{ 
  struct keyword *kw ;
  int tmp ;
  int tmp___0 ;

  {
#line 1470
  kw = words;
  {
#line 1470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1470
    if (! kw->keyword) {
#line 1470
      goto while_break;
    }
    {
#line 1472
    tmp___0 = strcasecmp((char const   *)word, (char const   *)kw->keyword);
    }
#line 1472
    if (! tmp___0) {
      {
#line 1474
      tmp = (*(kw->handler))(word, value, context, item);
      }
#line 1474
      if (tmp) {
#line 1476
        return (-1);
      }
#line 1478
      goto while_break;
    }
#line 1470
    kw ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1481
  if (! kw->keyword) {
#line 1483
    return (-2);
  }
#line 1485
  return (0);
}
}
#line 1488 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/file.c"
struct keyword words[52]  = 
#line 1488
  {      {(char *)"listen-addr", & set_listenaddr}, 
        {(char *)"port", & set_port}, 
        {(char *)"saref refinfo", & set_saref_num}, 
        {(char *)"rand source", & set_rand_source}, 
        {(char *)"auth file", & set_authfile}, 
        {(char *)"exclusive", & set_exclusive}, 
        {(char *)"autodial", & set_autodial}, 
        {(char *)"redial", & set_redial}, 
        {(char *)"redial timeout", & set_rtimeout}, 
        {(char *)"lns", & set_lns}, 
        {(char *)"max redials", & set_rmax}, 
        {(char *)"access control", & set_accesscontrol}, 
        {(char *)"force userspace", & set_userspace}, 
        {(char *)"ip range", & set_iprange}, 
        {(char *)"no ip range", & set_iprange}, 
        {(char *)"debug avp", & set_debugavp}, 
        {(char *)"debug network", & set_debugnetwork}, 
        {(char *)"debug packet", & set_debugpacket}, 
        {(char *)"debug tunnel", & set_debugtunnel}, 
        {(char *)"debug state", & set_debugstate}, 
        {(char *)"ipsec saref", & set_ipsec_saref}, 
        {(char *)"lac", & set_lac}, 
        {(char *)"no lac", & set_lac}, 
        {(char *)"assign ip", & set_assignip}, 
        {(char *)"local ip", & set_localaddr}, 
        {(char *)"remote ip", & set_remoteaddr}, 
        {(char *)"defaultroute", & set_defaultroute}, 
        {(char *)"length bit", & set_lbit}, 
        {(char *)"hidden bit", & set_hbit}, 
        {(char *)"require pap", & set_papchap}, 
        {(char *)"require chap", & set_papchap}, 
        {(char *)"require authentication", & set_papchap}, 
        {(char *)"require auth", & set_papchap}, 
        {(char *)"refuse pap", & set_papchap}, 
        {(char *)"refuse chap", & set_papchap}, 
        {(char *)"refuse authentication", & set_papchap}, 
        {(char *)"refuse auth", & set_papchap}, 
        {(char *)"unix authentication", & set_passwdauth}, 
        {(char *)"unix auth", & set_passwdauth}, 
        {(char *)"name", & set_authname}, 
        {(char *)"hostname", & set_hostname}, 
        {(char *)"ppp debug", & set_debug}, 
        {(char *)"pass peer", & set_pass_peer}, 
        {(char *)"pppoptfile", & set_pppoptfile}, 
        {(char *)"call rws", & set_rws}, 
        {(char *)"tunnel rws", & set_rws}, 
        {(char *)"flow bit", & set_flow}, 
        {(char *)"challenge", & set_challenge}, 
        {(char *)"tx bps", & set_speed}, 
        {(char *)"rx bps", & set_speed}, 
        {(char *)"bps", & set_speed}, 
        {(char *)((void *)0), (int (*)(char *word , char *value , int context , void *item ))((void *)0)}};
#line 56 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.h"
struct buffer *new_outgoing(struct tunnel *t ) ;
#line 57
void add_control_hdr(struct tunnel *t , struct call *c , struct buffer *buf ) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.h"
void unreserve_addr(unsigned int addr ) ;
#line 55
void mk_challenge(unsigned char *c , int length ) ;
#line 216 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/l2tp.h"
struct buffer *new_payload(struct sockaddr_in peer ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
struct buffer *new_payload(struct sockaddr_in peer ) 
{ 
  struct buffer *tmp ;
  struct buffer *tmp___0 ;

  {
  {
#line 33
  tmp___0 = new_buf(4096);
#line 33
  tmp = tmp___0;
  }
#line 34
  if (! tmp) {
#line 35
    return ((struct buffer *)((void *)0));
  }
#line 36
  tmp->peer = peer;
#line 37
  tmp->start += sizeof(struct payload_hdr );
#line 38
  tmp->len = 0;
#line 39
  return (tmp);
}
}
#line 42 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
void recycle_payload(struct buffer *buf , struct sockaddr_in peer ) 
{ 


  {
#line 44
  buf->start = buf->rstart + sizeof(struct payload_hdr );
#line 45
  buf->len = 0;
#line 46
  buf->peer = peer;
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
void add_payload_hdr(struct tunnel *t , struct call *c , struct buffer *buf ) 
{ 
  struct payload_hdr *p ;

  {
#line 52
  buf->start -= sizeof(struct payload_hdr );
#line 53
  buf->len = (int )((unsigned long )buf->len + sizeof(struct payload_hdr ));
#line 55
  buf->start += 2;
#line 56
  buf->len -= 2;
#line 57
  if (! c->fbit) {
#line 57
    if (! c->ourfbit) {
#line 60
      buf->start += 4;
#line 61
      buf->len -= 4;
    }
  }
#line 63
  if (! c->lbit) {
#line 66
    buf->start += 2;
#line 67
    buf->len -= 2;
  }
  {
#line 69
  p = (struct payload_hdr *)buf->start;
#line 71
  p->ver = htons((uint16_t )(((c->lbit | c->fbit) | c->ourfbit) | 2));
  }
#line 72
  if (c->lbit) {
    {
#line 74
    p->length = htons((_u16 )buf->len);
    }
  } else {
#line 78
    p = (struct payload_hdr *)((char *)p - 2);
  }
  {
#line 80
  p->tid = htons((uint16_t )t->tid);
#line 81
  p->cid = htons((uint16_t )c->cid);
  }
#line 82
  if (c->fbit) {
    {
#line 84
    p->Ns = htons(c->data_seq_num);
#line 85
    p->Nr = htons(c->data_rec_seq_num);
    }
  } else
#line 82
  if (c->ourfbit) {
    {
#line 84
    p->Ns = htons(c->data_seq_num);
#line 85
    p->Nr = htons(c->data_rec_seq_num);
    }
  }
#line 87
  c->data_seq_num = (_u16 )((int )c->data_seq_num + 1);
#line 89
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
static unsigned char rbuf[4096]  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
static int pos  =    0;
#line 98 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
static int max  =    0;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
int read_packet(struct buffer *buf , int fd , int convert ) 
{ 
  unsigned char c ;
  unsigned char escape ;
  unsigned char *p ;
  int res ;
  int errors ;
  ssize_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 94
  escape = (unsigned char)0;
#line 100
  errors = 0;
#line 103
  p = (unsigned char *)buf->start;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (pos >= max) {
      {
#line 108
      tmp = read(fd, (void *)(rbuf), sizeof(rbuf));
#line 108
      max = (int )tmp;
#line 109
      res = max;
#line 110
      pos = 0;
      }
    } else {
#line 114
      res = 1;
    }
#line 117
    tmp___0 = pos;
#line 117
    pos ++;
#line 117
    c = rbuf[tmp___0];
#line 120
    if (res < 1) {
#line 122
      if (res == 0) {
#line 127
        return (0);
      } else {
        {
#line 129
        tmp___1 = __errno_location();
        }
#line 129
        if (*tmp___1 == 5) {
#line 138
          return (0);
        } else {
          {
#line 129
          tmp___2 = __errno_location();
          }
#line 129
          if (*tmp___2 == 4) {
#line 138
            return (0);
          } else {
            {
#line 129
            tmp___3 = __errno_location();
            }
#line 129
            if (*tmp___3 == 11) {
#line 138
              return (0);
            }
          }
        }
      }
      {
#line 140
      errors ++;
#line 141
      tmp___4 = __errno_location();
#line 141
      tmp___5 = strerror(*tmp___4);
#line 141
      tmp___6 = __errno_location();
#line 141
      l2tp_log(7, "%s: Error %d (%s)\n", "read_packet", *tmp___6, tmp___5);
      }
#line 143
      if (errors > 10) {
        {
#line 145
        l2tp_log(7, "%s: Too many errors.  Declaring call dead.\n", "read_packet");
#line 148
        pos = 0;
#line 149
        max = 0;
#line 150
        tmp___7 = __errno_location();
        }
#line 150
        return (- *tmp___7);
      }
#line 152
      goto while_continue;
    }
    {
#line 157
    if ((int )c == 126) {
#line 157
      goto case_126;
    }
#line 197
    if ((int )c == 125) {
#line 197
      goto case_125;
    }
#line 203
    goto switch_default;
    case_126: /* CIL Label */ 
#line 158
    if (escape) {
      {
#line 160
      l2tp_log(7, "%s: got an escaped PPP_FLAG\n", "read_packet");
#line 162
      pos = 0;
#line 163
      max = 0;
      }
#line 164
      return (-22);
    }
#line 167
    if (convert) {
#line 169
      if (buf->len >= 2) {
#line 171
        buf->len -= 2;
      } else
#line 173
      if (! (buf->len == 1)) {
#line 180
        goto switch_break;
      }
    } else
#line 186
    if (buf->len < buf->maxlen) {
#line 188
      *p = c;
#line 189
      p ++;
#line 190
      (buf->len) ++;
    }
#line 195
    return (buf->len);
    case_125: /* CIL Label */ 
#line 198
    escape = (unsigned char)32;
#line 199
    if (convert) {
#line 200
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 204
    if (convert) {
#line 205
      c = (unsigned char )((int )c ^ (int )escape);
    }
#line 206
    escape = (unsigned char)0;
#line 207
    if (buf->len < buf->maxlen) {
#line 209
      *p = c;
#line 210
      p ++;
#line 211
      (buf->len) ++;
#line 212
      goto switch_break;
    }
    {
#line 214
    l2tp_log(4, "%s: read overrun\n", "read_packet");
#line 215
    pos = 0;
#line 216
    max = 0;
    }
#line 217
    return (-22);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  l2tp_log(4, "%s: You should not see this message.  If you do, please enter a bug report at http://lists.xelerance.com/mailman/listinfo/xl2tpd",
           "read_packet");
  }
#line 224
  return (-22);
}
}
#line 227 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
void call_close(struct call *c ) 
{ 
  struct buffer *buf ;
  struct schedule_entry *se ;
  struct schedule_entry *ose ;
  struct call *tmp ;
  struct call *tmp2 ;
  size_t tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 232
  if (! c) {
    {
#line 234
    l2tp_log(7, "%s: called on null call or containerless call\n", "call_close");
    }
#line 236
    return;
  } else
#line 232
  if (! c->container) {
    {
#line 234
    l2tp_log(7, "%s: called on null call or containerless call\n", "call_close");
    }
#line 236
    return;
  }
#line 238
  if ((unsigned long )c == (unsigned long )(c->container)->self) {
#line 250
    se = events;
#line 251
    ose = (struct schedule_entry *)((void *)0);
    {
#line 252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 252
      if (! se) {
#line 252
        goto while_break;
      }
#line 254
      if ((unsigned long )((struct buffer *)se->data)->tunnel == (unsigned long )c->container) {
#line 254
        goto _L;
      } else
#line 254
      if ((unsigned long )((struct tunnel *)se->data) == (unsigned long )c->container) {
        _L: /* CIL Label */ 
#line 260
        if (ose) {
#line 262
          ose->next = se->next;
#line 263
          if ((unsigned long )((struct tunnel *)se->data) != (unsigned long )c->container) {
            {
#line 264
            toss((struct buffer *)se->data);
            }
          }
          {
#line 265
          free((void *)se);
#line 266
          se = ose->next;
          }
        } else {
#line 270
          events = se->next;
#line 271
          if ((unsigned long )((struct tunnel *)se->data) != (unsigned long )c->container) {
            {
#line 272
            toss((struct buffer *)se->data);
            }
          }
          {
#line 273
          free((void *)se);
#line 274
          se = events;
          }
        }
      } else {
#line 279
        ose = se;
#line 280
        se = se->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 284
    if (c->closing) {
      {
#line 292
      destroy_tunnel(c->container);
      }
#line 293
      return;
    }
    {
#line 301
    c->closeSs = (c->container)->control_seq_num;
#line 302
    buf = new_outgoing(c->container);
#line 303
    add_message_type_avp(buf, (_u16 )4);
    }
#line 304
    if ((c->container)->hbit) {
      {
#line 306
      mk_challenge((c->container)->chal_them.vector, 16);
#line 307
      add_randvect_avp(buf, (c->container)->chal_them.vector, 16);
      }
    }
    {
#line 310
    add_tunnelid_avp(buf, (_u16 )(c->container)->ourtid);
    }
#line 311
    if (c->result < 0) {
#line 312
      c->result = 1;
    }
#line 313
    if (c->error < 0) {
#line 314
      c->error = 0;
    }
    {
#line 315
    tmp___0 = strlen((char const   *)(c->errormsg));
#line 315
    add_result_code_avp(buf, (_u16 )c->result, (_u16 )c->error, c->errormsg, (int )tmp___0);
#line 317
    add_control_hdr(c->container, c, buf);
    }
#line 318
    if (gconfig.packet_dump) {
      {
#line 319
      do_packet_dump(buf);
      }
    }
    {
#line 324
    control_xmit((void *)buf);
#line 329
    tmp = (c->container)->call_head;
    }
    {
#line 330
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 330
      if (! tmp) {
#line 330
        goto while_break___0;
      }
      {
#line 332
      tmp2 = tmp->next;
#line 333
      tmp->needclose = 0;
#line 334
      tmp->closing = -1;
#line 335
      call_close(tmp);
#line 336
      tmp = tmp2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 338
    tmp___1 = ntohs((c->container)->peer.sin_port);
#line 338
    tmp___2 = inet_ntoa((c->container)->peer.sin_addr);
#line 338
    l2tp_log(6, "Connection %d closed to %s, port %d (%s)\n", (c->container)->tid,
             tmp___2, (int )tmp___1, c->errormsg);
    }
  } else {
#line 349
    if (c->zlb_xmit) {
      {
#line 350
      deschedule(c->zlb_xmit);
      }
    }
#line 352
    if (c->closing) {
      {
#line 358
      destroy_call(c);
      }
#line 359
      return;
    }
    {
#line 361
    c->closeSs = (c->container)->control_seq_num;
#line 362
    buf = new_outgoing(c->container);
#line 363
    add_message_type_avp(buf, (_u16 )14);
    }
#line 364
    if ((c->container)->hbit) {
      {
#line 366
      mk_challenge((c->container)->chal_them.vector, 16);
#line 367
      add_randvect_avp(buf, (c->container)->chal_them.vector, 16);
      }
    }
#line 370
    if (c->result < 0) {
#line 371
      c->result = 1;
    }
#line 372
    if (c->error < 0) {
#line 373
      c->error = 0;
    }
    {
#line 374
    tmp___3 = strlen((char const   *)(c->errormsg));
#line 374
    add_result_code_avp(buf, (_u16 )c->result, (_u16 )c->error, c->errormsg, (int )tmp___3);
#line 379
    add_callid_avp(buf, (_u16 )c->ourcid);
#line 381
    add_control_hdr(c->container, c, buf);
    }
#line 382
    if (gconfig.packet_dump) {
      {
#line 383
      do_packet_dump(buf);
      }
    }
    {
#line 388
    control_xmit((void *)buf);
#line 389
    tmp___4 = inet_ntoa((c->container)->peer.sin_addr);
#line 389
    l2tp_log(6, "%s: Call %d to %s disconnected\n", "call_close", c->ourcid, tmp___4);
    }
  }
#line 395
  c->closing = -1;
#line 396
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
void destroy_call(struct call *c ) 
{ 
  struct call *p ;
  struct timeval tv ;
  pid_t pid ;

  {
#line 410
  if (c->fd > 0) {
    {
#line 411
    close(c->fd);
    }
  }
#line 413
  if (c->zlb_xmit) {
    {
#line 414
    deschedule(c->zlb_xmit);
    }
  }
#line 417
  if (c->addr) {
    {
#line 418
    unreserve_addr(c->addr);
    }
  }
#line 427
  pid = c->pppd;
#line 428
  if (pid) {
    {
#line 431
    c->pppd = 0;
#line 446
    l2tp_log(7, "Terminating pppd: sending TERM signal to pid %d\n", pid);
#line 448
    kill(pid, 15);
    }
  }
#line 456
  if (c->container) {
#line 458
    p = (c->container)->call_head;
#line 463
    if (p) {
#line 465
      if ((unsigned long )p == (unsigned long )c) {
#line 467
        (c->container)->call_head = c->next;
#line 468
        ((c->container)->count) --;
      } else {
        {
#line 472
        while (1) {
          while_continue: /* CIL Label */ ;
#line 472
          if (p->next) {
#line 472
            if (! ((unsigned long )p->next != (unsigned long )c)) {
#line 472
              goto while_break;
            }
          } else {
#line 472
            goto while_break;
          }
#line 473
          p = p->next;
        }
        while_break: /* CIL Label */ ;
        }
#line 474
        if (p->next) {
#line 476
          p->next = c->next;
#line 477
          ((c->container)->count) --;
        }
      }
    }
  }
#line 482
  if (c->lac) {
#line 484
    (c->lac)->c = (struct call *)((void *)0);
#line 485
    if ((c->lac)->redial) {
#line 485
      if ((c->lac)->rtimeout > 0) {
#line 485
        if (! (c->lac)->rsched) {
#line 485
          if ((c->lac)->active) {
            {
#line 492
            tv.tv_sec = (__time_t )(c->lac)->rtimeout;
#line 493
            tv.tv_usec = (__suseconds_t )0;
#line 494
            (c->lac)->rsched = schedule(tv, & magic_lac_dial, (void *)c->lac);
            }
          }
        }
      }
    }
  }
  {
#line 498
  free((void *)c);
  }
#line 499
  return;
}
}
#line 502 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
struct call *new_call(struct tunnel *parent ) 
{ 
  unsigned char entropy_buf[2] ;
  struct call *tmp ;
  void *tmp___0 ;
  unsigned short *temp ;
  void *tmp___1 ;

  {
  {
#line 504
  entropy_buf[0] = (unsigned char )'\000';
#line 504
  entropy_buf[1] = (unsigned char )'\000';
#line 505
  tmp___0 = malloc(sizeof(struct call ));
#line 505
  tmp = (struct call *)tmp___0;
  }
#line 507
  if (! tmp) {
#line 508
    return ((struct call *)((void *)0));
  }
#line 509
  tmp->tx_pkts = 0;
#line 510
  tmp->rx_pkts = 0;
#line 511
  tmp->tx_bytes = 0;
#line 512
  tmp->rx_bytes = 0;
#line 513
  tmp->zlb_xmit = (struct schedule_entry *)((void *)0);
#line 516
  tmp->prx = 0;
#line 518
  tmp->msgtype = 0;
#line 520
  tmp->data_seq_num = (_u16 )0;
#line 521
  tmp->data_rec_seq_num = (_u16 )0;
#line 522
  tmp->pLr = -1;
#line 523
  tmp->nego = 0;
#line 524
  tmp->debug = 0;
#line 525
  tmp->seq_reqd = 0;
#line 526
  tmp->state = 0;
#line 527
  if (parent->self) {
    {
#line 533
    get_entropy(entropy_buf, 2);
#line 536
    temp = (unsigned short *)(entropy_buf);
#line 537
    tmp->ourcid = (int )*temp & 65535;
    }
  }
  {
#line 546
  tmp->dialed[0] = (char)0;
#line 547
  tmp->dialing[0] = (char)0;
#line 548
  tmp->subaddy[0] = (char)0;
#line 549
  tmp->physchan = -1;
#line 550
  tmp->serno = 0U;
#line 551
  tmp->bearer = -1;
#line 552
  tmp->cid = -1;
#line 553
  tmp->qcid = -1;
#line 554
  tmp->container = parent;
#line 556
  tmp->fd = -1;
#line 557
  tmp___1 = malloc(sizeof(struct termios ));
#line 557
  tmp->oldptyconf = (struct termios *)tmp___1;
#line 558
  tmp->pnu = 0;
#line 559
  tmp->cnu = 0;
#line 560
  tmp->needclose = 0;
#line 561
  tmp->closing = 0;
#line 562
  tmp->die = 0;
#line 563
  tmp->pppd = 0;
#line 564
  tmp->error = -1;
#line 565
  tmp->result = -1;
#line 566
  tmp->errormsg[0] = (char)0;
#line 567
  tmp->fbit = 0;
#line 568
  tmp->cid = 0;
#line 569
  tmp->lbit = 0;
#line 571
  tmp->lns = parent->lns;
#line 572
  tmp->lac = parent->lac;
#line 573
  tmp->addr = 0U;
#line 578
  tmp->ourfbit = 0;
#line 581
  tmp->dial_no[0] = (char )'\000';
  }
#line 582
  return (tmp);
}
}
#line 585 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
struct call *get_tunnel(int tunnel , unsigned int addr , int port ) 
{ 
  struct tunnel *st ;

  {
#line 588
  if (tunnel) {
#line 590
    st = tunnels.head;
    {
#line 591
    while (1) {
      while_continue: /* CIL Label */ ;
#line 591
      if (! st) {
#line 591
        goto while_break;
      }
#line 593
      if (st->ourtid == tunnel) {
#line 595
        return (st->self);
      }
#line 597
      st = st->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 600
  return ((struct call *)((void *)0));
}
}
#line 603 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/call.c"
struct call *get_call(int tunnel , int call , struct in_addr addr , int port , IPsecSAref_t refme ,
                      IPsecSAref_t refhim ) 
{ 
  struct tunnel *st ;
  struct call *sc ;
  uint16_t tmp ;
  char *tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;

  {
#line 614
  if (tunnel) {
#line 616
    st = tunnels.head;
    {
#line 617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 617
      if (! st) {
#line 617
        goto while_break;
      }
#line 619
      if (st->ourtid == tunnel) {
#line 619
        if (gconfig.ipsecsaref == 0) {
#line 619
          goto _L___0;
        } else
#line 619
        if (st->refhim == refhim) {
#line 619
          goto _L___0;
        } else
#line 619
        if (refhim == 0U) {
#line 619
          goto _L___0;
        } else
#line 619
        if (st->refhim == 0U) {
          _L___0: /* CIL Label */ 
#line 625
          if (call) {
#line 627
            sc = st->call_head;
            {
#line 628
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 628
              if (! sc) {
#line 628
                goto while_break___0;
              }
#line 631
              if (sc->ourcid == call) {
#line 631
                return (sc);
              }
#line 632
              sc = sc->next;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 634
            l2tp_log(7, "%s: can\'t find call %d in tunnel %d\n (ref=%d/%d)", "get_call",
                     call, tunnel, refme, refhim);
            }
#line 636
            return ((struct call *)((void *)0));
          } else {
#line 640
            return (st->self);
          }
        }
      }
#line 643
      st = st->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 646
    l2tp_log(6, "Can not find tunnel %u (refhim=%u)\n", tunnel, refhim);
    }
#line 648
    return ((struct call *)((void *)0));
  } else {
#line 655
    if (call) {
      {
#line 657
      l2tp_log(4, "%s: call ID specified, but no tunnel ID specified.  tossing.\n",
               "get_call");
      }
#line 660
      return ((struct call *)((void *)0));
    }
#line 666
    if (gconfig.debug_tunnel) {
      {
#line 668
      tmp = ntohs((uint16_t )port);
#line 668
      tmp___0 = inet_ntoa(addr);
#line 668
      l2tp_log(7, "%s: allocating new tunnel for host %s, port %d.\n", "get_call",
               tmp___0, (int )tmp);
      }
    }
    {
#line 672
    st = new_tunnel();
    }
#line 672
    if (! st) {
      {
#line 674
      tmp___1 = ntohs((uint16_t )port);
#line 674
      tmp___2 = inet_ntoa(addr);
#line 674
      l2tp_log(4, "%s: unable to allocate new tunnel for host %s, port %d.\n", "get_call",
               tmp___2, (int )tmp___1);
      }
#line 677
      return ((struct call *)((void *)0));
    }
    {
#line 679
    st->peer.sin_family = (sa_family_t )2;
#line 680
    st->peer.sin_port = (in_port_t )port;
#line 681
    st->refme = refme;
#line 682
    st->refhim = refhim;
#line 683
    st->udp_fd = -1;
#line 684
    st->pppox_fd = -1;
#line 685
    bcopy((void const   *)(& addr), (void *)(& st->peer.sin_addr), sizeof(addr));
#line 686
    st->next = tunnels.head;
#line 687
    tunnels.head = st;
#line 688
    (tunnels.count) ++;
    }
#line 689
    return (st->self);
  }
}
}
#line 87 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/avp.h"
void encrypt_avp(struct buffer *buf , _u16 len , struct tunnel *t ) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.h"
struct lns *get_lns(struct tunnel *t ) ;
#line 50
unsigned int get_addr(struct iprange *ipr ) ;
#line 51
void reserve_addr(unsigned int addr ) ;
#line 54
int handle_challenge(struct tunnel *t , struct challenge *chal ) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
struct addr_ent *uaddr[256]  ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
void init_addr(void) 
{ 
  int x ;

  {
#line 33
  x = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (x < 256)) {
#line 33
      goto while_break;
    }
#line 34
    uaddr[x] = (struct addr_ent *)((void *)0);
#line 33
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
static int ip_used(unsigned int addr ) 
{ 
  struct addr_ent *tmp ;

  {
#line 40
  tmp = uaddr[addr % 256U];
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! tmp) {
#line 41
      goto while_break;
    }
#line 43
    if (tmp->addr == addr) {
#line 44
      return (-1);
    }
#line 45
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (0);
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
void mk_challenge(unsigned char *c , int length ) 
{ 


  {
  {
#line 52
  get_entropy(c, length);
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
void reserve_addr(unsigned int addr ) 
{ 
  struct addr_ent *tmp ;
  struct addr_ent *tmp2 ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 64
  addr = ntohl(addr);
#line 65
  tmp___0 = ip_used(addr);
  }
#line 65
  if (tmp___0) {
#line 66
    return;
  }
  {
#line 67
  tmp = uaddr[addr % 256U];
#line 68
  tmp___1 = malloc(sizeof(struct addr_ent ));
#line 68
  tmp2 = (struct addr_ent *)tmp___1;
#line 69
  uaddr[addr % 256U] = tmp2;
#line 70
  tmp2->next = tmp;
#line 71
  tmp2->addr = addr;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
void unreserve_addr(unsigned int addr ) 
{ 
  struct addr_ent *tmp ;
  struct addr_ent *last ;
  struct addr_ent *z ;

  {
  {
#line 76
  last = (struct addr_ent *)((void *)0);
#line 77
  addr = ntohl(addr);
#line 78
  tmp = uaddr[addr % 256U];
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! tmp) {
#line 79
      goto while_break;
    }
#line 81
    if (tmp->addr == addr) {
#line 83
      if (last) {
#line 85
        last->next = tmp->next;
      } else {
#line 89
        uaddr[addr % 256U] = tmp->next;
      }
      {
#line 91
      z = tmp;
#line 92
      tmp = tmp->next;
#line 93
      free((void *)z);
      }
    } else {
#line 97
      last = tmp;
#line 98
      tmp = tmp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
unsigned int get_addr(struct iprange *ipr ) 
{ 
  unsigned int x ;
  unsigned int y ;
  int status___0 ;
  struct iprange *ipr2 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ipr) {
#line 108
      goto while_break;
    }
#line 110
    if (ipr->sense == -1) {
      {
#line 111
      x = ntohl(ipr->start);
      }
      {
#line 111
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 111
        tmp___2 = ntohl(ipr->end);
        }
#line 111
        if (! (x <= tmp___2)) {
#line 111
          goto while_break___0;
        }
        {
#line 115
        tmp___1 = ip_used(x);
        }
#line 115
        if (! tmp___1) {
#line 117
          status___0 = -1;
#line 118
          ipr2 = ipr->next;
          {
#line 119
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 119
            if (! ipr2) {
#line 119
              goto while_break___1;
            }
            {
#line 121
            tmp = ntohl(ipr2->start);
            }
#line 121
            if (x >= tmp) {
              {
#line 121
              tmp___0 = ntohl(ipr2->end);
              }
#line 121
              if (x <= tmp___0) {
#line 123
                status___0 = ipr2->sense;
              }
            }
#line 124
            ipr2 = ipr2->next;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 126
          y = htonl(x);
          }
#line 127
          if (status___0 == -1) {
#line 128
            return (y);
          }
        }
#line 111
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 131
    ipr = ipr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (0U);
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
static int get_secret(char *us , char *them , unsigned char *secret , int size ) 
{ 
  FILE *f ;
  char buf[80] ;
  char *u ;
  char *t ;
  char *s ;
  int num ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 141
  num = 0;
#line 142
  f = fopen((char const   */* __restrict  */)(gconfig.authfile), (char const   */* __restrict  */)"r");
  }
#line 143
  if (! f) {
    {
#line 145
    l2tp_log(4, "%s : Unable to open \'%s\' for authentication\n", "get_secret", gconfig.authfile);
    }
#line 147
    return (0);
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    tmp___8 = feof(f);
    }
#line 149
    if (tmp___8) {
#line 149
      goto while_break;
    }
    {
#line 151
    num ++;
#line 152
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
    }
#line 152
    if ((unsigned long )((void *)0) == (unsigned long )tmp) {
#line 155
      goto while_break;
    }
#line 158
    t = buf;
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (! *t) {
#line 158
        goto while_break___0;
      }
#line 159
      if ((int )*t == 35) {
#line 159
        *t = (char)0;
      } else
#line 159
      if ((int )*t == 59) {
#line 159
        *t = (char)0;
      } else {
#line 159
        *t = *t;
      }
#line 158
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 161
    tmp___0 = strlen((char const   *)(buf));
#line 161
    t = (buf + tmp___0) - 1;
    }
    {
#line 161
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 161
      if ((unsigned long )t >= (unsigned long )(buf)) {
#line 161
        if (! ((int )*t < 33)) {
#line 161
          goto while_break___1;
        }
      } else {
#line 161
        goto while_break___1;
      }
#line 162
      *t = (char)0;
#line 161
      t --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 163
    tmp___1 = strlen((char const   *)(buf));
    }
#line 163
    if (! tmp___1) {
#line 164
      goto while_continue;
    }
#line 165
    u = buf;
    {
#line 166
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 166
      if (*u) {
#line 166
        if (! ((int )*u < 33)) {
#line 166
          goto while_break___2;
        }
      } else {
#line 166
        goto while_break___2;
      }
#line 167
      u ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 169
    if (! *u) {
      {
#line 171
      l2tp_log(4, "%s: Invalid authentication info (no us), line %d\n", "get_secret",
               num);
      }
#line 174
      goto while_continue;
    }
#line 176
    t = u;
    {
#line 177
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 177
      if (! ((int )*t > 32)) {
#line 177
        goto while_break___3;
      }
#line 178
      t ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 179
    tmp___2 = t;
#line 179
    t ++;
#line 179
    *tmp___2 = (char)0;
    {
#line 180
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 180
      if (*t) {
#line 180
        if (! ((int )*t < 33)) {
#line 180
          goto while_break___4;
        }
      } else {
#line 180
        goto while_break___4;
      }
#line 181
      t ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 183
    if (! *t) {
      {
#line 185
      l2tp_log(4, "%s: Invalid authentication info (nothem), line %d\n", "get_secret",
               num);
      }
#line 188
      goto while_continue;
    }
#line 190
    s = t;
    {
#line 191
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 191
      if (! ((int )*s > 33)) {
#line 191
        goto while_break___5;
      }
#line 192
      s ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 193
    tmp___3 = s;
#line 193
    s ++;
#line 193
    *tmp___3 = (char)0;
    {
#line 194
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 194
      if (*s) {
#line 194
        if (! ((int )*s < 33)) {
#line 194
          goto while_break___6;
        }
      } else {
#line 194
        goto while_break___6;
      }
#line 195
      s ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 196
    if (! *s) {
      {
#line 198
      l2tp_log(4, "%s: Invalid authentication info (no secret), line %d\n", "get_secret",
               num);
      }
#line 201
      goto while_continue;
    }
    {
#line 203
    tmp___4 = strcasecmp((char const   *)u, (char const   *)us);
    }
#line 203
    if (tmp___4) {
      {
#line 203
      tmp___5 = strcasecmp((char const   *)u, "*");
      }
#line 203
      if (! tmp___5) {
        _L: /* CIL Label */ 
        {
#line 203
        tmp___6 = strcasecmp((char const   *)t, (char const   *)them);
        }
#line 203
        if (tmp___6) {
          {
#line 203
          tmp___7 = strcasecmp((char const   *)t, "*");
          }
#line 203
          if (! tmp___7) {
            {
#line 211
            strncpy((char */* __restrict  */)((char *)secret), (char const   */* __restrict  */)s,
                    (size_t )size);
#line 212
            fclose(f);
            }
#line 213
            return (-1);
          }
        } else {
          {
#line 211
          strncpy((char */* __restrict  */)((char *)secret), (char const   */* __restrict  */)s,
                  (size_t )size);
#line 212
          fclose(f);
          }
#line 213
          return (-1);
        }
      }
    } else {
#line 203
      goto _L;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  fclose(f);
  }
#line 217
  return (0);
}
}
#line 220 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
int handle_challenge(struct tunnel *t , struct challenge *chal ) 
{ 
  char *us ;
  char *them ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 224
  if (! t->lns) {
#line 224
    if (! t->lac) {
      {
#line 226
      l2tp_log(7, "%s: No LNS or LAC to handle challenge!\n", "handle_challenge");
      }
#line 228
      return (-1);
    }
  }
#line 234
  if (t->lns) {
#line 236
    if ((t->lns)->hostname[0]) {
#line 237
      us = (t->lns)->hostname;
    } else {
#line 239
      us = hostname;
    }
#line 240
    if ((t->lns)->peername[0]) {
#line 241
      them = (t->lns)->peername;
    } else {
#line 243
      them = t->hostname;
    }
  } else {
#line 247
    if ((t->lac)->hostname[0]) {
#line 248
      us = (t->lac)->hostname;
    } else {
#line 250
      us = hostname;
    }
#line 251
    if ((t->lac)->peername[0]) {
#line 252
      them = (t->lac)->peername;
    } else {
#line 254
      them = t->hostname;
    }
  }
  {
#line 257
  tmp = get_secret(us, them, chal->secret, (int )sizeof(chal->secret));
  }
#line 257
  if (! tmp) {
    {
#line 259
    l2tp_log(7, "%s: no secret found for us=\'%s\' and them=\'%s\'\n", "handle_challenge",
             us, them);
    }
#line 261
    return (-1);
  }
  {
#line 275
  memset((void *)(chal->response), 0, (size_t )16);
#line 276
  MD5Init(& chal->md5);
#line 277
  MD5Update(& chal->md5, (unsigned char const   *)(& chal->ss), 1U);
#line 278
  tmp___0 = strlen((char const   *)((char *)(chal->secret)));
#line 278
  MD5Update(& chal->md5, (unsigned char const   *)(chal->secret), (unsigned int )tmp___0);
#line 279
  MD5Update(& chal->md5, (unsigned char const   *)chal->challenge, chal->chal_len);
#line 280
  MD5Final((unsigned char *)(chal->response), & chal->md5);
#line 293
  chal->state = 1;
  }
#line 294
  return (0);
}
}
#line 297 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
struct lns *get_lns(struct tunnel *t ) 
{ 
  struct lns *lns ;
  struct iprange *ipr ;
  int allow ;
  int checkdefault ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 306
  checkdefault = 0;
#line 309
  allow = 0;
#line 310
  lns = lnslist;
#line 311
  if (! lns) {
#line 313
    lns = deflns;
#line 314
    checkdefault = -1;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! lns) {
#line 316
      goto while_break;
    }
#line 318
    ipr = lns->lacs;
    {
#line 319
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 319
      if (! ipr) {
#line 319
        goto while_break___0;
      }
      {
#line 321
      tmp = ntohl(t->peer.sin_addr.s_addr);
#line 321
      tmp___0 = ntohl(ipr->start);
      }
#line 321
      if (tmp >= tmp___0) {
        {
#line 321
        tmp___1 = ntohl(t->peer.sin_addr.s_addr);
#line 321
        tmp___2 = ntohl(ipr->end);
        }
#line 321
        if (tmp___1 <= tmp___2) {
#line 330
          allow = ipr->sense;
        }
      }
#line 332
      ipr = ipr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 334
    if (allow) {
#line 335
      return (lns);
    }
#line 336
    lns = lns->next;
#line 337
    if (! lns) {
#line 337
      if (! checkdefault) {
#line 339
        lns = deflns;
#line 340
        checkdefault = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if (gconfig.accesscontrol) {
#line 344
    return ((struct lns *)((void *)0));
  } else {
#line 346
    return (deflns);
  }
}
}
#line 363 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
void encrypt_avp(struct buffer *buf , _u16 len , struct tunnel *t ) 
{ 
  struct avp_hdr *new_hdr ;
  struct avp_hdr *old_hdr ;
  _u16 length ;
  _u16 flags ;
  _u16 attr ;
  unsigned char *ptr ;
  unsigned char *end ;
  int cnt ;
  unsigned char digest[16] ;
  unsigned char *previous_segment ;
  uint16_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 369
  new_hdr = (struct avp_hdr *)((buf->start + buf->len) - (int )len);
#line 371
  old_hdr = (struct avp_hdr *)(((buf->start + buf->len) - (int )len) + 2);
#line 380
  length = (_u16 )(((((unsigned long )len - sizeof(struct avp_hdr )) + 1UL) / 16UL + 1UL) * 16UL + sizeof(struct avp_hdr ));
#line 383
  tmp = htons(old_hdr->length);
#line 383
  flags = (_u16 )((int )tmp & 61440);
#line 384
  new_hdr->length = htons((uint16_t )(((int )length | (int )flags) | 16384));
#line 385
  new_hdr->vendorid = old_hdr->vendorid;
#line 386
  attr = old_hdr->attr;
#line 386
  new_hdr->attr = attr;
#line 388
  old_hdr->attr = htons((uint16_t )((unsigned long )len - sizeof(struct avp_hdr )));
#line 391
  buf->len -= (int )len;
#line 392
  buf->len += (int )length;
#line 395
  MD5Init(& t->chal_them.md5);
#line 396
  MD5Update(& t->chal_them.md5, (unsigned char const   *)((void *)(& attr)), 2U);
#line 397
  tmp___0 = strlen((char const   *)((char *)(t->chal_them.secret)));
#line 397
  MD5Update(& t->chal_them.md5, (unsigned char const   *)(t->chal_them.secret), (unsigned int )tmp___0);
#line 399
  MD5Update(& t->chal_them.md5, (unsigned char const   *)t->chal_them.vector, 16U);
#line 400
  MD5Final((unsigned char *)(digest), & t->chal_them.md5);
#line 403
  ptr = (unsigned char *)new_hdr + sizeof(struct avp_hdr );
#line 404
  end = (unsigned char *)new_hdr + (int )length;
#line 405
  previous_segment = ptr;
  }
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 406
      goto while_break;
    }
#line 414
    cnt = 0;
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (! (cnt < 16)) {
#line 414
        goto while_break___0;
      }
#line 416
      *ptr = (unsigned char )((int )*ptr ^ (int )digest[cnt]);
#line 414
      cnt ++;
#line 414
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 422
    if ((unsigned long )ptr < (unsigned long )end) {
      {
#line 424
      MD5Init(& t->chal_them.md5);
#line 425
      tmp___1 = strlen((char const   *)((char *)(t->chal_them.secret)));
#line 425
      MD5Update(& t->chal_them.md5, (unsigned char const   *)(t->chal_them.secret),
                (unsigned int )tmp___1);
#line 427
      MD5Update(& t->chal_them.md5, (unsigned char const   *)previous_segment, 16U);
#line 428
      MD5Final((unsigned char *)(digest), & t->chal_them.md5);
      }
    }
#line 430
    previous_segment = ptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  return;
}
}
#line 434 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/aaa.c"
int decrypt_avp(char *buf , struct tunnel *t ) 
{ 
  int cnt ;
  int len ;
  int olen ;
  int flags ;
  unsigned char digest[16] ;
  char *ptr ;
  char *end ;
  _u16 attr ;
  struct avp_hdr *old_hdr ;
  struct avp_hdr *new_hdr ;
  int saved_segment_len ;
  unsigned char saved_segment[16] ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;

  {
#line 439
  cnt = 0;
#line 444
  old_hdr = (struct avp_hdr *)buf;
#line 445
  new_hdr = (struct avp_hdr *)(buf + 2);
#line 448
  ptr = (char *)old_hdr + sizeof(struct avp_hdr );
#line 449
  olen = (int )old_hdr->length & 4095;
#line 450
  end = buf + olen;
#line 451
  if (! t->chal_us.vector) {
    {
#line 453
    l2tp_log(7, "%s: Hidden bit set, but no random vector specified!\n", "decrypt_avp");
    }
#line 455
    return (-22);
  }
  {
#line 460
  attr = ntohs(old_hdr->attr);
#line 461
  MD5Init(& t->chal_us.md5);
#line 462
  MD5Update(& t->chal_us.md5, (unsigned char const   *)((void *)(& attr)), 2U);
#line 463
  tmp = strlen((char const   *)((char *)(t->chal_us.secret)));
#line 463
  MD5Update(& t->chal_us.md5, (unsigned char const   *)(t->chal_us.secret), (unsigned int )tmp);
#line 465
  MD5Update(& t->chal_us.md5, (unsigned char const   *)t->chal_us.vector, t->chal_us.vector_len);
#line 466
  MD5Final((unsigned char *)(digest), & t->chal_us.md5);
  }
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 473
      goto while_break;
    }
#line 475
    if (cnt >= 16) {
      {
#line 477
      MD5Init(& t->chal_us.md5);
#line 478
      tmp___0 = strlen((char const   *)((char *)(t->chal_us.secret)));
#line 478
      MD5Update(& t->chal_us.md5, (unsigned char const   *)(t->chal_us.secret), (unsigned int )tmp___0);
#line 480
      MD5Update(& t->chal_us.md5, (unsigned char const   *)(saved_segment), 16U);
#line 481
      MD5Final((unsigned char *)(digest), & t->chal_us.md5);
#line 482
      cnt = 0;
      }
    }
#line 487
    if (cnt == 0) {
#line 489
      if (end - ptr < 16L) {
#line 489
        saved_segment_len = (int )(end - ptr);
      } else {
#line 489
        saved_segment_len = 16;
      }
      {
#line 491
      memcpy((void */* __restrict  */)(saved_segment), (void const   */* __restrict  */)ptr,
             (size_t )saved_segment_len);
      }
    }
#line 493
    tmp___1 = cnt;
#line 493
    cnt ++;
#line 493
    *ptr = (char )((int )*ptr ^ (int )digest[tmp___1]);
#line 494
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 498
  flags = ((int )old_hdr->length & 61440) & -16385;
#line 499
  tmp___2 = ntohs(new_hdr->attr);
#line 499
  len = (int )((unsigned long )tmp___2 + sizeof(struct avp_hdr ));
  }
#line 500
  if (len > olen - 2) {
    {
#line 502
    l2tp_log(7, "%s: Decrypted length is too long (%d > %d)\n", "decrypt_avp", len,
             olen - 2);
    }
#line 505
    return (-22);
  }
#line 507
  new_hdr->attr = old_hdr->attr;
#line 508
  new_hdr->vendorid = old_hdr->vendorid;
#line 509
  new_hdr->length = (_u16 )(len | flags);
#line 510
  return (0);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.h"
__inline void recycle_outgoing(struct buffer *buf , struct sockaddr_in peer ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
_u16 ppp_crc16_table[256]  = 
#line 25 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
  {      (_u16 )0,      (_u16 )4489,      (_u16 )8978,      (_u16 )12955, 
        (_u16 )17956,      (_u16 )22445,      (_u16 )25910,      (_u16 )29887, 
        (_u16 )35912,      (_u16 )40385,      (_u16 )44890,      (_u16 )48851, 
        (_u16 )51820,      (_u16 )56293,      (_u16 )59774,      (_u16 )63735, 
        (_u16 )4225,      (_u16 )264,      (_u16 )13203,      (_u16 )8730, 
        (_u16 )22181,      (_u16 )18220,      (_u16 )30135,      (_u16 )25662, 
        (_u16 )40137,      (_u16 )36160,      (_u16 )49115,      (_u16 )44626, 
        (_u16 )56045,      (_u16 )52068,      (_u16 )63999,      (_u16 )59510, 
        (_u16 )8450,      (_u16 )12427,      (_u16 )528,      (_u16 )5017, 
        (_u16 )26406,      (_u16 )30383,      (_u16 )17460,      (_u16 )21949, 
        (_u16 )44362,      (_u16 )48323,      (_u16 )36440,      (_u16 )40913, 
        (_u16 )60270,      (_u16 )64231,      (_u16 )51324,      (_u16 )55797, 
        (_u16 )12675,      (_u16 )8202,      (_u16 )4753,      (_u16 )792, 
        (_u16 )30631,      (_u16 )26158,      (_u16 )21685,      (_u16 )17724, 
        (_u16 )48587,      (_u16 )44098,      (_u16 )40665,      (_u16 )36688, 
        (_u16 )64495,      (_u16 )60006,      (_u16 )55549,      (_u16 )51572, 
        (_u16 )16900,      (_u16 )21389,      (_u16 )24854,      (_u16 )28831, 
        (_u16 )1056,      (_u16 )5545,      (_u16 )10034,      (_u16 )14011, 
        (_u16 )52812,      (_u16 )57285,      (_u16 )60766,      (_u16 )64727, 
        (_u16 )34920,      (_u16 )39393,      (_u16 )43898,      (_u16 )47859, 
        (_u16 )21125,      (_u16 )17164,      (_u16 )29079,      (_u16 )24606, 
        (_u16 )5281,      (_u16 )1320,      (_u16 )14259,      (_u16 )9786, 
        (_u16 )57037,      (_u16 )53060,      (_u16 )64991,      (_u16 )60502, 
        (_u16 )39145,      (_u16 )35168,      (_u16 )48123,      (_u16 )43634, 
        (_u16 )25350,      (_u16 )29327,      (_u16 )16404,      (_u16 )20893, 
        (_u16 )9506,      (_u16 )13483,      (_u16 )1584,      (_u16 )6073, 
        (_u16 )61262,      (_u16 )65223,      (_u16 )52316,      (_u16 )56789, 
        (_u16 )43370,      (_u16 )47331,      (_u16 )35448,      (_u16 )39921, 
        (_u16 )29575,      (_u16 )25102,      (_u16 )20629,      (_u16 )16668, 
        (_u16 )13731,      (_u16 )9258,      (_u16 )5809,      (_u16 )1848, 
        (_u16 )65487,      (_u16 )60998,      (_u16 )56541,      (_u16 )52564, 
        (_u16 )47595,      (_u16 )43106,      (_u16 )39673,      (_u16 )35696, 
        (_u16 )33800,      (_u16 )38273,      (_u16 )42778,      (_u16 )46739, 
        (_u16 )49708,      (_u16 )54181,      (_u16 )57662,      (_u16 )61623, 
        (_u16 )2112,      (_u16 )6601,      (_u16 )11090,      (_u16 )15067, 
        (_u16 )20068,      (_u16 )24557,      (_u16 )28022,      (_u16 )31999, 
        (_u16 )38025,      (_u16 )34048,      (_u16 )47003,      (_u16 )42514, 
        (_u16 )53933,      (_u16 )49956,      (_u16 )61887,      (_u16 )57398, 
        (_u16 )6337,      (_u16 )2376,      (_u16 )15315,      (_u16 )10842, 
        (_u16 )24293,      (_u16 )20332,      (_u16 )32247,      (_u16 )27774, 
        (_u16 )42250,      (_u16 )46211,      (_u16 )34328,      (_u16 )38801, 
        (_u16 )58158,      (_u16 )62119,      (_u16 )49212,      (_u16 )53685, 
        (_u16 )10562,      (_u16 )14539,      (_u16 )2640,      (_u16 )7129, 
        (_u16 )28518,      (_u16 )32495,      (_u16 )19572,      (_u16 )24061, 
        (_u16 )46475,      (_u16 )41986,      (_u16 )38553,      (_u16 )34576, 
        (_u16 )62383,      (_u16 )57894,      (_u16 )53437,      (_u16 )49460, 
        (_u16 )14787,      (_u16 )10314,      (_u16 )6865,      (_u16 )2904, 
        (_u16 )32743,      (_u16 )28270,      (_u16 )23797,      (_u16 )19836, 
        (_u16 )50700,      (_u16 )55173,      (_u16 )58654,      (_u16 )62615, 
        (_u16 )32808,      (_u16 )37281,      (_u16 )41786,      (_u16 )45747, 
        (_u16 )19012,      (_u16 )23501,      (_u16 )26966,      (_u16 )30943, 
        (_u16 )3168,      (_u16 )7657,      (_u16 )12146,      (_u16 )16123, 
        (_u16 )54925,      (_u16 )50948,      (_u16 )62879,      (_u16 )58390, 
        (_u16 )37033,      (_u16 )33056,      (_u16 )46011,      (_u16 )41522, 
        (_u16 )23237,      (_u16 )19276,      (_u16 )31191,      (_u16 )26718, 
        (_u16 )7393,      (_u16 )3432,      (_u16 )16371,      (_u16 )11898, 
        (_u16 )59150,      (_u16 )63111,      (_u16 )50204,      (_u16 )54677, 
        (_u16 )41258,      (_u16 )45219,      (_u16 )33336,      (_u16 )37809, 
        (_u16 )27462,      (_u16 )31439,      (_u16 )18516,      (_u16 )23005, 
        (_u16 )11618,      (_u16 )15595,      (_u16 )3696,      (_u16 )8185, 
        (_u16 )63375,      (_u16 )58886,      (_u16 )54429,      (_u16 )50452, 
        (_u16 )45483,      (_u16 )40994,      (_u16 )37561,      (_u16 )33584, 
        (_u16 )31687,      (_u16 )27214,      (_u16 )22741,      (_u16 )18780, 
        (_u16 )15843,      (_u16 )11370,      (_u16 )7921,      (_u16 )3960};
#line 60 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
int global_serno  =    1;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
struct buffer *new_outgoing(struct tunnel *t ) 
{ 
  struct buffer *tmp ;
  struct buffer *tmp___0 ;

  {
  {
#line 67
  tmp___0 = new_buf(4096);
#line 67
  tmp = tmp___0;
  }
#line 68
  if (! tmp) {
#line 69
    return ((struct buffer *)((void *)0));
  }
#line 70
  tmp->peer = t->peer;
#line 71
  tmp->start += sizeof(struct control_hdr );
#line 72
  tmp->len = 0;
#line 73
  tmp->retries = 0;
#line 74
  tmp->tunnel = t;
#line 75
  return (tmp);
}
}
#line 78 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
__inline void recycle_outgoing(struct buffer *buf , struct sockaddr_in peer ) 
{ 


  {
#line 83
  buf->start = buf->rstart + sizeof(struct control_hdr );
#line 84
  buf->peer = peer;
#line 85
  buf->len = 0;
#line 86
  buf->retries = -1;
#line 87
  buf->tunnel = (struct tunnel *)((void *)0);
#line 88
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
void add_fcs(struct buffer *buf ) 
{ 
  _u16 fcs ;
  unsigned char *c ;
  int x ;

  {
#line 91
  fcs = (_u16 )65535;
#line 92
  c = (unsigned char *)buf->start;
#line 94
  x = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (x < buf->len)) {
#line 94
      goto while_break;
    }
#line 96
    fcs = (_u16 )(((int )fcs >> 8) ^ (int )ppp_crc16_table[((int )fcs ^ (int )*c) & 255]);
#line 97
    c ++;
#line 94
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  fcs = (_u16 )((int )fcs ^ 65535);
#line 100
  *c = (unsigned char )((int )fcs & 255);
#line 101
  c ++;
#line 102
  *c = (unsigned char )(((int )fcs >> 8) & 255);
#line 103
  buf->len += 2;
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
void add_control_hdr(struct tunnel *t , struct call *c , struct buffer *buf ) 
{ 
  struct control_hdr *h ;

  {
  {
#line 109
  buf->start -= sizeof(struct control_hdr );
#line 110
  buf->len = (int )((unsigned long )buf->len + sizeof(struct control_hdr ));
#line 111
  h = (struct control_hdr *)buf->start;
#line 112
  h->ver = htons((uint16_t )51202);
#line 113
  h->length = htons((_u16 )buf->len);
#line 114
  h->tid = htons((uint16_t )t->tid);
#line 115
  h->cid = htons((uint16_t )c->cid);
#line 116
  h->Ns = htons(t->control_seq_num);
#line 117
  h->Nr = htons(t->control_rec_seq_num);
#line 118
  t->control_seq_num = (_u16 )((int )t->control_seq_num + 1);
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
void hello(void *tun ) 
{ 
  struct buffer *buf ;
  struct tunnel *t ;
  struct timeval tv ;

  {
  {
#line 127
  tv.tv_sec = (__time_t )60;
#line 128
  tv.tv_usec = (__suseconds_t )0;
#line 129
  t = (struct tunnel *)tun;
#line 130
  buf = new_outgoing(t);
#line 131
  add_message_type_avp(buf, (_u16 )6);
#line 132
  add_control_hdr(t, t->self, buf);
  }
#line 133
  if (gconfig.packet_dump) {
    {
#line 134
    do_packet_dump(buf);
    }
  }
  {
#line 138
  control_xmit((void *)buf);
#line 146
  t->hello = schedule(tv, & hello, (void *)t);
  }
#line 147
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
void control_zlb(struct buffer *buf , struct tunnel *t , struct call *c ) 
{ 


  {
  {
#line 151
  recycle_outgoing(buf, t->peer);
#line 152
  add_control_hdr(t, c, buf);
#line 153
  t->control_seq_num = (_u16 )((int )t->control_seq_num - 1);
#line 158
  udp_xmit(buf, t);
  }
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
int control_finish(struct tunnel *t , struct call *c ) 
{ 
  struct buffer *buf ;
  struct call *p ;
  struct call *z ;
  struct tunnel *y ;
  struct timeval tv ;
  struct ppp_opts *po ;
  char ip1[80] ;
  char ip2[80] ;
  char dummy_buf[128] ;
  unsigned int tmp ;
  char passwdfd_buf[32] ;
  unsigned int tmp___0 ;
  int i ;
  int pppd_passwdfd[2] ;
  int tmptid ;
  int tmpcid ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct lns *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  uint16_t tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  uint16_t tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  uint16_t tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  int tmp___48 ;
  size_t tmp___49 ;
  ssize_t tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char const   *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char const   *tmp___59 ;
  char const   *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  char *tmp___71 ;

  {
#line 179
  dummy_buf[0] = (char )'/';
#line 179
  dummy_buf[1] = (char )'v';
#line 179
  dummy_buf[2] = (char )'a';
#line 179
  dummy_buf[3] = (char )'r';
#line 179
  dummy_buf[4] = (char )'/';
#line 179
  dummy_buf[5] = (char )'l';
#line 179
  dummy_buf[6] = (char )'2';
#line 179
  dummy_buf[7] = (char )'t';
#line 179
  dummy_buf[8] = (char )'p';
#line 179
  dummy_buf[9] = (char )'/';
#line 179
  dummy_buf[10] = (char )'\000';
#line 179
  tmp = 11U;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (tmp >= 128U) {
#line 179
      goto while_break;
    }
#line 179
    dummy_buf[tmp] = (char)0;
#line 179
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  passwdfd_buf[0] = (char )'\000';
#line 180
  tmp___0 = 1U;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (tmp___0 >= 32U) {
#line 180
      goto while_break___0;
    }
#line 180
    passwdfd_buf[tmp___0] = (char)0;
#line 180
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  if (c->msgtype < 0) {
    {
#line 187
    l2tp_log(7, "%s: Whoa...  non-ZLB with no message type!\n", "control_finish");
    }
#line 189
    return (-22);
  }
#line 191
  if (gconfig.debug_state) {
    {
#line 192
    l2tp_log(7, "%s: message type is %s(%d).  Tunnel is %d, call is %d.\n", "control_finish",
             msgtypes[c->msgtype], c->msgtype, t->tid, c->cid);
    }
  }
  {
#line 197
  if (c->msgtype == 0) {
#line 197
    goto case_0;
  }
#line 355
  if (c->msgtype == 1) {
#line 355
    goto case_1;
  }
#line 501
  if (c->msgtype == 2) {
#line 501
    goto case_2;
  }
#line 624
  if (c->msgtype == 3) {
#line 624
    goto case_3;
  }
#line 658
  if (c->msgtype == 4) {
#line 658
    goto case_4;
  }
#line 699
  if (c->msgtype == 10) {
#line 699
    goto case_10;
  }
#line 795
  if (c->msgtype == 11) {
#line 795
    goto case_11;
  }
#line 925
  if (c->msgtype == 12) {
#line 925
    goto case_12;
  }
#line 1004
  if (c->msgtype == 8) {
#line 1004
    goto case_8;
  }
#line 1006
  if (c->msgtype == 9) {
#line 1006
    goto case_9;
  }
#line 1073
  if (c->msgtype == 14) {
#line 1073
    goto case_14;
  }
#line 1129
  if (c->msgtype == 6) {
#line 1129
    goto case_6;
  }
#line 1131
  if (c->msgtype == 16) {
#line 1131
    goto case_16;
  }
#line 1133
  goto switch_default;
  case_0: /* CIL Label */ 
#line 201
  if ((unsigned long )t->self == (unsigned long )c) {
#line 203
    if (t->lns) {
#line 205
      t->ourrws = (t->lns)->tun_rws;
#line 206
      t->hbit = (t->lns)->hbit;
#line 207
      t->rxspeed = (t->lns)->rxspeed;
#line 208
      t->txspeed = (t->lns)->txspeed;
    } else
#line 210
    if (t->lac) {
#line 212
      t->ourrws = (t->lac)->tun_rws;
#line 213
      t->hbit = (t->lac)->hbit;
#line 214
      t->rxspeed = (t->lac)->rxspeed;
#line 215
      t->txspeed = (t->lac)->txspeed;
    }
    {
#line 218
    t->state = 1;
#line 219
    buf = new_outgoing(t);
#line 220
    add_message_type_avp(buf, (_u16 )1);
    }
#line 221
    if (t->hbit) {
      {
#line 223
      mk_challenge(t->chal_them.vector, 16);
#line 224
      add_randvect_avp(buf, t->chal_them.vector, 16);
      }
    }
    {
#line 226
    add_protocol_avp(buf);
#line 227
    add_frame_caps_avp(buf, (_u16 )t->ourfc);
#line 228
    add_bearer_caps_avp(buf, (_u16 )t->ourbc);
#line 230
    add_firmware_avp(buf);
    }
#line 231
    if (t->lac) {
#line 231
      if ((t->lac)->hostname) {
#line 231
        if ((t->lac)->hostname[0]) {
          {
#line 232
          add_hostname_avp(buf, (char const   *)((t->lac)->hostname));
          }
        } else {
#line 231
          goto _L___0;
        }
      } else {
#line 231
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 233
    if (t->lns) {
#line 233
      if ((t->lns)->hostname) {
#line 233
        if ((t->lns)->hostname[0]) {
          {
#line 234
          add_hostname_avp(buf, (char const   *)((t->lns)->hostname));
          }
        } else {
          {
#line 236
          add_hostname_avp(buf, (char const   *)(hostname));
          }
        }
      } else {
        {
#line 236
        add_hostname_avp(buf, (char const   *)(hostname));
        }
      }
    } else {
      {
#line 236
      add_hostname_avp(buf, (char const   *)(hostname));
      }
    }
    {
#line 237
    add_vendor_avp(buf);
#line 238
    add_tunnelid_avp(buf, (_u16 )t->ourtid);
    }
#line 239
    if (t->ourrws >= 0) {
      {
#line 240
      add_avp_rws(buf, (_u16 )t->ourrws);
      }
    }
#line 241
    if (t->lac) {
#line 241
      if ((t->lac)->challenge) {
#line 241
        goto _L___1;
      } else {
#line 241
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 241
    if (t->lns) {
#line 241
      if ((t->lns)->challenge) {
        _L___1: /* CIL Label */ 
#line 244
        if (t->chal_them.challenge) {
          {
#line 245
          free((void *)t->chal_them.challenge);
          }
        }
        {
#line 246
        tmp___1 = malloc((size_t )16);
#line 246
        t->chal_them.challenge = (unsigned char *)tmp___1;
        }
#line 247
        if (! t->chal_them.challenge) {
          {
#line 249
          l2tp_log(4, "%s: malloc failed for challenge\n", "control_finish");
#line 251
          toss(buf);
          }
#line 252
          return (-22);
        }
        {
#line 254
        mk_challenge(t->chal_them.challenge, 16);
#line 255
        t->chal_them.chal_len = 16U;
#line 256
        add_challenge_avp(buf, t->chal_them.challenge, (int )t->chal_them.chal_len);
#line 258
        t->chal_them.state = 1;
        }
      }
    }
    {
#line 263
    add_control_hdr(t, c, buf);
#line 264
    c->cnu = 0;
    }
#line 265
    if (gconfig.packet_dump) {
      {
#line 266
      do_packet_dump(buf);
      }
    }
#line 267
    if (gconfig.debug_state) {
      {
#line 268
      l2tp_log(7, "%s: sending SCCRQ\n", "control_finish");
      }
    }
    {
#line 270
    control_xmit((void *)buf);
    }
  } else
#line 274
  if (switch_io) {
#line 276
    c->state = 10;
#line 277
    if (c->lns) {
#line 279
      if ((c->lns)->lbit) {
#line 279
        c->lbit = 16384;
      } else {
#line 279
        c->lbit = 0;
      }
    } else
#line 283
    if (c->lac) {
#line 285
      if ((c->lac)->lbit) {
#line 285
        c->lbit = 16384;
      } else {
#line 285
        c->lbit = 0;
      }
    }
    {
#line 289
    buf = new_outgoing(t);
#line 290
    add_message_type_avp(buf, (_u16 )10);
    }
#line 291
    if (t->hbit) {
      {
#line 293
      mk_challenge(t->chal_them.vector, 16);
#line 294
      add_randvect_avp(buf, t->chal_them.vector, 16);
      }
    }
    {
#line 299
    add_callid_avp(buf, (_u16 )c->ourcid);
#line 301
    add_serno_avp(buf, (unsigned int )global_serno);
#line 302
    c->serno = (unsigned int )global_serno;
#line 303
    global_serno ++;
#line 304
    add_bearer_avp(buf, 0);
#line 305
    add_control_hdr(t, c, buf);
#line 306
    c->cnu = 0;
    }
#line 307
    if (gconfig.packet_dump) {
      {
#line 308
      do_packet_dump(buf);
      }
    }
#line 309
    if (gconfig.debug_state) {
      {
#line 310
      l2tp_log(7, "%s: sending ICRQ\n", "control_finish");
      }
    }
    {
#line 311
    control_xmit((void *)buf);
    }
  } else {
#line 315
    c->state = 7;
#line 316
    if (c->lns) {
#line 318
      if ((c->lns)->lbit) {
#line 318
        c->lbit = 16384;
      } else {
#line 318
        c->lbit = 0;
      }
    }
#line 328
    if (t->fc & 1) {
#line 329
      c->frame = 1;
    } else {
#line 331
      c->frame = 2;
    }
    {
#line 332
    buf = new_outgoing(t);
#line 333
    add_message_type_avp(buf, (_u16 )7);
#line 337
    add_callid_avp(buf, (_u16 )c->ourcid);
#line 339
    add_serno_avp(buf, (unsigned int )global_serno);
#line 340
    c->serno = (unsigned int )global_serno;
#line 341
    global_serno ++;
#line 342
    add_minbps_avp(buf, 10000);
#line 343
    add_maxbps_avp(buf, 10000000);
#line 344
    add_bearer_avp(buf, 0);
#line 345
    add_frame_avp(buf, c->frame);
#line 346
    add_number_avp(buf, c->dial_no);
#line 347
    add_control_hdr(t, c, buf);
#line 348
    c->cnu = 0;
    }
#line 349
    if (gconfig.packet_dump) {
      {
#line 350
      do_packet_dump(buf);
      }
    }
    {
#line 351
    control_xmit((void *)buf);
    }
  }
#line 354
  goto switch_break;
  case_1: /* CIL Label */ 
#line 360
  if (t->tid <= 0) {
#line 362
    if (c) {
#line 362
      if (c->debug) {
#line 362
        tmp___2 = 1;
      } else
#line 362
      if (t->debug) {
#line 362
        tmp___2 = 1;
      } else {
#line 362
        tmp___2 = 0;
      }
#line 362
      tmp___3 = tmp___2;
    } else {
#line 362
      tmp___3 = t->debug;
    }
#line 362
    if (tmp___3) {
      {
#line 363
      l2tp_log(7, "%s: Peer did not specify assigned tunnel ID.  Closing.\n", "control_finish");
      }
    }
    {
#line 366
    set_error(c, 6, "Specify your assigned tunnel ID");
#line 367
    c->needclose = -1;
    }
#line 368
    return (-22);
  }
  {
#line 370
  tmp___7 = get_lns(t);
#line 370
  t->lns = tmp___7;
  }
#line 370
  if (! tmp___7) {
#line 372
    if (c) {
#line 372
      if (c->debug) {
#line 372
        tmp___5 = 1;
      } else
#line 372
      if (t->debug) {
#line 372
        tmp___5 = 1;
      } else {
#line 372
        tmp___5 = 0;
      }
#line 372
      tmp___6 = tmp___5;
    } else {
#line 372
      tmp___6 = t->debug;
    }
#line 372
    if (tmp___6) {
      {
#line 373
      tmp___4 = inet_ntoa(t->peer.sin_addr);
#line 373
      l2tp_log(7, "%s: Denied connection to unauthorized peer %s\n", "control_finish",
               tmp___4);
      }
    }
    {
#line 376
    set_error(c, 6, "No Authorization");
#line 377
    c->needclose = -1;
    }
#line 378
    return (-22);
  }
#line 380
  t->ourrws = (t->lns)->tun_rws;
#line 381
  t->hbit = (t->lns)->hbit;
#line 382
  if (t->fc < 0) {
#line 384
    if (c) {
#line 384
      if (c->debug) {
#line 384
        tmp___8 = 1;
      } else
#line 384
      if (t->debug) {
#line 384
        tmp___8 = 1;
      } else {
#line 384
        tmp___8 = 0;
      }
#line 384
      tmp___9 = tmp___8;
    } else {
#line 384
      tmp___9 = t->debug;
    }
#line 384
    if (tmp___9) {
      {
#line 385
      l2tp_log(7, "%s: Peer did not specify framing capability.  Closing.\n", "control_finish");
      }
    }
    {
#line 388
    set_error(c, 6, "Specify framing capability");
#line 389
    c->needclose = -1;
    }
#line 390
    return (-22);
  }
  {
#line 404
  tmp___12 = strlen((char const   *)(t->hostname));
  }
#line 404
  if (! tmp___12) {
#line 404
    if (t->chal_us.state) {
#line 404
      goto _L___3;
    } else
#line 404
    if ((t->lns)->challenge) {
      _L___3: /* CIL Label */ 
#line 406
      if (c) {
#line 406
        if (c->debug) {
#line 406
          tmp___10 = 1;
        } else
#line 406
        if (t->debug) {
#line 406
          tmp___10 = 1;
        } else {
#line 406
          tmp___10 = 0;
        }
#line 406
        tmp___11 = tmp___10;
      } else {
#line 406
        tmp___11 = t->debug;
      }
#line 406
      if (tmp___11) {
        {
#line 407
        l2tp_log(7, "%s: Peer did not specify hostname.  Closing.\n", "control_finish");
        }
      }
      {
#line 410
      set_error(c, 6, "Specify your hostname");
#line 411
      c->needclose = -1;
      }
#line 412
      return (-22);
    }
  }
#line 414
  y = tunnels.head;
  {
#line 415
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 415
    if (! y) {
#line 415
      goto while_break___1;
    }
#line 417
    if (y->tid == t->tid) {
#line 417
      if (y->peer.sin_addr.s_addr == t->peer.sin_addr.s_addr) {
#line 417
        if (! gconfig.ipsecsaref) {
#line 417
          goto _L___4;
        } else
#line 417
        if (y->refhim == t->refhim) {
          _L___4: /* CIL Label */ 
#line 417
          if ((unsigned long )y != (unsigned long )t) {
            {
#line 428
            l2tp_log(7, "%s: Peer requested tunnel %d twice, ignoring second one.\n",
                     "control_finish", t->tid);
#line 431
            c->needclose = 0;
#line 432
            c->closing = -1;
            }
#line 433
            return (0);
          }
        }
      }
    }
#line 435
    y = y->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 437
  t->state = 2;
#line 438
  buf = new_outgoing(t);
#line 439
  add_message_type_avp(buf, (_u16 )2);
  }
#line 440
  if (t->hbit) {
    {
#line 442
    mk_challenge(t->chal_them.vector, 16);
#line 443
    add_randvect_avp(buf, t->chal_them.vector, 16);
    }
  }
  {
#line 445
  add_protocol_avp(buf);
#line 446
  add_frame_caps_avp(buf, (_u16 )t->ourfc);
#line 447
  add_bearer_caps_avp(buf, (_u16 )t->ourbc);
#line 448
  add_firmware_avp(buf);
  }
#line 449
  if (t->lac) {
#line 449
    if ((t->lac)->hostname) {
#line 449
      if ((t->lac)->hostname[0]) {
        {
#line 450
        add_hostname_avp(buf, (char const   *)((t->lac)->hostname));
        }
      } else {
#line 449
        goto _L___6;
      }
    } else {
#line 449
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 451
  if (t->lns) {
#line 451
    if ((t->lns)->hostname) {
#line 451
      if ((t->lns)->hostname[0]) {
        {
#line 452
        add_hostname_avp(buf, (char const   *)((t->lns)->hostname));
        }
      } else {
        {
#line 454
        add_hostname_avp(buf, (char const   *)(hostname));
        }
      }
    } else {
      {
#line 454
      add_hostname_avp(buf, (char const   *)(hostname));
      }
    }
  } else {
    {
#line 454
    add_hostname_avp(buf, (char const   *)(hostname));
    }
  }
  {
#line 455
  add_vendor_avp(buf);
#line 456
  add_tunnelid_avp(buf, (_u16 )t->ourtid);
  }
#line 457
  if (t->ourrws >= 0) {
    {
#line 458
    add_avp_rws(buf, (_u16 )t->ourrws);
    }
  }
#line 459
  if (t->chal_us.state) {
    {
#line 461
    t->chal_us.ss = (unsigned char)2;
#line 462
    handle_challenge(t, & t->chal_us);
#line 463
    add_chalresp_avp(buf, t->chal_us.response, 16);
    }
  }
#line 465
  if ((t->lns)->challenge) {
#line 467
    if (t->chal_them.challenge) {
      {
#line 468
      free((void *)t->chal_them.challenge);
      }
    }
    {
#line 469
    tmp___13 = malloc((size_t )16);
#line 469
    t->chal_them.challenge = (unsigned char *)tmp___13;
    }
#line 470
    if (! t->chal_them.challenge) {
      {
#line 472
      l2tp_log(4, "%s: malloc failed\n", "control_finish");
#line 473
      set_error(c, 6, "malloc failed");
#line 474
      toss(buf);
      }
#line 475
      return (-22);
    }
    {
#line 477
    mk_challenge(t->chal_them.challenge, 16);
#line 478
    t->chal_them.chal_len = 16U;
#line 479
    t->chal_them.ss = (unsigned char)3;
#line 480
    tmp___14 = handle_challenge(t, & t->chal_them);
    }
#line 480
    if (tmp___14) {
      {
#line 483
      l2tp_log(4, "%s: No secret for \'%s\'\n", "control_finish", t->hostname);
#line 485
      set_error(c, 6, "No secret on our side");
#line 486
      toss(buf);
      }
#line 487
      return (-22);
    }
    {
#line 489
    add_challenge_avp(buf, t->chal_them.challenge, (int )t->chal_them.chal_len);
    }
  }
  {
#line 492
  add_control_hdr(t, c, buf);
  }
#line 493
  if (gconfig.packet_dump) {
    {
#line 494
    do_packet_dump(buf);
    }
  }
#line 495
  c->cnu = 0;
#line 496
  if (gconfig.debug_state) {
    {
#line 497
    l2tp_log(7, "%s: sending SCCRP\n", "control_finish");
    }
  }
  {
#line 499
  control_xmit((void *)buf);
  }
#line 500
  goto switch_break;
  case_2: /* CIL Label */ 
#line 506
  if (t->fc < 0) {
#line 508
    if (c) {
#line 508
      if (c->debug) {
#line 508
        tmp___15 = 1;
      } else
#line 508
      if (t->debug) {
#line 508
        tmp___15 = 1;
      } else {
#line 508
        tmp___15 = 0;
      }
#line 508
      tmp___16 = tmp___15;
    } else {
#line 508
      tmp___16 = t->debug;
    }
#line 508
    if (tmp___16) {
      {
#line 509
      l2tp_log(7, "%s: Peer did not specify framing capability.  Closing.\n", "control_finish");
      }
    }
    {
#line 512
    set_error(c, 6, "Specify framing capability");
#line 513
    c->needclose = -1;
    }
#line 514
    return (-22);
  }
  {
#line 528
  tmp___19 = strlen((char const   *)(t->hostname));
  }
#line 528
  if (! tmp___19) {
#line 528
    if (t->chal_them.state) {
#line 528
      goto _L___7;
    } else
#line 528
    if (t->chal_us.state) {
      _L___7: /* CIL Label */ 
#line 530
      if (c) {
#line 530
        if (c->debug) {
#line 530
          tmp___17 = 1;
        } else
#line 530
        if (t->debug) {
#line 530
          tmp___17 = 1;
        } else {
#line 530
          tmp___17 = 0;
        }
#line 530
        tmp___18 = tmp___17;
      } else {
#line 530
        tmp___18 = t->debug;
      }
#line 530
      if (tmp___18) {
        {
#line 531
        l2tp_log(7, "%s: Peer did not specify hostname.  Closing.\n", "control_finish");
        }
      }
      {
#line 534
      set_error(c, 6, "Specify your hostname");
#line 535
      c->needclose = -1;
      }
#line 536
      return (-22);
    }
  }
#line 538
  if (t->tid <= 0) {
#line 540
    if (c) {
#line 540
      if (c->debug) {
#line 540
        tmp___20 = 1;
      } else
#line 540
      if (t->debug) {
#line 540
        tmp___20 = 1;
      } else {
#line 540
        tmp___20 = 0;
      }
#line 540
      tmp___21 = tmp___20;
    } else {
#line 540
      tmp___21 = t->debug;
    }
#line 540
    if (tmp___21) {
      {
#line 541
      l2tp_log(7, "%s: Peer did not specify assigned tunnel ID.  Closing.\n", "control_finish");
      }
    }
    {
#line 544
    set_error(c, 6, "Specify your assigned tunnel ID");
#line 545
    c->needclose = -1;
    }
#line 546
    return (-22);
  }
#line 548
  if (t->chal_them.state) {
    {
#line 550
    t->chal_them.ss = (unsigned char)2;
#line 551
    tmp___22 = handle_challenge(t, & t->chal_them);
    }
#line 551
    if (tmp___22) {
      {
#line 553
      set_error(c, 6, "No secret key on our side");
#line 554
      l2tp_log(4, "%s: No secret key for authenticating \'%s\'\n", "control_finish",
               t->hostname);
#line 556
      c->needclose = -1;
      }
#line 557
      return (-22);
    }
    {
#line 559
    tmp___23 = memcmp((void const   *)(t->chal_them.reply), (void const   *)(t->chal_them.response),
                      (size_t )16);
    }
#line 559
    if (tmp___23) {
      {
#line 562
      set_error(c, 6, "Invalid challenge authentication");
#line 564
      l2tp_log(7, "%s: Invalid authentication for host \'%s\'\n", "control_finish",
               t->hostname);
#line 566
      c->needclose = -1;
      }
#line 567
      return (-22);
    }
  }
#line 570
  if (t->chal_us.state) {
    {
#line 572
    t->chal_us.ss = (unsigned char)3;
#line 573
    tmp___24 = handle_challenge(t, & t->chal_us);
    }
#line 573
    if (tmp___24) {
      {
#line 575
      l2tp_log(4, "%s: No secret for authenticating to \'%s\'\n", "control_finish",
               t->hostname);
#line 577
      set_error(c, 6, "No secret key on our end");
#line 578
      c->needclose = -1;
      }
#line 579
      return (-22);
    }
  }
  {
#line 582
  t->state = 3;
#line 583
  buf = new_outgoing(t);
#line 584
  add_message_type_avp(buf, (_u16 )3);
  }
#line 585
  if (t->hbit) {
    {
#line 587
    mk_challenge(t->chal_them.vector, 16);
#line 588
    add_randvect_avp(buf, t->chal_them.vector, 16);
    }
  }
#line 590
  if (t->chal_us.state) {
    {
#line 591
    add_chalresp_avp(buf, t->chal_us.response, 16);
    }
  }
  {
#line 592
  add_control_hdr(t, c, buf);
  }
#line 593
  if (gconfig.packet_dump) {
    {
#line 594
    do_packet_dump(buf);
    }
  }
#line 595
  c->cnu = 0;
#line 596
  if (gconfig.debug_state) {
    {
#line 597
    l2tp_log(7, "%s: sending SCCCN\n", "control_finish");
    }
  }
  {
#line 598
  control_xmit((void *)buf);
#line 601
  connect_pppol2tp(t);
#line 605
  tv.tv_sec = (__time_t )60;
#line 606
  tv.tv_usec = (__suseconds_t )0;
#line 611
  t->hello = schedule(tv, & hello, (void *)t);
#line 612
  tmp___25 = ntohs(t->peer.sin_port);
#line 612
  tmp___26 = inet_ntoa(t->peer.sin_addr);
#line 612
  l2tp_log(5, "Connection established to %s, %d.  Local: %d, Remote: %d (ref=%u/%u).\n",
           tmp___26, (int )tmp___25, t->ourtid, t->tid, t->refme, t->refhim);
  }
#line 617
  if (t->lac) {
    {
#line 621
    magic_lac_dial((void *)t->lac);
    }
  }
#line 623
  goto switch_break;
  case_3: /* CIL Label */ 
#line 625
  if (t->chal_them.state) {
    {
#line 627
    tmp___27 = memcmp((void const   *)(t->chal_them.reply), (void const   *)(t->chal_them.response),
                      (size_t )16);
    }
#line 627
    if (tmp___27) {
      {
#line 630
      set_error(c, 6, "Invalid challenge authentication");
#line 632
      l2tp_log(7, "%s: Invalid authentication for host \'%s\'\n", "control_finish",
               t->hostname);
#line 634
      c->needclose = -1;
      }
#line 635
      return (-22);
    }
  }
  {
#line 638
  t->state = 3;
#line 639
  tmp___28 = ntohs(t->peer.sin_port);
#line 639
  tmp___29 = inet_ntoa(t->peer.sin_addr);
#line 639
  l2tp_log(5, "Connection established to %s, %d.  Local: %d, Remote: %d (ref=%u/%u).  LNS session is \'%s\'\n",
           tmp___29, (int )tmp___28, t->ourtid, t->tid, t->refme, t->refhim, (t->lns)->entname);
#line 646
  connect_pppol2tp(t);
#line 650
  tv.tv_sec = (__time_t )60;
#line 651
  tv.tv_usec = (__suseconds_t )0;
#line 656
  t->hello = schedule(tv, & hello, (void *)t);
  }
#line 657
  goto switch_break;
  case_4: /* CIL Label */ 
#line 659
  if (t->qtid < 0) {
#line 661
    if (c) {
#line 661
      if (c->debug) {
#line 661
        tmp___30 = 1;
      } else
#line 661
      if (t->debug) {
#line 661
        tmp___30 = 1;
      } else {
#line 661
        tmp___30 = 0;
      }
#line 661
      tmp___31 = tmp___30;
    } else {
#line 661
      tmp___31 = t->debug;
    }
#line 661
    if (tmp___31) {
      {
#line 662
      l2tp_log(7, "%s: Peer tried to disconnect without specifying tunnel ID\n", "control_finish");
      }
    }
#line 665
    return (-22);
  }
#line 669
  if (t->firmware == 65280) {
    {
#line 669
    tmp___32 = strncmp((char const   *)(t->vendor), "Deterministic Networks Inc.",
                       (size_t )27);
    }
#line 669
    if (tmp___32) {
#line 672
      tmptid = t->tid;
    } else {
#line 670
      tmptid = t->ourtid;
    }
  } else {
#line 672
    tmptid = t->tid;
  }
#line 673
  if (t->qtid != tmptid) {
#line 673
    if (tmptid > 0) {
#line 675
      if (c) {
#line 675
        if (c->debug) {
#line 675
          tmp___33 = 1;
        } else
#line 675
        if (t->debug) {
#line 675
          tmp___33 = 1;
        } else {
#line 675
          tmp___33 = 0;
        }
#line 675
        tmp___34 = tmp___33;
      } else {
#line 675
        tmp___34 = t->debug;
      }
#line 675
      if (tmp___34) {
        {
#line 676
        l2tp_log(7, "%s: Peer [Vendor:%s] [Firmware:%d (0x%.4x)] tried to disconnect with invalid TID (%d != %d)\n",
                 "control_finish", t->vendor, t->firmware, t->firmware, t->qtid, tmptid);
        }
      }
#line 679
      return (-22);
    }
  }
#line 682
  if (! t->tid) {
#line 683
    t->tid = t->qtid;
  }
#line 684
  if ((t->self)->result < 0) {
#line 686
    if (c) {
#line 686
      if (c->debug) {
#line 686
        tmp___35 = 1;
      } else
#line 686
      if (t->debug) {
#line 686
        tmp___35 = 1;
      } else {
#line 686
        tmp___35 = 0;
      }
#line 686
      tmp___36 = tmp___35;
    } else {
#line 686
      tmp___36 = t->debug;
    }
#line 686
    if (tmp___36) {
      {
#line 687
      l2tp_log(7, "%s: Peer tried to disconnect without specifying result code.\n",
               "control_finish");
      }
    }
#line 690
    return (-22);
  }
  {
#line 692
  tmp___37 = ntohs(t->peer.sin_port);
#line 692
  tmp___38 = inet_ntoa(t->peer.sin_addr);
#line 692
  l2tp_log(6, "%s: Connection closed to %s, port %d (%s), Local: %d, Remote: %d\n",
           "control_finish", tmp___38, (int )tmp___37, (t->self)->errormsg, t->ourtid,
           t->tid);
#line 696
  c->needclose = 0;
#line 697
  c->closing = -1;
  }
#line 698
  goto switch_break;
  case_10: /* CIL Label */ 
#line 700
  p = t->call_head;
#line 701
  if (! p->lns) {
    {
#line 703
    set_error(p, 6, "This tunnel cannot accept calls\n");
#line 704
    call_close(p);
    }
#line 705
    return (-22);
  }
#line 707
  if ((p->lns)->lbit) {
#line 707
    p->lbit = 16384;
  } else {
#line 707
    p->lbit = 0;
  }
#line 710
  if (p->cid < 0) {
#line 712
    if (c) {
#line 712
      if (c->debug) {
#line 712
        tmp___39 = 1;
      } else
#line 712
      if (t->debug) {
#line 712
        tmp___39 = 1;
      } else {
#line 712
        tmp___39 = 0;
      }
#line 712
      tmp___40 = tmp___39;
    } else {
#line 712
      tmp___40 = t->debug;
    }
#line 712
    if (tmp___40) {
      {
#line 713
      l2tp_log(7, "%s: Peer tried to initiate call without call ID\n", "control_finish");
      }
    }
    {
#line 718
    call_close(p);
    }
#line 719
    return (-22);
  }
#line 721
  z = p->next;
  {
#line 722
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 722
    if (! z) {
#line 722
      goto while_break___2;
    }
#line 724
    if (z->cid == p->cid) {
      {
#line 728
      l2tp_log(7, "%s: Peer requested call %d twice, ignoring second one.\n", "control_finish",
               p->cid);
#line 731
      p->needclose = 0;
#line 732
      p->closing = -1;
      }
#line 733
      return (0);
    }
#line 735
    z = z->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 737
  p = t->call_head;
#line 751
  if ((t->lns)->assign_ip) {
    {
#line 752
    p->addr = get_addr((t->lns)->range);
    }
#line 753
    if (! p->addr) {
      {
#line 755
      set_error(p, 4, "No available IP address");
#line 756
      call_close(p);
#line 757
      l2tp_log(7, "%s: Out of IP addresses on tunnel %d!\n", "control_finish", t->tid);
      }
#line 759
      return (-22);
    }
    {
#line 761
    reserve_addr(p->addr);
    }
  } else {
#line 764
    p->addr = 0U;
  }
  {
#line 767
  p->state = 11;
#line 768
  buf = new_outgoing(t);
#line 769
  add_message_type_avp(buf, (_u16 )11);
  }
#line 770
  if (t->hbit) {
    {
#line 772
    mk_challenge(t->chal_them.vector, 16);
#line 773
    add_randvect_avp(buf, t->chal_them.vector, 16);
    }
  }
  {
#line 778
  add_callid_avp(buf, (_u16 )p->ourcid);
#line 787
  add_control_hdr(t, p, buf);
  }
#line 788
  if (gconfig.packet_dump) {
    {
#line 789
    do_packet_dump(buf);
    }
  }
#line 790
  p->cnu = 0;
#line 791
  if (gconfig.debug_state) {
    {
#line 792
    l2tp_log(7, "%s: Sending ICRP\n", "control_finish");
    }
  }
  {
#line 793
  control_xmit((void *)buf);
  }
#line 794
  goto switch_break;
  case_11: /* CIL Label */ 
#line 796
  if (c->cid < 0) {
#line 798
    if (c) {
#line 798
      if (c->debug) {
#line 798
        tmp___41 = 1;
      } else
#line 798
      if (t->debug) {
#line 798
        tmp___41 = 1;
      } else {
#line 798
        tmp___41 = 0;
      }
#line 798
      tmp___42 = tmp___41;
    } else {
#line 798
      tmp___42 = t->debug;
    }
#line 798
    if (tmp___42) {
      {
#line 799
      l2tp_log(7, "%s: Peer tried to negotiate ICRP without specifying call ID\n",
               "control_finish");
      }
    }
#line 802
    c->needclose = -1;
#line 803
    return (-22);
  }
#line 805
  c->state = 12;
#line 806
  if (t->fc & 1) {
#line 807
    c->frame = 1;
  } else {
#line 809
    c->frame = 2;
  }
  {
#line 811
  buf = new_outgoing(t);
#line 812
  add_message_type_avp(buf, (_u16 )12);
  }
#line 813
  if (t->hbit) {
    {
#line 815
    mk_challenge(t->chal_them.vector, 16);
#line 816
    add_randvect_avp(buf, t->chal_them.vector, 16);
    }
  }
  {
#line 818
  add_txspeed_avp(buf, t->txspeed);
#line 819
  add_frame_avp(buf, c->frame);
#line 825
  add_rxspeed_avp(buf, t->rxspeed);
#line 828
  add_control_hdr(t, c, buf);
  }
#line 829
  if (gconfig.packet_dump) {
    {
#line 830
    do_packet_dump(buf);
    }
  }
#line 831
  c->cnu = 0;
#line 832
  if (gconfig.debug_state) {
    {
#line 833
    l2tp_log(7, "%s: Sending ICCN\n", "control_finish");
    }
  }
  {
#line 834
  tmp___43 = inet_ntoa(t->peer.sin_addr);
#line 834
  l2tp_log(5, "Call established with %s, Local: %d, Remote: %d, Serial: %d (ref=%u/%u)\n",
           tmp___43, c->ourcid, c->cid, c->serno, t->refme, t->refhim);
#line 838
  control_xmit((void *)buf);
#line 839
  po = (struct ppp_opts *)((void *)0);
#line 840
  po = add_opt(po, (char *)"passive");
#line 841
  po = add_opt(po, (char *)"nodetach");
  }
#line 842
  if (c->lac) {
#line 844
    if ((c->lac)->defaultroute) {
      {
#line 845
      po = add_opt(po, (char *)"defaultroute");
      }
    }
    {
#line 846
    tmp___44 = inet_ntoa(*((struct in_addr *)(& (c->lac)->localaddr)));
#line 846
    strncpy((char */* __restrict  */)(ip1), (char const   */* __restrict  */)tmp___44,
            sizeof(ip1));
#line 847
    tmp___45 = inet_ntoa(*((struct in_addr *)(& (c->lac)->remoteaddr)));
#line 847
    strncpy((char */* __restrict  */)(ip2), (char const   */* __restrict  */)tmp___45,
            sizeof(ip2));
    }
#line 849
    if ((c->lac)->remoteaddr) {
#line 849
      tmp___46 = (char const   *)(ip2);
    } else {
#line 849
      tmp___46 = "";
    }
#line 849
    if ((c->lac)->localaddr) {
#line 849
      tmp___47 = (char const   *)(ip1);
    } else {
#line 849
      tmp___47 = "";
    }
    {
#line 849
    po = add_opt(po, (char *)"%s:%s", tmp___47, tmp___46);
    }
#line 852
    if ((c->lac)->authself) {
#line 854
      if ((c->lac)->pap_refuse) {
        {
#line 855
        po = add_opt(po, (char *)"refuse-pap");
        }
      }
#line 856
      if ((c->lac)->chap_refuse) {
        {
#line 857
        po = add_opt(po, (char *)"refuse-chap");
        }
      }
    } else {
      {
#line 861
      po = add_opt(po, (char *)"refuse-pap");
#line 862
      po = add_opt(po, (char *)"refuse-chap");
      }
    }
#line 864
    if ((c->lac)->authpeer) {
      {
#line 866
      po = add_opt(po, (char *)"auth");
      }
#line 867
      if ((c->lac)->pap_require) {
        {
#line 868
        po = add_opt(po, (char *)"require-pap");
        }
      }
#line 869
      if ((c->lac)->chap_require) {
        {
#line 870
        po = add_opt(po, (char *)"require-chap");
        }
      }
    }
#line 872
    if ((c->lac)->authname[0]) {
      {
#line 874
      po = add_opt(po, (char *)"name");
#line 875
      po = add_opt(po, (c->lac)->authname);
      }
    }
#line 877
    if ((c->lac)->debug) {
      {
#line 878
      po = add_opt(po, (char *)"debug");
      }
    }
#line 879
    if ((c->lac)->password[0]) {
      {
#line 881
      tmp___48 = pipe((int *)(pppd_passwdfd));
      }
#line 881
      if (tmp___48 == -1) {
        {
#line 883
        l2tp_log(7, "%s: Unable to create password pipe for pppd\n", "control_finish");
        }
#line 885
        return (-22);
      }
      {
#line 887
      tmp___49 = strlen((char const   *)((c->lac)->password));
#line 887
      tmp___50 = write(pppd_passwdfd[1], (void const   *)((c->lac)->password), tmp___49);
      }
#line 887
      if (-1L == tmp___50) {
        {
#line 889
        l2tp_log(7, "%s: Unable to write password to pipe for pppd\n", "control_finish");
#line 891
        close(pppd_passwdfd[1]);
        }
#line 892
        return (-22);
      }
      {
#line 894
      close(pppd_passwdfd[1]);
      }
#line 897
      if (! (c->lac)->redial) {
#line 898
        i = 0;
        {
#line 898
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 898
          if (! (i < 80)) {
#line 898
            goto while_break___3;
          }
#line 899
          (c->lac)->password[i] = (char )'\000';
#line 898
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 901
      po = add_opt(po, (char *)"plugin");
#line 902
      po = add_opt(po, (char *)"passwordfd.so");
#line 903
      po = add_opt(po, (char *)"passwordfd");
#line 904
      snprintf((char */* __restrict  */)(passwdfd_buf), (size_t )32, (char const   */* __restrict  */)"%d",
               pppd_passwdfd[0]);
#line 905
      po = add_opt(po, passwdfd_buf);
      }
    }
#line 907
    if ((c->lac)->pppoptfile[0]) {
      {
#line 909
      po = add_opt(po, (char *)"file");
#line 910
      po = add_opt(po, (c->lac)->pppoptfile);
      }
    }
  }
#line 913
  if ((c->lac)->pass_peer) {
    {
#line 915
    po = add_opt(po, (char *)"ipparam");
#line 916
    tmp___51 = inet_ntoa(t->peer.sin_addr);
#line 916
    po = add_opt(po, tmp___51);
    }
  }
  {
#line 918
  start_pppd(c, po);
#line 919
  opt_destroy(po);
  }
#line 920
  if (c->lac) {
#line 921
    (c->lac)->rtries = 0;
  }
#line 922
  if ((c->lac)->password[0]) {
    {
#line 923
    close(pppd_passwdfd[0]);
    }
  }
#line 924
  goto switch_break;
  case_12: /* CIL Label */ 
#line 926
  if ((unsigned long )c == (unsigned long )t->self) {
    {
#line 928
    l2tp_log(7, "%s: Peer attempted ICCN on the actual tunnel, not the call", "control_finish");
    }
#line 931
    return (-22);
  }
#line 933
  if (c->txspeed < 1) {
    {
#line 935
    l2tp_log(7, "%s: Warning: Peer did not specify transmit speed\n", "control_finish");
    }
  }
#line 942
  if (c->frame < 1) {
    {
#line 944
    l2tp_log(7, "%s: Warning: Peer did not specify framing type\n", "control_finish");
    }
  }
  {
#line 951
  c->state = 12;
#line 952
  tmp___52 = inet_ntoa(*((struct in_addr *)(& (c->lns)->localaddr)));
#line 952
  strncpy((char */* __restrict  */)(ip1), (char const   */* __restrict  */)tmp___52,
          sizeof(ip1));
#line 953
  tmp___53 = inet_ntoa(*((struct in_addr *)(& c->addr)));
#line 953
  strncpy((char */* __restrict  */)(ip2), (char const   */* __restrict  */)tmp___53,
          sizeof(ip2));
#line 954
  po = (struct ppp_opts *)((void *)0);
#line 955
  po = add_opt(po, (char *)"passive");
#line 956
  po = add_opt(po, (char *)"nodetach");
  }
#line 957
  if ((c->lns)->localaddr) {
#line 957
    tmp___54 = (char const   *)(ip1);
  } else {
#line 957
    tmp___54 = "";
  }
  {
#line 957
  po = add_opt(po, (char *)"%s:%s", tmp___54, ip2);
  }
#line 958
  if ((c->lns)->authself) {
#line 960
    if ((c->lns)->pap_refuse) {
      {
#line 961
      po = add_opt(po, (char *)"refuse-pap");
      }
    }
#line 962
    if ((c->lns)->chap_refuse) {
      {
#line 963
      po = add_opt(po, (char *)"refuse-chap");
      }
    }
  } else {
    {
#line 967
    po = add_opt(po, (char *)"refuse-pap");
#line 968
    po = add_opt(po, (char *)"refuse-chap");
    }
  }
#line 970
  if ((c->lns)->authpeer) {
    {
#line 972
    po = add_opt(po, (char *)"auth");
    }
#line 973
    if ((c->lns)->pap_require) {
      {
#line 974
      po = add_opt(po, (char *)"require-pap");
      }
    }
#line 975
    if ((c->lns)->chap_require) {
      {
#line 976
      po = add_opt(po, (char *)"require-chap");
      }
    }
#line 977
    if ((c->lns)->passwdauth) {
      {
#line 978
      po = add_opt(po, (char *)"login");
      }
    }
  }
#line 980
  if ((c->lns)->authname[0]) {
    {
#line 982
    po = add_opt(po, (char *)"name");
#line 983
    po = add_opt(po, (c->lns)->authname);
    }
  }
#line 985
  if ((c->lns)->debug) {
    {
#line 986
    po = add_opt(po, (char *)"debug");
    }
  }
#line 987
  if ((c->lns)->pppoptfile[0]) {
    {
#line 989
    po = add_opt(po, (char *)"file");
#line 990
    po = add_opt(po, (c->lns)->pppoptfile);
    }
  }
#line 992
  if ((c->lns)->pass_peer) {
    {
#line 994
    po = add_opt(po, (char *)"ipparam");
#line 995
    tmp___55 = inet_ntoa(t->peer.sin_addr);
#line 995
    po = add_opt(po, tmp___55);
    }
  }
  {
#line 997
  start_pppd(c, po);
#line 998
  opt_destroy(po);
#line 999
  tmp___56 = inet_ntoa(t->peer.sin_addr);
#line 999
  l2tp_log(5, "Call established with %s, Local: %d, Remote: %d, Serial: %d\n", tmp___56,
           c->ourcid, c->cid, c->serno);
  }
#line 1003
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1005
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1007
  po = (struct ppp_opts *)((void *)0);
#line 1008
  po = add_opt(po, (char *)"passive");
#line 1009
  po = add_opt(po, (char *)"nodetach");
#line 1010
  po = add_opt(po, (char *)"file");
#line 1011
  strcat((char */* __restrict  */)(dummy_buf), (char const   */* __restrict  */)(c->dial_no));
#line 1012
  strcat((char */* __restrict  */)(dummy_buf), (char const   */* __restrict  */)".options");
#line 1013
  po = add_opt(po, dummy_buf);
  }
#line 1014
  if (c->lac) {
#line 1016
    if ((c->lac)->defaultroute) {
      {
#line 1017
      po = add_opt(po, (char *)"defaultroute");
      }
    }
    {
#line 1018
    tmp___57 = inet_ntoa(*((struct in_addr *)(& (c->lac)->localaddr)));
#line 1018
    strncpy((char */* __restrict  */)(ip1), (char const   */* __restrict  */)tmp___57,
            sizeof(ip1));
#line 1019
    tmp___58 = inet_ntoa(*((struct in_addr *)(& (c->lac)->remoteaddr)));
#line 1019
    strncpy((char */* __restrict  */)(ip2), (char const   */* __restrict  */)tmp___58,
            sizeof(ip2));
    }
#line 1020
    if ((c->lac)->remoteaddr) {
#line 1020
      tmp___59 = (char const   *)(ip2);
    } else {
#line 1020
      tmp___59 = "";
    }
#line 1020
    if ((c->lac)->localaddr) {
#line 1020
      tmp___60 = (char const   *)(ip1);
    } else {
#line 1020
      tmp___60 = "";
    }
    {
#line 1020
    po = add_opt(po, (char *)"%s:%s", tmp___60, tmp___59);
    }
#line 1022
    if ((c->lac)->authself) {
#line 1024
      if ((c->lac)->pap_refuse) {
        {
#line 1025
        po = add_opt(po, (char *)"refuse-pap");
        }
      }
#line 1026
      if ((c->lac)->chap_refuse) {
        {
#line 1027
        po = add_opt(po, (char *)"refuse-chap");
        }
      }
    } else {
      {
#line 1031
      po = add_opt(po, (char *)"refuse-pap");
#line 1032
      po = add_opt(po, (char *)"refuse-chap");
      }
    }
#line 1034
    if ((c->lac)->authpeer) {
      {
#line 1036
      po = add_opt(po, (char *)"auth");
      }
#line 1037
      if ((c->lac)->pap_require) {
        {
#line 1038
        po = add_opt(po, (char *)"require-pap");
        }
      }
#line 1039
      if ((c->lac)->chap_require) {
        {
#line 1040
        po = add_opt(po, (char *)"require-chap");
        }
      }
    }
#line 1042
    if ((c->lac)->authname[0]) {
      {
#line 1044
      po = add_opt(po, (char *)"name");
#line 1045
      po = add_opt(po, (c->lac)->authname);
      }
    }
#line 1047
    if ((c->lac)->debug) {
      {
#line 1048
      po = add_opt(po, (char *)"debug");
      }
    }
#line 1049
    if ((c->lac)->pppoptfile[0]) {
      {
#line 1051
      po = add_opt(po, (char *)"file");
#line 1052
      po = add_opt(po, (c->lac)->pppoptfile);
      }
    }
  }
#line 1055
  if ((c->lac)->pass_peer) {
    {
#line 1057
    po = add_opt(po, (char *)"ipparam");
#line 1058
    tmp___61 = inet_ntoa(t->peer.sin_addr);
#line 1058
    po = add_opt(po, tmp___61);
    }
  }
  {
#line 1060
  start_pppd(c, po);
#line 1063
  l2tp_log(6, "parameters: Local: %d , Remote: %d , Serial: %d , Pid: %d , Tunnelid: %d , Phoneid: %s\n",
           c->ourcid, c->cid, c->serno, c->pppd, t->ourtid, c->dial_no);
#line 1067
  opt_destroy(po);
  }
#line 1068
  if (c->lac) {
#line 1069
    (c->lac)->rtries = 0;
  }
#line 1070
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1074
  if (c->qcid < 0) {
#line 1076
    if (c) {
#line 1076
      if (c->debug) {
#line 1076
        tmp___62 = 1;
      } else
#line 1076
      if (t->debug) {
#line 1076
        tmp___62 = 1;
      } else {
#line 1076
        tmp___62 = 0;
      }
#line 1076
      tmp___63 = tmp___62;
    } else {
#line 1076
      tmp___63 = t->debug;
    }
#line 1076
    if (tmp___63) {
      {
#line 1077
      l2tp_log(7, "%s: Peer tried to disconnect without specifying call ID\n", "control_finish");
      }
    }
#line 1080
    return (-22);
  }
#line 1082
  if ((unsigned long )c == (unsigned long )t->self) {
#line 1084
    p = t->call_head;
    {
#line 1085
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1085
      if (p) {
#line 1085
        if (! (p->cid != c->qcid)) {
#line 1085
          goto while_break___4;
        }
      } else {
#line 1085
        goto while_break___4;
      }
#line 1086
      p = p->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1087
    if (! p) {
#line 1089
      if (c) {
#line 1089
        if (c->debug) {
#line 1089
          tmp___64 = 1;
        } else
#line 1089
        if (t->debug) {
#line 1089
          tmp___64 = 1;
        } else {
#line 1089
          tmp___64 = 0;
        }
#line 1089
        tmp___65 = tmp___64;
      } else {
#line 1089
        tmp___65 = t->debug;
      }
#line 1089
      if (tmp___65) {
        {
#line 1090
        l2tp_log(7, "%s: Unable to determine call to be disconnected.\n", "control_finish");
        }
      }
#line 1093
      return (-22);
    }
  } else {
#line 1097
    p = c;
  }
#line 1101
  if (t->firmware == 65280) {
    {
#line 1101
    tmp___66 = strncmp((char const   *)(t->vendor), "Deterministic Networks Inc.",
                       (size_t )27);
    }
#line 1101
    if (tmp___66) {
#line 1104
      tmpcid = p->cid;
    } else {
#line 1102
      tmpcid = p->ourcid;
    }
  } else {
#line 1104
    tmpcid = p->cid;
  }
#line 1106
  if (c->qcid != tmpcid) {
#line 1106
    if (tmpcid > 0) {
#line 1108
      if (c) {
#line 1108
        if (c->debug) {
#line 1108
          tmp___67 = 1;
        } else
#line 1108
        if (t->debug) {
#line 1108
          tmp___67 = 1;
        } else {
#line 1108
          tmp___67 = 0;
        }
#line 1108
        tmp___68 = tmp___67;
      } else {
#line 1108
        tmp___68 = t->debug;
      }
#line 1108
      if (tmp___68) {
        {
#line 1109
        l2tp_log(7, "%s: Peer tried to disconnect with invalid CID (%d != %d)\n",
                 "control_finish", c->qcid, c->ourcid);
        }
      }
#line 1112
      return (-22);
    }
  }
#line 1114
  c->qcid = -1;
#line 1115
  if (c->result < 0) {
#line 1117
    if (c) {
#line 1117
      if (c->debug) {
#line 1117
        tmp___69 = 1;
      } else
#line 1117
      if (t->debug) {
#line 1117
        tmp___69 = 1;
      } else {
#line 1117
        tmp___69 = 0;
      }
#line 1117
      tmp___70 = tmp___69;
    } else {
#line 1117
      tmp___70 = t->debug;
    }
#line 1117
    if (tmp___70) {
      {
#line 1118
      l2tp_log(7, "%s: Peer tried to disconnect without specifying result code.\n",
               "control_finish");
      }
    }
#line 1121
    return (-22);
  }
  {
#line 1123
  tmp___71 = inet_ntoa(t->peer.sin_addr);
#line 1123
  l2tp_log(6, "%s: Connection closed to %s, serial %d (%s)\n", "control_finish", tmp___71,
           c->serno, c->errormsg);
#line 1126
  c->needclose = 0;
#line 1127
  c->closing = -1;
  }
#line 1128
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1130
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1132
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1134
  l2tp_log(7, "%s: Don\'t know how to finish a message of type %d\n", "control_finish",
           c->msgtype);
#line 1137
  set_error(c, 6, "Unimplemented message %d\n", c->msgtype);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1139
  return (0);
}
}
#line 1142 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
__inline int check_control(struct buffer  const  *buf , struct tunnel *t , struct call *c ) 
{ 
  struct control_hdr *h ;
  struct buffer *zlb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1149
  h = (struct control_hdr *)buf->start;
#line 1151
  if ((unsigned long )buf->len < sizeof(struct control_hdr )) {
#line 1153
    if (c) {
#line 1153
      if (c->debug) {
#line 1153
        tmp = 1;
      } else
#line 1153
      if (t->debug) {
#line 1153
        tmp = 1;
      } else {
#line 1153
        tmp = 0;
      }
#line 1153
      tmp___0 = tmp;
    } else {
#line 1153
      tmp___0 = t->debug;
    }
#line 1153
    if (tmp___0) {
      {
#line 1155
      l2tp_log(7, "%s: Received too small of packet\n", "check_control");
      }
    }
#line 1158
    return (-22);
  }
#line 1161
  if (buf->len != (int const   )h->length) {
#line 1163
    if (c) {
#line 1163
      if (c->debug) {
#line 1163
        tmp___1 = 1;
      } else
#line 1163
      if (t->debug) {
#line 1163
        tmp___1 = 1;
      } else {
#line 1163
        tmp___1 = 0;
      }
#line 1163
      tmp___2 = tmp___1;
    } else {
#line 1163
      tmp___2 = t->debug;
    }
#line 1163
    if (tmp___2) {
      {
#line 1165
      l2tp_log(7, "%s: Reported and actual sizes differ (%d != %d)\n", "check_control",
               (int )h->length, buf->len);
      }
    }
#line 1169
    return (-22);
  }
#line 1178
  if ((int )h->Ns != (int )t->control_rec_seq_num) {
#line 1180
    if (c) {
#line 1180
      if (c->debug) {
#line 1180
        tmp___3 = 1;
      } else
#line 1180
      if (t->debug) {
#line 1180
        tmp___3 = 1;
      } else {
#line 1180
        tmp___3 = 0;
      }
#line 1180
      tmp___4 = tmp___3;
    } else {
#line 1180
      tmp___4 = t->debug;
    }
#line 1180
    if (tmp___4) {
      {
#line 1181
      l2tp_log(7, "%s: Received out of order control packet on tunnel %d (got %d, expected %d)\n",
               "check_control", t->tid, (int )h->Ns, (int )t->control_rec_seq_num);
      }
    }
#line 1184
    if ((int )h->Ns < (int )t->control_rec_seq_num) {
#line 1184
      if ((int )t->control_rec_seq_num - (int )h->Ns < 32768) {
        {
#line 1199
        zlb = new_outgoing(t);
#line 1200
        control_zlb(zlb, t, c);
#line 1201
        udp_xmit(zlb, t);
#line 1202
        toss(zlb);
        }
      } else {
#line 1184
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1184
    if ((int )h->Ns > (int )t->control_rec_seq_num) {
#line 1184
      if ((int )t->control_rec_seq_num - (int )h->Ns > 32768) {
        {
#line 1199
        zlb = new_outgoing(t);
#line 1200
        control_zlb(zlb, t, c);
#line 1201
        udp_xmit(zlb, t);
#line 1202
        toss(zlb);
        }
      } else {
#line 1184
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1204
    if (! t->control_rec_seq_num) {
#line 1204
      if (t->tid == -1) {
#line 1208
        c->needclose = 0;
#line 1209
        c->closing = -1;
      }
    }
#line 1211
    return (-22);
  } else {
#line 1215
    t->control_rec_seq_num = (_u16 )((int )t->control_rec_seq_num + 1);
#line 1216
    c->cnu = -1;
  }
#line 1223
  t->cLr = (int )h->Nr;
#line 1224
  if (t->sanity) {
#line 1226
    if (! ((int )h->ver & 32768)) {
#line 1228
      if (c) {
#line 1228
        if (c->debug) {
#line 1228
          tmp___5 = 1;
        } else
#line 1228
        if (t->debug) {
#line 1228
          tmp___5 = 1;
        } else {
#line 1228
          tmp___5 = 0;
        }
#line 1228
        tmp___6 = tmp___5;
      } else {
#line 1228
        tmp___6 = t->debug;
      }
#line 1228
      if (tmp___6) {
        {
#line 1230
        l2tp_log(7, "%s: Control bit not set\n", "check_control");
        }
      }
#line 1232
      return (-22);
    }
#line 1234
    if (! ((int )h->ver & 16384)) {
#line 1236
      if (c) {
#line 1236
        if (c->debug) {
#line 1236
          tmp___7 = 1;
        } else
#line 1236
        if (t->debug) {
#line 1236
          tmp___7 = 1;
        } else {
#line 1236
          tmp___7 = 0;
        }
#line 1236
        tmp___8 = tmp___7;
      } else {
#line 1236
        tmp___8 = t->debug;
      }
#line 1236
      if (tmp___8) {
        {
#line 1238
        l2tp_log(7, "%s: Length bit not set\n", "check_control");
        }
      }
#line 1240
      return (-22);
    }
#line 1242
    if (! ((int )h->ver & 2048)) {
#line 1244
      if (c) {
#line 1244
        if (c->debug) {
#line 1244
          tmp___9 = 1;
        } else
#line 1244
        if (t->debug) {
#line 1244
          tmp___9 = 1;
        } else {
#line 1244
          tmp___9 = 0;
        }
#line 1244
        tmp___10 = tmp___9;
      } else {
#line 1244
        tmp___10 = t->debug;
      }
#line 1244
      if (tmp___10) {
        {
#line 1246
        l2tp_log(7, "%s: Flow bit not set\n", "check_control");
        }
      }
#line 1248
      return (-22);
    }
#line 1250
    if (((int )h->ver & 7) != 2) {
#line 1252
      if (c) {
#line 1252
        if (c->debug) {
#line 1252
          tmp___11 = 1;
        } else
#line 1252
        if (t->debug) {
#line 1252
          tmp___11 = 1;
        } else {
#line 1252
          tmp___11 = 0;
        }
#line 1252
        tmp___12 = tmp___11;
      } else {
#line 1252
        tmp___12 = t->debug;
      }
#line 1252
      if (tmp___12) {
#line 1254
        if (((int )h->ver & 7) == 3) {
          {
#line 1256
          l2tp_log(7, "%s: PPTP packet received\n", "check_control");
          }
        } else
#line 1259
        if (((int )h->ver & 7) < 2) {
          {
#line 1261
          l2tp_log(7, "%s: L2F packet received\n", "check_control");
          }
        } else {
          {
#line 1266
          l2tp_log(7, "%s: Unknown version received\n", "check_control");
          }
        }
      }
#line 1270
      return (-22);
    }
  }
#line 1275
  return (0);
}
}
#line 1278 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
__inline int check_payload(struct buffer *buf , struct tunnel *t , struct call *c ) 
{ 
  int ehlen ;
  struct payload_hdr *h ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1286
  ehlen = 6;
#line 1287
  h = (struct payload_hdr *)buf->start;
#line 1288
  if (! c) {
#line 1290
    if (c) {
#line 1290
      if (c->debug) {
#line 1290
        tmp = 1;
      } else
#line 1290
      if (t->debug) {
#line 1290
        tmp = 1;
      } else {
#line 1290
        tmp = 0;
      }
#line 1290
      tmp___0 = tmp;
    } else {
#line 1290
      tmp___0 = t->debug;
    }
#line 1290
    if (tmp___0) {
      {
#line 1292
      l2tp_log(7, "%s: Aempted to send payload on tunnel\n", "check_payload");
      }
    }
#line 1295
    return (-22);
  }
#line 1297
  if (buf->len < 6) {
#line 1301
    if (c) {
#line 1301
      if (c->debug) {
#line 1301
        tmp___1 = 1;
      } else
#line 1301
      if (t->debug) {
#line 1301
        tmp___1 = 1;
      } else {
#line 1301
        tmp___1 = 0;
      }
#line 1301
      tmp___2 = tmp___1;
    } else {
#line 1301
      tmp___2 = t->debug;
    }
#line 1301
    if (tmp___2) {
      {
#line 1303
      l2tp_log(7, "%s:Recieved to small of packet\n", "check_payload");
      }
    }
#line 1305
    return (-22);
  }
#line 1308
  if (t->sanity) {
#line 1310
    if ((int )h->ver & 32768) {
#line 1312
      if (c) {
#line 1312
        if (c->debug) {
#line 1312
          tmp___3 = 1;
        } else
#line 1312
        if (t->debug) {
#line 1312
          tmp___3 = 1;
        } else {
#line 1312
          tmp___3 = 0;
        }
#line 1312
        tmp___4 = tmp___3;
      } else {
#line 1312
        tmp___4 = t->debug;
      }
#line 1312
      if (tmp___4) {
        {
#line 1314
        l2tp_log(7, "%s Control bit set\n", "check_payload");
        }
      }
#line 1316
      return (-22);
    }
#line 1318
    if ((int )h->ver & 16384) {
#line 1319
      ehlen += 2;
    }
#line 1320
    if ((int )h->ver & 2048) {
#line 1327
      ehlen += 4;
    }
#line 1336
    if ((int )h->ver & 512) {
#line 1337
      ehlen += 2;
    }
#line 1338
    if ((int )h->ver & 16384) {
#line 1339
      ehlen += (int )h->length;
    }
#line 1340
    if (((int )h->ver & 7) != 2) {
#line 1342
      if (c) {
#line 1342
        if (c->debug) {
#line 1342
          tmp___5 = 1;
        } else
#line 1342
        if (t->debug) {
#line 1342
          tmp___5 = 1;
        } else {
#line 1342
          tmp___5 = 0;
        }
#line 1342
        tmp___6 = tmp___5;
      } else {
#line 1342
        tmp___6 = t->debug;
      }
#line 1342
      if (tmp___6) {
#line 1344
        if (((int )h->ver & 7) == 3) {
          {
#line 1346
          l2tp_log(7, "%s: PPTP packet received\n", "check_payload");
          }
        } else
#line 1349
        if (((int )h->ver & 7) < 2) {
          {
#line 1351
          l2tp_log(7, "%s: L2F packet received\n", "check_payload");
          }
        } else {
          {
#line 1356
          l2tp_log(7, "%s: Unknown version received\n", "check_payload");
          }
        }
      }
#line 1360
      return (-22);
    }
#line 1362
    if (buf->len < ehlen) {
#line 1362
      if (! ((int )h->ver & 16384)) {
#line 1364
        if (c) {
#line 1364
          if (c->debug) {
#line 1364
            tmp___7 = 1;
          } else
#line 1364
          if (t->debug) {
#line 1364
            tmp___7 = 1;
          } else {
#line 1364
            tmp___7 = 0;
          }
#line 1364
          tmp___8 = tmp___7;
        } else {
#line 1364
          tmp___8 = t->debug;
        }
#line 1364
        if (tmp___8) {
          {
#line 1366
          l2tp_log(7, "%s payload too small (%d < %d)\n", "check_payload", buf->len,
                   ehlen);
          }
        }
#line 1369
        return (-22);
      }
    }
#line 1371
    if (buf->len != (int )h->length) {
#line 1371
      if ((int )h->ver & 16384) {
#line 1373
        if (c) {
#line 1373
          if (c->debug) {
#line 1373
            tmp___9 = 1;
          } else
#line 1373
          if (t->debug) {
#line 1373
            tmp___9 = 1;
          } else {
#line 1373
            tmp___9 = 0;
          }
#line 1373
          tmp___10 = tmp___9;
        } else {
#line 1373
          tmp___10 = t->debug;
        }
#line 1373
        if (tmp___10) {
          {
#line 1375
          l2tp_log(7, "%s: size mismatch (%d != %d)\n", "check_payload", buf->len,
                   (int )h->length);
          }
        }
#line 1378
        return (-22);
      }
    }
  }
#line 1382
  return (0);
}
}
#line 1384 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
__inline int expand_payload(struct buffer *buf , struct tunnel *t , struct call *c ) 
{ 
  struct payload_hdr *h ;
  _u16 *r ;
  struct payload_hdr *new_hdr ;
  int ehlen ;

  {
#line 1391
  h = (struct payload_hdr *)buf->start;
#line 1392
  r = (_u16 *)h;
#line 1394
  ehlen = 0;
#line 1398
  if (! ((int )h->ver & 16384)) {
#line 1399
    ehlen += 2;
  }
#line 1400
  if (! ((int )h->ver & 2048)) {
#line 1401
    ehlen += 4;
  }
#line 1402
  if (! ((int )h->ver & 512)) {
#line 1403
    ehlen += 2;
  }
#line 1404
  if (ehlen) {
#line 1410
    new_hdr = (struct payload_hdr *)(buf->start - ehlen);
#line 1411
    if ((unsigned long )((void *)new_hdr) < (unsigned long )buf->rstart) {
      {
#line 1413
      l2tp_log(4, "%s: not enough space to decompress frame\n", "expand_payload");
      }
#line 1415
      return (-22);
    }
#line 1418
    new_hdr->ver = *r;
#line 1419
    if ((int )new_hdr->ver & 16384) {
#line 1421
      r ++;
#line 1422
      new_hdr->length = *r;
    } else {
#line 1426
      new_hdr->length = (_u16 )(buf->len + ehlen);
    }
#line 1428
    r ++;
#line 1429
    new_hdr->tid = *r;
#line 1430
    r ++;
#line 1431
    new_hdr->cid = *r;
#line 1432
    if ((int )new_hdr->ver & 2048) {
#line 1434
      r ++;
#line 1435
      new_hdr->Ns = *r;
#line 1436
      r ++;
#line 1437
      new_hdr->Nr = *r;
    } else {
#line 1441
      new_hdr->Nr = c->data_seq_num;
#line 1442
      new_hdr->Ns = c->data_rec_seq_num;
    }
#line 1444
    if ((int )new_hdr->ver & 512) {
#line 1446
      r ++;
#line 1447
      new_hdr->o_size = *r;
    } else {
#line 1453
      new_hdr->o_size = (_u16 )0;
    }
  } else {
#line 1458
    new_hdr = h;
  }
#line 1477
  if ((int )new_hdr->Ns != (int )c->data_seq_num) {
#line 1480
    if ((int )new_hdr->Ns < (int )c->data_rec_seq_num) {
#line 1480
      if ((int )c->data_rec_seq_num - (int )new_hdr->Ns < 32768) {
#line 1491
        return (-22);
      } else {
#line 1480
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1480
    if ((int )new_hdr->Ns > (int )c->data_rec_seq_num) {
#line 1480
      if ((int )c->data_rec_seq_num - (int )new_hdr->Ns > 32768) {
#line 1491
        return (-22);
      } else {
#line 1480
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1493
    if ((int )new_hdr->Ns <= (int )c->data_rec_seq_num + 2) {
#line 1502
      c->data_rec_seq_num = new_hdr->Ns;
    } else {
#line 1512
      return (-22);
    }
  } else {
#line 1517
    c->data_rec_seq_num = (_u16 )((int )c->data_rec_seq_num + 1);
#line 1518
    c->pnu = -1;
  }
#line 1524
  c->pLr = (int )new_hdr->Nr;
#line 1525
  buf->start = (void *)new_hdr;
#line 1526
  buf->len += ehlen;
#line 1527
  return (0);
}
}
#line 1530 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
void send_zlb(void *data ) 
{ 
  struct call *c ;
  struct tunnel *t ;
  struct buffer *buf ;

  {
#line 1538
  c = (struct call *)data;
#line 1539
  if (! c) {
    {
#line 1541
    l2tp_log(4, "%s: called on NULL call\n", "send_zlb");
    }
#line 1542
    return;
  }
#line 1544
  t = c->container;
#line 1545
  if (! t) {
    {
#line 1547
    l2tp_log(4, "%s: called on call with NULL container\n", "send_zlb");
    }
#line 1549
    return;
  }
  {
#line 1552
  c->prx = (int )c->data_rec_seq_num;
#line 1553
  buf = new_payload(t->peer);
#line 1554
  add_payload_hdr(t, c, buf);
#line 1555
  c->data_seq_num = (_u16 )((int )c->data_seq_num - 1);
#line 1556
  c->zlb_xmit = (struct schedule_entry *)((void *)0);
#line 1560
  udp_xmit(buf, t);
#line 1561
  toss(buf);
  }
#line 1562
  return;
}
}
#line 1574 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
static unsigned char wbuf[4096]  ;
#line 1564 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
__inline int write_packet(struct buffer *buf , struct tunnel *t , struct call *c ,
                          int convert ) 
{ 
  int x ;
  unsigned char e ;
  int err ;
  int pos___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _u16 offset ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ssize_t tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;

  {
#line 1575
  pos___0 = 0;
#line 1577
  if (c->fd < 0) {
#line 1579
    if (c) {
#line 1579
      if (c->debug) {
#line 1579
        tmp = 1;
      } else
#line 1579
      if (t->debug) {
#line 1579
        tmp = 1;
      } else {
#line 1579
        tmp = 0;
      }
#line 1579
      tmp___1 = tmp;
    } else {
#line 1579
      if (t->debug) {
#line 1579
        tmp___0 = 1;
      } else {
#line 1579
        tmp___0 = 1;
      }
#line 1579
      tmp___1 = tmp___0;
    }
#line 1579
    if (tmp___1) {
      {
#line 1580
      l2tp_log(7, "%s: tty is not open yet.\n", "write_packet");
      }
    }
#line 1581
    return (-5);
  }
#line 1586
  offset = ((struct payload_hdr *)buf->start)->o_size;
#line 1587
  buf->start += sizeof(struct payload_hdr ) + (unsigned long )offset;
#line 1588
  buf->len = (int )((unsigned long )buf->len - (sizeof(struct payload_hdr ) + (unsigned long )offset));
#line 1590
  (c->rx_pkts) ++;
#line 1591
  c->rx_bytes += buf->len;
  {
#line 1596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1596
    if (! (! convert)) {
#line 1596
      goto while_break;
    }
    {
#line 1600
    tmp___2 = write(c->fd, (void const   *)buf->start, (size_t )buf->len);
#line 1600
    err = (int )tmp___2;
    }
#line 1601
    if (err == buf->len) {
#line 1603
      return (0);
    } else
#line 1605
    if (err == 0) {
      {
#line 1607
      l2tp_log(4, "%s: wrote no bytes of async packet\n", "write_packet");
      }
#line 1609
      return (-22);
    } else
#line 1611
    if (err < 0) {
      {
#line 1613
      tmp___5 = __errno_location();
      }
#line 1613
      if (*tmp___5 == 11) {
#line 1615
        goto while_continue;
      } else {
        {
#line 1613
        tmp___6 = __errno_location();
        }
#line 1613
        if (*tmp___6 == 4) {
#line 1615
          goto while_continue;
        } else {
          {
#line 1619
          tmp___3 = __errno_location();
#line 1619
          tmp___4 = strerror(*tmp___3);
#line 1619
          l2tp_log(4, "%s: async write failed: %s\n", "write_packet", tmp___4);
          }
        }
      }
    } else
#line 1623
    if (err < buf->len) {
      {
#line 1625
      l2tp_log(4, "%s: short write (%d of %d bytes)\n", "write_packet", err, buf->len);
      }
#line 1627
      return (-22);
    } else
#line 1629
    if (err > buf->len) {
      {
#line 1631
      l2tp_log(4, "%s: write returned LONGER than buffer length?\n", "write_packet");
      }
#line 1633
      return (-22);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1643
  add_fcs(buf);
#line 1644
  e = (unsigned char)126;
#line 1645
  tmp___7 = pos___0;
#line 1645
  pos___0 ++;
#line 1645
  wbuf[tmp___7] = e;
#line 1646
  x = 0;
  }
  {
#line 1646
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1646
    if (! (x < buf->len)) {
#line 1646
      goto while_break___0;
    }
#line 1650
    if ((unsigned long )pos___0 >= sizeof(wbuf) - 4UL) {
#line 1651
      if (c) {
#line 1651
        if (c->debug) {
#line 1651
          tmp___8 = 1;
        } else
#line 1651
        if (t->debug) {
#line 1651
          tmp___8 = 1;
        } else {
#line 1651
          tmp___8 = 0;
        }
#line 1651
        tmp___9 = tmp___8;
      } else {
#line 1651
        tmp___9 = t->debug;
      }
#line 1651
      if (tmp___9) {
        {
#line 1652
        l2tp_log(2, "%s: rx packet is too big after PPP encoding (size %u, max is %u)\n",
                 "write_packet", buf->len, 4096);
        }
      }
#line 1654
      return (-22);
    }
#line 1656
    e = (unsigned char )*((char *)buf->start + x);
#line 1657
    if ((int )e < 32) {
#line 1660
      e = (unsigned char )((int )e ^ 32);
#line 1661
      tmp___10 = pos___0;
#line 1661
      pos___0 ++;
#line 1661
      wbuf[tmp___10] = (unsigned char)125;
    } else
#line 1657
    if ((int )e == 125) {
#line 1660
      e = (unsigned char )((int )e ^ 32);
#line 1661
      tmp___10 = pos___0;
#line 1661
      pos___0 ++;
#line 1661
      wbuf[tmp___10] = (unsigned char)125;
    } else
#line 1657
    if ((int )e == 126) {
#line 1660
      e = (unsigned char )((int )e ^ 32);
#line 1661
      tmp___10 = pos___0;
#line 1661
      pos___0 ++;
#line 1661
      wbuf[tmp___10] = (unsigned char)125;
    }
#line 1663
    tmp___11 = pos___0;
#line 1663
    pos___0 ++;
#line 1663
    wbuf[tmp___11] = e;
#line 1646
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1666
  tmp___12 = pos___0;
#line 1666
  pos___0 ++;
#line 1666
  wbuf[tmp___12] = (unsigned char)126;
#line 1675
  x = 0;
  {
#line 1676
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1676
    if (! (pos___0 != x)) {
#line 1676
      goto while_break___1;
    }
    {
#line 1678
    tmp___13 = write(c->fd, (void const   *)(wbuf + x), (size_t )(pos___0 - x));
#line 1678
    err = (int )tmp___13;
    }
#line 1679
    if (err < 0) {
      {
#line 1680
      tmp___17 = __errno_location();
      }
#line 1680
      if (*tmp___17 != 4) {
        {
#line 1680
        tmp___18 = __errno_location();
        }
#line 1680
        if (*tmp___18 != 11) {
          {
#line 1681
          tmp___14 = __errno_location();
#line 1681
          tmp___15 = __errno_location();
#line 1681
          tmp___16 = strerror(*tmp___15);
#line 1681
          l2tp_log(4, "%s: %s(%d)\n", "write_packet", tmp___16, *tmp___14);
#line 1687
          c->needclose = -1;
#line 1688
          c->fd = -1;
          }
#line 1689
          return (-5);
        } else {
#line 1692
          goto while_continue___1;
        }
      } else {
#line 1692
        goto while_continue___1;
      }
    }
#line 1695
    x += err;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1697
  return (0);
}
}
#line 1700 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
void handle_special(struct buffer *buf , struct call *c , _u16 call ) 
{ 
  struct tunnel *t ;
  int tmp ;

  {
#line 1709
  t = c->container;
#line 1711
  if (! ((int )*((_u16 *)buf->start) & 32768)) {
#line 1712
    return;
  }
  {
#line 1716
  c->cid = (int )call;
#line 1717
  tmp = check_control((struct buffer  const  *)buf, t, c);
  }
#line 1717
  if (tmp) {
#line 1736
    c->cid = 0;
#line 1737
    if (gconfig.debug_tunnel) {
      {
#line 1738
      l2tp_log(7, "%s: invalid control packet\n", "handle_special");
      }
    }
  } else {
#line 1719
    if ((unsigned long )buf->len == sizeof(struct control_hdr )) {
#line 1722
      if (gconfig.debug_tunnel) {
        {
#line 1723
        l2tp_log(7, "%s: ZLB for closed call\n", "handle_special");
        }
      }
#line 1724
      c->cid = 0;
#line 1725
      return;
    }
    {
#line 1729
    control_zlb(buf, t, c);
#line 1730
    c->cid = 0;
#line 1731
    udp_xmit(buf, t);
#line 1732
    toss(buf);
    }
  }
#line 1740
  return;
}
}
#line 1742 "/home/june/repo/benchmarks/collector2/temp/xl2tpd-1.3.6+dfsg/control.c"
int handle_packet(struct buffer *buf , struct tunnel *t , struct call *c ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1751
  if ((int )*((_u16 *)buf->start) & 32768) {
    {
#line 1754
    tmp___1 = check_control((struct buffer  const  *)buf, t, c);
    }
#line 1754
    if (tmp___1) {
      {
#line 1791
      l2tp_log(7, "%s: bad control packet!\n", "handle_packet");
      }
#line 1792
      return (-22);
    } else {
#line 1756
      c->msgtype = -1;
#line 1757
      if ((unsigned long )buf->len == sizeof(struct control_hdr )) {
#line 1762
        t->control_rec_seq_num = (_u16 )((int )t->control_rec_seq_num - 1);
#line 1763
        c->cnu = 0;
#line 1764
        if (c->needclose) {
#line 1764
          if (c->closing) {
#line 1766
            if ((c->container)->cLr >= (int )c->closeSs) {
#line 1772
              c->needclose = 0;
            }
          }
        }
#line 1776
        return (0);
      } else {
        {
#line 1778
        tmp___0 = handle_avps(buf, t, c);
        }
#line 1778
        if (tmp___0) {
#line 1784
          if (gconfig.debug_tunnel) {
            {
#line 1785
            l2tp_log(7, "%s: bad AVP handling!\n", "handle_packet");
            }
          }
#line 1786
          return (-22);
        } else {
          {
#line 1780
          tmp = control_finish(t, c);
          }
#line 1780
          return (tmp);
        }
      }
    }
  } else {
    {
#line 1797
    tmp___3 = check_payload(buf, t, c);
    }
#line 1797
    if (tmp___3) {
      {
#line 1897
      l2tp_log(7, "%s: invalid payload packet!\n", "handle_packet");
      }
#line 1898
      return (-22);
    } else {
      {
#line 1799
      tmp___2 = expand_payload(buf, t, c);
      }
#line 1799
      if (tmp___2) {
#line 1889
        if (gconfig.debug_tunnel) {
          {
#line 1890
          l2tp_log(7, "%s: unable to expand payload!\n", "handle_packet");
          }
        }
#line 1892
        return (-22);
      } else
#line 1801
      if ((unsigned long )buf->len > sizeof(struct payload_hdr )) {
        {
#line 1818
        res = write_packet(buf, t, c, 1);
        }
#line 1819
        if (res) {
#line 1820
          return (res);
        }
#line 1855
        return (0);
      } else
#line 1857
      if ((unsigned long )buf->len == sizeof(struct payload_hdr )) {
#line 1878
        c->data_rec_seq_num = (_u16 )((int )c->data_rec_seq_num - 1);
#line 1879
        return (0);
      } else {
        {
#line 1883
        l2tp_log(7, "%s: payload too small!\n", "handle_packet");
        }
#line 1884
        return (-22);
      }
    }
  }
}
}
