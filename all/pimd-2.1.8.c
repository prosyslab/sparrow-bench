/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_62 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_63 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_62 ifr_ifrn ;
   union __anonunion_ifr_ifru_63 ifr_ifru ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 39 "/usr/include/linux/mroute.h"
typedef unsigned short vifi_t;
#line 98 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
typedef u_int u_int32;
#line 99 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
typedef u_short u_int16;
#line 100 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
typedef u_char u_int8;
#line 83 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct build_jp_message_ {
   struct build_jp_message_ *next ;
   u_int8 *jp_message ;
   u_int32 jp_message_size ;
   u_int16 holdtime ;
   u_int32 curr_group ;
   u_int8 curr_group_msklen ;
   u_int8 *join_list ;
   u_int32 join_list_size ;
   u_int16 join_addr_number ;
   u_int8 *prune_list ;
   u_int32 prune_list_size ;
   u_int16 prune_addr_number ;
   u_int8 *rp_list_join ;
   u_int32 rp_list_join_size ;
   u_int16 rp_list_join_number ;
   u_int8 *rp_list_prune ;
   u_int32 rp_list_prune_size ;
   u_int16 rp_list_prune_number ;
   u_int8 *num_groups_ptr ;
};
#line 83 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct build_jp_message_ build_jp_message_t;
#line 106 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct pim_nbr_entry {
   struct pim_nbr_entry *next ;
   struct pim_nbr_entry *prev ;
   u_int32 address ;
   vifi_t vifi ;
   u_int16 timer ;
   build_jp_message_t *build_jp_message ;
};
#line 106 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct pim_nbr_entry pim_nbr_entry_t;
#line 85 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct __anonstruct_nbrbitmap_t_72 {
   u_long hi ;
   u_long lo ;
};
#line 85 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
typedef struct __anonstruct_nbrbitmap_t_72 nbrbitmap_t;
#line 130
struct listaddr;
#line 130
struct vif_acl;
#line 130
struct phaddr;
#line 130
struct vif_filter;
#line 130 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct uvif {
   u_int uv_flags ;
   u_char uv_metric ;
   u_char uv_admetric ;
   u_char uv_threshold ;
   u_int uv_rate_limit ;
   u_int32 uv_lcl_addr ;
   u_int32 uv_rmt_addr ;
   u_int32 uv_dst_addr ;
   u_int32 uv_subnet ;
   u_int32 uv_subnetmask ;
   u_int32 uv_subnetbcast ;
   char uv_name[16] ;
   struct listaddr *uv_groups ;
   struct listaddr *uv_dvmrp_neighbors ;
   nbrbitmap_t uv_nbrmap ;
   struct listaddr *uv_querier ;
   int uv_igmpv1_warn ;
   int uv_prune_lifetime ;
   struct vif_acl *uv_acl ;
   int uv_leaf_timer ;
   struct phaddr *uv_addrs ;
   struct vif_filter *uv_filter ;
   u_int16 uv_pim_hello_timer ;
   u_int16 uv_gq_timer ;
   u_int16 uv_jp_timer ;
   int uv_local_pref ;
   int uv_local_metric ;
   struct pim_nbr_entry *uv_pim_neighbors ;
   int uv_ifindex ;
};
#line 183 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct phaddr {
   struct phaddr *pa_next ;
   u_int32 pa_subnet ;
   u_int32 pa_subnetmask ;
   u_int32 pa_subnetbcast ;
};
#line 191 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct vif_acl {
   struct vif_acl *acl_next ;
   u_int32 acl_addr ;
   u_int32 acl_mask ;
};
#line 197
struct vf_element;
#line 197 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct vif_filter {
   int vf_type ;
   int vf_flags ;
   struct vf_element *vf_filter ;
};
#line 206 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct vf_element {
   struct vf_element *vfe_next ;
   u_int32 vfe_addr ;
   u_int32 vfe_mask ;
   int vfe_flags ;
};
#line 214 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
union __anonunion_al_alu_73 {
   u_int32 alu_genid ;
   u_int32 alu_reporter ;
};
#line 214 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct listaddr {
   struct listaddr *al_next ;
   u_int32 al_addr ;
   u_long al_timer ;
   time_t al_ctime ;
   union __anonunion_al_alu_73 al_alu ;
   u_char al_pv ;
   u_char al_mv ;
   u_char al_old ;
   u_char al_index ;
   u_long al_timerid ;
   u_long al_query ;
   u_int16 al_flags ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
#line 38 "/usr/include/linux/mroute.h"
typedef unsigned long vifbitmap_t;
#line 58 "/usr/include/linux/mroute.h"
union __anonunion____missing_field_name_71 {
   struct in_addr vifc_lcl_addr ;
   int vifc_lcl_ifindex ;
};
#line 58 "/usr/include/linux/mroute.h"
struct vifctl {
   vifi_t vifc_vifi ;
   unsigned char vifc_flags ;
   unsigned char vifc_threshold ;
   unsigned int vifc_rate_limit ;
   union __anonunion____missing_field_name_71 __annonCompField2 ;
   struct in_addr vifc_rmt_addr ;
};
#line 80 "/usr/include/linux/mroute.h"
struct mfcctl {
   struct in_addr mfcc_origin ;
   struct in_addr mfcc_mcastgrp ;
   vifi_t mfcc_parent ;
   unsigned char mfcc_ttls[32] ;
   unsigned int mfcc_pkt_cnt ;
   unsigned int mfcc_byte_cnt ;
   unsigned int mfcc_wrong_if ;
   int mfcc_expire ;
};
#line 95 "/usr/include/linux/mroute.h"
struct sioc_sg_req {
   struct in_addr src ;
   struct in_addr grp ;
   unsigned long pktcnt ;
   unsigned long bytecnt ;
   unsigned long wrong_if ;
};
#line 107 "/usr/include/linux/mroute.h"
struct sioc_vif_req {
   vifi_t vifi ;
   unsigned long icount ;
   unsigned long ocount ;
   unsigned long ibytes ;
   unsigned long obytes ;
};
#line 222 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct sg_count {
   u_long pktcnt ;
   u_long bytecnt ;
   u_long wrong_if ;
};
#line 228 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct vif_count {
   u_long icount ;
   u_long ocount ;
   u_long ibytes ;
   u_long obytes ;
};
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 120 "/usr/include/linux/mroute.h"
struct igmpmsg {
   __u32 unused1 ;
   __u32 unused2 ;
   unsigned char im_msgtype ;
   unsigned char im_mbz ;
   unsigned char im_vif ;
   unsigned char unused3 ;
   struct in_addr im_src ;
   struct in_addr im_dst ;
};
#line 119 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct mrtentry;
#line 119
struct cand_rp;
#line 119 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct srcentry {
   struct srcentry *next ;
   struct srcentry *prev ;
   u_int32 address ;
   struct mrtentry *mrtlink ;
   vifi_t incoming ;
   struct pim_nbr_entry *upstream ;
   u_int32 metric ;
   u_int32 preference ;
   u_int16 timer ;
   struct cand_rp *cand_rp ;
};
#line 119 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct srcentry srcentry_t;
#line 131 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef srcentry_t rpentry_t;
#line 135
struct rp_grp_entry;
#line 135 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct cand_rp {
   struct cand_rp *next ;
   struct cand_rp *prev ;
   struct rp_grp_entry *rp_grp_next ;
   rpentry_t *rpentry ;
};
#line 135 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct cand_rp cand_rp_t;
#line 142 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct grp_mask {
   struct grp_mask *next ;
   struct grp_mask *prev ;
   struct rp_grp_entry *grp_rp_next ;
   u_int32 group_addr ;
   u_int32 group_mask ;
   u_int32 hash_mask ;
   u_int16 fragment_tag ;
   u_int8 group_rp_number ;
};
#line 142 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct grp_mask grp_mask_t;
#line 153
struct grpentry;
#line 153 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct rp_grp_entry {
   struct rp_grp_entry *rp_grp_next ;
   struct rp_grp_entry *rp_grp_prev ;
   struct rp_grp_entry *grp_rp_next ;
   struct rp_grp_entry *grp_rp_prev ;
   struct grpentry *grplink ;
   u_int16 holdtime ;
   u_int16 fragment_tag ;
   u_int8 priority ;
   grp_mask_t *group ;
   cand_rp_t *rp ;
};
#line 153 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct rp_grp_entry rp_grp_entry_t;
#line 168 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct grpentry {
   struct grpentry *next ;
   struct grpentry *prev ;
   struct grpentry *rpnext ;
   struct grpentry *rpprev ;
   u_int32 group ;
   u_int32 rpaddr ;
   struct mrtentry *mrtlink ;
   rp_grp_entry_t *active_rp_grp ;
   struct mrtentry *grp_route ;
};
#line 168 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct grpentry grpentry_t;
#line 180
struct kernel_cache;
#line 180 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct mrtentry {
   struct mrtentry *grpnext ;
   struct mrtentry *grpprev ;
   struct mrtentry *srcnext ;
   struct mrtentry *srcprev ;
   struct grpentry *group ;
   struct srcentry *source ;
   vifi_t incoming ;
   vifbitmap_t oifs ;
   vifbitmap_t joined_oifs ;
   vifbitmap_t pruned_oifs ;
   vifbitmap_t asserted_oifs ;
   vifbitmap_t leaves ;
   struct pim_nbr_entry *upstream ;
   u_int32 metric ;
   u_int32 preference ;
   u_int32 pmbr_addr ;
   u_int16 *vif_timers ;
   u_int16 *vif_deletion_delay ;
   u_int16 flags ;
   u_int16 timer ;
   u_int16 jp_timer ;
   u_int16 rs_timer ;
   u_int assert_timer ;
   u_int assert_rate_timer ;
   struct kernel_cache *kernel_cache ;
};
#line 180 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct mrtentry mrtentry_t;
#line 251 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
struct kernel_cache {
   struct kernel_cache *next ;
   struct kernel_cache *prev ;
   u_int32 source ;
   u_int32 group ;
   struct sg_count sg_count ;
};
#line 251 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.h"
typedef struct kernel_cache kernel_cache_t;
#line 255 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.h"
struct rpfctl {
   struct in_addr source ;
   struct in_addr rpfneighbor ;
   vifi_t iif ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 107 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 56 "include/netinet/pim.h"
struct pim {
   u_int pim_type : 4 ;
   u_int pim_vers : 4 ;
   uint8_t pim_reserved ;
   uint16_t pim_cksum ;
};
#line 200 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim pim_header_t;
#line 286 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
struct cand_rp_adv_message_ {
   u_int8 *buffer ;
   u_int8 *insert_data_ptr ;
   u_int8 *prefix_cnt_ptr ;
   u_int16 message_size ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_14 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_14 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 209 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
struct pim_register_ {
   u_int32 reg_flags ;
};
#line 209 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim_register_ pim_register_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 66 "/usr/include/netinet/igmp.h"
struct igmp {
   u_int8_t igmp_type ;
   u_int8_t igmp_code ;
   u_int16_t igmp_cksum ;
   struct in_addr igmp_group ;
};
#line 45 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
struct __anonstruct_cbk_t_74 {
   vifi_t vifi ;
   struct listaddr *g ;
   int q_time ;
};
#line 45 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
typedef struct __anonstruct_cbk_t_74 cbk_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 47 "/home/wheatley/newnew/temp/pimd-2.1.8/trace.h"
struct __anonstruct_q_74 {
   u_int qid : 24 ;
   u_int ttl : 8 ;
};
#line 47 "/home/wheatley/newnew/temp/pimd-2.1.8/trace.h"
struct tr_query {
   u_int32 tr_src ;
   u_int32 tr_dst ;
   u_int32 tr_raddr ;
   struct __anonstruct_q_74 q ;
};
#line 71 "/home/wheatley/newnew/temp/pimd-2.1.8/trace.h"
struct tr_resp {
   u_int32 tr_qarr ;
   u_int32 tr_inaddr ;
   u_int32 tr_outaddr ;
   u_int32 tr_rmtaddr ;
   u_int32 tr_vifin ;
   u_int32 tr_vifout ;
   u_int32 tr_pktcnt ;
   u_char tr_rproto ;
   u_char tr_fttl ;
   u_char tr_smask ;
   u_char tr_rflags ;
};
#line 163 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
struct pim_encod_uni_addr_ {
   u_int8 addr_family ;
   u_int8 encod_type ;
   u_int32 unicast_addr ;
};
#line 163 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim_encod_uni_addr_ pim_encod_uni_addr_t;
#line 175 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
struct pim_encod_grp_addr_ {
   u_int8 addr_family ;
   u_int8 encod_type ;
   u_int8 reserved ;
   u_int8 masklen ;
   u_int32 mcast_addr ;
};
#line 175 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim_encod_grp_addr_ pim_encod_grp_addr_t;
#line 184 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
struct pim_encod_src_addr_ {
   u_int8 addr_family ;
   u_int8 encod_type ;
   u_int8 flags ;
   u_int8 masklen ;
   u_int32 src_addr ;
};
#line 184 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim_encod_src_addr_ pim_encod_src_addr_t;
#line 203 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
struct pim_hello_ {
   u_int16 option_type ;
   u_int16 option_length ;
};
#line 203 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim_hello_ pim_hello_t;
#line 214 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
struct pim_register_stop_ {
   pim_encod_grp_addr_t encod_grp ;
   pim_encod_uni_addr_t encod_src ;
};
#line 214 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim_register_stop_ pim_register_stop_t;
#line 227 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
struct pim_jp_encod_grp_ {
   pim_encod_grp_addr_t encod_grp ;
   u_int16 number_join_src ;
   u_int16 number_prune_src ;
};
#line 227 "/home/wheatley/newnew/temp/pimd-2.1.8/pimd.h"
typedef struct pim_jp_encod_grp_ pim_jp_encod_grp_t;
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_64 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_64 ifc_ifcu ;
};
#line 626 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
struct rp_hold {
   struct rp_hold *next ;
   u_int32 address ;
   u_int32 group ;
   u_int32 mask ;
   u_int8 priority ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_33 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_36 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_37 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_38 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_31 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_32 _kill ;
   struct __anonstruct__timer_33 _timer ;
   struct __anonstruct__rt_34 _rt ;
   struct __anonstruct__sigchld_35 _sigchld ;
   struct __anonstruct__sigfault_36 _sigfault ;
   struct __anonstruct__sigpoll_37 _sigpoll ;
   struct __anonstruct__sigsys_38 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_30 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_31 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_30 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_50 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_50 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 76 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
struct ihandler {
   int fd ;
   void (*func)(int  , fd_set * ) ;
};
#line 82 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
struct debugname {
   char *name ;
   uint32_t level ;
   size_t nchars ;
};
#line 17 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
struct timeout_q;
#line 19 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
struct timeout_q {
   struct timeout_q *next ;
   int id ;
   void (*func)(void * ) ;
   void *data ;
   int time ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 149 "/usr/include/linux/rtnetlink.h"
struct rtattr {
   unsigned short rta_len ;
   unsigned short rta_type ;
};
#line 175 "/usr/include/linux/rtnetlink.h"
struct rtmsg {
   unsigned char rtm_family ;
   unsigned char rtm_dst_len ;
   unsigned char rtm_src_len ;
   unsigned char rtm_tos ;
   unsigned char rtm_table ;
   unsigned char rtm_protocol ;
   unsigned char rtm_scope ;
   unsigned char rtm_type ;
   unsigned int rtm_flags ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 43 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.h"
unsigned long debug ;
#line 273 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int igmp_socket ;
#line 276
u_int32 allrouters_group ;
#line 277
u_int32 allpimrouters_group ;
#line 282
char *configfilename ;
#line 293
int disable_all_by_default ;
#line 329
u_int32 default_source_metric ;
#line 330
u_int32 default_source_preference ;
#line 336 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
struct uvif uvifs[32]  ;
#line 337 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
vifi_t numvifs  ;
#line 338 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int total_interfaces  ;
#line 339 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
vifi_t reg_vif_num  ;
#line 340 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int phys_vif  ;
#line 341 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int udp_socket  ;
#line 343 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int vifs_down  ;
#line 434
void config_vifs_from_kernel(void) ;
#line 435
void config_vifs_from_file(void) ;
#line 440
void logit(int severity , int syserr , char const   *format  , ...) ;
#line 465
void query_groups(struct uvif *v ) ;
#line 486
void k_join(int socket___0 , u_int32 grp , struct uvif *v ) ;
#line 487
void k_leave(int socket___0 , u_int32 grp , struct uvif *v ) ;
#line 488
void k_init_pim(int socket___0 ) ;
#line 493
void k_add_vif(int socket___0 , vifi_t vifi , struct uvif *v ) ;
#line 494
void k_del_vif(int socket___0 , vifi_t vifi , struct uvif *v  __attribute__((__unused__)) ) ;
#line 520
int send_pim_hello(struct uvif *v , u_int16 holdtime ) ;
#line 551
int delete_vif_from_mrt(vifi_t vifi  __attribute__((__unused__)) ) ;
#line 617
void init_vifs(void) ;
#line 618
void zero_vif(struct uvif *v , int t ) ;
#line 619
void stop_all_vifs(void) ;
#line 620
void check_vif_state(void) ;
#line 621
vifi_t local_address(u_int32 src ) ;
#line 622
vifi_t find_vif_direct(u_int32 src ) ;
#line 623
vifi_t find_vif_direct_local(u_int32 src ) ;
#line 624
u_int32 max_local_address(void) ;
#line 635
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 61 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
static void start_vif(vifi_t vifi ) ;
#line 62
static void stop_vif(vifi_t vifi ) ;
#line 63
static void start_all_vifs(void) ;
#line 64
static int init_reg_vif(void) ;
#line 65
static int update_reg_vif(vifi_t register_vifi ) ;
#line 68 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
void init_vifs(void) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  int enabled_vifs ;
  char const   *tmp ;

  {
#line 74
  numvifs = (vifi_t )0;
#line 75
  reg_vif_num = (vifi_t )32;
#line 76
  vifs_down = 0;
#line 82
  udp_socket = igmp_socket;
#line 89
  vifi = (vifi_t )0;
#line 89
  v = uvifs;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((int )vifi < 32)) {
#line 89
      goto while_break;
    }
    {
#line 90
    zero_vif(v, 0);
#line 89
    vifi = (vifi_t )((int )vifi + 1);
#line 89
    v ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  logit(6, 0, "Getting vifs from kernel");
#line 94
  config_vifs_from_kernel();
  }
#line 95
  if (disable_all_by_default) {
    {
#line 96
    logit(6, 0, "Disabling all vifs from kernel");
#line 98
    vifi = (vifi_t )0;
#line 98
    v = uvifs;
    }
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! ((int )vifi < (int )numvifs)) {
#line 98
        goto while_break___0;
      }
#line 99
      v->uv_flags |= 512U;
#line 98
      vifi = (vifi_t )((int )vifi + 1);
#line 98
      v ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 101
  logit(6, 0, "Getting vifs from %s", configfilename);
#line 102
  config_vifs_from_file();
#line 107
  enabled_vifs = 0;
#line 108
  phys_vif = -1;
#line 110
  vifi = (vifi_t )0;
#line 110
  v = uvifs;
  }
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 110
    if (! ((int )vifi < (int )numvifs)) {
#line 110
      goto while_break___1;
    }
#line 115
    v->uv_jp_timer = (u_int16 )(3.5 * (double )60);
#line 116
    if (v->uv_flags & 773U) {
#line 117
      goto __Cont;
    }
#line 119
    if (phys_vif == -1) {
#line 120
      phys_vif = (int )vifi;
    }
#line 122
    enabled_vifs ++;
    __Cont: /* CIL Label */ 
#line 110
    vifi = (vifi_t )((int )vifi + 1);
#line 110
    v ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 125
  if (enabled_vifs < 1) {
#line 126
    if (enabled_vifs == 0) {
#line 126
      tmp = "no enabled vifs";
    } else {
#line 126
      tmp = "only one enabled vif";
    }
    {
#line 126
    logit(3, 0, "Cannot forward: %s", tmp);
    }
  }
  {
#line 128
  k_init_pim(igmp_socket);
#line 134
  init_reg_vif();
#line 136
  start_all_vifs();
  }
#line 137
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
void zero_vif(struct uvif *v , int t ) 
{ 
  u_long tmp ;

  {
#line 145
  v->uv_flags = (u_int )0;
#line 146
  v->uv_metric = (u_char )1;
#line 147
  v->uv_admetric = (u_char )0;
#line 148
  v->uv_threshold = (u_char )1;
#line 149
  if (t) {
#line 149
    v->uv_rate_limit = (u_int )0;
  } else {
#line 149
    v->uv_rate_limit = (u_int )0;
  }
#line 150
  v->uv_lcl_addr = (u_int32 )0;
#line 151
  v->uv_rmt_addr = (u_int32 )0;
#line 152
  if (t) {
#line 152
    v->uv_dst_addr = (u_int32 )0;
  } else {
#line 152
    v->uv_dst_addr = allpimrouters_group;
  }
  {
#line 153
  v->uv_subnet = (u_int32 )0;
#line 154
  v->uv_subnetmask = (u_int32 )0;
#line 155
  v->uv_subnetbcast = (u_int32 )0;
#line 156
  strlcpy(v->uv_name, "", (size_t )16);
#line 157
  v->uv_groups = (struct listaddr *)((void *)0);
#line 158
  v->uv_dvmrp_neighbors = (struct listaddr *)((void *)0);
#line 159
  tmp = (u_long )0;
#line 159
  v->uv_nbrmap.hi = tmp;
#line 159
  v->uv_nbrmap.lo = tmp;
#line 160
  v->uv_querier = (struct listaddr *)((void *)0);
#line 161
  v->uv_igmpv1_warn = 0;
#line 162
  v->uv_prune_lifetime = 0;
#line 163
  v->uv_acl = (struct vif_acl *)((void *)0);
#line 164
  v->uv_leaf_timer = 0;
#line 165
  v->uv_addrs = (struct phaddr *)((void *)0);
#line 166
  v->uv_filter = (struct vif_filter *)((void *)0);
#line 167
  v->uv_pim_hello_timer = (u_int16 )0;
#line 168
  v->uv_gq_timer = (u_int16 )0;
#line 169
  v->uv_jp_timer = (u_int16 )0;
#line 170
  v->uv_pim_neighbors = (struct pim_nbr_entry *)((void *)0);
#line 171
  v->uv_local_pref = (int )default_source_preference;
#line 172
  v->uv_local_metric = (int )default_source_metric;
#line 174
  v->uv_ifindex = -1;
  }
#line 176
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
static int init_reg_vif(void) 
{ 
  struct uvif *v ;
  vifi_t i ;

  {
#line 187
  v = & uvifs[numvifs];
#line 188
  v->uv_flags = (u_int )0;
#line 190
  if ((int )numvifs + 1 == 32) {
    {
#line 192
    logit(3, 0, "Cannot install the Register vif: too many interfaces");
    }
#line 194
    return (0);
  }
  {
#line 201
  reg_vif_num = numvifs;
#line 204
  v->uv_flags = (u_int )4;
#line 208
  strlcpy(v->uv_name, "register_vif0", sizeof(v->uv_name));
#line 213
  i = (vifi_t )0;
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! ((int )i < (int )numvifs)) {
#line 213
      goto while_break;
    }
#line 214
    if (uvifs[i].uv_flags & 773U) {
#line 215
      goto __Cont;
    }
#line 217
    goto while_break;
    __Cont: /* CIL Label */ 
#line 213
    i = (vifi_t )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if ((int )i >= (int )numvifs) {
    {
#line 221
    logit(3, 0, "No physical interface enabled");
    }
#line 222
    return (-1);
  }
#line 225
  v->uv_lcl_addr = uvifs[i].uv_lcl_addr;
#line 226
  v->uv_threshold = (u_char )1;
#line 228
  numvifs = (vifi_t )((int )numvifs + 1);
#line 229
  total_interfaces ++;
#line 231
  return (0);
}
}
#line 235 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
static void start_all_vifs(void) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  u_int action ;

  {
#line 242
  action = (u_int )0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    vifi = (vifi_t )0;
#line 243
    v = uvifs;
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 243
      if (! ((int )vifi < (int )numvifs)) {
#line 243
        goto while_break___0;
      }
#line 246
      if ((v->uv_flags & 4U) ^ action) {
#line 247
        goto __Cont;
      }
#line 250
      if (v->uv_flags & 768U) {
#line 251
        if (v->uv_flags & 512U) {
          {
#line 252
          logit(6, 0, "Interface %s is DISABLED; vif #%u out of service", v->uv_name,
                (int )vifi);
          }
        } else {
          {
#line 254
          logit(6, 0, "Interface %s is DOWN; vif #%u out of service", v->uv_name,
                (int )vifi);
          }
        }
      } else {
        {
#line 256
        start_vif(vifi);
        }
      }
      __Cont: /* CIL Label */ 
#line 243
      vifi = (vifi_t )((int )vifi + 1);
#line 243
      v ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    if (action == 4U) {
#line 261
      goto while_break;
    }
#line 242
    action = (u_int )4;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
void stop_all_vifs(void) 
{ 
  vifi_t vifi ;
  struct uvif *v ;

  {
#line 274
  vifi = (vifi_t )0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! ((int )vifi < (int )numvifs)) {
#line 274
      goto while_break;
    }
#line 275
    v = & uvifs[vifi];
#line 276
    if (! (v->uv_flags & 256U)) {
      {
#line 277
      stop_vif(vifi);
      }
    }
#line 274
    vifi = (vifi_t )((int )vifi + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 287 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
static void start_vif(vifi_t vifi ) 
{ 
  struct uvif *v ;
  long tmp ;
  long tmp___0 ;
  struct ifreq ifr ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 291
  v = & uvifs[vifi];
#line 293
  if (v->uv_flags & 4U) {
#line 294
    v->uv_flags &= 4294967039U;
  } else {
    {
#line 296
    v->uv_flags = ((v->uv_flags | 262144U) | 524288U) & 4294967039U;
#line 297
    tmp = random();
#line 297
    v->uv_pim_hello_timer = (u_int16 )(1L + tmp % 30L);
#line 298
    tmp___0 = random();
#line 298
    v->uv_jp_timer = (u_int16 )(1L + tmp___0 % 60L);
#line 300
    v->uv_gq_timer = (u_int16 )0;
#line 301
    v->uv_pim_neighbors = (pim_nbr_entry_t *)((void *)0);
    }
  }
  {
#line 305
  k_add_vif(igmp_socket, vifi, & uvifs[vifi]);
#line 306
  logit(6, 0, "Interface %s comes up; vif #%u now in service", v->uv_name, (int )vifi);
  }
#line 308
  if (! (v->uv_flags & 4U)) {
    {
#line 312
    k_join(igmp_socket, allpimrouters_group, v);
#line 319
    k_join(igmp_socket, allrouters_group, v);
#line 326
    v->uv_flags |= 1024U;
#line 327
    query_groups(v);
#line 332
    send_pim_hello(v, (u_int16 )(3.5 * (double )30));
    }
  } else {
    {
#line 338
    memset((void *)(& ifr), 0, sizeof(struct ifreq ));
#line 340
    strlcpy(ifr.ifr_ifrn.ifrn_name, "pimreg", (size_t )16);
#line 341
    tmp___2 = ioctl(udp_socket, 35123UL, (char *)(& ifr));
    }
#line 341
    if (tmp___2 < 0) {
      {
#line 342
      tmp___1 = __errno_location();
#line 342
      logit(3, *tmp___1, "ioctl SIOGIFINDEX for %s", ifr.ifr_ifrn.ifrn_name);
      }
#line 344
      return;
    }
#line 346
    v->uv_ifindex = ifr.ifr_ifru.ifru_ivalue;
  }
#line 349
  return;
}
}
#line 356 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
static void stop_vif(vifi_t vifi ) 
{ 
  struct uvif *v ;
  struct listaddr *a ;
  pim_nbr_entry_t *n ;
  pim_nbr_entry_t *next ;
  struct vif_acl *acl ;

  {
#line 367
  v = & uvifs[vifi];
#line 368
  if (! (v->uv_flags & 4U)) {
    {
#line 369
    k_leave(igmp_socket, allpimrouters_group, v);
#line 370
    k_leave(igmp_socket, allrouters_group, v);
    }
    {
#line 375
    while (1) {
      while_continue: /* CIL Label */ ;
#line 375
      if (! ((unsigned long )v->uv_groups != (unsigned long )((void *)0))) {
#line 375
        goto while_break;
      }
      {
#line 376
      a = v->uv_groups;
#line 377
      v->uv_groups = a->al_next;
#line 378
      free((void *)((char *)a));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 387
  delete_vif_from_mrt(vifi);
#line 390
  k_del_vif(igmp_socket, vifi, v);
#line 392
  v->uv_flags = (((v->uv_flags & 4294705151U) & 4294966271U) & 4294443007U) | 256U;
  }
#line 393
  if (! (v->uv_flags & 4U)) {
#line 394
    v->uv_pim_hello_timer = (u_int16 )0;
#line 395
    v->uv_jp_timer = (u_int16 )0;
#line 396
    v->uv_gq_timer = (u_int16 )0;
#line 398
    n = v->uv_pim_neighbors;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )n != (unsigned long )((void *)0))) {
#line 398
        goto while_break___0;
      }
      {
#line 399
      next = n->next;
#line 400
      free((void *)((char *)n));
#line 398
      n = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 402
    v->uv_pim_neighbors = (struct pim_nbr_entry *)((void *)0);
  }
  {
#line 407
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 407
    if (! ((unsigned long )v->uv_acl != (unsigned long )((void *)0))) {
#line 407
      goto while_break___1;
    }
    {
#line 408
    acl = v->uv_acl;
#line 409
    v->uv_acl = acl->acl_next;
#line 410
    free((void *)((char *)acl));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 413
  vifs_down = 1;
#line 414
  logit(6, 0, "Interface %s goes down; vif #%u out of service", v->uv_name, (int )vifi);
  }
#line 415
  return;
}
}
#line 425 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
static int update_reg_vif(vifi_t register_vifi ) 
{ 
  struct uvif *v ;
  vifi_t vifi ;

  {
#line 431
  vifi = (vifi_t )0;
#line 431
  v = uvifs;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! ((int )vifi < (int )numvifs)) {
#line 431
      goto while_break;
    }
#line 432
    if (v->uv_flags & 773U) {
#line 433
      goto __Cont;
    }
    {
#line 436
    stop_vif(register_vifi);
#line 437
    uvifs[register_vifi].uv_lcl_addr = uvifs[vifi].uv_lcl_addr;
#line 439
    start_vif(register_vifi);
    }
#line 440
    if (debug) {
#line 440
      if (debug & 33792UL) {
        {
#line 441
        logit(5, 0, "Interface %s has come up; vif #%u now in service", uvifs[register_vifi].uv_name,
              (int )register_vifi);
        }
      }
    }
#line 445
    return (0);
    __Cont: /* CIL Label */ 
#line 431
    vifi = (vifi_t )((int )vifi + 1);
#line 431
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  vifs_down = 1;
#line 449
  logit(4, 0, "Cannot start Register vif: %s", uvifs[vifi].uv_name);
  }
#line 451
  return (-1);
}
}
#line 466 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
static int checking_vifs  =    0;
#line 461 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
void check_vif_state(void) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  struct ifreq ifr ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  vifi_t vifi2 ;
  struct uvif *v2 ;
  int found ;

  {
#line 474
  if (checking_vifs) {
#line 475
    return;
  }
#line 477
  vifs_down = 0;
#line 478
  checking_vifs = 1;
#line 482
  vifi = (vifi_t )0;
#line 482
  v = uvifs;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! ((int )vifi < (int )numvifs)) {
#line 482
      goto while_break;
    }
#line 483
    if (v->uv_flags & 516U) {
#line 484
      goto __Cont;
    }
    {
#line 487
    strlcpy(ifr.ifr_ifrn.ifrn_name, (char const   *)(v->uv_name), sizeof(ifr.ifr_ifrn.ifrn_name));
#line 488
    tmp___1 = ioctl(udp_socket, 35091UL, (char *)(& ifr));
    }
#line 488
    if (tmp___1 < 0) {
      {
#line 489
      tmp = __errno_location();
      }
#line 489
      if (*tmp == 19) {
        {
#line 490
        logit(5, 0, "Interface %s has gone; vif #%u taken out of service", v->uv_name,
              (int )vifi);
#line 491
        stop_vif(vifi);
#line 492
        vifs_down = 1;
        }
#line 493
        goto __Cont;
      }
      {
#line 496
      tmp___0 = __errno_location();
#line 496
      logit(3, *tmp___0, "check_vif_state: ioctl SIOCGIFFLAGS for %s", ifr.ifr_ifrn.ifrn_name);
      }
    }
#line 499
    if (v->uv_flags & 256U) {
#line 500
      if ((int )ifr.ifr_ifru.ifru_flags & 1) {
        {
#line 501
        start_vif(vifi);
        }
      } else {
#line 503
        vifs_down = 1;
      }
    } else
#line 505
    if (! ((int )ifr.ifr_ifru.ifru_flags & 1)) {
      {
#line 506
      logit(5, 0, "Interface %s has gone down; vif #%u taken out of service", v->uv_name,
            (int )vifi);
#line 507
      stop_vif(vifi);
#line 508
      vifs_down = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 482
    vifi = (vifi_t )((int )vifi + 1);
#line 482
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 514
  vifi = (vifi_t )0;
#line 514
  v = uvifs;
  {
#line 514
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 514
    if (! ((int )vifi < (int )numvifs)) {
#line 514
      goto while_break___0;
    }
#line 519
    if (! (v->uv_flags & 4U)) {
#line 520
      goto __Cont___0;
    }
#line 522
    found = 0;
#line 526
    vifi2 = (vifi_t )0;
#line 526
    v2 = uvifs;
    {
#line 526
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 526
      if (! ((int )vifi2 < (int )numvifs)) {
#line 526
        goto while_break___1;
      }
#line 527
      if (v2->uv_flags & 773U) {
#line 528
        goto __Cont___1;
      }
#line 530
      if (v->uv_lcl_addr != v2->uv_lcl_addr) {
#line 531
        goto __Cont___1;
      }
#line 533
      found = 1;
#line 534
      goto while_break___1;
      __Cont___1: /* CIL Label */ 
#line 526
      vifi2 = (vifi_t )((int )vifi2 + 1);
#line 526
      v2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 539
    if (! found) {
      {
#line 540
      update_reg_vif(vifi);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 514
    vifi = (vifi_t )((int )vifi + 1);
#line 514
    v ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 543
  checking_vifs = 0;
#line 544
  return;
}
}
#line 553 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
vifi_t find_vif_direct(u_int32 src ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  struct phaddr *p ;

  {
#line 559
  vifi = (vifi_t )0;
#line 559
  v = uvifs;
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! ((int )vifi < (int )numvifs)) {
#line 559
      goto while_break;
    }
#line 560
    if (v->uv_flags & 773U) {
#line 561
      goto __Cont;
    }
#line 563
    if (src == v->uv_lcl_addr) {
#line 564
      return ((vifi_t )32);
    }
#line 566
    if ((src & v->uv_subnetmask) == v->uv_subnet) {
#line 566
      if (v->uv_subnetmask == 4294967295U) {
#line 569
        return (vifi);
      } else
#line 566
      if (src != v->uv_subnetbcast) {
#line 569
        return (vifi);
      }
    }
#line 573
    p = v->uv_addrs;
    {
#line 573
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 573
      if (! p) {
#line 573
        goto while_break___0;
      }
#line 574
      if ((src & p->pa_subnetmask) == p->pa_subnet) {
#line 574
        if (p->pa_subnetmask == 4294967295U) {
#line 577
          return (vifi);
        } else
#line 574
        if (src != p->pa_subnetbcast) {
#line 577
          return (vifi);
        }
      }
#line 573
      p = p->pa_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 581
    if (v->uv_flags & 1048576U) {
#line 581
      if (src == v->uv_rmt_addr) {
#line 582
        return (vifi);
      }
    }
    __Cont: /* CIL Label */ 
#line 559
    vifi = (vifi_t )((int )vifi + 1);
#line 559
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 585
  return ((vifi_t )32);
}
}
#line 593 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
vifi_t local_address(u_int32 src ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;

  {
#line 598
  vifi = (vifi_t )0;
#line 598
  v = uvifs;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! ((int )vifi < (int )numvifs)) {
#line 598
      goto while_break;
    }
#line 600
    if (v->uv_flags & 772U) {
#line 601
      goto __Cont;
    }
#line 603
    if (! (src != v->uv_lcl_addr)) {
#line 606
      return (vifi);
    }
    __Cont: /* CIL Label */ 
#line 598
    vifi = (vifi_t )((int )vifi + 1);
#line 598
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  return ((vifi_t )32);
}
}
#line 619 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
vifi_t find_vif_direct_local(u_int32 src ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  struct phaddr *p ;

  {
#line 625
  vifi = (vifi_t )0;
#line 625
  v = uvifs;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (! ((int )vifi < (int )numvifs)) {
#line 625
      goto while_break;
    }
#line 627
    if (v->uv_flags & 773U) {
#line 628
      goto __Cont;
    }
#line 630
    if (src == v->uv_lcl_addr) {
#line 631
      return (vifi);
    }
#line 633
    if ((src & v->uv_subnetmask) == v->uv_subnet) {
#line 633
      if (v->uv_subnetmask == 4294967295U) {
#line 636
        return (vifi);
      } else
#line 633
      if (src != v->uv_subnetbcast) {
#line 636
        return (vifi);
      }
    }
#line 640
    p = v->uv_addrs;
    {
#line 640
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 640
      if (! p) {
#line 640
        goto while_break___0;
      }
#line 641
      if ((src & p->pa_subnetmask) == p->pa_subnet) {
#line 641
        if (p->pa_subnetmask == 4294967295U) {
#line 644
          return (vifi);
        } else
#line 641
        if (src != p->pa_subnetbcast) {
#line 644
          return (vifi);
        }
      }
#line 640
      p = p->pa_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 648
    if (v->uv_flags & 1048576U) {
#line 648
      if (src == v->uv_rmt_addr) {
#line 649
        return (vifi);
      }
    }
    __Cont: /* CIL Label */ 
#line 625
    vifi = (vifi_t )((int )vifi + 1);
#line 625
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  return ((vifi_t )32);
}
}
#line 658 "/home/wheatley/newnew/temp/pimd-2.1.8/vif.c"
u_int32 max_local_address(void) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  u_int32 max_address ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 662
  max_address = (u_int32 )0;
#line 664
  vifi = (vifi_t )0;
#line 664
  v = uvifs;
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! ((int )vifi < (int )numvifs)) {
#line 664
      goto while_break;
    }
#line 667
    if (v->uv_flags & 772U) {
#line 668
      goto __Cont;
    }
    {
#line 670
    tmp = ntohl(v->uv_lcl_addr);
#line 670
    tmp___0 = ntohl(max_address);
    }
#line 670
    if (tmp > tmp___0) {
#line 671
      max_address = v->uv_lcl_addr;
    }
    __Cont: /* CIL Label */ 
#line 664
    vifi = (vifi_t )((int )vifi + 1);
#line 664
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  return (max_address);
}
}
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 346 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char s1[19] ;
#line 347
char s2[19] ;
#line 475
char *inet_fmt(u_int32 addr , char *s , size_t len ) ;
#line 480
void k_set_sndbuf(int socket___0 , int bufsize , int minsize ) ;
#line 481
void k_set_rcvbuf(int socket___0 , int bufsize , int minsize ) ;
#line 482
void k_hdr_include(int socket___0 , int bool ) ;
#line 483
void k_set_ttl(int socket___0  __attribute__((__unused__)) , int t ) ;
#line 484
void k_set_loop(int socket___0 , int flag ) ;
#line 485
void k_set_if(int socket___0 , u_int32 ifa ) ;
#line 489
void k_stop_pim(int socket___0 ) ;
#line 490
int k_del_mfc(int socket___0 , u_int32 source , u_int32 group ) ;
#line 491
int k_chg_mfc(int socket___0 , u_int32 source , u_int32 group , vifi_t iif , vifbitmap_t oifs ,
              u_int32 rp_addr  __attribute__((__unused__)) ) ;
#line 495
int k_get_vif_count(vifi_t vifi , struct vif_count *retval ) ;
#line 496
int k_get_sg_cnt(int socket___0 , u_int32 source , u_int32 group , struct sg_count *retval ) ;
#line 43 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
int curttl  =    0;
#line 58 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_init_pim(int socket___0 ) 
{ 
  int v ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 60
  v = 1;
#line 62
  tmp___1 = setsockopt(socket___0, 0, 200, (void const   *)((char *)(& v)), (socklen_t )sizeof(int ));
  }
#line 62
  if (tmp___1 < 0) {
    {
#line 63
    tmp___0 = __errno_location();
    }
#line 63
    if (*tmp___0 == 98) {
      {
#line 64
      logit(3, 0, "Another multicast routing application is already running.");
      }
    } else {
      {
#line 66
      tmp = __errno_location();
#line 66
      logit(3, *tmp, "Cannot enable multicast routing in kernel");
      }
    }
  }
  {
#line 69
  tmp___3 = setsockopt(socket___0, 0, 208, (void const   *)((char *)(& v)), (socklen_t )sizeof(int ));
  }
#line 69
  if (tmp___3 < 0) {
    {
#line 70
    tmp___2 = __errno_location();
#line 70
    logit(3, *tmp___2, "Cannot set PIM flag in kernel");
    }
  }
#line 71
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_stop_pim(int socket___0 ) 
{ 
  int v ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 80
  v = 0;
#line 82
  tmp___0 = setsockopt(socket___0, 0, 208, (void const   *)((char *)(& v)), (socklen_t )sizeof(int ));
  }
#line 82
  if (tmp___0 < 0) {
    {
#line 83
    tmp = __errno_location();
#line 83
    logit(3, *tmp, "Cannot reset PIM flag in kernel");
    }
  }
  {
#line 85
  tmp___2 = setsockopt(socket___0, 0, 201, (void const   *)((char *)((void *)0)),
                       (socklen_t )0);
  }
#line 85
  if (tmp___2 < 0) {
    {
#line 86
    tmp___1 = __errno_location();
#line 86
    logit(3, *tmp___1, "Cannot disable multicast routing in kernel");
    }
  }
#line 87
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_set_sndbuf(int socket___0 , int bufsize , int minsize ) 
{ 
  int delta ;
  int iter ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 96
  delta = bufsize / 2;
#line 97
  iter = 0;
#line 105
  tmp___0 = setsockopt(socket___0, 1, 7, (void const   *)((char *)(& bufsize)), (socklen_t )sizeof(bufsize));
  }
#line 105
  if (tmp___0 < 0) {
#line 106
    bufsize -= delta;
    {
#line 107
    while (1) {
      while_continue: /* CIL Label */ ;
#line 108
      iter ++;
#line 109
      if (delta > 1) {
#line 110
        delta /= 2;
      }
      {
#line 112
      tmp = setsockopt(socket___0, 1, 7, (void const   *)((char *)(& bufsize)), (socklen_t )sizeof(bufsize));
      }
#line 112
      if (tmp < 0) {
#line 113
        bufsize -= delta;
      } else {
#line 115
        if (delta < 1024) {
#line 116
          goto while_break;
        }
#line 117
        bufsize += delta;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 120
    if (bufsize < minsize) {
      {
#line 121
      logit(3, 0, "OS-allowed send buffer size %u < app min %u", bufsize, minsize);
      }
    }
  }
#line 126
  if (debug) {
#line 126
    if (debug & 2048UL) {
      {
#line 127
      logit(7, 0, "Got %d byte send buffer size in %d iterations", bufsize, iter);
      }
    }
  }
#line 130
  return;
}
}
#line 137 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_set_rcvbuf(int socket___0 , int bufsize , int minsize ) 
{ 
  int delta ;
  int iter ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 139
  delta = bufsize / 2;
#line 140
  iter = 0;
#line 148
  tmp___0 = setsockopt(socket___0, 1, 8, (void const   *)((char *)(& bufsize)), (socklen_t )sizeof(bufsize));
  }
#line 148
  if (tmp___0 < 0) {
#line 149
    bufsize -= delta;
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      iter ++;
#line 152
      if (delta > 1) {
#line 153
        delta /= 2;
      }
      {
#line 155
      tmp = setsockopt(socket___0, 1, 8, (void const   *)((char *)(& bufsize)), (socklen_t )sizeof(bufsize));
      }
#line 155
      if (tmp < 0) {
#line 156
        bufsize -= delta;
      } else {
#line 158
        if (delta < 1024) {
#line 159
          goto while_break;
        }
#line 160
        bufsize += delta;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 163
    if (bufsize < minsize) {
      {
#line 164
      logit(3, 0, "OS-allowed recv buffer size %u < app min %u", bufsize, minsize);
      }
    }
  }
#line 168
  if (debug) {
#line 168
    if (debug & 2048UL) {
      {
#line 169
      logit(7, 0, "Got %d byte recv buffer size in %d iterations", bufsize, iter);
      }
    }
  }
#line 172
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_hdr_include(int socket___0 , int bool ) 
{ 
  char const   *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 186
  tmp___1 = setsockopt(socket___0, 0, 3, (void const   *)((char *)(& bool)), (socklen_t )sizeof(bool));
  }
#line 186
  if (tmp___1 < 0) {
#line 187
    if (bool) {
#line 187
      tmp = "enabling";
    } else {
#line 187
      tmp = "disabling";
    }
    {
#line 187
    tmp___0 = __errno_location();
#line 187
    logit(3, *tmp___0, "Failed %s IP_HDRINCL on socket %d", tmp, socket___0);
    }
  }
#line 190
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_set_ttl(int socket___0  __attribute__((__unused__)) , int t ) 
{ 


  {
#line 201
  curttl = t;
#line 209
  return;
}
}
#line 215 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_set_loop(int socket___0 , int flag ) 
{ 
  u_char loop ;
  char const   *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 219
  loop = (u_char )flag;
#line 220
  tmp___1 = setsockopt(socket___0, 0, 34, (void const   *)((char *)(& loop)), (socklen_t )sizeof(loop));
  }
#line 220
  if (tmp___1 < 0) {
#line 221
    if (flag) {
#line 221
      tmp = "enabling";
    } else {
#line 221
      tmp = "disabling";
    }
    {
#line 221
    tmp___0 = __errno_location();
#line 221
    logit(3, *tmp___0, "Failed %s IP_MULTICAST_LOOP on socket %d", tmp, socket___0);
    }
  }
#line 223
  return;
}
}
#line 229 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_set_if(int socket___0 , u_int32 ifa ) 
{ 
  struct in_addr adr ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 233
  adr.s_addr = ifa;
#line 234
  tmp___3 = setsockopt(socket___0, 0, 32, (void const   *)((char *)(& adr)), (socklen_t )sizeof(adr));
  }
#line 234
  if (tmp___3 < 0) {
    {
#line 235
    tmp = __errno_location();
    }
#line 235
    if (*tmp == 99) {
#line 236
      return;
    } else {
      {
#line 235
      tmp___0 = __errno_location();
      }
#line 235
      if (*tmp___0 == 22) {
#line 236
        return;
      }
    }
    {
#line 237
    tmp___1 = inet_fmt(adr.s_addr, s1, sizeof(s1));
#line 237
    tmp___2 = __errno_location();
#line 237
    logit(3, *tmp___2, "Failed setting IP_MULTICAST_IF option on %s", tmp___1);
    }
  }
#line 240
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_join(int socket___0 , u_int32 grp , struct uvif *v ) 
{ 
  struct ip_mreqn mreq ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 255
  mreq.imr_ifindex = v->uv_ifindex;
#line 256
  mreq.imr_address.s_addr = v->uv_lcl_addr;
#line 260
  mreq.imr_multiaddr.s_addr = grp;
#line 262
  tmp___2 = setsockopt(socket___0, 0, 35, (void const   *)((char *)(& mreq)), (socklen_t )sizeof(mreq));
  }
#line 262
  if (tmp___2 < 0) {
    {
#line 265
    tmp = inet_fmt(v->uv_lcl_addr, s2, sizeof(s2));
#line 265
    tmp___0 = inet_fmt(grp, s1, sizeof(s1));
#line 265
    tmp___1 = __errno_location();
#line 265
    logit(4, *tmp___1, "Cannot join group %s on interface %s (ifindex %d)", tmp___0,
          tmp, v->uv_ifindex);
    }
  }
#line 274
  return;
}
}
#line 280 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_leave(int socket___0 , u_int32 grp , struct uvif *v ) 
{ 
  struct ip_mreqn mreq ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 289
  mreq.imr_ifindex = v->uv_ifindex;
#line 290
  mreq.imr_address.s_addr = v->uv_lcl_addr;
#line 294
  mreq.imr_multiaddr.s_addr = grp;
#line 296
  tmp___2 = setsockopt(socket___0, 0, 36, (void const   *)((char *)(& mreq)), (socklen_t )sizeof(mreq));
  }
#line 296
  if (tmp___2 < 0) {
    {
#line 298
    tmp = inet_fmt(v->uv_lcl_addr, s2, sizeof(s2));
#line 298
    tmp___0 = inet_fmt(grp, s1, sizeof(s1));
#line 298
    tmp___1 = __errno_location();
#line 298
    logit(4, *tmp___1, "Cannot leave group %s on interface %s (ifindex %d)", tmp___0,
          tmp, v->uv_ifindex);
    }
  }
#line 307
  return;
}
}
#line 312 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
static void uvif_to_vifctl(struct vifctl *vc , struct uvif *v ) 
{ 


  {
#line 315
  vc->vifc_flags = (unsigned char)0;
#line 316
  if (v->uv_flags & 4U) {
#line 317
    vc->vifc_flags = (unsigned char )((int )vc->vifc_flags | 4);
  }
#line 318
  vc->vifc_threshold = v->uv_threshold;
#line 319
  vc->vifc_rate_limit = v->uv_rate_limit;
#line 320
  vc->__annonCompField2.vifc_lcl_addr.s_addr = v->uv_lcl_addr;
#line 321
  vc->vifc_rmt_addr.s_addr = v->uv_rmt_addr;
#line 322
  return;
}
}
#line 327 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_add_vif(int socket___0 , vifi_t vifi , struct uvif *v ) 
{ 
  struct vifctl vc ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 331
  vc.vifc_vifi = vifi;
#line 332
  uvif_to_vifctl(& vc, v);
#line 333
  tmp___0 = setsockopt(socket___0, 0, 202, (void const   *)((char *)(& vc)), (socklen_t )sizeof(vc));
  }
#line 333
  if (tmp___0 < 0) {
    {
#line 334
    tmp = __errno_location();
#line 334
    logit(3, *tmp, "Failed adding VIF %d (MRT_ADD_VIF)", (int )vifi);
    }
  }
#line 335
  return;
}
}
#line 341 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
void k_del_vif(int socket___0 , vifi_t vifi , struct uvif *v  __attribute__((__unused__)) ) 
{ 
  struct vifctl vc ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 352
  vc.vifc_vifi = vifi;
#line 353
  uvif_to_vifctl(& vc, v);
#line 355
  tmp___2 = setsockopt(socket___0, 0, 203, (void const   *)((char *)(& vc)), (socklen_t )sizeof(vc));
  }
#line 355
  if (tmp___2 < 0) {
    {
#line 360
    tmp = __errno_location();
    }
#line 360
    if (*tmp == 99) {
#line 361
      return;
    } else {
      {
#line 360
      tmp___0 = __errno_location();
      }
#line 360
      if (*tmp___0 == 22) {
#line 361
        return;
      }
    }
    {
#line 363
    tmp___1 = __errno_location();
#line 363
    logit(3, *tmp___1, "Failed removing VIF %d (MRT_DEL_VIF)", (int )vifi);
    }
  }
#line 365
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
int k_del_mfc(int socket___0 , u_int32 source , u_int32 group ) 
{ 
  struct mfcctl mc ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 375
  mc.mfcc_origin.s_addr = source;
#line 376
  mc.mfcc_mcastgrp.s_addr = group;
#line 378
  tmp___2 = setsockopt(socket___0, 0, 205, (void const   *)((char *)(& mc)), (socklen_t )sizeof(mc));
  }
#line 378
  if (tmp___2 < 0) {
    {
#line 379
    tmp = inet_fmt(mc.mfcc_mcastgrp.s_addr, s2, sizeof(s2));
#line 379
    tmp___0 = inet_fmt(mc.mfcc_origin.s_addr, s1, sizeof(s1));
#line 379
    tmp___1 = __errno_location();
#line 379
    logit(4, *tmp___1, "Failed removing MFC entry src %s, grp %s", tmp___0, tmp);
    }
#line 383
    return (0);
  }
#line 386
  if (debug) {
#line 386
    if (debug & 4096UL) {
      {
#line 387
      tmp___3 = inet_fmt(mc.mfcc_mcastgrp.s_addr, s2, sizeof(s2));
#line 387
      tmp___4 = inet_fmt(mc.mfcc_origin.s_addr, s1, sizeof(s1));
#line 387
      logit(7, 0, "Removed MFC entry src %s, grp %s", tmp___4, tmp___3);
      }
    }
  }
#line 392
  return (1);
}
}
#line 399 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
int k_chg_mfc(int socket___0 , u_int32 source , u_int32 group , vifi_t iif , vifbitmap_t oifs ,
              u_int32 rp_addr  __attribute__((__unused__)) ) 
{ 
  struct mfcctl mc ;
  vifi_t vifi ;
  struct uvif *v ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 405
  mc.mfcc_origin.s_addr = source;
#line 409
  mc.mfcc_mcastgrp.s_addr = group;
#line 410
  mc.mfcc_parent = iif;
#line 415
  oifs &= (unsigned long )(~ (1 << (int )mc.mfcc_parent));
#line 417
  vifi = (vifi_t )0;
#line 417
  v = uvifs;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! ((int )vifi < (int )numvifs)) {
#line 417
      goto while_break;
    }
#line 418
    if (oifs & (unsigned long )(1 << (int )vifi)) {
#line 419
      mc.mfcc_ttls[vifi] = v->uv_threshold;
    } else {
#line 421
      mc.mfcc_ttls[vifi] = (unsigned char)0;
    }
#line 417
    vifi = (vifi_t )((int )vifi + 1);
#line 417
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  tmp___2 = setsockopt(socket___0, 0, 204, (void const   *)((char *)(& mc)), (socklen_t )sizeof(mc));
  }
#line 427
  if (tmp___2 < 0) {
    {
#line 428
    tmp = inet_fmt(mc.mfcc_mcastgrp.s_addr, s2, sizeof(s2));
#line 428
    tmp___0 = inet_fmt(mc.mfcc_origin.s_addr, s1, sizeof(s1));
#line 428
    tmp___1 = __errno_location();
#line 428
    logit(4, *tmp___1, "Failed adding MFC entry src %s grp %s", tmp___0, tmp);
    }
#line 432
    return (0);
  }
#line 435
  return (1);
}
}
#line 443 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
int k_get_vif_count(vifi_t vifi , struct vif_count *retval ) 
{ 
  struct sioc_vif_req vreq ;
  int *tmp ;
  u_long tmp___0 ;
  u_long tmp___1 ;
  u_long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 447
  vreq.vifi = vifi;
#line 448
  tmp___3 = ioctl(udp_socket, 35296UL, (char *)(& vreq));
  }
#line 448
  if (tmp___3 < 0) {
    {
#line 449
    tmp = __errno_location();
#line 449
    logit(4, *tmp, "Failed reading kernel packet count (SIOCGETVIFCNT) on vif %d",
          (int )vifi);
#line 451
    tmp___2 = (u_long )4294967295U;
#line 451
    retval->obytes = tmp___2;
#line 451
    tmp___1 = tmp___2;
#line 451
    retval->ibytes = tmp___1;
#line 451
    tmp___0 = tmp___1;
#line 451
    retval->ocount = tmp___0;
#line 451
    retval->icount = tmp___0;
    }
#line 456
    return (1);
  }
#line 459
  retval->icount = vreq.icount;
#line 460
  retval->ocount = vreq.ocount;
#line 461
  retval->ibytes = vreq.ibytes;
#line 462
  retval->obytes = vreq.obytes;
#line 464
  return (0);
}
}
#line 472 "/home/wheatley/newnew/temp/pimd-2.1.8/kern.c"
int k_get_sg_cnt(int socket___0 , u_int32 source , u_int32 group , struct sg_count *retval ) 
{ 
  struct sioc_sg_req sgreq ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  u_long tmp___2 ;
  u_long tmp___3 ;
  int tmp___4 ;

  {
  {
#line 476
  sgreq.src.s_addr = source;
#line 477
  sgreq.grp.s_addr = group;
#line 478
  tmp___4 = ioctl(socket___0, 35297UL, (char *)(& sgreq));
  }
#line 478
  if (tmp___4 < 0) {
#line 478
    goto _L;
  } else
#line 478
  if (sgreq.wrong_if == 4294967295UL) {
    _L: /* CIL Label */ 
    {
#line 483
    tmp = inet_fmt(group, s2, sizeof(s2));
#line 483
    tmp___0 = inet_fmt(source, s1, sizeof(s1));
#line 483
    tmp___1 = __errno_location();
#line 483
    logit(4, *tmp___1, "Failed reading kernel count (SIOCGETSGCNT) for (S,G) on (%s, %s)",
          tmp___0, tmp);
#line 485
    tmp___3 = (u_long )(~ 0);
#line 485
    retval->wrong_if = tmp___3;
#line 485
    tmp___2 = tmp___3;
#line 485
    retval->bytecnt = tmp___2;
#line 485
    retval->pktcnt = tmp___2;
    }
#line 487
    return (1);
  }
#line 489
  retval->pktcnt = sgreq.pktcnt;
#line 490
  retval->bytecnt = sgreq.bytecnt;
#line 491
  retval->wrong_if = sgreq.wrong_if;
#line 493
  return (0);
}
}
#line 269 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char *igmp_recv_buf ;
#line 319
u_int32 my_cand_rp_address ;
#line 503
mrtentry_t *find_route(u_int32 source , u_int32 group , u_int16 flags , char create ) ;
#line 509
void delete_mrtentry_all_kernel_cache(mrtentry_t *mrtentry_ptr ) ;
#line 512
void add_kernel_cache(mrtentry_t *mrtentry_ptr , u_int32 source , u_int32 group ,
                      u_int16 flags ) ;
#line 525
int send_pim_register(char *packet ) ;
#line 529
int send_pim_assert(u_int32 source , u_int32 group , vifi_t vifi , mrtentry_t *mrtentry_ptr ) ;
#line 540
int set_incoming(srcentry_t *srcentry_ptr , int srctype ) ;
#line 541
vifi_t get_iif(u_int32 address ) ;
#line 542
pim_nbr_entry_t *find_pim_nbr(u_int32 source ) ;
#line 544
void add_leaf(vifi_t vifi , u_int32 source  __attribute__((__unused__)) , u_int32 group ) ;
#line 545
void delete_leaf(vifi_t vifi , u_int32 source  __attribute__((__unused__)) , u_int32 group ) ;
#line 546
int change_interfaces(mrtentry_t *mrtentry_ptr , vifi_t new_iif , vifbitmap_t new_joined_oifs_ ,
                      vifbitmap_t new_pruned_oifs , vifbitmap_t new_leaves_ , vifbitmap_t new_asserted_oifs ,
                      u_int16 flags ) ;
#line 549
void calc_oifs(mrtentry_t *mrtentry_ptr , vifbitmap_t *oifs_ptr ) ;
#line 550
void process_kernel_call(void) ;
#line 552
mrtentry_t *switch_shortest_path(u_int32 source , u_int32 group ) ;
#line 555
int k_req_incoming(u_int32 source , struct rpfctl *rpf ) ;
#line 61 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
static void process_cache_miss(struct igmpmsg *igmpctl ) ;
#line 62
static void process_wrong_iif(struct igmpmsg *igmpctl ) ;
#line 63
static void process_whole_pkt(char *buf ) ;
#line 65 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
u_int32 default_source_metric  =    (u_int32 )1024;
#line 66 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
u_int32 default_source_preference  =    (u_int32 )1024;
#line 95 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
vifi_t get_iif(u_int32 address ) 
{ 
  struct rpfctl rpfc ;

  {
  {
#line 99
  k_req_incoming(address, & rpfc);
  }
#line 100
  if (rpfc.rpfneighbor.s_addr == 0U) {
#line 101
    return ((vifi_t )32);
  }
#line 102
  return (rpfc.iif);
}
}
#line 110 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
pim_nbr_entry_t *find_pim_nbr(u_int32 source ) 
{ 
  struct rpfctl rpfc ;
  pim_nbr_entry_t *pim_nbr ;
  u_int32 next_hop_router_addr ;
  vifi_t tmp ;

  {
  {
#line 116
  tmp = local_address(source);
  }
#line 116
  if ((int )tmp != 32) {
#line 117
    return ((pim_nbr_entry_t *)((void *)0));
  }
  {
#line 118
  k_req_incoming(source, & rpfc);
  }
#line 120
  if (rpfc.rpfneighbor.s_addr == 0U) {
#line 122
    return ((pim_nbr_entry_t *)((void *)0));
  } else
#line 120
  if ((int )rpfc.iif == 32) {
#line 122
    return ((pim_nbr_entry_t *)((void *)0));
  }
#line 124
  next_hop_router_addr = rpfc.rpfneighbor.s_addr;
#line 125
  pim_nbr = uvifs[rpfc.iif].uv_pim_neighbors;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )pim_nbr != (unsigned long )((void *)0))) {
#line 125
      goto while_break;
    }
#line 128
    if (pim_nbr->address == next_hop_router_addr) {
#line 129
      return (pim_nbr);
    }
#line 125
    pim_nbr = pim_nbr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return ((pim_nbr_entry_t *)((void *)0));
}
}
#line 155 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
int set_incoming(srcentry_t *srcentry_ptr , int srctype ) 
{ 
  struct rpfctl rpfc ;
  u_int32 source ;
  u_int32 neighbor_addr ;
  struct uvif *v ;
  pim_nbr_entry_t *n ;
  vifi_t tmp ;
  char *tmp___0 ;
  vifi_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 158
  source = srcentry_ptr->address;
#line 164
  srcentry_ptr->metric = (u_int32 )0;
#line 165
  srcentry_ptr->preference = (u_int32 )0;
#line 168
  tmp = local_address(source);
#line 168
  srcentry_ptr->incoming = tmp;
  }
#line 168
  if ((int )tmp != 32) {
#line 170
    if (srctype == 2) {
#line 171
      srcentry_ptr->incoming = reg_vif_num;
    }
#line 174
    srcentry_ptr->upstream = (struct pim_nbr_entry *)((void *)0);
#line 175
    return (1);
  }
  {
#line 178
  tmp___1 = find_vif_direct(source);
#line 178
  srcentry_ptr->incoming = tmp___1;
  }
#line 178
  if ((int )tmp___1 != 32) {
#line 182
    if (srctype == 1) {
#line 183
      srcentry_ptr->upstream = (struct pim_nbr_entry *)((void *)0);
#line 184
      return (1);
    } else {
#line 187
      neighbor_addr = source;
    }
  } else {
    {
#line 192
    k_req_incoming(source, & rpfc);
    }
#line 193
    if ((int )rpfc.iif == 32) {
#line 193
      goto _L;
    } else
#line 193
    if (rpfc.rpfneighbor.s_addr == 0U) {
      _L: /* CIL Label */ 
#line 196
      if (debug) {
#line 196
        if (debug & 5242880UL) {
          {
#line 197
          tmp___0 = inet_fmt(source, s1, sizeof(s1));
#line 197
          logit(7, 0, "NO ROUTE found for %s", tmp___0);
          }
        }
      }
#line 199
      return (0);
    }
#line 201
    srcentry_ptr->incoming = rpfc.iif;
#line 202
    neighbor_addr = rpfc.rpfneighbor.s_addr;
#line 204
    v = & uvifs[srcentry_ptr->incoming];
#line 205
    srcentry_ptr->preference = (u_int32 )v->uv_local_pref;
#line 206
    srcentry_ptr->metric = (u_int32 )v->uv_local_metric;
  }
#line 213
  v = & uvifs[srcentry_ptr->incoming];
#line 214
  n = v->uv_pim_neighbors;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned long )n != (unsigned long )((void *)0))) {
#line 214
      goto while_break;
    }
    {
#line 215
    tmp___2 = ntohl(neighbor_addr);
#line 215
    tmp___3 = ntohl(n->address);
    }
#line 215
    if (tmp___2 < tmp___3) {
#line 216
      goto __Cont;
    }
#line 218
    if (neighbor_addr == n->address) {
#line 223
      srcentry_ptr->upstream = n;
#line 224
      if (debug) {
#line 224
        if (debug & 4194304UL) {
          {
#line 225
          tmp___4 = inet_fmt(neighbor_addr, s2, sizeof(s2));
#line 225
          tmp___5 = inet_fmt(source, s1, sizeof(s1));
#line 225
          logit(7, 0, "For src %s, iif is %d, next hop router is %s", tmp___5, (int )srcentry_ptr->incoming,
                tmp___4);
          }
        }
      }
#line 230
      return (1);
    }
#line 233
    goto while_break;
    __Cont: /* CIL Label */ 
#line 214
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  tmp___6 = inet_fmt(neighbor_addr, s2, sizeof(s2));
#line 237
  tmp___7 = inet_fmt(source, s1, sizeof(s1));
#line 237
  logit(6, 0, "For src %s, iif is %d, next hop router is %s: NOT A PIM ROUTER", tmp___7,
        (int )srcentry_ptr->incoming, tmp___6);
#line 241
  srcentry_ptr->upstream = (struct pim_nbr_entry *)((void *)0);
  }
#line 243
  return (0);
}
}
#line 251 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
void add_leaf(vifi_t vifi , u_int32 source  __attribute__((__unused__)) , u_int32 group ) 
{ 
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_srcs ;
  vifbitmap_t old_oifs ;
  vifbitmap_t new_oifs ;
  vifbitmap_t new_leaves ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 259
  tmp = ntohl(group);
  }
#line 259
  if (tmp <= 3758096639U) {
#line 260
    return;
  }
#line 279
  if (uvifs[vifi].uv_flags & 262144U) {
    {
#line 280
    mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)1);
    }
  } else {
    {
#line 282
    mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)0);
    }
  }
#line 284
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 285
    return;
  }
#line 287
  if (debug) {
#line 287
    if (debug & 1048578UL) {
      {
#line 288
      tmp___0 = inet_fmt(group, s1, sizeof(s1));
#line 288
      logit(7, 0, "Adding vif %d for group %s", (int )vifi, tmp___0);
      }
    }
  }
#line 291
  if (mrtentry_ptr->leaves & (unsigned long )(1 << (int )vifi)) {
#line 292
    return;
  }
  {
#line 293
  calc_oifs(mrtentry_ptr, & old_oifs);
#line 294
  new_leaves = mrtentry_ptr->leaves;
#line 295
  new_leaves |= (unsigned long )(1 << (int )vifi);
#line 296
  change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                    mrtentry_ptr->pruned_oifs, new_leaves, mrtentry_ptr->asserted_oifs,
                    (u_int16 )0);
#line 302
  calc_oifs(mrtentry_ptr, & new_oifs);
  }
#line 305
  if (! (uvifs[vifi].uv_flags & 262144U)) {
#line 306
    return;
  }
#line 308
  if ((int )mrtentry_ptr->flags & 8) {
#line 313
    mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 314
    mrtentry_ptr->jp_timer = (u_int16 )0;
  } else
#line 308
  if (old_oifs == 0UL) {
#line 308
    if (! (new_oifs == 0UL)) {
#line 313
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 314
      mrtentry_ptr->jp_timer = (u_int16 )0;
    }
  }
#line 327
  mrtentry_srcs = (mrtentry_ptr->group)->mrtlink;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 327
      goto while_break;
    }
    {
#line 330
    new_leaves = mrtentry_srcs->leaves;
#line 331
    new_leaves |= (unsigned long )(1 << (int )vifi);
#line 332
    change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                      mrtentry_srcs->pruned_oifs, new_leaves, mrtentry_srcs->asserted_oifs,
                      (u_int16 )0);
#line 327
    mrtentry_srcs = mrtentry_srcs->grpnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return;
}
}
#line 346 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
void delete_leaf(vifi_t vifi , u_int32 source  __attribute__((__unused__)) , u_int32 group ) 
{ 
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_srcs ;
  vifbitmap_t new_oifs ;
  vifbitmap_t old_oifs ;
  vifbitmap_t new_leaves ;

  {
  {
#line 354
  mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)0);
  }
#line 355
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 356
    return;
  }
#line 358
  if (! (mrtentry_ptr->leaves & (unsigned long )(1 << (int )vifi))) {
#line 359
    return;
  }
  {
#line 361
  calc_oifs(mrtentry_ptr, & old_oifs);
#line 362
  new_leaves = mrtentry_ptr->leaves;
#line 363
  new_leaves &= (unsigned long )(~ (1 << (int )vifi));
#line 364
  change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                    mrtentry_ptr->pruned_oifs, new_leaves, mrtentry_ptr->asserted_oifs,
                    (u_int16 )0);
#line 370
  calc_oifs(mrtentry_ptr, & new_oifs);
  }
#line 371
  if (! (old_oifs == 0UL)) {
#line 371
    if (new_oifs == 0UL) {
#line 373
      mrtentry_ptr->jp_timer = (u_int16 )0;
    }
  }
#line 384
  mrtentry_srcs = (mrtentry_ptr->group)->mrtlink;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! ((unsigned long )mrtentry_srcs != (unsigned long )((void *)0))) {
#line 384
      goto while_break;
    }
    {
#line 387
    new_leaves = mrtentry_srcs->leaves;
#line 388
    new_leaves &= (unsigned long )(~ (1 << (int )vifi));
#line 389
    change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                      mrtentry_srcs->pruned_oifs, new_leaves, mrtentry_srcs->asserted_oifs,
                      (u_int16 )0);
#line 384
    mrtentry_srcs = mrtentry_srcs->grpnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  return;
}
}
#line 400 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
void calc_oifs(mrtentry_t *mrtentry_ptr , vifbitmap_t *oifs_ptr ) 
{ 
  vifbitmap_t oifs ;
  mrtentry_t *grp_route ;
  mrtentry_t *rp_route ;

  {
#line 414
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 415
    *oifs_ptr = (vifbitmap_t )0;
#line 416
    return;
  }
#line 419
  oifs = (vifbitmap_t )0;
#line 420
  if (! ((int )mrtentry_ptr->flags & 16384)) {
#line 422
    rp_route = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
#line 422
    if ((unsigned long )rp_route != (unsigned long )((void *)0)) {
#line 423
      oifs |= rp_route->joined_oifs;
#line 424
      oifs &= ~ rp_route->pruned_oifs;
#line 425
      oifs |= rp_route->leaves;
#line 426
      oifs &= ~ rp_route->asserted_oifs;
    }
  }
#line 429
  if ((int )mrtentry_ptr->flags & 8192) {
#line 431
    grp_route = (mrtentry_ptr->group)->grp_route;
#line 431
    if ((unsigned long )grp_route != (unsigned long )((void *)0)) {
#line 432
      oifs |= grp_route->joined_oifs;
#line 433
      oifs &= ~ grp_route->pruned_oifs;
#line 434
      oifs |= grp_route->leaves;
#line 435
      oifs &= ~ grp_route->asserted_oifs;
    }
  }
#line 440
  oifs |= mrtentry_ptr->joined_oifs;
#line 441
  oifs &= ~ mrtentry_ptr->pruned_oifs;
#line 442
  oifs |= mrtentry_ptr->leaves;
#line 443
  oifs &= ~ mrtentry_ptr->asserted_oifs;
#line 445
  *oifs_ptr = oifs;
#line 446
  return;
}
}
#line 458 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
int change_interfaces(mrtentry_t *mrtentry_ptr , vifi_t new_iif , vifbitmap_t new_joined_oifs_ ,
                      vifbitmap_t new_pruned_oifs , vifbitmap_t new_leaves_ , vifbitmap_t new_asserted_oifs ,
                      u_int16 flags ) 
{ 
  vifbitmap_t new_joined_oifs ;
  vifbitmap_t old_joined_oifs  __attribute__((__unused__)) ;
  vifbitmap_t old_pruned_oifs  __attribute__((__unused__)) ;
  vifbitmap_t old_leaves  __attribute__((__unused__)) ;
  vifbitmap_t new_leaves ;
  vifbitmap_t old_asserted_oifs  __attribute__((__unused__)) ;
  vifbitmap_t new_real_oifs ;
  vifbitmap_t old_real_oifs ;
  vifi_t old_iif ;
  rpentry_t *rpentry_ptr ;
  cand_rp_t *cand_rp_ptr ;
  kernel_cache_t *kernel_cache_ptr ;
  rp_grp_entry_t *rp_grp_entry_ptr ;
  grpentry_t *grpentry_ptr ;
  mrtentry_t *mrtentry_srcs ;
  mrtentry_t *mrtentry_wc ;
  mrtentry_t *mrtentry_rp ;
  int delete_mrtentry_flag ;
  int return_value ;
  int fire_timer_flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 487
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 488
    return (0);
  }
  {
#line 490
  new_joined_oifs = new_joined_oifs_;
#line 491
  new_leaves = new_leaves_;
#line 493
  old_iif = mrtentry_ptr->incoming;
#line 494
  old_joined_oifs = mrtentry_ptr->joined_oifs;
#line 495
  old_leaves = mrtentry_ptr->leaves;
#line 496
  old_pruned_oifs = mrtentry_ptr->pruned_oifs;
#line 497
  old_asserted_oifs = mrtentry_ptr->asserted_oifs;
#line 499
  old_real_oifs = mrtentry_ptr->oifs;
#line 501
  mrtentry_ptr->incoming = new_iif;
#line 502
  mrtentry_ptr->joined_oifs = new_joined_oifs;
#line 503
  mrtentry_ptr->pruned_oifs = new_pruned_oifs;
#line 504
  mrtentry_ptr->leaves = new_leaves;
#line 505
  mrtentry_ptr->asserted_oifs = new_asserted_oifs;
#line 506
  calc_oifs(mrtentry_ptr, & new_real_oifs);
  }
#line 508
  if (old_real_oifs == 0UL) {
#line 509
    if (new_real_oifs == 0UL) {
#line 510
      return_value = 0;
    } else {
#line 512
      return_value = 1;
    }
  } else
#line 514
  if (new_real_oifs == 0UL) {
#line 515
    return_value = -1;
  } else {
#line 517
    return_value = 0;
  }
#line 520
  if (new_real_oifs == old_real_oifs) {
#line 520
    if ((int )new_iif == (int )old_iif) {
#line 520
      if (! ((int )flags & 2)) {
#line 523
        return (0);
      }
    }
  }
#line 525
  if (return_value != 0) {
#line 526
    mrtentry_ptr->jp_timer = (u_int16 )0;
  } else
#line 525
  if ((int )new_iif != (int )old_iif) {
#line 526
    mrtentry_ptr->jp_timer = (u_int16 )0;
  } else
#line 525
  if ((int )flags & 2) {
#line 526
    mrtentry_ptr->jp_timer = (u_int16 )0;
  }
#line 528
  mrtentry_ptr->oifs = new_real_oifs;
#line 530
  if ((int )mrtentry_ptr->flags & 16384) {
#line 532
    rpentry_ptr = mrtentry_ptr->source;
#line 533
    if ((unsigned long )rpentry_ptr == (unsigned long )((void *)0)) {
#line 534
      return (0);
    }
#line 536
    rpentry_ptr->incoming = new_iif;
#line 537
    cand_rp_ptr = rpentry_ptr->cand_rp;
#line 539
    if (new_real_oifs == 0UL) {
#line 540
      delete_mrtentry_flag = 1;
    } else {
#line 542
      delete_mrtentry_flag = 0;
    }
#line 548
    if ((int )mrtentry_ptr->flags & 512) {
#line 550
      if (delete_mrtentry_flag == 1) {
#line 554
        kernel_cache_ptr = mrtentry_ptr->kernel_cache;
        {
#line 554
        while (1) {
          while_continue: /* CIL Label */ ;
#line 554
          if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 554
            goto while_break;
          }
          {
#line 557
          delete_mrtentry_all_kernel_cache(mrtentry_ptr);
#line 554
          kernel_cache_ptr = kernel_cache_ptr->next;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 559
        kernel_cache_ptr = mrtentry_ptr->kernel_cache;
        {
#line 559
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 559
          if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 559
            goto while_break___0;
          }
          {
#line 563
          k_chg_mfc(igmp_socket, kernel_cache_ptr->source, kernel_cache_ptr->group,
                    new_iif, new_real_oifs, (mrtentry_ptr->source)->address);
#line 559
          kernel_cache_ptr = kernel_cache_ptr->next;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 574
    fire_timer_flag = 0;
#line 575
    rp_grp_entry_ptr = cand_rp_ptr->rp_grp_next;
    {
#line 575
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 575
      if (! ((unsigned long )rp_grp_entry_ptr != (unsigned long )((void *)0))) {
#line 575
        goto while_break___1;
      }
#line 578
      grpentry_ptr = rp_grp_entry_ptr->grplink;
      {
#line 578
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 578
        if (! ((unsigned long )grpentry_ptr != (unsigned long )((void *)0))) {
#line 578
          goto while_break___2;
        }
#line 581
        if ((unsigned long )grpentry_ptr->grp_route != (unsigned long )((void *)0)) {
          {
#line 582
          tmp = change_interfaces(grpentry_ptr->grp_route, new_iif, (grpentry_ptr->grp_route)->joined_oifs,
                                  (grpentry_ptr->grp_route)->pruned_oifs, (grpentry_ptr->grp_route)->leaves,
                                  (grpentry_ptr->grp_route)->asserted_oifs, flags);
          }
#line 582
          if (tmp) {
#line 588
            fire_timer_flag = 1;
          }
        } else {
#line 591
          mrtentry_srcs = grpentry_ptr->mrtlink;
          {
#line 591
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 591
            if (! ((unsigned long )mrtentry_srcs != (unsigned long )((void *)0))) {
#line 591
              goto while_break___3;
            }
#line 594
            if ((int )mrtentry_srcs->flags & 4) {
              {
#line 595
              tmp___0 = change_interfaces(mrtentry_srcs, new_iif, mrtentry_srcs->joined_oifs,
                                          mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves,
                                          mrtentry_srcs->asserted_oifs, flags);
              }
#line 595
              if (tmp___0) {
#line 601
                fire_timer_flag = 1;
              }
            } else {
              {
#line 603
              tmp___1 = change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming,
                                          mrtentry_srcs->joined_oifs, mrtentry_srcs->pruned_oifs,
                                          mrtentry_srcs->leaves, mrtentry_srcs->asserted_oifs,
                                          flags);
              }
#line 603
              if (tmp___1) {
#line 610
                fire_timer_flag = 1;
              }
            }
#line 591
            mrtentry_srcs = mrtentry_srcs->grpnext;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 578
        grpentry_ptr = grpentry_ptr->rpnext;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 575
      rp_grp_entry_ptr = rp_grp_entry_ptr->rp_grp_next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 616
    if (fire_timer_flag == 1) {
#line 617
      mrtentry_ptr->jp_timer = (u_int16 )0;
    }
#line 626
    return (return_value);
  }
#line 629
  if ((int )mrtentry_ptr->flags & 2) {
#line 631
    if (new_real_oifs == 0UL) {
#line 632
      delete_mrtentry_flag = 1;
    } else {
#line 634
      delete_mrtentry_flag = 0;
    }
#line 640
    if ((int )mrtentry_ptr->flags & 512) {
#line 641
      if (delete_mrtentry_flag == 1) {
        {
#line 642
        delete_mrtentry_all_kernel_cache(mrtentry_ptr);
        }
      } else {
#line 644
        kernel_cache_ptr = mrtentry_ptr->kernel_cache;
        {
#line 644
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 644
          if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 644
            goto while_break___4;
          }
          {
#line 647
          k_chg_mfc(igmp_socket, kernel_cache_ptr->source, kernel_cache_ptr->group,
                    new_iif, new_real_oifs, (mrtentry_ptr->group)->rpaddr);
#line 644
          kernel_cache_ptr = kernel_cache_ptr->next;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 658
    fire_timer_flag = 0;
#line 659
    mrtentry_srcs = (mrtentry_ptr->group)->mrtlink;
    {
#line 659
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 659
      if (! mrtentry_srcs) {
#line 659
        goto while_break___5;
      }
#line 660
      if ((int )mrtentry_srcs->flags & 4) {
        {
#line 661
        tmp___2 = change_interfaces(mrtentry_srcs, new_iif, mrtentry_srcs->joined_oifs,
                                    mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves,
                                    mrtentry_srcs->asserted_oifs, flags);
        }
#line 661
        if (tmp___2) {
#line 666
          fire_timer_flag = 1;
        }
      } else {
        {
#line 668
        tmp___3 = change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                                    mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves,
                                    mrtentry_srcs->asserted_oifs, flags);
        }
#line 668
        if (tmp___3) {
#line 673
          fire_timer_flag = 1;
        }
      }
#line 659
      mrtentry_srcs = mrtentry_srcs->grpnext;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 677
    if (fire_timer_flag == 1) {
#line 678
      mrtentry_ptr->jp_timer = (u_int16 )0;
    }
#line 684
    return (return_value);
  }
#line 687
  if ((int )mrtentry_ptr->flags & 8192) {
#line 694
    mrtentry_rp = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
#line 695
    mrtentry_wc = (mrtentry_ptr->group)->grp_route;
#line 727
    if (new_real_oifs == 0UL) {
#line 728
      delete_mrtentry_flag = 1;
    } else {
#line 730
      delete_mrtentry_flag = 0;
    }
#line 736
    if ((int )mrtentry_ptr->flags & 512) {
#line 737
      if (delete_mrtentry_flag == 1) {
        {
#line 738
        delete_mrtentry_all_kernel_cache(mrtentry_ptr);
        }
      } else {
        {
#line 740
        k_chg_mfc(igmp_socket, (mrtentry_ptr->source)->address, (mrtentry_ptr->group)->group,
                  new_iif, new_real_oifs, (mrtentry_ptr->group)->rpaddr);
        }
      }
    }
#line 745
    if ((int )old_iif != (int )new_iif) {
#line 746
      if ((int )new_iif == (int )(mrtentry_ptr->source)->incoming) {
#line 753
        mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -5);
      }
#line 760
      if ((unsigned long )mrtentry_wc != (unsigned long )((void *)0)) {
#line 760
        if ((int )mrtentry_wc->incoming == (int )new_iif) {
#line 767
          mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -2);
#line 768
          mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 4);
        } else {
#line 760
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 760
      if ((unsigned long )mrtentry_rp != (unsigned long )((void *)0)) {
#line 760
        if ((int )mrtentry_rp->incoming == (int )new_iif) {
#line 767
          mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -2);
#line 768
          mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 4);
        }
      }
    }
#line 779
    return (return_value);
  }
#line 782
  return (return_value);
}
}
#line 789 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
int delete_vif_from_mrt(vifi_t vifi  __attribute__((__unused__)) ) 
{ 


  {
#line 791
  return (1);
}
}
#line 795 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
void process_kernel_call(void) 
{ 
  struct igmpmsg *igmpctl ;

  {
#line 799
  igmpctl = (struct igmpmsg *)igmp_recv_buf;
  {
#line 802
  if ((int )igmpctl->im_msgtype == 1) {
#line 802
    goto case_1;
  }
#line 805
  if ((int )igmpctl->im_msgtype == 2) {
#line 805
    goto case_2;
  }
#line 808
  if ((int )igmpctl->im_msgtype == 3) {
#line 808
    goto case_3;
  }
#line 811
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 803
  process_cache_miss(igmpctl);
  }
#line 804
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 806
  process_wrong_iif(igmpctl);
  }
#line 807
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 809
  process_whole_pkt(igmp_recv_buf);
  }
#line 810
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 812
  if (debug) {
#line 812
    if (debug & 2048UL) {
      {
#line 813
      logit(7, 0, "Unknown kernel_call code");
      }
    }
  }
#line 814
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 816
  return;
}
}
#line 823 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
static void process_cache_miss(struct igmpmsg *igmpctl ) 
{ 
  u_int32 source ;
  u_int32 mfc_source ;
  u_int32 group ;
  u_int32 rp_addr ;
  vifi_t iif ;
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_rp ;
  char *tmp ;
  char *tmp___0 ;
  uint32_t tmp___1 ;
  vifi_t tmp___2 ;

  {
#line 837
  group = igmpctl->im_dst.s_addr;
#line 838
  mfc_source = igmpctl->im_src.s_addr;
#line 838
  source = mfc_source;
#line 839
  iif = (vifi_t )igmpctl->im_vif;
#line 841
  if (debug) {
#line 841
    if (debug & 4096UL) {
      {
#line 842
      tmp = inet_fmt(group, s2, sizeof(s2));
#line 842
      tmp___0 = inet_fmt(source, s1, sizeof(s1));
#line 842
      logit(7, 0, "Cache miss, src %s, dst %s, iif %d", tmp___0, tmp, (int )iif);
      }
    }
  }
  {
#line 847
  tmp___1 = ntohl(group);
  }
#line 847
  if (tmp___1 <= 3758096639U) {
#line 848
    return;
  }
#line 854
  if (uvifs[iif].uv_flags & 262144U) {
    {
#line 854
    tmp___2 = find_vif_direct_local(source);
    }
#line 854
    if ((int )tmp___2 == (int )iif) {
      {
#line 855
      mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)1);
      }
#line 856
      if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 857
        return;
      }
#line 859
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 861
      if ((mrtentry_ptr->group)->rpaddr != my_cand_rp_address) {
#line 862
        mrtentry_ptr->joined_oifs |= (unsigned long )(1 << (int )reg_vif_num);
      }
      {
#line 863
      change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                        mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                        (u_int16 )0);
      }
    } else {
#line 854
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 870
    mrtentry_ptr = find_route(source, group, (u_int16 )24578, (char)0);
    }
#line 871
    if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 872
      return;
    }
  }
#line 880
  if ((int )mrtentry_ptr->incoming == (int )iif) {
#line 881
    if (! (mrtentry_ptr->oifs == 0UL)) {
#line 882
      if ((int )mrtentry_ptr->flags & 8192) {
#line 885
        if ((int )mrtentry_ptr->timer < 210) {
#line 886
          mrtentry_ptr->timer = (u_int16 )210;
        }
#line 887
        if (! ((int )mrtentry_ptr->flags & 1)) {
#line 888
          mrtentry_rp = (mrtentry_ptr->group)->grp_route;
#line 888
          if ((unsigned long )mrtentry_rp == (unsigned long )((void *)0)) {
#line 889
            mrtentry_rp = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
          }
#line 891
          if ((unsigned long )mrtentry_rp != (unsigned long )((void *)0)) {
#line 895
            if ((int )mrtentry_ptr->incoming != (int )mrtentry_rp->incoming) {
#line 897
              mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 1);
#line 898
              mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -5);
            } else
#line 895
            if ((unsigned long )mrtentry_ptr->upstream != (unsigned long )mrtentry_rp->upstream) {
#line 897
              mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 1);
#line 898
              mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -5);
            }
          }
        }
      }
#line 904
      if ((int )mrtentry_ptr->flags & 16384) {
#line 905
        rp_addr = (mrtentry_ptr->source)->address;
      } else {
#line 907
        rp_addr = (mrtentry_ptr->group)->rpaddr;
      }
      {
#line 909
      mfc_source = source;
#line 915
      add_kernel_cache(mrtentry_ptr, mfc_source, group, (u_int16 )1);
#line 919
      k_chg_mfc(igmp_socket, mfc_source, group, iif, mrtentry_ptr->oifs, rp_addr);
      }
    }
#line 926
    return;
  }
#line 930
  if ((int )mrtentry_ptr->flags & 8192) {
#line 932
    if ((int )mrtentry_ptr->flags & 1) {
#line 933
      return;
    }
#line 935
    mrtentry_rp = (mrtentry_ptr->group)->grp_route;
#line 935
    if ((unsigned long )mrtentry_rp == (unsigned long )((void *)0)) {
#line 936
      mrtentry_rp = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
    }
#line 938
    if ((unsigned long )mrtentry_rp != (unsigned long )((void *)0)) {
#line 939
      if ((int )mrtentry_rp->incoming == (int )iif) {
        {
#line 945
        add_kernel_cache(mrtentry_rp, mfc_source, group, (u_int16 )0);
#line 950
        k_chg_mfc(igmp_socket, mfc_source, group, iif, mrtentry_rp->oifs, (mrtentry_ptr->group)->rpaddr);
        }
      }
    }
  }
#line 958
  return;
}
}
#line 970 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
static void process_wrong_iif(struct igmpmsg *igmpctl ) 
{ 
  u_int32 source ;
  u_int32 group ;
  vifi_t iif ;
  mrtentry_t *mrtentry_ptr ;
  uint32_t tmp ;

  {
  {
#line 977
  group = igmpctl->im_dst.s_addr;
#line 978
  source = igmpctl->im_src.s_addr;
#line 979
  iif = (vifi_t )igmpctl->im_vif;
#line 982
  tmp = ntohl(group);
  }
#line 982
  if (tmp <= 3758096639U) {
#line 983
    return;
  }
#line 988
  if (uvifs[iif].uv_flags & 4U) {
#line 989
    return;
  }
  {
#line 991
  mrtentry_ptr = find_route(source, group, (u_int16 )24578, (char)0);
  }
#line 993
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 994
    return;
  }
#line 999
  if ((int )mrtentry_ptr->flags & 8192) {
#line 1000
    if (! ((int )mrtentry_ptr->flags & 1)) {
#line 1001
      if ((int )(mrtentry_ptr->source)->incoming == (int )iif) {
        {
#line 1003
        mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 1);
#line 1004
        mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -5);
#line 1005
        add_kernel_cache(mrtentry_ptr, source, group, (u_int16 )1);
#line 1006
        k_chg_mfc(igmp_socket, source, group, iif, mrtentry_ptr->oifs, (mrtentry_ptr->group)->rpaddr);
#line 1008
        mrtentry_ptr->jp_timer = (u_int16 )0;
        }
#line 1013
        return;
      }
    }
  }
#line 1019
  if (mrtentry_ptr->oifs & (unsigned long )(1 << (int )iif)) {
    {
#line 1020
    send_pim_assert(source, group, iif, mrtentry_ptr);
    }
  }
#line 1021
  return;
}
}
#line 1028 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
static void process_whole_pkt(char *buf ) 
{ 


  {
  {
#line 1030
  send_pim_register(buf + sizeof(struct igmpmsg ));
  }
#line 1031
  return;
}
}
#line 1034 "/home/wheatley/newnew/temp/pimd-2.1.8/route.c"
mrtentry_t *switch_shortest_path(u_int32 source , u_int32 group ) 
{ 
  mrtentry_t *mrtentry_ptr ;

  {
  {
#line 1039
  mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)1);
  }
#line 1039
  if ((unsigned long )mrtentry_ptr != (unsigned long )((void *)0)) {
#line 1040
    if ((int )mrtentry_ptr->flags & 8) {
#line 1041
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
    } else
#line 1043
    if ((int )mrtentry_ptr->flags & 4) {
      {
#line 1050
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -5);
#line 1051
      mrtentry_ptr->incoming = (mrtentry_ptr->source)->incoming;
#line 1052
      mrtentry_ptr->upstream = (mrtentry_ptr->source)->upstream;
#line 1053
      delete_mrtentry_all_kernel_cache(mrtentry_ptr);
#line 1054
      change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                        mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                        (u_int16 )0);
      }
    }
#line 1062
    mrtentry_ptr->timer = (u_int16 )210;
#line 1063
    mrtentry_ptr->jp_timer = (u_int16 )0;
  }
#line 1066
  return (mrtentry_ptr);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 300 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 pim_reg_rate_bytes ;
#line 301
u_int32 pim_reg_rate_check_interval ;
#line 302
u_int32 pim_data_rate_bytes ;
#line 303
u_int32 pim_data_rate_check_interval ;
#line 305
cand_rp_t *cand_rp_list ;
#line 306
grp_mask_t *grp_mask_list ;
#line 310
u_int16 curr_bsr_fragment_tag ;
#line 311
u_int8 curr_bsr_priority ;
#line 312
u_int32 curr_bsr_address ;
#line 313
u_int32 curr_bsr_hash_mask ;
#line 314
u_int8 cand_bsr_flag ;
#line 315
u_int8 my_bsr_priority ;
#line 316
u_int32 my_bsr_address ;
#line 317
u_int32 my_bsr_hash_mask ;
#line 318
u_int8 cand_rp_flag ;
#line 322
u_int16 my_cand_rp_adv_period ;
#line 325
u_int16 pim_bootstrap_timer ;
#line 327
u_int16 pim_cand_rp_adv_timer ;
#line 445
void dump_vifs(FILE *fp ) ;
#line 446
void dump_pim_mrt(FILE *fp ) ;
#line 447
int dump_rp_set(FILE *fp ) ;
#line 506
void delete_mrtentry(mrtentry_t *mrtentry_ptr ) ;
#line 510
void delete_single_kernel_cache(mrtentry_t *mrtentry_ptr , kernel_cache_t *kernel_cache_ptr ) ;
#line 521
void delete_pim_nbr(pim_nbr_entry_t *nbr_delete ) ;
#line 523
int send_pim_null_register(mrtentry_t *mrtentry_ptr ) ;
#line 527
int join_or_prune(mrtentry_t *mrtentry_ptr , pim_nbr_entry_t *upstream_router ) ;
#line 531
int add_jp_entry(pim_nbr_entry_t *pim_nbr , u_int16 holdtime , u_int32 group , u_int8 grp_msklen ,
                 u_int32 source , u_int8 src_msklen , u_int16 addr_flags , u_int8 join_prune ) ;
#line 533
void pack_and_send_jp_message(pim_nbr_entry_t *pim_nbr ) ;
#line 536
int send_pim_cand_rp_adv(void) ;
#line 537
void send_pim_bootstrap(void) ;
#line 563
u_int16 bootstrap_initial_delay(void) ;
#line 573
void delete_rp_grp_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                         rp_grp_entry_t *entry ) ;
#line 603
void init_timers(void) ;
#line 604
void age_vifs(void) ;
#line 605
void age_routes(void) ;
#line 606
void age_misc(void) ;
#line 46 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int32 pim_reg_rate_bytes  =    (u_int32 )100000;
#line 48 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int32 pim_reg_rate_check_interval  =    (u_int32 )20;
#line 49 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int32 pim_data_rate_bytes  =    (u_int32 )100000;
#line 51 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int32 pim_data_rate_check_interval  =    (u_int32 )20;
#line 63 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int16 unicast_routing_timer  ;
#line 66 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int16 unicast_routing_check_interval  ;
#line 67 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int8 ucast_flag  ;
#line 69 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int16 pim_data_rate_timer  ;
#line 74 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int8 pim_data_rate_flag  ;
#line 76 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int16 pim_reg_rate_timer  ;
#line 80 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int8 pim_reg_rate_flag  ;
#line 81 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int8 rate_flag  ;
#line 87 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int16 kernel_cache_timer  ;
#line 90 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
u_int16 kernel_cache_check_interval  ;
#line 93 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
srcentry_t srcentry_save  ;
#line 94 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
rpentry_t rpentry_save  ;
#line 99 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
void init_timers(void) 
{ 


  {
#line 102
  unicast_routing_check_interval = (u_int16 )20;
#line 103
  unicast_routing_timer = unicast_routing_check_interval;
#line 108
  if (pim_data_rate_check_interval < pim_reg_rate_check_interval) {
#line 109
    pim_reg_rate_check_interval = pim_data_rate_check_interval;
  }
#line 111
  pim_data_rate_timer = (u_int16 )((3U * pim_data_rate_check_interval) / 2U);
#line 112
  pim_reg_rate_timer = (u_int16 )((3U * pim_reg_rate_check_interval) / 2U);
#line 117
  srcentry_save.prev = (srcentry_t *)((void *)0);
#line 118
  srcentry_save.next = (srcentry_t *)((void *)0);
#line 119
  srcentry_save.address = (u_int32 )0;
#line 120
  srcentry_save.mrtlink = (mrtentry_t *)((void *)0);
#line 121
  srcentry_save.incoming = (vifi_t )32;
#line 122
  srcentry_save.upstream = (pim_nbr_entry_t *)((void *)0);
#line 123
  srcentry_save.metric = (u_int32 )(~ 0);
#line 124
  srcentry_save.preference = (u_int32 )(~ 0);
#line 125
  srcentry_save.timer = (u_int16 )0;
#line 126
  srcentry_save.cand_rp = (cand_rp_t *)((void *)0);
#line 128
  rpentry_save.prev = (rpentry_t *)((void *)0);
#line 129
  rpentry_save.next = (rpentry_t *)((void *)0);
#line 130
  rpentry_save.address = (u_int32 )0;
#line 131
  rpentry_save.mrtlink = (mrtentry_t *)((void *)0);
#line 132
  rpentry_save.incoming = (vifi_t )32;
#line 133
  rpentry_save.upstream = (pim_nbr_entry_t *)((void *)0);
#line 134
  rpentry_save.metric = (u_int32 )(~ 0);
#line 135
  rpentry_save.preference = (u_int32 )(~ 0);
#line 136
  rpentry_save.timer = (u_int16 )0;
#line 137
  rpentry_save.cand_rp = (cand_rp_t *)((void *)0);
#line 139
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
void age_vifs(void) 
{ 
  vifi_t vifi ;
  register struct uvif *v ;
  register pim_nbr_entry_t *next_nbr ;
  register pim_nbr_entry_t *curr_nbr ;
  int tmp ;
  u_int16 tmp___0 ;
  int tmp___1 ;
  u_int16 tmp___2 ;
  int tmp___3 ;
  u_int16 tmp___4 ;

  {
#line 161
  if (vifs_down) {
    {
#line 163
    check_vif_state();
    }
  }
#line 166
  vifi = (vifi_t )0;
#line 166
  v = uvifs;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((int )vifi < (int )numvifs)) {
#line 166
      goto while_break;
    }
#line 167
    if (v->uv_flags & 772U) {
#line 168
      goto __Cont;
    }
#line 170
    curr_nbr = v->uv_pim_neighbors;
    {
#line 170
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 170
      if (! ((unsigned long )curr_nbr != (unsigned long )((void *)0))) {
#line 170
        goto while_break___0;
      }
#line 172
      next_nbr = curr_nbr->next;
#line 179
      if (65535 == (int )curr_nbr->timer) {
#line 180
        goto __Cont___0;
      }
#line 181
      if ((int )curr_nbr->timer < 5) {
#line 181
        tmp = (int )curr_nbr->timer;
      } else {
#line 181
        tmp = 5;
      }
#line 181
      tmp___0 = (u_int16 )((int )curr_nbr->timer - tmp);
#line 181
      curr_nbr->timer = tmp___0;
#line 181
      if (tmp___0) {
#line 182
        goto __Cont___0;
      }
      {
#line 184
      delete_pim_nbr(curr_nbr);
      }
      __Cont___0: /* CIL Label */ 
#line 170
      curr_nbr = next_nbr;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 188
    if ((int )v->uv_pim_hello_timer < 5) {
#line 188
      tmp___1 = (int )v->uv_pim_hello_timer;
    } else {
#line 188
      tmp___1 = 5;
    }
#line 188
    tmp___2 = (u_int16 )((int )v->uv_pim_hello_timer - tmp___1);
#line 188
    v->uv_pim_hello_timer = tmp___2;
#line 188
    if (! tmp___2) {
      {
#line 189
      send_pim_hello(v, (u_int16 )(3.5 * (double )30));
      }
    }
#line 207
    if ((int )v->uv_gq_timer < 5) {
#line 207
      tmp___3 = (int )v->uv_gq_timer;
    } else {
#line 207
      tmp___3 = 5;
    }
#line 207
    tmp___4 = (u_int16 )((int )v->uv_gq_timer - tmp___3);
#line 207
    v->uv_gq_timer = tmp___4;
#line 207
    if (! tmp___4) {
      {
#line 208
      query_groups(v);
      }
    }
    __Cont: /* CIL Label */ 
#line 166
    vifi = (vifi_t )((int )vifi + 1);
#line 166
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  if (debug) {
#line 211
    if (debug & 1024UL) {
      {
#line 212
      dump_vifs(stderr);
      }
    }
  }
#line 213
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
void age_routes(void) 
{ 
  cand_rp_t *cand_rp_ptr ;
  grpentry_t *grpentry_ptr ;
  grpentry_t *grpentry_ptr_next ;
  mrtentry_t *mrtentry_grp ;
  mrtentry_t *mrtentry_rp ;
  mrtentry_t *mrtentry_wide ;
  mrtentry_t *mrtentry_srcs ;
  mrtentry_t *mrtentry_srcs_next ;
  struct uvif *v ;
  vifi_t vifi ;
  pim_nbr_entry_t *pim_nbr_ptr ;
  int change_flag ;
  int rp_action ;
  int grp_action ;
  int src_action ;
  int src_action_rp ;
  int dont_calc_action ;
  int did_switch_flag ;
  rp_grp_entry_t *rp_grp_entry_ptr ;
  kernel_cache_t *kernel_cache_ptr ;
  kernel_cache_t *kernel_cache_next ;
  u_long curr_bytecnt ;
  rpentry_t *rpentry_ptr ;
  int update_rp_iif ;
  int update_src_iif ;
  vifbitmap_t new_pruned_oifs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int16 tmp___4 ;
  int tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  u_int16 tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  int tmp___11 ;
  u_int16 tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  u_int16 tmp___15 ;
  int tmp___16 ;
  u_int16 tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  u_int16 tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  int tmp___23 ;
  u_int16 tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  u_int16 tmp___27 ;
  int tmp___28 ;
  u_int16 tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  u_int16 tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  int tmp___36 ;
  u_int16 tmp___37 ;
  int tmp___38 ;
  u_int16 tmp___39 ;

  {
#line 278
  src_action = 0;
#line 278
  src_action_rp = 0;
#line 294
  if ((int )unicast_routing_timer < 5) {
#line 294
    tmp = (int )unicast_routing_timer;
  } else {
#line 294
    tmp = 5;
  }
#line 294
  unicast_routing_timer = (u_int16 )((int )unicast_routing_timer - tmp);
#line 294
  if (unicast_routing_timer) {
#line 299
    ucast_flag = (u_int8 )0;
  } else {
#line 295
    ucast_flag = (u_int8 )1;
#line 296
    unicast_routing_timer = unicast_routing_check_interval;
  }
#line 301
  if ((int )pim_data_rate_timer < 5) {
#line 301
    tmp___0 = (int )pim_data_rate_timer;
  } else {
#line 301
    tmp___0 = 5;
  }
#line 301
  pim_data_rate_timer = (u_int16 )((int )pim_data_rate_timer - tmp___0);
#line 301
  if (pim_data_rate_timer) {
#line 306
    pim_data_rate_flag = (u_int8 )0;
  } else {
#line 302
    pim_data_rate_flag = (u_int8 )1;
#line 303
    pim_data_rate_timer = (u_int16 )pim_data_rate_check_interval;
  }
#line 308
  if ((int )pim_reg_rate_timer < 5) {
#line 308
    tmp___1 = (int )pim_reg_rate_timer;
  } else {
#line 308
    tmp___1 = 5;
  }
#line 308
  pim_reg_rate_timer = (u_int16 )((int )pim_reg_rate_timer - tmp___1);
#line 308
  if (pim_reg_rate_timer) {
#line 313
    pim_reg_rate_flag = (u_int8 )0;
  } else {
#line 309
    pim_reg_rate_flag = (u_int8 )1;
#line 310
    pim_reg_rate_timer = (u_int16 )pim_reg_rate_check_interval;
  }
#line 316
  rate_flag = (u_int8 )((int )pim_data_rate_flag | (int )pim_reg_rate_flag);
#line 319
  cand_rp_ptr = cand_rp_list;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ((unsigned long )cand_rp_ptr != (unsigned long )((cand_rp_t *)((void *)0)))) {
#line 319
      goto while_break;
    }
#line 322
    rpentry_ptr = cand_rp_ptr->rpentry;
#line 327
    rpentry_save.incoming = rpentry_ptr->incoming;
#line 328
    rpentry_save.upstream = rpentry_ptr->upstream;
#line 330
    update_rp_iif = 0;
#line 331
    if ((int )ucast_flag == 1) {
#line 331
      if (rpentry_ptr->address != my_cand_rp_address) {
        {
#line 336
        tmp___2 = set_incoming(rpentry_ptr, 2);
        }
#line 336
        if (! (tmp___2 != 1)) {
#line 346
          if ((unsigned long )rpentry_save.upstream != (unsigned long )rpentry_ptr->upstream) {
#line 351
            update_rp_iif = 1;
          } else
#line 346
          if ((int )rpentry_save.incoming != (int )rpentry_ptr->incoming) {
#line 351
            update_rp_iif = 1;
          }
        }
      }
    }
#line 356
    rp_action = 0;
#line 357
    mrtentry_rp = (cand_rp_ptr->rpentry)->mrtlink;
#line 358
    if ((unsigned long )mrtentry_rp != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 360
      change_flag = 0;
#line 361
      vifi = (vifi_t )0;
      {
#line 361
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 361
        if (! ((int )vifi < (int )numvifs)) {
#line 361
          goto while_break___0;
        }
#line 362
        if (mrtentry_rp->joined_oifs & (unsigned long )(1 << (int )vifi)) {
#line 363
          if ((int )*(mrtentry_rp->vif_timers + vifi) < 5) {
#line 363
            tmp___3 = (int )*(mrtentry_rp->vif_timers + vifi);
          } else {
#line 363
            tmp___3 = 5;
          }
#line 363
          tmp___4 = (u_int16 )((int )*(mrtentry_rp->vif_timers + vifi) - tmp___3);
#line 363
          *(mrtentry_rp->vif_timers + vifi) = tmp___4;
#line 363
          if (! tmp___4) {
#line 364
            mrtentry_rp->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 365
            change_flag = 1;
          }
        }
#line 361
        vifi = (vifi_t )((int )vifi + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 369
      if (change_flag == 1) {
        {
#line 370
        change_interfaces(mrtentry_rp, rpentry_ptr->incoming, mrtentry_rp->joined_oifs,
                          mrtentry_rp->pruned_oifs, mrtentry_rp->leaves, mrtentry_rp->asserted_oifs,
                          (u_int16 )0);
#line 376
        mrtentry_rp->upstream = rpentry_ptr->upstream;
        }
      } else
#line 369
      if (update_rp_iif == 1) {
        {
#line 370
        change_interfaces(mrtentry_rp, rpentry_ptr->incoming, mrtentry_rp->joined_oifs,
                          mrtentry_rp->pruned_oifs, mrtentry_rp->leaves, mrtentry_rp->asserted_oifs,
                          (u_int16 )0);
#line 376
        mrtentry_rp->upstream = rpentry_ptr->upstream;
        }
      }
#line 379
      if ((int )rate_flag == 1) {
#line 409
        kernel_cache_ptr = mrtentry_rp->kernel_cache;
        {
#line 409
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 409
          if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 409
            goto while_break___1;
          }
          {
#line 412
          kernel_cache_next = kernel_cache_ptr->next;
#line 413
          curr_bytecnt = kernel_cache_ptr->sg_count.bytecnt;
#line 414
          tmp___5 = k_get_sg_cnt(udp_socket, kernel_cache_ptr->source, kernel_cache_ptr->group,
                                 & kernel_cache_ptr->sg_count);
          }
#line 414
          if (tmp___5) {
            {
#line 423
            delete_single_kernel_cache(mrtentry_rp, kernel_cache_ptr);
            }
#line 425
            goto __Cont;
          } else
#line 414
          if (curr_bytecnt == kernel_cache_ptr->sg_count.bytecnt) {
            {
#line 423
            delete_single_kernel_cache(mrtentry_rp, kernel_cache_ptr);
            }
#line 425
            goto __Cont;
          }
#line 431
          did_switch_flag = 0;
#line 432
          if (curr_bytecnt + (u_long )pim_data_rate_bytes < kernel_cache_ptr->sg_count.bytecnt) {
#line 434
            if (mrtentry_rp->leaves & mrtentry_rp->oifs) {
              {
#line 444
              switch_shortest_path(kernel_cache_ptr->source, kernel_cache_ptr->group);
#line 446
              did_switch_flag = 1;
              }
            }
          }
#line 450
          if (did_switch_flag == 0) {
#line 450
            if (curr_bytecnt + (u_long )pim_reg_rate_bytes < kernel_cache_ptr->sg_count.bytecnt) {
#line 453
              if ((int )mrtentry_rp->incoming == (int )reg_vif_num) {
                {
#line 462
                switch_shortest_path(kernel_cache_ptr->source, kernel_cache_ptr->group);
                }
              }
            }
          }
          __Cont: /* CIL Label */ 
#line 409
          kernel_cache_ptr = kernel_cache_next;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 469
      if ((int )mrtentry_rp->jp_timer < 5) {
#line 469
        tmp___7 = (int )mrtentry_rp->jp_timer;
      } else {
#line 469
        tmp___7 = 5;
      }
#line 469
      tmp___8 = (u_int16 )((int )mrtentry_rp->jp_timer - tmp___7);
#line 469
      mrtentry_rp->jp_timer = tmp___8;
#line 469
      if (! tmp___8) {
        {
#line 470
        rp_action = join_or_prune(mrtentry_rp, mrtentry_rp->upstream);
        }
#line 472
        if (rp_action != 0) {
          {
#line 473
          tmp___6 = htonl(3758096384U);
#line 473
          add_jp_entry(mrtentry_rp->upstream, (u_int16 )(3.5 * (double )60), tmp___6,
                       (u_int8 )4, (mrtentry_rp->source)->address, (u_int8 )32, (u_int16 )6,
                       (u_int8 )rp_action);
          }
        }
#line 481
        mrtentry_rp->jp_timer = (u_int16 )60;
      }
#line 485
      if ((int )mrtentry_rp->flags & 4096) {
#line 486
        if (mrtentry_rp->assert_timer < 5U) {
#line 486
          tmp___9 = mrtentry_rp->assert_timer;
        } else {
#line 486
          tmp___9 = (u_int )5;
        }
#line 486
        tmp___10 = mrtentry_rp->assert_timer - tmp___9;
#line 486
        mrtentry_rp->assert_timer = tmp___10;
#line 486
        if (! tmp___10) {
#line 488
          mrtentry_rp->flags = (u_int16 )((int )mrtentry_rp->flags & -4097);
        }
      }
#line 498
      if ((int )mrtentry_rp->rs_timer < 5) {
#line 498
        tmp___11 = (int )mrtentry_rp->rs_timer;
      } else {
#line 498
        tmp___11 = 5;
      }
#line 498
      tmp___12 = (u_int16 )((int )mrtentry_rp->rs_timer - tmp___11);
#line 498
      mrtentry_rp->rs_timer = tmp___12;
#line 498
      if (tmp___12) {
#line 498
        tmp___13 = 0;
      } else {
#line 498
        tmp___13 = 1;
      }
#line 501
      if ((int )mrtentry_rp->timer < 5) {
#line 501
        tmp___14 = (int )mrtentry_rp->timer;
      } else {
#line 501
        tmp___14 = 5;
      }
#line 501
      tmp___15 = (u_int16 )((int )mrtentry_rp->timer - tmp___14);
#line 501
      mrtentry_rp->timer = tmp___15;
#line 501
      if (! tmp___15) {
#line 501
        if (mrtentry_rp->leaves == 0UL) {
          {
#line 503
          delete_mrtentry(mrtentry_rp);
          }
        }
      }
    }
#line 508
    mrtentry_rp = (cand_rp_ptr->rpentry)->mrtlink;
#line 511
    rp_grp_entry_ptr = cand_rp_ptr->rp_grp_next;
    {
#line 511
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 511
      if (! ((unsigned long )rp_grp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 511
        goto while_break___2;
      }
#line 514
      grpentry_ptr = rp_grp_entry_ptr->grplink;
      {
#line 514
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 514
        if (! ((unsigned long )grpentry_ptr != (unsigned long )((grpentry_t *)((void *)0)))) {
#line 514
          goto while_break___3;
        }
#line 517
        grpentry_ptr_next = grpentry_ptr->rpnext;
#line 518
        mrtentry_grp = grpentry_ptr->grp_route;
#line 519
        mrtentry_srcs = grpentry_ptr->mrtlink;
#line 521
        grp_action = 0;
#line 522
        if ((unsigned long )mrtentry_grp != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 525
          change_flag = 0;
#line 526
          vifi = (vifi_t )0;
          {
#line 526
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 526
            if (! ((int )vifi < (int )numvifs)) {
#line 526
              goto while_break___4;
            }
#line 527
            if (mrtentry_grp->joined_oifs & (unsigned long )(1 << (int )vifi)) {
#line 528
              if ((int )*(mrtentry_grp->vif_timers + vifi) < 5) {
#line 528
                tmp___16 = (int )*(mrtentry_grp->vif_timers + vifi);
              } else {
#line 528
                tmp___16 = 5;
              }
#line 528
              tmp___17 = (u_int16 )((int )*(mrtentry_grp->vif_timers + vifi) - tmp___16);
#line 528
              *(mrtentry_grp->vif_timers + vifi) = tmp___17;
#line 528
              if (! tmp___17) {
#line 529
                mrtentry_grp->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 530
                change_flag = 1;
              }
            }
#line 526
            vifi = (vifi_t )((int )vifi + 1);
          }
          while_break___4: /* CIL Label */ ;
          }
#line 534
          if (change_flag == 1) {
            {
#line 535
            change_interfaces(mrtentry_grp, rpentry_ptr->incoming, mrtentry_grp->joined_oifs,
                              mrtentry_grp->pruned_oifs, mrtentry_grp->leaves, mrtentry_grp->asserted_oifs,
                              (u_int16 )0);
#line 541
            mrtentry_grp->upstream = rpentry_ptr->upstream;
            }
          } else
#line 534
          if (update_rp_iif == 1) {
            {
#line 535
            change_interfaces(mrtentry_grp, rpentry_ptr->incoming, mrtentry_grp->joined_oifs,
                              mrtentry_grp->pruned_oifs, mrtentry_grp->leaves, mrtentry_grp->asserted_oifs,
                              (u_int16 )0);
#line 541
            mrtentry_grp->upstream = rpentry_ptr->upstream;
            }
          }
#line 545
          if ((int )rate_flag == 1) {
#line 546
            kernel_cache_ptr = mrtentry_grp->kernel_cache;
            {
#line 546
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 546
              if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 546
                goto while_break___5;
              }
              {
#line 549
              kernel_cache_next = kernel_cache_ptr->next;
#line 550
              curr_bytecnt = kernel_cache_ptr->sg_count.bytecnt;
#line 552
              tmp___18 = k_get_sg_cnt(udp_socket, kernel_cache_ptr->source, kernel_cache_ptr->group,
                                      & kernel_cache_ptr->sg_count);
              }
#line 552
              if (tmp___18) {
                {
#line 564
                delete_single_kernel_cache(mrtentry_grp, kernel_cache_ptr);
                }
#line 566
                goto __Cont___0;
              } else
#line 552
              if (curr_bytecnt == kernel_cache_ptr->sg_count.bytecnt) {
                {
#line 564
                delete_single_kernel_cache(mrtentry_grp, kernel_cache_ptr);
                }
#line 566
                goto __Cont___0;
              }
#line 572
              did_switch_flag = 0;
#line 573
              if (curr_bytecnt + (u_long )pim_data_rate_bytes < kernel_cache_ptr->sg_count.bytecnt) {
#line 575
                if (mrtentry_grp->leaves & mrtentry_grp->oifs) {
                  {
#line 586
                  switch_shortest_path(kernel_cache_ptr->source, kernel_cache_ptr->group);
#line 587
                  did_switch_flag = 1;
                  }
                }
              }
#line 591
              if (did_switch_flag == 0) {
#line 591
                if (curr_bytecnt + (u_long )pim_reg_rate_bytes < kernel_cache_ptr->sg_count.bytecnt) {
#line 594
                  if ((int )mrtentry_grp->incoming == (int )reg_vif_num) {
                    {
#line 604
                    switch_shortest_path(kernel_cache_ptr->source, kernel_cache_ptr->group);
                    }
                  }
                }
              }
              __Cont___0: /* CIL Label */ 
#line 546
              kernel_cache_ptr = kernel_cache_next;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
#line 611
          dont_calc_action = 0;
#line 612
          if (rp_action != 0) {
            {
#line 613
            grp_action = join_or_prune(mrtentry_grp, mrtentry_grp->upstream);
#line 615
            dont_calc_action = 1;
            }
#line 616
            if (rp_action == 1) {
#line 616
              if (grp_action == 2) {
#line 620
                mrtentry_grp->jp_timer = (u_int16 )0;
              } else {
#line 616
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 616
            if (rp_action == 2) {
#line 616
              if (grp_action == 1) {
#line 620
                mrtentry_grp->jp_timer = (u_int16 )0;
              }
            }
          }
#line 623
          if ((int )mrtentry_grp->jp_timer < 5) {
#line 623
            tmp___19 = (int )mrtentry_grp->jp_timer;
          } else {
#line 623
            tmp___19 = 5;
          }
#line 623
          tmp___20 = (u_int16 )((int )mrtentry_grp->jp_timer - tmp___19);
#line 623
          mrtentry_grp->jp_timer = tmp___20;
#line 623
          if (! tmp___20) {
#line 624
            if (dont_calc_action != 1) {
              {
#line 625
              grp_action = join_or_prune(mrtentry_grp, mrtentry_grp->upstream);
              }
            }
#line 627
            if (grp_action != 0) {
              {
#line 628
              add_jp_entry(mrtentry_grp->upstream, (u_int16 )(3.5 * (double )60),
                           (mrtentry_grp->group)->group, (u_int8 )32, (cand_rp_ptr->rpentry)->address,
                           (u_int8 )32, (u_int16 )6, (u_int8 )grp_action);
              }
            }
#line 636
            mrtentry_grp->jp_timer = (u_int16 )60;
          }
#line 640
          if ((int )mrtentry_grp->flags & 4096) {
#line 641
            if (mrtentry_grp->assert_timer < 5U) {
#line 641
              tmp___21 = mrtentry_grp->assert_timer;
            } else {
#line 641
              tmp___21 = (u_int )5;
            }
#line 641
            tmp___22 = mrtentry_grp->assert_timer - tmp___21;
#line 641
            mrtentry_grp->assert_timer = tmp___22;
#line 641
            if (! tmp___22) {
#line 643
              mrtentry_grp->flags = (u_int16 )((int )mrtentry_grp->flags & -4097);
            }
          }
#line 654
          if ((int )mrtentry_grp->rs_timer < 5) {
#line 654
            tmp___23 = (int )mrtentry_grp->rs_timer;
          } else {
#line 654
            tmp___23 = 5;
          }
#line 654
          tmp___24 = (u_int16 )((int )mrtentry_grp->rs_timer - tmp___23);
#line 654
          mrtentry_grp->rs_timer = tmp___24;
#line 654
          if (tmp___24) {
#line 654
            tmp___25 = 0;
          } else {
#line 654
            tmp___25 = 1;
          }
#line 657
          if ((int )mrtentry_grp->timer < 5) {
#line 657
            tmp___26 = (int )mrtentry_grp->timer;
          } else {
#line 657
            tmp___26 = 5;
          }
#line 657
          tmp___27 = (u_int16 )((int )mrtentry_grp->timer - tmp___26);
#line 657
          mrtentry_grp->timer = tmp___27;
#line 657
          if (! tmp___27) {
#line 657
            if (mrtentry_grp->leaves == 0UL) {
              {
#line 659
              delete_mrtentry(mrtentry_grp);
              }
            }
          }
        }
        {
#line 666
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 666
          if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 666
            goto while_break___6;
          }
#line 669
          mrtentry_srcs_next = mrtentry_srcs->grpnext;
#line 672
          change_flag = 0;
#line 673
          vifi = (vifi_t )0;
          {
#line 673
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 673
            if (! ((int )vifi < (int )numvifs)) {
#line 673
              goto while_break___7;
            }
#line 674
            if (mrtentry_srcs->joined_oifs & (unsigned long )(1 << (int )vifi)) {
#line 676
              if ((int )vifi != (int )reg_vif_num) {
#line 677
                if ((int )*(mrtentry_srcs->vif_timers + vifi) < 5) {
#line 677
                  tmp___28 = (int )*(mrtentry_srcs->vif_timers + vifi);
                } else {
#line 677
                  tmp___28 = 5;
                }
#line 677
                tmp___29 = (u_int16 )((int )*(mrtentry_srcs->vif_timers + vifi) - tmp___28);
#line 677
                *(mrtentry_srcs->vif_timers + vifi) = tmp___29;
#line 677
                if (! tmp___29) {
#line 678
                  mrtentry_srcs->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 680
                  change_flag = 1;
                }
              }
            }
#line 673
            vifi = (vifi_t )((int )vifi + 1);
          }
          while_break___7: /* CIL Label */ ;
          }
#line 686
          update_src_iif = 0;
#line 687
          if ((int )ucast_flag == 1) {
#line 688
            if (! ((int )mrtentry_srcs->flags & 4)) {
              {
#line 690
              srcentry_save.incoming = (mrtentry_srcs->source)->incoming;
#line 692
              srcentry_save.upstream = (mrtentry_srcs->source)->upstream;
#line 694
              tmp___30 = set_incoming(mrtentry_srcs->source, 1);
              }
#line 694
              if (tmp___30 != 1) {
                {
#line 701
                delete_mrtentry(mrtentry_srcs);
                }
#line 702
                goto __Cont___1;
              } else
#line 706
              if ((int )srcentry_save.incoming != (int )mrtentry_srcs->incoming) {
#line 711
                update_src_iif = 1;
#line 712
                mrtentry_srcs->incoming = (mrtentry_srcs->source)->incoming;
#line 714
                mrtentry_srcs->upstream = (mrtentry_srcs->source)->upstream;
              } else
#line 706
              if ((unsigned long )srcentry_save.upstream != (unsigned long )mrtentry_srcs->upstream) {
#line 711
                update_src_iif = 1;
#line 712
                mrtentry_srcs->incoming = (mrtentry_srcs->source)->incoming;
#line 714
                mrtentry_srcs->upstream = (mrtentry_srcs->source)->upstream;
              }
            } else
#line 721
            if ((unsigned long )rpentry_save.upstream != (unsigned long )mrtentry_srcs->upstream) {
#line 725
              update_src_iif = 1;
#line 727
              mrtentry_srcs->incoming = rpentry_ptr->incoming;
#line 729
              mrtentry_srcs->upstream = rpentry_ptr->upstream;
            } else
#line 721
            if ((int )rpentry_save.incoming != (int )mrtentry_srcs->incoming) {
#line 725
              update_src_iif = 1;
#line 727
              mrtentry_srcs->incoming = rpentry_ptr->incoming;
#line 729
              mrtentry_srcs->upstream = rpentry_ptr->upstream;
            }
          }
#line 735
          if (change_flag == 1) {
            {
#line 737
            change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                              mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves, mrtentry_srcs->asserted_oifs,
                              (u_int16 )0);
            }
          } else
#line 735
          if (update_src_iif == 1) {
            {
#line 737
            change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                              mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves, mrtentry_srcs->asserted_oifs,
                              (u_int16 )0);
            }
          }
#line 744
          if ((int )rate_flag == 1) {
#line 745
            kernel_cache_ptr = mrtentry_srcs->kernel_cache;
            {
#line 745
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 745
              if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 745
                goto while_break___8;
              }
              {
#line 748
              kernel_cache_next = kernel_cache_ptr->next;
#line 749
              curr_bytecnt = kernel_cache_ptr->sg_count.bytecnt;
#line 750
              tmp___31 = k_get_sg_cnt(udp_socket, kernel_cache_ptr->source, kernel_cache_ptr->group,
                                      & kernel_cache_ptr->sg_count);
              }
#line 750
              if (tmp___31) {
                {
#line 761
                delete_single_kernel_cache(mrtentry_srcs, kernel_cache_ptr);
                }
#line 763
                goto __Cont___2;
              } else
#line 750
              if (curr_bytecnt == kernel_cache_ptr->sg_count.bytecnt) {
                {
#line 761
                delete_single_kernel_cache(mrtentry_srcs, kernel_cache_ptr);
                }
#line 763
                goto __Cont___2;
              }
#line 781
              did_switch_flag = 0;
#line 782
              if (curr_bytecnt + (u_long )pim_data_rate_bytes < kernel_cache_ptr->sg_count.bytecnt) {
#line 784
                if (! ((int )mrtentry_srcs->flags & 4)) {
#line 785
                  mrtentry_srcs->timer = (u_int16 )210;
#line 787
                  goto __Cont___2;
                }
#line 789
                if (mrtentry_srcs->leaves & mrtentry_srcs->oifs) {
                  {
#line 791
                  switch_shortest_path(kernel_cache_ptr->source, kernel_cache_ptr->group);
#line 792
                  did_switch_flag = 1;
                  }
                }
              }
#line 796
              if (did_switch_flag == 0) {
#line 796
                if (curr_bytecnt + (u_long )pim_reg_rate_bytes < kernel_cache_ptr->sg_count.bytecnt) {
#line 799
                  if (! ((int )mrtentry_srcs->flags & 4)) {
#line 800
                    mrtentry_srcs->timer = (u_int16 )210;
#line 802
                    goto __Cont___2;
                  }
#line 804
                  if ((int )mrtentry_srcs->incoming == (int )reg_vif_num) {
                    {
#line 805
                    switch_shortest_path(kernel_cache_ptr->source, kernel_cache_ptr->group);
                    }
                  }
                }
              }
              __Cont___2: /* CIL Label */ 
#line 745
              kernel_cache_ptr = kernel_cache_next;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
#line 817
          mrtentry_wide = (mrtentry_srcs->group)->grp_route;
#line 818
          if ((unsigned long )mrtentry_wide == (unsigned long )((mrtentry_t *)((void *)0))) {
#line 819
            mrtentry_wide = mrtentry_rp;
          }
#line 821
          dont_calc_action = 0;
#line 822
          if (rp_action != 0) {
#line 822
            goto _L___0;
          } else
#line 822
          if (grp_action != 0) {
            _L___0: /* CIL Label */ 
            {
#line 824
            src_action_rp = join_or_prune(mrtentry_srcs, rpentry_ptr->upstream);
#line 826
            src_action = src_action_rp;
#line 827
            dont_calc_action = 1;
            }
#line 828
            if (src_action_rp == 1) {
#line 829
              if (grp_action == 2) {
#line 831
                mrtentry_srcs->jp_timer = (u_int16 )0;
              } else
#line 829
              if (rp_action == 2) {
#line 831
                mrtentry_srcs->jp_timer = (u_int16 )0;
              }
            } else
#line 832
            if (src_action_rp == 2) {
#line 833
              if (grp_action == 1) {
#line 835
                mrtentry_srcs->jp_timer = (u_int16 )0;
              } else
#line 833
              if (rp_action == 1) {
#line 835
                mrtentry_srcs->jp_timer = (u_int16 )0;
              }
            }
          }
#line 840
          if ((int )mrtentry_srcs->jp_timer < 5) {
#line 840
            tmp___32 = (int )mrtentry_srcs->jp_timer;
          } else {
#line 840
            tmp___32 = 5;
          }
#line 840
          tmp___33 = (u_int16 )((int )mrtentry_srcs->jp_timer - tmp___32);
#line 840
          mrtentry_srcs->jp_timer = tmp___33;
#line 840
          if (! tmp___33) {
#line 841
            if (dont_calc_action != 1) {
              {
#line 842
              src_action = join_or_prune(mrtentry_srcs, mrtentry_srcs->upstream);
              }
            } else
#line 841
            if ((unsigned long )rpentry_ptr->upstream != (unsigned long )mrtentry_srcs->upstream) {
              {
#line 842
              src_action = join_or_prune(mrtentry_srcs, mrtentry_srcs->upstream);
              }
            }
#line 844
            if (src_action != 0) {
              {
#line 845
              add_jp_entry(mrtentry_srcs->upstream, (u_int16 )(3.5 * (double )60),
                           (mrtentry_srcs->group)->group, (u_int8 )32, (mrtentry_srcs->source)->address,
                           (u_int8 )32, (u_int16 )((int )mrtentry_srcs->flags & 4),
                           (u_int8 )src_action);
              }
            }
#line 853
            if ((unsigned long )mrtentry_wide != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 857
              if ((unsigned long )mrtentry_srcs->upstream != (unsigned long )mrtentry_wide->upstream) {
#line 858
                if (dont_calc_action != 1) {
                  {
#line 859
                  src_action_rp = join_or_prune(mrtentry_srcs, mrtentry_wide->upstream);
                  }
                }
#line 865
                if (src_action_rp == 2) {
                  {
#line 866
                  add_jp_entry(mrtentry_wide->upstream, (u_int16 )(3.5 * (double )60),
                               (mrtentry_srcs->group)->group, (u_int8 )32, (mrtentry_srcs->source)->address,
                               (u_int8 )32, (u_int16 )4, (u_int8 )src_action_rp);
                  }
                }
              }
            }
#line 877
            mrtentry_srcs->jp_timer = (u_int16 )60;
          }
#line 880
          if ((int )mrtentry_srcs->flags & 4096) {
#line 881
            if (mrtentry_srcs->assert_timer < 5U) {
#line 881
              tmp___34 = mrtentry_srcs->assert_timer;
            } else {
#line 881
              tmp___34 = (u_int )5;
            }
#line 881
            tmp___35 = mrtentry_srcs->assert_timer - tmp___34;
#line 881
            mrtentry_srcs->assert_timer = tmp___35;
#line 881
            if (! tmp___35) {
#line 883
              mrtentry_srcs->flags = (u_int16 )((int )mrtentry_srcs->flags & -4097);
            }
          }
#line 891
          if ((int )mrtentry_srcs->rs_timer > 0) {
#line 892
            if ((int )mrtentry_srcs->rs_timer < 5) {
#line 892
              tmp___36 = (int )mrtentry_srcs->rs_timer;
            } else {
#line 892
              tmp___36 = 5;
            }
#line 892
            tmp___37 = (u_int16 )((int )mrtentry_srcs->rs_timer - tmp___36);
#line 892
            mrtentry_srcs->rs_timer = tmp___37;
#line 892
            if (tmp___37) {
#line 909
              if ((int )mrtentry_srcs->rs_timer <= 5) {
                {
#line 920
                send_pim_null_register(mrtentry_srcs);
                }
              }
            } else {
              {
#line 894
              new_pruned_oifs = mrtentry_srcs->pruned_oifs;
#line 896
              new_pruned_oifs &= (unsigned long )(~ (1 << (int )reg_vif_num));
#line 897
              change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                                new_pruned_oifs, mrtentry_srcs->leaves, mrtentry_srcs->asserted_oifs,
                                (u_int16 )0);
              }
            }
          }
#line 926
          if ((int )mrtentry_srcs->timer < 5) {
#line 926
            tmp___38 = (int )mrtentry_srcs->timer;
          } else {
#line 926
            tmp___38 = 5;
          }
#line 926
          tmp___39 = (u_int16 )((int )mrtentry_srcs->timer - tmp___38);
#line 926
          mrtentry_srcs->timer = tmp___39;
#line 926
          if (! tmp___39) {
#line 927
            if (mrtentry_srcs->leaves == 0UL) {
              {
#line 928
              delete_mrtentry(mrtentry_srcs);
              }
#line 929
              goto __Cont___1;
            }
#line 938
            if ((unsigned long )(mrtentry_srcs->group)->grp_route != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 940
              if (! ((((mrtentry_srcs->group)->grp_route)->leaves & mrtentry_srcs->leaves) ^ mrtentry_srcs->leaves)) {
                {
#line 943
                delete_mrtentry(mrtentry_srcs);
                }
#line 944
                goto __Cont___1;
              }
            }
          }
          __Cont___1: /* CIL Label */ 
#line 666
          mrtentry_srcs = mrtentry_srcs_next;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 514
        grpentry_ptr = grpentry_ptr_next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 511
      rp_grp_entry_ptr = rp_grp_entry_ptr->rp_grp_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 319
    cand_rp_ptr = cand_rp_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 954
  vifi = (vifi_t )0;
#line 954
  v = & uvifs[0];
  {
#line 954
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 954
    if (! ((int )vifi < (int )numvifs)) {
#line 954
      goto while_break___9;
    }
#line 956
    pim_nbr_ptr = v->uv_pim_neighbors;
    {
#line 956
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 956
      if (! ((unsigned long )pim_nbr_ptr != (unsigned long )((pim_nbr_entry_t *)((void *)0)))) {
#line 956
        goto while_break___10;
      }
      {
#line 959
      pack_and_send_jp_message(pim_nbr_ptr);
#line 956
      pim_nbr_ptr = pim_nbr_ptr->next;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 954
    vifi = (vifi_t )((int )vifi + 1);
#line 954
    v ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 963
  if (debug) {
#line 963
    if (debug & 1048576UL) {
      {
#line 964
      dump_pim_mrt(stderr);
      }
    }
  }
#line 965
  return;
}
}
#line 973 "/home/wheatley/newnew/temp/pimd-2.1.8/timer.c"
void age_misc(void) 
{ 
  rp_grp_entry_t *rp_grp_entry_ptr ;
  rp_grp_entry_t *rp_grp_entry_next ;
  grp_mask_t *grp_mask_ptr ;
  grp_mask_t *grp_mask_next ;
  int tmp ;
  u_int16 tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 982
  grp_mask_ptr = grp_mask_list;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 982
    if (! ((unsigned long )grp_mask_ptr != (unsigned long )((grp_mask_t *)((void *)0)))) {
#line 982
      goto while_break;
    }
#line 988
    grp_mask_next = grp_mask_ptr->next;
#line 989
    rp_grp_entry_ptr = grp_mask_ptr->grp_rp_next;
    {
#line 989
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 989
      if (! ((unsigned long )rp_grp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 989
        goto while_break___0;
      }
#line 992
      rp_grp_entry_next = rp_grp_entry_ptr->grp_rp_next;
#line 993
      if ((int )rp_grp_entry_ptr->holdtime < 60000) {
#line 994
        if ((int )rp_grp_entry_ptr->holdtime < 5) {
#line 994
          tmp = (int )rp_grp_entry_ptr->holdtime;
        } else {
#line 994
          tmp = 5;
        }
#line 994
        tmp___0 = (u_int16 )((int )rp_grp_entry_ptr->holdtime - tmp);
#line 994
        rp_grp_entry_ptr->holdtime = tmp___0;
#line 994
        if (! tmp___0) {
          {
#line 995
          delete_rp_grp_entry(& cand_rp_list, & grp_mask_list, rp_grp_entry_ptr);
          }
        }
      }
#line 989
      rp_grp_entry_ptr = rp_grp_entry_next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 982
    grp_mask_ptr = grp_mask_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  if ((int )cand_rp_flag == 1) {
#line 1003
    if ((int )pim_cand_rp_adv_timer < 5) {
#line 1003
      tmp___1 = (int )pim_cand_rp_adv_timer;
    } else {
#line 1003
      tmp___1 = 5;
    }
#line 1003
    pim_cand_rp_adv_timer = (u_int16 )((int )pim_cand_rp_adv_timer - tmp___1);
#line 1003
    if (! pim_cand_rp_adv_timer) {
      {
#line 1004
      send_pim_cand_rp_adv();
#line 1005
      pim_cand_rp_adv_timer = my_cand_rp_adv_period;
      }
    }
  }
#line 1010
  if ((int )pim_bootstrap_timer < 5) {
#line 1010
    tmp___4 = (int )pim_bootstrap_timer;
  } else {
#line 1010
    tmp___4 = 5;
  }
#line 1010
  pim_bootstrap_timer = (u_int16 )((int )pim_bootstrap_timer - tmp___4);
#line 1010
  if (! pim_bootstrap_timer) {
#line 1011
    if ((int )cand_bsr_flag == 0) {
#line 1018
      curr_bsr_fragment_tag = (u_int16 )0;
#line 1019
      curr_bsr_priority = (u_int8 )0;
#line 1020
      curr_bsr_address = (u_int32 )0;
      {
#line 1021
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1021
        tmp___2 = htonl((uint32_t )(-1 << ((sizeof(curr_bsr_hash_mask) << 3) - 30UL)));
#line 1021
        curr_bsr_hash_mask = tmp___2;
        }
#line 1021
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1022
      pim_bootstrap_timer = (u_int16 )(2.5 * (double )30 + (double )10);
    } else
#line 1026
    if (curr_bsr_address == my_bsr_address) {
      {
#line 1027
      pim_bootstrap_timer = (u_int16 )30;
#line 1028
      send_pim_bootstrap();
      }
    } else {
      {
#line 1035
      pim_bootstrap_timer = bootstrap_initial_delay();
#line 1036
      tmp___3 = random();
#line 1036
      curr_bsr_fragment_tag = (u_int16 )tmp___3;
#line 1037
      curr_bsr_priority = my_bsr_priority;
#line 1038
      curr_bsr_address = my_bsr_address;
#line 1039
      curr_bsr_hash_mask = my_bsr_hash_mask;
      }
    }
  }
#line 1045
  if (debug) {
#line 1045
    if (debug & 655360UL) {
      {
#line 1046
      dump_rp_set(stderr);
      }
    }
  }
#line 1048
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 40 "/home/wheatley/newnew/temp/pimd-2.1.8/pidfile.c"
static char *pidfile_path  ;
#line 41 "/home/wheatley/newnew/temp/pimd-2.1.8/pidfile.c"
static pid_t pidfile_pid  ;
#line 43
static void pidfile_cleanup(void) ;
#line 45
extern char *__progname ;
#line 47 "/home/wheatley/newnew/temp/pimd-2.1.8/pidfile.c"
int pidfile(char const   *basename ) 
{ 
  int save_errno ;
  int result ;
  pid_t pid___0 ;
  FILE *f ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 54
  if ((unsigned long )basename == (unsigned long )((void *)0)) {
#line 55
    basename = (char const   *)__progname;
  }
#line 57
  if ((unsigned long )pidfile_path != (unsigned long )((void *)0)) {
    {
#line 58
    free((void *)pidfile_path);
#line 59
    pidfile_path = (char *)((void *)0);
    }
  }
  {
#line 63
  result = asprintf((char **/* __restrict  */)(& pidfile_path), (char const   */* __restrict  */)"%s%s.pid",
                    "/var/run/", basename);
  }
#line 64
  if (result == -1) {
#line 65
    return (-1);
  } else
#line 64
  if ((unsigned long )pidfile_path == (unsigned long )((void *)0)) {
#line 65
    return (-1);
  }
  {
#line 67
  f = fopen((char const   */* __restrict  */)pidfile_path, (char const   */* __restrict  */)"w");
  }
#line 67
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 68
    tmp = __errno_location();
#line 68
    save_errno = *tmp;
#line 69
    free((void *)pidfile_path);
#line 70
    pidfile_path = (char *)((void *)0);
#line 71
    tmp___0 = __errno_location();
#line 71
    *tmp___0 = save_errno;
    }
#line 72
    return (-1);
  }
  {
#line 75
  pid___0 = getpid();
#line 76
  tmp___3 = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld\n",
                    (long )pid___0);
  }
#line 76
  if (tmp___3 <= 0) {
#line 76
    goto _L;
  } else {
    {
#line 76
    tmp___4 = fclose(f);
    }
#line 76
    if (tmp___4 != 0) {
      _L: /* CIL Label */ 
      {
#line 77
      tmp___1 = __errno_location();
#line 77
      save_errno = *tmp___1;
#line 78
      unlink((char const   *)pidfile_path);
#line 79
      free((void *)pidfile_path);
#line 80
      pidfile_path = (char *)((void *)0);
#line 81
      tmp___2 = __errno_location();
#line 81
      *tmp___2 = save_errno;
      }
#line 82
      return (-1);
    }
  }
  {
#line 85
  pidfile_pid = pid___0;
#line 86
  tmp___7 = atexit(& pidfile_cleanup);
  }
#line 86
  if (tmp___7 < 0) {
    {
#line 87
    tmp___5 = __errno_location();
#line 87
    save_errno = *tmp___5;
#line 88
    unlink((char const   *)pidfile_path);
#line 89
    free((void *)pidfile_path);
#line 90
    pidfile_path = (char *)((void *)0);
#line 91
    pidfile_pid = 0;
#line 92
    tmp___6 = __errno_location();
#line 92
    *tmp___6 = save_errno;
    }
#line 93
    return (-1);
  }
#line 96
  return (0);
}
}
#line 99 "/home/wheatley/newnew/temp/pimd-2.1.8/pidfile.c"
static void pidfile_cleanup(void) 
{ 
  __pid_t tmp ;

  {
#line 103
  if ((unsigned long )pidfile_path != (unsigned long )((void *)0)) {
    {
#line 103
    tmp = getpid();
    }
#line 103
    if (pidfile_pid == tmp) {
      {
#line 104
      unlink((char const   *)pidfile_path);
      }
    }
  }
#line 105
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 286 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
struct cand_rp_adv_message_ cand_rp_adv_message  ;
#line 305 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
cand_rp_t *cand_rp_list  ;
#line 306 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
grp_mask_t *grp_mask_list  ;
#line 307 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
cand_rp_t *segmented_cand_rp_list  ;
#line 308 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
grp_mask_t *segmented_grp_mask_list  ;
#line 310 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int16 curr_bsr_fragment_tag  ;
#line 311 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int8 curr_bsr_priority  ;
#line 312 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 curr_bsr_address  ;
#line 313 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 curr_bsr_hash_mask  ;
#line 315 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int8 my_bsr_priority  ;
#line 316 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 my_bsr_address  ;
#line 317 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 my_bsr_hash_mask  ;
#line 319 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 my_cand_rp_address  ;
#line 320 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int8 my_cand_rp_priority  ;
#line 321 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int16 my_cand_rp_holdtime  ;
#line 322 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int16 my_cand_rp_adv_period  ;
#line 325 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int16 pim_bootstrap_timer  ;
#line 326 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 rp_my_ipv4_hashmask  ;
#line 327 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int16 pim_cand_rp_adv_timer  ;
#line 472
int inet_valid_host(u_int32 naddr ) ;
#line 508
void delete_grpentry(grpentry_t *grpentry_ptr ) ;
#line 562
void init_rp_and_bsr(void) ;
#line 564
rp_grp_entry_t *add_rp_grp_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                                 u_int32 rp_addr , u_int8 rp_priority , u_int16 rp_holdtime ,
                                 u_int32 group_addr , u_int32 group_mask , u_int32 bsr_hash_mask ,
                                 u_int16 fragment_tag ) ;
#line 575
void delete_grp_mask(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                     u_int32 group_addr , u_int32 group_mask ) ;
#line 577
void delete_rp(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list , u_int32 rp_addr ) ;
#line 579
void delete_rp_list(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ) ;
#line 580
rpentry_t *rp_match(u_int32 group ) ;
#line 581
rp_grp_entry_t *rp_grp_match(u_int32 group ) ;
#line 582
rpentry_t *rp_find(u_int32 rp_address ) ;
#line 583
int remap_grpentry(grpentry_t *grpentry_ptr ) ;
#line 584
int create_pim_bootstrap_message(char *send_buff ) ;
#line 585
int check_mrtentry_rp(mrtentry_t *mrtentry_ptr , u_int32 rp_addr ) ;
#line 55 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
u_int8 cand_bsr_flag  =    (u_int8 )0;
#line 64 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
u_int8 cand_rp_flag  =    (u_int8 )0;
#line 72
static cand_rp_t *add_cand_rp(cand_rp_t **used_cand_rp_list , u_int32 address ) ;
#line 73
static grp_mask_t *add_grp_mask(grp_mask_t **used_grp_mask_list , u_int32 group_addr ,
                                u_int32 group_mask , u_int32 hash_mask ) ;
#line 77
static void delete_grp_mask_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                                  grp_mask_t *grp_mask_delete ) ;
#line 80
static void delete_rp_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                            cand_rp_t *cand_rp_delete ) ;
#line 85 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
void init_rp_and_bsr(void) 
{ 
  uint32_t tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  long tmp___2 ;

  {
  {
#line 88
  delete_rp_list(& cand_rp_list, & grp_mask_list);
#line 89
  delete_rp_list(& segmented_cand_rp_list, & segmented_grp_mask_list);
  }
#line 91
  if ((int )cand_bsr_flag == 0) {
#line 96
    curr_bsr_fragment_tag = (u_int16 )0;
#line 97
    curr_bsr_priority = (u_int8 )0;
#line 98
    curr_bsr_address = (u_int32 )0;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 99
      tmp = htonl((uint32_t )(-1 << ((sizeof(curr_bsr_hash_mask) << 3) - 30UL)));
#line 99
      curr_bsr_hash_mask = tmp;
      }
#line 99
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 100
    pim_bootstrap_timer = (u_int16 )(2.5 * (double )30 + (double )10);
  } else {
    {
#line 102
    tmp___0 = random();
#line 102
    curr_bsr_fragment_tag = (u_int16 )tmp___0;
#line 103
    curr_bsr_priority = my_bsr_priority;
#line 104
    curr_bsr_address = my_bsr_address;
#line 105
    curr_bsr_hash_mask = my_bsr_hash_mask;
#line 106
    pim_bootstrap_timer = bootstrap_initial_delay();
    }
  }
#line 109
  if ((int )cand_rp_flag != 0) {
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 110
      tmp___1 = htonl((uint32_t )(-1 << ((sizeof(rp_my_ipv4_hashmask) << 3) - 30UL)));
#line 110
      rp_my_ipv4_hashmask = tmp___1;
      }
#line 110
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 112
    tmp___2 = random();
#line 112
    pim_cand_rp_adv_timer = (u_int16 )(tmp___2 % (long )my_cand_rp_adv_period);
    }
  }
#line 114
  return;
}
}
#line 117 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
u_int16 bootstrap_initial_delay(void) 
{ 
  long addr_delay ;
  long delay ;
  long log_mask ;
  int log_of_2 ;
  u_int8 best_priority ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 139
  if ((int )curr_bsr_priority < (int )my_bsr_priority) {
#line 139
    best_priority = my_bsr_priority;
  } else {
#line 139
    best_priority = curr_bsr_priority;
  }
#line 140
  if ((int )best_priority == (int )my_bsr_priority) {
    {
#line 141
    tmp = ntohl(curr_bsr_address);
#line 141
    tmp___0 = ntohl(my_bsr_address);
#line 141
    addr_delay = (long )(tmp - tmp___0);
#line 146
    log_mask = (long )(sizeof(addr_delay) << 3);
#line 147
    log_mask = (long )(1 << (log_mask - 1L));
#line 148
    log_of_2 = (int )((sizeof(addr_delay) << 3) - 1UL);
    }
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! log_of_2) {
#line 148
        goto while_break;
      }
#line 149
      if (addr_delay & log_mask) {
#line 150
        goto while_break;
      } else {
#line 152
        log_mask >>= 1;
      }
#line 148
      log_of_2 --;
    }
    while_break: /* CIL Label */ ;
    }
#line 154
    addr_delay = (long )(log_of_2 / 16);
  } else {
    {
#line 156
    tmp___1 = ntohl(my_bsr_address);
#line 156
    addr_delay = (long )(2U - tmp___1 / (uint32_t )(1 << 31));
    }
  }
#line 159
  delay = (long )((1 + (int )best_priority) - (int )my_bsr_priority);
#line 161
  log_mask = (long )(sizeof(delay) << 3);
#line 162
  log_mask = (long )(1 << (log_mask - 1L));
#line 163
  log_of_2 = (int )((sizeof(delay) << 3) - 1UL);
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! log_of_2) {
#line 163
      goto while_break___0;
    }
#line 164
    if (delay & log_mask) {
#line 165
      goto while_break___0;
    } else {
#line 167
      log_mask >>= 1;
    }
#line 163
    log_of_2 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 170
  delay = (long )(5 + 2 * log_of_2) + addr_delay;
#line 172
  return ((u_int16 )delay);
}
}
#line 176 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
static cand_rp_t *add_cand_rp(cand_rp_t **used_cand_rp_list , u_int32 address ) 
{ 
  cand_rp_t *prev ;
  cand_rp_t *next ;
  cand_rp_t *ptr ;
  rpentry_t *entry ;
  u_int32 addr_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  vifi_t tmp___3 ;

  {
  {
#line 178
  prev = (cand_rp_t *)((void *)0);
#line 182
  tmp = ntohl(address);
#line 182
  addr_h = tmp;
#line 185
  next = *used_cand_rp_list;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! next) {
#line 185
      goto while_break;
    }
    {
#line 186
    tmp___0 = ntohl((next->rpentry)->address);
    }
#line 186
    if (tmp___0 > addr_h) {
#line 187
      goto __Cont;
    }
#line 189
    if ((next->rpentry)->address == address) {
#line 190
      return (next);
    } else {
#line 192
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 185
    prev = next;
#line 185
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  tmp___1 = calloc((size_t )1, sizeof(cand_rp_t ));
#line 196
  ptr = (cand_rp_t *)tmp___1;
  }
#line 197
  if (! ptr) {
    {
#line 198
    logit(3, 0, "Ran out of memory in add_cand_rp()");
    }
  }
#line 199
  ptr->rp_grp_next = (struct rp_grp_entry *)((void *)0);
#line 200
  ptr->next = next;
#line 201
  ptr->prev = prev;
#line 202
  if (next) {
#line 203
    next->prev = ptr;
  }
#line 204
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 205
    *used_cand_rp_list = ptr;
  } else {
#line 207
    prev->next = ptr;
  }
  {
#line 209
  tmp___2 = calloc((size_t )1, sizeof(rpentry_t ));
#line 209
  entry = (rpentry_t *)tmp___2;
  }
#line 210
  if (! entry) {
    {
#line 211
    logit(3, 0, "Ran out of memory in add_cand_rp()");
    }
  }
  {
#line 212
  ptr->rpentry = entry;
#line 213
  entry->next = (struct srcentry *)((void *)0);
#line 214
  entry->prev = (struct srcentry *)((void *)0);
#line 215
  entry->address = address;
#line 216
  entry->mrtlink = (struct mrtentry *)((void *)0);
#line 217
  entry->incoming = (vifi_t )32;
#line 218
  entry->upstream = (struct pim_nbr_entry *)((void *)0);
#line 220
  entry->metric = (u_int32 )(~ 0);
#line 221
  entry->preference = (u_int32 )(~ 0);
#line 222
  entry->timer = (u_int16 )0;
#line 223
  entry->cand_rp = ptr;
#line 228
  tmp___3 = local_address(entry->address);
  }
#line 228
  if ((int )tmp___3 == 32) {
    {
#line 230
    set_incoming(entry, 2);
    }
  } else {
#line 233
    entry->incoming = reg_vif_num;
  }
#line 235
  return (ptr);
}
}
#line 239 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
static grp_mask_t *add_grp_mask(grp_mask_t **used_grp_mask_list , u_int32 group_addr ,
                                u_int32 group_mask , u_int32 hash_mask ) 
{ 
  grp_mask_t *prev ;
  grp_mask_t *next ;
  grp_mask_t *ptr ;
  u_int32 prefix_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 241
  prev = (grp_mask_t *)((void *)0);
#line 244
  tmp = ntohl(group_addr & group_mask);
#line 244
  prefix_h = tmp;
#line 247
  next = *used_grp_mask_list;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! next) {
#line 247
      goto while_break;
    }
    {
#line 248
    tmp___0 = ntohl(next->group_addr & next->group_mask);
    }
#line 248
    if (tmp___0 > prefix_h) {
#line 249
      goto __Cont;
    }
#line 252
    if ((next->group_addr & next->group_mask) == (group_addr & group_mask)) {
      {
#line 253
      tmp___1 = ntohl(next->group_mask);
#line 253
      tmp___2 = ntohl(group_mask);
      }
#line 253
      if (tmp___1 > tmp___2) {
#line 254
        goto __Cont;
      } else
#line 255
      if (next->group_mask == group_mask) {
#line 256
        return (next);
      } else {
#line 258
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 247
    prev = next;
#line 247
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 262
  tmp___3 = calloc((size_t )1, sizeof(grp_mask_t ));
#line 262
  ptr = (grp_mask_t *)tmp___3;
  }
#line 263
  if (! ptr) {
    {
#line 264
    logit(3, 0, "Ran out of memory in add_grp_mask()");
    }
  }
#line 266
  ptr->grp_rp_next = (rp_grp_entry_t *)((void *)0);
#line 267
  ptr->next = next;
#line 268
  ptr->prev = prev;
#line 269
  if (next) {
#line 270
    next->prev = ptr;
  }
#line 271
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 272
    *used_grp_mask_list = ptr;
  } else {
#line 274
    prev->next = ptr;
  }
#line 276
  ptr->group_addr = group_addr;
#line 277
  ptr->group_mask = group_mask;
#line 278
  ptr->hash_mask = hash_mask;
#line 279
  ptr->group_rp_number = (u_int8 )0;
#line 280
  ptr->fragment_tag = (u_int16 )0;
#line 282
  return (ptr);
}
}
#line 290 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
rp_grp_entry_t *add_rp_grp_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                                 u_int32 rp_addr , u_int8 rp_priority , u_int16 rp_holdtime ,
                                 u_int32 group_addr , u_int32 group_mask , u_int32 bsr_hash_mask ,
                                 u_int16 fragment_tag ) 
{ 
  cand_rp_t *cand_rp_ptr ;
  grp_mask_t *mask_ptr ;
  rpentry_t *rpentry_ptr ;
  rp_grp_entry_t *entry_next ;
  rp_grp_entry_t *entry_new ;
  rp_grp_entry_t *entry_prev ;
  grpentry_t *grpentry_ptr_prev ;
  grpentry_t *grpentry_ptr_next ;
  u_int32 rp_addr_h ;
  u_int8 old_highest_priority ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 305
  entry_prev = (rp_grp_entry_t *)((void *)0);
#line 309
  old_highest_priority = (u_int8 )(~ 0);
#line 312
  tmp = inet_valid_host(rp_addr);
  }
#line 312
  if (! tmp) {
#line 313
    return ((rp_grp_entry_t *)((void *)0));
  }
  {
#line 314
  tmp___0 = ntohl(group_addr);
  }
#line 314
  if (! ((tmp___0 & 4026531840U) == 3758096384U)) {
#line 315
    return ((rp_grp_entry_t *)((void *)0));
  }
  {
#line 317
  mask_ptr = add_grp_mask(used_grp_mask_list, group_addr, group_mask, bsr_hash_mask);
  }
#line 318
  if ((unsigned long )mask_ptr == (unsigned long )((void *)0)) {
#line 319
    return ((rp_grp_entry_t *)((void *)0));
  }
  {
#line 336
  cand_rp_ptr = add_cand_rp(used_cand_rp_list, rp_addr);
  }
#line 337
  if ((unsigned long )cand_rp_ptr == (unsigned long )((void *)0)) {
#line 338
    if ((unsigned long )mask_ptr->grp_rp_next == (unsigned long )((void *)0)) {
      {
#line 339
      delete_grp_mask(used_cand_rp_list, used_grp_mask_list, group_addr, group_mask);
      }
    }
#line 341
    return ((rp_grp_entry_t *)((void *)0));
  }
  {
#line 344
  rpentry_ptr = cand_rp_ptr->rpentry;
#line 345
  rpentry_ptr->timer = rp_holdtime;
#line 346
  rp_addr_h = ntohl(rp_addr);
#line 347
  mask_ptr->fragment_tag = fragment_tag;
#line 349
  entry_prev = (rp_grp_entry_t *)((void *)0);
#line 350
  entry_next = mask_ptr->grp_rp_next;
  }
#line 352
  if ((unsigned long )entry_next != (unsigned long )((void *)0)) {
#line 353
    old_highest_priority = entry_next->priority;
  }
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! entry_next) {
#line 354
      goto while_break;
    }
#line 359
    if ((int )entry_next->priority < (int )rp_priority) {
#line 360
      goto __Cont;
    }
#line 361
    if ((int )entry_next->priority > (int )rp_priority) {
#line 362
      goto while_break;
    }
    {
#line 371
    tmp___1 = ntohl(((entry_next->rp)->rpentry)->address);
    }
#line 371
    if (tmp___1 > rp_addr_h) {
#line 372
      goto __Cont;
    }
    {
#line 373
    tmp___2 = ntohl(((entry_next->rp)->rpentry)->address);
    }
#line 373
    if (tmp___2 < rp_addr_h) {
#line 374
      goto while_break;
    }
#line 381
    entry_next->holdtime = rp_holdtime;
#line 382
    entry_next->fragment_tag = fragment_tag;
#line 384
    return (entry_next);
    __Cont: /* CIL Label */ 
#line 354
    entry_prev = entry_next;
#line 354
    entry_next = entry_next->grp_rp_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 388
  tmp___3 = calloc((size_t )1, sizeof(rp_grp_entry_t ));
#line 388
  entry_new = (rp_grp_entry_t *)tmp___3;
  }
#line 389
  if (! entry_new) {
    {
#line 390
    logit(3, 0, "Ran out of memory in add_rp_grp_entry()");
    }
  }
#line 391
  entry_new->grp_rp_next = entry_next;
#line 392
  entry_new->grp_rp_prev = entry_prev;
#line 393
  if (entry_next) {
#line 394
    entry_next->grp_rp_prev = entry_new;
  }
#line 395
  if ((unsigned long )entry_prev == (unsigned long )((void *)0)) {
#line 396
    mask_ptr->grp_rp_next = entry_new;
  } else {
#line 398
    entry_prev->grp_rp_next = entry_new;
  }
#line 404
  entry_new->rp_grp_next = cand_rp_ptr->rp_grp_next;
#line 405
  if (cand_rp_ptr->rp_grp_next) {
#line 406
    (cand_rp_ptr->rp_grp_next)->rp_grp_prev = entry_new;
  }
#line 407
  entry_new->rp_grp_prev = (struct rp_grp_entry *)((void *)0);
#line 408
  cand_rp_ptr->rp_grp_next = entry_new;
#line 410
  entry_new->holdtime = rp_holdtime;
#line 411
  entry_new->fragment_tag = fragment_tag;
#line 412
  entry_new->priority = rp_priority;
#line 413
  entry_new->group = mask_ptr;
#line 414
  entry_new->rp = cand_rp_ptr;
#line 415
  entry_new->grplink = (struct grpentry *)((void *)0);
#line 417
  mask_ptr->group_rp_number = (u_int8 )((int )mask_ptr->group_rp_number + 1);
#line 419
  if ((int )(mask_ptr->grp_rp_next)->priority == (int )rp_priority) {
#line 422
    entry_next = mask_ptr->grp_rp_next;
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 422
      if (! entry_next) {
#line 422
        goto while_break___0;
      }
#line 423
      if ((int )entry_next->priority > (int )old_highest_priority) {
#line 424
        goto while_break___0;
      }
#line 426
      grpentry_ptr_prev = entry_next->grplink;
      {
#line 426
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 426
        if (! grpentry_ptr_prev) {
#line 426
          goto while_break___1;
        }
        {
#line 427
        grpentry_ptr_next = grpentry_ptr_prev->rpnext;
#line 428
        remap_grpentry(grpentry_ptr_prev);
#line 429
        grpentry_ptr_prev = grpentry_ptr_next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 422
      entry_next = entry_next->grp_rp_next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 434
  return (entry_new);
}
}
#line 438 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
void delete_rp_grp_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                         rp_grp_entry_t *entry ) 
{ 
  grpentry_t *ptr ;
  grpentry_t *ptr_next ;

  {
#line 443
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 444
    return;
  }
#line 445
  (entry->group)->group_rp_number = (u_int8 )((int )(entry->group)->group_rp_number - 1);
#line 448
  if (entry->rp_grp_prev) {
#line 449
    (entry->rp_grp_prev)->rp_grp_next = entry->rp_grp_next;
  } else {
#line 451
    (entry->rp)->rp_grp_next = entry->rp_grp_next;
  }
#line 452
  if (entry->rp_grp_next) {
#line 453
    (entry->rp_grp_next)->rp_grp_prev = entry->rp_grp_prev;
  }
#line 455
  if (entry->grp_rp_prev) {
#line 456
    (entry->grp_rp_prev)->grp_rp_next = entry->grp_rp_next;
  } else {
#line 458
    (entry->group)->grp_rp_next = entry->grp_rp_next;
  }
#line 460
  if (entry->grp_rp_next) {
#line 461
    (entry->grp_rp_next)->grp_rp_prev = entry->grp_rp_prev;
  }
#line 464
  if ((unsigned long )(entry->group)->grp_rp_next == (unsigned long )((void *)0)) {
    {
#line 465
    delete_grp_mask_entry(used_cand_rp_list, used_grp_mask_list, entry->group);
    }
  }
#line 467
  if ((unsigned long )(entry->rp)->rp_grp_next == (unsigned long )((void *)0)) {
    {
#line 468
    delete_rp_entry(used_cand_rp_list, used_grp_mask_list, entry->rp);
    }
  }
#line 471
  ptr = entry->grplink;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! ptr) {
#line 471
      goto while_break;
    }
    {
#line 472
    ptr_next = ptr->rpnext;
#line 473
    remap_grpentry(ptr);
#line 471
    ptr = ptr_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 476
  free((void *)((char *)entry));
  }
#line 477
  return;
}
}
#line 483 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
void delete_rp_list(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ) 
{ 
  cand_rp_t *cand_ptr ;
  cand_rp_t *cand_next ;
  rp_grp_entry_t *entry_ptr ;
  rp_grp_entry_t *entry_next ;
  grp_mask_t *mask_ptr ;
  grp_mask_t *mask_next ;
  grpentry_t *gentry_ptr ;
  grpentry_t *gentry_ptr_next ;
  kernel_cache_t *prev ;
  kernel_cache_t *next ;

  {
#line 490
  cand_ptr = *used_cand_rp_list;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! cand_ptr) {
#line 490
      goto while_break;
    }
#line 491
    cand_next = cand_ptr->next;
#line 494
    if ((cand_ptr->rpentry)->mrtlink) {
#line 495
      if ((int )((cand_ptr->rpentry)->mrtlink)->flags & 512) {
        {
#line 496
        delete_mrtentry_all_kernel_cache((cand_ptr->rpentry)->mrtlink);
        }
      }
      {
#line 497
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 497
        free((void *)((char *)((cand_ptr->rpentry)->mrtlink)->vif_timers));
#line 497
        free((void *)((char *)((cand_ptr->rpentry)->mrtlink)->vif_deletion_delay));
#line 497
        next = ((cand_ptr->rpentry)->mrtlink)->kernel_cache;
        }
        {
#line 497
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 497
          if (! ((unsigned long )next != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 497
            goto while_break___1;
          }
          {
#line 497
          prev = next;
#line 497
          next = next->next;
#line 497
          free((void *)prev);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 497
        free((void *)((char *)((cand_ptr->rpentry)->mrtlink)->kernel_cache));
#line 497
        free((void *)((char *)(cand_ptr->rpentry)->mrtlink));
        }
#line 497
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 499
    free((void *)cand_ptr->rpentry);
#line 502
    entry_ptr = cand_ptr->rp_grp_next;
    }
    {
#line 502
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 502
      if (! entry_ptr) {
#line 502
        goto while_break___2;
      }
#line 503
      entry_next = entry_ptr->rp_grp_next;
#line 506
      gentry_ptr = entry_ptr->grplink;
      {
#line 506
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 506
        if (! gentry_ptr) {
#line 506
          goto while_break___3;
        }
#line 507
        gentry_ptr_next = gentry_ptr->rpnext;
#line 508
        gentry_ptr->rpnext = (struct grpentry *)((void *)0);
#line 509
        gentry_ptr->rpprev = (struct grpentry *)((void *)0);
#line 510
        gentry_ptr->active_rp_grp = (rp_grp_entry_t *)((void *)0);
#line 511
        gentry_ptr->rpaddr = (u_int32 )0;
#line 506
        gentry_ptr = gentry_ptr_next;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 514
      free((void *)entry_ptr);
#line 502
      entry_ptr = entry_next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 517
    free((void *)cand_ptr);
#line 518
    cand_ptr = cand_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  *used_cand_rp_list = (cand_rp_t *)((void *)0);
#line 522
  mask_ptr = *used_grp_mask_list;
  {
#line 522
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 522
    if (! mask_ptr) {
#line 522
      goto while_break___4;
    }
    {
#line 523
    mask_next = mask_ptr->next;
#line 524
    free((void *)mask_ptr);
#line 522
    mask_ptr = mask_next;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 526
  *used_grp_mask_list = (grp_mask_t *)((void *)0);
#line 527
  return;
}
}
#line 530 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
void delete_grp_mask(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                     u_int32 group_addr , u_int32 group_mask ) 
{ 
  grp_mask_t *ptr ;
  u_int32 prefix_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 533
  tmp = ntohl(group_addr & group_mask);
#line 533
  prefix_h = tmp;
#line 535
  ptr = *used_grp_mask_list;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! ptr) {
#line 535
      goto while_break;
    }
    {
#line 536
    tmp___0 = ntohl(ptr->group_addr & ptr->group_mask);
    }
#line 536
    if (tmp___0 > prefix_h) {
#line 537
      goto __Cont;
    }
#line 539
    if (ptr->group_addr == group_addr) {
      {
#line 540
      tmp___1 = ntohl(ptr->group_mask);
#line 540
      tmp___2 = ntohl(group_mask);
      }
#line 540
      if (tmp___1 > tmp___2) {
#line 541
        goto __Cont;
      } else
#line 542
      if (ptr->group_mask == group_mask) {
#line 543
        goto while_break;
      } else {
#line 545
        return;
      }
    }
    __Cont: /* CIL Label */ 
#line 535
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  if ((unsigned long )ptr == (unsigned long )((grp_mask_t *)((void *)0))) {
#line 550
    return;
  }
  {
#line 552
  delete_grp_mask_entry(used_cand_rp_list, used_grp_mask_list, ptr);
  }
#line 553
  return;
}
}
#line 555 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
static void delete_grp_mask_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                                  grp_mask_t *grp_mask_delete ) 
{ 
  grpentry_t *grp_ptr ;
  grpentry_t *grp_ptr_next ;
  rp_grp_entry_t *entry_ptr ;
  rp_grp_entry_t *entry_next ;

  {
#line 561
  if ((unsigned long )grp_mask_delete == (unsigned long )((void *)0)) {
#line 562
    return;
  }
#line 565
  if (grp_mask_delete->prev) {
#line 566
    (grp_mask_delete->prev)->next = grp_mask_delete->next;
  } else {
#line 568
    *used_grp_mask_list = grp_mask_delete->next;
  }
#line 570
  if (grp_mask_delete->next) {
#line 571
    (grp_mask_delete->next)->prev = grp_mask_delete->prev;
  }
#line 574
  entry_ptr = grp_mask_delete->grp_rp_next;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! entry_ptr) {
#line 574
      goto while_break;
    }
#line 575
    entry_next = entry_ptr->grp_rp_next;
#line 578
    grp_ptr = entry_ptr->grplink;
    {
#line 578
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 578
      if (! grp_ptr) {
#line 578
        goto while_break___0;
      }
      {
#line 579
      grp_ptr_next = grp_ptr->rpnext;
#line 580
      remap_grpentry(grp_ptr);
#line 578
      grp_ptr = grp_ptr_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 583
    if ((unsigned long )entry_ptr->rp_grp_prev != (unsigned long )((rp_grp_entry_t *)((void *)0))) {
#line 584
      (entry_ptr->rp_grp_prev)->rp_grp_next = entry_ptr->rp_grp_next;
    } else {
#line 586
      (entry_ptr->rp)->rp_grp_next = entry_ptr->rp_grp_next;
    }
#line 588
    if ((unsigned long )entry_ptr->rp_grp_next != (unsigned long )((void *)0)) {
#line 589
      (entry_ptr->rp_grp_next)->rp_grp_prev = entry_ptr->rp_grp_prev;
    }
#line 592
    if ((unsigned long )(entry_ptr->rp)->rp_grp_next == (unsigned long )((void *)0)) {
      {
#line 593
      delete_rp_entry(used_cand_rp_list, used_grp_mask_list, entry_ptr->rp);
      }
    }
    {
#line 595
    free((void *)entry_ptr);
#line 574
    entry_ptr = entry_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 598
  free((void *)grp_mask_delete);
  }
#line 599
  return;
}
}
#line 604 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
void delete_rp(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list , u_int32 rp_addr ) 
{ 
  cand_rp_t *ptr ;
  u_int32 rp_addr_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 607
  tmp = ntohl(rp_addr);
#line 607
  rp_addr_h = tmp;
#line 609
  ptr = *used_cand_rp_list;
  }
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 609
      goto while_break;
    }
    {
#line 610
    tmp___0 = ntohl((ptr->rpentry)->address);
    }
#line 610
    if (tmp___0 > rp_addr_h) {
#line 611
      goto __Cont;
    }
#line 613
    if ((ptr->rpentry)->address == rp_addr) {
#line 614
      goto while_break;
    } else {
#line 616
      return;
    }
    __Cont: /* CIL Label */ 
#line 609
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 620
    return;
  }
  {
#line 622
  delete_rp_entry(used_cand_rp_list, used_grp_mask_list, ptr);
  }
#line 623
  return;
}
}
#line 626 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
static void delete_rp_entry(cand_rp_t **used_cand_rp_list , grp_mask_t **used_grp_mask_list ,
                            cand_rp_t *cand_rp_delete ) 
{ 
  rp_grp_entry_t *entry_ptr ;
  rp_grp_entry_t *entry_next ;
  grpentry_t *grp_ptr ;
  grpentry_t *grp_ptr_next ;
  kernel_cache_t *prev ;
  kernel_cache_t *next ;

  {
#line 633
  if ((unsigned long )cand_rp_delete == (unsigned long )((void *)0)) {
#line 634
    return;
  }
#line 637
  if (cand_rp_delete->prev) {
#line 638
    (cand_rp_delete->prev)->next = cand_rp_delete->next;
  } else {
#line 640
    *used_cand_rp_list = cand_rp_delete->next;
  }
#line 642
  if (cand_rp_delete->next) {
#line 643
    (cand_rp_delete->next)->prev = cand_rp_delete->prev;
  }
#line 645
  if ((cand_rp_delete->rpentry)->mrtlink) {
#line 646
    if ((int )((cand_rp_delete->rpentry)->mrtlink)->flags & 512) {
      {
#line 647
      delete_mrtentry_all_kernel_cache((cand_rp_delete->rpentry)->mrtlink);
      }
    }
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 649
      free((void *)((char *)((cand_rp_delete->rpentry)->mrtlink)->vif_timers));
#line 649
      free((void *)((char *)((cand_rp_delete->rpentry)->mrtlink)->vif_deletion_delay));
#line 649
      next = ((cand_rp_delete->rpentry)->mrtlink)->kernel_cache;
      }
      {
#line 649
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 649
        if (! ((unsigned long )next != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 649
          goto while_break___0;
        }
        {
#line 649
        prev = next;
#line 649
        next = next->next;
#line 649
        free((void *)prev);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 649
      free((void *)((char *)((cand_rp_delete->rpentry)->mrtlink)->kernel_cache));
#line 649
      free((void *)((char *)(cand_rp_delete->rpentry)->mrtlink));
      }
#line 649
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 651
  free((void *)((char *)cand_rp_delete->rpentry));
#line 654
  entry_ptr = cand_rp_delete->rp_grp_next;
  }
  {
#line 654
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 654
    if (! entry_ptr) {
#line 654
      goto while_break___1;
    }
#line 655
    entry_next = entry_ptr->rp_grp_next;
#line 656
    (entry_ptr->group)->group_rp_number = (u_int8 )((int )(entry_ptr->group)->group_rp_number - 1);
#line 659
    if (entry_ptr->grp_rp_prev) {
#line 660
      (entry_ptr->grp_rp_prev)->grp_rp_next = entry_ptr->grp_rp_next;
    } else {
#line 662
      (entry_ptr->group)->grp_rp_next = entry_ptr->grp_rp_next;
    }
#line 664
    if (entry_ptr->grp_rp_next) {
#line 665
      (entry_ptr->grp_rp_next)->grp_rp_prev = entry_ptr->grp_rp_prev;
    }
#line 667
    if ((unsigned long )entry_ptr->grp_rp_next == (unsigned long )((void *)0)) {
      {
#line 668
      delete_grp_mask_entry(used_cand_rp_list, used_grp_mask_list, entry_ptr->group);
      }
    }
#line 671
    grp_ptr = entry_ptr->grplink;
    {
#line 671
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 671
      if (! grp_ptr) {
#line 671
        goto while_break___2;
      }
      {
#line 672
      grp_ptr_next = grp_ptr->rpnext;
#line 673
      remap_grpentry(grp_ptr);
#line 671
      grp_ptr = grp_ptr_next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 676
    free((void *)entry_ptr);
#line 654
    entry_ptr = entry_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 679
  free((void *)((char *)cand_rp_delete));
  }
#line 680
  return;
}
}
#line 689 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
int remap_grpentry(grpentry_t *grpentry_ptr ) 
{ 
  rpentry_t *rpentry_ptr ;
  rp_grp_entry_t *entry_ptr ;
  mrtentry_t *grp_route ;
  mrtentry_t *mrtentry_ptr ;

  {
#line 696
  if ((unsigned long )grpentry_ptr == (unsigned long )((void *)0)) {
#line 697
    return (0);
  }
#line 700
  if (grpentry_ptr->rpprev) {
#line 701
    (grpentry_ptr->rpprev)->rpnext = grpentry_ptr->rpnext;
  } else
#line 703
  if (grpentry_ptr->active_rp_grp) {
#line 704
    (grpentry_ptr->active_rp_grp)->grplink = grpentry_ptr->rpnext;
  }
#line 707
  if (grpentry_ptr->rpnext) {
#line 708
    (grpentry_ptr->rpnext)->rpprev = grpentry_ptr->rpprev;
  }
  {
#line 710
  entry_ptr = rp_grp_match(grpentry_ptr->group);
  }
#line 711
  if ((unsigned long )entry_ptr == (unsigned long )((void *)0)) {
    {
#line 713
    delete_grpentry(grpentry_ptr);
    }
#line 714
    return (0);
  }
#line 716
  rpentry_ptr = (entry_ptr->rp)->rpentry;
#line 719
  grpentry_ptr->rpaddr = rpentry_ptr->address;
#line 720
  grpentry_ptr->active_rp_grp = entry_ptr;
#line 721
  grpentry_ptr->rpnext = entry_ptr->grplink;
#line 722
  if (grpentry_ptr->rpnext) {
#line 723
    (grpentry_ptr->rpnext)->rpprev = grpentry_ptr;
  }
#line 724
  grpentry_ptr->rpprev = (struct grpentry *)((void *)0);
#line 725
  entry_ptr->grplink = grpentry_ptr;
#line 727
  grp_route = grpentry_ptr->grp_route;
#line 728
  if (grp_route) {
    {
#line 729
    grp_route->upstream = rpentry_ptr->upstream;
#line 730
    grp_route->metric = rpentry_ptr->metric;
#line 731
    grp_route->preference = rpentry_ptr->preference;
#line 732
    change_interfaces(grp_route, rpentry_ptr->incoming, grp_route->joined_oifs, grp_route->pruned_oifs,
                      grp_route->leaves, grp_route->asserted_oifs, (u_int16 )2);
    }
  }
#line 739
  mrtentry_ptr = grpentry_ptr->mrtlink;
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 739
    if (! mrtentry_ptr) {
#line 739
      goto while_break;
    }
#line 740
    if (! ((int )mrtentry_ptr->flags & 4)) {
#line 741
      goto __Cont;
    }
    {
#line 743
    mrtentry_ptr->upstream = rpentry_ptr->upstream;
#line 744
    mrtentry_ptr->metric = rpentry_ptr->metric;
#line 745
    mrtentry_ptr->preference = rpentry_ptr->preference;
#line 746
    change_interfaces(mrtentry_ptr, rpentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                      mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                      (u_int16 )2);
    }
    __Cont: /* CIL Label */ 
#line 739
    mrtentry_ptr = mrtentry_ptr->grpnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 753
  return (1);
}
}
#line 757 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
rpentry_t *rp_match(u_int32 group ) 
{ 
  rp_grp_entry_t *ptr ;

  {
  {
#line 761
  ptr = rp_grp_match(group);
  }
#line 762
  if (ptr) {
#line 763
    return ((ptr->rp)->rpentry);
  }
#line 765
  return ((rpentry_t *)((void *)0));
}
}
#line 768 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
rp_grp_entry_t *rp_grp_match(u_int32 group ) 
{ 
  grp_mask_t *mask_ptr ;
  rp_grp_entry_t *entry_ptr ;
  rp_grp_entry_t *best_entry ;
  u_int8 best_priority ;
  u_int32 best_hash_value ;
  u_int32 best_address_h ;
  u_int32 curr_hash_value ;
  u_int32 curr_address_h ;
  u_int32 group_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 772
  best_entry = (rp_grp_entry_t *)((void *)0);
#line 773
  best_priority = (u_int8 )(~ 0);
#line 774
  best_hash_value = (u_int32 )0;
#line 775
  best_address_h = (u_int32 )0;
#line 776
  curr_hash_value = (u_int32 )0;
#line 777
  curr_address_h = (u_int32 )0;
#line 778
  tmp = ntohl(group);
#line 778
  group_h = tmp;
  }
#line 780
  if ((unsigned long )grp_mask_list == (unsigned long )((void *)0)) {
#line 781
    return ((rp_grp_entry_t *)((void *)0));
  }
#line 783
  mask_ptr = grp_mask_list;
  {
#line 783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 783
    if (! mask_ptr) {
#line 783
      goto while_break;
    }
    {
#line 785
    tmp___0 = ntohl(mask_ptr->group_mask);
#line 785
    tmp___1 = ntohl(mask_ptr->group_mask & mask_ptr->group_addr);
    }
#line 785
    if ((group_h & tmp___0) != tmp___1) {
#line 787
      goto __Cont;
    }
#line 789
    entry_ptr = mask_ptr->grp_rp_next;
    {
#line 789
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 789
      if (! entry_ptr) {
#line 789
        goto while_break___0;
      }
#line 790
      if ((int )best_priority < (int )entry_ptr->priority) {
#line 791
        goto while_break___0;
      }
      {
#line 793
      curr_hash_value = (1103515245U * ((1103515245U * (group_h & mask_ptr->hash_mask) + 12345U) ^ curr_address_h) + 12345U) % 2147483648U;
#line 794
      curr_address_h = ntohl(((entry_ptr->rp)->rpentry)->address);
      }
#line 796
      if ((int )best_priority == (int )entry_ptr->priority) {
#line 798
        if (curr_hash_value < best_hash_value) {
#line 799
          goto __Cont___0;
        }
#line 801
        if (curr_hash_value == best_hash_value) {
#line 802
          if (curr_address_h < best_address_h) {
#line 803
            goto __Cont___0;
          }
        }
      }
#line 808
      best_entry = entry_ptr;
#line 809
      best_priority = best_entry->priority;
#line 810
      best_address_h = curr_address_h;
#line 811
      best_hash_value = curr_hash_value;
      __Cont___0: /* CIL Label */ 
#line 789
      entry_ptr = entry_ptr->grp_rp_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 783
    mask_ptr = mask_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 815
  return (best_entry);
}
}
#line 819 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
rpentry_t *rp_find(u_int32 rp_address ) 
{ 
  cand_rp_t *cand_rp_ptr ;
  u_int32 address_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 822
  tmp = ntohl(rp_address);
#line 822
  address_h = tmp;
#line 824
  cand_rp_ptr = cand_rp_list;
  }
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! ((unsigned long )cand_rp_ptr != (unsigned long )((void *)0))) {
#line 824
      goto while_break;
    }
    {
#line 825
    tmp___0 = ntohl((cand_rp_ptr->rpentry)->address);
    }
#line 825
    if (tmp___0 > address_h) {
#line 826
      goto __Cont;
    }
#line 828
    if ((cand_rp_ptr->rpentry)->address == rp_address) {
#line 829
      return (cand_rp_ptr->rpentry);
    }
#line 831
    return ((rpentry_t *)((void *)0));
    __Cont: /* CIL Label */ 
#line 824
    cand_rp_ptr = cand_rp_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 834
  return ((rpentry_t *)((void *)0));
}
}
#line 844 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
int create_pim_bootstrap_message(char *send_buff ) 
{ 
  u_int8 *data_ptr ;
  grp_mask_t *mask_ptr ;
  rp_grp_entry_t *entry_ptr ;
  int datalen ;
  u_int8 masklen ;
  register u_int16 Xv ;
  u_int8 *tmp ;
  u_int8 *tmp___0 ;
  register u_int32 tmp_mask ;
  uint32_t tmp___1 ;
  register u_int8 tmp_masklen ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  register u_int32 Xv___0 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  register u_int32 tmp_mask___0 ;
  uint32_t tmp___10 ;
  register u_int8 tmp_masklen___0 ;
  u_int32 mask ;
  uint32_t tmp___11 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  u_int8 *tmp___14 ;
  u_int8 *tmp___15 ;
  register u_int32 Xv___1 ;
  u_int8 *tmp___16 ;
  u_int8 *tmp___17 ;
  u_int8 *tmp___18 ;
  u_int8 *tmp___19 ;
  u_int8 *tmp___20 ;
  u_int8 *tmp___21 ;
  register u_int16 Xv___2 ;
  u_int8 *tmp___22 ;
  u_int8 *tmp___23 ;
  u_int8 *tmp___24 ;
  u_int8 *tmp___25 ;
  register u_int32 Xv___3 ;
  u_int8 *tmp___26 ;
  u_int8 *tmp___27 ;
  u_int8 *tmp___28 ;
  u_int8 *tmp___29 ;
  register u_int16 Xv___4 ;
  u_int8 *tmp___30 ;
  u_int8 *tmp___31 ;
  u_int8 *tmp___32 ;
  u_int8 *tmp___33 ;

  {
#line 852
  if (curr_bsr_address == 0U) {
#line 853
    return (0);
  }
#line 855
  data_ptr = (u_int8 *)((send_buff + sizeof(struct ip )) + sizeof(pim_header_t ));
#line 856
  if (curr_bsr_address == my_bsr_address) {
#line 857
    curr_bsr_fragment_tag = (u_int16 )((int )curr_bsr_fragment_tag + 1);
  }
  {
#line 859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 859
    Xv = curr_bsr_fragment_tag;
#line 859
    tmp = data_ptr;
#line 859
    data_ptr ++;
#line 859
    *tmp = (u_int8 )((int )Xv >> 8);
#line 859
    tmp___0 = data_ptr;
#line 859
    data_ptr ++;
#line 859
    *tmp___0 = (u_int8 )Xv;
#line 859
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 860
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 860
    tmp___1 = ntohl(curr_bsr_hash_mask);
#line 860
    tmp_mask = tmp___1;
#line 860
    tmp_masklen = (u_int8 )(sizeof(curr_bsr_hash_mask) << 3);
    }
    {
#line 860
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 860
      if (! ((int )tmp_masklen > 0)) {
#line 860
        goto while_break___1;
      }
#line 860
      if (tmp_mask & 1U) {
#line 860
        goto while_break___1;
      }
#line 860
      tmp_masklen = (u_int8 )((int )tmp_masklen - 1);
#line 860
      tmp_mask >>= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 860
    masklen = tmp_masklen;
#line 860
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 861
  tmp___2 = data_ptr;
#line 861
  data_ptr ++;
#line 861
  *tmp___2 = masklen;
#line 862
  tmp___3 = data_ptr;
#line 862
  data_ptr ++;
#line 862
  *tmp___3 = curr_bsr_priority;
  {
#line 863
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 863
    tmp___4 = data_ptr;
#line 863
    data_ptr ++;
#line 863
    *tmp___4 = (u_int8 )1;
#line 863
    tmp___5 = data_ptr;
#line 863
    data_ptr ++;
#line 863
    *tmp___5 = (u_int8 )0;
    {
#line 863
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 863
      Xv___0 = curr_bsr_address;
#line 863
      tmp___6 = data_ptr;
#line 863
      data_ptr ++;
#line 863
      *tmp___6 = (u_int8 )Xv___0;
#line 863
      tmp___7 = data_ptr;
#line 863
      data_ptr ++;
#line 863
      *tmp___7 = (u_int8 )(Xv___0 >> 8);
#line 863
      tmp___8 = data_ptr;
#line 863
      data_ptr ++;
#line 863
      *tmp___8 = (u_int8 )(Xv___0 >> 16);
#line 863
      tmp___9 = data_ptr;
#line 863
      data_ptr ++;
#line 863
      *tmp___9 = (u_int8 )(Xv___0 >> 24);
#line 863
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 863
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 866
  mask_ptr = grp_mask_list;
  {
#line 866
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 866
    if (! mask_ptr) {
#line 866
      goto while_break___4;
    }
    {
#line 867
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 867
      tmp___10 = ntohl(mask_ptr->group_mask);
#line 867
      tmp_mask___0 = tmp___10;
#line 867
      tmp_masklen___0 = (u_int8 )(sizeof(mask_ptr->group_mask) << 3);
      }
      {
#line 867
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 867
        if (! ((int )tmp_masklen___0 > 0)) {
#line 867
          goto while_break___6;
        }
#line 867
        if (tmp_mask___0 & 1U) {
#line 867
          goto while_break___6;
        }
#line 867
        tmp_masklen___0 = (u_int8 )((int )tmp_masklen___0 - 1);
#line 867
        tmp_mask___0 >>= 1;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 867
      masklen = tmp_masklen___0;
#line 867
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 868
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 868
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 868
        if (masklen) {
          {
#line 868
          tmp___11 = htonl((uint32_t )(-1 << ((sizeof(mask) << 3) - (unsigned long )masklen)));
#line 868
          mask = tmp___11;
          }
        } else {
#line 868
          mask = (u_int32 )0;
        }
#line 868
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 868
      tmp___12 = data_ptr;
#line 868
      data_ptr ++;
#line 868
      *tmp___12 = (u_int8 )1;
#line 868
      tmp___13 = data_ptr;
#line 868
      data_ptr ++;
#line 868
      *tmp___13 = (u_int8 )0;
#line 868
      tmp___14 = data_ptr;
#line 868
      data_ptr ++;
#line 868
      *tmp___14 = (u_int8 )0;
#line 868
      tmp___15 = data_ptr;
#line 868
      data_ptr ++;
#line 868
      *tmp___15 = masklen;
      {
#line 868
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 868
        Xv___1 = mask_ptr->group_addr & mask;
#line 868
        tmp___16 = data_ptr;
#line 868
        data_ptr ++;
#line 868
        *tmp___16 = (u_int8 )Xv___1;
#line 868
        tmp___17 = data_ptr;
#line 868
        data_ptr ++;
#line 868
        *tmp___17 = (u_int8 )(Xv___1 >> 8);
#line 868
        tmp___18 = data_ptr;
#line 868
        data_ptr ++;
#line 868
        *tmp___18 = (u_int8 )(Xv___1 >> 16);
#line 868
        tmp___19 = data_ptr;
#line 868
        data_ptr ++;
#line 868
        *tmp___19 = (u_int8 )(Xv___1 >> 24);
#line 868
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 868
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 869
    tmp___20 = data_ptr;
#line 869
    data_ptr ++;
#line 869
    *tmp___20 = mask_ptr->group_rp_number;
#line 870
    tmp___21 = data_ptr;
#line 870
    data_ptr ++;
#line 870
    *tmp___21 = mask_ptr->group_rp_number;
    {
#line 871
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 871
      Xv___2 = (u_int16 )0;
#line 871
      tmp___22 = data_ptr;
#line 871
      data_ptr ++;
#line 871
      *tmp___22 = (u_int8 )((int )Xv___2 >> 8);
#line 871
      tmp___23 = data_ptr;
#line 871
      data_ptr ++;
#line 871
      *tmp___23 = (u_int8 )Xv___2;
#line 871
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 873
    entry_ptr = mask_ptr->grp_rp_next;
    {
#line 873
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 873
      if (! entry_ptr) {
#line 873
        goto while_break___11;
      }
      {
#line 874
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 874
        tmp___24 = data_ptr;
#line 874
        data_ptr ++;
#line 874
        *tmp___24 = (u_int8 )1;
#line 874
        tmp___25 = data_ptr;
#line 874
        data_ptr ++;
#line 874
        *tmp___25 = (u_int8 )0;
        {
#line 874
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 874
          Xv___3 = ((entry_ptr->rp)->rpentry)->address;
#line 874
          tmp___26 = data_ptr;
#line 874
          data_ptr ++;
#line 874
          *tmp___26 = (u_int8 )Xv___3;
#line 874
          tmp___27 = data_ptr;
#line 874
          data_ptr ++;
#line 874
          *tmp___27 = (u_int8 )(Xv___3 >> 8);
#line 874
          tmp___28 = data_ptr;
#line 874
          data_ptr ++;
#line 874
          *tmp___28 = (u_int8 )(Xv___3 >> 16);
#line 874
          tmp___29 = data_ptr;
#line 874
          data_ptr ++;
#line 874
          *tmp___29 = (u_int8 )(Xv___3 >> 24);
#line 874
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 874
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 875
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 875
        Xv___4 = entry_ptr->holdtime;
#line 875
        tmp___30 = data_ptr;
#line 875
        data_ptr ++;
#line 875
        *tmp___30 = (u_int8 )((int )Xv___4 >> 8);
#line 875
        tmp___31 = data_ptr;
#line 875
        data_ptr ++;
#line 875
        *tmp___31 = (u_int8 )Xv___4;
#line 875
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 876
      tmp___32 = data_ptr;
#line 876
      data_ptr ++;
#line 876
      *tmp___32 = entry_ptr->priority;
#line 877
      tmp___33 = data_ptr;
#line 877
      data_ptr ++;
#line 877
      *tmp___33 = (u_int8 )0;
#line 873
      entry_ptr = entry_ptr->grp_rp_next;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 866
    mask_ptr = mask_ptr->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 881
  datalen = (int )(((unsigned long )(data_ptr - (u_int8 *)send_buff) - sizeof(struct ip )) - sizeof(pim_header_t ));
#line 883
  return (datalen);
}
}
#line 891 "/home/wheatley/newnew/temp/pimd-2.1.8/rp.c"
int check_mrtentry_rp(mrtentry_t *mrtentry_ptr , u_int32 rp_addr ) 
{ 
  rp_grp_entry_t *ptr ;

  {
#line 895
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 896
    return (0);
  }
#line 898
  if (rp_addr == 0U) {
#line 899
    return (0);
  }
#line 901
  ptr = (mrtentry_ptr->group)->active_rp_grp;
#line 902
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 903
    return (0);
  }
#line 905
  if ((mrtentry_ptr->group)->rpaddr == rp_addr) {
#line 906
    return (1);
  }
#line 908
  return (0);
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 271 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char *pim_recv_buf  ;
#line 272 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char *pim_send_buf  ;
#line 274 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int pim_socket  ;
#line 275
u_int32 allhosts_group ;
#line 277 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 allpimrouters_group  ;
#line 278
build_jp_message_t *build_jp_message_pool ;
#line 279
int build_jp_message_pool_counter ;
#line 438
char *packet_kind(u_int proto , u_int type , u_int code ) ;
#line 471
int inet_cksum(u_int16 *addr , u_int len ) ;
#line 499
int register_input_handler(int fd , void (*func)(int  , fd_set * ) ) ;
#line 514
void init_pim(void) ;
#line 515
void send_pim(char *buf , u_int32 src , u_int32 dst , int type , int datalen ) ;
#line 516
void send_pim_unicast(char *buf , u_int32 src , u_int32 dst , int type , int datalen ) ;
#line 519
int receive_pim_hello(u_int32 src , u_int32 dst  __attribute__((__unused__)) , char *pim_message ,
                      size_t datalen ) ;
#line 522
int receive_pim_register(u_int32 reg_src , u_int32 reg_dst , char *pim_message , size_t datalen ) ;
#line 524
int receive_pim_register_stop(u_int32 reg_src , u_int32 reg_dst , char *pim_message ,
                              size_t datalen ) ;
#line 526
int receive_pim_join_prune(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                           char *pim_message , int datalen ) ;
#line 528
int receive_pim_assert(u_int32 src , u_int32 dst  __attribute__((__unused__)) , char *pim_message ,
                       int datalen ) ;
#line 534
int receive_pim_cand_rp_adv(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                            char *pim_message , int datalen ) ;
#line 535
int receive_pim_bootstrap(u_int32 src , u_int32 dst , char *pim_message , int datalen ) ;
#line 52 "/home/wheatley/newnew/temp/pimd-2.1.8/pim.c"
static void pim_read(int f  __attribute__((__unused__)) , fd_set *rfd  __attribute__((__unused__)) ) ;
#line 53
static void accept_pim(ssize_t recvlen ) ;
#line 56 "/home/wheatley/newnew/temp/pimd-2.1.8/pim.c"
void init_pim(void) 
{ 
  struct ip *ip ;
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 61
  pim_socket = socket(2, 3, 103);
  }
#line 61
  if (pim_socket < 0) {
    {
#line 62
    tmp = __errno_location();
#line 62
    logit(3, *tmp, "Failed creating PIM socket");
    }
  }
  {
#line 63
  k_hdr_include(pim_socket, 1);
#line 64
  k_set_sndbuf(pim_socket, 262144, 49152);
#line 66
  k_set_rcvbuf(pim_socket, 262144, 49152);
#line 68
  k_set_ttl(pim_socket, 1);
#line 69
  k_set_loop(pim_socket, 0);
#line 71
  allpimrouters_group = htonl(3758096397U);
#line 73
  tmp___0 = calloc((size_t )1, (size_t )131072);
#line 73
  pim_recv_buf = (char *)tmp___0;
#line 74
  tmp___1 = calloc((size_t )1, (size_t )131072);
#line 74
  pim_send_buf = (char *)tmp___1;
  }
#line 75
  if (! pim_recv_buf) {
    {
#line 76
    logit(3, 0, "Ran out of memory in init_pim()");
    }
  } else
#line 75
  if (! pim_send_buf) {
    {
#line 76
    logit(3, 0, "Ran out of memory in init_pim()");
    }
  }
  {
#line 79
  ip = (struct ip *)pim_send_buf;
#line 80
  memset((void *)ip, 0, sizeof(*ip));
#line 81
  ip->ip_v = 4U;
#line 82
  ip->ip_hl = (unsigned int )(sizeof(struct ip ) >> 2);
#line 83
  ip->ip_tos = (u_int8_t )0;
#line 84
  ip->ip_id = (u_short )0;
#line 85
  ip->ip_off = (u_short )0;
#line 86
  ip->ip_p = (u_int8_t )103;
#line 90
  ip->ip_sum = (u_short )0;
#line 93
  tmp___2 = register_input_handler(pim_socket, & pim_read);
  }
#line 93
  if (tmp___2 < 0) {
    {
#line 94
    logit(3, 0, "Failed registering pim_read() as an input handler");
    }
  }
#line 97
  build_jp_message_pool = (build_jp_message_t *)((void *)0);
#line 98
  build_jp_message_pool_counter = 0;
#line 99
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/pimd-2.1.8/pim.c"
static void pim_read(int f  __attribute__((__unused__)) , fd_set *rfd  __attribute__((__unused__)) ) 
{ 
  ssize_t len ;
  socklen_t dummy ;
  sigset_t block ;
  sigset_t oblock ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 106
  dummy = (socklen_t )0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    len = recvfrom(pim_socket, (void */* __restrict  */)pim_recv_buf, (size_t )131072,
                   0, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)(& dummy));
    }
#line 113
    if (! (len < 0L)) {
#line 113
      goto while_break;
    }
    {
#line 114
    tmp = __errno_location();
    }
#line 114
    if (*tmp == 4) {
#line 115
      goto while_continue;
    }
    {
#line 117
    tmp___0 = __errno_location();
#line 117
    logit(3, *tmp___0, "Failed recvfrom() in pim_read()");
    }
#line 118
    return;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  sigemptyset(& block);
#line 123
  sigaddset(& block, 14);
#line 124
  tmp___2 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& block), (sigset_t */* __restrict  */)(& oblock));
  }
#line 124
  if (tmp___2 < 0) {
    {
#line 125
    tmp___1 = __errno_location();
#line 125
    logit(3, *tmp___1, "sigprocmask");
    }
  }
  {
#line 131
  accept_pim(len);
#line 134
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oblock), (sigset_t */* __restrict  */)((sigset_t *)((void *)0)));
  }
#line 138
  return;
}
}
#line 140 "/home/wheatley/newnew/temp/pimd-2.1.8/pim.c"
static void accept_pim(ssize_t recvlen ) 
{ 
  u_int32 src ;
  u_int32 dst ;
  struct ip *ip ;
  pim_header_t *pim ;
  int iphdrlen ;
  int pimlen ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 147
  if (recvlen < (ssize_t )sizeof(struct ip )) {
    {
#line 148
    logit(4, 0, "packet too short (%u bytes) for IP header", recvlen);
    }
#line 150
    return;
  }
#line 153
  ip = (struct ip *)pim_recv_buf;
#line 154
  src = ip->ip_src.s_addr;
#line 155
  dst = ip->ip_dst.s_addr;
#line 156
  iphdrlen = (int )(ip->ip_hl << 2);
#line 158
  pim = (pim_header_t *)(pim_recv_buf + iphdrlen);
#line 159
  pimlen = (int )(recvlen - (ssize_t )iphdrlen);
#line 160
  if ((ssize_t )pimlen < (ssize_t )sizeof(*pim)) {
    {
#line 161
    tmp = inet_fmt(dst, s2, sizeof(s2));
#line 161
    tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 161
    logit(4, 0, "IP data field too short (%u bytes) for PIM header, from %s to %s",
          pimlen, tmp___0, tmp);
    }
#line 164
    return;
  }
  {
#line 184
  if (pim->pim_type == 0U) {
#line 184
    goto case_0;
  }
#line 187
  if (pim->pim_type == 1U) {
#line 187
    goto case_1;
  }
#line 190
  if (pim->pim_type == 2U) {
#line 190
    goto case_2;
  }
#line 193
  if (pim->pim_type == 3U) {
#line 193
    goto case_3;
  }
#line 196
  if (pim->pim_type == 4U) {
#line 196
    goto case_4;
  }
#line 199
  if (pim->pim_type == 5U) {
#line 199
    goto case_5;
  }
#line 203
  if (pim->pim_type == 7U) {
#line 203
    goto case_7;
  }
#line 203
  if (pim->pim_type == 6U) {
#line 203
    goto case_7;
  }
#line 207
  if (pim->pim_type == 8U) {
#line 207
    goto case_8;
  }
#line 210
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 185
  receive_pim_hello(src, dst, (char *)pim, (size_t )pimlen);
  }
#line 186
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 188
  receive_pim_register(src, dst, (char *)pim, (size_t )pimlen);
  }
#line 189
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 191
  receive_pim_register_stop(src, dst, (char *)pim, (size_t )pimlen);
  }
#line 192
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 194
  receive_pim_join_prune(src, dst, (char *)pim, pimlen);
  }
#line 195
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 197
  receive_pim_bootstrap(src, dst, (char *)pim, pimlen);
  }
#line 198
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 200
  receive_pim_assert(src, dst, (char *)pim, pimlen);
  }
#line 201
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 204
  tmp___1 = inet_fmt(dst, s2, sizeof(s2));
#line 204
  tmp___2 = inet_fmt(src, s1, sizeof(s1));
#line 204
  tmp___3 = packet_kind((u_int )103, pim->pim_type, (u_int )0);
#line 204
  logit(6, 0, "ignore %s from %s to %s", tmp___3, tmp___2, tmp___1);
  }
  case_8: /* CIL Label */ 
  {
#line 208
  receive_pim_cand_rp_adv(src, dst, (char *)pim, pimlen);
  }
#line 209
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 211
  tmp___4 = inet_fmt(dst, s2, sizeof(s2));
#line 211
  tmp___5 = inet_fmt(src, s1, sizeof(s1));
#line 211
  logit(6, 0, "ignore unknown PIM message code %u from %s to %s", pim->pim_type, tmp___5,
        tmp___4);
  }
#line 214
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/pimd-2.1.8/pim.c"
void send_pim(char *buf , u_int32 src , u_int32 dst , int type , int datalen ) 
{ 
  struct sockaddr_in sdst ;
  struct ip *ip ;
  pim_header_t *pim ;
  int sendlen ;
  int setloop ;
  int tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  ssize_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 229
  setloop = 0;
#line 232
  ip = (struct ip *)buf;
#line 233
  ip->ip_len = (u_short )((sizeof(struct ip ) + sizeof(pim_header_t )) + (unsigned long )datalen);
#line 234
  ip->ip_src.s_addr = src;
#line 235
  ip->ip_dst.s_addr = dst;
#line 236
  ip->ip_ttl = (u_int8_t )255;
#line 237
  sendlen = (int )ip->ip_len;
#line 239
  ip->ip_len = htons(ip->ip_len);
#line 243
  pim = (pim_header_t *)(buf + sizeof(struct ip ));
#line 244
  pim->pim_type = (u_int )type;
#line 245
  pim->pim_vers = (u_int )2;
#line 246
  pim->pim_reserved = (uint8_t )0;
#line 247
  pim->pim_cksum = (uint16_t )0;
#line 251
  tmp = inet_cksum((u_int16 *)pim, (u_int )(sizeof(pim_header_t ) + (unsigned long )datalen));
#line 251
  pim->pim_cksum = (uint16_t )tmp;
#line 254
  tmp___0 = ntohl(dst);
  }
#line 254
  if ((tmp___0 & 4026531840U) == 3758096384U) {
    {
#line 255
    k_set_if(pim_socket, src);
    }
#line 256
    if (dst == allhosts_group) {
      {
#line 258
      setloop = 1;
#line 259
      k_set_loop(pim_socket, 1);
      }
    } else
#line 256
    if (dst == allrouters_group) {
      {
#line 258
      setloop = 1;
#line 259
      k_set_loop(pim_socket, 1);
      }
    } else
#line 256
    if (dst == allpimrouters_group) {
      {
#line 258
      setloop = 1;
#line 259
      k_set_loop(pim_socket, 1);
      }
    }
#line 262
    ip->ip_ttl = (u_int8_t )curttl;
  } else {
#line 264
    ip->ip_ttl = (u_int8_t )255;
  }
  {
#line 268
  memset((void *)(& sdst), 0, sizeof(sdst));
#line 269
  sdst.sin_family = (sa_family_t )2;
#line 273
  sdst.sin_addr.s_addr = dst;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 274
    tmp___6 = sendto(pim_socket, (void const   *)buf, (size_t )sendlen, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sdst)),
                     (socklen_t )sizeof(sdst));
    }
#line 274
    if (! (tmp___6 < 0L)) {
#line 274
      goto while_break;
    }
    {
#line 275
    tmp___5 = __errno_location();
    }
#line 275
    if (*tmp___5 == 4) {
#line 276
      goto while_continue;
    } else {
      {
#line 277
      tmp___4 = __errno_location();
      }
#line 277
      if (*tmp___4 == 100) {
        {
#line 278
        check_vif_state();
        }
      } else {
        {
#line 280
        tmp___1 = inet_fmt(dst, s2, sizeof(s2));
#line 280
        tmp___2 = inet_fmt(src, s1, sizeof(s1));
#line 280
        tmp___3 = __errno_location();
#line 280
        logit(4, *tmp___3, "sendto from %s to %s", tmp___2, tmp___1);
        }
      }
    }
#line 282
    if (setloop) {
      {
#line 283
      k_set_loop(pim_socket, 0);
      }
    }
#line 284
    return;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  if (setloop) {
    {
#line 288
    k_set_loop(pim_socket, 0);
    }
  }
#line 290
  if (debug) {
#line 290
    if (debug & 8388608UL) {
#line 291
      if (debug) {
#line 291
        if (debug & 8372224UL) {
          {
#line 292
          tmp___7 = inet_fmt(dst, s2, sizeof(s2));
          }
#line 292
          if (src == 0U) {
#line 292
            tmp___9 = "INADDR_ANY";
          } else {
            {
#line 292
            tmp___8 = inet_fmt(src, s1, sizeof(s1));
#line 292
            tmp___9 = (char const   *)tmp___8;
            }
          }
          {
#line 292
          tmp___10 = packet_kind((u_int )103, (u_int )type, (u_int )0);
#line 292
          logit(7, 0, "SENT %s from %-15s to %s", tmp___10, tmp___9, tmp___7);
          }
        }
      }
    }
  }
#line 298
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/pimd-2.1.8/pim.c"
u_int pim_send_cnt  =    (u_int )0;
#line 309 "/home/wheatley/newnew/temp/pimd-2.1.8/pim.c"
void send_pim_unicast(char *buf , u_int32 src , u_int32 dst , int type , int datalen ) 
{ 
  struct sockaddr_in sdst ;
  struct ip *ip ;
  pim_header_t *pim ;
  int sendlen ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  ssize_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 317
  ip = (struct ip *)buf;
#line 318
  ip->ip_len = (u_short )((sizeof(struct ip ) + sizeof(pim_header_t )) + (unsigned long )datalen);
#line 319
  ip->ip_src.s_addr = src;
#line 320
  ip->ip_dst.s_addr = dst;
#line 321
  sendlen = (int )ip->ip_len;
#line 323
  ip->ip_ttl = (u_int8_t )255;
#line 325
  ip->ip_len = htons(ip->ip_len);
#line 329
  pim = (pim_header_t *)(buf + sizeof(struct ip ));
#line 330
  pim->pim_vers = (u_int )2;
#line 331
  pim->pim_type = (u_int )type;
#line 332
  pim->pim_reserved = (uint8_t )0;
#line 333
  pim->pim_cksum = (uint16_t )0;
  }
#line 348
  if (1 == type) {
    {
#line 349
    tmp = inet_cksum((u_int16 *)pim, (u_int )(sizeof(pim_header_t ) + sizeof(pim_register_t )));
#line 349
    pim->pim_cksum = (uint16_t )tmp;
    }
  } else {
    {
#line 352
    tmp___0 = inet_cksum((u_int16 *)pim, (u_int )(sizeof(pim_header_t ) + (unsigned long )datalen));
#line 352
    pim->pim_cksum = (uint16_t )tmp___0;
    }
  }
  {
#line 357
  memset((void *)(& sdst), 0, sizeof(sdst));
#line 358
  sdst.sin_family = (sa_family_t )2;
#line 362
  sdst.sin_addr.s_addr = dst;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 363
    tmp___6 = sendto(pim_socket, (void const   *)buf, (size_t )sendlen, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sdst)),
                     (socklen_t )sizeof(sdst));
    }
#line 363
    if (! (tmp___6 < 0L)) {
#line 363
      goto while_break;
    }
    {
#line 364
    tmp___5 = __errno_location();
    }
#line 364
    if (*tmp___5 == 4) {
#line 365
      goto while_continue;
    } else {
      {
#line 366
      tmp___4 = __errno_location();
      }
#line 366
      if (*tmp___4 == 100) {
        {
#line 367
        check_vif_state();
        }
      } else {
        {
#line 369
        tmp___1 = inet_fmt(dst, s2, sizeof(s2));
#line 369
        tmp___2 = inet_fmt(src, s1, sizeof(s1));
#line 369
        tmp___3 = __errno_location();
#line 369
        logit(4, *tmp___3, "sendto from %s to %s", tmp___2, tmp___1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  if (debug) {
#line 373
    if (debug & 8388608UL) {
#line 374
      if (debug) {
#line 374
        if (debug & 8372224UL) {
          {
#line 383
          tmp___7 = inet_fmt(dst, s2, sizeof(s2));
#line 383
          tmp___8 = inet_fmt(src, s1, sizeof(s1));
#line 383
          tmp___9 = packet_kind((u_int )103, (u_int )type, (u_int )0);
#line 383
          logit(7, 0, "sending %s from %-15s to %s", tmp___9, tmp___8, tmp___7);
          }
        }
      }
    }
  }
#line 388
  return;
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 269 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char *igmp_recv_buf  ;
#line 270 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char *igmp_send_buf  ;
#line 273 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int igmp_socket  ;
#line 275 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 allhosts_group  ;
#line 276 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_int32 allrouters_group  ;
#line 439
int debug_kind(u_int proto , u_int type , u_int code ) ;
#line 441
int log_level(u_int proto , u_int type , u_int code ) ;
#line 450
void dvmrp_accept_probe(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ,
                        u_int32 level  __attribute__((__unused__)) ) ;
#line 451
void dvmrp_accept_report(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                         u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ,
                         u_int32 level  __attribute__((__unused__)) ) ;
#line 452
void dvmrp_accept_info_request(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                               u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) ;
#line 453
void dvmrp_accept_info_reply(u_int32 src , u_int32 dst , u_char *p  __attribute__((__unused__)) ,
                             int datalen  __attribute__((__unused__)) ) ;
#line 454
void dvmrp_accept_neighbors(u_int32 src , u_int32 dst , u_char *p  __attribute__((__unused__)) ,
                            int datalen  __attribute__((__unused__)) , u_int32 level  __attribute__((__unused__)) ) ;
#line 455
void dvmrp_accept_neighbors2(u_int32 src , u_int32 dst , u_char *p  __attribute__((__unused__)) ,
                             int datalen  __attribute__((__unused__)) , u_int32 level  __attribute__((__unused__)) ) ;
#line 456
void dvmrp_accept_prune(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) ;
#line 457
void dvmrp_accept_graft(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) ;
#line 458
void dvmrp_accept_g_ack(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) ;
#line 461
void init_igmp(void) ;
#line 462
void send_igmp(char *buf , u_int32 src , u_int32 dst , int type , int code , u_int32 group ,
               int datalen ) ;
#line 466
void accept_membership_query(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                             u_int32 group , int tmo ) ;
#line 467
void accept_group_report(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                         u_int32 group , int igmp_report_type ) ;
#line 468
void accept_leave_message(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                          u_int32 group ) ;
#line 612
void accept_mtrace(u_int32 src , u_int32 dst , u_int32 group , char *data , u_int no ,
                   int datalen ) ;
#line 613
void accept_neighbor_request(u_int32 src , u_int32 dst  __attribute__((__unused__)) ) ;
#line 614
void accept_neighbor_request2(u_int32 src , u_int32 dst  __attribute__((__unused__)) ) ;
#line 61 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp.c"
static void igmp_read(int i  __attribute__((__unused__)) , fd_set *rfd  __attribute__((__unused__)) ) ;
#line 62
static void accept_igmp(ssize_t recvlen ) ;
#line 69 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp.c"
void init_igmp(void) 
{ 
  struct ip *ip ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 73
  tmp = calloc((size_t )1, (size_t )131072);
#line 73
  igmp_recv_buf = (char *)tmp;
#line 74
  tmp___0 = calloc((size_t )1, (size_t )131072);
#line 74
  igmp_send_buf = (char *)tmp___0;
  }
#line 75
  if (! igmp_recv_buf) {
    {
#line 76
    logit(3, 0, "Ran out of memory in init_igmp()");
    }
  } else
#line 75
  if (! igmp_send_buf) {
    {
#line 76
    logit(3, 0, "Ran out of memory in init_igmp()");
    }
  }
  {
#line 78
  igmp_socket = socket(2, 3, 2);
  }
#line 78
  if (igmp_socket < 0) {
    {
#line 79
    tmp___1 = __errno_location();
#line 79
    logit(3, *tmp___1, "Failed creating IGMP socket in init_igmp()");
    }
  }
  {
#line 81
  k_hdr_include(igmp_socket, 1);
#line 82
  k_set_sndbuf(igmp_socket, 262144, 49152);
#line 84
  k_set_rcvbuf(igmp_socket, 262144, 49152);
#line 86
  k_set_ttl(igmp_socket, 1);
#line 87
  k_set_loop(igmp_socket, 0);
#line 89
  ip = (struct ip *)igmp_send_buf;
#line 90
  memset((void *)ip, 0, sizeof(*ip));
#line 91
  ip->ip_v = 4U;
#line 92
  ip->ip_hl = (unsigned int )(sizeof(struct ip ) >> 2);
#line 93
  ip->ip_tos = (u_int8_t )192;
#line 94
  ip->ip_id = (u_short )0;
#line 95
  ip->ip_off = (u_short )0;
#line 96
  ip->ip_ttl = (u_int8_t )255;
#line 97
  ip->ip_p = (u_int8_t )2;
#line 101
  ip->ip_sum = (u_short )0;
#line 105
  allhosts_group = htonl(3758096385U);
#line 106
  allrouters_group = htonl(3758096386U);
#line 108
  tmp___2 = register_input_handler(igmp_socket, & igmp_read);
  }
#line 108
  if (tmp___2 < 0) {
    {
#line 109
    logit(3, 0, "Failed registering igmp_read() as an input handler in init_igmp()");
    }
  }
#line 110
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp.c"
static void igmp_read(int i  __attribute__((__unused__)) , fd_set *rfd  __attribute__((__unused__)) ) 
{ 
  ssize_t len ;
  socklen_t dummy ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 117
  dummy = (socklen_t )0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    len = recvfrom(igmp_socket, (void */* __restrict  */)igmp_recv_buf, (size_t )131072,
                   0, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)(& dummy));
    }
#line 119
    if (! (len < 0L)) {
#line 119
      goto while_break;
    }
    {
#line 120
    tmp = __errno_location();
    }
#line 120
    if (*tmp == 4) {
#line 121
      goto while_continue;
    }
    {
#line 123
    tmp___0 = __errno_location();
#line 123
    logit(3, *tmp___0, "Failed recvfrom() in igmp_read()");
    }
#line 124
    return;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  accept_igmp(len);
  }
#line 128
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp.c"
static void accept_igmp(ssize_t recvlen ) 
{ 
  register u_int32 src ;
  register u_int32 dst ;
  register u_int32 group ;
  struct ip *ip ;
  struct igmp *igmp ;
  int ipdatalen ;
  int iphdrlen ;
  int igmpdatalen ;
  uint16_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 142
  if (recvlen < (ssize_t )sizeof(struct ip )) {
    {
#line 143
    logit(4, 0, "Received packet too short (%u bytes) for IP header", recvlen);
    }
#line 144
    return;
  }
#line 147
  ip = (struct ip *)igmp_recv_buf;
#line 148
  src = ip->ip_src.s_addr;
#line 149
  dst = ip->ip_dst.s_addr;
#line 152
  if ((int )ip->ip_p == 0) {
    {
#line 159
    process_kernel_call();
    }
#line 160
    return;
  }
  {
#line 163
  iphdrlen = (int )(ip->ip_hl << 2);
#line 165
  tmp = ntohs(ip->ip_len);
#line 165
  ipdatalen = (int )tmp - iphdrlen;
  }
#line 169
  if ((ssize_t )(iphdrlen + ipdatalen) != recvlen) {
    {
#line 170
    tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 170
    logit(4, 0, "Received packet from %s shorter (%u bytes) than hdr+data length (%u+%u)",
          tmp___0, recvlen, iphdrlen, ipdatalen);
    }
#line 172
    return;
  }
#line 175
  igmp = (struct igmp *)(igmp_recv_buf + iphdrlen);
#line 176
  group = igmp->igmp_group.s_addr;
#line 177
  igmpdatalen = ipdatalen - 8;
#line 178
  if (igmpdatalen < 0) {
    {
#line 179
    tmp___1 = inet_fmt(src, s1, sizeof(s1));
#line 179
    logit(4, 0, "Received IP data field too short (%u bytes) for IGMP, from %s", ipdatalen,
          tmp___1);
    }
#line 181
    return;
  }
  {
#line 194
  if ((int )igmp->igmp_type == 17) {
#line 194
    goto case_17;
  }
#line 199
  if ((int )igmp->igmp_type == 22) {
#line 199
    goto case_22;
  }
#line 199
  if ((int )igmp->igmp_type == 18) {
#line 199
    goto case_22;
  }
#line 203
  if ((int )igmp->igmp_type == 23) {
#line 203
    goto case_23;
  }
#line 207
  if ((int )igmp->igmp_type == 19) {
#line 207
    goto case_19;
  }
#line 265
  if ((int )igmp->igmp_type == 20) {
#line 265
    goto case_20;
  }
#line 268
  if ((int )igmp->igmp_type == 30) {
#line 268
    goto case_30;
  }
#line 271
  if ((int )igmp->igmp_type == 31) {
#line 271
    goto case_31;
  }
#line 276
  goto switch_default___0;
  case_17: /* CIL Label */ 
  {
#line 195
  accept_membership_query(src, dst, group, (int )igmp->igmp_code);
  }
#line 196
  return;
  case_22: /* CIL Label */ 
  case_18: /* CIL Label */ 
  {
#line 200
  accept_group_report(src, dst, group, (int )igmp->igmp_type);
  }
#line 201
  return;
  case_23: /* CIL Label */ 
  {
#line 204
  accept_leave_message(src, dst, group);
  }
#line 205
  return;
  case_19: /* CIL Label */ 
  {
#line 211
  group = ntohl(group);
  }
  {
#line 214
  if ((int )igmp->igmp_code == 1) {
#line 214
    goto case_1;
  }
#line 218
  if ((int )igmp->igmp_code == 2) {
#line 218
    goto case_2;
  }
#line 222
  if ((int )igmp->igmp_code == 3) {
#line 222
    goto case_3;
  }
#line 226
  if ((int )igmp->igmp_code == 5) {
#line 226
    goto case_5;
  }
#line 230
  if ((int )igmp->igmp_code == 4) {
#line 230
    goto case_4;
  }
#line 234
  if ((int )igmp->igmp_code == 6) {
#line 234
    goto case_6;
  }
#line 239
  if ((int )igmp->igmp_code == 7) {
#line 239
    goto case_7;
  }
#line 243
  if ((int )igmp->igmp_code == 8) {
#line 243
    goto case_8;
  }
#line 247
  if ((int )igmp->igmp_code == 9) {
#line 247
    goto case_9;
  }
#line 251
  if ((int )igmp->igmp_code == 10) {
#line 251
    goto case_10;
  }
#line 255
  if ((int )igmp->igmp_code == 11) {
#line 255
    goto case_11;
  }
#line 259
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 215
  dvmrp_accept_probe(src, dst, (u_char *)(igmp + 1), igmpdatalen, group);
  }
#line 216
  return;
  case_2: /* CIL Label */ 
  {
#line 219
  dvmrp_accept_report(src, dst, (u_char *)(igmp + 1), igmpdatalen, group);
  }
#line 220
  return;
  case_3: /* CIL Label */ 
  {
#line 223
  accept_neighbor_request(src, dst);
  }
#line 224
  return;
  case_5: /* CIL Label */ 
  {
#line 227
  accept_neighbor_request2(src, dst);
  }
#line 228
  return;
  case_4: /* CIL Label */ 
  {
#line 231
  dvmrp_accept_neighbors(src, dst, (u_char *)(igmp + 1), igmpdatalen, group);
  }
#line 232
  return;
  case_6: /* CIL Label */ 
  {
#line 235
  dvmrp_accept_neighbors2(src, dst, (u_char *)(igmp + 1), igmpdatalen, group);
  }
#line 237
  return;
  case_7: /* CIL Label */ 
  {
#line 240
  dvmrp_accept_prune(src, dst, (u_char *)(igmp + 1), igmpdatalen);
  }
#line 241
  return;
  case_8: /* CIL Label */ 
  {
#line 244
  dvmrp_accept_graft(src, dst, (u_char *)(igmp + 1), igmpdatalen);
  }
#line 245
  return;
  case_9: /* CIL Label */ 
  {
#line 248
  dvmrp_accept_g_ack(src, dst, (u_char *)(igmp + 1), igmpdatalen);
  }
#line 249
  return;
  case_10: /* CIL Label */ 
  {
#line 252
  dvmrp_accept_info_request(src, dst, (u_char *)(igmp + 1), igmpdatalen);
  }
#line 253
  return;
  case_11: /* CIL Label */ 
  {
#line 256
  dvmrp_accept_info_reply(src, dst, (u_char *)(igmp + 1), igmpdatalen);
  }
#line 257
  return;
  switch_default: /* CIL Label */ 
  {
#line 260
  tmp___2 = inet_fmt(dst, s2, sizeof(s2));
#line 260
  tmp___3 = inet_fmt(src, s1, sizeof(s1));
#line 260
  logit(6, 0, "Ignoring unknown DVMRP message code %u from %s to %s", (int )igmp->igmp_code,
        tmp___3, tmp___2);
  }
#line 262
  return;
  switch_break___0: /* CIL Label */ ;
  }
  case_20: /* CIL Label */ 
#line 266
  return;
  case_30: /* CIL Label */ 
#line 269
  return;
  case_31: /* CIL Label */ 
  {
#line 272
  accept_mtrace(src, dst, group, (char *)(igmp + 1), (u_int )igmp->igmp_code, igmpdatalen);
  }
#line 274
  return;
  switch_default___0: /* CIL Label */ 
  {
#line 277
  tmp___4 = inet_fmt(dst, s2, sizeof(s2));
#line 277
  tmp___5 = inet_fmt(src, s1, sizeof(s1));
#line 277
  logit(6, 0, "Ignoring unknown IGMP message type %x from %s to %s", (int )igmp->igmp_type,
        tmp___5, tmp___4);
  }
#line 279
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 283 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp.c"
void send_igmp(char *buf , u_int32 src , u_int32 dst , int type , int code , u_int32 group ,
               int datalen ) 
{ 
  struct sockaddr_in sdst ;
  struct ip *ip ;
  struct igmp *igmp ;
  int sendlen ;
  int setloop ;
  int tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 289
  setloop = 0;
#line 292
  ip = (struct ip *)buf;
#line 293
  ip->ip_len = (u_short )((sizeof(struct ip ) + 8UL) + (unsigned long )datalen);
#line 294
  ip->ip_src.s_addr = src;
#line 295
  ip->ip_dst.s_addr = dst;
#line 296
  sendlen = (int )ip->ip_len;
#line 298
  ip->ip_len = htons(ip->ip_len);
#line 301
  igmp = (struct igmp *)(buf + sizeof(struct ip ));
#line 302
  igmp->igmp_type = (u_int8_t )type;
#line 303
  igmp->igmp_code = (u_int8_t )code;
#line 304
  igmp->igmp_group.s_addr = group;
#line 305
  igmp->igmp_cksum = (u_int16_t )0;
#line 306
  tmp = inet_cksum((u_int16 *)igmp, (u_int )(8 + datalen));
#line 306
  igmp->igmp_cksum = (u_int16_t )tmp;
#line 309
  tmp___0 = ntohl(dst);
  }
#line 309
  if ((tmp___0 & 4026531840U) == 3758096384U) {
    {
#line 310
    k_set_if(igmp_socket, src);
    }
#line 311
    if (type != 19) {
      {
#line 312
      setloop = 1;
#line 313
      k_set_loop(igmp_socket, 1);
      }
    } else
#line 311
    if (dst == allhosts_group) {
      {
#line 312
      setloop = 1;
#line 313
      k_set_loop(igmp_socket, 1);
      }
    }
#line 316
    ip->ip_ttl = (u_int8_t )curttl;
  } else {
#line 318
    ip->ip_ttl = (u_int8_t )255;
  }
  {
#line 322
  memset((void *)(& sdst), 0, sizeof(sdst));
#line 323
  sdst.sin_family = (sa_family_t )2;
#line 327
  sdst.sin_addr.s_addr = dst;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 328
    tmp___8 = sendto(igmp_socket, (void const   *)igmp_send_buf, (size_t )sendlen,
                     0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sdst)),
                     (socklen_t )sizeof(sdst));
    }
#line 328
    if (! (tmp___8 < 0L)) {
#line 328
      goto while_break;
    }
    {
#line 329
    tmp___7 = __errno_location();
    }
#line 329
    if (*tmp___7 == 4) {
#line 330
      goto while_continue;
    } else {
      {
#line 331
      tmp___5 = __errno_location();
      }
#line 331
      if (*tmp___5 == 100) {
        {
#line 332
        check_vif_state();
        }
      } else {
        {
#line 331
        tmp___6 = __errno_location();
        }
#line 331
        if (*tmp___6 == 19) {
          {
#line 332
          check_vif_state();
          }
        } else {
          {
#line 334
          tmp___1 = inet_fmt(src, s2, sizeof(s2));
#line 334
          tmp___2 = inet_fmt(dst, s1, sizeof(s1));
#line 334
          tmp___3 = __errno_location();
#line 334
          tmp___4 = log_level((u_int )2, (u_int )type, (u_int )code);
#line 334
          logit(tmp___4, *tmp___3, "Sendto to %s on %s", tmp___2, tmp___1);
          }
        }
      }
    }
#line 337
    if (setloop) {
      {
#line 338
      k_set_loop(igmp_socket, 0);
      }
    }
#line 340
    return;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if (setloop) {
    {
#line 344
    k_set_loop(igmp_socket, 0);
    }
  }
#line 346
  if (debug) {
    {
#line 346
    tmp___13 = debug_kind((u_int )2, (u_int )type, (u_int )code);
    }
#line 346
    if (debug & (unsigned long )(512 | tmp___13)) {
      {
#line 347
      tmp___9 = inet_fmt(dst, s2, sizeof(s2));
      }
#line 347
      if (src == 0U) {
#line 347
        tmp___11 = "INADDR_ANY";
      } else {
        {
#line 347
        tmp___10 = inet_fmt(src, s1, sizeof(s1));
#line 347
        tmp___11 = (char const   *)tmp___10;
        }
      }
      {
#line 347
      tmp___12 = packet_kind((u_int )2, (u_int )type, (u_int )code);
#line 347
      logit(7, 0, "SENT %s from %-15s to %s", tmp___12, tmp___11, tmp___9);
      }
    }
  }
#line 352
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 429 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int timer_setTimer(int delay , void (*action)(void * ) , void *data ) ;
#line 430
void timer_clearTimer(int timer_id ) ;
#line 55 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
static void DelVif(void *arg ) ;
#line 56
static int SetTimer(vifi_t vifi , struct listaddr *g ) ;
#line 57
static int DeleteTimer(int id___0 ) ;
#line 58
static void SendQuery(void *arg ) ;
#line 59
static int SetQueryTimer(struct listaddr *g , vifi_t vifi , int to_expire , int q_time ) ;
#line 65 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
void query_groups(struct uvif *v ) 
{ 
  struct listaddr *g ;
  int tmp ;

  {
#line 69
  v->uv_gq_timer = (u_int16 )125;
#line 70
  if (v->uv_flags & 1024U) {
#line 71
    if (v->uv_flags & 8192U) {
#line 71
      tmp = 0;
    } else {
#line 71
      tmp = 100;
    }
    {
#line 71
    send_igmp(igmp_send_buf, v->uv_lcl_addr, allhosts_group, 17, tmp, (u_int32 )0,
              0);
    }
  }
#line 80
  g = v->uv_groups;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 80
      goto while_break;
    }
#line 81
    if ((int )g->al_old > 5) {
#line 82
      g->al_old = (u_char )((int )g->al_old - 5);
    } else {
#line 84
      g->al_old = (u_char )0;
    }
#line 80
    g = g->al_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
void accept_membership_query(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                             u_int32 group , int tmo ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  vifi_t tmp ;
  char *tmp___0 ;
  int i ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  struct listaddr *g ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 98
  tmp = local_address(src);
  }
#line 98
  if ((int )tmp != 32) {
#line 99
    return;
  }
  {
#line 102
  vifi = find_vif_direct(src);
  }
#line 102
  if ((int )vifi == 32) {
#line 103
    if (debug) {
#line 103
      if (debug & 112UL) {
        {
#line 104
        tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 104
        logit(6, 0, "ignoring group membership query from non-adjacent host %s", tmp___0);
        }
      }
    }
#line 107
    return;
  }
#line 110
  v = & uvifs[vifi];
#line 112
  if (tmo == 0) {
#line 112
    if (! (v->uv_flags & 8192U)) {
#line 112
      goto _L;
    } else {
#line 112
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 112
  if (tmo != 0) {
#line 112
    if (v->uv_flags & 8192U) {
      _L: /* CIL Label */ 
#line 119
      (v->uv_igmpv1_warn) ++;
#line 119
      i = v->uv_igmpv1_warn;
      {
#line 120
      while (1) {
        while_continue: /* CIL Label */ ;
#line 120
        if (i) {
#line 120
          if (! (! (i & 1))) {
#line 120
            goto while_break;
          }
        } else {
#line 120
          goto while_break;
        }
#line 121
        i >>= 1;
      }
      while_break: /* CIL Label */ ;
      }
#line 122
      if (i == 1) {
#line 123
        if (tmo == 0) {
#line 123
          tmp___1 = "please configure vif for IGMPv1";
        } else {
#line 123
          tmp___1 = "but I am configured for IGMPv1";
        }
        {
#line 123
        tmp___2 = inet_fmt(src, s1, sizeof(s1));
        }
#line 123
        if (tmo == 0) {
#line 123
          tmp___3 = "Received IGMPv1 report from";
        } else {
#line 123
          tmp___3 = "Received IGMPv2 report from";
        }
        {
#line 123
        logit(4, 0, "%s %s on vif %d, %s", tmp___3, tmp___2, (int )vifi, tmp___1);
        }
      }
    }
  }
#line 133
  if ((unsigned long )v->uv_querier == (unsigned long )((void *)0)) {
#line 133
    goto _L___1;
  } else
#line 133
  if ((v->uv_querier)->al_addr != src) {
    _L___1: /* CIL Label */ 
    {
#line 142
    tmp___8 = ntohl(src);
    }
#line 142
    if (v->uv_querier) {
      {
#line 142
      tmp___9 = ntohl((v->uv_querier)->al_addr);
#line 142
      tmp___11 = tmp___9;
      }
    } else {
      {
#line 142
      tmp___10 = ntohl(v->uv_lcl_addr);
#line 142
      tmp___11 = tmp___10;
      }
    }
#line 142
    if (tmp___8 < tmp___11) {
#line 144
      if (debug) {
#line 144
        if (debug & 112UL) {
#line 145
          if (v->uv_querier) {
            {
#line 145
            tmp___4 = inet_fmt((v->uv_querier)->al_addr, s2, sizeof(s2));
#line 145
            tmp___5 = (char const   *)tmp___4;
            }
          } else {
#line 145
            tmp___5 = "me";
          }
          {
#line 145
          tmp___6 = inet_fmt(src, s1, sizeof(s1));
#line 145
          logit(7, 0, "new querier %s (was %s) on vif %d", tmp___6, tmp___5, (int )vifi);
          }
        }
      }
#line 150
      if (! v->uv_querier) {
        {
#line 151
        tmp___7 = calloc((size_t )1, sizeof(struct listaddr ));
#line 151
        v->uv_querier = (struct listaddr *)tmp___7;
        }
#line 152
        if (! v->uv_querier) {
          {
#line 153
          logit(3, 0, "Failed calloc() in accept_membership_query()\n");
          }
#line 154
          return;
        }
#line 157
        (v->uv_querier)->al_next = (struct listaddr *)((void *)0);
#line 158
        (v->uv_querier)->al_timer = (u_long )0;
#line 159
        (v->uv_querier)->al_alu.alu_genid = (u_int32 )0;
#line 161
        (v->uv_querier)->al_pv = (u_char )0;
#line 162
        (v->uv_querier)->al_mv = (u_char )0;
#line 163
        (v->uv_querier)->al_old = (u_char )0;
#line 164
        (v->uv_querier)->al_index = (u_char )0;
#line 165
        (v->uv_querier)->al_timerid = (u_long )0;
#line 166
        (v->uv_querier)->al_query = (u_long )0;
#line 167
        (v->uv_querier)->al_flags = (u_int16 )0;
#line 169
        v->uv_flags &= 4294966271U;
      }
      {
#line 171
      (v->uv_querier)->al_addr = src;
#line 172
      time(& (v->uv_querier)->al_ctime);
      }
    }
  }
#line 179
  if (v->uv_querier) {
#line 179
    if (src == (v->uv_querier)->al_addr) {
#line 180
      (v->uv_querier)->al_timer = (u_long )0;
    }
  }
#line 187
  if (! (v->uv_flags & 8192U)) {
#line 187
    if (group != 0U) {
#line 187
      if (src != v->uv_lcl_addr) {
#line 191
        if (debug) {
#line 191
          if (debug & 112UL) {
            {
#line 192
            tmp___12 = inet_fmt(src, s1, sizeof(s1));
#line 192
            tmp___13 = inet_fmt(group, s2, sizeof(s2));
#line 192
            logit(7, 0, "%s for %s from %s on vif %d, timer %d", "Group-specific membership query",
                  tmp___13, tmp___12, (int )vifi, tmo);
            }
          }
        }
#line 198
        g = v->uv_groups;
        {
#line 198
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 198
          if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 198
            goto while_break___0;
          }
#line 199
          if (group == g->al_addr) {
#line 199
            if (g->al_query == 0UL) {
#line 201
              if (g->al_timerid) {
                {
#line 202
                tmp___14 = DeleteTimer((int )g->al_timerid);
#line 202
                g->al_timerid = (u_long )tmp___14;
                }
              }
              {
#line 203
              g->al_timer = (u_long )((2 * tmo) / 10);
#line 205
              g->al_query = (u_long )-1;
#line 206
              tmp___15 = SetTimer(vifi, g);
#line 206
              g->al_timerid = (u_long )tmp___15;
              }
#line 207
              if (debug) {
#line 207
                if (debug & 112UL) {
                  {
#line 208
                  tmp___16 = inet_fmt(group, s2, sizeof(s2));
#line 208
                  logit(7, 0, "timer for grp %s on vif %d set to %ld", tmp___16, (int )vifi,
                        g->al_timer);
                  }
                }
              }
#line 212
              goto while_break___0;
            }
          }
#line 198
          g = g->al_next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 216
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
void accept_group_report(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                         u_int32 group , int igmp_report_type ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  struct listaddr *g ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 228
  vifi = find_vif_direct_local(src);
  }
#line 228
  if ((int )vifi == 32) {
#line 229
    if (debug) {
#line 229
      if (debug & 112UL) {
        {
#line 230
        tmp = inet_fmt(src, s1, sizeof(s1));
#line 230
        logit(6, 0, "ignoring group membership report from non-adjacent host %s",
              tmp);
        }
      }
    }
#line 234
    return;
  }
#line 237
  v = & uvifs[vifi];
#line 242
  g = v->uv_groups;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 242
      goto while_break;
    }
#line 243
    if (group == g->al_addr) {
#line 244
      if (igmp_report_type == 18) {
#line 245
        g->al_old = (u_char )2;
      }
#line 247
      g->al_alu.alu_reporter = src;
#line 250
      g->al_timer = (u_long )260;
#line 251
      if (g->al_query) {
        {
#line 252
        tmp___0 = DeleteTimer((int )g->al_query);
#line 252
        g->al_query = (u_long )tmp___0;
        }
      }
#line 253
      if (g->al_timerid) {
        {
#line 254
        tmp___1 = DeleteTimer((int )g->al_timerid);
#line 254
        g->al_timerid = (u_long )tmp___1;
        }
      }
      {
#line 255
      tmp___2 = SetTimer(vifi, g);
#line 255
      g->al_timerid = (u_long )tmp___2;
#line 258
      add_leaf(vifi, (u_int32 )0, group);
      }
#line 259
      goto while_break;
    }
#line 242
    g = g->al_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  if ((unsigned long )g == (unsigned long )((void *)0)) {
    {
#line 267
    tmp___3 = calloc((size_t )1, sizeof(struct listaddr ));
#line 267
    g = (struct listaddr *)tmp___3;
    }
#line 268
    if (! g) {
      {
#line 269
      logit(3, 0, "Ran out of memory");
      }
#line 270
      return;
    }
#line 273
    g->al_addr = group;
#line 274
    if (igmp_report_type == 18) {
#line 275
      g->al_old = (u_char )2;
    } else {
#line 277
      g->al_old = (u_char )0;
    }
    {
#line 280
    g->al_query = (u_long )0;
#line 281
    g->al_timer = (u_long )260;
#line 282
    g->al_alu.alu_reporter = src;
#line 283
    tmp___4 = SetTimer(vifi, g);
#line 283
    g->al_timerid = (u_long )tmp___4;
#line 284
    g->al_next = v->uv_groups;
#line 285
    v->uv_groups = g;
#line 286
    time(& g->al_ctime);
#line 290
    add_leaf(vifi, (u_int32 )0, group);
    }
  }
#line 292
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
void accept_leave_message(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                          u_int32 group ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  struct listaddr *g ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 303
  vifi = find_vif_direct_local(src);
  }
#line 303
  if ((int )vifi == 32) {
#line 304
    if (debug) {
#line 304
      if (debug & 112UL) {
        {
#line 305
        tmp = inet_fmt(src, s1, sizeof(s1));
#line 305
        logit(6, 0, "ignoring group leave report from non-adjacent host %s", tmp);
        }
      }
    }
#line 309
    return;
  }
#line 312
  v = & uvifs[vifi];
#line 327
  g = v->uv_groups;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 327
      goto while_break;
    }
#line 328
    if (group == g->al_addr) {
#line 329
      if (debug) {
#line 329
        if (debug & 112UL) {
          {
#line 330
          logit(7, 0, "[vif.c, _accept_leave_message] %d %d \n", (int )g->al_old,
                g->al_query);
          }
        }
      }
#line 336
      if (g->al_old) {
#line 337
        return;
      }
#line 340
      if (g->al_query) {
#line 341
        return;
      }
#line 344
      if (g->al_timerid) {
        {
#line 345
        tmp___0 = DeleteTimer((int )g->al_timerid);
#line 345
        g->al_timerid = (u_long )tmp___0;
        }
      }
#line 354
      g->al_timer = (u_long )3;
#line 356
      if (v->uv_flags & 1024U) {
        {
#line 357
        send_igmp(igmp_send_buf, v->uv_lcl_addr, g->al_addr, 17, 10, g->al_addr, 0);
        }
      }
      {
#line 362
      tmp___1 = SetQueryTimer(g, vifi, 1, 10);
#line 362
      g->al_query = (u_long )tmp___1;
#line 365
      tmp___2 = SetTimer(vifi, g);
#line 365
      g->al_timerid = (u_long )tmp___2;
      }
#line 366
      goto while_break;
    }
#line 327
    g = g->al_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 375 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
static void DelVif(void *arg ) 
{ 
  cbk_t *cbk ;
  vifi_t vifi ;
  struct uvif *v ;
  struct listaddr *a ;
  struct listaddr **anp ;
  struct listaddr *g ;

  {
#line 377
  cbk = (cbk_t *)arg;
#line 378
  vifi = cbk->vifi;
#line 379
  v = & uvifs[vifi];
#line 380
  g = cbk->g;
#line 386
  if (g->al_query) {
    {
#line 387
    DeleteTimer((int )g->al_query);
    }
  }
  {
#line 389
  delete_leaf(vifi, (u_int32 )0, g->al_addr);
#line 391
  anp = & v->uv_groups;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    a = *anp;
#line 392
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 392
      goto while_break;
    }
#line 393
    if ((unsigned long )a == (unsigned long )g) {
      {
#line 394
      *anp = a->al_next;
#line 395
      free((void *)((char *)a));
      }
    } else {
#line 397
      anp = & a->al_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  free((void *)cbk);
  }
#line 402
  return;
}
}
#line 408 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
static int SetTimer(vifi_t vifi , struct listaddr *g ) 
{ 
  cbk_t *cbk ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 412
  tmp = calloc((size_t )1, sizeof(cbk_t ));
#line 412
  cbk = (cbk_t *)tmp;
  }
#line 413
  if (! cbk) {
    {
#line 414
    logit(3, 0, "Failed calloc() in SetTimer()\n");
    }
#line 415
    return (-1);
  }
  {
#line 418
  cbk->vifi = vifi;
#line 419
  cbk->g = g;
#line 421
  tmp___0 = timer_setTimer((int )g->al_timer, & DelVif, (void *)cbk);
  }
#line 421
  return (tmp___0);
}
}
#line 428 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
static int DeleteTimer(int id___0 ) 
{ 


  {
  {
#line 430
  timer_clearTimer(id___0);
  }
#line 432
  return (0);
}
}
#line 439 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
static void SendQuery(void *arg ) 
{ 
  cbk_t *cbk ;
  struct uvif *v ;

  {
#line 441
  cbk = (cbk_t *)arg;
#line 442
  v = & uvifs[cbk->vifi];
#line 444
  if (v->uv_flags & 1024U) {
    {
#line 445
    send_igmp(igmp_send_buf, v->uv_lcl_addr, (cbk->g)->al_addr, 17, cbk->q_time, (cbk->g)->al_addr,
              0);
    }
  }
  {
#line 449
  (cbk->g)->al_query = (u_long )0;
#line 450
  free((void *)cbk);
  }
#line 451
  return;
}
}
#line 457 "/home/wheatley/newnew/temp/pimd-2.1.8/igmp_proto.c"
static int SetQueryTimer(struct listaddr *g , vifi_t vifi , int to_expire , int q_time ) 
{ 
  cbk_t *cbk ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 461
  tmp = calloc((size_t )1, sizeof(cbk_t ));
#line 461
  cbk = (cbk_t *)tmp;
  }
#line 462
  if (! cbk) {
    {
#line 463
    logit(3, 0, "Failed calloc() in SetQueryTimer()\n");
    }
#line 464
    return (-1);
  }
  {
#line 467
  cbk->g = g;
#line 468
  cbk->q_time = q_time;
#line 469
  cbk->vifi = vifi;
#line 471
  tmp___0 = timer_setTimer(to_expire, & SendQuery, (void *)cbk);
  }
#line 471
  return (tmp___0);
}
}
#line 1 "/home/wheatley/newnew/temp/pimd-2.1.8/vers.c"
char todaysversion[6]  = {      (char )'2',      (char )'.',      (char )'1',      (char )'.', 
        (char )'8',      (char )'\000'};
#line 455 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 348 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char s3[19] ;
#line 80 "/home/wheatley/newnew/temp/pimd-2.1.8/trace.c"
static u_int32 oqid  =    (u_int32 )0;
#line 53 "/home/wheatley/newnew/temp/pimd-2.1.8/trace.c"
void accept_mtrace(u_int32 src , u_int32 dst , u_int32 group , char *data , u_int no ,
                   int datalen ) 
{ 
  u_char type ;
  mrtentry_t *mrt ;
  struct tr_query *qry ;
  struct tr_resp *resp ;
  int vifi ;
  char *p ;
  u_int rcount ;
  int errcode ;
  int resptype ;
  struct timeval tp ;
  struct sioc_vif_req v_req ;
  u_int32 parent_address ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  uint32_t tmp___12 ;
  vifi_t tmp___13 ;
  char *tmp___14 ;
  uint32_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  uint32_t tmp___18 ;
  vifi_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char const   *tmp___28 ;
  uint32_t tmp___29 ;

  {
  {
#line 69
  errcode = 0;
#line 77
  parent_address = (in_addr_t )0;
#line 83
  gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )0);
  }
#line 88
  if ((unsigned long )datalen == sizeof(struct tr_query )) {
#line 89
    type = (u_char )1;
#line 90
    if (debug) {
#line 90
      if (debug & 128UL) {
        {
#line 91
        tmp = inet_fmt(dst, s2, sizeof(s2));
#line 91
        tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 91
        logit(7, 0, "Initial traceroute query rcvd from %s to %s", tmp___0, tmp);
        }
      }
    }
  } else
#line 94
  if (((unsigned long )datalen - sizeof(struct tr_query )) % sizeof(struct tr_resp ) == 0UL) {
#line 95
    type = (u_char )2;
#line 96
    if (debug) {
#line 96
      if (debug & 128UL) {
        {
#line 97
        tmp___1 = inet_fmt(dst, s2, sizeof(s2));
#line 97
        tmp___2 = inet_fmt(src, s1, sizeof(s1));
#line 97
        logit(7, 0, "In-transit traceroute query rcvd from %s to %s", tmp___2, tmp___1);
        }
      }
    }
    {
#line 99
    tmp___3 = ntohl(dst);
    }
#line 99
    if ((tmp___3 & 4026531840U) == 3758096384U) {
#line 100
      if (debug) {
#line 100
        if (debug & 128UL) {
          {
#line 101
          logit(7, 0, "Dropping multicast response");
          }
        }
      }
#line 102
      return;
    }
  } else {
    {
#line 106
    tmp___4 = inet_fmt(dst, s2, sizeof(s2));
#line 106
    tmp___5 = inet_fmt(src, s1, sizeof(s1));
#line 106
    logit(4, 0, "%s from %s to %s", "Non decipherable traceroute request recieved",
          tmp___5, tmp___4);
    }
#line 109
    return;
  }
#line 112
  qry = (struct tr_query *)data;
#line 117
  rcount = (u_int )(((unsigned long )datalen - sizeof(struct tr_query )) / sizeof(struct tr_resp ));
#line 117
  if (rcount == no) {
#line 118
    if (debug) {
#line 118
      if (debug & 128UL) {
        {
#line 119
        logit(7, 0, "packet with all reports filled in");
        }
      }
    }
#line 120
    return;
  }
#line 123
  if (debug) {
#line 123
    if (debug & 128UL) {
      {
#line 124
      tmp___6 = inet_fmt(qry->tr_dst, s3, sizeof(s3));
#line 124
      tmp___7 = inet_fmt(group, s2, sizeof(s2));
#line 124
      tmp___8 = inet_fmt(qry->tr_src, s1, sizeof(s1));
#line 124
      logit(7, 0, "s: %s g: %s d: %s ", tmp___8, tmp___7, tmp___6);
#line 126
      tmp___9 = inet_fmt(qry->tr_raddr, s1, sizeof(s1));
#line 126
      logit(7, 0, "rttl: %d rd: %s", qry->q.ttl, tmp___9);
#line 128
      logit(7, 0, "rcount:%d, qid:%06x", rcount, qry->q.qid);
      }
    }
  }
  {
#line 132
  mrt = find_route(qry->tr_src, group, (u_int16 )24578, (char)0);
  }
#line 134
  if (debug) {
#line 134
    if (debug & 128UL) {
#line 135
      if ((unsigned long )mrt != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 136
        if ((unsigned long )mrt->upstream != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 137
          parent_address = (mrt->upstream)->address;
        } else {
#line 139
          parent_address = (in_addr_t )0;
        }
        {
#line 140
        tmp___10 = inet_fmt(parent_address, s1, sizeof(s1));
#line 140
        logit(7, 0, "mrt parent vif: %d rtr: %s metric: %d", (int )mrt->incoming,
              tmp___10, mrt->metric);
        }
      } else {
        {
#line 147
        logit(7, 0, "...no route");
        }
      }
    }
  }
#line 156
  if ((int )type == 1) {
#line 157
    if (oqid == qry->q.qid) {
#line 168
      if (debug) {
#line 168
        if (debug & 128UL) {
          {
#line 169
          logit(7, 0, "ignoring duplicate traceroute packet");
          }
        }
      }
#line 170
      return;
    }
#line 173
    if ((unsigned long )mrt == (unsigned long )((mrtentry_t *)((void *)0))) {
#line 174
      if (debug) {
#line 174
        if (debug & 128UL) {
          {
#line 175
          tmp___11 = inet_fmt(qry->tr_src, s1, sizeof(s1));
#line 175
          logit(7, 0, "Mcast traceroute: no route entry %s", tmp___11);
          }
        }
      }
      {
#line 177
      tmp___12 = ntohl(dst);
      }
#line 177
      if ((tmp___12 & 4026531840U) == 3758096384U) {
#line 178
        return;
      }
    }
    {
#line 180
    tmp___13 = find_vif_direct(qry->tr_dst);
#line 180
    vifi = (int )tmp___13;
    }
#line 182
    if (vifi == 32) {
#line 184
      if (debug) {
#line 184
        if (debug & 128UL) {
          {
#line 185
          tmp___14 = inet_fmt(qry->tr_dst, s1, sizeof(s1));
#line 185
          logit(7, 0, "Destination %s not an interface", tmp___14);
          }
        }
      }
      {
#line 187
      tmp___15 = ntohl(dst);
      }
#line 187
      if ((tmp___15 & 4026531840U) == 3758096384U) {
#line 188
        return;
      }
#line 189
      errcode = 1;
    } else
#line 190
    if ((unsigned long )mrt != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 190
      if (! (mrt->oifs & (unsigned long )(1 << vifi))) {
#line 191
        if (debug) {
#line 191
          if (debug & 128UL) {
            {
#line 192
            tmp___16 = inet_fmt(qry->tr_src, s2, sizeof(s2));
#line 192
            tmp___17 = inet_fmt(qry->tr_dst, s1, sizeof(s1));
#line 192
            logit(7, 0, "Destination %s not on forwarding tree for src %s", tmp___17,
                  tmp___16);
            }
          }
        }
        {
#line 195
        tmp___18 = ntohl(dst);
        }
#line 195
        if ((tmp___18 & 4026531840U) == 3758096384U) {
#line 196
          return;
        }
#line 197
        errcode = 1;
      }
    }
  } else {
    {
#line 206
    tmp___19 = find_vif_direct(src);
#line 206
    vifi = (int )tmp___19;
    }
#line 206
    if (vifi == 32) {
#line 207
      if (debug) {
#line 207
        if (debug & 128UL) {
          {
#line 208
          logit(7, 0, "Wrong interface for packet");
          }
        }
      }
#line 209
      errcode = 1;
    }
  }
#line 214
  oqid = qry->q.qid;
#line 216
  if (debug) {
#line 216
    if (debug & 128UL) {
      {
#line 217
      logit(7, 0, "Sending traceroute response");
      }
    }
  }
  {
#line 220
  p = (igmp_send_buf + 20) + 8;
#line 222
  bcopy((void const   *)data, (void *)p, (size_t )datalen);
#line 224
  p += datalen;
  }
#line 230
  if ((unsigned long )(p + sizeof(struct tr_resp )) > (unsigned long )(igmp_send_buf + 131072)) {
#line 231
    resp = (struct tr_resp *)p - 1;
#line 232
    resp->tr_rflags = (u_char )129;
#line 233
    mrt = (mrtentry_t *)((void *)0);
#line 234
    goto sendit;
  }
  {
#line 240
  resp = (struct tr_resp *)p;
#line 241
  memset((void *)resp, 0, sizeof(struct tr_resp ));
#line 242
  datalen = (int )((unsigned long )datalen + sizeof(struct tr_resp ));
#line 244
  resp->tr_qarr = htonl((uint32_t )((((unsigned long )tp.tv_sec + 2208988800UL) << 16) + (unsigned long )((tp.tv_usec << 10) / 15625L)));
#line 246
  resp->tr_rproto = (u_char )3;
  }
#line 247
  if (vifi == 32) {
#line 247
    resp->tr_outaddr = dst;
  } else {
#line 247
    resp->tr_outaddr = uvifs[vifi].uv_lcl_addr;
  }
#line 248
  if (vifi == 32) {
#line 248
    resp->tr_fttl = (u_char )0;
  } else {
#line 248
    resp->tr_fttl = uvifs[vifi].uv_threshold;
  }
#line 249
  resp->tr_rflags = (u_char )errcode;
#line 254
  v_req.vifi = (vifi_t )vifi;
#line 255
  if (vifi != 32) {
    {
#line 255
    tmp___20 = ioctl(udp_socket, 35296UL, (char *)(& v_req));
    }
#line 255
    if (tmp___20 >= 0) {
      {
#line 256
      resp->tr_vifout = htonl((uint32_t )v_req.ocount);
      }
    } else {
#line 258
      resp->tr_vifout = 4294967295U;
    }
  } else {
#line 258
    resp->tr_vifout = 4294967295U;
  }
#line 309
  if ((unsigned long )mrt == (unsigned long )((mrtentry_t *)((void *)0))) {
#line 310
    src = dst;
#line 311
    resp->tr_inaddr = (u_int32 )0;
#line 312
    resp->tr_rflags = (u_char )5;
#line 313
    resp->tr_rmtaddr = (u_int32 )0;
  } else {
    {
#line 316
    v_req.vifi = mrt->incoming;
#line 317
    tmp___21 = ioctl(udp_socket, 35296UL, (char *)(& v_req));
    }
#line 317
    if (tmp___21 >= 0) {
      {
#line 318
      resp->tr_vifin = htonl((uint32_t )v_req.icount);
      }
    } else {
#line 320
      resp->tr_vifin = 4294967295U;
    }
#line 325
    src = uvifs[mrt->incoming].uv_lcl_addr;
#line 326
    resp->tr_inaddr = src;
#line 327
    if ((unsigned long )mrt->upstream != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 328
      parent_address = (mrt->upstream)->address;
    } else {
#line 330
      parent_address = (in_addr_t )0;
    }
#line 332
    resp->tr_rmtaddr = parent_address;
#line 333
    if (! (mrt->oifs & (unsigned long )(1 << vifi))) {
#line 334
      if (debug) {
#line 334
        if (debug & 128UL) {
          {
#line 335
          tmp___22 = inet_fmt(qry->tr_src, s2, sizeof(s2));
#line 335
          tmp___23 = inet_fmt(qry->tr_dst, s1, sizeof(s1));
#line 335
          logit(7, 0, "Destination %s not on forwarding tree for src %s", tmp___23,
                tmp___22);
          }
        }
      }
#line 337
      resp->tr_rflags = (u_char )1;
    }
  }
  sendit: 
#line 354
  if (debug) {
#line 354
    if (debug & 128UL) {
      {
#line 355
      logit(7, 0, "rcount:%d, no:%d", rcount, no);
      }
    }
  }
#line 357
  if (rcount + 1U == no) {
#line 358
    resptype = 30;
#line 359
    dst = qry->tr_raddr;
  } else
#line 357
  if ((unsigned long )mrt == (unsigned long )((void *)0)) {
#line 358
    resptype = 30;
#line 359
    dst = qry->tr_raddr;
  } else
#line 357
  if (mrt->metric == 1U) {
#line 358
    resptype = 30;
#line 359
    dst = qry->tr_raddr;
  } else
#line 369
  if ((unsigned long )mrt->upstream != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 370
    parent_address = (mrt->upstream)->address;
  } else {
#line 372
    parent_address = (in_addr_t )0;
  }
  {
#line 373
  dst = parent_address;
#line 374
  resptype = 31;
#line 378
  tmp___29 = ntohl(dst);
  }
#line 378
  if ((tmp___29 & 4026531840U) == 3758096384U) {
#line 383
    if (phys_vif != -1) {
#line 384
      if (debug) {
#line 384
        if (debug & 128UL) {
          {
#line 385
          tmp___24 = inet_fmt(uvifs[phys_vif].uv_lcl_addr, s2, sizeof(s2));
#line 385
          tmp___25 = inet_fmt(dst, s1, sizeof(s1));
#line 385
          logit(7, 0, "Sending reply to %s from %s", tmp___25, tmp___24);
          }
        }
      }
      {
#line 388
      k_set_ttl(igmp_socket, (int )qry->q.ttl);
#line 389
      send_igmp(igmp_send_buf, uvifs[phys_vif].uv_lcl_addr, dst, resptype, (int )no,
                group, datalen);
#line 391
      k_set_ttl(igmp_socket, 1);
      }
    } else {
      {
#line 393
      logit(6, 0, "No enabled phyints -- %s", "dropping traceroute reply");
      }
    }
  } else {
#line 396
    if (debug) {
#line 396
      if (debug & 128UL) {
        {
#line 397
        tmp___26 = inet_fmt(src, s2, sizeof(s2));
#line 397
        tmp___27 = inet_fmt(dst, s1, sizeof(s1));
        }
#line 397
        if (resptype == 30) {
#line 397
          tmp___28 = "reply";
        } else {
#line 397
          tmp___28 = "request on";
        }
        {
#line 397
        logit(7, 0, "Sending %s to %s from %s", tmp___28, tmp___27, tmp___26);
        }
      }
    }
    {
#line 401
    send_igmp(igmp_send_buf, src, dst, resptype, (int )no, group, datalen);
    }
  }
#line 403
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/pimd-2.1.8/trace.c"
void accept_neighbor_request(u_int32 src , u_int32 dst  __attribute__((__unused__)) ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  u_char *p ;
  u_char *ncount ;
  pim_nbr_entry_t *pim_nbr ;
  int datalen ;
  u_int32 temp_addr ;
  u_int32 them ;
  uint32_t tmp ;
  int tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  uint32_t tmp___12 ;

  {
#line 418
  them = src;
#line 426
  p = (u_char *)((igmp_send_buf + 20) + 8);
#line 427
  datalen = 0;
#line 429
  vifi = (vifi_t )0;
#line 429
  v = uvifs;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! ((int )vifi < (int )numvifs)) {
#line 429
      goto while_break;
    }
#line 430
    if (v->uv_flags & 512U) {
#line 431
      goto __Cont;
    }
#line 433
    ncount = (u_char *)0;
#line 436
    pim_nbr = v->uv_pim_neighbors;
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 436
      if (! ((unsigned long )pim_nbr != (unsigned long )((pim_nbr_entry_t *)((void *)0)))) {
#line 436
        goto while_break___0;
      }
#line 439
      if ((unsigned long )ncount == (unsigned long )((u_char *)0)) {
#line 439
        tmp___0 = 11;
      } else {
#line 439
        tmp___0 = 4;
      }
#line 439
      if (datalen + tmp___0 > 508) {
        {
#line 440
        tmp = htonl((uint32_t )(2 | (1 << 8)));
#line 440
        send_igmp(igmp_send_buf, (in_addr_t )0, them, 19, 4, tmp, datalen);
#line 442
        p = (u_char *)((igmp_send_buf + 20) + 8);
#line 443
        datalen = 0;
#line 444
        ncount = (u_char *)0;
        }
      }
#line 448
      if ((unsigned long )ncount == (unsigned long )((u_char *)0)) {
        {
#line 449
        temp_addr = ntohl(v->uv_lcl_addr);
#line 449
        tmp___1 = p;
#line 449
        p ++;
#line 449
        *tmp___1 = (u_char )(temp_addr >> 24);
#line 449
        tmp___2 = p;
#line 449
        p ++;
#line 449
        *tmp___2 = (u_char )((temp_addr >> 16) & 255U);
#line 449
        tmp___3 = p;
#line 449
        p ++;
#line 449
        *tmp___3 = (u_char )((temp_addr >> 8) & 255U);
#line 449
        tmp___4 = p;
#line 449
        p ++;
#line 449
        *tmp___4 = (u_char )(temp_addr & 255U);
#line 450
        tmp___5 = p;
#line 450
        p ++;
#line 450
        *tmp___5 = v->uv_metric;
#line 451
        tmp___6 = p;
#line 451
        p ++;
#line 451
        *tmp___6 = v->uv_threshold;
#line 452
        ncount = p;
#line 453
        tmp___7 = p;
#line 453
        p ++;
#line 453
        *tmp___7 = (u_char )0;
#line 454
        datalen += 7;
        }
      }
      {
#line 457
      temp_addr = ntohl(pim_nbr->address);
#line 457
      tmp___8 = p;
#line 457
      p ++;
#line 457
      *tmp___8 = (u_char )(temp_addr >> 24);
#line 457
      tmp___9 = p;
#line 457
      p ++;
#line 457
      *tmp___9 = (u_char )((temp_addr >> 16) & 255U);
#line 457
      tmp___10 = p;
#line 457
      p ++;
#line 457
      *tmp___10 = (u_char )((temp_addr >> 8) & 255U);
#line 457
      tmp___11 = p;
#line 457
      p ++;
#line 457
      *tmp___11 = (u_char )(temp_addr & 255U);
#line 458
      datalen += 4;
#line 459
      *ncount = (u_char )((int )*ncount + 1);
#line 436
      pim_nbr = pim_nbr->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 429
    vifi = (vifi_t )((int )vifi + 1);
#line 429
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  if (datalen != 0) {
    {
#line 464
    tmp___12 = htonl((uint32_t )(2 | (1 << 8)));
#line 464
    send_igmp(igmp_send_buf, (in_addr_t )0, them, 19, 4, tmp___12, datalen);
    }
  }
#line 466
  return;
}
}
#line 475 "/home/wheatley/newnew/temp/pimd-2.1.8/trace.c"
void accept_neighbor_request2(u_int32 src , u_int32 dst  __attribute__((__unused__)) ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  u_char *p ;
  u_char *ncount ;
  pim_nbr_entry_t *pim_nbr ;
  int datalen ;
  u_int32 them ;
  register u_int32 vflags ;
  register u_char rflags ;
  uint32_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  uint32_t tmp___4 ;
  int tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  uint32_t tmp___10 ;

  {
#line 483
  them = src;
#line 485
  p = (u_char *)((igmp_send_buf + 20) + 8);
#line 486
  datalen = 0;
#line 488
  vifi = (vifi_t )0;
#line 488
  v = uvifs;
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! ((int )vifi < (int )numvifs)) {
#line 488
      goto while_break;
    }
#line 489
    vflags = v->uv_flags;
#line 490
    rflags = (u_char )0;
#line 491
    if (vflags & 1U) {
#line 492
      rflags = (u_char )((int )rflags | 1);
    }
#line 493
    if (vflags & 2U) {
#line 494
      rflags = (u_char )((int )rflags | 2);
    }
#line 495
    if (vflags & 2097152U) {
#line 496
      rflags = (u_char )((int )rflags | 4);
    }
#line 497
    if (vflags & 256U) {
#line 498
      rflags = (u_char )((int )rflags | 16);
    }
#line 499
    if (vflags & 512U) {
#line 500
      rflags = (u_char )((int )rflags | 32);
    }
#line 501
    if (vflags & 1024U) {
#line 502
      rflags = (u_char )((int )rflags | 64);
    }
#line 503
    if (vflags & 4096U) {
#line 504
      rflags = (u_char )((int )rflags | 128);
    }
#line 505
    ncount = (u_char *)0;
#line 506
    pim_nbr = v->uv_pim_neighbors;
#line 507
    if ((unsigned long )pim_nbr == (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 512
      if ((int )rflags & 1) {
#line 513
        rflags = (u_char )((int )rflags | 16);
      }
#line 514
      if (datalen > 496) {
        {
#line 515
        tmp = htonl((uint32_t )(2 | (1 << 8)));
#line 515
        send_igmp(igmp_send_buf, (in_addr_t )0, them, 19, 6, tmp, datalen);
#line 517
        p = (u_char *)((igmp_send_buf + 20) + 8);
#line 518
        datalen = 0;
        }
      }
#line 520
      *((u_int *)p) = v->uv_lcl_addr;
#line 521
      p += 4;
#line 522
      tmp___0 = p;
#line 522
      p ++;
#line 522
      *tmp___0 = v->uv_metric;
#line 523
      tmp___1 = p;
#line 523
      p ++;
#line 523
      *tmp___1 = v->uv_threshold;
#line 524
      tmp___2 = p;
#line 524
      p ++;
#line 524
      *tmp___2 = rflags;
#line 525
      tmp___3 = p;
#line 525
      p ++;
#line 525
      *tmp___3 = (u_char )1;
#line 526
      *((u_int *)p) = v->uv_rmt_addr;
#line 527
      p += 4;
#line 528
      datalen += 12;
    } else {
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 530
        if (! pim_nbr) {
#line 530
          goto while_break___0;
        }
#line 532
        if ((unsigned long )ncount == (unsigned long )((u_char *)0)) {
#line 532
          tmp___5 = 12;
        } else {
#line 532
          tmp___5 = 4;
        }
#line 532
        if (datalen + tmp___5 > 508) {
          {
#line 533
          tmp___4 = htonl((uint32_t )(2 | (1 << 8)));
#line 533
          send_igmp(igmp_send_buf, (in_addr_t )0, them, 19, 6, tmp___4, datalen);
#line 535
          p = (u_char *)((igmp_send_buf + 20) + 8);
#line 536
          datalen = 0;
#line 537
          ncount = (u_char *)0;
          }
        }
#line 540
        if ((unsigned long )ncount == (unsigned long )((u_char *)0)) {
#line 541
          *((u_int *)p) = v->uv_lcl_addr;
#line 542
          p += 4;
#line 543
          tmp___6 = p;
#line 543
          p ++;
#line 543
          *tmp___6 = v->uv_metric;
#line 544
          tmp___7 = p;
#line 544
          p ++;
#line 544
          *tmp___7 = v->uv_threshold;
#line 545
          tmp___8 = p;
#line 545
          p ++;
#line 545
          *tmp___8 = rflags;
#line 546
          ncount = p;
#line 547
          tmp___9 = p;
#line 547
          p ++;
#line 547
          *tmp___9 = (u_char )0;
#line 548
          datalen += 8;
        }
#line 550
        *((u_int *)p) = pim_nbr->address;
#line 551
        p += 4;
#line 552
        datalen += 4;
#line 553
        *ncount = (u_char )((int )*ncount + 1);
#line 530
        pim_nbr = pim_nbr->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 488
    vifi = (vifi_t )((int )vifi + 1);
#line 488
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  if (datalen != 0) {
    {
#line 558
    tmp___10 = htonl((uint32_t )(2 | (1 << 8)));
#line 558
    send_igmp(igmp_send_buf, (in_addr_t )0, them, 19, 6, tmp___10, datalen);
    }
  }
#line 560
  return;
}
}
#line 42 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_probe(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ,
                        u_int32 level  __attribute__((__unused__)) ) 
{ 


  {
#line 50
  return;
}
}
#line 58 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_report(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                         u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ,
                         u_int32 level  __attribute__((__unused__)) ) 
{ 


  {
#line 66
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_info_request(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                               u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) 
{ 


  {
#line 78
  return;
}
}
#line 85 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_info_reply(u_int32 src , u_int32 dst , u_char *p  __attribute__((__unused__)) ,
                             int datalen  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 92
  if (debug) {
#line 92
    if (debug & 512UL) {
      {
#line 93
      tmp = inet_fmt(dst, s2, sizeof(s2));
#line 93
      tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 93
      logit(7, 0, "ignoring spurious DVMRP info reply from %s to %s", tmp___0, tmp);
      }
    }
  }
#line 95
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_neighbors(u_int32 src , u_int32 dst , u_char *p  __attribute__((__unused__)) ,
                            int datalen  __attribute__((__unused__)) , u_int32 level  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 109
  tmp = inet_fmt(dst, s2, sizeof(s2));
#line 109
  tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 109
  logit(6, 0, "ignoring spurious DVMRP neighbor list from %s to %s", tmp___0, tmp);
  }
#line 111
  return;
}
}
#line 117 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_neighbors2(u_int32 src , u_int32 dst , u_char *p  __attribute__((__unused__)) ,
                             int datalen  __attribute__((__unused__)) , u_int32 level  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 125
  if (debug) {
#line 125
    if (debug & 512UL) {
      {
#line 126
      tmp = inet_fmt(dst, s2, sizeof(s2));
#line 126
      tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 126
      logit(7, 0, "ignoring spurious DVMRP neighbor list2 from %s to %s", tmp___0,
            tmp);
      }
    }
  }
#line 129
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_prune(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) 
{ 


  {
#line 150
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_graft(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) 
{ 


  {
#line 174
  return;
}
}
#line 187 "/home/wheatley/newnew/temp/pimd-2.1.8/dvmrp_proto.c"
void dvmrp_accept_g_ack(u_int32 src  __attribute__((__unused__)) , u_int32 dst  __attribute__((__unused__)) ,
                        u_char *p  __attribute__((__unused__)) , int datalen  __attribute__((__unused__)) ) 
{ 


  {
#line 194
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 332 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
srcentry_t *srclist  ;
#line 333 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
grpentry_t *grplist  ;
#line 502
void init_pim_mrt(void) ;
#line 504
grpentry_t *find_group(u_int32 group ) ;
#line 505
srcentry_t *find_source(u_int32 source ) ;
#line 507
void delete_srcentry(srcentry_t *srcentry_ptr ) ;
#line 511
void delete_single_kernel_cache_addr(mrtentry_t *mrtentry_ptr , u_int32 source , u_int32 group ) ;
#line 44 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static srcentry_t *create_srcentry(u_int32 source ) ;
#line 45
static int search_srclist(u_int32 source , srcentry_t **sourceEntry ) ;
#line 46
static int search_srcmrtlink(srcentry_t *srcentry_ptr , u_int32 group , mrtentry_t **mrtPtr ) ;
#line 47
static void insert_srcmrtlink(mrtentry_t *mrtentry_new , mrtentry_t *mrtentry_prev ,
                              srcentry_t *srcentry_ptr ) ;
#line 48
static grpentry_t *create_grpentry(u_int32 group ) ;
#line 49
static int search_grplist(u_int32 group , grpentry_t **groupEntry ) ;
#line 50
static int search_grpmrtlink(grpentry_t *grpentry_ptr , u_int32 source , mrtentry_t **mrtPtr ) ;
#line 51
static void insert_grpmrtlink(mrtentry_t *mrtentry_new , mrtentry_t *mrtentry_prev ,
                              grpentry_t *grpentry_ptr ) ;
#line 52
static mrtentry_t *alloc_mrtentry(srcentry_t *srcentry_ptr , grpentry_t *grpentry_ptr ) ;
#line 53
static mrtentry_t *create_mrtentry(srcentry_t *srcentry_ptr , grpentry_t *grpentry_ptr ,
                                   u_int16 flags ) ;
#line 54
static void move_kernel_cache(mrtentry_t *mrtentry_ptr , u_int16 flags ) ;
#line 56 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void init_pim_mrt(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 63
  tmp = calloc((size_t )1, sizeof(srcentry_t ));
#line 63
  srclist = (srcentry_t *)tmp;
  }
#line 64
  if (! srclist) {
    {
#line 65
    logit(3, 0, "Ran out of memory in init_pim_mrt()");
    }
  }
  {
#line 66
  srclist->next = (struct srcentry *)((void *)0);
#line 67
  srclist->prev = (struct srcentry *)((void *)0);
#line 68
  srclist->address = (u_int32 )0;
#line 69
  srclist->mrtlink = (struct mrtentry *)((void *)0);
#line 70
  srclist->incoming = (vifi_t )32;
#line 71
  srclist->upstream = (struct pim_nbr_entry *)((void *)0);
#line 72
  srclist->metric = (u_int32 )0;
#line 73
  srclist->preference = (u_int32 )0;
#line 74
  srclist->timer = (u_int16 )0;
#line 75
  srclist->cand_rp = (struct cand_rp *)((void *)0);
#line 80
  tmp___0 = calloc((size_t )1, sizeof(grpentry_t ));
#line 80
  grplist = (grpentry_t *)tmp___0;
  }
#line 81
  if (! grplist) {
    {
#line 82
    logit(3, 0, "Ran out of memory in init_pim_mrt()");
    }
  }
#line 83
  grplist->next = (struct grpentry *)((void *)0);
#line 84
  grplist->prev = (struct grpentry *)((void *)0);
#line 85
  grplist->rpnext = (struct grpentry *)((void *)0);
#line 86
  grplist->rpprev = (struct grpentry *)((void *)0);
#line 87
  grplist->group = (u_int32 )0;
#line 88
  grplist->rpaddr = (u_int32 )0;
#line 89
  grplist->mrtlink = (struct mrtentry *)((void *)0);
#line 90
  grplist->active_rp_grp = (rp_grp_entry_t *)((void *)0);
#line 91
  grplist->grp_route = (struct mrtentry *)((void *)0);
#line 92
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
grpentry_t *find_group(u_int32 group ) 
{ 
  grpentry_t *grpentry_ptr ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 99
  tmp = ntohl(group);
  }
#line 99
  if (! ((tmp & 4026531840U) == 3758096384U)) {
#line 100
    return ((grpentry_t *)((void *)0));
  }
  {
#line 102
  tmp___0 = search_grplist(group, & grpentry_ptr);
  }
#line 102
  if (tmp___0 == 1) {
#line 104
    return (grpentry_ptr);
  }
#line 106
  return ((grpentry_t *)((void *)0));
}
}
#line 110 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
srcentry_t *find_source(u_int32 source ) 
{ 
  srcentry_t *srcentry_ptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 114
  tmp = inet_valid_host(source);
  }
#line 114
  if (! tmp) {
#line 115
    return ((srcentry_t *)((void *)0));
  }
  {
#line 117
  tmp___0 = search_srclist(source, & srcentry_ptr);
  }
#line 117
  if (tmp___0 == 1) {
#line 119
    return (srcentry_ptr);
  }
#line 121
  return ((srcentry_t *)((void *)0));
}
}
#line 125 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
mrtentry_t *find_route(u_int32 source , u_int32 group , u_int16 flags , char create ) 
{ 
  srcentry_t *srcentry_ptr ;
  grpentry_t *grpentry_ptr ;
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_ptr_wc ;
  mrtentry_t *mrtentry_ptr_pmbr ;
  mrtentry_t *mrtentry_ptr_2 ;
  rpentry_t *rpentry_ptr ;
  rp_grp_entry_t *rp_grp_entry_ptr ;
  uint32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 127
  srcentry_ptr = (srcentry_t *)((void *)0);
#line 128
  grpentry_ptr = (grpentry_t *)((void *)0);
#line 129
  mrtentry_ptr = (mrtentry_t *)((void *)0);
#line 130
  mrtentry_ptr_wc = (mrtentry_t *)((void *)0);
#line 131
  mrtentry_ptr_pmbr = (mrtentry_t *)((void *)0);
#line 132
  mrtentry_ptr_2 = (mrtentry_t *)((void *)0);
#line 133
  rpentry_ptr = (rpentry_t *)((void *)0);
#line 134
  rp_grp_entry_ptr = (rp_grp_entry_t *)((void *)0);
#line 136
  if ((int )flags & 8194) {
    {
#line 137
    tmp = ntohl(group);
    }
#line 137
    if (! ((tmp & 4026531840U) == 3758096384U)) {
#line 138
      return ((mrtentry_t *)((void *)0));
    }
  }
#line 141
  if ((int )flags & 8192) {
    {
#line 142
    tmp___0 = inet_valid_host(source);
    }
#line 142
    if (! tmp___0) {
#line 143
      return ((mrtentry_t *)((void *)0));
    }
  }
#line 146
  if ((int )create == 0) {
#line 147
    if ((int )flags & 8194) {
      {
#line 148
      tmp___1 = search_grplist(group, & grpentry_ptr);
      }
#line 148
      if (tmp___1 == 0) {
#line 150
        if ((int )flags & 16384) {
          {
#line 151
          rpentry_ptr = rp_match(group);
          }
#line 152
          if (rpentry_ptr) {
#line 153
            return (rpentry_ptr->mrtlink);
          }
        }
#line 156
        return ((mrtentry_t *)((void *)0));
      }
#line 160
      if ((int )flags & 8192) {
        {
#line 161
        tmp___2 = search_grpmrtlink(grpentry_ptr, source, & mrtentry_ptr);
        }
#line 161
        if (tmp___2 == 1) {
#line 163
          return (mrtentry_ptr);
        }
      }
#line 168
      if ((int )flags & 2) {
#line 168
        if (grpentry_ptr->grp_route) {
#line 169
          return (grpentry_ptr->grp_route);
        }
      }
    }
#line 173
    if ((int )flags & 16384) {
#line 174
      rpentry_ptr = (rpentry_t *)((void *)0);
#line 175
      if (group != 0U) {
        {
#line 176
        rpentry_ptr = rp_match(group);
        }
      } else
#line 177
      if (source != 0U) {
        {
#line 178
        rpentry_ptr = rp_find(source);
        }
      }
#line 180
      if (rpentry_ptr) {
#line 181
        return (rpentry_ptr->mrtlink);
      }
    }
#line 184
    return ((mrtentry_t *)((void *)0));
  }
#line 190
  if ((int )flags & 8194) {
    {
#line 191
    grpentry_ptr = create_grpentry(group);
    }
#line 192
    if (! grpentry_ptr) {
#line 193
      return ((mrtentry_t *)((void *)0));
    }
#line 195
    if (! grpentry_ptr->active_rp_grp) {
      {
#line 196
      rp_grp_entry_ptr = rp_grp_match(group);
      }
#line 197
      if (! rp_grp_entry_ptr) {
#line 198
        if (! grpentry_ptr->mrtlink) {
#line 198
          if (! grpentry_ptr->grp_route) {
            {
#line 200
            delete_grpentry(grpentry_ptr);
            }
          }
        }
#line 203
        return ((mrtentry_t *)((void *)0));
      }
#line 206
      rpentry_ptr = (rp_grp_entry_ptr->rp)->rpentry;
#line 207
      grpentry_ptr->active_rp_grp = rp_grp_entry_ptr;
#line 208
      grpentry_ptr->rpaddr = rpentry_ptr->address;
#line 211
      grpentry_ptr->rpnext = rp_grp_entry_ptr->grplink;
#line 212
      rp_grp_entry_ptr->grplink = grpentry_ptr;
#line 213
      if (grpentry_ptr->rpnext) {
#line 214
        (grpentry_ptr->rpnext)->rpprev = grpentry_ptr;
      }
    } else {
#line 217
      rpentry_ptr = ((grpentry_ptr->active_rp_grp)->rp)->rpentry;
    }
  }
#line 221
  mrtentry_ptr_pmbr = (mrtentry_t *)((void *)0);
#line 221
  mrtentry_ptr_wc = mrtentry_ptr_pmbr;
#line 223
  if ((int )flags & 2) {
    {
#line 225
    mrtentry_ptr_wc = create_mrtentry((srcentry_t *)((void *)0), grpentry_ptr, (u_int16 )2);
    }
#line 226
    if (! mrtentry_ptr_wc) {
#line 227
      if (! grpentry_ptr->mrtlink) {
        {
#line 229
        delete_grpentry(grpentry_ptr);
        }
      }
#line 232
      return ((mrtentry_t *)((void *)0));
    }
#line 235
    if ((int )mrtentry_ptr_wc->flags & 8) {
#line 236
      mrtentry_ptr_pmbr = rpentry_ptr->mrtlink;
#line 238
      if (mrtentry_ptr_pmbr) {
        {
#line 239
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 239
          mrtentry_ptr_wc->joined_oifs = mrtentry_ptr_pmbr->joined_oifs;
#line 239
          mrtentry_ptr_wc->oifs = mrtentry_ptr_pmbr->oifs;
#line 239
          mrtentry_ptr_wc->leaves = mrtentry_ptr_pmbr->leaves;
#line 239
          mrtentry_ptr_wc->pruned_oifs = mrtentry_ptr_pmbr->pruned_oifs;
#line 239
          mrtentry_ptr_wc->asserted_oifs = mrtentry_ptr_pmbr->asserted_oifs;
#line 239
          memcpy((void */* __restrict  */)mrtentry_ptr_wc->vif_timers, (void const   */* __restrict  */)mrtentry_ptr_pmbr->vif_timers,
                 (unsigned long )numvifs * sizeof(*(mrtentry_ptr_pmbr->vif_timers + 0)));
#line 239
          memcpy((void */* __restrict  */)mrtentry_ptr_wc->vif_deletion_delay, (void const   */* __restrict  */)mrtentry_ptr_pmbr->vif_deletion_delay,
                 (unsigned long )numvifs * sizeof(*(mrtentry_ptr_pmbr->vif_deletion_delay + 0)));
          }
#line 239
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 241
      mrtentry_ptr_wc->incoming = rpentry_ptr->incoming;
#line 242
      mrtentry_ptr_wc->upstream = rpentry_ptr->upstream;
#line 243
      mrtentry_ptr_wc->metric = rpentry_ptr->metric;
#line 244
      mrtentry_ptr_wc->preference = rpentry_ptr->preference;
#line 245
      move_kernel_cache(mrtentry_ptr_wc, (u_int16 )0);
      }
    }
#line 251
    if (! ((int )flags & 8192)) {
#line 252
      return (mrtentry_ptr_wc);
    }
  }
#line 256
  if ((int )flags & 8192) {
    {
#line 258
    srcentry_ptr = create_srcentry(source);
    }
#line 259
    if (! srcentry_ptr) {
#line 261
      if (! grpentry_ptr->grp_route) {
#line 261
        goto _L;
      } else
#line 261
      if (grpentry_ptr->grp_route) {
#line 261
        if ((int )(grpentry_ptr->grp_route)->flags & 8) {
          _L: /* CIL Label */ 
#line 261
          if (! grpentry_ptr->mrtlink) {
            {
#line 264
            delete_grpentry(grpentry_ptr);
            }
          }
        }
      }
#line 267
      return ((mrtentry_t *)((void *)0));
    }
    {
#line 270
    mrtentry_ptr = create_mrtentry(srcentry_ptr, grpentry_ptr, (u_int16 )8192);
    }
#line 271
    if (! mrtentry_ptr) {
#line 272
      if (! grpentry_ptr->grp_route) {
#line 272
        goto _L___0;
      } else
#line 272
      if (grpentry_ptr->grp_route) {
#line 272
        if ((int )(grpentry_ptr->grp_route)->flags & 8) {
          _L___0: /* CIL Label */ 
#line 272
          if (! grpentry_ptr->mrtlink) {
            {
#line 276
            delete_grpentry(grpentry_ptr);
            }
          }
        }
      }
#line 278
      if (! srcentry_ptr->mrtlink) {
        {
#line 280
        delete_srcentry(srcentry_ptr);
        }
      }
#line 283
      return ((mrtentry_t *)((void *)0));
    }
#line 286
    if ((int )mrtentry_ptr->flags & 8) {
#line 287
      mrtentry_ptr_2 = grpentry_ptr->grp_route;
#line 288
      if (! mrtentry_ptr_2) {
#line 289
        mrtentry_ptr_2 = rpentry_ptr->mrtlink;
      }
#line 292
      if (mrtentry_ptr_2) {
        {
#line 293
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 293
          mrtentry_ptr->joined_oifs = mrtentry_ptr_2->joined_oifs;
#line 293
          mrtentry_ptr->oifs = mrtentry_ptr_2->oifs;
#line 293
          mrtentry_ptr->leaves = mrtentry_ptr_2->leaves;
#line 293
          mrtentry_ptr->pruned_oifs = mrtentry_ptr_2->pruned_oifs;
#line 293
          mrtentry_ptr->asserted_oifs = mrtentry_ptr_2->asserted_oifs;
#line 293
          memcpy((void */* __restrict  */)mrtentry_ptr->vif_timers, (void const   */* __restrict  */)mrtentry_ptr_2->vif_timers,
                 (unsigned long )numvifs * sizeof(*(mrtentry_ptr_2->vif_timers + 0)));
#line 293
          memcpy((void */* __restrict  */)mrtentry_ptr->vif_deletion_delay, (void const   */* __restrict  */)mrtentry_ptr_2->vif_deletion_delay,
                 (unsigned long )numvifs * sizeof(*(mrtentry_ptr_2->vif_deletion_delay + 0)));
          }
#line 293
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 294
        if ((int )flags & 4) {
#line 296
          mrtentry_ptr->incoming = mrtentry_ptr_2->incoming;
#line 297
          mrtentry_ptr->upstream = mrtentry_ptr_2->upstream;
#line 298
          mrtentry_ptr->metric = mrtentry_ptr_2->metric;
#line 299
          mrtentry_ptr->preference = mrtentry_ptr_2->preference;
#line 300
          mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 4);
        }
      }
#line 303
      if (! ((int )mrtentry_ptr->flags & 4)) {
#line 304
        mrtentry_ptr->incoming = srcentry_ptr->incoming;
#line 305
        mrtentry_ptr->upstream = srcentry_ptr->upstream;
#line 306
        mrtentry_ptr->metric = srcentry_ptr->metric;
#line 307
        mrtentry_ptr->preference = srcentry_ptr->preference;
      }
      {
#line 309
      move_kernel_cache(mrtentry_ptr, (u_int16 )0);
      }
    }
#line 315
    return (mrtentry_ptr);
  }
#line 318
  if ((int )flags & 16384) {
#line 320
    if (group != 0U) {
      {
#line 321
      rpentry_ptr = rp_match(group);
      }
    } else
#line 322
    if (source != 0U) {
      {
#line 323
      rpentry_ptr = rp_find(source);
      }
#line 324
      if (! rpentry_ptr) {
#line 325
        return ((mrtentry_t *)((void *)0));
      }
    } else {
#line 327
      return ((mrtentry_t *)((void *)0));
    }
#line 330
    if (rpentry_ptr->mrtlink) {
#line 331
      return (rpentry_ptr->mrtlink);
    }
    {
#line 333
    mrtentry_ptr = create_mrtentry(rpentry_ptr, (grpentry_t *)((void *)0), (u_int16 )16384);
    }
#line 334
    if (! mrtentry_ptr) {
#line 335
      return ((mrtentry_t *)((void *)0));
    }
#line 337
    mrtentry_ptr->incoming = rpentry_ptr->incoming;
#line 338
    mrtentry_ptr->upstream = rpentry_ptr->upstream;
#line 339
    mrtentry_ptr->metric = rpentry_ptr->metric;
#line 340
    mrtentry_ptr->preference = rpentry_ptr->preference;
#line 342
    return (mrtentry_ptr);
  }
#line 345
  return ((mrtentry_t *)((void *)0));
}
}
#line 349 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void delete_srcentry(srcentry_t *srcentry_ptr ) 
{ 
  mrtentry_t *ptr ;
  mrtentry_t *next ;
  kernel_cache_t *prev ;
  kernel_cache_t *next___0 ;

  {
#line 354
  if (! srcentry_ptr) {
#line 355
    return;
  }
#line 358
  (srcentry_ptr->prev)->next = srcentry_ptr->next;
#line 359
  if (srcentry_ptr->next) {
#line 360
    (srcentry_ptr->next)->prev = srcentry_ptr->prev;
  }
#line 362
  ptr = srcentry_ptr->mrtlink;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ptr) {
#line 362
      goto while_break;
    }
#line 363
    next = ptr->srcnext;
#line 364
    if ((int )ptr->flags & 512) {
      {
#line 366
      delete_mrtentry_all_kernel_cache(ptr);
      }
    }
#line 368
    if (ptr->grpprev) {
#line 369
      (ptr->grpprev)->grpnext = ptr->grpnext;
    } else {
#line 371
      (ptr->group)->mrtlink = ptr->grpnext;
#line 372
      if (! ptr->grpnext) {
#line 372
        if (! (ptr->group)->grp_route) {
          {
#line 374
          delete_grpentry(ptr->group);
          }
        }
      }
    }
#line 378
    if (ptr->grpnext) {
#line 379
      (ptr->grpnext)->grpprev = ptr->grpprev;
    }
    {
#line 381
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 381
      free((void *)((char *)ptr->vif_timers));
#line 381
      free((void *)((char *)ptr->vif_deletion_delay));
#line 381
      next___0 = ptr->kernel_cache;
      }
      {
#line 381
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 381
        if (! ((unsigned long )next___0 != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 381
          goto while_break___1;
        }
        {
#line 381
        prev = next___0;
#line 381
        next___0 = next___0->next;
#line 381
        free((void *)prev);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 381
      free((void *)((char *)ptr->kernel_cache));
#line 381
      free((void *)((char *)ptr));
      }
#line 381
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 362
    ptr = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 384
  free((void *)((char *)srcentry_ptr));
  }
#line 385
  return;
}
}
#line 388 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void delete_grpentry(grpentry_t *grpentry_ptr ) 
{ 
  mrtentry_t *ptr ;
  mrtentry_t *next ;
  kernel_cache_t *prev ;
  kernel_cache_t *next___0 ;
  kernel_cache_t *prev___0 ;
  kernel_cache_t *next___1 ;

  {
#line 393
  if (! grpentry_ptr) {
#line 394
    return;
  }
#line 397
  (grpentry_ptr->prev)->next = grpentry_ptr->next;
#line 398
  if (grpentry_ptr->next) {
#line 399
    (grpentry_ptr->next)->prev = grpentry_ptr->prev;
  }
#line 401
  if (grpentry_ptr->grp_route) {
#line 402
    if ((int )(grpentry_ptr->grp_route)->flags & 512) {
      {
#line 403
      delete_mrtentry_all_kernel_cache(grpentry_ptr->grp_route);
      }
    }
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 404
      free((void *)((char *)(grpentry_ptr->grp_route)->vif_timers));
#line 404
      free((void *)((char *)(grpentry_ptr->grp_route)->vif_deletion_delay));
#line 404
      next___0 = (grpentry_ptr->grp_route)->kernel_cache;
      }
      {
#line 404
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 404
        if (! ((unsigned long )next___0 != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 404
          goto while_break___0;
        }
        {
#line 404
        prev = next___0;
#line 404
        next___0 = next___0->next;
#line 404
        free((void *)prev);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 404
      free((void *)((char *)(grpentry_ptr->grp_route)->kernel_cache));
#line 404
      free((void *)((char *)grpentry_ptr->grp_route));
      }
#line 404
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 408
  if ((unsigned long )grpentry_ptr->active_rp_grp != (unsigned long )((void *)0)) {
#line 409
    if ((unsigned long )grpentry_ptr->rpnext != (unsigned long )((void *)0)) {
#line 410
      (grpentry_ptr->rpnext)->rpprev = grpentry_ptr->rpprev;
    }
#line 412
    if ((unsigned long )grpentry_ptr->rpprev != (unsigned long )((void *)0)) {
#line 413
      (grpentry_ptr->rpprev)->rpnext = grpentry_ptr->rpnext;
    } else {
#line 415
      (grpentry_ptr->active_rp_grp)->grplink = grpentry_ptr->rpnext;
    }
  }
#line 418
  ptr = grpentry_ptr->mrtlink;
  {
#line 418
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 418
    if (! ptr) {
#line 418
      goto while_break___1;
    }
#line 419
    next = ptr->grpnext;
#line 420
    if ((int )ptr->flags & 512) {
      {
#line 422
      delete_mrtentry_all_kernel_cache(ptr);
      }
    }
#line 424
    if (ptr->srcprev) {
#line 425
      (ptr->srcprev)->srcnext = ptr->srcnext;
    } else {
#line 427
      (ptr->source)->mrtlink = ptr->srcnext;
#line 428
      if (! ptr->srcnext) {
        {
#line 430
        delete_srcentry(ptr->source);
        }
      }
    }
#line 434
    if (ptr->srcnext) {
#line 435
      (ptr->srcnext)->srcprev = ptr->srcprev;
    }
    {
#line 437
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 437
      free((void *)((char *)ptr->vif_timers));
#line 437
      free((void *)((char *)ptr->vif_deletion_delay));
#line 437
      next___1 = ptr->kernel_cache;
      }
      {
#line 437
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 437
        if (! ((unsigned long )next___1 != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 437
          goto while_break___3;
        }
        {
#line 437
        prev___0 = next___1;
#line 437
        next___1 = next___1->next;
#line 437
        free((void *)prev___0);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 437
      free((void *)((char *)ptr->kernel_cache));
#line 437
      free((void *)((char *)ptr));
      }
#line 437
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 418
    ptr = next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 440
  free((void *)((char *)grpentry_ptr));
  }
#line 441
  return;
}
}
#line 444 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void delete_mrtentry(mrtentry_t *mrtentry_ptr ) 
{ 
  grpentry_t *grpentry_ptr ;
  mrtentry_t *mrtentry_wc ;
  mrtentry_t *mrtentry_rp ;
  kernel_cache_t *prev ;
  kernel_cache_t *next ;

  {
#line 450
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 451
    return;
  }
#line 454
  if ((int )mrtentry_ptr->flags & 512) {
    {
#line 455
    delete_mrtentry_all_kernel_cache(mrtentry_ptr);
    }
  }
#line 462
  if ((int )mrtentry_ptr->flags & 16384) {
#line 464
    (mrtentry_ptr->source)->mrtlink = (struct mrtentry *)((void *)0);
  } else
#line 465
  if ((int )mrtentry_ptr->flags & 8192) {
#line 469
    if ((unsigned long )mrtentry_ptr->grpprev != (unsigned long )((void *)0)) {
#line 470
      (mrtentry_ptr->grpprev)->grpnext = mrtentry_ptr->grpnext;
    } else {
#line 472
      (mrtentry_ptr->group)->mrtlink = mrtentry_ptr->grpnext;
#line 473
      if ((unsigned long )mrtentry_ptr->grpnext == (unsigned long )((void *)0)) {
#line 477
        mrtentry_rp = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
#line 478
        mrtentry_wc = (mrtentry_ptr->group)->grp_route;
#line 479
        if ((unsigned long )mrtentry_rp != (unsigned long )((void *)0)) {
#line 480
          mrtentry_rp->flags = (u_int16 )((int )mrtentry_rp->flags & -32769);
        }
#line 482
        if ((unsigned long )mrtentry_wc != (unsigned long )((void *)0)) {
#line 483
          mrtentry_wc->flags = (u_int16 )((int )mrtentry_wc->flags & -32769);
        } else {
          {
#line 488
          delete_grpentry(mrtentry_ptr->group);
          }
        }
      }
    }
#line 492
    if ((unsigned long )mrtentry_ptr->grpnext != (unsigned long )((void *)0)) {
#line 493
      (mrtentry_ptr->grpnext)->grpprev = mrtentry_ptr->grpprev;
    }
#line 496
    if ((unsigned long )mrtentry_ptr->srcprev != (unsigned long )((void *)0)) {
#line 497
      (mrtentry_ptr->srcprev)->srcnext = mrtentry_ptr->srcnext;
    } else {
#line 499
      (mrtentry_ptr->source)->mrtlink = mrtentry_ptr->srcnext;
#line 500
      if ((unsigned long )mrtentry_ptr->srcnext == (unsigned long )((void *)0)) {
        {
#line 502
        delete_srcentry(mrtentry_ptr->source);
        }
      }
    }
#line 506
    if ((unsigned long )mrtentry_ptr->srcnext != (unsigned long )((void *)0)) {
#line 507
      (mrtentry_ptr->srcnext)->srcprev = mrtentry_ptr->srcprev;
    }
  } else {
#line 510
    grpentry_ptr = mrtentry_ptr->group;
#line 511
    grpentry_ptr->grp_route = (struct mrtentry *)((void *)0);
#line 513
    if ((unsigned long )grpentry_ptr->mrtlink == (unsigned long )((void *)0)) {
      {
#line 515
      delete_grpentry(grpentry_ptr);
      }
    }
  }
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 518
    free((void *)((char *)mrtentry_ptr->vif_timers));
#line 518
    free((void *)((char *)mrtentry_ptr->vif_deletion_delay));
#line 518
    next = mrtentry_ptr->kernel_cache;
    }
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 518
      if (! ((unsigned long )next != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 518
        goto while_break___0;
      }
      {
#line 518
      prev = next;
#line 518
      next = next->next;
#line 518
      free((void *)prev);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 518
    free((void *)((char *)mrtentry_ptr->kernel_cache));
#line 518
    free((void *)((char *)mrtentry_ptr));
    }
#line 518
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  return;
}
}
#line 522 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static int search_srclist(u_int32 source , srcentry_t **sourceEntry ) 
{ 
  srcentry_t *s_prev ;
  srcentry_t *s ;
  u_int32 source_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 525
  tmp = ntohl(source);
#line 525
  source_h = tmp;
#line 527
  s_prev = srclist;
#line 527
  s = s_prev->next;
  }
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 527
      goto while_break;
    }
    {
#line 531
    tmp___0 = ntohl(s->address);
    }
#line 531
    if (tmp___0 < source_h) {
#line 532
      goto __Cont;
    }
#line 534
    if (s->address == source) {
#line 535
      *sourceEntry = s;
#line 536
      return (1);
    }
#line 538
    goto while_break;
    __Cont: /* CIL Label */ 
#line 527
    s_prev = s;
#line 527
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  *sourceEntry = s_prev;
#line 542
  return (0);
}
}
#line 546 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static int search_grplist(u_int32 group , grpentry_t **groupEntry ) 
{ 
  grpentry_t *g_prev ;
  grpentry_t *g ;
  u_int32 group_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 549
  tmp = ntohl(group);
#line 549
  group_h = tmp;
#line 551
  g_prev = grplist;
#line 551
  g = g_prev->next;
  }
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 551
    if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 551
      goto while_break;
    }
    {
#line 555
    tmp___0 = ntohl(g->group);
    }
#line 555
    if (tmp___0 < group_h) {
#line 556
      goto __Cont;
    }
#line 557
    if (g->group == group) {
#line 558
      *groupEntry = g;
#line 559
      return (1);
    }
#line 561
    goto while_break;
    __Cont: /* CIL Label */ 
#line 551
    g_prev = g;
#line 551
    g = g->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  *groupEntry = g_prev;
#line 565
  return (0);
}
}
#line 569 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static srcentry_t *create_srcentry(u_int32 source ) 
{ 
  srcentry_t *srcentry_ptr ;
  srcentry_t *srcentry_prev ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 574
  tmp = search_srclist(source, & srcentry_prev);
  }
#line 574
  if (tmp == 1) {
#line 575
    return (srcentry_prev);
  }
  {
#line 577
  tmp___0 = calloc((size_t )1, sizeof(srcentry_t ));
#line 577
  srcentry_ptr = (srcentry_t *)tmp___0;
  }
#line 578
  if (! srcentry_ptr) {
    {
#line 579
    tmp___1 = inet_fmt(source, s1, sizeof(s1));
#line 579
    logit(4, 0, "Memory allocation error for srcentry %s", tmp___1);
    }
#line 581
    return ((srcentry_t *)((void *)0));
  }
  {
#line 584
  srcentry_ptr->address = source;
#line 589
  tmp___2 = set_incoming(srcentry_ptr, 1);
  }
#line 589
  if (tmp___2 == 0) {
    {
#line 590
    free((void *)((char *)srcentry_ptr));
    }
#line 591
    return ((srcentry_t *)((void *)0));
  }
#line 594
  srcentry_ptr->timer = (u_int16 )0;
#line 595
  srcentry_ptr->mrtlink = (struct mrtentry *)((void *)0);
#line 596
  srcentry_ptr->cand_rp = (struct cand_rp *)((void *)0);
#line 597
  srcentry_ptr->next = srcentry_prev->next;
#line 598
  srcentry_prev->next = srcentry_ptr;
#line 599
  srcentry_ptr->prev = srcentry_prev;
#line 600
  if (srcentry_ptr->next) {
#line 601
    (srcentry_ptr->next)->prev = srcentry_ptr;
  }
#line 603
  if (debug) {
#line 603
    if (debug & 4096UL) {
      {
#line 604
      tmp___3 = inet_fmt(source, s1, sizeof(s1));
#line 604
      logit(7, 0, "create source entry, source %s", tmp___3);
      }
    }
  }
#line 608
  return (srcentry_ptr);
}
}
#line 612 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static grpentry_t *create_grpentry(u_int32 group ) 
{ 
  grpentry_t *grpentry_ptr ;
  grpentry_t *grpentry_prev ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 619
  tmp = search_grplist(group, & grpentry_prev);
  }
#line 619
  if (tmp == 1) {
#line 620
    return (grpentry_prev);
  }
  {
#line 622
  tmp___0 = calloc((size_t )1, sizeof(grpentry_t ));
#line 622
  grpentry_ptr = (grpentry_t *)tmp___0;
  }
#line 623
  if (! grpentry_ptr) {
    {
#line 624
    tmp___1 = inet_fmt(group, s1, sizeof(s1));
#line 624
    logit(4, 0, "Memory allocation error for grpentry %s", tmp___1);
    }
#line 626
    return ((grpentry_t *)((void *)0));
  }
#line 635
  grpentry_ptr->group = group;
#line 636
  grpentry_ptr->rpaddr = (u_int32 )0;
#line 637
  grpentry_ptr->mrtlink = (struct mrtentry *)((void *)0);
#line 638
  grpentry_ptr->active_rp_grp = (rp_grp_entry_t *)((void *)0);
#line 639
  grpentry_ptr->grp_route = (struct mrtentry *)((void *)0);
#line 640
  grpentry_ptr->rpnext = (struct grpentry *)((void *)0);
#line 641
  grpentry_ptr->rpprev = (struct grpentry *)((void *)0);
#line 644
  grpentry_ptr->next = grpentry_prev->next;
#line 645
  grpentry_prev->next = grpentry_ptr;
#line 646
  grpentry_ptr->prev = grpentry_prev;
#line 647
  if (grpentry_ptr->next) {
#line 648
    (grpentry_ptr->next)->prev = grpentry_ptr;
  }
#line 650
  if (debug) {
#line 650
    if (debug & 4096UL) {
      {
#line 651
      tmp___2 = inet_fmt(group, s1, sizeof(s1));
#line 651
      logit(7, 0, "create group entry, group %s", tmp___2);
      }
    }
  }
#line 654
  return (grpentry_ptr);
}
}
#line 663 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static int search_srcmrtlink(srcentry_t *srcentry_ptr , u_int32 group , mrtentry_t **mrtPtr ) 
{ 
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *m_prev ;
  u_int32 group_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 666
  m_prev = (mrtentry_t *)((void *)0);
#line 667
  tmp = ntohl(group);
#line 667
  group_h = tmp;
#line 669
  mrtentry_ptr = srcentry_ptr->mrtlink;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! ((unsigned long )mrtentry_ptr != (unsigned long )((void *)0))) {
#line 669
      goto while_break;
    }
    {
#line 675
    tmp___0 = ntohl((mrtentry_ptr->group)->group);
    }
#line 675
    if (tmp___0 < group_h) {
#line 676
      goto __Cont;
    }
#line 678
    if ((mrtentry_ptr->group)->group == group) {
#line 679
      *mrtPtr = mrtentry_ptr;
#line 680
      return (1);
    }
#line 683
    goto while_break;
    __Cont: /* CIL Label */ 
#line 669
    m_prev = mrtentry_ptr;
#line 669
    mrtentry_ptr = mrtentry_ptr->srcnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  *mrtPtr = m_prev;
#line 688
  return (0);
}
}
#line 697 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static int search_grpmrtlink(grpentry_t *grpentry_ptr , u_int32 source , mrtentry_t **mrtPtr ) 
{ 
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *m_prev ;
  u_int32 source_h ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 700
  m_prev = (mrtentry_t *)((void *)0);
#line 701
  tmp = ntohl(source);
#line 701
  source_h = tmp;
#line 703
  mrtentry_ptr = grpentry_ptr->mrtlink;
  }
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! ((unsigned long )mrtentry_ptr != (unsigned long )((void *)0))) {
#line 703
      goto while_break;
    }
    {
#line 709
    tmp___0 = ntohl((mrtentry_ptr->source)->address);
    }
#line 709
    if (tmp___0 < source_h) {
#line 710
      goto __Cont;
    }
#line 712
    if (source == (mrtentry_ptr->source)->address) {
#line 713
      *mrtPtr = mrtentry_ptr;
#line 714
      return (1);
    }
#line 717
    goto while_break;
    __Cont: /* CIL Label */ 
#line 703
    m_prev = mrtentry_ptr;
#line 703
    mrtentry_ptr = mrtentry_ptr->grpnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  *mrtPtr = m_prev;
#line 722
  return (0);
}
}
#line 726 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static void insert_srcmrtlink(mrtentry_t *mrtentry_new , mrtentry_t *mrtentry_prev ,
                              srcentry_t *srcentry_ptr ) 
{ 


  {
#line 728
  if ((unsigned long )mrtentry_prev == (unsigned long )((void *)0)) {
#line 730
    mrtentry_new->srcnext = srcentry_ptr->mrtlink;
#line 731
    mrtentry_new->srcprev = (struct mrtentry *)((void *)0);
#line 732
    srcentry_ptr->mrtlink = mrtentry_new;
  } else {
#line 735
    mrtentry_new->srcnext = mrtentry_prev->srcnext;
#line 736
    mrtentry_new->srcprev = mrtentry_prev;
#line 737
    mrtentry_prev->srcnext = mrtentry_new;
  }
#line 740
  if ((unsigned long )mrtentry_new->srcnext != (unsigned long )((void *)0)) {
#line 741
    (mrtentry_new->srcnext)->srcprev = mrtentry_new;
  }
#line 742
  return;
}
}
#line 745 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static void insert_grpmrtlink(mrtentry_t *mrtentry_new , mrtentry_t *mrtentry_prev ,
                              grpentry_t *grpentry_ptr ) 
{ 


  {
#line 747
  if ((unsigned long )mrtentry_prev == (unsigned long )((void *)0)) {
#line 749
    mrtentry_new->grpnext = grpentry_ptr->mrtlink;
#line 750
    mrtentry_new->grpprev = (struct mrtentry *)((void *)0);
#line 751
    grpentry_ptr->mrtlink = mrtentry_new;
  } else {
#line 754
    mrtentry_new->grpnext = mrtentry_prev->grpnext;
#line 755
    mrtentry_new->grpprev = mrtentry_prev;
#line 756
    mrtentry_prev->grpnext = mrtentry_new;
  }
#line 759
  if ((unsigned long )mrtentry_new->grpnext != (unsigned long )((void *)0)) {
#line 760
    (mrtentry_new->grpnext)->grpprev = mrtentry_new;
  }
#line 761
  return;
}
}
#line 764 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static mrtentry_t *alloc_mrtentry(srcentry_t *srcentry_ptr , grpentry_t *grpentry_ptr ) 
{ 
  mrtentry_t *mrtentry_ptr ;
  u_int16 i ;
  u_int16 *i_ptr ;
  u_int8 vif_numbers ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  kernel_cache_t *prev ;
  kernel_cache_t *next ;

  {
  {
#line 770
  tmp = calloc((size_t )1, sizeof(mrtentry_t ));
#line 770
  mrtentry_ptr = (mrtentry_t *)tmp;
  }
#line 771
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
    {
#line 772
    logit(4, 0, "alloc_mrtentry(): out of memory");
    }
#line 773
    return ((mrtentry_t *)((void *)0));
  }
  {
#line 780
  mrtentry_ptr->source = srcentry_ptr;
#line 781
  mrtentry_ptr->group = grpentry_ptr;
#line 782
  mrtentry_ptr->incoming = (vifi_t )32;
#line 783
  mrtentry_ptr->joined_oifs = (vifbitmap_t )0;
#line 784
  mrtentry_ptr->leaves = (vifbitmap_t )0;
#line 785
  mrtentry_ptr->pruned_oifs = (vifbitmap_t )0;
#line 786
  mrtentry_ptr->asserted_oifs = (vifbitmap_t )0;
#line 787
  mrtentry_ptr->oifs = (vifbitmap_t )0;
#line 788
  mrtentry_ptr->upstream = (struct pim_nbr_entry *)((void *)0);
#line 789
  mrtentry_ptr->metric = (u_int32 )0;
#line 790
  mrtentry_ptr->preference = (u_int32 )0;
#line 791
  mrtentry_ptr->pmbr_addr = (u_int32 )0;
#line 808
  tmp___0 = calloc((size_t )1, sizeof(u_int16 ) * (unsigned long )total_interfaces);
#line 808
  mrtentry_ptr->vif_timers = (u_int16 *)tmp___0;
#line 809
  tmp___1 = calloc((size_t )1, sizeof(u_int16 ) * (unsigned long )total_interfaces);
#line 809
  mrtentry_ptr->vif_deletion_delay = (u_int16 *)tmp___1;
#line 810
  vif_numbers = (u_int8 )total_interfaces;
  }
#line 812
  if ((unsigned long )mrtentry_ptr->vif_timers == (unsigned long )((void *)0)) {
#line 812
    goto _L;
  } else
#line 812
  if ((unsigned long )mrtentry_ptr->vif_deletion_delay == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 814
    logit(4, 0, "alloc_mrtentry(): out of memory");
    }
    {
#line 815
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 815
      free((void *)((char *)mrtentry_ptr->vif_timers));
#line 815
      free((void *)((char *)mrtentry_ptr->vif_deletion_delay));
#line 815
      next = mrtentry_ptr->kernel_cache;
      }
      {
#line 815
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 815
        if (! ((unsigned long )next != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 815
          goto while_break___0;
        }
        {
#line 815
        prev = next;
#line 815
        next = next->next;
#line 815
        free((void *)prev);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 815
      free((void *)((char *)mrtentry_ptr->kernel_cache));
#line 815
      free((void *)((char *)mrtentry_ptr));
      }
#line 815
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 816
    return ((mrtentry_t *)((void *)0));
  }
#line 820
  i = (u_int16 )0;
#line 820
  i_ptr = mrtentry_ptr->vif_timers;
  {
#line 820
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 820
    if (! ((int )i < (int )vif_numbers)) {
#line 820
      goto while_break___1;
    }
#line 821
    *i_ptr = (u_int16 )0;
#line 820
    i = (u_int16 )((int )i + 1);
#line 820
    i_ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 823
  i = (u_int16 )0;
#line 823
  i_ptr = mrtentry_ptr->vif_deletion_delay;
  {
#line 823
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 823
    if (! ((int )i < (int )vif_numbers)) {
#line 823
      goto while_break___2;
    }
#line 824
    *i_ptr = (u_int16 )0;
#line 823
    i = (u_int16 )((int )i + 1);
#line 823
    i_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 827
  mrtentry_ptr->flags = (u_int16 )8;
#line 828
  mrtentry_ptr->timer = (u_int16 )0;
#line 829
  mrtentry_ptr->jp_timer = (u_int16 )0;
#line 830
  mrtentry_ptr->rs_timer = (u_int16 )0;
#line 831
  mrtentry_ptr->assert_timer = (u_int )0;
#line 832
  mrtentry_ptr->assert_rate_timer = (u_int )0;
#line 833
  mrtentry_ptr->kernel_cache = (struct kernel_cache *)((void *)0);
#line 835
  return (mrtentry_ptr);
}
}
#line 839 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static mrtentry_t *create_mrtentry(srcentry_t *srcentry_ptr , grpentry_t *grpentry_ptr ,
                                   u_int16 flags ) 
{ 
  mrtentry_t *r_new ;
  mrtentry_t *r_grp_insert ;
  mrtentry_t *r_src_insert ;
  u_int32 source ;
  u_int32 group ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 846
  if ((int )flags & 8192) {
    {
#line 848
    source = srcentry_ptr->address;
#line 849
    group = grpentry_ptr->group;
#line 851
    tmp = search_grpmrtlink(grpentry_ptr, source, & r_grp_insert);
    }
#line 851
    if (tmp == 1) {
#line 852
      return (r_grp_insert);
    }
    {
#line 854
    tmp___2 = search_srcmrtlink(srcentry_ptr, group, & r_src_insert);
    }
#line 854
    if (tmp___2 == 1) {
      {
#line 859
      tmp___0 = inet_fmt(group, s2, sizeof(s2));
#line 859
      tmp___1 = inet_fmt(source, s1, sizeof(s1));
#line 859
      logit(3, 0, "MRT inconsistency for src %s and grp %s\n", tmp___1, tmp___0);
      }
#line 862
      return ((mrtentry_t *)((void *)0));
    }
    {
#line 867
    r_new = alloc_mrtentry(srcentry_ptr, grpentry_ptr);
    }
#line 868
    if ((unsigned long )r_new == (unsigned long )((void *)0)) {
#line 869
      return ((mrtentry_t *)((void *)0));
    }
    {
#line 875
    insert_grpmrtlink(r_new, r_grp_insert, grpentry_ptr);
#line 876
    insert_srcmrtlink(r_new, r_src_insert, srcentry_ptr);
#line 877
    r_new->flags = (u_int16 )((int )r_new->flags | 8192);
    }
#line 878
    return (r_new);
  }
#line 881
  if ((int )flags & 2) {
#line 883
    if ((unsigned long )grpentry_ptr->grp_route != (unsigned long )((void *)0)) {
#line 884
      return (grpentry_ptr->grp_route);
    }
    {
#line 885
    r_new = alloc_mrtentry(srcentry_ptr, grpentry_ptr);
    }
#line 886
    if ((unsigned long )r_new == (unsigned long )((void *)0)) {
#line 887
      return ((mrtentry_t *)((void *)0));
    }
#line 888
    grpentry_ptr->grp_route = r_new;
#line 889
    r_new->flags = (u_int16 )((int )r_new->flags | 6);
#line 890
    return (r_new);
  }
#line 893
  if ((int )flags & 16384) {
#line 895
    if ((unsigned long )srcentry_ptr->mrtlink != (unsigned long )((void *)0)) {
#line 896
      return (srcentry_ptr->mrtlink);
    }
    {
#line 897
    r_new = alloc_mrtentry(srcentry_ptr, grpentry_ptr);
    }
#line 898
    if ((unsigned long )r_new == (unsigned long )((void *)0)) {
#line 899
      return ((mrtentry_t *)((void *)0));
    }
#line 900
    srcentry_ptr->mrtlink = r_new;
#line 901
    r_new->flags = (u_int16 )((int )r_new->flags | 16388);
#line 902
    return (r_new);
  }
#line 905
  return ((mrtentry_t *)((void *)0));
}
}
#line 912 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void delete_mrtentry_all_kernel_cache(mrtentry_t *mrtentry_ptr ) 
{ 
  kernel_cache_t *kernel_cache_prev ;
  kernel_cache_t *kernel_cache_ptr ;

  {
#line 917
  if (! ((int )mrtentry_ptr->flags & 512)) {
#line 918
    return;
  }
#line 922
  kernel_cache_ptr = mrtentry_ptr->kernel_cache;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 922
      goto while_break;
    }
    {
#line 923
    kernel_cache_prev = kernel_cache_ptr;
#line 924
    kernel_cache_ptr = kernel_cache_ptr->next;
#line 925
    k_del_mfc(igmp_socket, kernel_cache_prev->source, kernel_cache_prev->group);
#line 927
    free((void *)((char *)kernel_cache_prev));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 929
  mrtentry_ptr->kernel_cache = (struct kernel_cache *)((void *)0);
#line 932
  mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -33281);
#line 933
  return;
}
}
#line 936 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void delete_single_kernel_cache(mrtentry_t *mrtentry_ptr , kernel_cache_t *kernel_cache_ptr ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 938
  if ((unsigned long )kernel_cache_ptr->prev == (unsigned long )((void *)0)) {
#line 939
    mrtentry_ptr->kernel_cache = kernel_cache_ptr->next;
#line 940
    if ((unsigned long )mrtentry_ptr->kernel_cache == (unsigned long )((void *)0)) {
#line 941
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -33281);
    }
  } else {
#line 943
    (kernel_cache_ptr->prev)->next = kernel_cache_ptr->next;
  }
#line 946
  if ((unsigned long )kernel_cache_ptr->next != (unsigned long )((void *)0)) {
#line 947
    (kernel_cache_ptr->next)->prev = kernel_cache_ptr->prev;
  }
#line 949
  if (debug) {
#line 949
    if (debug & 4096UL) {
      {
#line 950
      tmp = inet_fmt(kernel_cache_ptr->group, s2, sizeof(s2));
#line 950
      tmp___0 = inet_fmt(kernel_cache_ptr->source, s1, sizeof(s1));
#line 950
      logit(7, 0, "Deleting MFC entry for source %s and group %s", tmp___0, tmp);
      }
    }
  }
  {
#line 955
  k_del_mfc(igmp_socket, kernel_cache_ptr->source, kernel_cache_ptr->group);
#line 956
  free((void *)((char *)kernel_cache_ptr));
  }
#line 957
  return;
}
}
#line 960 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void delete_single_kernel_cache_addr(mrtentry_t *mrtentry_ptr , u_int32 source , u_int32 group ) 
{ 
  u_int32 source_h ;
  u_int32 group_h ;
  kernel_cache_t *kernel_cache_ptr ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 966
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 967
    return;
  }
  {
#line 969
  source_h = ntohl(source);
#line 970
  group_h = ntohl(group);
#line 973
  kernel_cache_ptr = mrtentry_ptr->kernel_cache;
  }
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 973
      goto while_break;
    }
    {
#line 976
    tmp = ntohl(kernel_cache_ptr->group);
    }
#line 976
    if (tmp < group_h) {
#line 977
      goto __Cont;
    }
    {
#line 978
    tmp___0 = ntohl(kernel_cache_ptr->group);
    }
#line 978
    if (tmp___0 > group_h) {
#line 979
      return;
    }
    {
#line 980
    tmp___1 = ntohl(kernel_cache_ptr->source);
    }
#line 980
    if (tmp___1 < source_h) {
#line 981
      goto __Cont;
    }
    {
#line 982
    tmp___2 = ntohl(kernel_cache_ptr->source);
    }
#line 982
    if (tmp___2 > source_h) {
#line 983
      return;
    }
#line 986
    goto while_break;
    __Cont: /* CIL Label */ 
#line 973
    kernel_cache_ptr = kernel_cache_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 989
  if ((unsigned long )kernel_cache_ptr == (unsigned long )((void *)0)) {
#line 990
    return;
  }
#line 993
  if ((unsigned long )kernel_cache_ptr->prev == (unsigned long )((void *)0)) {
#line 994
    mrtentry_ptr->kernel_cache = kernel_cache_ptr->next;
#line 995
    if ((unsigned long )mrtentry_ptr->kernel_cache == (unsigned long )((void *)0)) {
#line 996
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -33281);
    }
  } else {
#line 998
    (kernel_cache_ptr->prev)->next = kernel_cache_ptr->next;
  }
#line 1001
  if ((unsigned long )kernel_cache_ptr->next != (unsigned long )((void *)0)) {
#line 1002
    (kernel_cache_ptr->next)->prev = kernel_cache_ptr->prev;
  }
#line 1004
  if (debug) {
#line 1004
    if (debug & 4096UL) {
      {
#line 1005
      tmp___3 = inet_fmt(kernel_cache_ptr->group, s2, sizeof(s2));
#line 1005
      tmp___4 = inet_fmt(kernel_cache_ptr->source, s1, sizeof(s1));
#line 1005
      logit(7, 0, "Deleting MFC entry for source %s and group %s", tmp___4, tmp___3);
      }
    }
  }
  {
#line 1010
  k_del_mfc(igmp_socket, kernel_cache_ptr->source, kernel_cache_ptr->group);
#line 1011
  free((void *)((char *)kernel_cache_ptr));
  }
#line 1012
  return;
}
}
#line 1019 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
void add_kernel_cache(mrtentry_t *mrtentry_ptr , u_int32 source , u_int32 group ,
                      u_int16 flags ) 
{ 
  u_int32 source_h ;
  u_int32 group_h ;
  kernel_cache_t *kernel_cache_next ;
  kernel_cache_t *kernel_cache_prev ;
  kernel_cache_t *kernel_cache_new ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  void *tmp___4 ;

  {
#line 1027
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 1028
    return;
  }
  {
#line 1030
  move_kernel_cache(mrtentry_ptr, flags);
  }
#line 1032
  if ((int )mrtentry_ptr->flags & 8192) {
#line 1034
    if ((int )mrtentry_ptr->flags & 512) {
#line 1035
      return;
    }
    {
#line 1037
    tmp = calloc((size_t )1, sizeof(kernel_cache_t ));
#line 1037
    kernel_cache_new = (kernel_cache_t *)tmp;
#line 1038
    kernel_cache_new->next = (struct kernel_cache *)((void *)0);
#line 1039
    kernel_cache_new->prev = (struct kernel_cache *)((void *)0);
#line 1040
    kernel_cache_new->source = source;
#line 1041
    kernel_cache_new->group = group;
#line 1042
    kernel_cache_new->sg_count.pktcnt = (u_long )0;
#line 1043
    kernel_cache_new->sg_count.bytecnt = (u_long )0;
#line 1044
    kernel_cache_new->sg_count.wrong_if = (u_long )0;
#line 1045
    mrtentry_ptr->kernel_cache = kernel_cache_new;
#line 1046
    mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 512);
    }
#line 1048
    return;
  }
  {
#line 1051
  source_h = ntohl(source);
#line 1052
  group_h = ntohl(group);
#line 1053
  kernel_cache_prev = (kernel_cache_t *)((void *)0);
#line 1055
  kernel_cache_next = mrtentry_ptr->kernel_cache;
  }
  {
#line 1055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1055
    if (! ((unsigned long )kernel_cache_next != (unsigned long )((void *)0))) {
#line 1055
      goto while_break;
    }
    {
#line 1059
    tmp___0 = ntohl(kernel_cache_next->group);
    }
#line 1059
    if (tmp___0 < group_h) {
#line 1060
      goto __Cont;
    }
    {
#line 1061
    tmp___1 = ntohl(kernel_cache_next->group);
    }
#line 1061
    if (tmp___1 > group_h) {
#line 1062
      goto while_break;
    }
    {
#line 1063
    tmp___2 = ntohl(kernel_cache_next->source);
    }
#line 1063
    if (tmp___2 < source_h) {
#line 1064
      goto __Cont;
    }
    {
#line 1065
    tmp___3 = ntohl(kernel_cache_next->source);
    }
#line 1065
    if (tmp___3 > source_h) {
#line 1066
      goto while_break;
    }
#line 1069
    return;
    __Cont: /* CIL Label */ 
#line 1055
    kernel_cache_prev = kernel_cache_next;
#line 1055
    kernel_cache_next = kernel_cache_next->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1076
  tmp___4 = calloc((size_t )1, sizeof(kernel_cache_t ));
#line 1076
  kernel_cache_new = (kernel_cache_t *)tmp___4;
  }
#line 1077
  if ((unsigned long )kernel_cache_prev != (unsigned long )((void *)0)) {
#line 1078
    kernel_cache_prev->next = kernel_cache_new;
  } else {
#line 1080
    mrtentry_ptr->kernel_cache = kernel_cache_new;
  }
#line 1082
  if ((unsigned long )kernel_cache_next != (unsigned long )((void *)0)) {
#line 1083
    kernel_cache_next->prev = kernel_cache_new;
  }
#line 1085
  kernel_cache_new->prev = kernel_cache_prev;
#line 1086
  kernel_cache_new->next = kernel_cache_next;
#line 1087
  kernel_cache_new->source = source;
#line 1088
  kernel_cache_new->group = group;
#line 1089
  kernel_cache_new->sg_count.pktcnt = (u_long )0;
#line 1090
  kernel_cache_new->sg_count.bytecnt = (u_long )0;
#line 1091
  kernel_cache_new->sg_count.wrong_if = (u_long )0;
#line 1092
  mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 512);
#line 1093
  return;
}
}
#line 1098 "/home/wheatley/newnew/temp/pimd-2.1.8/mrt.c"
static void move_kernel_cache(mrtentry_t *mrtentry_ptr , u_int16 flags ) 
{ 
  kernel_cache_t *kernel_cache_ptr ;
  kernel_cache_t *insert_kernel_cache_ptr ;
  kernel_cache_t *first_kernel_cache_ptr ;
  kernel_cache_t *last_kernel_cache_ptr ;
  kernel_cache_t *prev_kernel_cache_ptr ;
  mrtentry_t *mrtentry_pmbr ;
  mrtentry_t *mrtentry_rp ;
  u_int32 group_h ;
  u_int32 source_h ;
  int found ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 1111
  if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 1112
    return;
  }
#line 1114
  if ((int )mrtentry_ptr->flags & 16384) {
#line 1115
    return;
  }
#line 1117
  if ((int )mrtentry_ptr->flags & 2) {
    {
#line 1119
    group_h = ntohl((mrtentry_ptr->group)->group);
#line 1120
    mrtentry_pmbr = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
    }
#line 1122
    if ((unsigned long )mrtentry_pmbr == (unsigned long )((void *)0)) {
#line 1123
      return;
    }
#line 1125
    last_kernel_cache_ptr = (kernel_cache_t *)((void *)0);
#line 1125
    first_kernel_cache_ptr = last_kernel_cache_ptr;
#line 1126
    kernel_cache_ptr = mrtentry_pmbr->kernel_cache;
    {
#line 1126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1126
      if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 1126
        goto while_break;
      }
      {
#line 1133
      tmp = ntohl(kernel_cache_ptr->group);
      }
#line 1133
      if (tmp < group_h) {
#line 1134
        goto __Cont;
      }
      {
#line 1136
      tmp___0 = ntohl(kernel_cache_ptr->group);
      }
#line 1136
      if (tmp___0 != group_h) {
#line 1137
        goto while_break;
      }
#line 1140
      if ((unsigned long )first_kernel_cache_ptr == (unsigned long )((void *)0)) {
#line 1141
        last_kernel_cache_ptr = kernel_cache_ptr;
#line 1141
        first_kernel_cache_ptr = last_kernel_cache_ptr;
      } else {
#line 1144
        last_kernel_cache_ptr = kernel_cache_ptr;
      }
      __Cont: /* CIL Label */ 
#line 1126
      kernel_cache_ptr = kernel_cache_ptr->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1148
    if ((unsigned long )first_kernel_cache_ptr != (unsigned long )((void *)0)) {
#line 1150
      if ((unsigned long )first_kernel_cache_ptr->prev != (unsigned long )((void *)0)) {
#line 1151
        (first_kernel_cache_ptr->prev)->next = last_kernel_cache_ptr->next;
      } else {
#line 1154
        mrtentry_pmbr->kernel_cache = last_kernel_cache_ptr->next;
      }
#line 1157
      if ((unsigned long )last_kernel_cache_ptr->next != (unsigned long )((void *)0)) {
#line 1158
        (last_kernel_cache_ptr->next)->prev = first_kernel_cache_ptr->prev;
      }
#line 1160
      if ((unsigned long )mrtentry_pmbr->kernel_cache == (unsigned long )((void *)0)) {
#line 1161
        mrtentry_pmbr->flags = (u_int16 )((int )mrtentry_pmbr->flags & -33281);
      }
#line 1164
      prev_kernel_cache_ptr = (kernel_cache_t *)((void *)0);
#line 1165
      last_kernel_cache_ptr->next = (struct kernel_cache *)((void *)0);
#line 1166
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 512);
#line 1168
      kernel_cache_ptr = mrtentry_ptr->kernel_cache;
      {
#line 1168
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1168
        if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 1168
          goto while_break___0;
        }
#line 1170
        if ((unsigned long )first_kernel_cache_ptr == (unsigned long )((void *)0)) {
#line 1171
          goto while_break___0;
        }
        {
#line 1173
        tmp___1 = ntohl(kernel_cache_ptr->source);
#line 1173
        tmp___2 = ntohl(first_kernel_cache_ptr->source);
        }
#line 1173
        if (tmp___1 > tmp___2) {
#line 1176
          insert_kernel_cache_ptr = first_kernel_cache_ptr;
#line 1177
          first_kernel_cache_ptr = first_kernel_cache_ptr->next;
#line 1179
          if ((unsigned long )kernel_cache_ptr->prev != (unsigned long )((void *)0)) {
#line 1180
            (kernel_cache_ptr->prev)->next = insert_kernel_cache_ptr;
          } else {
#line 1182
            mrtentry_ptr->kernel_cache = insert_kernel_cache_ptr;
          }
#line 1184
          insert_kernel_cache_ptr->prev = kernel_cache_ptr->prev;
#line 1185
          insert_kernel_cache_ptr->next = kernel_cache_ptr;
#line 1186
          kernel_cache_ptr->prev = insert_kernel_cache_ptr;
        }
#line 1188
        prev_kernel_cache_ptr = kernel_cache_ptr;
#line 1189
        kernel_cache_ptr = kernel_cache_ptr->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1192
      if ((unsigned long )first_kernel_cache_ptr != (unsigned long )((void *)0)) {
#line 1194
        if ((unsigned long )prev_kernel_cache_ptr != (unsigned long )((void *)0)) {
#line 1195
          prev_kernel_cache_ptr->next = first_kernel_cache_ptr;
        } else {
#line 1197
          mrtentry_ptr->kernel_cache = first_kernel_cache_ptr;
        }
#line 1199
        first_kernel_cache_ptr->prev = prev_kernel_cache_ptr;
      }
    }
#line 1203
    return;
  }
#line 1206
  if ((int )mrtentry_ptr->flags & 8192) {
#line 1214
    mrtentry_rp = (mrtentry_ptr->group)->grp_route;
#line 1214
    if ((unsigned long )mrtentry_rp == (unsigned long )((void *)0)) {
#line 1215
      mrtentry_rp = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
    }
#line 1217
    if ((unsigned long )mrtentry_rp == (unsigned long )((void *)0)) {
#line 1218
      return;
    }
#line 1220
    if ((int )mrtentry_rp->incoming != (int )mrtentry_ptr->incoming) {
#line 1230
      if (! ((int )flags & 1)) {
#line 1231
        return;
      }
    }
    {
#line 1235
    source_h = ntohl((mrtentry_ptr->source)->address);
#line 1236
    group_h = ntohl((mrtentry_ptr->group)->group);
#line 1237
    found = 0;
#line 1238
    kernel_cache_ptr = mrtentry_rp->kernel_cache;
    }
    {
#line 1238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1238
      if (! ((unsigned long )kernel_cache_ptr != (unsigned long )((void *)0))) {
#line 1238
        goto while_break___1;
      }
      {
#line 1241
      tmp___3 = ntohl(kernel_cache_ptr->group);
      }
#line 1241
      if (tmp___3 < group_h) {
#line 1242
        goto __Cont___0;
      }
      {
#line 1244
      tmp___4 = ntohl(kernel_cache_ptr->group);
      }
#line 1244
      if (tmp___4 > group_h) {
#line 1245
        goto while_break___1;
      }
      {
#line 1247
      tmp___5 = ntohl(kernel_cache_ptr->source);
      }
#line 1247
      if (tmp___5 < source_h) {
#line 1248
        goto __Cont___0;
      }
      {
#line 1250
      tmp___6 = ntohl(kernel_cache_ptr->source);
      }
#line 1250
      if (tmp___6 > source_h) {
#line 1251
        goto while_break___1;
      }
#line 1254
      if ((unsigned long )kernel_cache_ptr->prev != (unsigned long )((void *)0)) {
#line 1255
        (kernel_cache_ptr->prev)->next = kernel_cache_ptr->next;
      } else {
#line 1257
        mrtentry_rp->kernel_cache = kernel_cache_ptr->next;
      }
#line 1260
      if ((unsigned long )kernel_cache_ptr->next != (unsigned long )((void *)0)) {
#line 1261
        (kernel_cache_ptr->next)->prev = kernel_cache_ptr->prev;
      }
#line 1263
      found = 1;
#line 1265
      goto while_break___1;
      __Cont___0: /* CIL Label */ 
#line 1238
      kernel_cache_ptr = kernel_cache_ptr->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1268
    if (found == 1) {
#line 1269
      if ((unsigned long )mrtentry_rp->kernel_cache == (unsigned long )((void *)0)) {
#line 1270
        mrtentry_rp->flags = (u_int16 )((int )mrtentry_rp->flags & -33281);
      }
#line 1272
      if ((unsigned long )mrtentry_ptr->kernel_cache != (unsigned long )((void *)0)) {
        {
#line 1273
        free((void *)((char *)mrtentry_ptr->kernel_cache));
        }
      }
#line 1275
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 512);
#line 1276
      mrtentry_ptr->kernel_cache = kernel_cache_ptr;
#line 1277
      kernel_cache_ptr->prev = (struct kernel_cache *)((void *)0);
#line 1278
      kernel_cache_ptr->next = (struct kernel_cache *)((void *)0);
    }
  }
#line 1281
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 278 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
build_jp_message_t *build_jp_message_pool  ;
#line 279 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int build_jp_message_pool_counter  ;
#line 349
char s4[19] ;
#line 530
int send_periodic_pim_join_prune(vifi_t vifi , pim_nbr_entry_t *pim_nbr , u_int16 holdtime ) ;
#line 40 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static int parse_pim_hello(char *pim_message , size_t datalen , u_int32 src , u_int16 *holdtime ) ;
#line 41
static int send_pim_register_stop(u_int32 reg_src , u_int32 reg_dst , u_int32 inner_grp ,
                                  u_int32 inner_src ) ;
#line 42
static build_jp_message_t *get_jp_working_buff(void) ;
#line 43
static void return_jp_working_buff(pim_nbr_entry_t *pim_nbr ) ;
#line 44
static void pack_jp_message(pim_nbr_entry_t *pim_nbr ) ;
#line 45
static void send_jp_message(pim_nbr_entry_t *pim_nbr ) ;
#line 46
static int compare_metrics(u_int32 local_preference , u_int32 local_metric , u_int32 local_address___0 ,
                           u_int32 remote_preference , u_int32 remote_metric , u_int32 remote_address ) ;
#line 59 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int receive_pim_hello(u_int32 src , u_int32 dst  __attribute__((__unused__)) , char *pim_message ,
                      size_t datalen ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  pim_nbr_entry_t *nbr ;
  pim_nbr_entry_t *prev_nbr ;
  pim_nbr_entry_t *new_nbr ;
  u_int16 holdtime ;
  int bsr_length ;
  u_int8 *data_ptr  __attribute__((__unused__)) ;
  srcentry_t *srcentry_ptr ;
  mrtentry_t *mrtentry_ptr ;
  int tmp ;
  char *tmp___0 ;
  vifi_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;

  {
  {
#line 64
  holdtime = (u_int16 )0;
#line 71
  tmp = inet_cksum((u_int16 *)pim_message, (u_int )datalen);
  }
#line 71
  if (tmp) {
#line 72
    return (0);
  }
  {
#line 74
  vifi = find_vif_direct(src);
  }
#line 74
  if ((int )vifi == 32) {
    {
#line 78
    tmp___1 = local_address(src);
    }
#line 78
    if ((int )tmp___1 == 32) {
      {
#line 79
      tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 79
      logit(6, 0, "Ignoring PIM_HELLO from non-neighbor router %s", tmp___0);
      }
    }
#line 81
    return (0);
  }
#line 84
  v = & uvifs[vifi];
#line 85
  if (v->uv_flags & 772U) {
#line 86
    return (0);
  }
  {
#line 88
  data_ptr = (u_int8 *)(pim_message + sizeof(pim_header_t ));
#line 91
  tmp___2 = parse_pim_hello(pim_message, datalen, src, & holdtime);
  }
#line 91
  if (tmp___2 == 0) {
#line 92
    return (0);
  }
#line 94
  if (debug) {
#line 94
    if (debug & 2113536UL) {
      {
#line 95
      tmp___3 = inet_fmt(src, s1, sizeof(s1));
#line 95
      logit(7, 0, "PIM HELLO holdtime from %s is %u", tmp___3, (int )holdtime);
      }
    }
  }
#line 99
  prev_nbr = (pim_nbr_entry_t *)((void *)0);
#line 99
  nbr = v->uv_pim_neighbors;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((unsigned long )nbr != (unsigned long )((pim_nbr_entry_t *)((void *)0)))) {
#line 99
      goto while_break;
    }
    {
#line 106
    tmp___4 = ntohl(src);
#line 106
    tmp___5 = ntohl(nbr->address);
    }
#line 106
    if (tmp___4 < tmp___5) {
#line 107
      goto __Cont;
    }
#line 109
    if (src == nbr->address) {
#line 111
      if (0 == (int )holdtime) {
        {
#line 116
        tmp___6 = inet_fmt(src, s1, sizeof(s1));
#line 116
        logit(6, 0, "PIM HELLO received: neighbor %s going down", tmp___6);
#line 118
        delete_pim_nbr(nbr);
        }
#line 120
        return (1);
      }
#line 122
      nbr->timer = holdtime;
#line 124
      return (1);
    } else {
#line 131
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 99
    prev_nbr = nbr;
#line 99
    nbr = nbr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp___7 = calloc((size_t )1, sizeof(pim_nbr_entry_t ));
#line 139
  new_nbr = (pim_nbr_entry_t *)tmp___7;
  }
#line 140
  if (! new_nbr) {
    {
#line 141
    logit(3, 0, "Ran out of memory in receive_pim_hello()");
    }
  }
#line 142
  new_nbr->address = src;
#line 143
  new_nbr->vifi = vifi;
#line 144
  new_nbr->timer = holdtime;
#line 145
  new_nbr->build_jp_message = (build_jp_message_t *)((void *)0);
#line 146
  new_nbr->next = nbr;
#line 147
  new_nbr->prev = prev_nbr;
#line 149
  if ((unsigned long )prev_nbr != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 150
    prev_nbr->next = new_nbr;
  } else {
#line 152
    v->uv_pim_neighbors = new_nbr;
  }
#line 153
  if ((unsigned long )new_nbr->next != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 154
    (new_nbr->next)->prev = new_nbr;
  }
  {
#line 156
  v->uv_flags &= 4294443007U;
#line 157
  v->uv_flags |= 2097152U;
#line 163
  send_pim_hello(v, (u_int16 )(3.5 * (double )30));
  }
#line 165
  if (v->uv_flags & 262144U) {
    {
#line 170
    bsr_length = create_pim_bootstrap_message(pim_send_buf);
    }
#line 170
    if (bsr_length) {
      {
#line 171
      send_pim_unicast(pim_send_buf, v->uv_lcl_addr, src, 4, bsr_length);
      }
    }
    {
#line 174
    tmp___8 = ntohl(v->uv_lcl_addr);
#line 174
    tmp___9 = ntohl(src);
    }
#line 174
    if (tmp___8 < tmp___9) {
#line 179
      srcentry_ptr = srclist->next;
      {
#line 179
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! ((unsigned long )srcentry_ptr != (unsigned long )((srcentry_t *)((void *)0)))) {
#line 179
          goto while_break___0;
        }
#line 184
        if ((int )srcentry_ptr->incoming != (int )vifi) {
#line 186
          goto __Cont___0;
        } else
#line 184
        if ((unsigned long )srcentry_ptr->upstream != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 186
          goto __Cont___0;
        }
#line 188
        mrtentry_ptr = srcentry_ptr->mrtlink;
        {
#line 188
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 188
          if (! ((unsigned long )mrtentry_ptr != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 188
            goto while_break___1;
          }
#line 192
          if (! ((int )mrtentry_ptr->flags & 8192)) {
#line 193
            goto __Cont___1;
          }
          {
#line 196
          mrtentry_ptr->joined_oifs &= (unsigned long )(~ (1 << (int )reg_vif_num));
#line 197
          change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                            mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                            (u_int16 )0);
          }
          __Cont___1: /* CIL Label */ 
#line 188
          mrtentry_ptr = mrtentry_ptr->srcnext;
        }
        while_break___1: /* CIL Label */ ;
        }
        __Cont___0: /* CIL Label */ 
#line 179
        srcentry_ptr = srcentry_ptr->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 205
      v->uv_flags &= 4294705151U;
    }
  }
#line 214
  if (debug) {
#line 214
    if (debug & 16384UL) {
      {
#line 215
      dump_vifs(stderr);
      }
    }
  }
#line 217
  return (1);
}
}
#line 221 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
void delete_pim_nbr(pim_nbr_entry_t *nbr_delete ) 
{ 
  srcentry_t *srcentry_ptr ;
  srcentry_t *srcentry_ptr_next ;
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_srcs ;
  grpentry_t *grpentry_ptr ;
  pim_nbr_entry_t *new_nbr  __attribute__((__unused__)) ;
  cand_rp_t *cand_rp_ptr ;
  rp_grp_entry_t *rp_grp_entry_ptr ;
  rpentry_t *rpentry_ptr ;
  struct uvif *v ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  vifi_t tmp___2 ;

  {
#line 234
  v = & uvifs[nbr_delete->vifi];
#line 237
  if ((unsigned long )nbr_delete->prev != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 238
    (nbr_delete->prev)->next = nbr_delete->next;
  } else {
#line 240
    v->uv_pim_neighbors = nbr_delete->next;
  }
#line 241
  if ((unsigned long )nbr_delete->next != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 242
    (nbr_delete->next)->prev = nbr_delete->prev;
  }
  {
#line 244
  return_jp_working_buff(nbr_delete);
  }
#line 246
  if ((unsigned long )v->uv_pim_neighbors == (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 248
    v->uv_flags &= 4292870143U;
#line 249
    v->uv_flags |= 786432U;
  } else {
    {
#line 252
    tmp = ntohl(v->uv_lcl_addr);
#line 252
    tmp___0 = ntohl((v->uv_pim_neighbors)->address);
    }
#line 252
    if (tmp > tmp___0) {
#line 257
      v->uv_flags |= 262144U;
    }
  }
#line 261
  srcentry_ptr = srclist;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! ((unsigned long )srcentry_ptr != (unsigned long )((srcentry_t *)((void *)0)))) {
#line 261
      goto while_break;
    }
#line 263
    srcentry_ptr_next = srcentry_ptr->next;
#line 265
    if ((unsigned long )srcentry_ptr->upstream != (unsigned long )nbr_delete) {
#line 266
      goto __Cont;
    }
    {
#line 269
    tmp___1 = set_incoming(srcentry_ptr, 1);
    }
#line 269
    if (tmp___1 == 0) {
      {
#line 275
      delete_srcentry(srcentry_ptr);
      }
    } else
#line 277
    if ((unsigned long )srcentry_ptr->upstream != (unsigned long )((pim_nbr_entry_t *)((void *)0))) {
#line 283
      new_nbr = srcentry_ptr->upstream;
#line 284
      mrtentry_ptr = srcentry_ptr->mrtlink;
      {
#line 284
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 284
        if (! ((unsigned long )mrtentry_ptr != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 284
          goto while_break___0;
        }
#line 287
        if (! ((int )mrtentry_ptr->flags & 4)) {
          {
#line 288
          mrtentry_ptr->upstream = srcentry_ptr->upstream;
#line 289
          mrtentry_ptr->metric = srcentry_ptr->metric;
#line 290
          mrtentry_ptr->preference = srcentry_ptr->preference;
#line 291
          change_interfaces(mrtentry_ptr, srcentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                            mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                            (u_int16 )0);
          }
        }
#line 284
        mrtentry_ptr = mrtentry_ptr->srcnext;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 261
    srcentry_ptr = srcentry_ptr_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  cand_rp_ptr = cand_rp_list;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! ((unsigned long )cand_rp_ptr != (unsigned long )((cand_rp_t *)((void *)0)))) {
#line 302
      goto while_break___1;
    }
#line 304
    if ((unsigned long )(cand_rp_ptr->rpentry)->upstream != (unsigned long )nbr_delete) {
#line 305
      goto __Cont___0;
    }
    {
#line 306
    rpentry_ptr = cand_rp_ptr->rpentry;
#line 309
    tmp___2 = local_address(rpentry_ptr->address);
    }
#line 309
    if ((int )tmp___2 == 32) {
      {
#line 310
      set_incoming(rpentry_ptr, 2);
      }
    } else {
#line 312
      rpentry_ptr->incoming = reg_vif_num;
#line 313
      rpentry_ptr->upstream = (pim_nbr_entry_t *)((void *)0);
    }
#line 315
    mrtentry_ptr = rpentry_ptr->mrtlink;
#line 316
    if ((unsigned long )mrtentry_ptr != (unsigned long )((mrtentry_t *)((void *)0))) {
      {
#line 317
      mrtentry_ptr->upstream = rpentry_ptr->upstream;
#line 318
      mrtentry_ptr->metric = rpentry_ptr->metric;
#line 319
      mrtentry_ptr->preference = rpentry_ptr->preference;
#line 320
      change_interfaces(mrtentry_ptr, rpentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                        mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                        (u_int16 )0);
      }
    }
#line 328
    rp_grp_entry_ptr = cand_rp_ptr->rp_grp_next;
    {
#line 328
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 328
      if (! ((unsigned long )rp_grp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 328
        goto while_break___2;
      }
#line 331
      grpentry_ptr = rp_grp_entry_ptr->grplink;
      {
#line 331
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 331
        if (! ((unsigned long )grpentry_ptr != (unsigned long )((grpentry_t *)((void *)0)))) {
#line 331
          goto while_break___3;
        }
#line 334
        mrtentry_ptr = grpentry_ptr->grp_route;
#line 335
        if ((unsigned long )mrtentry_ptr != (unsigned long )((mrtentry_t *)((void *)0))) {
          {
#line 336
          mrtentry_ptr->upstream = rpentry_ptr->upstream;
#line 337
          mrtentry_ptr->metric = rpentry_ptr->metric;
#line 338
          mrtentry_ptr->preference = rpentry_ptr->preference;
#line 339
          change_interfaces(mrtentry_ptr, rpentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                            mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                            (u_int16 )0);
          }
        }
#line 347
        mrtentry_srcs = grpentry_ptr->mrtlink;
        {
#line 347
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 347
          if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 347
            goto while_break___4;
          }
#line 350
          if ((int )mrtentry_srcs->flags & 4) {
            {
#line 351
            mrtentry_ptr->upstream = rpentry_ptr->upstream;
#line 352
            mrtentry_ptr->metric = rpentry_ptr->metric;
#line 353
            mrtentry_ptr->preference = rpentry_ptr->preference;
#line 354
            change_interfaces(mrtentry_srcs, rpentry_ptr->incoming, mrtentry_srcs->joined_oifs,
                              mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves, mrtentry_srcs->asserted_oifs,
                              (u_int16 )0);
            }
          }
#line 347
          mrtentry_srcs = mrtentry_srcs->grpnext;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 331
        grpentry_ptr = grpentry_ptr->rpnext;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 328
      rp_grp_entry_ptr = rp_grp_entry_ptr->rp_grp_next;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 302
    cand_rp_ptr = cand_rp_ptr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 366
  free((void *)((char *)nbr_delete));
  }
#line 367
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static int parse_pim_hello(char *pim_message , size_t datalen , u_int32 src , u_int16 *holdtime ) 
{ 
  u_int8 *pim_hello_message ;
  u_int8 *data_ptr ;
  u_int16 option_type ;
  u_int16 option_length ;
  int holdtime_received_ok ;
  int option_total_length ;
  register u_int16 Xv ;
  u_int8 *tmp ;
  u_int8 *tmp___0 ;
  register u_int16 Xv___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  char *tmp___3 ;
  register u_int16 Xv___1 ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;

  {
#line 377
  holdtime_received_ok = 0;
#line 380
  pim_hello_message = (u_int8 *)(pim_message + sizeof(pim_header_t ));
#line 381
  datalen -= sizeof(pim_header_t );
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! (datalen >= sizeof(pim_hello_t ))) {
#line 382
      goto while_break;
    }
#line 384
    data_ptr = pim_hello_message;
    {
#line 385
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 385
      tmp = data_ptr;
#line 385
      data_ptr ++;
#line 385
      Xv = (u_int16 )((int )*tmp << 8);
#line 385
      tmp___0 = data_ptr;
#line 385
      data_ptr ++;
#line 385
      Xv = (u_int16 )((int )Xv | (int )*tmp___0);
#line 385
      option_type = Xv;
#line 385
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 386
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 386
      tmp___1 = data_ptr;
#line 386
      data_ptr ++;
#line 386
      Xv___0 = (u_int16 )((int )*tmp___1 << 8);
#line 386
      tmp___2 = data_ptr;
#line 386
      data_ptr ++;
#line 386
      Xv___0 = (u_int16 )((int )Xv___0 | (int )*tmp___2);
#line 386
      option_length = Xv___0;
#line 386
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 388
    if ((int )option_type == 1) {
#line 389
      if (2 != (int )option_length) {
#line 390
        if (debug) {
#line 390
          if (debug & 16384UL) {
            {
#line 391
            tmp___3 = inet_fmt(src, s1, sizeof(s1));
#line 391
            logit(7, 0, "PIM HELLO Holdtime from %s: invalid OptionLength = %u", tmp___3,
                  (int )option_length);
            }
          }
        }
#line 394
        return (0);
      }
      {
#line 397
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 397
        tmp___4 = data_ptr;
#line 397
        data_ptr ++;
#line 397
        Xv___1 = (u_int16 )((int )*tmp___4 << 8);
#line 397
        tmp___5 = data_ptr;
#line 397
        data_ptr ++;
#line 397
        Xv___1 = (u_int16 )((int )Xv___1 | (int )*tmp___5);
#line 397
        *holdtime = Xv___1;
#line 397
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 398
      holdtime_received_ok = 1;
    }
#line 412
    option_total_length = (int )(sizeof(pim_hello_t ) + (unsigned long )option_length);
#line 415
    datalen -= (size_t )option_total_length;
#line 416
    pim_hello_message += option_total_length;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return (holdtime_received_ok);
}
}
#line 423 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int send_pim_hello(struct uvif *v , u_int16 holdtime ) 
{ 
  char *buf ;
  u_int8 *data_ptr ;
  int datalen ;
  register u_int16 Xv ;
  u_int8 *tmp ;
  u_int8 *tmp___0 ;
  register u_int16 Xv___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  register u_int16 Xv___1 ;
  u_int8 *tmp___3 ;
  u_int8 *tmp___4 ;

  {
#line 429
  buf = (pim_send_buf + sizeof(struct ip )) + sizeof(pim_header_t );
#line 430
  data_ptr = (u_int8 *)buf;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    Xv = (u_int16 )1;
#line 431
    tmp = data_ptr;
#line 431
    data_ptr ++;
#line 431
    *tmp = (u_int8 )((int )Xv >> 8);
#line 431
    tmp___0 = data_ptr;
#line 431
    data_ptr ++;
#line 431
    *tmp___0 = (u_int8 )Xv;
#line 431
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 432
    Xv___0 = (u_int16 )2;
#line 432
    tmp___1 = data_ptr;
#line 432
    data_ptr ++;
#line 432
    *tmp___1 = (u_int8 )((int )Xv___0 >> 8);
#line 432
    tmp___2 = data_ptr;
#line 432
    data_ptr ++;
#line 432
    *tmp___2 = (u_int8 )Xv___0;
#line 432
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 433
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 433
    Xv___1 = holdtime;
#line 433
    tmp___3 = data_ptr;
#line 433
    data_ptr ++;
#line 433
    *tmp___3 = (u_int8 )((int )Xv___1 >> 8);
#line 433
    tmp___4 = data_ptr;
#line 433
    data_ptr ++;
#line 433
    *tmp___4 = (u_int8 )Xv___1;
#line 433
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 435
  datalen = (int )(data_ptr - (u_int8 *)buf);
#line 436
  send_pim(pim_send_buf, v->uv_lcl_addr, allpimrouters_group, 0, datalen);
#line 437
  v->uv_pim_hello_timer = (u_int16 )30;
  }
#line 439
  return (1);
}
}
#line 451 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int receive_pim_register(u_int32 reg_src , u_int32 reg_dst , char *pim_message , size_t datalen ) 
{ 
  u_int32 inner_src ;
  u_int32 inner_grp ;
  pim_register_t *register_p ;
  struct ip *ip ;
  u_int32 borderBit ;
  u_int32 nullRegisterBit ;
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_ptr2 ;
  vifbitmap_t oifs ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  uint32_t tmp___11 ;
  int tmp___12 ;
  uint32_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  vifi_t tmp___16 ;
  int tmp___17 ;
  u_int32 mfc_source ;
  u_int32 mfc_source___0 ;

  {
#line 466
  if (datalen < (sizeof(pim_header_t ) + sizeof(pim_register_t )) + sizeof(struct ip )) {
#line 467
    if (debug) {
#line 467
      if (debug & 32768UL) {
        {
#line 468
        tmp = inet_fmt(reg_src, s1, sizeof(s1));
#line 468
        logit(6, 0, "PIM register: short packet (len = %d) from %s", datalen, tmp);
        }
      }
    }
#line 472
    return (0);
  }
  {
#line 482
  tmp___1 = inet_cksum((u_int16 *)pim_message, (u_int )(sizeof(pim_header_t ) + sizeof(pim_register_t )));
  }
#line 482
  if (tmp___1) {
    {
#line 482
    tmp___2 = inet_cksum((u_int16 *)pim_message, (u_int )datalen);
    }
#line 482
    if (tmp___2) {
#line 484
      if (debug) {
#line 484
        if (debug & 32768UL) {
          {
#line 485
          tmp___0 = inet_fmt(reg_src, s1, sizeof(s1));
#line 485
          logit(7, 0, "PIM REGISTER from DR %s: invalid PIM header checksum", tmp___0);
          }
        }
      }
#line 489
      return (0);
    }
  }
  {
#line 492
  register_p = (pim_register_t *)(pim_message + sizeof(pim_header_t ));
#line 493
  tmp___3 = ntohl(register_p->reg_flags);
#line 493
  borderBit = tmp___3 & 2147483648U;
#line 494
  tmp___4 = ntohl(register_p->reg_flags);
#line 494
  nullRegisterBit = tmp___4 & 1073741824U;
#line 497
  ip = (struct ip *)(register_p + 1);
  }
#line 500
  if (ip->ip_v != 4U) {
#line 500
    if (! nullRegisterBit) {
#line 501
      if (debug) {
#line 501
        if (debug & 32768UL) {
          {
#line 502
          tmp___5 = inet_fmt(reg_src, s1, sizeof(s1));
#line 502
          logit(6, 0, "PIM register: incorrect IP version (%d) of the inner packet from %s",
                ip->ip_v, tmp___5);
          }
        }
      }
#line 505
      return (0);
    }
  }
  {
#line 509
  inner_src = ip->ip_src.s_addr;
#line 510
  inner_grp = ip->ip_dst.s_addr;
#line 516
  tmp___12 = inet_valid_host(inner_src);
  }
#line 516
  if (tmp___12) {
    {
#line 516
    tmp___13 = ntohl(inner_grp);
    }
#line 516
    if (! ((tmp___13 & 4026531840U) == 3758096384U)) {
      _L: /* CIL Label */ 
      {
#line 517
      tmp___8 = inet_valid_host(inner_src);
      }
#line 517
      if (! tmp___8) {
        {
#line 518
        tmp___6 = inet_fmt(inner_src, s2, sizeof(s2));
#line 518
        tmp___7 = inet_fmt(reg_src, s1, sizeof(s1));
#line 518
        logit(4, 0, "Inner source address of register message by %s is invalid: %s",
              tmp___7, tmp___6);
        }
      }
      {
#line 521
      tmp___11 = ntohl(inner_grp);
      }
#line 521
      if (! ((tmp___11 & 4026531840U) == 3758096384U)) {
        {
#line 522
        tmp___9 = inet_fmt(inner_grp, s2, sizeof(s2));
#line 522
        tmp___10 = inet_fmt(reg_src, s1, sizeof(s1));
#line 522
        logit(4, 0, "Inner group address of register message by %s is invalid: %s",
              tmp___10, tmp___9);
        }
      }
      {
#line 525
      send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
      }
#line 527
      return (0);
    }
  } else {
#line 516
    goto _L;
  }
  {
#line 530
  mrtentry_ptr = find_route(inner_src, inner_grp, (u_int16 )24578, (char)0);
  }
#line 531
  if (! mrtentry_ptr) {
#line 533
    if (debug) {
#line 533
      if (debug & 32768UL) {
        {
#line 534
        tmp___14 = inet_fmt(inner_grp, s2, sizeof(s2));
#line 534
        tmp___15 = inet_fmt(inner_src, s1, sizeof(s1));
#line 534
        logit(7, 0, "No routing entry for source %s and/or group %s", tmp___15, tmp___14);
        }
      }
    }
    {
#line 538
    send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
    }
#line 540
    return (1);
  }
  {
#line 544
  tmp___16 = local_address(reg_dst);
  }
#line 544
  if ((int )tmp___16 == 32) {
    {
#line 546
    send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
    }
#line 548
    return (1);
  } else {
    {
#line 544
    tmp___17 = check_mrtentry_rp(mrtentry_ptr, reg_dst);
    }
#line 544
    if (tmp___17 == 0) {
      {
#line 546
      send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
      }
#line 548
      return (1);
    }
  }
#line 551
  if ((int )mrtentry_ptr->flags & 8192) {
#line 554
    mrtentry_ptr->timer = (u_int16 )210;
#line 555
    if (! ((int )mrtentry_ptr->flags & 1)) {
#line 556
      if (! nullRegisterBit) {
        {
#line 557
        calc_oifs(mrtentry_ptr, & oifs);
        }
#line 558
        if (oifs == 0UL) {
#line 558
          if ((int )mrtentry_ptr->incoming == (int )reg_vif_num) {
            {
#line 559
            send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
            }
#line 560
            return (1);
          }
        }
#line 574
        if (borderBit) {
#line 575
          if (mrtentry_ptr->pmbr_addr != reg_src) {
            {
#line 576
            send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
            }
#line 578
            return (1);
          }
        }
#line 582
        return (1);
      }
#line 586
      return (1);
    } else {
      {
#line 590
      send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
      }
#line 591
      return (1);
    }
  }
#line 594
  if ((int )mrtentry_ptr->flags & 16386) {
#line 595
    if (borderBit) {
      {
#line 598
      mrtentry_ptr2 = find_route(inner_src, inner_grp, (u_int16 )8192, (char)1);
      }
#line 599
      if (mrtentry_ptr2) {
#line 600
        mrtentry_ptr2->pmbr_addr = reg_src;
#line 602
        mrtentry_ptr2->flags = (u_int16 )((int )mrtentry_ptr2->flags & -10);
#line 603
        mrtentry_ptr2->timer = (u_int16 )210;
#line 605
        mrtentry_ptr2->jp_timer = (u_int16 )0;
      }
    }
  }
#line 615
  if ((int )mrtentry_ptr->flags & 2) {
    {
#line 617
    calc_oifs(mrtentry_ptr, & oifs);
    }
#line 618
    if (oifs == 0UL) {
      {
#line 619
      send_pim_register_stop(reg_dst, reg_src, inner_grp, (u_int32 )0);
      }
#line 621
      return (0);
    } else
#line 625
    if (! nullRegisterBit) {
      {
#line 631
      mfc_source = inner_src;
#line 636
      add_kernel_cache(mrtentry_ptr, mfc_source, inner_grp, (u_int16 )0);
#line 637
      k_chg_mfc(igmp_socket, mfc_source, inner_grp, mrtentry_ptr->incoming, mrtentry_ptr->oifs,
                (mrtentry_ptr->group)->rpaddr);
      }
#line 641
      return (1);
    }
#line 645
    return (1);
  }
#line 648
  if ((int )mrtentry_ptr->flags & 16384) {
#line 650
    if (! nullRegisterBit) {
      {
#line 651
      mfc_source___0 = inner_src;
#line 655
      mrtentry_ptr2 = find_route((u_int32 )0, inner_grp, (u_int16 )2, (char)1);
      }
#line 656
      if (! mrtentry_ptr2) {
#line 657
        return (0);
      }
#line 658
      if ((int )mrtentry_ptr2->flags & 8) {
#line 660
        mrtentry_ptr2->flags = (u_int16 )((int )mrtentry_ptr2->flags & -9);
#line 662
        mrtentry_ptr2->timer = mrtentry_ptr->timer;
      }
      {
#line 669
      add_kernel_cache(mrtentry_ptr, mfc_source___0, inner_grp, (u_int16 )0);
#line 670
      k_chg_mfc(igmp_socket, mfc_source___0, inner_grp, mrtentry_ptr->incoming, mrtentry_ptr->oifs,
                (mrtentry_ptr2->group)->rpaddr);
      }
#line 674
      return (1);
    }
  }
  {
#line 680
  send_pim_register_stop(reg_dst, reg_src, inner_grp, inner_src);
  }
#line 682
  return (1);
}
}
#line 686 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int send_pim_register(char *packet ) 
{ 
  struct ip *ip ;
  u_int32 source ;
  u_int32 group ;
  vifi_t vifi ;
  rpentry_t *rpentry_ptr ;
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_ptr2 ;
  u_int32 reg_src ;
  u_int32 reg_dst ;
  int pktlen ;
  char *buf ;
  vifi_t tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 695
  pktlen = 0;
#line 698
  ip = (struct ip *)packet;
#line 699
  source = ip->ip_src.s_addr;
#line 700
  group = ip->ip_dst.s_addr;
#line 702
  vifi = find_vif_direct_local(source);
  }
#line 702
  if ((int )vifi == 32) {
#line 703
    return (0);
  }
#line 705
  if (! (uvifs[vifi].uv_flags & 262144U)) {
#line 706
    return (0);
  }
  {
#line 708
  rpentry_ptr = rp_match(group);
  }
#line 709
  if (! rpentry_ptr) {
#line 710
    return (0);
  }
  {
#line 712
  tmp = local_address(rpentry_ptr->address);
  }
#line 712
  if ((int )tmp != 32) {
#line 714
    return (0);
  }
  {
#line 717
  mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)1);
  }
#line 718
  if (! mrtentry_ptr) {
#line 719
    return (0);
  }
#line 721
  if ((int )mrtentry_ptr->flags & 8) {
#line 723
    mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 724
    mrtentry_ptr->rs_timer = (u_int16 )0;
#line 725
    mrtentry_ptr2 = (mrtentry_ptr->group)->grp_route;
#line 726
    if (! mrtentry_ptr2) {
#line 727
      mrtentry_ptr2 = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
    }
#line 728
    if (mrtentry_ptr2) {
#line 729
      mrtentry_ptr2->jp_timer = (u_int16 )0;
    }
  }
#line 738
  mrtentry_ptr->timer = (u_int16 )210;
#line 740
  if ((int )mrtentry_ptr->rs_timer <= 0) {
    {
#line 769
    buf = (pim_send_buf + sizeof(struct ip )) + sizeof(pim_header_t );
#line 770
    memset((void *)buf, 0, sizeof(pim_register_t ));
#line 771
    buf += sizeof(pim_register_t );
#line 775
    tmp___0 = ntohs(ip->ip_len);
#line 775
    pktlen = (int )tmp___0;
#line 776
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)ip, (size_t )pktlen);
#line 777
    pktlen = (int )((unsigned long )pktlen + sizeof(pim_register_t ));
#line 778
    reg_src = uvifs[vifi].uv_lcl_addr;
#line 779
    reg_dst = (mrtentry_ptr->group)->rpaddr;
#line 780
    send_pim_unicast(pim_send_buf, reg_src, reg_dst, 1, pktlen);
    }
#line 783
    return (1);
  }
#line 786
  return (1);
}
}
#line 790 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int send_pim_null_register(mrtentry_t *mrtentry_ptr ) 
{ 
  struct ip *ip ;
  pim_register_t *pim_register ;
  int pktlen ;
  vifi_t vifi ;
  u_int32 reg_source ;
  u_int32 dest ;
  int tmp ;

  {
  {
#line 794
  pktlen = 0;
#line 799
  vifi = find_vif_direct_local((mrtentry_ptr->source)->address);
  }
#line 799
  if ((int )vifi == 32) {
#line 800
    return (0);
  }
  {
#line 802
  pim_register = (pim_register_t *)((pim_send_buf + sizeof(struct ip )) + sizeof(pim_header_t ));
#line 804
  memset((void *)pim_register, 0, sizeof(pim_register_t ));
#line 805
  pim_register->reg_flags = htonl(pim_register->reg_flags | 1073741824U);
#line 808
  ip = (struct ip *)(pim_register + 1);
#line 810
  ip->ip_v = 4U;
#line 811
  ip->ip_hl = (unsigned int )(sizeof(struct ip ) >> 2);
#line 812
  ip->ip_tos = (u_int8_t )0;
#line 813
  ip->ip_id = (u_short )0;
#line 814
  ip->ip_off = (u_short )0;
#line 815
  ip->ip_p = (u_int8_t )17;
#line 816
  ip->ip_len = htons((uint16_t )sizeof(struct ip ));
#line 817
  ip->ip_ttl = (u_int8_t )1;
#line 818
  ip->ip_src.s_addr = (mrtentry_ptr->source)->address;
#line 819
  ip->ip_dst.s_addr = (mrtentry_ptr->group)->group;
#line 824
  ip->ip_sum = (u_short )0;
#line 825
  tmp = inet_cksum((u_int16 *)ip, (u_int )sizeof(struct ip ));
#line 825
  ip->ip_sum = (u_short )tmp;
#line 829
  pktlen = (int )(sizeof(pim_register_t ) + sizeof(struct ip ));
#line 831
  dest = (mrtentry_ptr->group)->rpaddr;
#line 832
  reg_source = uvifs[vifi].uv_lcl_addr;
#line 834
  send_pim_unicast(pim_send_buf, reg_source, dest, 1, pktlen);
  }
#line 836
  return (1);
}
}
#line 843 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int receive_pim_register_stop(u_int32 reg_src , u_int32 reg_dst , char *pim_message ,
                              size_t datalen ) 
{ 
  pim_register_stop_t *pim_regstop_p ;
  pim_encod_grp_addr_t encod_grp ;
  pim_encod_uni_addr_t encod_unisrc ;
  u_int8 *data_ptr ;
  mrtentry_t *mrtentry_ptr ;
  vifbitmap_t pruned_oifs ;
  int tmp ;
  u_int8 *tmp___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  register u_long Xv ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  register u_long Xv___0 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;

  {
  {
#line 853
  tmp = inet_cksum((u_int16 *)pim_message, (u_int )datalen);
  }
#line 853
  if (tmp) {
#line 854
    return (0);
  }
#line 856
  pim_regstop_p = (pim_register_stop_t *)(pim_message + sizeof(pim_header_t ));
#line 858
  data_ptr = (u_int8 *)(& pim_regstop_p->encod_grp);
  {
#line 859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 859
    tmp___0 = data_ptr;
#line 859
    data_ptr ++;
#line 859
    encod_grp.addr_family = *tmp___0;
#line 859
    tmp___1 = data_ptr;
#line 859
    data_ptr ++;
#line 859
    encod_grp.encod_type = *tmp___1;
#line 859
    tmp___2 = data_ptr;
#line 859
    data_ptr ++;
#line 859
    encod_grp.reserved = *tmp___2;
#line 859
    tmp___3 = data_ptr;
#line 859
    data_ptr ++;
#line 859
    encod_grp.masklen = *tmp___3;
    {
#line 859
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 859
      tmp___4 = data_ptr;
#line 859
      data_ptr ++;
#line 859
      Xv = (u_long )*tmp___4;
#line 859
      tmp___5 = data_ptr;
#line 859
      data_ptr ++;
#line 859
      Xv |= (unsigned long )((int )*tmp___5 << 8);
#line 859
      tmp___6 = data_ptr;
#line 859
      data_ptr ++;
#line 859
      Xv |= (unsigned long )((int )*tmp___6 << 16);
#line 859
      tmp___7 = data_ptr;
#line 859
      data_ptr ++;
#line 859
      Xv |= (unsigned long )((int )*tmp___7 << 24);
#line 859
      encod_grp.mcast_addr = (u_int32 )Xv;
#line 859
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 859
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 860
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 860
    tmp___8 = data_ptr;
#line 860
    data_ptr ++;
#line 860
    encod_unisrc.addr_family = *tmp___8;
#line 860
    tmp___9 = data_ptr;
#line 860
    data_ptr ++;
#line 860
    encod_unisrc.encod_type = *tmp___9;
    {
#line 860
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 860
      tmp___10 = data_ptr;
#line 860
      data_ptr ++;
#line 860
      Xv___0 = (u_long )*tmp___10;
#line 860
      tmp___11 = data_ptr;
#line 860
      data_ptr ++;
#line 860
      Xv___0 |= (unsigned long )((int )*tmp___11 << 8);
#line 860
      tmp___12 = data_ptr;
#line 860
      data_ptr ++;
#line 860
      Xv___0 |= (unsigned long )((int )*tmp___12 << 16);
#line 860
      tmp___13 = data_ptr;
#line 860
      data_ptr ++;
#line 860
      Xv___0 |= (unsigned long )((int )*tmp___13 << 24);
#line 860
      encod_unisrc.unicast_addr = (u_int32 )Xv___0;
#line 860
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 860
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 862
  if (debug) {
#line 862
    if (debug & 32768UL) {
      {
#line 863
      tmp___14 = inet_fmt(encod_grp.mcast_addr, s4, sizeof(s4));
#line 863
      tmp___15 = inet_fmt(encod_unisrc.unicast_addr, s3, sizeof(s3));
#line 863
      tmp___16 = inet_fmt(reg_dst, s2, sizeof(s2));
#line 863
      tmp___17 = inet_fmt(reg_src, s1, sizeof(s1));
#line 863
      logit(7, 0, "Received PIM_REGISTER_STOP from RP %s to %s for src = %s and group = %s",
            tmp___17, tmp___16, tmp___15, tmp___14);
      }
    }
  }
  {
#line 870
  mrtentry_ptr = find_route(encod_unisrc.unicast_addr, encod_grp.mcast_addr, (u_int16 )8192,
                            (char)0);
  }
#line 871
  if (! mrtentry_ptr) {
#line 872
    return (0);
  }
  {
#line 877
  tmp___18 = check_mrtentry_rp(mrtentry_ptr, reg_src);
  }
#line 877
  if (tmp___18 == 0) {
#line 878
    return (0);
  }
  {
#line 881
  tmp___19 = random();
#line 881
  mrtentry_ptr->rs_timer = (u_int16 )(0.5 * (double )60 + (double )(tmp___19 % 61L));
#line 884
  pruned_oifs = mrtentry_ptr->pruned_oifs;
#line 885
  pruned_oifs |= (unsigned long )(1 << (int )reg_vif_num);
#line 886
  change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                    pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                    (u_int16 )0);
  }
#line 891
  return (1);
}
}
#line 897 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static int send_pim_register_stop(u_int32 reg_src , u_int32 reg_dst , u_int32 inner_grp ,
                                  u_int32 inner_src ) 
{ 
  char *buf ;
  u_int8 *data_ptr ;
  u_int32 mask ;
  uint32_t tmp ;
  u_int8 *tmp___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  register u_int32 Xv ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  register u_int32 Xv___0 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;

  {
#line 903
  buf = (pim_send_buf + sizeof(struct ip )) + sizeof(pim_header_t );
#line 904
  data_ptr = (u_int8 *)buf;
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 905
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 905
      tmp = htonl((uint32_t )(-1 << ((sizeof(mask) << 3) - 32UL)));
#line 905
      mask = tmp;
      }
#line 905
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 905
    tmp___0 = data_ptr;
#line 905
    data_ptr ++;
#line 905
    *tmp___0 = (u_int8 )1;
#line 905
    tmp___1 = data_ptr;
#line 905
    data_ptr ++;
#line 905
    *tmp___1 = (u_int8 )0;
#line 905
    tmp___2 = data_ptr;
#line 905
    data_ptr ++;
#line 905
    *tmp___2 = (u_int8 )0;
#line 905
    tmp___3 = data_ptr;
#line 905
    data_ptr ++;
#line 905
    *tmp___3 = (u_int8 )32;
    {
#line 905
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 905
      Xv = inner_grp & mask;
#line 905
      tmp___4 = data_ptr;
#line 905
      data_ptr ++;
#line 905
      *tmp___4 = (u_int8 )Xv;
#line 905
      tmp___5 = data_ptr;
#line 905
      data_ptr ++;
#line 905
      *tmp___5 = (u_int8 )(Xv >> 8);
#line 905
      tmp___6 = data_ptr;
#line 905
      data_ptr ++;
#line 905
      *tmp___6 = (u_int8 )(Xv >> 16);
#line 905
      tmp___7 = data_ptr;
#line 905
      data_ptr ++;
#line 905
      *tmp___7 = (u_int8 )(Xv >> 24);
#line 905
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 905
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 906
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 906
    tmp___8 = data_ptr;
#line 906
    data_ptr ++;
#line 906
    *tmp___8 = (u_int8 )1;
#line 906
    tmp___9 = data_ptr;
#line 906
    data_ptr ++;
#line 906
    *tmp___9 = (u_int8 )0;
    {
#line 906
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 906
      Xv___0 = inner_src;
#line 906
      tmp___10 = data_ptr;
#line 906
      data_ptr ++;
#line 906
      *tmp___10 = (u_int8 )Xv___0;
#line 906
      tmp___11 = data_ptr;
#line 906
      data_ptr ++;
#line 906
      *tmp___11 = (u_int8 )(Xv___0 >> 8);
#line 906
      tmp___12 = data_ptr;
#line 906
      data_ptr ++;
#line 906
      *tmp___12 = (u_int8 )(Xv___0 >> 16);
#line 906
      tmp___13 = data_ptr;
#line 906
      data_ptr ++;
#line 906
      *tmp___13 = (u_int8 )(Xv___0 >> 24);
#line 906
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 906
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 907
  send_pim_unicast(pim_send_buf, reg_src, reg_dst, 2, (int )(data_ptr - (u_int8 *)buf));
  }
#line 909
  return (1);
}
}
#line 916 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int join_or_prune(mrtentry_t *mrtentry_ptr , pim_nbr_entry_t *upstream_router ) 
{ 
  vifbitmap_t entry_oifs ;
  mrtentry_t *mrtentry_grp ;

  {
#line 921
  if (! mrtentry_ptr) {
#line 922
    return (0);
  } else
#line 921
  if (! upstream_router) {
#line 922
    return (0);
  }
  {
#line 924
  calc_oifs(mrtentry_ptr, & entry_oifs);
  }
#line 925
  if ((int )mrtentry_ptr->flags & 16386) {
#line 928
    if ((unsigned long )upstream_router != (unsigned long )mrtentry_ptr->upstream) {
#line 929
      return (0);
    }
#line 932
    if (entry_oifs == 0UL) {
#line 935
      if (! (uvifs[mrtentry_ptr->incoming].uv_flags & 262144U)) {
#line 937
        return (2);
      }
#line 939
      if (mrtentry_ptr->leaves & (unsigned long )(1 << (int )mrtentry_ptr->incoming)) {
#line 941
        return (1);
      }
#line 944
      return (2);
    }
#line 947
    return (1);
  }
#line 950
  if ((int )mrtentry_ptr->flags & 8192) {
#line 953
    if ((unsigned long )mrtentry_ptr->upstream == (unsigned long )upstream_router) {
#line 954
      if (! ((int )mrtentry_ptr->flags & 4)) {
#line 956
        if (entry_oifs == 0UL) {
#line 957
          if ((mrtentry_ptr->group)->active_rp_grp) {
#line 957
            if ((mrtentry_ptr->group)->rpaddr == my_cand_rp_address) {
#line 962
              return (0);
            }
          }
#line 965
          return (2);
        } else {
#line 968
          return (1);
        }
      } else
#line 973
      if (entry_oifs == 0UL) {
#line 974
        return (2);
      }
    }
#line 981
    if (! (mrtentry_ptr->group)->active_rp_grp) {
#line 982
      return (0);
    }
#line 984
    mrtentry_grp = (mrtentry_ptr->group)->grp_route;
#line 985
    if (! mrtentry_grp) {
#line 986
      mrtentry_grp = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
#line 987
      if (! mrtentry_grp) {
#line 988
        return (0);
      }
    }
#line 991
    if ((unsigned long )mrtentry_grp->upstream != (unsigned long )upstream_router) {
#line 992
      return (0);
    }
#line 994
    if (! ((int )mrtentry_ptr->flags & 4)) {
#line 994
      if ((int )mrtentry_ptr->flags & 1) {
#line 995
        return (2);
      }
    }
  }
#line 998
  return (0);
}
}
#line 1005 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int receive_pim_join_prune(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                           char *pim_message , int datalen ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  pim_encod_uni_addr_t uni_target_addr ;
  pim_encod_grp_addr_t encod_group ;
  pim_encod_src_addr_t encod_src ;
  u_int8 *data_ptr ;
  u_int8 *data_ptr_start ;
  u_int8 *data_ptr_group_end ;
  u_int8 num_groups ;
  u_int8 num_groups_tmp ;
  int star_star_rp_found ;
  u_int16 holdtime ;
  u_int16 num_j_srcs ;
  u_int16 num_j_srcs_tmp ;
  u_int16 num_p_srcs ;
  u_int32 source ;
  u_int32 group ;
  u_int32 s_mask ;
  u_int32 g_mask ;
  u_int8 s_flags ;
  u_int8 reserved  __attribute__((__unused__)) ;
  rpentry_t *rpentry_ptr ;
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_srcs ;
  mrtentry_t *mrtentry_rp ;
  grpentry_t *grpentry_ptr ;
  u_int16 jp_value ;
  pim_nbr_entry_t *upstream_router ;
  int my_action ;
  int ignore_group ;
  rp_grp_entry_t *rp_grp_entry_ptr ;
  u_int8 *data_ptr_group_j_start ;
  u_int8 *data_ptr_group_p_start ;
  char *tmp ;
  vifi_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  u_int8 *tmp___3 ;
  u_int8 *tmp___4 ;
  register u_long Xv ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  u_int8 *tmp___10 ;
  register u_int16 Xv___0 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  u_int8 *tmp___14 ;
  u_int8 *tmp___15 ;
  u_int8 *tmp___16 ;
  register u_long Xv___1 ;
  u_int8 *tmp___17 ;
  u_int8 *tmp___18 ;
  u_int8 *tmp___19 ;
  u_int8 *tmp___20 ;
  register u_int16 Xv___2 ;
  u_int8 *tmp___21 ;
  u_int8 *tmp___22 ;
  register u_int16 Xv___3 ;
  u_int8 *tmp___23 ;
  u_int8 *tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  u_int8 *tmp___27 ;
  u_int8 *tmp___28 ;
  u_int8 *tmp___29 ;
  u_int8 *tmp___30 ;
  register u_long Xv___4 ;
  u_int8 *tmp___31 ;
  u_int8 *tmp___32 ;
  u_int8 *tmp___33 ;
  u_int8 *tmp___34 ;
  int tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  long tmp___39 ;
  u_int16 tmp___40 ;
  u_int8 *tmp___41 ;
  u_int8 *tmp___42 ;
  u_int8 *tmp___43 ;
  u_int8 *tmp___44 ;
  register u_long Xv___5 ;
  u_int8 *tmp___45 ;
  u_int8 *tmp___46 ;
  u_int8 *tmp___47 ;
  u_int8 *tmp___48 ;
  int tmp___49 ;
  uint32_t tmp___50 ;
  long tmp___51 ;
  uint32_t tmp___52 ;
  uint32_t tmp___53 ;
  long tmp___54 ;
  long tmp___55 ;
  long tmp___56 ;
  u_int16 tmp___57 ;
  uint32_t tmp___58 ;
  u_int8 *tmp___59 ;
  u_int8 *tmp___60 ;
  u_int8 *tmp___61 ;
  u_int8 *tmp___62 ;
  register u_long Xv___6 ;
  u_int8 *tmp___63 ;
  u_int8 *tmp___64 ;
  u_int8 *tmp___65 ;
  u_int8 *tmp___66 ;
  int tmp___67 ;
  uint32_t tmp___68 ;
  uint32_t tmp___69 ;
  uint32_t tmp___70 ;
  long tmp___71 ;
  uint32_t tmp___72 ;
  uint32_t tmp___73 ;
  long tmp___74 ;
  u_int16 tmp___75 ;
  u_int8 *tmp___76 ;
  u_int8 *tmp___77 ;
  u_int8 *tmp___78 ;
  u_int8 *tmp___79 ;
  register u_long Xv___7 ;
  u_int8 *tmp___80 ;
  u_int8 *tmp___81 ;
  u_int8 *tmp___82 ;
  u_int8 *tmp___83 ;
  int tmp___84 ;
  uint32_t tmp___85 ;
  long tmp___86 ;
  uint32_t tmp___87 ;
  uint32_t tmp___88 ;
  long tmp___89 ;
  long tmp___90 ;
  long tmp___91 ;
  uint32_t tmp___92 ;
  uint32_t tmp___93 ;
  long tmp___94 ;
  u_int16 tmp___95 ;
  u_int8 tmp___96 ;
  u_int8 *tmp___97 ;
  u_int8 *tmp___98 ;
  u_int8 *tmp___99 ;
  u_int8 *tmp___100 ;
  register u_long Xv___8 ;
  u_int8 *tmp___101 ;
  u_int8 *tmp___102 ;
  u_int8 *tmp___103 ;
  u_int8 *tmp___104 ;
  register u_int16 Xv___9 ;
  u_int8 *tmp___105 ;
  u_int8 *tmp___106 ;
  register u_int16 Xv___10 ;
  u_int8 *tmp___107 ;
  u_int8 *tmp___108 ;
  uint32_t tmp___109 ;
  u_int8 *tmp___110 ;
  u_int8 *tmp___111 ;
  u_int8 *tmp___112 ;
  u_int8 *tmp___113 ;
  register u_long Xv___11 ;
  u_int8 *tmp___114 ;
  u_int8 *tmp___115 ;
  u_int8 *tmp___116 ;
  u_int8 *tmp___117 ;
  u_int16 tmp___118 ;
  u_int8 tmp___119 ;
  u_int8 *tmp___120 ;
  u_int8 *tmp___121 ;
  u_int8 *tmp___122 ;
  u_int8 *tmp___123 ;
  register u_long Xv___12 ;
  u_int8 *tmp___124 ;
  u_int8 *tmp___125 ;
  u_int8 *tmp___126 ;
  u_int8 *tmp___127 ;
  register u_int16 Xv___13 ;
  u_int8 *tmp___128 ;
  u_int8 *tmp___129 ;
  register u_int16 Xv___14 ;
  u_int8 *tmp___130 ;
  u_int8 *tmp___131 ;
  uint32_t tmp___132 ;
  uint32_t tmp___133 ;
  u_int8 *tmp___134 ;
  u_int8 *tmp___135 ;
  u_int8 *tmp___136 ;
  u_int8 *tmp___137 ;
  register u_long Xv___15 ;
  u_int8 *tmp___138 ;
  u_int8 *tmp___139 ;
  u_int8 *tmp___140 ;
  u_int8 *tmp___141 ;
  u_int16 tmp___142 ;
  u_int8 *tmp___143 ;
  u_int8 *tmp___144 ;
  u_int8 *tmp___145 ;
  u_int8 *tmp___146 ;
  register u_long Xv___16 ;
  u_int8 *tmp___147 ;
  u_int8 *tmp___148 ;
  u_int8 *tmp___149 ;
  u_int8 *tmp___150 ;
  int tmp___151 ;
  u_int16 tmp___152 ;
  u_int8 *tmp___153 ;
  u_int8 *tmp___154 ;
  u_int8 *tmp___155 ;
  u_int8 *tmp___156 ;
  register u_long Xv___17 ;
  u_int8 *tmp___157 ;
  u_int8 *tmp___158 ;
  u_int8 *tmp___159 ;
  u_int8 *tmp___160 ;
  int tmp___161 ;
  uint32_t tmp___162 ;
  vifi_t tmp___163 ;
  u_int16 tmp___164 ;
  u_int8 tmp___165 ;
  u_int8 *tmp___166 ;
  u_int8 *tmp___167 ;
  u_int8 *tmp___168 ;
  u_int8 *tmp___169 ;
  register u_long Xv___18 ;
  u_int8 *tmp___170 ;
  u_int8 *tmp___171 ;
  u_int8 *tmp___172 ;
  u_int8 *tmp___173 ;
  register u_int16 Xv___19 ;
  u_int8 *tmp___174 ;
  u_int8 *tmp___175 ;
  register u_int16 Xv___20 ;
  u_int8 *tmp___176 ;
  u_int8 *tmp___177 ;
  uint32_t tmp___178 ;
  u_int8 *tmp___179 ;
  u_int8 *tmp___180 ;
  u_int8 *tmp___181 ;
  u_int8 *tmp___182 ;
  register u_long Xv___21 ;
  u_int8 *tmp___183 ;
  u_int8 *tmp___184 ;
  u_int8 *tmp___185 ;
  u_int8 *tmp___186 ;
  int tmp___187 ;
  uint32_t tmp___188 ;
  u_int16 tmp___189 ;
  u_int8 *tmp___190 ;
  u_int8 *tmp___191 ;
  u_int8 *tmp___192 ;
  u_int8 *tmp___193 ;
  register u_long Xv___22 ;
  u_int8 *tmp___194 ;
  u_int8 *tmp___195 ;
  u_int8 *tmp___196 ;
  u_int8 *tmp___197 ;
  int tmp___198 ;
  uint32_t tmp___199 ;
  u_int16 tmp___200 ;
  u_int8 tmp___201 ;

  {
  {
#line 1041
  vifi = find_vif_direct(src);
  }
#line 1041
  if ((int )vifi == 32) {
    {
#line 1045
    tmp___0 = local_address(src);
    }
#line 1045
    if ((int )tmp___0 == 32) {
      {
#line 1046
      tmp = inet_fmt(src, s1, sizeof(s1));
#line 1046
      logit(6, 0, "Ignoring PIM_JOIN_PRUNE from non-neighbor router %s", tmp);
      }
    }
#line 1050
    return (0);
  }
  {
#line 1054
  tmp___1 = inet_cksum((u_int16 *)pim_message, (u_int )datalen);
  }
#line 1054
  if (tmp___1) {
#line 1055
    return (0);
  }
#line 1057
  v = & uvifs[vifi];
#line 1058
  if (uvifs[vifi].uv_flags & 525060U) {
#line 1059
    return (0);
  }
#line 1062
  if (datalen < 14) {
    {
#line 1063
    tmp___2 = inet_fmt(src, s1, sizeof(s1));
#line 1063
    logit(5, 0, "receive_pim_join_prune: Join/Prune message size(%u) is too short from %s on %s",
          datalen, tmp___2, v->uv_name);
    }
#line 1066
    return (0);
  }
#line 1074
  data_ptr = (u_int8 *)(pim_message + sizeof(pim_header_t ));
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    tmp___3 = data_ptr;
#line 1076
    data_ptr ++;
#line 1076
    uni_target_addr.addr_family = *tmp___3;
#line 1076
    tmp___4 = data_ptr;
#line 1076
    data_ptr ++;
#line 1076
    uni_target_addr.encod_type = *tmp___4;
    {
#line 1076
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1076
      tmp___5 = data_ptr;
#line 1076
      data_ptr ++;
#line 1076
      Xv = (u_long )*tmp___5;
#line 1076
      tmp___6 = data_ptr;
#line 1076
      data_ptr ++;
#line 1076
      Xv |= (unsigned long )((int )*tmp___6 << 8);
#line 1076
      tmp___7 = data_ptr;
#line 1076
      data_ptr ++;
#line 1076
      Xv |= (unsigned long )((int )*tmp___7 << 16);
#line 1076
      tmp___8 = data_ptr;
#line 1076
      data_ptr ++;
#line 1076
      Xv |= (unsigned long )((int )*tmp___8 << 24);
#line 1076
      uni_target_addr.unicast_addr = (u_int32 )Xv;
#line 1076
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1076
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  tmp___9 = data_ptr;
#line 1077
  data_ptr ++;
#line 1077
  reserved = *tmp___9;
#line 1078
  tmp___10 = data_ptr;
#line 1078
  data_ptr ++;
#line 1078
  num_groups = *tmp___10;
#line 1079
  if ((int )num_groups == 0) {
#line 1080
    return (0);
  }
  {
#line 1081
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1081
    tmp___11 = data_ptr;
#line 1081
    data_ptr ++;
#line 1081
    Xv___0 = (u_int16 )((int )*tmp___11 << 8);
#line 1081
    tmp___12 = data_ptr;
#line 1081
    data_ptr ++;
#line 1081
    Xv___0 = (u_int16 )((int )Xv___0 | (int )*tmp___12);
#line 1081
    holdtime = Xv___0;
#line 1081
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1083
  if (uni_target_addr.unicast_addr != v->uv_lcl_addr) {
    {
#line 1092
    upstream_router = find_pim_nbr(uni_target_addr.unicast_addr);
    }
#line 1093
    if (! upstream_router) {
#line 1094
      return (0);
    }
    {
#line 1096
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1096
      tmp___96 = num_groups;
#line 1096
      num_groups = (u_int8 )((int )num_groups - 1);
#line 1096
      if (! tmp___96) {
#line 1096
        goto while_break___2;
      }
      {
#line 1097
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1097
        tmp___13 = data_ptr;
#line 1097
        data_ptr ++;
#line 1097
        encod_group.addr_family = *tmp___13;
#line 1097
        tmp___14 = data_ptr;
#line 1097
        data_ptr ++;
#line 1097
        encod_group.encod_type = *tmp___14;
#line 1097
        tmp___15 = data_ptr;
#line 1097
        data_ptr ++;
#line 1097
        encod_group.reserved = *tmp___15;
#line 1097
        tmp___16 = data_ptr;
#line 1097
        data_ptr ++;
#line 1097
        encod_group.masklen = *tmp___16;
        {
#line 1097
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1097
          tmp___17 = data_ptr;
#line 1097
          data_ptr ++;
#line 1097
          Xv___1 = (u_long )*tmp___17;
#line 1097
          tmp___18 = data_ptr;
#line 1097
          data_ptr ++;
#line 1097
          Xv___1 |= (unsigned long )((int )*tmp___18 << 8);
#line 1097
          tmp___19 = data_ptr;
#line 1097
          data_ptr ++;
#line 1097
          Xv___1 |= (unsigned long )((int )*tmp___19 << 16);
#line 1097
          tmp___20 = data_ptr;
#line 1097
          data_ptr ++;
#line 1097
          Xv___1 |= (unsigned long )((int )*tmp___20 << 24);
#line 1097
          encod_group.mcast_addr = (u_int32 )Xv___1;
#line 1097
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1097
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1098
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1098
        tmp___21 = data_ptr;
#line 1098
        data_ptr ++;
#line 1098
        Xv___2 = (u_int16 )((int )*tmp___21 << 8);
#line 1098
        tmp___22 = data_ptr;
#line 1098
        data_ptr ++;
#line 1098
        Xv___2 = (u_int16 )((int )Xv___2 | (int )*tmp___22);
#line 1098
        num_j_srcs = Xv___2;
#line 1098
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 1099
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1099
        tmp___23 = data_ptr;
#line 1099
        data_ptr ++;
#line 1099
        Xv___3 = (u_int16 )((int )*tmp___23 << 8);
#line 1099
        tmp___24 = data_ptr;
#line 1099
        data_ptr ++;
#line 1099
        Xv___3 = (u_int16 )((int )Xv___3 | (int )*tmp___24);
#line 1099
        num_p_srcs = Xv___3;
#line 1099
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1100
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1100
        if (encod_group.masklen) {
          {
#line 1100
          tmp___25 = htonl((uint32_t )(-1 << ((sizeof(g_mask) << 3) - (unsigned long )encod_group.masklen)));
#line 1100
          g_mask = tmp___25;
          }
        } else {
#line 1100
          g_mask = (u_int32 )0;
        }
#line 1100
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1101
      group = encod_group.mcast_addr;
#line 1102
      tmp___26 = ntohl(group);
      }
#line 1102
      if (! ((tmp___26 & 4026531840U) == 3758096384U)) {
#line 1103
        data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1104
        goto while_continue___2;
      }
      {
#line 1107
      tmp___58 = ntohl(group);
      }
#line 1107
      if (tmp___58 == 3758096384U) {
#line 1107
        if ((int )encod_group.masklen == 4) {
          {
#line 1110
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1110
            tmp___40 = num_j_srcs;
#line 1110
            num_j_srcs = (u_int16 )((int )num_j_srcs - 1);
#line 1110
            if (! tmp___40) {
#line 1110
              goto while_break___8;
            }
            {
#line 1111
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 1111
              tmp___27 = data_ptr;
#line 1111
              data_ptr ++;
#line 1111
              encod_src.addr_family = *tmp___27;
#line 1111
              tmp___28 = data_ptr;
#line 1111
              data_ptr ++;
#line 1111
              encod_src.encod_type = *tmp___28;
#line 1111
              tmp___29 = data_ptr;
#line 1111
              data_ptr ++;
#line 1111
              encod_src.flags = *tmp___29;
#line 1111
              tmp___30 = data_ptr;
#line 1111
              data_ptr ++;
#line 1111
              encod_src.masklen = *tmp___30;
              {
#line 1111
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 1111
                tmp___31 = data_ptr;
#line 1111
                data_ptr ++;
#line 1111
                Xv___4 = (u_long )*tmp___31;
#line 1111
                tmp___32 = data_ptr;
#line 1111
                data_ptr ++;
#line 1111
                Xv___4 |= (unsigned long )((int )*tmp___32 << 8);
#line 1111
                tmp___33 = data_ptr;
#line 1111
                data_ptr ++;
#line 1111
                Xv___4 |= (unsigned long )((int )*tmp___33 << 16);
#line 1111
                tmp___34 = data_ptr;
#line 1111
                data_ptr ++;
#line 1111
                Xv___4 |= (unsigned long )((int )*tmp___34 << 24);
#line 1111
                encod_src.src_addr = (u_int32 )Xv___4;
#line 1111
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 1111
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
            {
#line 1112
            source = encod_src.src_addr;
#line 1113
            tmp___35 = inet_valid_host(source);
            }
#line 1113
            if (! tmp___35) {
#line 1114
              goto while_continue___8;
            }
#line 1116
            s_flags = encod_src.flags;
            {
#line 1117
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 1117
              if (encod_src.masklen) {
                {
#line 1117
                tmp___36 = htonl((uint32_t )(-1 << ((sizeof(s_mask) << 3) - (unsigned long )encod_src.masklen)));
#line 1117
                s_mask = tmp___36;
                }
              } else {
#line 1117
                s_mask = (u_int32 )0;
              }
#line 1117
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 1118
            if ((int )s_flags & 1) {
#line 1118
              if ((int )s_flags & 2) {
                {
#line 1120
                rpentry_ptr = rp_find(source);
                }
#line 1121
                if (! rpentry_ptr) {
#line 1122
                  goto while_continue___8;
                }
                {
#line 1124
                mrtentry_rp = rpentry_ptr->mrtlink;
#line 1125
                my_action = join_or_prune(mrtentry_rp, upstream_router);
                }
#line 1126
                if (my_action != 1) {
#line 1127
                  goto while_continue___8;
                }
#line 1131
                if ((int )mrtentry_rp->jp_timer > (int )holdtime) {
#line 1132
                  goto while_continue___8;
                }
#line 1134
                if ((int )mrtentry_rp->jp_timer == (int )holdtime) {
                  {
#line 1134
                  tmp___37 = ntohl(src);
#line 1134
                  tmp___38 = ntohl(v->uv_lcl_addr);
                  }
#line 1134
                  if (tmp___37 > tmp___38) {
#line 1135
                    goto while_continue___8;
                  }
                }
                {
#line 1141
                tmp___39 = random();
#line 1141
                jp_value = (u_int16 )((double )60 + 0.5 * (double )(tmp___39 % 60L));
                }
#line 1143
                if ((int )mrtentry_rp->jp_timer < (int )jp_value) {
#line 1144
                  mrtentry_rp->jp_timer = jp_value;
                }
              }
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 1148
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 1148
            tmp___57 = num_p_srcs;
#line 1148
            num_p_srcs = (u_int16 )((int )num_p_srcs - 1);
#line 1148
            if (! tmp___57) {
#line 1148
              goto while_break___12;
            }
            {
#line 1155
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 1155
              tmp___41 = data_ptr;
#line 1155
              data_ptr ++;
#line 1155
              encod_src.addr_family = *tmp___41;
#line 1155
              tmp___42 = data_ptr;
#line 1155
              data_ptr ++;
#line 1155
              encod_src.encod_type = *tmp___42;
#line 1155
              tmp___43 = data_ptr;
#line 1155
              data_ptr ++;
#line 1155
              encod_src.flags = *tmp___43;
#line 1155
              tmp___44 = data_ptr;
#line 1155
              data_ptr ++;
#line 1155
              encod_src.masklen = *tmp___44;
              {
#line 1155
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 1155
                tmp___45 = data_ptr;
#line 1155
                data_ptr ++;
#line 1155
                Xv___5 = (u_long )*tmp___45;
#line 1155
                tmp___46 = data_ptr;
#line 1155
                data_ptr ++;
#line 1155
                Xv___5 |= (unsigned long )((int )*tmp___46 << 8);
#line 1155
                tmp___47 = data_ptr;
#line 1155
                data_ptr ++;
#line 1155
                Xv___5 |= (unsigned long )((int )*tmp___47 << 16);
#line 1155
                tmp___48 = data_ptr;
#line 1155
                data_ptr ++;
#line 1155
                Xv___5 |= (unsigned long )((int )*tmp___48 << 24);
#line 1155
                encod_src.src_addr = (u_int32 )Xv___5;
#line 1155
                goto while_break___14;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 1155
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
            {
#line 1156
            source = encod_src.src_addr;
#line 1157
            tmp___49 = inet_valid_host(source);
            }
#line 1157
            if (! tmp___49) {
#line 1158
              goto while_continue___12;
            }
#line 1159
            s_flags = encod_src.flags;
            {
#line 1160
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 1160
              if (encod_src.masklen) {
                {
#line 1160
                tmp___50 = htonl((uint32_t )(-1 << ((sizeof(s_mask) << 3) - (unsigned long )encod_src.masklen)));
#line 1160
                s_mask = tmp___50;
                }
              } else {
#line 1160
                s_mask = (u_int32 )0;
              }
#line 1160
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 1161
            if ((int )s_flags & 1) {
#line 1161
              if ((int )s_flags & 2) {
                {
#line 1163
                rpentry_ptr = rp_find(source);
                }
#line 1164
                if (! rpentry_ptr) {
#line 1165
                  goto while_continue___12;
                }
                {
#line 1167
                mrtentry_rp = rpentry_ptr->mrtlink;
#line 1168
                my_action = join_or_prune(mrtentry_rp, upstream_router);
                }
#line 1169
                if (my_action == 2) {
#line 1171
                  if ((int )mrtentry_rp->jp_timer < (int )holdtime) {
#line 1171
                    goto _L;
                  } else
#line 1171
                  if ((int )mrtentry_rp->jp_timer == (int )holdtime) {
                    {
#line 1171
                    tmp___52 = ntohl(src);
#line 1171
                    tmp___53 = ntohl(v->uv_lcl_addr);
                    }
#line 1171
                    if (tmp___52 > tmp___53) {
                      _L: /* CIL Label */ 
                      {
#line 1175
                      tmp___51 = random();
#line 1175
                      jp_value = (u_int16 )((double )60 + 0.5 * (double )(tmp___51 % 60L));
                      }
#line 1176
                      if ((int )mrtentry_rp->jp_timer < (int )jp_value) {
#line 1177
                        mrtentry_rp->jp_timer = jp_value;
                      }
                    }
                  }
                } else
#line 1179
                if (my_action == 1) {
                  {
#line 1181
                  tmp___54 = random();
#line 1181
                  jp_value = (u_int16 )((tmp___54 % (long )((int )((double )10 * 4.5))) / 10L);
                  }
#line 1183
                  if ((int )mrtentry_rp->jp_timer > (int )jp_value) {
#line 1184
                    mrtentry_rp->jp_timer = jp_value;
                  }
                }
#line 1191
                grpentry_ptr = ((rpentry_ptr->cand_rp)->rp_grp_next)->grplink;
                {
#line 1191
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 1191
                  if (! ((unsigned long )grpentry_ptr != (unsigned long )((grpentry_t *)((void *)0)))) {
#line 1191
                    goto while_break___16;
                  }
                  {
#line 1194
                  my_action = join_or_prune(grpentry_ptr->grp_route, upstream_router);
                  }
#line 1195
                  if (my_action == 1) {
                    {
#line 1196
                    tmp___55 = random();
#line 1196
                    jp_value = (u_int16 )((tmp___55 % (long )((int )((double )10 * 4.5))) / 10L);
                    }
#line 1198
                    if ((int )(grpentry_ptr->grp_route)->jp_timer > (int )jp_value) {
#line 1199
                      (grpentry_ptr->grp_route)->jp_timer = jp_value;
                    }
                  }
#line 1201
                  mrtentry_srcs = grpentry_ptr->mrtlink;
                  {
#line 1201
                  while (1) {
                    while_continue___17: /* CIL Label */ ;
#line 1201
                    if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 1201
                      goto while_break___17;
                    }
                    {
#line 1204
                    my_action = join_or_prune(mrtentry_srcs, upstream_router);
                    }
#line 1205
                    if (my_action == 1) {
                      {
#line 1206
                      tmp___56 = random();
#line 1206
                      jp_value = (u_int16 )((tmp___56 % (long )((int )((double )10 * 4.5))) / 10L);
                      }
#line 1208
                      if ((int )mrtentry_srcs->jp_timer > (int )jp_value) {
#line 1209
                        mrtentry_srcs->jp_timer = jp_value;
                      }
                    }
#line 1201
                    mrtentry_srcs = mrtentry_srcs->grpnext;
                  }
                  while_break___17: /* CIL Label */ ;
                  }
#line 1191
                  grpentry_ptr = grpentry_ptr->rpnext;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
            }
          }
          while_break___12: /* CIL Label */ ;
          }
#line 1215
          goto while_continue___2;
        }
      }
      {
#line 1224
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 1224
        tmp___75 = num_j_srcs;
#line 1224
        num_j_srcs = (u_int16 )((int )num_j_srcs - 1);
#line 1224
        if (! tmp___75) {
#line 1224
          goto while_break___18;
        }
        {
#line 1225
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 1225
          tmp___59 = data_ptr;
#line 1225
          data_ptr ++;
#line 1225
          encod_src.addr_family = *tmp___59;
#line 1225
          tmp___60 = data_ptr;
#line 1225
          data_ptr ++;
#line 1225
          encod_src.encod_type = *tmp___60;
#line 1225
          tmp___61 = data_ptr;
#line 1225
          data_ptr ++;
#line 1225
          encod_src.flags = *tmp___61;
#line 1225
          tmp___62 = data_ptr;
#line 1225
          data_ptr ++;
#line 1225
          encod_src.masklen = *tmp___62;
          {
#line 1225
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 1225
            tmp___63 = data_ptr;
#line 1225
            data_ptr ++;
#line 1225
            Xv___6 = (u_long )*tmp___63;
#line 1225
            tmp___64 = data_ptr;
#line 1225
            data_ptr ++;
#line 1225
            Xv___6 |= (unsigned long )((int )*tmp___64 << 8);
#line 1225
            tmp___65 = data_ptr;
#line 1225
            data_ptr ++;
#line 1225
            Xv___6 |= (unsigned long )((int )*tmp___65 << 16);
#line 1225
            tmp___66 = data_ptr;
#line 1225
            data_ptr ++;
#line 1225
            Xv___6 |= (unsigned long )((int )*tmp___66 << 24);
#line 1225
            encod_src.src_addr = (u_int32 )Xv___6;
#line 1225
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
#line 1225
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
        {
#line 1226
        source = encod_src.src_addr;
#line 1227
        tmp___67 = inet_valid_host(source);
        }
#line 1227
        if (! tmp___67) {
#line 1228
          goto while_continue___18;
        }
#line 1230
        s_flags = encod_src.flags;
        {
#line 1231
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 1231
          if (encod_src.masklen) {
            {
#line 1231
            tmp___68 = htonl((uint32_t )(-1 << ((sizeof(s_mask) << 3) - (unsigned long )encod_src.masklen)));
#line 1231
            s_mask = tmp___68;
            }
          } else {
#line 1231
            s_mask = (u_int32 )0;
          }
#line 1231
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 1233
        if ((int )s_flags & 1) {
#line 1233
          if ((int )s_flags & 2) {
            {
#line 1235
            mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)0);
            }
#line 1236
            if (! mrtentry_ptr) {
#line 1237
              goto while_continue___18;
            }
            {
#line 1239
            my_action = join_or_prune(mrtentry_ptr, upstream_router);
            }
#line 1240
            if (my_action != 1) {
#line 1241
              goto while_continue___18;
            }
#line 1244
            if (source != ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->address) {
#line 1245
              goto while_continue___18;
            }
#line 1249
            if ((int )mrtentry_ptr->jp_timer > (int )holdtime) {
#line 1250
              goto while_continue___18;
            }
#line 1252
            if ((int )mrtentry_ptr->jp_timer == (int )holdtime) {
              {
#line 1252
              tmp___69 = ntohl(src);
#line 1252
              tmp___70 = ntohl(v->uv_lcl_addr);
              }
#line 1252
              if (tmp___69 > tmp___70) {
#line 1253
                goto while_continue___18;
              }
            }
            {
#line 1255
            tmp___71 = random();
#line 1255
            jp_value = (u_int16 )((double )60 + 0.5 * (double )(tmp___71 % 60L));
            }
#line 1256
            if ((int )mrtentry_ptr->jp_timer < (int )jp_value) {
#line 1257
              mrtentry_ptr->jp_timer = jp_value;
            }
#line 1258
            goto while_continue___18;
          }
        }
        {
#line 1262
        mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)0);
        }
#line 1263
        if (! mrtentry_ptr) {
#line 1264
          goto while_continue___18;
        }
        {
#line 1266
        my_action = join_or_prune(mrtentry_ptr, upstream_router);
        }
#line 1267
        if (my_action != 1) {
#line 1268
          goto while_continue___18;
        }
#line 1272
        if ((int )mrtentry_ptr->jp_timer > (int )holdtime) {
#line 1273
          goto while_continue___18;
        }
#line 1275
        if ((int )mrtentry_ptr->jp_timer == (int )holdtime) {
          {
#line 1275
          tmp___72 = ntohl(src);
#line 1275
          tmp___73 = ntohl(v->uv_lcl_addr);
          }
#line 1275
          if (tmp___72 > tmp___73) {
#line 1276
            goto while_continue___18;
          }
        }
        {
#line 1278
        tmp___74 = random();
#line 1278
        jp_value = (u_int16 )((double )60 + 0.5 * (double )(tmp___74 % 60L));
        }
#line 1279
        if ((int )mrtentry_ptr->jp_timer < (int )jp_value) {
#line 1280
          mrtentry_ptr->jp_timer = jp_value;
        }
#line 1281
        goto while_continue___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 1285
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 1285
        tmp___95 = num_p_srcs;
#line 1285
        num_p_srcs = (u_int16 )((int )num_p_srcs - 1);
#line 1285
        if (! tmp___95) {
#line 1285
          goto while_break___22;
        }
        {
#line 1286
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 1286
          tmp___76 = data_ptr;
#line 1286
          data_ptr ++;
#line 1286
          encod_src.addr_family = *tmp___76;
#line 1286
          tmp___77 = data_ptr;
#line 1286
          data_ptr ++;
#line 1286
          encod_src.encod_type = *tmp___77;
#line 1286
          tmp___78 = data_ptr;
#line 1286
          data_ptr ++;
#line 1286
          encod_src.flags = *tmp___78;
#line 1286
          tmp___79 = data_ptr;
#line 1286
          data_ptr ++;
#line 1286
          encod_src.masklen = *tmp___79;
          {
#line 1286
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 1286
            tmp___80 = data_ptr;
#line 1286
            data_ptr ++;
#line 1286
            Xv___7 = (u_long )*tmp___80;
#line 1286
            tmp___81 = data_ptr;
#line 1286
            data_ptr ++;
#line 1286
            Xv___7 |= (unsigned long )((int )*tmp___81 << 8);
#line 1286
            tmp___82 = data_ptr;
#line 1286
            data_ptr ++;
#line 1286
            Xv___7 |= (unsigned long )((int )*tmp___82 << 16);
#line 1286
            tmp___83 = data_ptr;
#line 1286
            data_ptr ++;
#line 1286
            Xv___7 |= (unsigned long )((int )*tmp___83 << 24);
#line 1286
            encod_src.src_addr = (u_int32 )Xv___7;
#line 1286
            goto while_break___24;
          }
          while_break___24: /* CIL Label */ ;
          }
#line 1286
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
        {
#line 1287
        source = encod_src.src_addr;
#line 1288
        tmp___84 = inet_valid_host(source);
        }
#line 1288
        if (! tmp___84) {
#line 1289
          goto while_continue___22;
        }
#line 1291
        s_flags = encod_src.flags;
        {
#line 1292
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 1292
          if (encod_src.masklen) {
            {
#line 1292
            tmp___85 = htonl((uint32_t )(-1 << ((sizeof(s_mask) << 3) - (unsigned long )encod_src.masklen)));
#line 1292
            s_mask = tmp___85;
            }
          } else {
#line 1292
            s_mask = (u_int32 )0;
          }
#line 1292
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 1293
        if ((int )s_flags & 1) {
#line 1293
          if ((int )s_flags & 2) {
            {
#line 1295
            rpentry_ptr = rp_match(group);
            }
#line 1296
            if (! rpentry_ptr) {
#line 1297
              goto while_continue___22;
            } else
#line 1296
            if (rpentry_ptr->address != source) {
#line 1297
              goto while_continue___22;
            }
            {
#line 1299
            mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)0);
            }
#line 1300
            if (! mrtentry_ptr) {
#line 1301
              goto while_continue___22;
            }
            {
#line 1303
            my_action = join_or_prune(mrtentry_ptr, upstream_router);
            }
#line 1304
            if (my_action == 2) {
#line 1306
              if ((int )mrtentry_ptr->jp_timer < (int )holdtime) {
#line 1306
                goto _L___0;
              } else
#line 1306
              if ((int )mrtentry_ptr->jp_timer == (int )holdtime) {
                {
#line 1306
                tmp___87 = ntohl(src);
#line 1306
                tmp___88 = ntohl(v->uv_lcl_addr);
                }
#line 1306
                if (tmp___87 > tmp___88) {
                  _L___0: /* CIL Label */ 
                  {
#line 1310
                  tmp___86 = random();
#line 1310
                  jp_value = (u_int16 )((double )60 + 0.5 * (double )(tmp___86 % 60L));
                  }
#line 1311
                  if ((int )mrtentry_ptr->jp_timer < (int )jp_value) {
#line 1312
                    mrtentry_ptr->jp_timer = jp_value;
                  }
                }
              }
            } else
#line 1315
            if (my_action == 1) {
              {
#line 1317
              tmp___89 = random();
#line 1317
              jp_value = (u_int16 )((tmp___89 % (long )((int )((double )10 * 4.5))) / 10L);
              }
#line 1319
              if ((int )mrtentry_ptr->jp_timer > (int )jp_value) {
#line 1320
                mrtentry_ptr->jp_timer = jp_value;
              }
            }
#line 1327
            mrtentry_srcs = (mrtentry_ptr->group)->mrtlink;
            {
#line 1327
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 1327
              if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 1327
                goto while_break___26;
              }
              {
#line 1330
              my_action = join_or_prune(mrtentry_srcs, upstream_router);
              }
#line 1331
              if (my_action == 1) {
                {
#line 1332
                tmp___90 = random();
#line 1332
                jp_value = (u_int16 )((tmp___90 % (long )((int )((double )10 * 4.5))) / 10L);
                }
#line 1334
                if ((int )mrtentry_ptr->jp_timer > (int )jp_value) {
#line 1335
                  mrtentry_ptr->jp_timer = jp_value;
                }
              }
#line 1327
              mrtentry_srcs = mrtentry_srcs->grpnext;
            }
            while_break___26: /* CIL Label */ ;
            }
#line 1338
            goto while_continue___22;
          }
        }
        {
#line 1342
        mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)0);
        }
#line 1343
        if ((unsigned long )mrtentry_ptr == (unsigned long )((void *)0)) {
#line 1344
          goto while_continue___22;
        }
        {
#line 1346
        my_action = join_or_prune(mrtentry_ptr, upstream_router);
        }
#line 1347
        if (my_action == 2) {
#line 1350
          if ((int )mrtentry_ptr->jp_timer < (int )holdtime) {
#line 1350
            goto _L___1;
          } else
#line 1350
          if ((int )mrtentry_ptr->jp_timer == (int )holdtime) {
            {
#line 1350
            tmp___92 = ntohl(src);
#line 1350
            tmp___93 = ntohl(v->uv_lcl_addr);
            }
#line 1350
            if (tmp___92 > tmp___93) {
              _L___1: /* CIL Label */ 
              {
#line 1353
              tmp___91 = random();
#line 1353
              jp_value = (u_int16 )((double )60 + 0.5 * (double )(tmp___91 % 60L));
              }
#line 1354
              if ((int )mrtentry_ptr->jp_timer < (int )jp_value) {
#line 1355
                mrtentry_ptr->jp_timer = jp_value;
              }
            }
          }
        } else
#line 1358
        if (my_action == 1) {
          {
#line 1360
          tmp___94 = random();
#line 1360
          jp_value = (u_int16 )((tmp___94 % (long )((int )((double )10 * 4.5))) / 10L);
          }
#line 1362
          if ((int )mrtentry_ptr->jp_timer > (int )jp_value) {
#line 1363
            mrtentry_ptr->jp_timer = jp_value;
          }
        }
      }
      while_break___22: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1367
    return (1);
  }
#line 1404
  num_groups_tmp = num_groups;
#line 1405
  data_ptr_start = data_ptr;
#line 1406
  star_star_rp_found = 0;
  {
#line 1407
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1407
    tmp___119 = num_groups_tmp;
#line 1407
    num_groups_tmp = (u_int8 )((int )num_groups_tmp - 1);
#line 1407
    if (! tmp___119) {
#line 1407
      goto while_break___27;
    }
    {
#line 1409
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1409
      tmp___97 = data_ptr;
#line 1409
      data_ptr ++;
#line 1409
      encod_group.addr_family = *tmp___97;
#line 1409
      tmp___98 = data_ptr;
#line 1409
      data_ptr ++;
#line 1409
      encod_group.encod_type = *tmp___98;
#line 1409
      tmp___99 = data_ptr;
#line 1409
      data_ptr ++;
#line 1409
      encod_group.reserved = *tmp___99;
#line 1409
      tmp___100 = data_ptr;
#line 1409
      data_ptr ++;
#line 1409
      encod_group.masklen = *tmp___100;
      {
#line 1409
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 1409
        tmp___101 = data_ptr;
#line 1409
        data_ptr ++;
#line 1409
        Xv___8 = (u_long )*tmp___101;
#line 1409
        tmp___102 = data_ptr;
#line 1409
        data_ptr ++;
#line 1409
        Xv___8 |= (unsigned long )((int )*tmp___102 << 8);
#line 1409
        tmp___103 = data_ptr;
#line 1409
        data_ptr ++;
#line 1409
        Xv___8 |= (unsigned long )((int )*tmp___103 << 16);
#line 1409
        tmp___104 = data_ptr;
#line 1409
        data_ptr ++;
#line 1409
        Xv___8 |= (unsigned long )((int )*tmp___104 << 24);
#line 1409
        encod_group.mcast_addr = (u_int32 )Xv___8;
#line 1409
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 1409
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 1410
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 1410
      tmp___105 = data_ptr;
#line 1410
      data_ptr ++;
#line 1410
      Xv___9 = (u_int16 )((int )*tmp___105 << 8);
#line 1410
      tmp___106 = data_ptr;
#line 1410
      data_ptr ++;
#line 1410
      Xv___9 = (u_int16 )((int )Xv___9 | (int )*tmp___106);
#line 1410
      num_j_srcs = Xv___9;
#line 1410
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 1411
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1411
      tmp___107 = data_ptr;
#line 1411
      data_ptr ++;
#line 1411
      Xv___10 = (u_int16 )((int )*tmp___107 << 8);
#line 1411
      tmp___108 = data_ptr;
#line 1411
      data_ptr ++;
#line 1411
      Xv___10 = (u_int16 )((int )Xv___10 | (int )*tmp___108);
#line 1411
      num_p_srcs = Xv___10;
#line 1411
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 1412
    group = encod_group.mcast_addr;
#line 1413
    tmp___109 = ntohl(group);
    }
#line 1413
    if (tmp___109 != 3758096384U) {
#line 1415
      data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1416
      goto while_continue___27;
    } else
#line 1413
    if ((int )encod_group.masklen != 4) {
#line 1415
      data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1416
      goto while_continue___27;
    }
#line 1422
    star_star_rp_found = 1;
    {
#line 1423
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 1423
      tmp___118 = num_j_srcs;
#line 1423
      num_j_srcs = (u_int16 )((int )num_j_srcs - 1);
#line 1423
      if (! tmp___118) {
#line 1423
        goto while_break___32;
      }
      {
#line 1424
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 1424
        tmp___110 = data_ptr;
#line 1424
        data_ptr ++;
#line 1424
        encod_src.addr_family = *tmp___110;
#line 1424
        tmp___111 = data_ptr;
#line 1424
        data_ptr ++;
#line 1424
        encod_src.encod_type = *tmp___111;
#line 1424
        tmp___112 = data_ptr;
#line 1424
        data_ptr ++;
#line 1424
        encod_src.flags = *tmp___112;
#line 1424
        tmp___113 = data_ptr;
#line 1424
        data_ptr ++;
#line 1424
        encod_src.masklen = *tmp___113;
        {
#line 1424
        while (1) {
          while_continue___34: /* CIL Label */ ;
#line 1424
          tmp___114 = data_ptr;
#line 1424
          data_ptr ++;
#line 1424
          Xv___11 = (u_long )*tmp___114;
#line 1424
          tmp___115 = data_ptr;
#line 1424
          data_ptr ++;
#line 1424
          Xv___11 |= (unsigned long )((int )*tmp___115 << 8);
#line 1424
          tmp___116 = data_ptr;
#line 1424
          data_ptr ++;
#line 1424
          Xv___11 |= (unsigned long )((int )*tmp___116 << 16);
#line 1424
          tmp___117 = data_ptr;
#line 1424
          data_ptr ++;
#line 1424
          Xv___11 |= (unsigned long )((int )*tmp___117 << 24);
#line 1424
          encod_src.src_addr = (u_int32 )Xv___11;
#line 1424
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
#line 1424
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
      {
#line 1425
      rpentry_ptr = rp_find(encod_src.src_addr);
      }
#line 1426
      if ((unsigned long )rpentry_ptr == (unsigned long )((rpentry_t *)((void *)0))) {
#line 1427
        goto while_continue___32;
      }
#line 1428
      rp_grp_entry_ptr = (rpentry_ptr->cand_rp)->rp_grp_next;
      {
#line 1428
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 1428
        if (! ((unsigned long )rp_grp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 1428
          goto while_break___35;
        }
#line 1431
        grpentry_ptr = rp_grp_entry_ptr->grplink;
        {
#line 1431
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 1431
          if (! ((unsigned long )grpentry_ptr != (unsigned long )((grpentry_t *)((void *)0)))) {
#line 1431
            goto while_break___36;
          }
#line 1434
          if ((unsigned long )grpentry_ptr->grp_route != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 1435
            (grpentry_ptr->grp_route)->pruned_oifs &= (unsigned long )(~ (1 << (int )vifi));
          }
#line 1436
          mrtentry_ptr = grpentry_ptr->mrtlink;
          {
#line 1436
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 1436
            if (! ((unsigned long )mrtentry_ptr != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 1436
              goto while_break___37;
            }
#line 1439
            mrtentry_ptr->pruned_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1436
            mrtentry_ptr = mrtentry_ptr->grpnext;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 1431
          grpentry_ptr = grpentry_ptr->rpnext;
        }
        while_break___36: /* CIL Label */ ;
        }
#line 1428
        rp_grp_entry_ptr = rp_grp_entry_ptr->rp_grp_next;
      }
      while_break___35: /* CIL Label */ ;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
#line 1443
    data_ptr += (unsigned long )num_p_srcs * sizeof(pim_encod_src_addr_t );
  }
  while_break___27: /* CIL Label */ ;
  }
#line 1450
  data_ptr = data_ptr_start;
#line 1451
  num_groups_tmp = num_groups;
  {
#line 1452
  while (1) {
    while_continue___38: /* CIL Label */ ;
#line 1452
    tmp___165 = num_groups_tmp;
#line 1452
    num_groups_tmp = (u_int8 )((int )num_groups_tmp - 1);
#line 1452
    if (! tmp___165) {
#line 1452
      goto while_break___38;
    }
    {
#line 1453
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 1453
      tmp___120 = data_ptr;
#line 1453
      data_ptr ++;
#line 1453
      encod_group.addr_family = *tmp___120;
#line 1453
      tmp___121 = data_ptr;
#line 1453
      data_ptr ++;
#line 1453
      encod_group.encod_type = *tmp___121;
#line 1453
      tmp___122 = data_ptr;
#line 1453
      data_ptr ++;
#line 1453
      encod_group.reserved = *tmp___122;
#line 1453
      tmp___123 = data_ptr;
#line 1453
      data_ptr ++;
#line 1453
      encod_group.masklen = *tmp___123;
      {
#line 1453
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 1453
        tmp___124 = data_ptr;
#line 1453
        data_ptr ++;
#line 1453
        Xv___12 = (u_long )*tmp___124;
#line 1453
        tmp___125 = data_ptr;
#line 1453
        data_ptr ++;
#line 1453
        Xv___12 |= (unsigned long )((int )*tmp___125 << 8);
#line 1453
        tmp___126 = data_ptr;
#line 1453
        data_ptr ++;
#line 1453
        Xv___12 |= (unsigned long )((int )*tmp___126 << 16);
#line 1453
        tmp___127 = data_ptr;
#line 1453
        data_ptr ++;
#line 1453
        Xv___12 |= (unsigned long )((int )*tmp___127 << 24);
#line 1453
        encod_group.mcast_addr = (u_int32 )Xv___12;
#line 1453
        goto while_break___40;
      }
      while_break___40: /* CIL Label */ ;
      }
#line 1453
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 1454
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 1454
      tmp___128 = data_ptr;
#line 1454
      data_ptr ++;
#line 1454
      Xv___13 = (u_int16 )((int )*tmp___128 << 8);
#line 1454
      tmp___129 = data_ptr;
#line 1454
      data_ptr ++;
#line 1454
      Xv___13 = (u_int16 )((int )Xv___13 | (int )*tmp___129);
#line 1454
      num_j_srcs = Xv___13;
#line 1454
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 1455
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 1455
      tmp___130 = data_ptr;
#line 1455
      data_ptr ++;
#line 1455
      Xv___14 = (u_int16 )((int )*tmp___130 << 8);
#line 1455
      tmp___131 = data_ptr;
#line 1455
      data_ptr ++;
#line 1455
      Xv___14 = (u_int16 )((int )Xv___14 | (int )*tmp___131);
#line 1455
      num_p_srcs = Xv___14;
#line 1455
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 1456
    group = encod_group.mcast_addr;
#line 1457
    tmp___132 = ntohl(group);
    }
#line 1457
    if (! ((tmp___132 & 4026531840U) == 3758096384U)) {
#line 1458
      data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1459
      goto while_continue___38;
    }
    {
#line 1462
    tmp___133 = ntohl(group);
    }
#line 1462
    if (tmp___133 == 3758096384U) {
#line 1462
      if ((int )encod_group.masklen == 4) {
#line 1465
        data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1466
        goto while_continue___38;
      }
    }
    {
#line 1469
    rpentry_ptr = rp_match(group);
    }
#line 1470
    if ((unsigned long )rpentry_ptr == (unsigned long )((rpentry_t *)((void *)0))) {
#line 1471
      data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1472
      goto while_continue___38;
    }
#line 1475
    data_ptr_group_j_start = data_ptr;
#line 1476
    data_ptr_group_p_start = data_ptr + (unsigned long )num_j_srcs * sizeof(pim_encod_src_addr_t );
#line 1477
    data_ptr_group_end = data_ptr + (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1484
    num_j_srcs_tmp = num_j_srcs;
#line 1485
    ignore_group = 0;
    {
#line 1486
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 1486
      tmp___142 = num_j_srcs_tmp;
#line 1486
      num_j_srcs_tmp = (u_int16 )((int )num_j_srcs_tmp - 1);
#line 1486
      if (! tmp___142) {
#line 1486
        goto while_break___43;
      }
      {
#line 1487
      while (1) {
        while_continue___44: /* CIL Label */ ;
#line 1487
        tmp___134 = data_ptr;
#line 1487
        data_ptr ++;
#line 1487
        encod_src.addr_family = *tmp___134;
#line 1487
        tmp___135 = data_ptr;
#line 1487
        data_ptr ++;
#line 1487
        encod_src.encod_type = *tmp___135;
#line 1487
        tmp___136 = data_ptr;
#line 1487
        data_ptr ++;
#line 1487
        encod_src.flags = *tmp___136;
#line 1487
        tmp___137 = data_ptr;
#line 1487
        data_ptr ++;
#line 1487
        encod_src.masklen = *tmp___137;
        {
#line 1487
        while (1) {
          while_continue___45: /* CIL Label */ ;
#line 1487
          tmp___138 = data_ptr;
#line 1487
          data_ptr ++;
#line 1487
          Xv___15 = (u_long )*tmp___138;
#line 1487
          tmp___139 = data_ptr;
#line 1487
          data_ptr ++;
#line 1487
          Xv___15 |= (unsigned long )((int )*tmp___139 << 8);
#line 1487
          tmp___140 = data_ptr;
#line 1487
          data_ptr ++;
#line 1487
          Xv___15 |= (unsigned long )((int )*tmp___140 << 16);
#line 1487
          tmp___141 = data_ptr;
#line 1487
          data_ptr ++;
#line 1487
          Xv___15 |= (unsigned long )((int )*tmp___141 << 24);
#line 1487
          encod_src.src_addr = (u_int32 )Xv___15;
#line 1487
          goto while_break___45;
        }
        while_break___45: /* CIL Label */ ;
        }
#line 1487
        goto while_break___44;
      }
      while_break___44: /* CIL Label */ ;
      }
#line 1488
      if ((int )encod_src.flags & 1) {
#line 1488
        if ((int )encod_src.flags & 2) {
#line 1493
          if (rpentry_ptr->address != encod_src.src_addr) {
#line 1494
            ignore_group = 1;
#line 1495
            goto while_break___43;
          }
          {
#line 1498
          mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)0);
          }
#line 1499
          if (mrtentry_ptr) {
#line 1500
            mrtentry_srcs = (mrtentry_ptr->group)->mrtlink;
            {
#line 1500
            while (1) {
              while_continue___46: /* CIL Label */ ;
#line 1500
              if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 1500
                goto while_break___46;
              }
#line 1503
              mrtentry_srcs->pruned_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1500
              mrtentry_srcs = mrtentry_srcs->grpnext;
            }
            while_break___46: /* CIL Label */ ;
            }
          }
#line 1505
          goto while_break___43;
        }
      }
    }
    while_break___43: /* CIL Label */ ;
    }
#line 1509
    if (ignore_group == 1) {
#line 1510
      data_ptr += (unsigned long )((int )num_j_srcs_tmp + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1511
      goto while_continue___38;
    }
#line 1514
    data_ptr = data_ptr_group_p_start;
    {
#line 1516
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 1516
      tmp___152 = num_p_srcs;
#line 1516
      num_p_srcs = (u_int16 )((int )num_p_srcs - 1);
#line 1516
      if (! tmp___152) {
#line 1516
        goto while_break___47;
      }
      {
#line 1517
      while (1) {
        while_continue___48: /* CIL Label */ ;
#line 1517
        tmp___143 = data_ptr;
#line 1517
        data_ptr ++;
#line 1517
        encod_src.addr_family = *tmp___143;
#line 1517
        tmp___144 = data_ptr;
#line 1517
        data_ptr ++;
#line 1517
        encod_src.encod_type = *tmp___144;
#line 1517
        tmp___145 = data_ptr;
#line 1517
        data_ptr ++;
#line 1517
        encod_src.flags = *tmp___145;
#line 1517
        tmp___146 = data_ptr;
#line 1517
        data_ptr ++;
#line 1517
        encod_src.masklen = *tmp___146;
        {
#line 1517
        while (1) {
          while_continue___49: /* CIL Label */ ;
#line 1517
          tmp___147 = data_ptr;
#line 1517
          data_ptr ++;
#line 1517
          Xv___16 = (u_long )*tmp___147;
#line 1517
          tmp___148 = data_ptr;
#line 1517
          data_ptr ++;
#line 1517
          Xv___16 |= (unsigned long )((int )*tmp___148 << 8);
#line 1517
          tmp___149 = data_ptr;
#line 1517
          data_ptr ++;
#line 1517
          Xv___16 |= (unsigned long )((int )*tmp___149 << 16);
#line 1517
          tmp___150 = data_ptr;
#line 1517
          data_ptr ++;
#line 1517
          Xv___16 |= (unsigned long )((int )*tmp___150 << 24);
#line 1517
          encod_src.src_addr = (u_int32 )Xv___16;
#line 1517
          goto while_break___49;
        }
        while_break___49: /* CIL Label */ ;
        }
#line 1517
        goto while_break___48;
      }
      while_break___48: /* CIL Label */ ;
      }
      {
#line 1518
      source = encod_src.src_addr;
#line 1519
      tmp___151 = inet_valid_host(source);
      }
#line 1519
      if (! tmp___151) {
#line 1520
        goto while_continue___47;
      }
#line 1522
      s_flags = encod_src.flags;
#line 1523
      if (! ((int )s_flags & 3)) {
        {
#line 1525
        mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)0);
        }
#line 1526
        if (! mrtentry_ptr) {
#line 1527
          goto while_continue___47;
        }
#line 1534
        if (v->uv_flags & 1048576U) {
#line 1535
          *(mrtentry_ptr->vif_timers + vifi) = (u_int16 )0;
        } else
#line 1538
        if ((int )*(mrtentry_ptr->vif_timers + vifi) > (int )*(mrtentry_ptr->vif_deletion_delay + vifi)) {
#line 1539
          *(mrtentry_ptr->vif_timers + vifi) = *(mrtentry_ptr->vif_deletion_delay + vifi);
        }
#line 1542
        if ((int )*(mrtentry_ptr->vif_timers + vifi) <= 0) {
          {
#line 1543
          mrtentry_ptr->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1544
          mrtentry_ptr->pruned_oifs |= (unsigned long )(1 << (int )vifi);
#line 1545
          change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                            mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                            (u_int16 )0);
          }
        }
#line 1552
        goto while_continue___47;
      }
#line 1555
      if ((int )s_flags & 1) {
#line 1555
        if (! ((int )s_flags & 2)) {
          {
#line 1557
          mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)0);
          }
#line 1558
          if (mrtentry_ptr) {
#line 1559
            mrtentry_ptr->timer = holdtime;
#line 1560
            if (v->uv_flags & 1048576U) {
#line 1561
              *(mrtentry_ptr->vif_timers + vifi) = (u_int16 )0;
            } else
#line 1564
            if ((int )*(mrtentry_ptr->vif_timers + vifi) > (int )*(mrtentry_ptr->vif_deletion_delay + vifi)) {
#line 1565
              *(mrtentry_ptr->vif_timers + vifi) = *(mrtentry_ptr->vif_deletion_delay + vifi);
            }
#line 1568
            if ((int )*(mrtentry_ptr->vif_timers + vifi) <= 0) {
              {
#line 1569
              mrtentry_ptr->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1570
              mrtentry_ptr->pruned_oifs |= (unsigned long )(1 << (int )vifi);
#line 1571
              change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                                mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                                (u_int16 )0);
              }
            }
#line 1578
            goto while_continue___47;
          }
          {
#line 1582
          mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )16386, (char)0);
          }
#line 1583
          if (mrtentry_ptr) {
            {
#line 1584
            mrtentry_ptr = find_route(source, group, (u_int16 )8196, (char)1);
            }
#line 1585
            if (! mrtentry_ptr) {
#line 1586
              goto while_continue___47;
            }
            {
#line 1588
            mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 1589
            *(mrtentry_ptr->vif_timers + vifi) = (u_int16 )0;
#line 1593
            mrtentry_ptr->timer = holdtime;
#line 1598
            mrtentry_ptr->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1599
            mrtentry_ptr->pruned_oifs |= (unsigned long )(1 << (int )vifi);
#line 1600
            change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                              mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                              (u_int16 )0);
            }
          }
#line 1607
          goto while_continue___47;
        }
      }
#line 1610
      if ((int )s_flags & 1) {
#line 1610
        if ((int )s_flags & 2) {
          {
#line 1612
          mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )16386, (char)0);
          }
#line 1613
          if (mrtentry_ptr) {
#line 1614
            if ((int )mrtentry_ptr->flags & 2) {
#line 1620
              if (((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->address != source) {
#line 1621
                goto while_continue___47;
              }
#line 1623
              if (v->uv_flags & 1048576U) {
#line 1624
                *(mrtentry_ptr->vif_timers + vifi) = (u_int16 )0;
              } else
#line 1627
              if ((int )*(mrtentry_ptr->vif_timers + vifi) > (int )*(mrtentry_ptr->vif_deletion_delay + vifi)) {
#line 1628
                *(mrtentry_ptr->vif_timers + vifi) = *(mrtentry_ptr->vif_deletion_delay + vifi);
              }
#line 1631
              if ((int )*(mrtentry_ptr->vif_timers + vifi) <= 0) {
                {
#line 1632
                mrtentry_ptr->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1633
                mrtentry_ptr->pruned_oifs |= (unsigned long )(1 << (int )vifi);
#line 1634
                change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                                  mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves,
                                  mrtentry_ptr->asserted_oifs, (u_int16 )0);
                }
              }
#line 1641
              goto while_continue___47;
            }
#line 1645
            if ((mrtentry_ptr->source)->address != source) {
#line 1646
              goto while_continue___47;
            }
            {
#line 1648
            mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)1);
            }
#line 1649
            if (! mrtentry_ptr) {
#line 1650
              goto while_continue___47;
            }
            {
#line 1652
            mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 1653
            *(mrtentry_ptr->vif_timers + vifi) = (u_int16 )0;
#line 1657
            mrtentry_ptr->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1658
            mrtentry_ptr->pruned_oifs |= (unsigned long )(1 << (int )vifi);
#line 1659
            change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                              mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                              (u_int16 )0);
            }
          }
        }
      }
    }
    while_break___47: /* CIL Label */ ;
    }
#line 1671
    data_ptr = data_ptr_group_j_start;
    {
#line 1672
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 1672
      tmp___164 = num_j_srcs;
#line 1672
      num_j_srcs = (u_int16 )((int )num_j_srcs - 1);
#line 1672
      if (! tmp___164) {
#line 1672
        goto while_break___50;
      }
      {
#line 1673
      while (1) {
        while_continue___51: /* CIL Label */ ;
#line 1673
        tmp___153 = data_ptr;
#line 1673
        data_ptr ++;
#line 1673
        encod_src.addr_family = *tmp___153;
#line 1673
        tmp___154 = data_ptr;
#line 1673
        data_ptr ++;
#line 1673
        encod_src.encod_type = *tmp___154;
#line 1673
        tmp___155 = data_ptr;
#line 1673
        data_ptr ++;
#line 1673
        encod_src.flags = *tmp___155;
#line 1673
        tmp___156 = data_ptr;
#line 1673
        data_ptr ++;
#line 1673
        encod_src.masklen = *tmp___156;
        {
#line 1673
        while (1) {
          while_continue___52: /* CIL Label */ ;
#line 1673
          tmp___157 = data_ptr;
#line 1673
          data_ptr ++;
#line 1673
          Xv___17 = (u_long )*tmp___157;
#line 1673
          tmp___158 = data_ptr;
#line 1673
          data_ptr ++;
#line 1673
          Xv___17 |= (unsigned long )((int )*tmp___158 << 8);
#line 1673
          tmp___159 = data_ptr;
#line 1673
          data_ptr ++;
#line 1673
          Xv___17 |= (unsigned long )((int )*tmp___159 << 16);
#line 1673
          tmp___160 = data_ptr;
#line 1673
          data_ptr ++;
#line 1673
          Xv___17 |= (unsigned long )((int )*tmp___160 << 24);
#line 1673
          encod_src.src_addr = (u_int32 )Xv___17;
#line 1673
          goto while_break___52;
        }
        while_break___52: /* CIL Label */ ;
        }
#line 1673
        goto while_break___51;
      }
      while_break___51: /* CIL Label */ ;
      }
      {
#line 1674
      source = encod_src.src_addr;
#line 1675
      tmp___161 = inet_valid_host(source);
      }
#line 1675
      if (! tmp___161) {
#line 1676
        goto while_continue___50;
      }
#line 1678
      s_flags = encod_src.flags;
      {
#line 1679
      while (1) {
        while_continue___53: /* CIL Label */ ;
#line 1679
        if (encod_src.masklen) {
          {
#line 1679
          tmp___162 = htonl((uint32_t )(-1 << ((sizeof(s_mask) << 3) - (unsigned long )encod_src.masklen)));
#line 1679
          s_mask = tmp___162;
          }
        } else {
#line 1679
          s_mask = (u_int32 )0;
        }
#line 1679
        goto while_break___53;
      }
      while_break___53: /* CIL Label */ ;
      }
#line 1680
      if ((int )s_flags & 2) {
#line 1680
        if ((int )s_flags & 1) {
          {
#line 1685
          mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )2, (char)1);
          }
#line 1686
          if (! mrtentry_ptr) {
#line 1687
            goto while_continue___50;
          }
#line 1689
          mrtentry_ptr->joined_oifs |= (unsigned long )(1 << (int )vifi);
#line 1690
          mrtentry_ptr->pruned_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1691
          mrtentry_ptr->asserted_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1693
          if ((int )*(mrtentry_ptr->vif_timers + vifi) < (int )holdtime) {
#line 1694
            *(mrtentry_ptr->vif_timers + vifi) = holdtime;
#line 1695
            *(mrtentry_ptr->vif_deletion_delay + vifi) = (u_int16 )((int )holdtime / 3);
          }
#line 1697
          if ((int )mrtentry_ptr->timer < (int )holdtime) {
#line 1698
            mrtentry_ptr->timer = holdtime;
          }
          {
#line 1699
          mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 1700
          change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                            mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                            (u_int16 )0);
#line 1711
          mrtentry_srcs = (mrtentry_ptr->group)->mrtlink;
          }
          {
#line 1711
          while (1) {
            while_continue___54: /* CIL Label */ ;
#line 1711
            if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 1711
              goto while_break___54;
            }
            {
#line 1714
            change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                              mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves, mrtentry_srcs->asserted_oifs,
                              (u_int16 )0);
#line 1711
            mrtentry_srcs = mrtentry_srcs->grpnext;
            }
          }
          while_break___54: /* CIL Label */ ;
          }
#line 1720
          goto while_continue___50;
        }
      }
#line 1723
      if (! ((int )s_flags & 3)) {
        {
#line 1725
        tmp___163 = get_iif(source);
        }
#line 1725
        if ((int )vifi == (int )tmp___163) {
#line 1726
          goto while_continue___50;
        }
        {
#line 1728
        mrtentry_ptr = find_route(source, group, (u_int16 )8192, (char)1);
        }
#line 1729
        if (! mrtentry_ptr) {
#line 1730
          goto while_continue___50;
        }
#line 1732
        mrtentry_ptr->joined_oifs |= (unsigned long )(1 << (int )vifi);
#line 1733
        mrtentry_ptr->pruned_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1734
        mrtentry_ptr->asserted_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1736
        if ((int )*(mrtentry_ptr->vif_timers + vifi) < (int )holdtime) {
#line 1737
          *(mrtentry_ptr->vif_timers + vifi) = holdtime;
#line 1738
          *(mrtentry_ptr->vif_deletion_delay + vifi) = (u_int16 )((int )holdtime / 3);
        }
#line 1740
        if ((int )mrtentry_ptr->timer < (int )holdtime) {
#line 1741
          mrtentry_ptr->timer = holdtime;
        }
        {
#line 1747
        mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 1752
        change_interfaces(mrtentry_ptr, (mrtentry_ptr->source)->incoming, mrtentry_ptr->joined_oifs,
                          mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                          (u_int16 )0);
        }
#line 1758
        goto while_continue___50;
      }
    }
    while_break___50: /* CIL Label */ ;
    }
#line 1761
    data_ptr = data_ptr_group_end;
  }
  while_break___38: /* CIL Label */ ;
  }
#line 1765
  if (star_star_rp_found != 1) {
#line 1766
    return (1);
  }
#line 1768
  data_ptr = data_ptr_start;
  {
#line 1769
  while (1) {
    while_continue___55: /* CIL Label */ ;
#line 1769
    tmp___201 = num_groups;
#line 1769
    num_groups = (u_int8 )((int )num_groups - 1);
#line 1769
    if (! tmp___201) {
#line 1769
      goto while_break___55;
    }
    {
#line 1773
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 1773
      tmp___166 = data_ptr;
#line 1773
      data_ptr ++;
#line 1773
      encod_group.addr_family = *tmp___166;
#line 1773
      tmp___167 = data_ptr;
#line 1773
      data_ptr ++;
#line 1773
      encod_group.encod_type = *tmp___167;
#line 1773
      tmp___168 = data_ptr;
#line 1773
      data_ptr ++;
#line 1773
      encod_group.reserved = *tmp___168;
#line 1773
      tmp___169 = data_ptr;
#line 1773
      data_ptr ++;
#line 1773
      encod_group.masklen = *tmp___169;
      {
#line 1773
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 1773
        tmp___170 = data_ptr;
#line 1773
        data_ptr ++;
#line 1773
        Xv___18 = (u_long )*tmp___170;
#line 1773
        tmp___171 = data_ptr;
#line 1773
        data_ptr ++;
#line 1773
        Xv___18 |= (unsigned long )((int )*tmp___171 << 8);
#line 1773
        tmp___172 = data_ptr;
#line 1773
        data_ptr ++;
#line 1773
        Xv___18 |= (unsigned long )((int )*tmp___172 << 16);
#line 1773
        tmp___173 = data_ptr;
#line 1773
        data_ptr ++;
#line 1773
        Xv___18 |= (unsigned long )((int )*tmp___173 << 24);
#line 1773
        encod_group.mcast_addr = (u_int32 )Xv___18;
#line 1773
        goto while_break___57;
      }
      while_break___57: /* CIL Label */ ;
      }
#line 1773
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 1774
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 1774
      tmp___174 = data_ptr;
#line 1774
      data_ptr ++;
#line 1774
      Xv___19 = (u_int16 )((int )*tmp___174 << 8);
#line 1774
      tmp___175 = data_ptr;
#line 1774
      data_ptr ++;
#line 1774
      Xv___19 = (u_int16 )((int )Xv___19 | (int )*tmp___175);
#line 1774
      num_j_srcs = Xv___19;
#line 1774
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 1775
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1775
      tmp___176 = data_ptr;
#line 1775
      data_ptr ++;
#line 1775
      Xv___20 = (u_int16 )((int )*tmp___176 << 8);
#line 1775
      tmp___177 = data_ptr;
#line 1775
      data_ptr ++;
#line 1775
      Xv___20 = (u_int16 )((int )Xv___20 | (int )*tmp___177);
#line 1775
      num_p_srcs = Xv___20;
#line 1775
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 1776
    group = encod_group.mcast_addr;
#line 1777
    tmp___178 = ntohl(group);
    }
#line 1777
    if (tmp___178 != 3758096384U) {
#line 1780
      data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1782
      goto while_continue___55;
    } else
#line 1777
    if ((int )encod_group.masklen != 4) {
#line 1780
      data_ptr += (unsigned long )((int )num_j_srcs + (int )num_p_srcs) * sizeof(pim_encod_src_addr_t );
#line 1782
      goto while_continue___55;
    }
    {
#line 1785
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 1785
      tmp___189 = num_j_srcs;
#line 1785
      num_j_srcs = (u_int16 )((int )num_j_srcs - 1);
#line 1785
      if (! tmp___189) {
#line 1785
        goto while_break___60;
      }
      {
#line 1787
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 1787
        tmp___179 = data_ptr;
#line 1787
        data_ptr ++;
#line 1787
        encod_src.addr_family = *tmp___179;
#line 1787
        tmp___180 = data_ptr;
#line 1787
        data_ptr ++;
#line 1787
        encod_src.encod_type = *tmp___180;
#line 1787
        tmp___181 = data_ptr;
#line 1787
        data_ptr ++;
#line 1787
        encod_src.flags = *tmp___181;
#line 1787
        tmp___182 = data_ptr;
#line 1787
        data_ptr ++;
#line 1787
        encod_src.masklen = *tmp___182;
        {
#line 1787
        while (1) {
          while_continue___62: /* CIL Label */ ;
#line 1787
          tmp___183 = data_ptr;
#line 1787
          data_ptr ++;
#line 1787
          Xv___21 = (u_long )*tmp___183;
#line 1787
          tmp___184 = data_ptr;
#line 1787
          data_ptr ++;
#line 1787
          Xv___21 |= (unsigned long )((int )*tmp___184 << 8);
#line 1787
          tmp___185 = data_ptr;
#line 1787
          data_ptr ++;
#line 1787
          Xv___21 |= (unsigned long )((int )*tmp___185 << 16);
#line 1787
          tmp___186 = data_ptr;
#line 1787
          data_ptr ++;
#line 1787
          Xv___21 |= (unsigned long )((int )*tmp___186 << 24);
#line 1787
          encod_src.src_addr = (u_int32 )Xv___21;
#line 1787
          goto while_break___62;
        }
        while_break___62: /* CIL Label */ ;
        }
#line 1787
        goto while_break___61;
      }
      while_break___61: /* CIL Label */ ;
      }
      {
#line 1788
      source = encod_src.src_addr;
#line 1789
      tmp___187 = inet_valid_host(source);
      }
#line 1789
      if (! tmp___187) {
#line 1790
        goto while_continue___60;
      }
#line 1792
      s_flags = encod_src.flags;
      {
#line 1793
      while (1) {
        while_continue___63: /* CIL Label */ ;
#line 1793
        if (encod_src.masklen) {
          {
#line 1793
          tmp___188 = htonl((uint32_t )(-1 << ((sizeof(s_mask) << 3) - (unsigned long )encod_src.masklen)));
#line 1793
          s_mask = tmp___188;
          }
        } else {
#line 1793
          s_mask = (u_int32 )0;
        }
#line 1793
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
      {
#line 1794
      mrtentry_ptr = find_route(source, (u_int32 )0, (u_int16 )16384, (char)1);
      }
#line 1795
      if ((unsigned long )mrtentry_ptr == (unsigned long )((mrtentry_t *)((void *)0))) {
#line 1796
        goto while_continue___60;
      }
#line 1798
      mrtentry_ptr->joined_oifs |= (unsigned long )(1 << (int )vifi);
#line 1799
      mrtentry_ptr->pruned_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1800
      mrtentry_ptr->asserted_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1802
      if ((int )*(mrtentry_ptr->vif_timers + vifi) < (int )holdtime) {
#line 1803
        *(mrtentry_ptr->vif_timers + vifi) = holdtime;
#line 1804
        *(mrtentry_ptr->vif_deletion_delay + vifi) = (u_int16 )((int )holdtime / 3);
      }
#line 1806
      if ((int )mrtentry_ptr->timer < (int )holdtime) {
#line 1807
        mrtentry_ptr->timer = holdtime;
      }
      {
#line 1808
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -9);
#line 1809
      change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                        mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                        (u_int16 )0);
#line 1821
      rp_grp_entry_ptr = ((mrtentry_ptr->source)->cand_rp)->rp_grp_next;
      }
      {
#line 1821
      while (1) {
        while_continue___64: /* CIL Label */ ;
#line 1821
        if (! ((unsigned long )rp_grp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 1821
          goto while_break___64;
        }
#line 1824
        grpentry_ptr = rp_grp_entry_ptr->grplink;
        {
#line 1824
        while (1) {
          while_continue___65: /* CIL Label */ ;
#line 1824
          if (! ((unsigned long )grpentry_ptr != (unsigned long )((grpentry_t *)((void *)0)))) {
#line 1824
            goto while_break___65;
          }
#line 1828
          if ((unsigned long )grpentry_ptr->grp_route != (unsigned long )((void *)0)) {
            {
#line 1829
            change_interfaces(grpentry_ptr->grp_route, (grpentry_ptr->grp_route)->incoming,
                              (grpentry_ptr->grp_route)->joined_oifs, (grpentry_ptr->grp_route)->pruned_oifs,
                              (grpentry_ptr->grp_route)->leaves, (grpentry_ptr->grp_route)->asserted_oifs,
                              (u_int16 )0);
            }
          }
#line 1837
          mrtentry_srcs = grpentry_ptr->mrtlink;
          {
#line 1837
          while (1) {
            while_continue___66: /* CIL Label */ ;
#line 1837
            if (! ((unsigned long )mrtentry_srcs != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 1837
              goto while_break___66;
            }
            {
#line 1840
            change_interfaces(mrtentry_srcs, mrtentry_srcs->incoming, mrtentry_srcs->joined_oifs,
                              mrtentry_srcs->pruned_oifs, mrtentry_srcs->leaves, mrtentry_srcs->asserted_oifs,
                              (u_int16 )0);
#line 1837
            mrtentry_srcs = mrtentry_srcs->grpnext;
            }
          }
          while_break___66: /* CIL Label */ ;
          }
#line 1824
          grpentry_ptr = grpentry_ptr->rpnext;
        }
        while_break___65: /* CIL Label */ ;
        }
#line 1821
        rp_grp_entry_ptr = rp_grp_entry_ptr->rp_grp_next;
      }
      while_break___64: /* CIL Label */ ;
      }
#line 1848
      goto while_continue___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 1851
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 1851
      tmp___200 = num_p_srcs;
#line 1851
      num_p_srcs = (u_int16 )((int )num_p_srcs - 1);
#line 1851
      if (! tmp___200) {
#line 1851
        goto while_break___67;
      }
      {
#line 1853
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 1853
        tmp___190 = data_ptr;
#line 1853
        data_ptr ++;
#line 1853
        encod_src.addr_family = *tmp___190;
#line 1853
        tmp___191 = data_ptr;
#line 1853
        data_ptr ++;
#line 1853
        encod_src.encod_type = *tmp___191;
#line 1853
        tmp___192 = data_ptr;
#line 1853
        data_ptr ++;
#line 1853
        encod_src.flags = *tmp___192;
#line 1853
        tmp___193 = data_ptr;
#line 1853
        data_ptr ++;
#line 1853
        encod_src.masklen = *tmp___193;
        {
#line 1853
        while (1) {
          while_continue___69: /* CIL Label */ ;
#line 1853
          tmp___194 = data_ptr;
#line 1853
          data_ptr ++;
#line 1853
          Xv___22 = (u_long )*tmp___194;
#line 1853
          tmp___195 = data_ptr;
#line 1853
          data_ptr ++;
#line 1853
          Xv___22 |= (unsigned long )((int )*tmp___195 << 8);
#line 1853
          tmp___196 = data_ptr;
#line 1853
          data_ptr ++;
#line 1853
          Xv___22 |= (unsigned long )((int )*tmp___196 << 16);
#line 1853
          tmp___197 = data_ptr;
#line 1853
          data_ptr ++;
#line 1853
          Xv___22 |= (unsigned long )((int )*tmp___197 << 24);
#line 1853
          encod_src.src_addr = (u_int32 )Xv___22;
#line 1853
          goto while_break___69;
        }
        while_break___69: /* CIL Label */ ;
        }
#line 1853
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
      {
#line 1854
      source = encod_src.src_addr;
#line 1855
      tmp___198 = inet_valid_host(source);
      }
#line 1855
      if (! tmp___198) {
#line 1856
        goto while_continue___67;
      }
#line 1858
      s_flags = encod_src.flags;
      {
#line 1859
      while (1) {
        while_continue___70: /* CIL Label */ ;
#line 1859
        if (encod_src.masklen) {
          {
#line 1859
          tmp___199 = htonl((uint32_t )(-1 << ((sizeof(s_mask) << 3) - (unsigned long )encod_src.masklen)));
#line 1859
          s_mask = tmp___199;
          }
        } else {
#line 1859
          s_mask = (u_int32 )0;
        }
#line 1859
        goto while_break___70;
      }
      while_break___70: /* CIL Label */ ;
      }
      {
#line 1860
      mrtentry_ptr = find_route(source, (u_int32 )0, (u_int16 )16384, (char)0);
      }
#line 1861
      if ((unsigned long )mrtentry_ptr == (unsigned long )((mrtentry_t *)((void *)0))) {
#line 1862
        goto while_continue___67;
      }
#line 1869
      if (v->uv_flags & 1048576U) {
#line 1870
        *(mrtentry_ptr->vif_timers + vifi) = (u_int16 )0;
      } else
#line 1873
      if ((int )*(mrtentry_ptr->vif_timers + vifi) > (int )*(mrtentry_ptr->vif_deletion_delay + vifi)) {
#line 1874
        *(mrtentry_ptr->vif_timers + vifi) = *(mrtentry_ptr->vif_deletion_delay + vifi);
      }
#line 1877
      if ((int )*(mrtentry_ptr->vif_timers + vifi) <= 0) {
        {
#line 1878
        mrtentry_ptr->joined_oifs &= (unsigned long )(~ (1 << (int )vifi));
#line 1879
        mrtentry_ptr->pruned_oifs |= (unsigned long )(1 << (int )vifi);
#line 1880
        mrtentry_ptr->asserted_oifs |= (unsigned long )(1 << (int )vifi);
#line 1881
        change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                          mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                          (u_int16 )0);
        }
      }
    }
    while_break___67: /* CIL Label */ ;
    }
  }
  while_break___55: /* CIL Label */ ;
  }
#line 1892
  return (1);
}
}
#line 1914 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int send_periodic_pim_join_prune(vifi_t vifi , pim_nbr_entry_t *pim_nbr , u_int16 holdtime ) 
{ 
  grpentry_t *grpentry_ptr ;
  mrtentry_t *mrtentry_ptr ;
  rpentry_t *rpentry_ptr ;
  u_int32 src_addr ;
  struct uvif *v ;
  pim_nbr_entry_t *pim_nbr_ptr ;
  cand_rp_t *cand_rp_ptr ;
  vifi_t tmp ;
  uint32_t tmp___0 ;

  {
#line 1932
  v = & uvifs[vifi];
#line 1935
  grpentry_ptr = grplist;
  {
#line 1935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1935
    if (! grpentry_ptr) {
#line 1935
      goto while_break;
    }
#line 1936
    mrtentry_ptr = grpentry_ptr->grp_route;
#line 1938
    if (mrtentry_ptr) {
#line 1938
      if ((int )mrtentry_ptr->incoming == (int )vifi) {
#line 1938
        if ((int )mrtentry_ptr->jp_timer <= 5) {
#line 1943
          if (pim_nbr) {
#line 1943
            if ((unsigned long )mrtentry_ptr->upstream != (unsigned long )pim_nbr) {
#line 1944
              goto __Cont;
            }
          }
#line 1947
          if (! (mrtentry_ptr->joined_oifs == 0UL)) {
            {
#line 1948
            add_jp_entry(mrtentry_ptr->upstream, holdtime, grpentry_ptr->group, (u_int8 )32,
                         grpentry_ptr->rpaddr, (u_int8 )32, (u_int16 )0, (u_int8 )1);
            }
          } else
#line 1947
          if (v->uv_flags & 262144U) {
            {
#line 1948
            add_jp_entry(mrtentry_ptr->upstream, holdtime, grpentry_ptr->group, (u_int8 )32,
                         grpentry_ptr->rpaddr, (u_int8 )32, (u_int16 )0, (u_int8 )1);
            }
          }
#line 1955
          if (mrtentry_ptr->joined_oifs == 0UL) {
#line 1955
            if (! (v->uv_flags & 262144U)) {
#line 1955
              if ((int )mrtentry_ptr->jp_timer <= 5) {
                {
#line 1958
                add_jp_entry(mrtentry_ptr->upstream, holdtime, grpentry_ptr->group,
                             (u_int8 )32, grpentry_ptr->rpaddr, (u_int8 )32, (u_int16 )0,
                             (u_int8 )2);
                }
              }
            }
          }
        }
      }
    }
#line 1966
    mrtentry_ptr = grpentry_ptr->mrtlink;
    {
#line 1966
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1966
      if (! mrtentry_ptr) {
#line 1966
        goto while_break___0;
      }
#line 1968
      if (pim_nbr) {
#line 1968
        if ((unsigned long )mrtentry_ptr->upstream != (unsigned long )pim_nbr) {
#line 1969
          goto __Cont___0;
        }
      }
#line 1971
      if ((int )mrtentry_ptr->flags & 4) {
#line 1973
        src_addr = (mrtentry_ptr->source)->address;
#line 1974
        if (mrtentry_ptr->joined_oifs == 0UL) {
#line 1974
          goto _L;
        } else {
          {
#line 1974
          tmp = find_vif_direct_local(src_addr);
          }
#line 1974
          if ((int )tmp != 32) {
#line 1974
            if (grpentry_ptr->grp_route) {
              _L: /* CIL Label */ 
#line 1978
              if ((int )(grpentry_ptr->grp_route)->incoming == (int )vifi) {
#line 1978
                if ((int )(grpentry_ptr->grp_route)->jp_timer <= 5) {
                  {
#line 1981
                  add_jp_entry((grpentry_ptr->grp_route)->upstream, holdtime, grpentry_ptr->group,
                               (u_int8 )32, src_addr, (u_int8 )32, (u_int16 )4, (u_int8 )2);
                  }
                }
              }
            }
          }
        }
      } else {
#line 1989
        if (mrtentry_ptr->joined_oifs == 0UL) {
#line 1991
          if ((int )mrtentry_ptr->incoming == (int )vifi) {
#line 1991
            if ((int )mrtentry_ptr->jp_timer <= 5) {
              {
#line 1993
              add_jp_entry(mrtentry_ptr->upstream, holdtime, grpentry_ptr->group,
                           (u_int8 )32, (mrtentry_ptr->source)->address, (u_int8 )32,
                           (u_int16 )0, (u_int8 )2);
              }
            }
          }
        } else
#line 2000
        if ((int )mrtentry_ptr->incoming == (int )vifi) {
#line 2000
          if ((int )mrtentry_ptr->jp_timer <= 5) {
            {
#line 2002
            add_jp_entry(mrtentry_ptr->upstream, holdtime, grpentry_ptr->group, (u_int8 )32,
                         (mrtentry_ptr->source)->address, (u_int8 )32, (u_int16 )0,
                         (u_int8 )1);
            }
          }
        }
#line 2008
        if ((int )mrtentry_ptr->flags & 1) {
#line 2008
          if (grpentry_ptr->grp_route) {
#line 2008
            if ((int )mrtentry_ptr->incoming != (int )(grpentry_ptr->grp_route)->incoming) {
#line 2008
              if ((int )(grpentry_ptr->grp_route)->incoming == (int )vifi) {
#line 2008
                if ((int )(grpentry_ptr->grp_route)->jp_timer <= 5) {
                  {
#line 2013
                  add_jp_entry((grpentry_ptr->grp_route)->upstream, holdtime, grpentry_ptr->group,
                               (u_int8 )32, (mrtentry_ptr->source)->address, (u_int8 )32,
                               (u_int16 )4, (u_int8 )2);
                  }
                }
              }
            }
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1966
      mrtentry_ptr = mrtentry_ptr->grpnext;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1935
    grpentry_ptr = grpentry_ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2023
  cand_rp_ptr = cand_rp_list;
  {
#line 2023
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2023
    if (! cand_rp_ptr) {
#line 2023
      goto while_break___1;
    }
#line 2024
    rpentry_ptr = cand_rp_ptr->rpentry;
#line 2027
    if (pim_nbr) {
#line 2027
      if ((unsigned long )rpentry_ptr->upstream != (unsigned long )pim_nbr) {
#line 2028
        goto __Cont___1;
      }
    }
#line 2031
    if (rpentry_ptr->mrtlink) {
#line 2031
      if ((int )rpentry_ptr->incoming == (int )vifi) {
#line 2031
        if ((int )(rpentry_ptr->mrtlink)->jp_timer <= 5) {
          {
#line 2034
          tmp___0 = htonl(3758096384U);
#line 2034
          add_jp_entry(rpentry_ptr->upstream, holdtime, tmp___0, (u_int8 )4, rpentry_ptr->address,
                       (u_int8 )32, (u_int16 )6, (u_int8 )1);
          }
        }
      }
    }
    __Cont___1: /* CIL Label */ 
#line 2023
    cand_rp_ptr = cand_rp_ptr->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2040
  pim_nbr_ptr = v->uv_pim_neighbors;
  {
#line 2040
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2040
    if (! pim_nbr_ptr) {
#line 2040
      goto while_break___2;
    }
#line 2042
    if (pim_nbr) {
#line 2042
      if ((unsigned long )pim_nbr_ptr != (unsigned long )pim_nbr) {
#line 2043
        goto __Cont___2;
      }
    }
    {
#line 2045
    pack_and_send_jp_message(pim_nbr_ptr);
    }
    __Cont___2: /* CIL Label */ 
#line 2040
    pim_nbr_ptr = pim_nbr->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2048
  return (1);
}
}
#line 2052 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int add_jp_entry(pim_nbr_entry_t *pim_nbr , u_int16 holdtime , u_int32 group , u_int8 grp_msklen ,
                 u_int32 source , u_int8 src_msklen , u_int16 addr_flags , u_int8 join_prune ) 
{ 
  build_jp_message_t *bjpm ;
  u_int8 *data_ptr ;
  u_int8 flags ;
  int rp_flag ;
  u_int8 *tmp ;
  u_int8 *tmp___0 ;
  register u_int32 Xv ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  register u_int16 Xv___0 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  uint32_t tmp___9 ;
  u_int32 mask ;
  uint32_t tmp___10 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  u_int8 *tmp___14 ;
  register u_int32 Xv___1 ;
  u_int8 *tmp___15 ;
  u_int8 *tmp___16 ;
  u_int8 *tmp___17 ;
  u_int8 *tmp___18 ;

  {
#line 2058
  flags = (u_int8 )0;
#line 2061
  bjpm = pim_nbr->build_jp_message;
#line 2062
  if (bjpm) {
#line 2063
    if ((((bjpm->jp_message_size + bjpm->join_list_size) + bjpm->prune_list_size) + bjpm->rp_list_join_size) + bjpm->rp_list_prune_size >= 8192U) {
      {
#line 2073
      pack_and_send_jp_message(pim_nbr);
#line 2074
      bjpm = pim_nbr->build_jp_message;
      }
    } else
#line 2063
    if (bjpm->join_list_size >= 1500U) {
      {
#line 2073
      pack_and_send_jp_message(pim_nbr);
#line 2074
      bjpm = pim_nbr->build_jp_message;
      }
    } else
#line 2063
    if (bjpm->prune_list_size >= 1500U) {
      {
#line 2073
      pack_and_send_jp_message(pim_nbr);
#line 2074
      bjpm = pim_nbr->build_jp_message;
      }
    } else
#line 2063
    if (bjpm->rp_list_join_size >= 1500U) {
      {
#line 2073
      pack_and_send_jp_message(pim_nbr);
#line 2074
      bjpm = pim_nbr->build_jp_message;
      }
    } else
#line 2063
    if (bjpm->rp_list_prune_size >= 1500U) {
      {
#line 2073
      pack_and_send_jp_message(pim_nbr);
#line 2074
      bjpm = pim_nbr->build_jp_message;
      }
    }
  }
#line 2078
  if (bjpm) {
#line 2079
    if (bjpm->curr_group != group) {
      {
#line 2082
      pack_jp_message(pim_nbr);
      }
    } else
#line 2079
    if ((int )bjpm->curr_group_msklen != (int )grp_msklen) {
      {
#line 2082
      pack_jp_message(pim_nbr);
      }
    } else
#line 2079
    if ((int )bjpm->holdtime != (int )holdtime) {
      {
#line 2082
      pack_jp_message(pim_nbr);
      }
    }
  }
#line 2086
  if (! bjpm) {
    {
#line 2087
    bjpm = get_jp_working_buff();
    }
#line 2088
    if (! bjpm) {
      {
#line 2089
      logit(3, 0, "Failed allocating working buffer in add_jp_entry()\n");
#line 2090
      exit(-1);
      }
    }
#line 2093
    pim_nbr->build_jp_message = bjpm;
#line 2094
    data_ptr = bjpm->jp_message;
    {
#line 2095
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2095
      tmp = data_ptr;
#line 2095
      data_ptr ++;
#line 2095
      *tmp = (u_int8 )1;
#line 2095
      tmp___0 = data_ptr;
#line 2095
      data_ptr ++;
#line 2095
      *tmp___0 = (u_int8 )0;
      {
#line 2095
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2095
        Xv = pim_nbr->address;
#line 2095
        tmp___1 = data_ptr;
#line 2095
        data_ptr ++;
#line 2095
        *tmp___1 = (u_int8 )Xv;
#line 2095
        tmp___2 = data_ptr;
#line 2095
        data_ptr ++;
#line 2095
        *tmp___2 = (u_int8 )(Xv >> 8);
#line 2095
        tmp___3 = data_ptr;
#line 2095
        data_ptr ++;
#line 2095
        *tmp___3 = (u_int8 )(Xv >> 16);
#line 2095
        tmp___4 = data_ptr;
#line 2095
        data_ptr ++;
#line 2095
        *tmp___4 = (u_int8 )(Xv >> 24);
#line 2095
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2095
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2096
    tmp___5 = data_ptr;
#line 2096
    data_ptr ++;
#line 2096
    *tmp___5 = (u_int8 )0;
#line 2097
    tmp___6 = data_ptr;
#line 2097
    data_ptr ++;
#line 2097
    bjpm->num_groups_ptr = tmp___6;
#line 2098
    *(bjpm->num_groups_ptr) = (u_int8 )0;
    {
#line 2099
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2099
      Xv___0 = holdtime;
#line 2099
      tmp___7 = data_ptr;
#line 2099
      data_ptr ++;
#line 2099
      *tmp___7 = (u_int8 )((int )Xv___0 >> 8);
#line 2099
      tmp___8 = data_ptr;
#line 2099
      data_ptr ++;
#line 2099
      *tmp___8 = (u_int8 )Xv___0;
#line 2099
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2100
    bjpm->holdtime = holdtime;
#line 2101
    bjpm->jp_message_size = (u_int32 )(data_ptr - bjpm->jp_message);
  }
  {
#line 2105
  bjpm->curr_group = group;
#line 2106
  bjpm->curr_group_msklen = grp_msklen;
#line 2108
  tmp___9 = htonl(3758096384U);
  }
#line 2108
  if (group == tmp___9) {
#line 2108
    if ((int )grp_msklen == 4) {
#line 2109
      rp_flag = 1;
    } else {
#line 2111
      rp_flag = 0;
    }
  } else {
#line 2111
    rp_flag = 0;
  }
  {
#line 2114
  if ((int )join_prune == 1) {
#line 2114
    goto case_1;
  }
#line 2121
  if ((int )join_prune == 2) {
#line 2121
    goto case_2;
  }
#line 2128
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2115
  if (rp_flag == 1) {
#line 2116
    data_ptr = bjpm->rp_list_join + bjpm->rp_list_join_size;
  } else {
#line 2118
    data_ptr = bjpm->join_list + bjpm->join_list_size;
  }
#line 2119
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2122
  if (rp_flag == 1) {
#line 2123
    data_ptr = bjpm->rp_list_prune + bjpm->rp_list_prune_size;
  } else {
#line 2125
    data_ptr = bjpm->prune_list + bjpm->prune_list_size;
  }
#line 2126
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2129
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 2132
  flags = (u_int8 )((int )flags | 4);
#line 2133
  if ((int )addr_flags & 4) {
#line 2134
    flags = (u_int8 )((int )flags | 1);
  }
#line 2135
  if ((int )addr_flags & 2) {
#line 2136
    flags = (u_int8 )((int )flags | 2);
  }
  {
#line 2137
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2137
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2137
      if (src_msklen) {
        {
#line 2137
        tmp___10 = htonl((uint32_t )(-1 << ((sizeof(mask) << 3) - (unsigned long )src_msklen)));
#line 2137
        mask = tmp___10;
        }
      } else {
#line 2137
        mask = (u_int32 )0;
      }
#line 2137
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2137
    tmp___11 = data_ptr;
#line 2137
    data_ptr ++;
#line 2137
    *tmp___11 = (u_int8 )1;
#line 2137
    tmp___12 = data_ptr;
#line 2137
    data_ptr ++;
#line 2137
    *tmp___12 = (u_int8 )0;
#line 2137
    tmp___13 = data_ptr;
#line 2137
    data_ptr ++;
#line 2137
    *tmp___13 = flags;
#line 2137
    tmp___14 = data_ptr;
#line 2137
    data_ptr ++;
#line 2137
    *tmp___14 = src_msklen;
    {
#line 2137
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2137
      Xv___1 = source & mask;
#line 2137
      tmp___15 = data_ptr;
#line 2137
      data_ptr ++;
#line 2137
      *tmp___15 = (u_int8 )Xv___1;
#line 2137
      tmp___16 = data_ptr;
#line 2137
      data_ptr ++;
#line 2137
      *tmp___16 = (u_int8 )(Xv___1 >> 8);
#line 2137
      tmp___17 = data_ptr;
#line 2137
      data_ptr ++;
#line 2137
      *tmp___17 = (u_int8 )(Xv___1 >> 16);
#line 2137
      tmp___18 = data_ptr;
#line 2137
      data_ptr ++;
#line 2137
      *tmp___18 = (u_int8 )(Xv___1 >> 24);
#line 2137
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2137
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2140
  if ((int )join_prune == 1) {
#line 2140
    goto case_1___0;
  }
#line 2150
  if ((int )join_prune == 2) {
#line 2150
    goto case_2___0;
  }
#line 2160
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 2141
  if (rp_flag == 1) {
#line 2142
    bjpm->rp_list_join_size = (u_int32 )(data_ptr - bjpm->rp_list_join);
#line 2143
    bjpm->rp_list_join_number = (u_int16 )((int )bjpm->rp_list_join_number + 1);
  } else {
#line 2145
    bjpm->join_list_size = (u_int32 )(data_ptr - bjpm->join_list);
#line 2146
    bjpm->join_addr_number = (u_int16 )((int )bjpm->join_addr_number + 1);
  }
#line 2148
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 2151
  if (rp_flag == 1) {
#line 2152
    bjpm->rp_list_prune_size = (u_int32 )(data_ptr - bjpm->rp_list_prune);
#line 2153
    bjpm->rp_list_prune_number = (u_int16 )((int )bjpm->rp_list_prune_number + 1);
  } else {
#line 2155
    bjpm->prune_list_size = (u_int32 )(data_ptr - bjpm->prune_list);
#line 2156
    bjpm->prune_addr_number = (u_int16 )((int )bjpm->prune_addr_number + 1);
  }
#line 2158
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2161
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
#line 2164
  return (1);
}
}
#line 2169 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static build_jp_message_t *get_jp_working_buff(void) 
{ 
  build_jp_message_t *bjpm_ptr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 2173
  if (build_jp_message_pool_counter == 0) {
    {
#line 2174
    tmp = calloc((size_t )1, sizeof(build_jp_message_t ));
#line 2174
    bjpm_ptr = (build_jp_message_t *)tmp;
    }
#line 2175
    if (! bjpm_ptr) {
#line 2176
      return ((build_jp_message_t *)((void *)0));
    }
    {
#line 2178
    bjpm_ptr->next = (build_jp_message_t *)((void *)0);
#line 2179
    tmp___0 = calloc((size_t )1, (8192UL + sizeof(pim_jp_encod_grp_t )) + 2UL * sizeof(pim_encod_src_addr_t ));
#line 2179
    bjpm_ptr->jp_message = (u_int8 *)tmp___0;
    }
#line 2182
    if (! bjpm_ptr->jp_message) {
      {
#line 2183
      free((void *)bjpm_ptr);
      }
#line 2184
      return ((build_jp_message_t *)((void *)0));
    }
    {
#line 2187
    bjpm_ptr->jp_message_size = (u_int32 )0;
#line 2188
    bjpm_ptr->join_list_size = (u_int32 )0;
#line 2189
    bjpm_ptr->join_addr_number = (u_int16 )0;
#line 2190
    tmp___1 = calloc((size_t )1, 1500UL + sizeof(pim_encod_src_addr_t ));
#line 2190
    bjpm_ptr->join_list = (u_int8 *)tmp___1;
    }
#line 2192
    if (! bjpm_ptr->join_list) {
      {
#line 2193
      free((void *)bjpm_ptr->jp_message);
#line 2194
      free((void *)bjpm_ptr);
      }
#line 2195
      return ((build_jp_message_t *)((void *)0));
    }
    {
#line 2197
    bjpm_ptr->prune_list_size = (u_int32 )0;
#line 2198
    bjpm_ptr->prune_addr_number = (u_int16 )0;
#line 2199
    tmp___2 = calloc((size_t )1, 1500UL + sizeof(pim_encod_src_addr_t ));
#line 2199
    bjpm_ptr->prune_list = (u_int8 *)tmp___2;
    }
#line 2201
    if (! bjpm_ptr->prune_list) {
      {
#line 2202
      free((void *)bjpm_ptr->join_list);
#line 2203
      free((void *)bjpm_ptr->jp_message);
#line 2204
      free((void *)bjpm_ptr);
      }
#line 2205
      return ((build_jp_message_t *)((void *)0));
    }
    {
#line 2207
    bjpm_ptr->rp_list_join_size = (u_int32 )0;
#line 2208
    bjpm_ptr->rp_list_join_number = (u_int16 )0;
#line 2209
    tmp___3 = calloc((size_t )1, 1500UL + sizeof(pim_encod_src_addr_t ));
#line 2209
    bjpm_ptr->rp_list_join = (u_int8 *)tmp___3;
    }
#line 2211
    if (! bjpm_ptr->rp_list_join) {
      {
#line 2212
      free((void *)bjpm_ptr->prune_list);
#line 2213
      free((void *)bjpm_ptr->join_list);
#line 2214
      free((void *)bjpm_ptr->jp_message);
#line 2215
      free((void *)bjpm_ptr);
      }
#line 2216
      return ((build_jp_message_t *)((void *)0));
    }
    {
#line 2218
    bjpm_ptr->rp_list_prune_size = (u_int32 )0;
#line 2219
    bjpm_ptr->rp_list_prune_number = (u_int16 )0;
#line 2220
    tmp___4 = calloc((size_t )1, 1500UL + sizeof(pim_encod_src_addr_t ));
#line 2220
    bjpm_ptr->rp_list_prune = (u_int8 *)tmp___4;
    }
#line 2222
    if (! bjpm_ptr->rp_list_prune) {
      {
#line 2223
      free((void *)bjpm_ptr->rp_list_join);
#line 2224
      free((void *)bjpm_ptr->prune_list);
#line 2225
      free((void *)bjpm_ptr->join_list);
#line 2226
      free((void *)bjpm_ptr->jp_message);
#line 2227
      free((void *)bjpm_ptr);
      }
#line 2228
      return ((build_jp_message_t *)((void *)0));
    }
#line 2230
    bjpm_ptr->curr_group = (u_int32 )0;
#line 2231
    bjpm_ptr->curr_group_msklen = (u_int8 )0;
#line 2232
    bjpm_ptr->holdtime = (u_int16 )0;
#line 2234
    return (bjpm_ptr);
  }
#line 2237
  bjpm_ptr = build_jp_message_pool;
#line 2238
  build_jp_message_pool = build_jp_message_pool->next;
#line 2239
  build_jp_message_pool_counter --;
#line 2240
  bjpm_ptr->jp_message_size = (u_int32 )0;
#line 2241
  bjpm_ptr->join_list_size = (u_int32 )0;
#line 2242
  bjpm_ptr->join_addr_number = (u_int16 )0;
#line 2243
  bjpm_ptr->prune_list_size = (u_int32 )0;
#line 2244
  bjpm_ptr->prune_addr_number = (u_int16 )0;
#line 2245
  bjpm_ptr->curr_group = (u_int32 )0;
#line 2246
  bjpm_ptr->curr_group_msklen = (u_int8 )0;
#line 2248
  return (bjpm_ptr);
}
}
#line 2252 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static void return_jp_working_buff(pim_nbr_entry_t *pim_nbr ) 
{ 
  build_jp_message_t *bjpm_ptr ;

  {
#line 2254
  bjpm_ptr = pim_nbr->build_jp_message;
#line 2256
  if (! bjpm_ptr) {
#line 2257
    return;
  }
#line 2261
  if (build_jp_message_pool_counter >= 8) {
    {
#line 2262
    free((void *)bjpm_ptr->jp_message);
#line 2263
    free((void *)bjpm_ptr->join_list);
#line 2264
    free((void *)bjpm_ptr->prune_list);
#line 2265
    free((void *)bjpm_ptr->rp_list_join);
#line 2266
    free((void *)bjpm_ptr->rp_list_prune);
#line 2267
    free((void *)bjpm_ptr);
    }
  } else {
#line 2269
    bjpm_ptr->next = build_jp_message_pool;
#line 2270
    build_jp_message_pool = bjpm_ptr;
#line 2271
    build_jp_message_pool_counter ++;
  }
#line 2273
  pim_nbr->build_jp_message = (build_jp_message_t *)((void *)0);
#line 2274
  return;
}
}
#line 2283 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static void pack_jp_message(pim_nbr_entry_t *pim_nbr ) 
{ 
  build_jp_message_t *bjpm ;
  u_int8 *data_ptr ;
  u_int32 mask ;
  uint32_t tmp ;
  u_int8 *tmp___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  register u_int32 Xv ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  register u_int16 Xv___0 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  register u_int16 Xv___1 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  u_int32 mask___0 ;
  uint32_t tmp___12 ;
  u_int8 *tmp___13 ;
  u_int8 *tmp___14 ;
  u_int8 *tmp___15 ;
  u_int8 *tmp___16 ;
  register u_int32 Xv___2 ;
  uint32_t tmp___17 ;
  u_int8 *tmp___18 ;
  u_int8 *tmp___19 ;
  u_int8 *tmp___20 ;
  u_int8 *tmp___21 ;
  register u_int16 Xv___3 ;
  u_int8 *tmp___22 ;
  u_int8 *tmp___23 ;
  register u_int16 Xv___4 ;
  u_int8 *tmp___24 ;
  u_int8 *tmp___25 ;

  {
#line 2288
  bjpm = pim_nbr->build_jp_message;
#line 2289
  if (! bjpm) {
#line 2290
    return;
  } else
#line 2289
  if (bjpm->curr_group == 0U) {
#line 2290
    return;
  }
#line 2292
  data_ptr = bjpm->jp_message + bjpm->jp_message_size;
  {
#line 2293
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2293
      if (bjpm->curr_group_msklen) {
        {
#line 2293
        tmp = htonl((uint32_t )(-1 << ((sizeof(mask) << 3) - (unsigned long )bjpm->curr_group_msklen)));
#line 2293
        mask = tmp;
        }
      } else {
#line 2293
        mask = (u_int32 )0;
      }
#line 2293
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2293
    tmp___0 = data_ptr;
#line 2293
    data_ptr ++;
#line 2293
    *tmp___0 = (u_int8 )1;
#line 2293
    tmp___1 = data_ptr;
#line 2293
    data_ptr ++;
#line 2293
    *tmp___1 = (u_int8 )0;
#line 2293
    tmp___2 = data_ptr;
#line 2293
    data_ptr ++;
#line 2293
    *tmp___2 = (u_int8 )0;
#line 2293
    tmp___3 = data_ptr;
#line 2293
    data_ptr ++;
#line 2293
    *tmp___3 = bjpm->curr_group_msklen;
    {
#line 2293
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2293
      Xv = bjpm->curr_group & mask;
#line 2293
      tmp___4 = data_ptr;
#line 2293
      data_ptr ++;
#line 2293
      *tmp___4 = (u_int8 )Xv;
#line 2293
      tmp___5 = data_ptr;
#line 2293
      data_ptr ++;
#line 2293
      *tmp___5 = (u_int8 )(Xv >> 8);
#line 2293
      tmp___6 = data_ptr;
#line 2293
      data_ptr ++;
#line 2293
      *tmp___6 = (u_int8 )(Xv >> 16);
#line 2293
      tmp___7 = data_ptr;
#line 2293
      data_ptr ++;
#line 2293
      *tmp___7 = (u_int8 )(Xv >> 24);
#line 2293
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2293
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2294
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2294
    Xv___0 = bjpm->join_addr_number;
#line 2294
    tmp___8 = data_ptr;
#line 2294
    data_ptr ++;
#line 2294
    *tmp___8 = (u_int8 )((int )Xv___0 >> 8);
#line 2294
    tmp___9 = data_ptr;
#line 2294
    data_ptr ++;
#line 2294
    *tmp___9 = (u_int8 )Xv___0;
#line 2294
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2295
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2295
    Xv___1 = bjpm->prune_addr_number;
#line 2295
    tmp___10 = data_ptr;
#line 2295
    data_ptr ++;
#line 2295
    *tmp___10 = (u_int8 )((int )Xv___1 >> 8);
#line 2295
    tmp___11 = data_ptr;
#line 2295
    data_ptr ++;
#line 2295
    *tmp___11 = (u_int8 )Xv___1;
#line 2295
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2296
  memcpy((void */* __restrict  */)data_ptr, (void const   */* __restrict  */)bjpm->join_list,
         (size_t )bjpm->join_list_size);
#line 2297
  data_ptr += bjpm->join_list_size;
#line 2298
  memcpy((void */* __restrict  */)data_ptr, (void const   */* __restrict  */)bjpm->prune_list,
         (size_t )bjpm->prune_list_size);
#line 2299
  data_ptr += bjpm->prune_list_size;
#line 2300
  bjpm->jp_message_size = (u_int32 )(data_ptr - bjpm->jp_message);
#line 2301
  bjpm->curr_group = (u_int32 )0;
#line 2302
  bjpm->curr_group_msklen = (u_int8 )0;
#line 2303
  bjpm->join_list_size = (u_int32 )0;
#line 2304
  bjpm->join_addr_number = (u_int16 )0;
#line 2305
  bjpm->prune_list_size = (u_int32 )0;
#line 2306
  bjpm->prune_addr_number = (u_int16 )0;
#line 2307
  *(bjpm->num_groups_ptr) = (u_int8 )((int )*(bjpm->num_groups_ptr) + 1);
  }
#line 2309
  if ((int )*(bjpm->num_groups_ptr) == 254) {
#line 2310
    if ((int )bjpm->rp_list_join_number + (int )bjpm->rp_list_prune_number) {
#line 2312
      data_ptr = bjpm->jp_message + bjpm->jp_message_size;
      {
#line 2313
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2313
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 2313
          tmp___12 = htonl((uint32_t )(-1 << ((sizeof(mask___0) << 3) - 4UL)));
#line 2313
          mask___0 = tmp___12;
          }
#line 2313
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2313
        tmp___13 = data_ptr;
#line 2313
        data_ptr ++;
#line 2313
        *tmp___13 = (u_int8 )1;
#line 2313
        tmp___14 = data_ptr;
#line 2313
        data_ptr ++;
#line 2313
        *tmp___14 = (u_int8 )0;
#line 2313
        tmp___15 = data_ptr;
#line 2313
        data_ptr ++;
#line 2313
        *tmp___15 = (u_int8 )0;
#line 2313
        tmp___16 = data_ptr;
#line 2313
        data_ptr ++;
#line 2313
        *tmp___16 = (u_int8 )4;
        {
#line 2313
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 2313
          tmp___17 = htonl(3758096384U);
#line 2313
          Xv___2 = tmp___17 & mask___0;
#line 2313
          tmp___18 = data_ptr;
#line 2313
          data_ptr ++;
#line 2313
          *tmp___18 = (u_int8 )Xv___2;
#line 2313
          tmp___19 = data_ptr;
#line 2313
          data_ptr ++;
#line 2313
          *tmp___19 = (u_int8 )(Xv___2 >> 8);
#line 2313
          tmp___20 = data_ptr;
#line 2313
          data_ptr ++;
#line 2313
          *tmp___20 = (u_int8 )(Xv___2 >> 16);
#line 2313
          tmp___21 = data_ptr;
#line 2313
          data_ptr ++;
#line 2313
          *tmp___21 = (u_int8 )(Xv___2 >> 24);
          }
#line 2313
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2313
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2314
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2314
        Xv___3 = bjpm->rp_list_join_number;
#line 2314
        tmp___22 = data_ptr;
#line 2314
        data_ptr ++;
#line 2314
        *tmp___22 = (u_int8 )((int )Xv___3 >> 8);
#line 2314
        tmp___23 = data_ptr;
#line 2314
        data_ptr ++;
#line 2314
        *tmp___23 = (u_int8 )Xv___3;
#line 2314
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 2315
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2315
        Xv___4 = bjpm->rp_list_prune_number;
#line 2315
        tmp___24 = data_ptr;
#line 2315
        data_ptr ++;
#line 2315
        *tmp___24 = (u_int8 )((int )Xv___4 >> 8);
#line 2315
        tmp___25 = data_ptr;
#line 2315
        data_ptr ++;
#line 2315
        *tmp___25 = (u_int8 )Xv___4;
#line 2315
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 2316
      memcpy((void */* __restrict  */)data_ptr, (void const   */* __restrict  */)bjpm->rp_list_join,
             (size_t )bjpm->rp_list_join_size);
#line 2317
      data_ptr += bjpm->rp_list_join_size;
#line 2318
      memcpy((void */* __restrict  */)data_ptr, (void const   */* __restrict  */)bjpm->rp_list_prune,
             (size_t )bjpm->rp_list_prune_size);
#line 2319
      data_ptr += bjpm->rp_list_prune_size;
#line 2320
      bjpm->jp_message_size = (u_int32 )(data_ptr - bjpm->jp_message);
#line 2321
      bjpm->rp_list_join_size = (u_int32 )0;
#line 2322
      bjpm->rp_list_join_number = (u_int16 )0;
#line 2323
      bjpm->rp_list_prune_size = (u_int32 )0;
#line 2324
      bjpm->rp_list_prune_number = (u_int16 )0;
#line 2325
      *(bjpm->num_groups_ptr) = (u_int8 )((int )*(bjpm->num_groups_ptr) + 1);
      }
    }
    {
#line 2327
    send_jp_message(pim_nbr);
    }
  }
#line 2329
  return;
}
}
#line 2332 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
void pack_and_send_jp_message(pim_nbr_entry_t *pim_nbr ) 
{ 
  u_int8 *data_ptr ;
  build_jp_message_t *bjpm ;
  u_int32 mask ;
  uint32_t tmp ;
  u_int8 *tmp___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  register u_int32 Xv ;
  uint32_t tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  register u_int16 Xv___0 ;
  u_int8 *tmp___9 ;
  u_int8 *tmp___10 ;
  register u_int16 Xv___1 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;

  {
#line 2337
  if (! pim_nbr) {
#line 2338
    return;
  } else
#line 2337
  if (! pim_nbr->build_jp_message) {
#line 2338
    return;
  }
  {
#line 2340
  pack_jp_message(pim_nbr);
#line 2342
  bjpm = pim_nbr->build_jp_message;
  }
#line 2343
  if ((int )bjpm->rp_list_join_number + (int )bjpm->rp_list_prune_number) {
#line 2345
    data_ptr = bjpm->jp_message + bjpm->jp_message_size;
    {
#line 2346
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2346
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2346
        tmp = htonl((uint32_t )(-1 << ((sizeof(mask) << 3) - 4UL)));
#line 2346
        mask = tmp;
        }
#line 2346
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2346
      tmp___0 = data_ptr;
#line 2346
      data_ptr ++;
#line 2346
      *tmp___0 = (u_int8 )1;
#line 2346
      tmp___1 = data_ptr;
#line 2346
      data_ptr ++;
#line 2346
      *tmp___1 = (u_int8 )0;
#line 2346
      tmp___2 = data_ptr;
#line 2346
      data_ptr ++;
#line 2346
      *tmp___2 = (u_int8 )0;
#line 2346
      tmp___3 = data_ptr;
#line 2346
      data_ptr ++;
#line 2346
      *tmp___3 = (u_int8 )4;
      {
#line 2346
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 2346
        tmp___4 = htonl(3758096384U);
#line 2346
        Xv = tmp___4 & mask;
#line 2346
        tmp___5 = data_ptr;
#line 2346
        data_ptr ++;
#line 2346
        *tmp___5 = (u_int8 )Xv;
#line 2346
        tmp___6 = data_ptr;
#line 2346
        data_ptr ++;
#line 2346
        *tmp___6 = (u_int8 )(Xv >> 8);
#line 2346
        tmp___7 = data_ptr;
#line 2346
        data_ptr ++;
#line 2346
        *tmp___7 = (u_int8 )(Xv >> 16);
#line 2346
        tmp___8 = data_ptr;
#line 2346
        data_ptr ++;
#line 2346
        *tmp___8 = (u_int8 )(Xv >> 24);
        }
#line 2346
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2346
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2347
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2347
      Xv___0 = bjpm->rp_list_join_number;
#line 2347
      tmp___9 = data_ptr;
#line 2347
      data_ptr ++;
#line 2347
      *tmp___9 = (u_int8 )((int )Xv___0 >> 8);
#line 2347
      tmp___10 = data_ptr;
#line 2347
      data_ptr ++;
#line 2347
      *tmp___10 = (u_int8 )Xv___0;
#line 2347
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2348
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2348
      Xv___1 = bjpm->rp_list_prune_number;
#line 2348
      tmp___11 = data_ptr;
#line 2348
      data_ptr ++;
#line 2348
      *tmp___11 = (u_int8 )((int )Xv___1 >> 8);
#line 2348
      tmp___12 = data_ptr;
#line 2348
      data_ptr ++;
#line 2348
      *tmp___12 = (u_int8 )Xv___1;
#line 2348
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2349
    memcpy((void */* __restrict  */)data_ptr, (void const   */* __restrict  */)bjpm->rp_list_join,
           (size_t )bjpm->rp_list_join_size);
#line 2350
    data_ptr += bjpm->rp_list_join_size;
#line 2351
    memcpy((void */* __restrict  */)data_ptr, (void const   */* __restrict  */)bjpm->rp_list_prune,
           (size_t )bjpm->rp_list_prune_size);
#line 2352
    data_ptr += bjpm->rp_list_prune_size;
#line 2353
    bjpm->jp_message_size = (u_int32 )(data_ptr - bjpm->jp_message);
#line 2354
    bjpm->rp_list_join_size = (u_int32 )0;
#line 2355
    bjpm->rp_list_join_number = (u_int16 )0;
#line 2356
    bjpm->rp_list_prune_size = (u_int32 )0;
#line 2357
    bjpm->rp_list_prune_number = (u_int16 )0;
#line 2358
    *(bjpm->num_groups_ptr) = (u_int8 )((int )*(bjpm->num_groups_ptr) + 1);
    }
  }
  {
#line 2360
  send_jp_message(pim_nbr);
  }
#line 2361
  return;
}
}
#line 2364 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static void send_jp_message(pim_nbr_entry_t *pim_nbr ) 
{ 
  u_int16 datalen ;
  vifi_t vifi ;

  {
  {
#line 2369
  datalen = (u_int16 )(pim_nbr->build_jp_message)->jp_message_size;
#line 2370
  vifi = pim_nbr->vifi;
#line 2371
  memcpy((void */* __restrict  */)((pim_send_buf + sizeof(struct ip )) + sizeof(pim_header_t )),
         (void const   */* __restrict  */)(pim_nbr->build_jp_message)->jp_message,
         (size_t )datalen);
#line 2373
  send_pim(pim_send_buf, uvifs[vifi].uv_lcl_addr, allpimrouters_group, 3, (int )datalen);
#line 2375
  return_jp_working_buff(pim_nbr);
  }
#line 2376
  return;
}
}
#line 2382 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int receive_pim_assert(u_int32 src , u_int32 dst  __attribute__((__unused__)) , char *pim_message ,
                       int datalen ) 
{ 
  vifi_t vifi ;
  pim_encod_uni_addr_t eusaddr ;
  pim_encod_grp_addr_t egaddr ;
  u_int32 source ;
  u_int32 group ;
  mrtentry_t *mrtentry_ptr ;
  mrtentry_t *mrtentry_ptr2 ;
  u_int8 *data_ptr ;
  struct uvif *v ;
  u_int32 assert_preference ;
  u_int32 assert_metric ;
  u_int32 assert_rptbit ;
  u_int32 local_metric ;
  u_int32 local_preference ;
  u_int8 local_rptbit ;
  u_int8 local_wins ;
  pim_nbr_entry_t *original_upstream_router ;
  char *tmp ;
  vifi_t tmp___0 ;
  int tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  register u_long Xv ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  register u_long Xv___0 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  u_int8 *tmp___14 ;
  u_int8 *tmp___15 ;
  register u_long Xv___1 ;
  u_int8 *tmp___16 ;
  u_int8 *tmp___17 ;
  u_int8 *tmp___18 ;
  u_int8 *tmp___19 ;
  register u_long Xv___2 ;
  u_int8 *tmp___20 ;
  u_int8 *tmp___21 ;
  u_int8 *tmp___22 ;
  u_int8 *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 2400
  vifi = find_vif_direct(src);
  }
#line 2401
  if ((int )vifi == 32) {
    {
#line 2405
    tmp___0 = local_address(src);
    }
#line 2405
    if ((int )tmp___0 == 32) {
      {
#line 2406
      tmp = inet_fmt(src, s1, sizeof(s1));
#line 2406
      logit(6, 0, "Ignoring PIM_ASSERT from non-neighbor router %s", tmp);
      }
    }
#line 2409
    return (0);
  }
  {
#line 2413
  tmp___1 = inet_cksum((u_int16 *)pim_message, (u_int )datalen);
  }
#line 2413
  if (tmp___1) {
#line 2414
    return (0);
  }
#line 2416
  v = & uvifs[vifi];
#line 2417
  if (uvifs[vifi].uv_flags & 525060U) {
#line 2418
    return (0);
  }
#line 2420
  data_ptr = (u_int8 *)(pim_message + sizeof(pim_header_t ));
  {
#line 2423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2423
    tmp___2 = data_ptr;
#line 2423
    data_ptr ++;
#line 2423
    egaddr.addr_family = *tmp___2;
#line 2423
    tmp___3 = data_ptr;
#line 2423
    data_ptr ++;
#line 2423
    egaddr.encod_type = *tmp___3;
#line 2423
    tmp___4 = data_ptr;
#line 2423
    data_ptr ++;
#line 2423
    egaddr.reserved = *tmp___4;
#line 2423
    tmp___5 = data_ptr;
#line 2423
    data_ptr ++;
#line 2423
    egaddr.masklen = *tmp___5;
    {
#line 2423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2423
      tmp___6 = data_ptr;
#line 2423
      data_ptr ++;
#line 2423
      Xv = (u_long )*tmp___6;
#line 2423
      tmp___7 = data_ptr;
#line 2423
      data_ptr ++;
#line 2423
      Xv |= (unsigned long )((int )*tmp___7 << 8);
#line 2423
      tmp___8 = data_ptr;
#line 2423
      data_ptr ++;
#line 2423
      Xv |= (unsigned long )((int )*tmp___8 << 16);
#line 2423
      tmp___9 = data_ptr;
#line 2423
      data_ptr ++;
#line 2423
      Xv |= (unsigned long )((int )*tmp___9 << 24);
#line 2423
      egaddr.mcast_addr = (u_int32 )Xv;
#line 2423
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2423
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2424
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2424
    tmp___10 = data_ptr;
#line 2424
    data_ptr ++;
#line 2424
    eusaddr.addr_family = *tmp___10;
#line 2424
    tmp___11 = data_ptr;
#line 2424
    data_ptr ++;
#line 2424
    eusaddr.encod_type = *tmp___11;
    {
#line 2424
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2424
      tmp___12 = data_ptr;
#line 2424
      data_ptr ++;
#line 2424
      Xv___0 = (u_long )*tmp___12;
#line 2424
      tmp___13 = data_ptr;
#line 2424
      data_ptr ++;
#line 2424
      Xv___0 |= (unsigned long )((int )*tmp___13 << 8);
#line 2424
      tmp___14 = data_ptr;
#line 2424
      data_ptr ++;
#line 2424
      Xv___0 |= (unsigned long )((int )*tmp___14 << 16);
#line 2424
      tmp___15 = data_ptr;
#line 2424
      data_ptr ++;
#line 2424
      Xv___0 |= (unsigned long )((int )*tmp___15 << 24);
#line 2424
      eusaddr.unicast_addr = (u_int32 )Xv___0;
#line 2424
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2424
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2427
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2427
    tmp___16 = data_ptr;
#line 2427
    data_ptr ++;
#line 2427
    Xv___1 = (u_long )((int )*tmp___16 << 24);
#line 2427
    tmp___17 = data_ptr;
#line 2427
    data_ptr ++;
#line 2427
    Xv___1 |= (unsigned long )((int )*tmp___17 << 16);
#line 2427
    tmp___18 = data_ptr;
#line 2427
    data_ptr ++;
#line 2427
    Xv___1 |= (unsigned long )((int )*tmp___18 << 8);
#line 2427
    tmp___19 = data_ptr;
#line 2427
    data_ptr ++;
#line 2427
    Xv___1 |= (unsigned long )*tmp___19;
#line 2427
    assert_preference = (u_int32 )Xv___1;
#line 2427
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2428
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2428
    tmp___20 = data_ptr;
#line 2428
    data_ptr ++;
#line 2428
    Xv___2 = (u_long )((int )*tmp___20 << 24);
#line 2428
    tmp___21 = data_ptr;
#line 2428
    data_ptr ++;
#line 2428
    Xv___2 |= (unsigned long )((int )*tmp___21 << 16);
#line 2428
    tmp___22 = data_ptr;
#line 2428
    data_ptr ++;
#line 2428
    Xv___2 |= (unsigned long )((int )*tmp___22 << 8);
#line 2428
    tmp___23 = data_ptr;
#line 2428
    data_ptr ++;
#line 2428
    Xv___2 |= (unsigned long )*tmp___23;
#line 2428
    assert_metric = (u_int32 )Xv___2;
#line 2428
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2429
  assert_rptbit = assert_preference & 2147483648U;
#line 2431
  source = eusaddr.unicast_addr;
#line 2432
  group = egaddr.mcast_addr;
#line 2434
  if (assert_rptbit) {
    {
#line 2435
    mrtentry_ptr = find_route((u_int32 )0, group, (u_int16 )16386, (char)0);
    }
#line 2436
    if (mrtentry_ptr) {
#line 2437
      if (! ((int )mrtentry_ptr->flags & 512)) {
#line 2438
        if ((int )mrtentry_ptr->flags & 2) {
#line 2439
          mrtentry_ptr = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
        }
      }
    }
  } else {
    {
#line 2442
    mrtentry_ptr = find_route(source, group, (u_int16 )24578, (char)0);
    }
#line 2443
    if (mrtentry_ptr) {
#line 2444
      if (! ((int )mrtentry_ptr->flags & 512)) {
#line 2445
        if ((int )mrtentry_ptr->flags & 8192) {
#line 2446
          mrtentry_ptr2 = (mrtentry_ptr->group)->grp_route;
#line 2447
          if (mrtentry_ptr2) {
#line 2447
            if ((int )mrtentry_ptr2->flags & 512) {
#line 2448
              mrtentry_ptr = mrtentry_ptr2;
            } else {
#line 2450
              mrtentry_ptr = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
            }
          } else {
#line 2450
            mrtentry_ptr = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
          }
        } else
#line 2452
        if ((int )mrtentry_ptr->flags & 2) {
#line 2453
          mrtentry_ptr = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->mrtlink;
        }
      }
    }
  }
#line 2458
  if (! mrtentry_ptr) {
#line 2460
    return (0);
  } else
#line 2458
  if (! ((int )mrtentry_ptr->flags & 512)) {
#line 2460
    return (0);
  }
#line 2464
  if ((int )mrtentry_ptr->flags & 16384) {
#line 2473
    local_metric = mrtentry_ptr->metric;
#line 2474
    local_preference = mrtentry_ptr->preference;
  } else
#line 2464
  if ((int )mrtentry_ptr->flags & 8192) {
#line 2464
    if (! ((int )mrtentry_ptr->flags & 4)) {
#line 2473
      local_metric = mrtentry_ptr->metric;
#line 2474
      local_preference = mrtentry_ptr->preference;
    } else {
#line 2486
      local_metric = mrtentry_ptr->metric;
#line 2487
      local_preference = mrtentry_ptr->preference;
    }
  } else {
#line 2486
    local_metric = mrtentry_ptr->metric;
#line 2487
    local_preference = mrtentry_ptr->preference;
  }
#line 2490
  local_rptbit = (u_int8 )((int )mrtentry_ptr->flags & 4);
#line 2491
  if (local_rptbit) {
#line 2493
    local_preference |= 2147483648U;
  }
#line 2496
  if (mrtentry_ptr->oifs & (unsigned long )(1 << (int )vifi)) {
    {
#line 2509
    tmp___24 = compare_metrics(local_preference, local_metric, v->uv_lcl_addr, assert_preference,
                               assert_metric, src);
#line 2509
    local_wins = (u_int8 )tmp___24;
    }
#line 2513
    if ((int )local_wins == 1) {
      {
#line 2515
      send_pim_assert(source, group, vifi, mrtentry_ptr);
      }
#line 2516
      return (1);
    }
#line 2520
    if (assert_rptbit) {
#line 2520
      if ((int )mrtentry_ptr->flags & 16384) {
        {
#line 2522
        mrtentry_ptr2 = find_route((u_int32 )0, group, (u_int16 )2, (char)1);
        }
      } else {
#line 2520
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2523
    if (! assert_rptbit) {
#line 2523
      if ((int )mrtentry_ptr->flags & 16386) {
        {
#line 2525
        mrtentry_ptr2 = find_route(source, group, (u_int16 )8192, (char)1);
        }
      } else {
#line 2528
        mrtentry_ptr2 = (mrtentry_t *)((void *)0);
      }
    } else {
#line 2528
      mrtentry_ptr2 = (mrtentry_t *)((void *)0);
    }
#line 2531
    if (mrtentry_ptr2) {
#line 2532
      mrtentry_ptr2->flags = (u_int16 )((int )mrtentry_ptr2->flags & -9);
#line 2536
      mrtentry_ptr2->timer = (u_int16 )210;
#line 2537
      if ((int )mrtentry_ptr2->flags & 4) {
#line 2548
        local_metric = mrtentry_ptr->metric;
#line 2549
        local_preference = mrtentry_ptr->preference;
#line 2550
        local_preference |= 2147483648U;
      } else {
#line 2558
        local_metric = mrtentry_ptr->metric;
#line 2559
        local_preference = mrtentry_ptr->preference;
      }
      {
#line 2562
      tmp___25 = compare_metrics(local_preference, local_metric, v->uv_lcl_addr, assert_preference,
                                 assert_metric, src);
#line 2562
      local_wins = (u_int8 )tmp___25;
      }
#line 2565
      if ((int )local_wins == 1) {
        {
#line 2567
        send_pim_assert(source, group, vifi, mrtentry_ptr);
        }
#line 2568
        return (1);
      }
#line 2571
      mrtentry_ptr = mrtentry_ptr2;
    }
#line 2575
    mrtentry_ptr->asserted_oifs |= (unsigned long )(1 << (int )vifi);
#line 2577
    if ((int )mrtentry_ptr->timer < 180) {
#line 2578
      mrtentry_ptr->timer = (u_int16 )180;
    }
    {
#line 2582
    change_interfaces(mrtentry_ptr, mrtentry_ptr->incoming, mrtentry_ptr->joined_oifs,
                      mrtentry_ptr->pruned_oifs, mrtentry_ptr->leaves, mrtentry_ptr->asserted_oifs,
                      (u_int16 )0);
    }
#line 2589
    return (0);
  }
#line 2593
  if ((int )mrtentry_ptr->incoming == (int )vifi) {
#line 2595
    if (assert_rptbit) {
#line 2596
      if (! ((int )mrtentry_ptr->flags & 4)) {
#line 2597
        return (1);
      }
    }
#line 2605
    local_metric = mrtentry_ptr->metric;
#line 2606
    local_preference = mrtentry_ptr->preference;
#line 2607
    if ((int )mrtentry_ptr->flags & 4) {
#line 2608
      local_preference |= 2147483648U;
    }
    {
#line 2610
    tmp___26 = compare_metrics(local_preference, local_metric, (mrtentry_ptr->upstream)->address,
                               assert_preference, assert_metric, src);
#line 2610
    local_wins = (u_int8 )tmp___26;
    }
#line 2614
    if ((int )local_wins == 1) {
#line 2615
      return (1);
    }
    {
#line 2618
    mrtentry_ptr->preference = assert_preference;
#line 2619
    mrtentry_ptr->metric = assert_metric;
#line 2620
    mrtentry_ptr->upstream = find_pim_nbr(src);
    }
#line 2623
    if ((int )mrtentry_ptr->flags & 16384) {
#line 2624
      original_upstream_router = (mrtentry_ptr->source)->upstream;
    } else
#line 2626
    if ((int )mrtentry_ptr->flags & 4) {
#line 2627
      original_upstream_router = ((((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry)->upstream;
    } else {
#line 2629
      original_upstream_router = (mrtentry_ptr->source)->upstream;
    }
#line 2630
    if ((unsigned long )mrtentry_ptr->upstream != (unsigned long )original_upstream_router) {
#line 2631
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags | 4096);
#line 2632
      mrtentry_ptr->assert_timer = (u_int )180;
    } else {
#line 2634
      mrtentry_ptr->flags = (u_int16 )((int )mrtentry_ptr->flags & -4097);
    }
  }
#line 2638
  return (1);
}
}
#line 2642 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int send_pim_assert(u_int32 source , u_int32 group , vifi_t vifi , mrtentry_t *mrtentry_ptr ) 
{ 
  u_int8 *data_ptr ;
  u_int8 *data_start_ptr ;
  u_int32 local_preference ;
  u_int32 local_metric ;
  srcentry_t *srcentry_ptr  __attribute__((__unused__)) ;
  u_int32 mask ;
  uint32_t tmp ;
  u_int8 *tmp___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  register u_int32 Xv ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  register u_int32 Xv___0 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  register u_int32 Xv___1 ;
  u_int8 *tmp___14 ;
  u_int8 *tmp___15 ;
  u_int8 *tmp___16 ;
  u_int8 *tmp___17 ;
  register u_int32 Xv___2 ;
  u_int8 *tmp___18 ;
  u_int8 *tmp___19 ;
  u_int8 *tmp___20 ;
  u_int8 *tmp___21 ;

  {
#line 2655
  if (uvifs[vifi].uv_flags & 5U) {
#line 2656
    return (0);
  }
#line 2658
  data_ptr = (u_int8 *)((pim_send_buf + sizeof(struct ip )) + sizeof(pim_header_t ));
#line 2659
  data_start_ptr = data_ptr;
  {
#line 2660
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2660
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2660
      tmp = htonl((uint32_t )(-1 << ((sizeof(mask) << 3) - 32UL)));
#line 2660
      mask = tmp;
      }
#line 2660
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2660
    tmp___0 = data_ptr;
#line 2660
    data_ptr ++;
#line 2660
    *tmp___0 = (u_int8 )1;
#line 2660
    tmp___1 = data_ptr;
#line 2660
    data_ptr ++;
#line 2660
    *tmp___1 = (u_int8 )0;
#line 2660
    tmp___2 = data_ptr;
#line 2660
    data_ptr ++;
#line 2660
    *tmp___2 = (u_int8 )0;
#line 2660
    tmp___3 = data_ptr;
#line 2660
    data_ptr ++;
#line 2660
    *tmp___3 = (u_int8 )32;
    {
#line 2660
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2660
      Xv = group & mask;
#line 2660
      tmp___4 = data_ptr;
#line 2660
      data_ptr ++;
#line 2660
      *tmp___4 = (u_int8 )Xv;
#line 2660
      tmp___5 = data_ptr;
#line 2660
      data_ptr ++;
#line 2660
      *tmp___5 = (u_int8 )(Xv >> 8);
#line 2660
      tmp___6 = data_ptr;
#line 2660
      data_ptr ++;
#line 2660
      *tmp___6 = (u_int8 )(Xv >> 16);
#line 2660
      tmp___7 = data_ptr;
#line 2660
      data_ptr ++;
#line 2660
      *tmp___7 = (u_int8 )(Xv >> 24);
#line 2660
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2660
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2661
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2661
    tmp___8 = data_ptr;
#line 2661
    data_ptr ++;
#line 2661
    *tmp___8 = (u_int8 )1;
#line 2661
    tmp___9 = data_ptr;
#line 2661
    data_ptr ++;
#line 2661
    *tmp___9 = (u_int8 )0;
    {
#line 2661
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2661
      Xv___0 = source;
#line 2661
      tmp___10 = data_ptr;
#line 2661
      data_ptr ++;
#line 2661
      *tmp___10 = (u_int8 )Xv___0;
#line 2661
      tmp___11 = data_ptr;
#line 2661
      data_ptr ++;
#line 2661
      *tmp___11 = (u_int8 )(Xv___0 >> 8);
#line 2661
      tmp___12 = data_ptr;
#line 2661
      data_ptr ++;
#line 2661
      *tmp___12 = (u_int8 )(Xv___0 >> 16);
#line 2661
      tmp___13 = data_ptr;
#line 2661
      data_ptr ++;
#line 2661
      *tmp___13 = (u_int8 )(Xv___0 >> 24);
#line 2661
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2661
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2666
  if ((int )mrtentry_ptr->flags & 16384) {
#line 2668
    srcentry_ptr = mrtentry_ptr->source;
  } else
#line 2672
  if ((int )mrtentry_ptr->flags & 4) {
#line 2674
    srcentry_ptr = (((mrtentry_ptr->group)->active_rp_grp)->rp)->rpentry;
  } else {
#line 2680
    srcentry_ptr = mrtentry_ptr->source;
  }
#line 2690
  local_metric = mrtentry_ptr->metric;
#line 2691
  local_preference = mrtentry_ptr->preference;
#line 2693
  if ((int )mrtentry_ptr->flags & 4) {
#line 2694
    local_preference |= 2147483648U;
  }
  {
#line 2695
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2695
    Xv___1 = local_preference;
#line 2695
    tmp___14 = data_ptr;
#line 2695
    data_ptr ++;
#line 2695
    *tmp___14 = (u_int8 )(Xv___1 >> 24);
#line 2695
    tmp___15 = data_ptr;
#line 2695
    data_ptr ++;
#line 2695
    *tmp___15 = (u_int8 )(Xv___1 >> 16);
#line 2695
    tmp___16 = data_ptr;
#line 2695
    data_ptr ++;
#line 2695
    *tmp___16 = (u_int8 )(Xv___1 >> 8);
#line 2695
    tmp___17 = data_ptr;
#line 2695
    data_ptr ++;
#line 2695
    *tmp___17 = (u_int8 )Xv___1;
#line 2695
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 2696
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2696
    Xv___2 = local_metric;
#line 2696
    tmp___18 = data_ptr;
#line 2696
    data_ptr ++;
#line 2696
    *tmp___18 = (u_int8 )(Xv___2 >> 24);
#line 2696
    tmp___19 = data_ptr;
#line 2696
    data_ptr ++;
#line 2696
    *tmp___19 = (u_int8 )(Xv___2 >> 16);
#line 2696
    tmp___20 = data_ptr;
#line 2696
    data_ptr ++;
#line 2696
    *tmp___20 = (u_int8 )(Xv___2 >> 8);
#line 2696
    tmp___21 = data_ptr;
#line 2696
    data_ptr ++;
#line 2696
    *tmp___21 = (u_int8 )Xv___2;
#line 2696
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 2697
  send_pim(pim_send_buf, uvifs[vifi].uv_lcl_addr, allpimrouters_group, 5, (int )(data_ptr - data_start_ptr));
  }
#line 2700
  return (1);
}
}
#line 2705 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
static int compare_metrics(u_int32 local_preference , u_int32 local_metric , u_int32 local_address___0 ,
                           u_int32 remote_preference , u_int32 remote_metric , u_int32 remote_address ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 2716
  if (remote_preference > local_preference) {
#line 2717
    return (1);
  }
#line 2719
  if (remote_preference < local_preference) {
#line 2720
    return (0);
  }
#line 2722
  if (remote_metric > local_metric) {
#line 2723
    return (1);
  }
#line 2725
  if (remote_metric < local_metric) {
#line 2726
    return (0);
  }
  {
#line 2728
  tmp = ntohl(local_address___0);
#line 2728
  tmp___0 = ntohl(remote_address);
  }
#line 2728
  if (tmp > tmp___0) {
#line 2729
    return (1);
  }
#line 2731
  return (0);
}
}
#line 2739 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int receive_pim_bootstrap(u_int32 src , u_int32 dst , char *pim_message , int datalen ) 
{ 
  u_int8 *data_ptr ;
  u_int8 *max_data_ptr ;
  u_int16 new_bsr_fragment_tag ;
  u_int8 new_bsr_hash_masklen ;
  u_int8 new_bsr_priority ;
  pim_encod_uni_addr_t new_bsr_uni_addr ;
  u_int32 new_bsr_address ;
  struct rpfctl rpfc ;
  pim_nbr_entry_t *n ;
  pim_nbr_entry_t *rpf_neighbor  __attribute__((__unused__)) ;
  u_int32 neighbor_addr ;
  vifi_t vifi ;
  vifi_t incoming ;
  int min_datalen ;
  pim_encod_grp_addr_t curr_group_addr ;
  pim_encod_uni_addr_t curr_rp_addr ;
  u_int8 curr_rp_count ;
  u_int8 curr_frag_rp_count ;
  u_int16 reserved_short  __attribute__((__unused__)) ;
  u_int16 curr_rp_holdtime ;
  u_int8 curr_rp_priority ;
  u_int8 reserved_byte  __attribute__((__unused__)) ;
  u_int32 curr_group_mask ;
  u_int32 prefix_h ;
  grp_mask_t *grp_mask_ptr ;
  grp_mask_t *grp_mask_next ;
  rp_grp_entry_t *grp_rp_entry_ptr ;
  rp_grp_entry_t *grp_rp_entry_next ;
  int tmp ;
  char *tmp___0 ;
  vifi_t tmp___1 ;
  vifi_t tmp___2 ;
  char *tmp___3 ;
  register u_int16 Xv ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  register u_long Xv___0 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  vifi_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  vifi_t tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  uint32_t tmp___22 ;
  u_int8 *tmp___23 ;
  u_int8 *tmp___24 ;
  u_int8 *tmp___25 ;
  u_int8 *tmp___26 ;
  register u_long Xv___1 ;
  u_int8 *tmp___27 ;
  u_int8 *tmp___28 ;
  u_int8 *tmp___29 ;
  u_int8 *tmp___30 ;
  u_int8 *tmp___31 ;
  u_int8 *tmp___32 ;
  register u_int16 Xv___2 ;
  u_int8 *tmp___33 ;
  u_int8 *tmp___34 ;
  uint32_t tmp___35 ;
  u_int8 *tmp___36 ;
  u_int8 *tmp___37 ;
  register u_long Xv___3 ;
  u_int8 *tmp___38 ;
  u_int8 *tmp___39 ;
  u_int8 *tmp___40 ;
  u_int8 *tmp___41 ;
  register u_int16 Xv___4 ;
  u_int8 *tmp___42 ;
  u_int8 *tmp___43 ;
  u_int8 *tmp___44 ;
  u_int8 *tmp___45 ;
  uint32_t tmp___46 ;
  u_int8 tmp___47 ;
  uint32_t tmp___48 ;
  u_int8 *tmp___49 ;
  u_int8 *tmp___50 ;
  register u_long Xv___5 ;
  u_int8 *tmp___51 ;
  u_int8 *tmp___52 ;
  u_int8 *tmp___53 ;
  u_int8 *tmp___54 ;
  register u_int16 Xv___6 ;
  u_int8 *tmp___55 ;
  u_int8 *tmp___56 ;
  u_int8 *tmp___57 ;
  u_int8 *tmp___58 ;
  uint32_t tmp___59 ;
  u_int8 tmp___60 ;
  u_int8 *tmp___61 ;
  u_int8 *tmp___62 ;
  register u_long Xv___7 ;
  u_int8 *tmp___63 ;
  u_int8 *tmp___64 ;
  u_int8 *tmp___65 ;
  u_int8 *tmp___66 ;
  register u_int16 Xv___8 ;
  u_int8 *tmp___67 ;
  u_int8 *tmp___68 ;
  u_int8 *tmp___69 ;
  u_int8 *tmp___70 ;
  uint32_t tmp___71 ;
  u_int8 tmp___72 ;

  {
  {
#line 2751
  incoming = (vifi_t )32;
#line 2769
  tmp = inet_cksum((u_int16 *)pim_message, (u_int )datalen);
  }
#line 2769
  if (tmp) {
#line 2770
    return (0);
  }
  {
#line 2772
  tmp___2 = find_vif_direct(src);
  }
#line 2772
  if ((int )tmp___2 == 32) {
    {
#line 2776
    tmp___1 = local_address(src);
    }
#line 2776
    if ((int )tmp___1 == 32) {
      {
#line 2777
      tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 2777
      logit(6, 0, "Ignoring PIM_BOOTSTRAP from non-neighbor router %s", tmp___0);
      }
    }
#line 2780
    return (0);
  }
#line 2784
  if (datalen < 14) {
    {
#line 2785
    tmp___3 = inet_fmt(src, s1, sizeof(s1));
#line 2785
    logit(5, 0, "receive_pim_bootstrap: Bootstrap message size(%u) is too short from %s",
          datalen, tmp___3);
    }
#line 2788
    return (0);
  }
#line 2791
  data_ptr = (u_int8 *)(pim_message + sizeof(pim_header_t ));
  {
#line 2794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2794
    tmp___4 = data_ptr;
#line 2794
    data_ptr ++;
#line 2794
    Xv = (u_int16 )((int )*tmp___4 << 8);
#line 2794
    tmp___5 = data_ptr;
#line 2794
    data_ptr ++;
#line 2794
    Xv = (u_int16 )((int )Xv | (int )*tmp___5);
#line 2794
    new_bsr_fragment_tag = Xv;
#line 2794
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2795
  tmp___6 = data_ptr;
#line 2795
  data_ptr ++;
#line 2795
  new_bsr_hash_masklen = *tmp___6;
#line 2796
  tmp___7 = data_ptr;
#line 2796
  data_ptr ++;
#line 2796
  new_bsr_priority = *tmp___7;
  {
#line 2797
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2797
    tmp___8 = data_ptr;
#line 2797
    data_ptr ++;
#line 2797
    new_bsr_uni_addr.addr_family = *tmp___8;
#line 2797
    tmp___9 = data_ptr;
#line 2797
    data_ptr ++;
#line 2797
    new_bsr_uni_addr.encod_type = *tmp___9;
    {
#line 2797
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2797
      tmp___10 = data_ptr;
#line 2797
      data_ptr ++;
#line 2797
      Xv___0 = (u_long )*tmp___10;
#line 2797
      tmp___11 = data_ptr;
#line 2797
      data_ptr ++;
#line 2797
      Xv___0 |= (unsigned long )((int )*tmp___11 << 8);
#line 2797
      tmp___12 = data_ptr;
#line 2797
      data_ptr ++;
#line 2797
      Xv___0 |= (unsigned long )((int )*tmp___12 << 16);
#line 2797
      tmp___13 = data_ptr;
#line 2797
      data_ptr ++;
#line 2797
      Xv___0 |= (unsigned long )((int )*tmp___13 << 24);
#line 2797
      new_bsr_uni_addr.unicast_addr = (u_int32 )Xv___0;
#line 2797
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2797
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2798
  new_bsr_address = new_bsr_uni_addr.unicast_addr;
#line 2800
  tmp___14 = local_address(new_bsr_address);
  }
#line 2800
  if ((int )tmp___14 != 32) {
#line 2801
    return (0);
  }
#line 2811
  if ((int )curr_bsr_priority > (int )new_bsr_priority) {
#line 2815
    return (0);
  } else
#line 2811
  if ((int )curr_bsr_priority == (int )new_bsr_priority) {
    {
#line 2811
    tmp___15 = ntohl(curr_bsr_address);
#line 2811
    tmp___16 = ntohl(new_bsr_address);
    }
#line 2811
    if (tmp___15 > tmp___16) {
#line 2815
      return (0);
    }
  }
#line 2819
  if (dst == allpimrouters_group) {
    {
#line 2820
    k_req_incoming(new_bsr_address, & rpfc);
    }
#line 2821
    if ((int )rpfc.iif == 32) {
#line 2823
      return (0);
    } else
#line 2821
    if (rpfc.rpfneighbor.s_addr == 0U) {
#line 2823
      return (0);
    }
#line 2826
    neighbor_addr = rpfc.rpfneighbor.s_addr;
#line 2827
    incoming = rpfc.iif;
#line 2828
    if (uvifs[incoming].uv_flags & 772U) {
#line 2829
      return (0);
    }
#line 2832
    n = uvifs[incoming].uv_pim_neighbors;
    {
#line 2832
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2832
      if (! ((unsigned long )n != (unsigned long )((void *)0))) {
#line 2832
        goto while_break___2;
      }
      {
#line 2833
      tmp___17 = ntohl(neighbor_addr);
#line 2833
      tmp___18 = ntohl(n->address);
      }
#line 2833
      if (tmp___17 < tmp___18) {
#line 2834
        goto __Cont;
      }
#line 2836
      if (neighbor_addr == n->address) {
#line 2837
        rpf_neighbor = n;
#line 2838
        goto while_break___2;
      }
#line 2841
      return (0);
      __Cont: /* CIL Label */ 
#line 2832
      n = n->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2844
    if (! n) {
#line 2845
      return (0);
    } else
#line 2844
    if (n->address != src) {
#line 2845
      return (0);
    }
  } else {
    {
#line 2848
    tmp___19 = local_address(dst);
    }
#line 2848
    if ((int )tmp___19 == 32) {
#line 2852
      return (0);
    }
#line 2856
    if ((unsigned long )cand_rp_list != (unsigned long )((cand_rp_t *)((void *)0))) {
#line 2860
      return (0);
    }
#line 2863
    vifi = (vifi_t )0;
    {
#line 2863
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2863
      if (! ((int )vifi < (int )numvifs)) {
#line 2863
        goto while_break___3;
      }
#line 2864
      if (uvifs[vifi].uv_flags & 772U) {
#line 2865
        goto __Cont___0;
      }
#line 2867
      if (uvifs[vifi].uv_lcl_addr == dst) {
#line 2868
        incoming = vifi;
#line 2869
        goto while_break___3;
      }
      __Cont___0: /* CIL Label */ 
#line 2863
      vifi = (vifi_t )((int )vifi + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2873
    if ((int )incoming == 32) {
#line 2875
      if (debug) {
#line 2875
        if (debug & 4325376UL) {
          {
#line 2876
          tmp___20 = inet_fmt(dst, s2, sizeof(s2));
#line 2876
          tmp___21 = inet_fmt(src, s1, sizeof(s1));
#line 2876
          logit(7, 0, "Unicast boostrap message from %s to ignored: cannot find iif",
                tmp___21, tmp___20);
          }
        }
      }
#line 2877
      return (0);
    }
  }
#line 2882
  if ((int )cand_rp_flag == 1) {
#line 2885
    if (new_bsr_address != curr_bsr_address) {
#line 2886
      pim_cand_rp_adv_timer = (u_int16 )0;
    }
  }
#line 2892
  vifi = (vifi_t )0;
  {
#line 2892
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2892
    if (! ((int )vifi < (int )numvifs)) {
#line 2892
      goto while_break___4;
    }
#line 2893
    if ((int )vifi == (int )incoming) {
#line 2894
      goto __Cont___1;
    }
#line 2896
    if (uvifs[vifi].uv_flags & 525060U) {
#line 2897
      goto __Cont___1;
    }
    {
#line 2899
    memcpy((void */* __restrict  */)(pim_send_buf + sizeof(struct ip )), (void const   */* __restrict  */)pim_message,
           (size_t )datalen);
#line 2900
    send_pim(pim_send_buf, uvifs[vifi].uv_lcl_addr, allpimrouters_group, 4, (int )((unsigned long )datalen - sizeof(pim_header_t )));
    }
    __Cont___1: /* CIL Label */ 
#line 2892
    vifi = (vifi_t )((int )vifi + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2904
  max_data_ptr = (u_int8 *)pim_message + datalen;
#line 2908
  min_datalen = 22;
#line 2910
  if ((int )new_bsr_fragment_tag != (int )curr_bsr_fragment_tag) {
    {
#line 2912
    delete_rp_list(& segmented_cand_rp_list, & segmented_grp_mask_list);
    }
  } else
#line 2910
  if (new_bsr_address != curr_bsr_address) {
    {
#line 2912
    delete_rp_list(& segmented_cand_rp_list, & segmented_grp_mask_list);
    }
  }
#line 2915
  curr_bsr_address = new_bsr_address;
#line 2916
  curr_bsr_priority = new_bsr_priority;
#line 2917
  curr_bsr_fragment_tag = new_bsr_fragment_tag;
  {
#line 2918
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2918
    if (new_bsr_hash_masklen) {
      {
#line 2918
      tmp___22 = htonl((uint32_t )(-1 << ((sizeof(curr_bsr_hash_mask) << 3) - (unsigned long )new_bsr_hash_masklen)));
#line 2918
      curr_bsr_hash_mask = tmp___22;
      }
    } else {
#line 2918
      curr_bsr_hash_mask = (u_int32 )0;
    }
#line 2918
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2919
  pim_bootstrap_timer = (u_int16 )(2.5 * (double )30 + (double )10);
  {
#line 2921
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2921
    if (! ((unsigned long )(data_ptr + min_datalen) <= (unsigned long )max_data_ptr)) {
#line 2921
      goto while_break___6;
    }
    {
#line 2922
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2922
      tmp___23 = data_ptr;
#line 2922
      data_ptr ++;
#line 2922
      curr_group_addr.addr_family = *tmp___23;
#line 2922
      tmp___24 = data_ptr;
#line 2922
      data_ptr ++;
#line 2922
      curr_group_addr.encod_type = *tmp___24;
#line 2922
      tmp___25 = data_ptr;
#line 2922
      data_ptr ++;
#line 2922
      curr_group_addr.reserved = *tmp___25;
#line 2922
      tmp___26 = data_ptr;
#line 2922
      data_ptr ++;
#line 2922
      curr_group_addr.masklen = *tmp___26;
      {
#line 2922
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2922
        tmp___27 = data_ptr;
#line 2922
        data_ptr ++;
#line 2922
        Xv___1 = (u_long )*tmp___27;
#line 2922
        tmp___28 = data_ptr;
#line 2922
        data_ptr ++;
#line 2922
        Xv___1 |= (unsigned long )((int )*tmp___28 << 8);
#line 2922
        tmp___29 = data_ptr;
#line 2922
        data_ptr ++;
#line 2922
        Xv___1 |= (unsigned long )((int )*tmp___29 << 16);
#line 2922
        tmp___30 = data_ptr;
#line 2922
        data_ptr ++;
#line 2922
        Xv___1 |= (unsigned long )((int )*tmp___30 << 24);
#line 2922
        curr_group_addr.mcast_addr = (u_int32 )Xv___1;
#line 2922
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2922
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2923
    tmp___31 = data_ptr;
#line 2923
    data_ptr ++;
#line 2923
    curr_rp_count = *tmp___31;
#line 2924
    tmp___32 = data_ptr;
#line 2924
    data_ptr ++;
#line 2924
    curr_frag_rp_count = *tmp___32;
    {
#line 2925
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2925
      tmp___33 = data_ptr;
#line 2925
      data_ptr ++;
#line 2925
      Xv___2 = (u_int16 )((int )*tmp___33 << 8);
#line 2925
      tmp___34 = data_ptr;
#line 2925
      data_ptr ++;
#line 2925
      Xv___2 = (u_int16 )((int )Xv___2 | (int )*tmp___34);
#line 2925
      reserved_short = Xv___2;
#line 2925
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 2926
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2926
      if (curr_group_addr.masklen) {
        {
#line 2926
        tmp___35 = htonl((uint32_t )(-1 << ((sizeof(curr_group_mask) << 3) - (unsigned long )curr_group_addr.masklen)));
#line 2926
        curr_group_mask = tmp___35;
        }
      } else {
#line 2926
        curr_group_mask = (u_int32 )0;
      }
#line 2926
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2927
    if ((int )curr_rp_count == 0) {
      {
#line 2928
      delete_grp_mask(& cand_rp_list, & grp_mask_list, curr_group_addr.mcast_addr,
                      curr_group_mask);
      }
#line 2930
      goto while_continue___6;
    }
#line 2933
    if ((int )curr_rp_count == (int )curr_frag_rp_count) {
      {
#line 2935
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2935
        tmp___47 = curr_frag_rp_count;
#line 2935
        curr_frag_rp_count = (u_int8 )((int )curr_frag_rp_count - 1);
#line 2935
        if (! tmp___47) {
#line 2935
          goto while_break___11;
        }
        {
#line 2936
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 2936
          tmp___36 = data_ptr;
#line 2936
          data_ptr ++;
#line 2936
          curr_rp_addr.addr_family = *tmp___36;
#line 2936
          tmp___37 = data_ptr;
#line 2936
          data_ptr ++;
#line 2936
          curr_rp_addr.encod_type = *tmp___37;
          {
#line 2936
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 2936
            tmp___38 = data_ptr;
#line 2936
            data_ptr ++;
#line 2936
            Xv___3 = (u_long )*tmp___38;
#line 2936
            tmp___39 = data_ptr;
#line 2936
            data_ptr ++;
#line 2936
            Xv___3 |= (unsigned long )((int )*tmp___39 << 8);
#line 2936
            tmp___40 = data_ptr;
#line 2936
            data_ptr ++;
#line 2936
            Xv___3 |= (unsigned long )((int )*tmp___40 << 16);
#line 2936
            tmp___41 = data_ptr;
#line 2936
            data_ptr ++;
#line 2936
            Xv___3 |= (unsigned long )((int )*tmp___41 << 24);
#line 2936
            curr_rp_addr.unicast_addr = (u_int32 )Xv___3;
#line 2936
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 2936
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 2937
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 2937
          tmp___42 = data_ptr;
#line 2937
          data_ptr ++;
#line 2937
          Xv___4 = (u_int16 )((int )*tmp___42 << 8);
#line 2937
          tmp___43 = data_ptr;
#line 2937
          data_ptr ++;
#line 2937
          Xv___4 = (u_int16 )((int )Xv___4 | (int )*tmp___43);
#line 2937
          curr_rp_holdtime = Xv___4;
#line 2937
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 2938
        tmp___44 = data_ptr;
#line 2938
        data_ptr ++;
#line 2938
        curr_rp_priority = *tmp___44;
#line 2939
        tmp___45 = data_ptr;
#line 2939
        data_ptr ++;
#line 2939
        reserved_byte = *tmp___45;
        {
#line 2940
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 2940
          if (curr_group_addr.masklen) {
            {
#line 2940
            tmp___46 = htonl((uint32_t )(-1 << ((sizeof(curr_group_mask) << 3) - (unsigned long )curr_group_addr.masklen)));
#line 2940
            curr_group_mask = tmp___46;
            }
          } else {
#line 2940
            curr_group_mask = (u_int32 )0;
          }
#line 2940
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 2941
        add_rp_grp_entry(& cand_rp_list, & grp_mask_list, curr_rp_addr.unicast_addr,
                         curr_rp_priority, curr_rp_holdtime, curr_group_addr.mcast_addr,
                         curr_group_mask, curr_bsr_hash_mask, curr_bsr_fragment_tag);
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 2948
      goto while_continue___6;
    }
    {
#line 2955
    prefix_h = ntohl(curr_group_addr.mcast_addr & curr_group_mask);
#line 2956
    grp_mask_ptr = segmented_grp_mask_list;
    }
    {
#line 2956
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 2956
      if (! ((unsigned long )grp_mask_ptr != (unsigned long )((grp_mask_t *)((void *)0)))) {
#line 2956
        goto while_break___16;
      }
      {
#line 2959
      tmp___48 = ntohl(grp_mask_ptr->group_addr & grp_mask_ptr->group_mask);
      }
#line 2959
      if (! (tmp___48 > prefix_h)) {
#line 2963
        goto while_break___16;
      }
#line 2956
      grp_mask_ptr = grp_mask_ptr->next;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 2966
    if ((unsigned long )grp_mask_ptr != (unsigned long )((grp_mask_t *)((void *)0))) {
#line 2966
      if (grp_mask_ptr->group_addr == curr_group_addr.mcast_addr) {
#line 2966
        if (grp_mask_ptr->group_mask == curr_group_mask) {
#line 2966
          if ((int )grp_mask_ptr->group_rp_number + (int )curr_frag_rp_count == (int )curr_rp_count) {
            {
#line 2971
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 2971
              tmp___60 = curr_frag_rp_count;
#line 2971
              curr_frag_rp_count = (u_int8 )((int )curr_frag_rp_count - 1);
#line 2971
              if (! tmp___60) {
#line 2971
                goto while_break___17;
              }
              {
#line 2972
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 2972
                tmp___49 = data_ptr;
#line 2972
                data_ptr ++;
#line 2972
                curr_rp_addr.addr_family = *tmp___49;
#line 2972
                tmp___50 = data_ptr;
#line 2972
                data_ptr ++;
#line 2972
                curr_rp_addr.encod_type = *tmp___50;
                {
#line 2972
                while (1) {
                  while_continue___19: /* CIL Label */ ;
#line 2972
                  tmp___51 = data_ptr;
#line 2972
                  data_ptr ++;
#line 2972
                  Xv___5 = (u_long )*tmp___51;
#line 2972
                  tmp___52 = data_ptr;
#line 2972
                  data_ptr ++;
#line 2972
                  Xv___5 |= (unsigned long )((int )*tmp___52 << 8);
#line 2972
                  tmp___53 = data_ptr;
#line 2972
                  data_ptr ++;
#line 2972
                  Xv___5 |= (unsigned long )((int )*tmp___53 << 16);
#line 2972
                  tmp___54 = data_ptr;
#line 2972
                  data_ptr ++;
#line 2972
                  Xv___5 |= (unsigned long )((int )*tmp___54 << 24);
#line 2972
                  curr_rp_addr.unicast_addr = (u_int32 )Xv___5;
#line 2972
                  goto while_break___19;
                }
                while_break___19: /* CIL Label */ ;
                }
#line 2972
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 2973
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 2973
                tmp___55 = data_ptr;
#line 2973
                data_ptr ++;
#line 2973
                Xv___6 = (u_int16 )((int )*tmp___55 << 8);
#line 2973
                tmp___56 = data_ptr;
#line 2973
                data_ptr ++;
#line 2973
                Xv___6 = (u_int16 )((int )Xv___6 | (int )*tmp___56);
#line 2973
                curr_rp_holdtime = Xv___6;
#line 2973
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 2974
              tmp___57 = data_ptr;
#line 2974
              data_ptr ++;
#line 2974
              curr_rp_priority = *tmp___57;
#line 2975
              tmp___58 = data_ptr;
#line 2975
              data_ptr ++;
#line 2975
              reserved_byte = *tmp___58;
              {
#line 2976
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 2976
                if (curr_group_addr.masklen) {
                  {
#line 2976
                  tmp___59 = htonl((uint32_t )(-1 << ((sizeof(curr_group_mask) << 3) - (unsigned long )curr_group_addr.masklen)));
#line 2976
                  curr_group_mask = tmp___59;
                  }
                } else {
#line 2976
                  curr_group_mask = (u_int32 )0;
                }
#line 2976
                goto while_break___21;
              }
              while_break___21: /* CIL Label */ ;
              }
              {
#line 2977
              add_rp_grp_entry(& cand_rp_list, & grp_mask_list, curr_rp_addr.unicast_addr,
                               curr_rp_priority, curr_rp_holdtime, curr_group_addr.mcast_addr,
                               curr_group_mask, curr_bsr_hash_mask, curr_bsr_fragment_tag);
              }
            }
            while_break___17: /* CIL Label */ ;
            }
#line 2989
            grp_rp_entry_ptr = grp_mask_ptr->grp_rp_next;
            {
#line 2989
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 2989
              if (! ((unsigned long )grp_rp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 2989
                goto while_break___22;
              }
              {
#line 2992
              add_rp_grp_entry(& cand_rp_list, & grp_mask_list, ((grp_rp_entry_ptr->rp)->rpentry)->address,
                               grp_rp_entry_ptr->priority, grp_rp_entry_ptr->holdtime,
                               curr_group_addr.mcast_addr, curr_group_mask, curr_bsr_hash_mask,
                               curr_bsr_fragment_tag);
#line 2989
              grp_rp_entry_ptr = grp_rp_entry_ptr->grp_rp_next;
              }
            }
            while_break___22: /* CIL Label */ ;
            }
            {
#line 3002
            delete_grp_mask(& segmented_cand_rp_list, & segmented_grp_mask_list, curr_group_addr.mcast_addr,
                            curr_group_mask);
            }
          } else {
#line 2966
            goto _L___1;
          }
        } else {
#line 2966
          goto _L___1;
        }
      } else {
#line 2966
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 3008
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 3008
        tmp___72 = curr_frag_rp_count;
#line 3008
        curr_frag_rp_count = (u_int8 )((int )curr_frag_rp_count - 1);
#line 3008
        if (! tmp___72) {
#line 3008
          goto while_break___23;
        }
        {
#line 3009
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 3009
          tmp___61 = data_ptr;
#line 3009
          data_ptr ++;
#line 3009
          curr_rp_addr.addr_family = *tmp___61;
#line 3009
          tmp___62 = data_ptr;
#line 3009
          data_ptr ++;
#line 3009
          curr_rp_addr.encod_type = *tmp___62;
          {
#line 3009
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 3009
            tmp___63 = data_ptr;
#line 3009
            data_ptr ++;
#line 3009
            Xv___7 = (u_long )*tmp___63;
#line 3009
            tmp___64 = data_ptr;
#line 3009
            data_ptr ++;
#line 3009
            Xv___7 |= (unsigned long )((int )*tmp___64 << 8);
#line 3009
            tmp___65 = data_ptr;
#line 3009
            data_ptr ++;
#line 3009
            Xv___7 |= (unsigned long )((int )*tmp___65 << 16);
#line 3009
            tmp___66 = data_ptr;
#line 3009
            data_ptr ++;
#line 3009
            Xv___7 |= (unsigned long )((int )*tmp___66 << 24);
#line 3009
            curr_rp_addr.unicast_addr = (u_int32 )Xv___7;
#line 3009
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
#line 3009
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
        {
#line 3010
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 3010
          tmp___67 = data_ptr;
#line 3010
          data_ptr ++;
#line 3010
          Xv___8 = (u_int16 )((int )*tmp___67 << 8);
#line 3010
          tmp___68 = data_ptr;
#line 3010
          data_ptr ++;
#line 3010
          Xv___8 = (u_int16 )((int )Xv___8 | (int )*tmp___68);
#line 3010
          curr_rp_holdtime = Xv___8;
#line 3010
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 3011
        tmp___69 = data_ptr;
#line 3011
        data_ptr ++;
#line 3011
        curr_rp_priority = *tmp___69;
#line 3012
        tmp___70 = data_ptr;
#line 3012
        data_ptr ++;
#line 3012
        reserved_byte = *tmp___70;
        {
#line 3013
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 3013
          if (curr_group_addr.masklen) {
            {
#line 3013
            tmp___71 = htonl((uint32_t )(-1 << ((sizeof(curr_group_mask) << 3) - (unsigned long )curr_group_addr.masklen)));
#line 3013
            curr_group_mask = tmp___71;
            }
          } else {
#line 3013
            curr_group_mask = (u_int32 )0;
          }
#line 3013
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
        {
#line 3014
        add_rp_grp_entry(& segmented_cand_rp_list, & segmented_grp_mask_list, curr_rp_addr.unicast_addr,
                         curr_rp_priority, curr_rp_holdtime, curr_group_addr.mcast_addr,
                         curr_group_mask, curr_bsr_hash_mask, curr_bsr_fragment_tag);
        }
      }
      while_break___23: /* CIL Label */ ;
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 3032
  grp_mask_ptr = grp_mask_list;
  {
#line 3032
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 3032
    if (! ((unsigned long )grp_mask_ptr != (unsigned long )((grp_mask_t *)((void *)0)))) {
#line 3032
      goto while_break___28;
    }
#line 3035
    grp_mask_next = grp_mask_ptr->next;
#line 3036
    if ((int )grp_mask_ptr->fragment_tag == (int )curr_bsr_fragment_tag) {
#line 3037
      grp_rp_entry_ptr = grp_mask_ptr->grp_rp_next;
      {
#line 3037
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 3037
        if (! ((unsigned long )grp_rp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 3037
          goto while_break___29;
        }
#line 3040
        grp_rp_entry_next = grp_rp_entry_ptr->grp_rp_next;
#line 3041
        if ((int )grp_rp_entry_ptr->fragment_tag != (int )curr_bsr_fragment_tag) {
          {
#line 3042
          delete_rp_grp_entry(& cand_rp_list, & grp_mask_list, grp_rp_entry_ptr);
          }
        }
#line 3037
        grp_rp_entry_ptr = grp_rp_entry_next;
      }
      while_break___29: /* CIL Label */ ;
      }
    }
#line 3032
    grp_mask_ptr = grp_mask_next;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 3048
  grp_mask_ptr = segmented_grp_mask_list;
  {
#line 3048
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 3048
    if (! ((unsigned long )grp_mask_ptr != (unsigned long )((grp_mask_t *)((void *)0)))) {
#line 3048
      goto while_break___30;
    }
#line 3051
    grp_mask_next = grp_mask_ptr->next;
#line 3052
    if ((int )grp_mask_ptr->fragment_tag == (int )curr_bsr_fragment_tag) {
#line 3053
      grp_rp_entry_ptr = grp_mask_ptr->grp_rp_next;
      {
#line 3053
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 3053
        if (! ((unsigned long )grp_rp_entry_ptr != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 3053
          goto while_break___31;
        }
#line 3056
        grp_rp_entry_next = grp_rp_entry_ptr->grp_rp_next;
#line 3057
        if ((int )grp_rp_entry_ptr->fragment_tag != (int )curr_bsr_fragment_tag) {
          {
#line 3058
          delete_rp_grp_entry(& segmented_cand_rp_list, & segmented_grp_mask_list,
                              grp_rp_entry_ptr);
          }
        }
#line 3053
        grp_rp_entry_ptr = grp_rp_entry_next;
      }
      while_break___31: /* CIL Label */ ;
      }
    }
#line 3048
    grp_mask_ptr = grp_mask_next;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 3065
  return (1);
}
}
#line 3069 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
void send_pim_bootstrap(void) 
{ 
  int datalen ;
  vifi_t vifi ;

  {
  {
#line 3074
  datalen = create_pim_bootstrap_message(pim_send_buf);
  }
#line 3074
  if (datalen) {
#line 3075
    vifi = (vifi_t )0;
    {
#line 3075
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3075
      if (! ((int )vifi < (int )numvifs)) {
#line 3075
        goto while_break;
      }
#line 3076
      if (uvifs[vifi].uv_flags & 772U) {
#line 3077
        goto __Cont;
      }
      {
#line 3078
      send_pim(pim_send_buf, uvifs[vifi].uv_lcl_addr, allpimrouters_group, 4, datalen);
      }
      __Cont: /* CIL Label */ 
#line 3075
      vifi = (vifi_t )((int )vifi + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3082
  return;
}
}
#line 3093 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int receive_pim_cand_rp_adv(u_int32 src , u_int32 dst  __attribute__((__unused__)) ,
                            char *pim_message , int datalen ) 
{ 
  u_int8 prefix_cnt ;
  u_int8 priority ;
  u_int16 holdtime ;
  pim_encod_uni_addr_t cand_rp_addr ;
  pim_encod_grp_addr_t encod_grp_addr ;
  u_int8 *data_ptr ;
  u_int32 grp_mask ;
  int tmp ;
  char *tmp___0 ;
  u_int8 *tmp___1 ;
  u_int8 *tmp___2 ;
  register u_int16 Xv ;
  u_int8 *tmp___3 ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  register u_long Xv___0 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  u_int8 *tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  u_int8 *tmp___13 ;
  u_int8 *tmp___14 ;
  u_int8 *tmp___15 ;
  u_int8 *tmp___16 ;
  register u_long Xv___1 ;
  u_int8 *tmp___17 ;
  u_int8 *tmp___18 ;
  u_int8 *tmp___19 ;
  u_int8 *tmp___20 ;
  uint32_t tmp___21 ;
  u_int8 tmp___22 ;

  {
  {
#line 3104
  tmp = inet_cksum((u_int16 *)pim_message, (u_int )datalen);
  }
#line 3104
  if (tmp) {
#line 3105
    return (0);
  }
#line 3108
  if ((int )cand_bsr_flag == 0) {
#line 3109
    return (0);
  } else
#line 3108
  if (curr_bsr_address != my_bsr_address) {
#line 3109
    return (0);
  }
#line 3112
  if (datalen < 14) {
    {
#line 3113
    tmp___0 = inet_fmt(src, s1, sizeof(s1));
#line 3113
    logit(5, 0, "receive_pim_cand_rp_adv: cand_RP message size(%u) is too short from %s",
          datalen, tmp___0);
    }
#line 3116
    return (0);
  }
#line 3119
  data_ptr = (u_int8 *)(pim_message + sizeof(pim_header_t ));
#line 3122
  tmp___1 = data_ptr;
#line 3122
  data_ptr ++;
#line 3122
  prefix_cnt = *tmp___1;
#line 3123
  tmp___2 = data_ptr;
#line 3123
  data_ptr ++;
#line 3123
  priority = *tmp___2;
  {
#line 3124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3124
    tmp___3 = data_ptr;
#line 3124
    data_ptr ++;
#line 3124
    Xv = (u_int16 )((int )*tmp___3 << 8);
#line 3124
    tmp___4 = data_ptr;
#line 3124
    data_ptr ++;
#line 3124
    Xv = (u_int16 )((int )Xv | (int )*tmp___4);
#line 3124
    holdtime = Xv;
#line 3124
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3125
    tmp___5 = data_ptr;
#line 3125
    data_ptr ++;
#line 3125
    cand_rp_addr.addr_family = *tmp___5;
#line 3125
    tmp___6 = data_ptr;
#line 3125
    data_ptr ++;
#line 3125
    cand_rp_addr.encod_type = *tmp___6;
    {
#line 3125
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3125
      tmp___7 = data_ptr;
#line 3125
      data_ptr ++;
#line 3125
      Xv___0 = (u_long )*tmp___7;
#line 3125
      tmp___8 = data_ptr;
#line 3125
      data_ptr ++;
#line 3125
      Xv___0 |= (unsigned long )((int )*tmp___8 << 8);
#line 3125
      tmp___9 = data_ptr;
#line 3125
      data_ptr ++;
#line 3125
      Xv___0 |= (unsigned long )((int )*tmp___9 << 16);
#line 3125
      tmp___10 = data_ptr;
#line 3125
      data_ptr ++;
#line 3125
      Xv___0 |= (unsigned long )((int )*tmp___10 << 24);
#line 3125
      cand_rp_addr.unicast_addr = (u_int32 )Xv___0;
#line 3125
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3125
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3126
  if ((int )prefix_cnt == 0) {
    {
#line 3128
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 3128
      tmp___11 = htonl((uint32_t )(-1 << ((sizeof(grp_mask) << 3) - 4UL)));
#line 3128
      grp_mask = tmp___11;
      }
#line 3128
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3129
    tmp___12 = htonl(3758096384U);
#line 3129
    add_rp_grp_entry(& cand_rp_list, & grp_mask_list, cand_rp_addr.unicast_addr, priority,
                     holdtime, tmp___12, grp_mask, my_bsr_hash_mask, curr_bsr_fragment_tag);
    }
#line 3135
    return (1);
  }
  {
#line 3138
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3138
    tmp___22 = prefix_cnt;
#line 3138
    prefix_cnt = (u_int8 )((int )prefix_cnt - 1);
#line 3138
    if (! tmp___22) {
#line 3138
      goto while_break___3;
    }
    {
#line 3139
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3139
      tmp___13 = data_ptr;
#line 3139
      data_ptr ++;
#line 3139
      encod_grp_addr.addr_family = *tmp___13;
#line 3139
      tmp___14 = data_ptr;
#line 3139
      data_ptr ++;
#line 3139
      encod_grp_addr.encod_type = *tmp___14;
#line 3139
      tmp___15 = data_ptr;
#line 3139
      data_ptr ++;
#line 3139
      encod_grp_addr.reserved = *tmp___15;
#line 3139
      tmp___16 = data_ptr;
#line 3139
      data_ptr ++;
#line 3139
      encod_grp_addr.masklen = *tmp___16;
      {
#line 3139
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3139
        tmp___17 = data_ptr;
#line 3139
        data_ptr ++;
#line 3139
        Xv___1 = (u_long )*tmp___17;
#line 3139
        tmp___18 = data_ptr;
#line 3139
        data_ptr ++;
#line 3139
        Xv___1 |= (unsigned long )((int )*tmp___18 << 8);
#line 3139
        tmp___19 = data_ptr;
#line 3139
        data_ptr ++;
#line 3139
        Xv___1 |= (unsigned long )((int )*tmp___19 << 16);
#line 3139
        tmp___20 = data_ptr;
#line 3139
        data_ptr ++;
#line 3139
        Xv___1 |= (unsigned long )((int )*tmp___20 << 24);
#line 3139
        encod_grp_addr.mcast_addr = (u_int32 )Xv___1;
#line 3139
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3139
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3140
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3140
      if (encod_grp_addr.masklen) {
        {
#line 3140
        tmp___21 = htonl((uint32_t )(-1 << ((sizeof(grp_mask) << 3) - (unsigned long )encod_grp_addr.masklen)));
#line 3140
        grp_mask = tmp___21;
        }
      } else {
#line 3140
        grp_mask = (u_int32 )0;
      }
#line 3140
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 3141
    add_rp_grp_entry(& cand_rp_list, & grp_mask_list, cand_rp_addr.unicast_addr, priority,
                     holdtime, encod_grp_addr.mcast_addr, grp_mask, my_bsr_hash_mask,
                     curr_bsr_fragment_tag);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3149
  return (1);
}
}
#line 3153 "/home/wheatley/newnew/temp/pimd-2.1.8/pim_proto.c"
int send_pim_cand_rp_adv(void) 
{ 
  u_int8 prefix_cnt ;
  u_int32 grp_mask ;
  pim_encod_grp_addr_t encod_grp_addr ;
  u_int8 *data_ptr ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  u_int8 *tmp___2 ;
  u_int8 *tmp___3 ;
  u_int8 *tmp___4 ;
  u_int8 *tmp___5 ;
  register u_long Xv ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  uint32_t tmp___10 ;
  u_int8 tmp___11 ;

  {
  {
#line 3160
  tmp = inet_valid_host(curr_bsr_address);
  }
#line 3160
  if (! tmp) {
#line 3161
    return (0);
  }
#line 3163
  if (curr_bsr_address == my_bsr_address) {
#line 3165
    prefix_cnt = *(cand_rp_adv_message.prefix_cnt_ptr);
#line 3166
    if ((int )prefix_cnt == 0) {
      {
#line 3168
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 3168
        tmp___0 = htonl((uint32_t )(-1 << ((sizeof(grp_mask) << 3) - 4UL)));
#line 3168
        grp_mask = tmp___0;
        }
#line 3168
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3169
      tmp___1 = htonl(3758096384U);
#line 3169
      add_rp_grp_entry(& cand_rp_list, & grp_mask_list, my_cand_rp_address, my_cand_rp_priority,
                       my_cand_rp_holdtime, tmp___1, my_bsr_hash_mask, grp_mask, curr_bsr_fragment_tag);
      }
#line 3175
      return (1);
    }
#line 3179
    data_ptr = cand_rp_adv_message.buffer + 10;
    {
#line 3180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3180
      tmp___11 = prefix_cnt;
#line 3180
      prefix_cnt = (u_int8 )((int )prefix_cnt - 1);
#line 3180
      if (! tmp___11) {
#line 3180
        goto while_break___0;
      }
      {
#line 3181
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3181
        tmp___2 = data_ptr;
#line 3181
        data_ptr ++;
#line 3181
        encod_grp_addr.addr_family = *tmp___2;
#line 3181
        tmp___3 = data_ptr;
#line 3181
        data_ptr ++;
#line 3181
        encod_grp_addr.encod_type = *tmp___3;
#line 3181
        tmp___4 = data_ptr;
#line 3181
        data_ptr ++;
#line 3181
        encod_grp_addr.reserved = *tmp___4;
#line 3181
        tmp___5 = data_ptr;
#line 3181
        data_ptr ++;
#line 3181
        encod_grp_addr.masklen = *tmp___5;
        {
#line 3181
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3181
          tmp___6 = data_ptr;
#line 3181
          data_ptr ++;
#line 3181
          Xv = (u_long )*tmp___6;
#line 3181
          tmp___7 = data_ptr;
#line 3181
          data_ptr ++;
#line 3181
          Xv |= (unsigned long )((int )*tmp___7 << 8);
#line 3181
          tmp___8 = data_ptr;
#line 3181
          data_ptr ++;
#line 3181
          Xv |= (unsigned long )((int )*tmp___8 << 16);
#line 3181
          tmp___9 = data_ptr;
#line 3181
          data_ptr ++;
#line 3181
          Xv |= (unsigned long )((int )*tmp___9 << 24);
#line 3181
          encod_grp_addr.mcast_addr = (u_int32 )Xv;
#line 3181
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3181
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 3182
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3182
        if (encod_grp_addr.masklen) {
          {
#line 3182
          tmp___10 = htonl((uint32_t )(-1 << ((sizeof(grp_mask) << 3) - (unsigned long )encod_grp_addr.masklen)));
#line 3182
          grp_mask = tmp___10;
          }
        } else {
#line 3182
          grp_mask = (u_int32 )0;
        }
#line 3182
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 3183
      add_rp_grp_entry(& cand_rp_list, & grp_mask_list, my_cand_rp_address, my_cand_rp_priority,
                       my_cand_rp_holdtime, encod_grp_addr.mcast_addr, grp_mask, my_bsr_hash_mask,
                       curr_bsr_fragment_tag);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3193
    return (1);
  }
  {
#line 3196
  data_ptr = (u_int8 *)((pim_send_buf + sizeof(struct ip )) + sizeof(pim_header_t ));
#line 3197
  memcpy((void */* __restrict  */)data_ptr, (void const   */* __restrict  */)cand_rp_adv_message.buffer,
         (size_t )cand_rp_adv_message.message_size);
#line 3198
  send_pim_unicast(pim_send_buf, my_cand_rp_address, curr_bsr_address, 8, (int )cand_rp_adv_message.message_size);
  }
#line 3201
  return (1);
}
}
#line 28 "/home/wheatley/newnew/temp/pimd-2.1.8/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 31
  d = dst;
#line 32
  s = src;
#line 33
  n = siz;
#line 36
  if (n != 0UL) {
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      n --;
#line 37
      if (! (n != 0UL)) {
#line 37
        goto while_break;
      }
#line 38
      tmp = d;
#line 38
      d ++;
#line 38
      tmp___1 = s;
#line 38
      s ++;
#line 38
      tmp___0 = (char )*tmp___1;
#line 38
      *tmp = tmp___0;
#line 38
      if ((int )tmp___0 == 0) {
#line 39
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 44
  if (n == 0UL) {
#line 45
    if (siz != 0UL) {
#line 46
      *d = (char )'\000';
    }
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 47
      tmp___2 = s;
#line 47
      s ++;
#line 47
      if (! *tmp___2) {
#line 47
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 51
  return ((size_t )((s - src) - 1L));
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 474 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int inet_valid_subnet(u_int32 nsubnet , u_int32 nmask ) ;
#line 476
char *netname(u_int32 addr , u_int32 mask ) ;
#line 477
u_int32 inet_parse(char *s , int n ) ;
#line 48 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
static char *next_word(char **s ) ;
#line 49
static int parse_phyint(char *s ) ;
#line 50
static u_int32 ifname2addr(char *s ) ;
#line 52
struct rp_hold *g_rp_hold ;
#line 58 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
void config_vifs_from_kernel(void) 
{ 
  struct ifreq *ifrp ;
  struct ifreq *ifend ;
  struct uvif *v ;
  vifi_t vifi ;
  u_int32 n ;
  u_int32 addr ;
  u_int32 mask ;
  u_int32 subnet ;
  short flags ;
  int num_ifreq ;
  struct ifconf ifc ;
  char *newbuf ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  struct ifreq ifr ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  struct ifreq ifridx ;
  int *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
  {
#line 66
  num_ifreq = 64;
#line 70
  total_interfaces = 0;
#line 72
  ifc.ifc_len = (int )((unsigned long )num_ifreq * sizeof(struct ifreq ));
#line 73
  tmp = calloc((size_t )ifc.ifc_len, sizeof(char ));
#line 73
  ifc.ifc_ifcu.ifcu_buf = (__caddr_t )tmp;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ifc.ifc_ifcu.ifcu_buf) {
#line 74
      goto while_break;
    }
    {
#line 75
    tmp___1 = ioctl(udp_socket, 35090UL, (char *)(& ifc));
    }
#line 75
    if (tmp___1 < 0) {
      {
#line 76
      tmp___0 = __errno_location();
#line 76
      logit(3, *tmp___0, "ioctl SIOCGIFCONF");
      }
    }
#line 87
    if ((unsigned long )num_ifreq * sizeof(struct ifreq ) >= (unsigned long )ifc.ifc_len + sizeof(struct ifreq )) {
#line 88
      goto while_break;
    }
    {
#line 90
    num_ifreq *= 2;
#line 91
    ifc.ifc_len = (int )((unsigned long )num_ifreq * sizeof(struct ifreq ));
#line 92
    tmp___2 = realloc((void *)ifc.ifc_ifcu.ifcu_buf, (size_t )ifc.ifc_len);
#line 92
    newbuf = (char *)tmp___2;
    }
#line 93
    if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
      {
#line 94
      free((void *)ifc.ifc_ifcu.ifcu_buf);
      }
    }
#line 95
    ifc.ifc_ifcu.ifcu_buf = newbuf;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if ((unsigned long )ifc.ifc_ifcu.ifcu_buf == (unsigned long )((void *)0)) {
    {
#line 98
    logit(3, 0, "config_vifs_from_kernel: ran out of memory");
    }
  }
#line 100
  ifrp = (struct ifreq *)ifc.ifc_ifcu.ifcu_buf;
#line 101
  ifend = (struct ifreq *)(ifc.ifc_ifcu.ifcu_buf + ifc.ifc_len);
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! ((unsigned long )ifrp < (unsigned long )ifend)) {
#line 105
      goto while_break___0;
    }
#line 112
    n = (u_int32 )sizeof(*ifrp);
#line 118
    if ((int )ifrp->ifr_ifru.ifru_addr.sa_family != 2) {
#line 119
      total_interfaces ++;
#line 120
      goto __Cont;
    }
    {
#line 123
    addr = ((struct sockaddr_in *)(& ifrp->ifr_ifru.ifru_addr))->sin_addr.s_addr;
#line 131
    memcpy((void */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (void const   */* __restrict  */)(ifrp->ifr_ifrn.ifrn_name),
           sizeof(ifr.ifr_ifrn.ifrn_name));
#line 137
    tmp___4 = ioctl(udp_socket, 35091UL, (char *)(& ifr));
    }
#line 137
    if (tmp___4 < 0) {
      {
#line 138
      tmp___3 = __errno_location();
#line 138
      logit(3, *tmp___3, "ioctl SIOCGIFFLAGS for %s", ifr.ifr_ifrn.ifrn_name);
      }
    }
#line 139
    flags = ifr.ifr_ifru.ifru_flags;
#line 140
    if (((int )flags & 4104) != 4096) {
#line 141
      goto __Cont;
    }
    {
#line 148
    total_interfaces ++;
#line 155
    tmp___6 = ioctl(udp_socket, 35099UL, (char *)(& ifr));
    }
#line 155
    if (tmp___6 < 0) {
#line 156
      if (! ((int )flags & 16)) {
        {
#line 157
        tmp___5 = __errno_location();
#line 157
        logit(3, *tmp___5, "ioctl SIOCGIFNETMASK for %s", ifr.ifr_ifrn.ifrn_name);
        }
      }
#line 159
      mask = 4294967295U;
    } else {
#line 161
      mask = ((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr.s_addr;
    }
    {
#line 164
    subnet = addr & mask;
#line 165
    tmp___10 = inet_valid_subnet(subnet, mask);
    }
#line 165
    if (tmp___10) {
#line 165
      if (addr == subnet) {
#line 165
        goto _L;
      } else
#line 165
      if (addr == (subnet | ~ mask)) {
        _L: /* CIL Label */ 
        {
#line 167
        tmp___9 = inet_valid_host(addr);
        }
#line 167
        if (tmp___9) {
#line 167
          if (! ((int )flags & 16)) {
            {
#line 168
            tmp___7 = inet_fmt(mask, s2, sizeof(s2));
#line 168
            tmp___8 = inet_fmt(addr, s1, sizeof(s1));
#line 168
            logit(4, 0, "ignoring %s, has invalid address (%s) and/or mask (%s)",
                  ifr.ifr_ifrn.ifrn_name, tmp___8, tmp___7);
            }
#line 170
            goto __Cont;
          }
        } else {
          {
#line 168
          tmp___7 = inet_fmt(mask, s2, sizeof(s2));
#line 168
          tmp___8 = inet_fmt(addr, s1, sizeof(s1));
#line 168
          logit(4, 0, "ignoring %s, has invalid address (%s) and/or mask (%s)", ifr.ifr_ifrn.ifrn_name,
                tmp___8, tmp___7);
          }
#line 170
          goto __Cont;
        }
      }
    } else {
#line 165
      goto _L;
    }
#line 182
    vifi = (vifi_t )0;
#line 182
    v = uvifs;
    {
#line 182
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 182
      if (! ((int )vifi < (int )numvifs)) {
#line 182
        goto while_break___1;
      }
      {
#line 183
      tmp___13 = strcmp((char const   *)(v->uv_name), (char const   *)(ifr.ifr_ifrn.ifrn_name));
      }
#line 183
      if (tmp___13 == 0) {
        {
#line 184
        tmp___11 = netname(subnet, mask);
#line 184
        tmp___12 = inet_fmt(addr, s1, sizeof(s1));
#line 184
        logit(7, 0, "Skipping %s (%s on subnet %s) (alias for vif#%u?)", v->uv_name,
              tmp___12, tmp___11, (int )vifi);
        }
#line 187
        goto while_break___1;
      }
#line 190
      if ((int )flags & 16) {
#line 191
        goto __Cont___0;
      }
#line 192
      if (v->uv_flags & 1048576U) {
#line 193
        goto __Cont___0;
      }
#line 206
      if ((addr & v->uv_subnetmask) == v->uv_subnet) {
        {
#line 208
        logit(4, 0, "Ignoring %s, same subnet as %s", ifr.ifr_ifrn.ifrn_name, v->uv_name);
        }
#line 210
        goto while_break___1;
      } else
#line 206
      if ((v->uv_subnet & mask) == subnet) {
        {
#line 208
        logit(4, 0, "Ignoring %s, same subnet as %s", ifr.ifr_ifrn.ifrn_name, v->uv_name);
        }
#line 210
        goto while_break___1;
      }
      __Cont___0: /* CIL Label */ 
#line 182
      vifi = (vifi_t )((int )vifi + 1);
#line 182
      v ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 214
    if ((int )vifi != (int )numvifs) {
#line 215
      goto __Cont;
    }
#line 220
    if ((int )numvifs == 32) {
      {
#line 221
      logit(4, 0, "Too many vifs, ignoring %s", ifr.ifr_ifrn.ifrn_name);
      }
#line 222
      goto __Cont;
    }
    {
#line 224
    v = & uvifs[numvifs];
#line 225
    zero_vif(v, 0);
#line 226
    v->uv_lcl_addr = addr;
#line 227
    v->uv_subnet = subnet;
#line 228
    v->uv_subnetmask = mask;
#line 229
    v->uv_subnetbcast = subnet | ~ mask;
#line 230
    strlcpy(v->uv_name, (char const   *)(ifr.ifr_ifrn.ifrn_name), (size_t )16);
    }
#line 232
    if ((int )flags & 16) {
      {
#line 233
      v->uv_flags |= 1064960U;
#line 234
      tmp___15 = ioctl(udp_socket, 35095UL, (char *)(& ifr));
      }
#line 234
      if (tmp___15 < 0) {
        {
#line 235
        tmp___14 = __errno_location();
#line 235
        logit(3, *tmp___14, "ioctl SIOCGIFDSTADDR for %s", v->uv_name);
        }
      } else {
#line 237
        v->uv_rmt_addr = ((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_dstaddr))->sin_addr.s_addr;
      }
    }
    {
#line 246
    memset((void *)(& ifridx), 0, sizeof(ifridx));
#line 247
    strlcpy(ifridx.ifr_ifrn.ifrn_name, (char const   *)(v->uv_name), (size_t )16);
#line 248
    tmp___17 = ioctl(udp_socket, 35123UL, (char *)(& ifridx));
    }
#line 248
    if (tmp___17 < 0) {
      {
#line 249
      tmp___16 = __errno_location();
#line 249
      logit(3, *tmp___16, "ioctl SIOGIFINDEX for %s", ifridx.ifr_ifrn.ifrn_name);
      }
#line 252
      return;
    }
#line 254
    v->uv_ifindex = ifridx.ifr_ifru.ifru_ivalue;
#line 256
    if ((int )flags & 16) {
      {
#line 257
      tmp___18 = inet_fmt(v->uv_rmt_addr, s2, sizeof(s2));
#line 257
      tmp___19 = inet_fmt(addr, s1, sizeof(s1));
#line 257
      logit(6, 0, "Installing %s (%s -> %s) as vif #%u-%d - rate=%d", v->uv_name,
            tmp___19, tmp___18, (int )numvifs, v->uv_ifindex, v->uv_rate_limit);
      }
    } else {
      {
#line 261
      tmp___20 = netname(subnet, mask);
#line 261
      tmp___21 = inet_fmt(addr, s1, sizeof(s1));
#line 261
      logit(6, 0, "Installing %s (%s on subnet %s) as vif #%u-%d - rate=%d", v->uv_name,
            tmp___21, tmp___20, (int )numvifs, v->uv_ifindex, v->uv_rate_limit);
      }
    }
#line 277
    numvifs = (vifi_t )((int )numvifs + 1);
#line 283
    if (! ((int )flags & 1)) {
#line 284
      v->uv_flags |= 256U;
#line 285
      vifs_down = 1;
    }
    __Cont: /* CIL Label */ 
#line 105
    ifrp = (struct ifreq *)((char *)ifrp + n);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 314 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
static int wordToOption(char *word ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 316
  tmp = strcmp((char const   *)word, "");
  }
#line 316
  if (tmp == 0) {
#line 317
    return (1);
  }
  {
#line 318
  tmp___0 = strcmp((char const   *)word, "phyint");
  }
#line 318
  if (tmp___0 == 0) {
#line 319
    return (2);
  }
  {
#line 320
  tmp___1 = strcmp((char const   *)word, "cand_rp");
  }
#line 320
  if (tmp___1 == 0) {
#line 321
    return (3);
  }
  {
#line 322
  tmp___2 = strcmp((char const   *)word, "rp_address");
  }
#line 322
  if (tmp___2 == 0) {
#line 323
    return (64);
  }
  {
#line 324
  tmp___3 = strcmp((char const   *)word, "group_prefix");
  }
#line 324
  if (tmp___3 == 0) {
#line 325
    return (4);
  }
  {
#line 326
  tmp___4 = strcmp((char const   *)word, "cand_bootstrap_router");
  }
#line 326
  if (tmp___4 == 0) {
#line 327
    return (5);
  }
  {
#line 328
  tmp___5 = strcmp((char const   *)word, "switch_register_threshold");
  }
#line 328
  if (tmp___5 == 0) {
#line 329
    return (6);
  }
  {
#line 330
  tmp___6 = strcmp((char const   *)word, "switch_data_threshold");
  }
#line 330
  if (tmp___6 == 0) {
#line 331
    return (7);
  }
  {
#line 332
  tmp___7 = strcmp((char const   *)word, "default_source_metric");
  }
#line 332
  if (tmp___7 == 0) {
#line 333
    return (8);
  }
  {
#line 334
  tmp___8 = strcmp((char const   *)word, "default_source_preference");
  }
#line 334
  if (tmp___8 == 0) {
#line 335
    return (9);
  }
  {
#line 336
  tmp___9 = strcmp((char const   *)word, "altnet");
  }
#line 336
  if (tmp___9 == 0) {
#line 337
    return (10);
  }
  {
#line 338
  tmp___10 = strcmp((char const   *)word, "masklen");
  }
#line 338
  if (tmp___10 == 0) {
#line 339
    return (11);
  }
  {
#line 340
  tmp___11 = strcmp((char const   *)word, "scoped");
  }
#line 340
  if (tmp___11 == 0) {
#line 341
    return (12);
  }
#line 343
  return (-1);
}
}
#line 359 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
static int parse_phyint(char *s ) 
{ 
  char *w ;
  char c ;
  u_int32 local ;
  u_int32 altnet_addr ;
  u_int32 scoped_addr ;
  vifi_t vifi ;
  struct uvif *v ;
  u_int n ;
  u_int altnet_masklen ;
  u_int scoped_masklen ;
  struct phaddr *ph ;
  struct vif_acl *v_acl ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  uint32_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;

  {
  {
#line 369
  w = next_word(& s);
#line 369
  tmp = strcmp((char const   *)w, "");
  }
#line 369
  if (tmp == 0) {
    {
#line 370
    logit(4, 0, "Missing phyint address in %s", configfilename);
    }
#line 371
    return (0);
  }
  {
#line 373
  local = ifname2addr(w);
  }
#line 374
  if (! local) {
    {
#line 375
    local = inet_parse(w, 4);
#line 376
    tmp___0 = inet_valid_host(local);
    }
#line 376
    if (! tmp___0) {
      {
#line 377
      logit(4, 0, "Invalid phyint address \'%s\' in %s", w, configfilename);
      }
#line 379
      return (0);
    }
  }
#line 382
  vifi = (vifi_t )0;
#line 382
  v = uvifs;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! ((int )vifi < (int )numvifs)) {
#line 382
      goto while_break;
    }
#line 383
    if ((int )vifi == (int )numvifs) {
      {
#line 384
      tmp___1 = inet_fmt(local, s1, sizeof(s1));
#line 384
      logit(4, 0, "phyint %s in %s is not a configured interface", tmp___1, configfilename);
      }
#line 386
      return (0);
    }
#line 389
    if (local != v->uv_lcl_addr) {
#line 390
      goto __Cont;
    }
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 392
      w = next_word(& s);
#line 392
      tmp___45 = strcmp((char const   *)w, "");
      }
#line 392
      if (tmp___45 == 0) {
#line 392
        goto while_break___0;
      }
      {
#line 393
      tmp___2 = strcmp((char const   *)w, "disable");
      }
#line 393
      if (tmp___2 == 0) {
#line 394
        v->uv_flags |= 512U;
#line 395
        goto while_continue___0;
      }
      {
#line 398
      tmp___3 = strcmp((char const   *)w, "enable");
      }
#line 398
      if (tmp___3 == 0) {
#line 399
        v->uv_flags &= 4294966783U;
#line 400
        goto while_continue___0;
      }
      {
#line 403
      tmp___15 = strcmp((char const   *)w, "altnet");
      }
#line 403
      if (tmp___15 == 0) {
        {
#line 404
        w = next_word(& s);
#line 404
        tmp___5 = strcmp((char const   *)w, "");
        }
#line 404
        if (tmp___5 == 0) {
          {
#line 405
          tmp___4 = inet_fmt(local, s1, sizeof(s1));
#line 405
          logit(4, 0, "Missing ALTNET for phyint %s in %s", tmp___4, configfilename);
          }
#line 407
          goto while_continue___0;
        }
        {
#line 409
        altnet_addr = ifname2addr(w);
        }
#line 410
        if (! altnet_addr) {
          {
#line 411
          altnet_addr = inet_parse(w, 4);
#line 412
          tmp___6 = inet_valid_host(altnet_addr);
          }
#line 412
          if (! tmp___6) {
            {
#line 413
            logit(4, 0, "Invalid altnet address \'%s\' in %s", w, configfilename);
            }
#line 414
            return (0);
          }
        }
        {
#line 417
        w = next_word(& s);
#line 417
        tmp___11 = strcmp((char const   *)w, "masklen");
        }
#line 417
        if (tmp___11 == 0) {
          {
#line 418
          w = next_word(& s);
#line 418
          tmp___8 = strcmp((char const   *)w, "");
          }
#line 418
          if (tmp___8 == 0) {
            {
#line 419
            tmp___7 = inet_fmt(local, s1, sizeof(s1));
#line 419
            logit(4, 0, "Missing ALTNET masklen for phyint %s in %s", tmp___7, configfilename);
            }
#line 421
            goto while_continue___0;
          }
          {
#line 423
          tmp___10 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                            & altnet_masklen);
          }
#line 423
          if (tmp___10 != 1) {
            {
#line 424
            tmp___9 = inet_fmt(local, s1, sizeof(s1));
#line 424
            logit(4, 0, "Invalid altnet masklen \'%s\' for phyint %s in %s", w, tmp___9,
                  configfilename);
            }
#line 426
            goto while_continue___0;
          }
        }
        {
#line 429
        tmp___12 = calloc((size_t )1, sizeof(struct phaddr ));
#line 429
        ph = (struct phaddr *)tmp___12;
        }
#line 430
        if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 431
          return (0);
        }
#line 432
        if (altnet_masklen) {
          {
#line 433
          ph->pa_subnetmask = htonl((uint32_t )(~ ((1 << (32U - altnet_masklen)) - 1)));
          }
        } else {
#line 435
          ph->pa_subnetmask = v->uv_subnetmask;
        }
#line 437
        ph->pa_subnet = altnet_addr & ph->pa_subnetmask;
#line 438
        ph->pa_subnetbcast = ph->pa_subnet | ~ ph->pa_subnetmask;
#line 439
        if (altnet_addr & ~ ph->pa_subnetmask) {
          {
#line 440
          tmp___13 = inet_fmt(altnet_addr, s1, sizeof(s1));
#line 440
          logit(4, 0, "Extra subnet %s/%d has host bits set", tmp___13, altnet_masklen);
          }
        }
        {
#line 442
        ph->pa_next = v->uv_addrs;
#line 443
        v->uv_addrs = ph;
#line 444
        tmp___14 = inet_fmt(altnet_addr, s1, sizeof(s1));
#line 444
        logit(7, 0, "ALTNET: %s/%d", tmp___14, altnet_masklen);
        }
      }
      {
#line 449
      tmp___27 = strcmp((char const   *)w, "scoped");
      }
#line 449
      if (tmp___27 == 0) {
        {
#line 450
        w = next_word(& s);
#line 450
        tmp___17 = strcmp((char const   *)w, "");
        }
#line 450
        if (tmp___17 == 0) {
          {
#line 451
          tmp___16 = inet_fmt(local, s1, sizeof(s1));
#line 451
          logit(4, 0, "Missing SCOPED for phyint %s in %s", tmp___16, configfilename);
          }
#line 453
          goto while_continue___0;
        }
        {
#line 455
        scoped_addr = ifname2addr(w);
        }
#line 456
        if (! scoped_addr) {
          {
#line 457
          scoped_addr = inet_parse(w, 4);
#line 458
          tmp___18 = ntohl(scoped_addr);
          }
#line 458
          if (! ((tmp___18 & 4026531840U) == 3758096384U)) {
            {
#line 459
            logit(4, 0, "Invalid scoped address \'%s\' in %s", w, configfilename);
            }
#line 460
            return (0);
          }
        }
        {
#line 463
        w = next_word(& s);
#line 463
        tmp___23 = strcmp((char const   *)w, "masklen");
        }
#line 463
        if (tmp___23 == 0) {
          {
#line 464
          w = next_word(& s);
#line 464
          tmp___20 = strcmp((char const   *)w, "");
          }
#line 464
          if (tmp___20 == 0) {
            {
#line 465
            tmp___19 = inet_fmt(local, s1, sizeof(s1));
#line 465
            logit(4, 0, "Missing SCOPED masklen for phyint %s in %s", tmp___19, configfilename);
            }
#line 467
            goto while_continue___0;
          }
          {
#line 469
          tmp___22 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                            & scoped_masklen);
          }
#line 469
          if (tmp___22 != 1) {
            {
#line 470
            tmp___21 = inet_fmt(local, s1, sizeof(s1));
#line 470
            logit(4, 0, "Invalid scoped masklen \'%s\' for phyint %s in %s", w, tmp___21,
                  configfilename);
            }
#line 472
            goto while_continue___0;
          }
        }
        {
#line 476
        tmp___24 = calloc((size_t )1, sizeof(struct vif_acl ));
#line 476
        v_acl = (struct vif_acl *)tmp___24;
        }
#line 477
        if ((unsigned long )v_acl == (unsigned long )((void *)0)) {
#line 478
          return (0);
        }
        {
#line 479
        v_acl->acl_mask = htonl((uint32_t )(~ ((1 << (32U - scoped_masklen)) - 1)));
#line 480
        v_acl->acl_addr = scoped_addr & v_acl->acl_mask;
        }
#line 481
        if (scoped_addr & ~ v_acl->acl_mask) {
          {
#line 482
          tmp___25 = inet_fmt(scoped_addr, s1, sizeof(s1));
#line 482
          logit(4, 0, "Boundary spec %s/%d has host bits set", tmp___25, scoped_masklen);
          }
        }
        {
#line 484
        v_acl->acl_next = v->uv_acl;
#line 485
        v->uv_acl = v_acl;
#line 486
        tmp___26 = inet_fmt(v_acl->acl_addr, s1, sizeof(s1));
#line 486
        logit(7, 0, "SCOPED %s/%x", tmp___26, v_acl->acl_mask);
        }
      }
      {
#line 490
      tmp___32 = strcmp((char const   *)w, "threshold");
      }
#line 490
      if (tmp___32 == 0) {
        {
#line 491
        w = next_word(& s);
#line 491
        tmp___29 = strcmp((char const   *)w, "");
        }
#line 491
        if (tmp___29 == 0) {
          {
#line 492
          tmp___28 = inet_fmt(local, s1, sizeof(s1));
#line 492
          logit(4, 0, "Missing threshold for phyint %s in %s", tmp___28, configfilename);
          }
#line 494
          goto while_continue___0;
        }
        {
#line 496
        tmp___31 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u%c",
                          & n, & c);
        }
#line 496
        if (tmp___31 != 1) {
          {
#line 497
          tmp___30 = inet_fmt(local, s1, sizeof(s1));
#line 497
          logit(4, 0, "Invalid threshold \'%s\' for phyint %s in %s", w, tmp___30,
                configfilename);
          }
#line 499
          goto while_continue___0;
        } else
#line 496
        if (n < 1U) {
          {
#line 497
          tmp___30 = inet_fmt(local, s1, sizeof(s1));
#line 497
          logit(4, 0, "Invalid threshold \'%s\' for phyint %s in %s", w, tmp___30,
                configfilename);
          }
#line 499
          goto while_continue___0;
        } else
#line 496
        if (n > 255U) {
          {
#line 497
          tmp___30 = inet_fmt(local, s1, sizeof(s1));
#line 497
          logit(4, 0, "Invalid threshold \'%s\' for phyint %s in %s", w, tmp___30,
                configfilename);
          }
#line 499
          goto while_continue___0;
        }
#line 501
        v->uv_threshold = (u_char )n;
#line 502
        goto while_continue___0;
      }
      {
#line 504
      tmp___38 = strcmp((char const   *)w, "preference");
      }
#line 504
      if (tmp___38 == 0) {
        {
#line 505
        w = next_word(& s);
#line 505
        tmp___34 = strcmp((char const   *)w, "");
        }
#line 505
        if (tmp___34 == 0) {
          {
#line 506
          tmp___33 = inet_fmt(local, s1, sizeof(s1));
#line 506
          logit(4, 0, "Missing preference for phyint %s in %s", tmp___33, configfilename);
          }
#line 508
          goto while_continue___0;
        }
        {
#line 510
        tmp___36 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u%c",
                          & n, & c);
        }
#line 510
        if (tmp___36 != 1) {
          {
#line 511
          tmp___35 = inet_fmt(local, s1, sizeof(s1));
#line 511
          logit(4, 0, "Invalid preference \'%s\' for phyint %s in %s", w, tmp___35,
                configfilename);
          }
#line 514
          goto while_continue___0;
        } else
#line 510
        if (n < 1U) {
          {
#line 511
          tmp___35 = inet_fmt(local, s1, sizeof(s1));
#line 511
          logit(4, 0, "Invalid preference \'%s\' for phyint %s in %s", w, tmp___35,
                configfilename);
          }
#line 514
          goto while_continue___0;
        } else
#line 510
        if (n > 255U) {
          {
#line 511
          tmp___35 = inet_fmt(local, s1, sizeof(s1));
#line 511
          logit(4, 0, "Invalid preference \'%s\' for phyint %s in %s", w, tmp___35,
                configfilename);
          }
#line 514
          goto while_continue___0;
        }
#line 516
        if (debug) {
#line 516
          if (debug & 262144UL) {
            {
#line 517
            tmp___37 = inet_fmt(local, s1, sizeof(s1));
#line 517
            logit(7, 0, "Config setting default local preference on %s to %d.", tmp___37,
                  n);
            }
          }
        }
#line 519
        v->uv_local_pref = (int )n;
#line 520
        goto while_continue___0;
      }
      {
#line 522
      tmp___44 = strcmp((char const   *)w, "metric");
      }
#line 522
      if (tmp___44 == 0) {
        {
#line 523
        w = next_word(& s);
#line 523
        tmp___40 = strcmp((char const   *)w, "");
        }
#line 523
        if (tmp___40 == 0) {
          {
#line 524
          tmp___39 = inet_fmt(local, s1, sizeof(s1));
#line 524
          logit(4, 0, "Missing metric for phyint %s in %s", tmp___39, configfilename);
          }
#line 526
          goto while_continue___0;
        }
        {
#line 528
        tmp___42 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u%c",
                          & n, & c);
        }
#line 528
        if (tmp___42 != 1) {
          {
#line 529
          tmp___41 = inet_fmt(local, s1, sizeof(s1));
#line 529
          logit(4, 0, "Invalid metric \'%s\' for phyint %s in %s", w, tmp___41, configfilename);
          }
#line 532
          goto while_continue___0;
        } else
#line 528
        if (n < 1U) {
          {
#line 529
          tmp___41 = inet_fmt(local, s1, sizeof(s1));
#line 529
          logit(4, 0, "Invalid metric \'%s\' for phyint %s in %s", w, tmp___41, configfilename);
          }
#line 532
          goto while_continue___0;
        } else
#line 528
        if (n > 1024U) {
          {
#line 529
          tmp___41 = inet_fmt(local, s1, sizeof(s1));
#line 529
          logit(4, 0, "Invalid metric \'%s\' for phyint %s in %s", w, tmp___41, configfilename);
          }
#line 532
          goto while_continue___0;
        }
#line 534
        if (debug) {
#line 534
          if (debug & 262144UL) {
            {
#line 535
            tmp___43 = inet_fmt(local, s1, sizeof(s1));
#line 535
            logit(7, 0, "Config setting default local metric on %s to %d.", tmp___43,
                  n);
            }
          }
        }
#line 538
        v->uv_local_metric = (int )n;
#line 539
        goto while_continue___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 542
    goto while_break;
    __Cont: /* CIL Label */ 
#line 382
    vifi = (vifi_t )((int )vifi + 1);
#line 382
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return (1);
}
}
#line 556 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parse_candidateRP(char *s ) 
{ 
  u_int time___0 ;
  u_int priority ;
  char *w ;
  u_int32 local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  vifi_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 558
  time___0 = (u_int )60;
#line 559
  priority = (u_int )0;
#line 561
  local = (u_int32 )0;
#line 563
  cand_rp_flag = (u_int8 )0;
#line 564
  my_cand_rp_adv_period = (u_int16 )60;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 565
    w = next_word(& s);
#line 565
    tmp___7 = strcmp((char const   *)w, "");
    }
#line 565
    if (tmp___7 == 0) {
#line 565
      goto while_break;
    }
    {
#line 566
    tmp___1 = strcmp((char const   *)w, "priority");
    }
#line 566
    if (tmp___1 == 0) {
      {
#line 567
      w = next_word(& s);
#line 567
      tmp = strcmp((char const   *)w, "");
      }
#line 567
      if (tmp == 0) {
        {
#line 568
        logit(4, 0, "Missing priority; set to default %u (0 is highest)", 0);
#line 570
        priority = (u_int )0;
        }
#line 571
        goto while_continue;
      }
      {
#line 573
      tmp___0 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                       & priority);
      }
#line 573
      if (tmp___0 != 1) {
        {
#line 574
        logit(4, 0, "Invalid priority %s; set to default %u (0 is highest)", 0);
#line 576
        priority = (u_int )0;
        }
      }
#line 578
      goto while_continue;
    }
    {
#line 580
    tmp___4 = strcmp((char const   *)w, "time");
    }
#line 580
    if (tmp___4 == 0) {
      {
#line 581
      w = next_word(& s);
#line 581
      tmp___2 = strcmp((char const   *)w, "");
      }
#line 581
      if (tmp___2 == 0) {
        {
#line 582
        logit(4, 0, "Missing cand_rp_adv_period value; set to default %u", 60);
#line 584
        time___0 = (u_int )60;
        }
#line 585
        goto while_continue;
      }
      {
#line 587
      tmp___3 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                       & time___0);
      }
#line 587
      if (tmp___3 != 1) {
        {
#line 588
        logit(4, 0, "Invalid cand_rp_adv_period value; set to default %u", 60);
#line 590
        time___0 = (u_int )60;
        }
#line 591
        goto while_continue;
      }
#line 593
      my_cand_rp_adv_period = (u_int16 )(~ 0);
#line 593
      if (time___0 > (u_int )my_cand_rp_adv_period) {
#line 594
        time___0 = (u_int )my_cand_rp_adv_period;
      }
#line 596
      if (time___0 < 10U) {
#line 597
        time___0 = (u_int )10;
      }
#line 602
      my_cand_rp_adv_period = (u_int16 )time___0;
#line 603
      goto while_continue;
    }
    {
#line 606
    local = inet_parse(w, 4);
#line 607
    tmp___6 = inet_valid_host(local);
    }
#line 607
    if (tmp___6) {
      {
#line 611
      tmp___5 = local_address(local);
      }
#line 611
      if ((int )tmp___5 == 32) {
        {
#line 612
        local = max_local_address();
#line 613
        logit(4, 0, "Cand-RP address is not local \'%s\' in %s. Will use the largest enabled local address.",
              w, configfilename);
        }
      }
    } else {
      {
#line 608
      local = max_local_address();
#line 609
      logit(4, 0, "Invalid Cand-RP address provided \'%s\' in %s. Will use the largest enabled local address.",
            w, configfilename);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  if (local == 0U) {
    {
#line 620
    local = max_local_address();
    }
  }
  {
#line 623
  my_cand_rp_address = local;
#line 624
  my_cand_rp_priority = (u_int8 )priority;
#line 625
  my_cand_rp_adv_period = (u_int16 )time___0;
#line 626
  cand_rp_flag = (u_int8 )1;
#line 628
  tmp___8 = inet_fmt(local, s1, sizeof(s1));
#line 628
  logit(6, 0, "Local Cand-RP address is %s", tmp___8);
#line 629
  logit(6, 0, "Local Cand-RP priority is %u", priority);
#line 630
  logit(6, 0, "Local Cand-RP advertisement period is %u sec.", time___0);
  }
#line 632
  return (1);
}
}
#line 643 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parse_group_prefix(char *s ) 
{ 
  char *w ;
  u_int32 group_addr ;
  u_int32 masklen ;
  int tmp ;
  char *tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int32 mask ;
  uint32_t tmp___4 ;
  u_int8 *tmp___5 ;
  u_int8 *tmp___6 ;
  u_int8 *tmp___7 ;
  u_int8 *tmp___8 ;
  register u_int32 Xv ;
  u_int8 *tmp___9 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  u_int8 *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 649
  w = next_word(& s);
#line 650
  tmp = strcmp((char const   *)w, "");
  }
#line 650
  if (tmp == 0) {
    {
#line 651
    logit(4, 0, "Configuration error for \'group_prefix\' in %s: no group_addr. Ignoring...",
          configfilename);
    }
#line 652
    return (0);
  }
  {
#line 654
  group_addr = inet_parse(w, 4);
#line 655
  tmp___1 = ntohl(group_addr);
  }
#line 655
  if (! ((tmp___1 & 4026531840U) == 3758096384U)) {
    {
#line 656
    tmp___0 = inet_fmt(group_addr, s1, sizeof(s1));
#line 656
    logit(4, 0, "Config error for \'group_prefix\' in %s: %s is not a mcast addr. Ignoring...",
          configfilename, tmp___0);
    }
#line 658
    return (0);
  }
#line 666
  if ((int )*(cand_rp_adv_message.prefix_cnt_ptr) == 255) {
    {
#line 667
    logit(4, 0, "Too many group_prefix configured. Truncating...");
    }
#line 668
    return (0);
  }
  {
#line 671
  w = next_word(& s);
#line 671
  tmp___3 = strcmp((char const   *)w, "masklen");
  }
#line 671
  if (tmp___3 == 0) {
    {
#line 672
    w = next_word(& s);
#line 673
    tmp___2 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                     & masklen);
    }
#line 673
    if (tmp___2 == 1) {
#line 674
      if ((unsigned long )masklen > sizeof(group_addr) * 8UL) {
#line 675
        masklen = (u_int32 )(sizeof(group_addr) * 8UL);
      } else
#line 677
      if (masklen < 4U) {
#line 678
        masklen = (u_int32 )4;
      }
    } else {
#line 681
      masklen = (u_int32 )16;
    }
  } else {
#line 684
    masklen = (u_int32 )16;
  }
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 686
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 686
      if ((u_int8 )masklen) {
        {
#line 686
        tmp___4 = htonl((uint32_t )(-1 << ((sizeof(mask) << 3) - (unsigned long )((u_int8 )masklen))));
#line 686
        mask = tmp___4;
        }
      } else {
#line 686
        mask = (u_int32 )0;
      }
#line 686
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 686
    tmp___5 = cand_rp_adv_message.insert_data_ptr;
#line 686
    (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
    *tmp___5 = (u_int8 )1;
#line 686
    tmp___6 = cand_rp_adv_message.insert_data_ptr;
#line 686
    (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
    *tmp___6 = (u_int8 )0;
#line 686
    tmp___7 = cand_rp_adv_message.insert_data_ptr;
#line 686
    (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
    *tmp___7 = (u_int8 )0;
#line 686
    tmp___8 = cand_rp_adv_message.insert_data_ptr;
#line 686
    (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
    *tmp___8 = (u_int8 )masklen;
    {
#line 686
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 686
      Xv = group_addr & mask;
#line 686
      tmp___9 = cand_rp_adv_message.insert_data_ptr;
#line 686
      (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
      *tmp___9 = (u_int8 )Xv;
#line 686
      tmp___10 = cand_rp_adv_message.insert_data_ptr;
#line 686
      (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
      *tmp___10 = (u_int8 )(Xv >> 8);
#line 686
      tmp___11 = cand_rp_adv_message.insert_data_ptr;
#line 686
      (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
      *tmp___11 = (u_int8 )(Xv >> 16);
#line 686
      tmp___12 = cand_rp_adv_message.insert_data_ptr;
#line 686
      (cand_rp_adv_message.insert_data_ptr) ++;
#line 686
      *tmp___12 = (u_int8 )(Xv >> 24);
#line 686
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 686
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 688
  *(cand_rp_adv_message.prefix_cnt_ptr) = (u_int8 )((int )*(cand_rp_adv_message.prefix_cnt_ptr) + 1);
#line 690
  tmp___13 = inet_fmt(group_addr, s1, sizeof(s1));
#line 690
  logit(6, 0, "Adding prefix %s/%d", tmp___13, masklen);
  }
#line 692
  return (1);
}
}
#line 704 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parseBSR(char *s ) 
{ 
  char *w ;
  u_int32 local ;
  u_int32 priority ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  vifi_t tmp___3 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  char *tmp___6 ;

  {
#line 707
  local = (u_int32 )0;
#line 708
  priority = (u_int32 )0;
#line 710
  cand_bsr_flag = (u_int8 )0;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 711
    w = next_word(& s);
#line 711
    tmp___4 = strcmp((char const   *)w, "");
    }
#line 711
    if (tmp___4 == 0) {
#line 711
      goto while_break;
    }
    {
#line 712
    tmp___1 = strcmp((char const   *)w, "priority");
    }
#line 712
    if (tmp___1 == 0) {
      {
#line 713
      w = next_word(& s);
#line 713
      tmp = strcmp((char const   *)w, "");
      }
#line 713
      if (tmp == 0) {
        {
#line 714
        logit(4, 0, "Missing priority; set to default %u (0 is lowest)\n", 0);
#line 716
        priority = (u_int32 )0;
        }
#line 717
        goto while_continue;
      }
      {
#line 719
      tmp___0 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                       & priority);
      }
#line 719
      if (tmp___0 != 1) {
        {
#line 720
        logit(4, 0, "Invalid priority %s; set to default %u (0 is lowest)", 0);
#line 722
        priority = (u_int32 )0;
        }
#line 723
        goto while_continue;
      }
#line 725
      my_bsr_priority = (u_int8 )(~ 0);
#line 725
      if (priority > (u_int32 )my_bsr_priority) {
#line 726
        priority = (u_int32 )my_bsr_priority;
      }
#line 727
      my_bsr_priority = (u_int8 )priority;
#line 728
      goto while_continue;
    }
    {
#line 732
    local = inet_parse(w, 4);
#line 733
    tmp___2 = inet_valid_host(local);
    }
#line 733
    if (! tmp___2) {
      {
#line 734
      local = max_local_address();
#line 735
      logit(4, 0, "Invalid BSR address provided \'%s\' in %s. Will use the largest enabled local address.",
            w, configfilename);
      }
#line 737
      goto while_continue;
    }
    {
#line 739
    tmp___3 = local_address(local);
    }
#line 739
    if ((int )tmp___3 == 32) {
      {
#line 740
      local = max_local_address();
#line 741
      logit(4, 0, "Cand-BSR address is not local \'%s\' in %s. Will use the largest enabled local address.",
            w, configfilename);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  if (local == 0U) {
    {
#line 748
    local = max_local_address();
    }
  }
#line 749
  my_bsr_address = local;
#line 750
  my_bsr_priority = (u_int8 )priority;
  {
#line 751
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 751
    tmp___5 = htonl((uint32_t )(-1 << ((sizeof(my_bsr_hash_mask) << 3) - 30UL)));
#line 751
    my_bsr_hash_mask = tmp___5;
    }
#line 751
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 752
  cand_bsr_flag = (u_int8 )1;
#line 753
  tmp___6 = inet_fmt(local, s1, sizeof(s1));
#line 753
  logit(6, 0, "Local Cand-BSR address is %s", tmp___6);
#line 754
  logit(6, 0, "Local Cand-BSR priority is %u", priority);
  }
#line 756
  return (1);
}
}
#line 775 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parse_rp_address(char *s ) 
{ 
  char *w ;
  u_int32 local ;
  u_int32 group_addr ;
  uint32_t tmp ;
  u_int32 masklen ;
  u_int priority ;
  struct rp_hold *rph ;
  int tmp___0 ;
  char *tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 778
  local = (u_int32 )16777215;
#line 779
  tmp = htonl(3758096384U);
#line 779
  group_addr = tmp;
#line 780
  masklen = (u_int32 )16;
#line 781
  priority = (u_int )0;
#line 785
  w = next_word(& s);
#line 786
  tmp___0 = strcmp((char const   *)w, "");
  }
#line 786
  if (tmp___0 == 0) {
    {
#line 787
    logit(4, 0, "\'rp_address\' in %s: no <rp-addr> - ignoring", configfilename);
    }
#line 788
    return (0);
  }
  {
#line 791
  local = inet_parse(w, 4);
  }
#line 792
  if (local == 16777215U) {
    {
#line 793
    logit(4, 0, "\'rp_address\' in %s: invalid <rp-addr> provided: \'%s\'", configfilename,
          w);
    }
#line 794
    return (0);
  }
  {
#line 798
  w = next_word(& s);
#line 799
  tmp___8 = strcmp((char const   *)w, "");
  }
#line 799
  if (tmp___8 == 0) {
    {
#line 843
    group_addr = htonl(3758096384U);
#line 844
    masklen = (u_int32 )4;
#line 845
    priority = (u_int )1;
    }
  } else {
    {
#line 800
    group_addr = inet_parse(w, 4);
#line 801
    tmp___2 = ntohl(group_addr);
    }
#line 801
    if (! ((tmp___2 & 4026531840U) == 3758096384U)) {
      {
#line 802
      tmp___1 = inet_fmt(group_addr, s1, sizeof(s1));
#line 802
      logit(4, 0, "\'rp_address\' in %s: %s is not a multicast addr", configfilename,
            tmp___1);
      }
#line 803
      return (0);
    }
#line 806
    masklen = (u_int32 )16;
#line 807
    priority = (u_int )0;
    {
#line 810
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 810
      w = next_word(& s);
#line 810
      tmp___7 = strcmp((char const   *)w, "");
      }
#line 810
      if (tmp___7 == 0) {
#line 810
        goto while_break;
      }
      {
#line 811
      tmp___6 = strcmp((char const   *)w, "masklen");
      }
#line 811
      if (tmp___6 == 0) {
        {
#line 812
        w = next_word(& s);
#line 813
        tmp___3 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                         & masklen);
        }
#line 813
        if (tmp___3 == 1) {
#line 814
          if ((unsigned long )masklen > sizeof(group_addr) * 8UL) {
#line 815
            masklen = (u_int32 )(sizeof(group_addr) * 8UL);
          } else
#line 817
          if (masklen < 4U) {
            {
#line 818
            logit(4, 0, "\'rp_address\' in %s: %s is too small. set to %d.", configfilename,
                  w, 4);
#line 819
            masklen = (u_int32 )4;
            }
          }
        } else {
          {
#line 823
          logit(4, 0, "\'rp_address\' in %s: %s is invalid masklen. set to default(%d)",
                configfilename, w, 16);
#line 824
          masklen = (u_int32 )16;
          }
        }
      } else {
        {
#line 827
        tmp___5 = strcmp((char const   *)w, "priority");
        }
#line 827
        if (tmp___5 == 0) {
          {
#line 828
          w = next_word(& s);
#line 829
          tmp___4 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                           & priority);
          }
#line 829
          if (tmp___4 == 1) {
#line 830
            if (priority > 255U) {
              {
#line 831
              logit(4, 0, "\'rp_address\' in %s: %s is too big. set to %d.", configfilename,
                    w, 255);
#line 832
              priority = (u_int )255;
              }
            }
          } else {
            {
#line 836
            logit(4, 0, "\'rp_address\' in %s: %s is invalid priority. set to default(%d)",
                  configfilename, w, 0);
#line 837
            priority = (u_int )0;
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 849
  tmp___9 = calloc((size_t )1, sizeof(*rph));
#line 849
  rph = (struct rp_hold *)tmp___9;
  }
#line 850
  if (! rph) {
    {
#line 851
    logit(4, 0, "Ran out of memory in parse_rp_address()");
    }
#line 852
    return (0);
  }
  {
#line 854
  rph->address = local;
#line 855
  rph->group = group_addr;
#line 856
  rph->mask = htonl((uint32_t )(~ ((1 << (32U - masklen)) - 1)));
#line 857
  rph->priority = (u_int8 )priority;
#line 860
  rph->next = g_rp_hold;
#line 861
  g_rp_hold = rph;
#line 863
  tmp___10 = inet_fmt(group_addr, s2, sizeof(s2));
#line 863
  tmp___11 = inet_fmt(local, s1, sizeof(s1));
#line 863
  logit(6, 0, "Added static RP: %s, group %s/%d, prioriy %d", tmp___11, tmp___10,
        masklen, priority);
  }
#line 865
  return (1);
}
}
#line 881 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parse_reg_threshold(char *s ) 
{ 
  char *w ;
  u_int rate ;
  u_int interval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 887
  rate = (u_int )50000;
#line 888
  interval = (u_int )20;
#line 889
  pim_reg_rate_bytes = (rate * interval) / 10U;
#line 890
  pim_reg_rate_check_interval = interval;
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 892
    w = next_word(& s);
#line 892
    tmp___5 = strcmp((char const   *)w, "");
    }
#line 892
    if (tmp___5 == 0) {
#line 892
      goto while_break;
    }
    {
#line 893
    tmp___1 = strcmp((char const   *)w, "rate");
    }
#line 893
    if (tmp___1 == 0) {
      {
#line 895
      w = next_word(& s);
#line 895
      tmp = strcmp((char const   *)w, "");
      }
#line 895
      if (tmp == 0) {
        {
#line 896
        logit(4, 0, "Missing reg_rate value; set to default %u (bits/s)\n", 50000);
#line 898
        rate = (u_int )50000;
        }
#line 899
        goto while_continue;
      }
      {
#line 901
      tmp___0 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                       & rate);
      }
#line 901
      if (tmp___0 != 1) {
        {
#line 902
        logit(4, 0, "Invalid reg_rate value %s; set to default %u (bits/s)", w, 50000);
#line 904
        rate = (u_int )50000;
        }
      }
#line 906
      goto while_continue;
    }
    {
#line 908
    tmp___4 = strcmp((char const   *)w, "interval");
    }
#line 908
    if (tmp___4 == 0) {
      {
#line 909
      w = next_word(& s);
#line 909
      tmp___2 = strcmp((char const   *)w, "");
      }
#line 909
      if (tmp___2 == 0) {
        {
#line 910
        logit(4, 0, "Missing reg_rate interval; set to default %u seconds", 20);
#line 912
        interval = (u_int )20;
        }
#line 913
        goto while_continue;
      }
      {
#line 915
      tmp___3 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                       & interval);
      }
#line 915
      if (tmp___3 != 1) {
        {
#line 916
        logit(4, 0, "Invalid reg_rate interval %s; set to default %u seconds", w,
              20);
#line 918
        interval = (u_int )20;
        }
      }
#line 920
      goto while_continue;
    }
    {
#line 922
    logit(4, 0, "Invalid parameter %s; setting rate and interval to default", w);
#line 923
    rate = (u_int )50000;
#line 924
    interval = (u_int )20;
    }
#line 925
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  if (interval < 5U) {
    {
#line 929
    logit(4, 0, "reg_rate interval too short; set to default %u seconds", 20);
#line 931
    interval = (u_int )20;
    }
  }
  {
#line 934
  logit(6, 0, "reg_rate_limit is %u (bits/s)", rate);
#line 935
  logit(6, 0, "reg_rate_interval is %u (seconds)", interval);
#line 936
  pim_reg_rate_bytes = (rate * interval) / 10U;
#line 937
  pim_reg_rate_check_interval = interval;
  }
#line 939
  return (1);
}
}
#line 952 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parse_data_threshold(char *s ) 
{ 
  char *w ;
  u_int rate ;
  u_int interval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 958
  rate = (u_int )50000;
#line 959
  interval = (u_int )20;
#line 960
  pim_data_rate_bytes = (rate * interval) / 10U;
#line 961
  pim_data_rate_check_interval = interval;
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 963
    w = next_word(& s);
#line 963
    tmp___5 = strcmp((char const   *)w, "");
    }
#line 963
    if (tmp___5 == 0) {
#line 963
      goto while_break;
    }
    {
#line 964
    tmp___1 = strcmp((char const   *)w, "rate");
    }
#line 964
    if (tmp___1 == 0) {
      {
#line 965
      w = next_word(& s);
#line 965
      tmp = strcmp((char const   *)w, "");
      }
#line 965
      if (tmp == 0) {
        {
#line 966
        logit(4, 0, "Missing data_rate value; set to default %u (bits/s)\n", 50000);
#line 968
        rate = (u_int )50000;
        }
#line 969
        goto while_continue;
      }
      {
#line 971
      tmp___0 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                       & rate);
      }
#line 971
      if (tmp___0 != 1) {
        {
#line 972
        logit(4, 0, "Invalid data_rate value %s; set to default %u (bits/s)", w, 50000);
#line 974
        rate = (u_int )50000;
        }
      }
#line 976
      goto while_continue;
    }
    {
#line 978
    tmp___4 = strcmp((char const   *)w, "interval");
    }
#line 978
    if (tmp___4 == 0) {
      {
#line 979
      w = next_word(& s);
#line 979
      tmp___2 = strcmp((char const   *)w, "");
      }
#line 979
      if (tmp___2 == 0) {
        {
#line 980
        logit(4, 0, "Missing data_rate interval; set to default %u seconds", 20);
#line 982
        interval = (u_int )20;
        }
#line 983
        goto while_continue;
      }
      {
#line 985
      tmp___3 = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                       & interval);
      }
#line 985
      if (tmp___3 != 1) {
        {
#line 986
        logit(4, 0, "Invalid data_rate interval %s; set to default %u seconds", w,
              20);
#line 988
        interval = (u_int )20;
        }
      }
#line 990
      goto while_continue;
    }
    {
#line 992
    logit(4, 0, "Invalid parameter %s; setting rate and interval to default", w);
#line 993
    rate = (u_int )50000;
#line 994
    interval = (u_int )20;
    }
#line 995
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 998
  if (interval < 5U) {
    {
#line 999
    logit(4, 0, "data_rate interval too short; set to default %u seconds", 20);
#line 1001
    interval = (u_int )20;
    }
  }
  {
#line 1004
  logit(6, 0, "data_rate_limit is %u (bits/s)", rate);
#line 1005
  logit(6, 0, "data_rate_interval is %u (seconds)", interval);
#line 1006
  pim_data_rate_bytes = (rate * interval) / 10U;
#line 1007
  pim_data_rate_check_interval = interval;
  }
#line 1009
  return (1);
}
}
#line 1024 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parse_default_source_metric(char *s ) 
{ 
  char *w ;
  u_int value ;
  vifi_t vifi ;
  struct uvif *v ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1031
  value = (u_int )1024;
#line 1032
  w = next_word(& s);
#line 1032
  tmp___0 = strcmp((char const   *)w, "");
  }
#line 1032
  if (tmp___0 == 0) {
    {
#line 1033
    logit(4, 0, "Missing default source metric; set to default %u", 1024);
    }
  } else {
    {
#line 1035
    tmp = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                 & value);
    }
#line 1035
    if (tmp != 1) {
      {
#line 1036
      logit(4, 0, "Invalid default source metric; set to default %u", 1024);
#line 1038
      value = (u_int )1024;
      }
    }
  }
  {
#line 1040
  default_source_metric = value;
#line 1041
  logit(6, 0, "default_source_metric is %u", value);
#line 1043
  vifi = (vifi_t )0;
#line 1043
  v = uvifs;
  }
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    if (! ((int )vifi < 32)) {
#line 1043
      goto while_break;
    }
#line 1044
    v->uv_local_metric = (int )default_source_metric;
#line 1043
    vifi = (vifi_t )((int )vifi + 1);
#line 1043
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1046
  return (1);
}
}
#line 1061 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
int parse_default_source_preference(char *s ) 
{ 
  char *w ;
  u_int value ;
  vifi_t vifi ;
  struct uvif *v ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1068
  value = (u_int )1024;
#line 1069
  w = next_word(& s);
#line 1069
  tmp___0 = strcmp((char const   *)w, "");
  }
#line 1069
  if (tmp___0 == 0) {
    {
#line 1070
    logit(4, 0, "Missing default source preference; set to default %u", 1024);
    }
  } else {
    {
#line 1072
    tmp = sscanf((char const   */* __restrict  */)w, (char const   */* __restrict  */)"%u",
                 & value);
    }
#line 1072
    if (tmp != 1) {
      {
#line 1073
      logit(4, 0, "Invalid default source preference; set to default %u", 1024);
#line 1075
      value = (u_int )1024;
      }
    }
  }
  {
#line 1077
  default_source_preference = value;
#line 1078
  logit(6, 0, "default_source_preference is %u", value);
#line 1079
  vifi = (vifi_t )0;
#line 1079
  v = uvifs;
  }
  {
#line 1079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1079
    if (! ((int )vifi < 32)) {
#line 1079
      goto while_break;
    }
#line 1080
    v->uv_local_pref = (int )default_source_preference;
#line 1079
    vifi = (vifi_t )((int )vifi + 1);
#line 1079
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1082
  return (1);
}
}
#line 1086 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
void config_vifs_from_file(void) 
{ 
  FILE *f ;
  char linebuf[1024] ;
  char *w ;
  char *s ;
  struct ifconf ifc ;
  int option ;
  char ifbuf[8192] ;
  u_int8 *data_ptr ;
  int error_flag ;
  int line_num ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  u_int8 *tmp___7 ;
  register u_int16 Xv ;
  u_int8 *tmp___8 ;
  u_int8 *tmp___9 ;
  u_int8 *tmp___10 ;
  u_int8 *tmp___11 ;
  register u_int32 Xv___0 ;
  u_int8 *tmp___12 ;
  u_int8 *tmp___13 ;
  u_int8 *tmp___14 ;
  u_int8 *tmp___15 ;

  {
  {
#line 1098
  error_flag = 0;
#line 1099
  line_num = 0;
#line 1101
  f = fopen((char const   */* __restrict  */)configfilename, (char const   */* __restrict  */)"r");
  }
#line 1101
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1102
    tmp___0 = __errno_location();
    }
#line 1102
    if (*tmp___0 != 2) {
      {
#line 1103
      tmp = __errno_location();
#line 1103
      logit(4, *tmp, "Cannot open %s", configfilename);
      }
    }
#line 1104
    return;
  }
  {
#line 1108
  tmp___1 = calloc((size_t )1, (4UL + sizeof(pim_encod_uni_addr_t )) + 255UL * sizeof(pim_encod_grp_addr_t ));
#line 1108
  cand_rp_adv_message.buffer = (u_int8 *)tmp___1;
  }
#line 1111
  if (! cand_rp_adv_message.buffer) {
    {
#line 1112
    tmp___2 = __errno_location();
#line 1112
    logit(3, *tmp___2, "Ran out of memory in config_vifs_from_file()");
    }
  }
  {
#line 1114
  cand_rp_adv_message.prefix_cnt_ptr = cand_rp_adv_message.buffer;
#line 1118
  *(cand_rp_adv_message.prefix_cnt_ptr) = (u_int8 )0;
#line 1119
  cand_rp_adv_message.insert_data_ptr = cand_rp_adv_message.buffer;
#line 1121
  cand_rp_adv_message.insert_data_ptr += 10;
#line 1123
  ifc.ifc_ifcu.ifcu_buf = ifbuf;
#line 1124
  ifc.ifc_len = (int )sizeof(ifbuf);
#line 1125
  tmp___4 = ioctl(udp_socket, 35090UL, (char *)(& ifc));
  }
#line 1125
  if (tmp___4 < 0) {
    {
#line 1126
    tmp___3 = __errno_location();
#line 1126
    logit(3, *tmp___3, "ioctl SIOCGIFCONF");
    }
  }
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1128
    tmp___6 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)f);
    }
#line 1128
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 1128
      goto while_break;
    }
    {
#line 1129
    tmp___5 = strlen((char const   *)(linebuf));
    }
#line 1129
    if (tmp___5 >= 1023UL) {
      {
#line 1130
      logit(4, 0, "line length must be shorter than %d in %s:%d", 1024, configfilename,
            line_num);
#line 1132
      error_flag = 1;
      }
    } else {
#line 1134
      line_num ++;
    }
    {
#line 1137
    s = linebuf;
#line 1138
    w = next_word(& s);
#line 1139
    option = wordToOption(w);
    }
    {
#line 1142
    if (option == 1) {
#line 1142
      goto case_1;
    }
#line 1145
    if (option == 2) {
#line 1145
      goto case_2;
    }
#line 1148
    if (option == 3) {
#line 1148
      goto case_3;
    }
#line 1151
    if (option == 64) {
#line 1151
      goto case_64;
    }
#line 1154
    if (option == 4) {
#line 1154
      goto case_4;
    }
#line 1157
    if (option == 5) {
#line 1157
      goto case_5;
    }
#line 1160
    if (option == 6) {
#line 1160
      goto case_6;
    }
#line 1163
    if (option == 7) {
#line 1163
      goto case_7;
    }
#line 1166
    if (option == 8) {
#line 1166
      goto case_8;
    }
#line 1169
    if (option == 9) {
#line 1169
      goto case_9;
    }
#line 1172
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1143
    goto while_continue;
#line 1144
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1146
    parse_phyint(s);
    }
#line 1147
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1149
    parse_candidateRP(s);
    }
#line 1150
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 1152
    parse_rp_address(s);
    }
#line 1153
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1155
    parse_group_prefix(s);
    }
#line 1156
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1158
    parseBSR(s);
    }
#line 1159
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1161
    parse_reg_threshold(s);
    }
#line 1162
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1164
    parse_data_threshold(s);
    }
#line 1165
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1167
    parse_default_source_metric(s);
    }
#line 1168
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 1170
    parse_default_source_preference(s);
    }
#line 1171
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1173
    logit(4, 0, "unknown command \'%s\' in %s:%d", w, configfilename, line_num);
#line 1175
    error_flag = 1;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  if (error_flag) {
    {
#line 1183
    logit(3, 0, "Syntax Error in %s", configfilename);
    }
  }
#line 1186
  cand_rp_adv_message.message_size = (u_int16 )(cand_rp_adv_message.insert_data_ptr - cand_rp_adv_message.buffer);
#line 1187
  if ((int )cand_rp_flag != 0) {
#line 1189
    my_cand_rp_holdtime = (u_int16 )(2.5 * (double )my_cand_rp_adv_period);
#line 1191
    data_ptr = cand_rp_adv_message.buffer + 1;
#line 1192
    tmp___7 = data_ptr;
#line 1192
    data_ptr ++;
#line 1192
    *tmp___7 = my_cand_rp_priority;
    {
#line 1193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1193
      Xv = my_cand_rp_holdtime;
#line 1193
      tmp___8 = data_ptr;
#line 1193
      data_ptr ++;
#line 1193
      *tmp___8 = (u_int8 )((int )Xv >> 8);
#line 1193
      tmp___9 = data_ptr;
#line 1193
      data_ptr ++;
#line 1193
      *tmp___9 = (u_int8 )Xv;
#line 1193
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1194
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1194
      tmp___10 = data_ptr;
#line 1194
      data_ptr ++;
#line 1194
      *tmp___10 = (u_int8 )1;
#line 1194
      tmp___11 = data_ptr;
#line 1194
      data_ptr ++;
#line 1194
      *tmp___11 = (u_int8 )0;
      {
#line 1194
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1194
        Xv___0 = my_cand_rp_address;
#line 1194
        tmp___12 = data_ptr;
#line 1194
        data_ptr ++;
#line 1194
        *tmp___12 = (u_int8 )Xv___0;
#line 1194
        tmp___13 = data_ptr;
#line 1194
        data_ptr ++;
#line 1194
        *tmp___13 = (u_int8 )(Xv___0 >> 8);
#line 1194
        tmp___14 = data_ptr;
#line 1194
        data_ptr ++;
#line 1194
        *tmp___14 = (u_int8 )(Xv___0 >> 16);
#line 1194
        tmp___15 = data_ptr;
#line 1194
        data_ptr ++;
#line 1194
        *tmp___15 = (u_int8 )(Xv___0 >> 24);
#line 1194
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1194
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1197
  fclose(f);
  }
#line 1198
  return;
}
}
#line 1201 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
static u_int32 ifname2addr(char *s ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  int tmp ;

  {
#line 1206
  vifi = (vifi_t )0;
#line 1206
  v = uvifs;
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    if (! ((int )vifi < (int )numvifs)) {
#line 1206
      goto while_break;
    }
    {
#line 1207
    tmp = strcmp((char const   *)(v->uv_name), (char const   *)s);
    }
#line 1207
    if (! tmp) {
#line 1208
      return (v->uv_lcl_addr);
    }
#line 1206
    vifi = (vifi_t )((int )vifi + 1);
#line 1206
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1211
  return ((u_int32 )0);
}
}
#line 1214 "/home/wheatley/newnew/temp/pimd-2.1.8/config.c"
static char *next_word(char **s ) 
{ 
  char *w ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1218
  w = *s;
  {
#line 1219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1219
    if (! ((int )*w == 32)) {
#line 1219
      if (! ((int )*w == 9)) {
#line 1219
        goto while_break;
      }
    }
#line 1220
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  *s = w;
  {
#line 1223
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1226
    if ((int )*(*s) == 9) {
#line 1226
      goto case_9;
    }
#line 1226
    if ((int )*(*s) == 32) {
#line 1226
      goto case_9;
    }
#line 1231
    if ((int )*(*s) == 35) {
#line 1231
      goto case_35;
    }
#line 1231
    if ((int )*(*s) == 10) {
#line 1231
      goto case_35;
    }
#line 1234
    if ((int )*(*s) == 0) {
#line 1234
      goto case_0;
    }
#line 1236
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1227
    *(*s) = (char )'\000';
#line 1228
    (*s) ++;
#line 1229
    return (w);
    case_35: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1232
    *(*s) = (char )'\000';
#line 1233
    return (w);
    case_0: /* CIL Label */ 
#line 1235
    return (w);
    switch_default: /* CIL Label */ 
#line 1237
    if (((int )*(*s) & -128) == 0) {
      {
#line 1237
      tmp___0 = __ctype_b_loc();
      }
#line 1237
      if ((int const   )*(*tmp___0 + (int )*(*s)) & 256) {
        {
#line 1238
        tmp = tolower((int )*(*s));
#line 1238
        *(*s) = (char )tmp;
        }
      }
    }
#line 1239
    (*s) ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 346 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char s1[19]  ;
#line 347 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char s2[19]  ;
#line 348 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char s3[19]  ;
#line 349 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
char s4[19]  ;
#line 473
int inet_valid_mask(u_int32 mask ) ;
#line 31 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
int inet_valid_host(u_int32 naddr ) 
{ 
  u_int32 addr ;
  int tmp ;

  {
  {
#line 35
  addr = ntohl(naddr);
  }
#line 37
  if ((addr & 4026531840U) == 3758096384U) {
#line 37
    tmp = 0;
  } else
#line 37
  if ((addr & 4026531840U) == 4026531840U) {
#line 37
    tmp = 0;
  } else
#line 37
  if ((addr & 4278190080U) == 0U) {
#line 37
    tmp = 0;
  } else {
#line 37
    tmp = 1;
  }
#line 37
  return (tmp);
}
}
#line 47 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
int inet_valid_mask(u_int32 mask ) 
{ 


  {
#line 51
  if (~ (((mask & - mask) - 1U) | mask) != 0U) {
#line 53
    return (0);
  }
#line 56
  return (1);
}
}
#line 68 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
int inet_valid_subnet(u_int32 nsubnet , u_int32 nmask ) 
{ 
  register u_int32 subnet ;
  register u_int32 mask ;
  int tmp ;

  {
  {
#line 74
  subnet = ntohl(nsubnet);
#line 75
  mask = ntohl(nmask);
  }
#line 77
  if ((subnet & mask) != subnet) {
#line 78
    return (0);
  }
#line 80
  if (subnet == 0U) {
#line 81
    return (mask == 0U);
  }
#line 83
  if ((subnet & 2147483648U) == 0U) {
#line 84
    if (mask < 4278190080U) {
#line 86
      return (0);
    } else
#line 84
    if ((subnet & 4278190080U) == 2130706432U) {
#line 86
      return (0);
    } else
#line 84
    if ((subnet & 4278190080U) == 0U) {
#line 86
      return (0);
    }
  } else
#line 88
  if ((subnet & 4026531840U) == 3758096384U) {
#line 90
    return (0);
  } else
#line 88
  if ((subnet & 4026531840U) == 4026531840U) {
#line 90
    return (0);
  }
#line 92
  if (subnet & ~ mask) {
#line 94
    return (0);
  }
  {
#line 96
  tmp = inet_valid_mask(mask);
  }
#line 96
  if (! tmp) {
#line 98
    return (0);
  }
#line 101
  return (1);
}
}
#line 108 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
char *inet_fmt(u_int32 addr , char *s , size_t len ) 
{ 
  u_char *a ;

  {
  {
#line 112
  a = (u_char *)(& addr);
#line 113
  snprintf((char */* __restrict  */)s, len, (char const   */* __restrict  */)"%u.%u.%u.%u",
           (int )*(a + 0), (int )*(a + 1), (int )*(a + 2), (int )*(a + 3));
  }
#line 115
  return (s);
}
}
#line 125 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
u_int32 inet_parse(char *s , int n ) 
{ 
  u_int32 a ;
  u_int a0 ;
  u_int a1 ;
  u_int a2 ;
  u_int a3 ;
  int i ;
  char c ;

  {
  {
#line 130
  a = (u_int32 )0;
#line 131
  a0 = (u_int )0;
#line 131
  a1 = (u_int )0;
#line 131
  a2 = (u_int )0;
#line 131
  a3 = (u_int )0;
#line 135
  i = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%u.%u.%u.%u%c",
             & a0, & a1, & a2, & a3, & c);
  }
#line 136
  if (i < n) {
#line 137
    return (4294967295U);
  } else
#line 136
  if (i > 4) {
#line 137
    return (4294967295U);
  } else
#line 136
  if (a0 > 255U) {
#line 137
    return (4294967295U);
  } else
#line 136
  if (a1 > 255U) {
#line 137
    return (4294967295U);
  } else
#line 136
  if (a2 > 255U) {
#line 137
    return (4294967295U);
  } else
#line 136
  if (a3 > 255U) {
#line 137
    return (4294967295U);
  }
#line 139
  *((u_char *)(& a) + 0) = (u_char )a0;
#line 140
  *((u_char *)(& a) + 1) = (u_char )a1;
#line 141
  *((u_char *)(& a) + 2) = (u_char )a2;
#line 142
  *((u_char *)(& a) + 3) = (u_char )a3;
#line 144
  return (a);
}
}
#line 166 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
int inet_cksum(u_int16 *addr , u_int len ) 
{ 
  register int nleft ;
  register u_int16 *w ;
  u_int16 answer ;
  register int sum ;
  u_int16 *tmp ;

  {
#line 171
  nleft = (int )len;
#line 172
  w = addr;
#line 173
  answer = (u_int16 )0;
#line 174
  sum = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (nleft > 1)) {
#line 182
      goto while_break;
    }
#line 183
    tmp = w;
#line 183
    w ++;
#line 183
    sum += (int )*tmp;
#line 184
    nleft -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (nleft == 1) {
#line 189
    *((u_char *)(& answer)) = *((u_char *)w);
#line 190
    sum += (int )answer;
  }
#line 196
  sum = (sum >> 16) + (sum & 65535);
#line 197
  sum += sum >> 16;
#line 198
  answer = (u_int16 )(~ sum);
#line 199
  return ((int )answer);
}
}
#line 209 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
static char domain[65]  ;
#line 210
void trimdomain(char *cp ) ;
#line 210 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
static int first  =    1;
#line 205 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
void trimdomain(char *cp ) 
{ 
  char *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 213
  if (first) {
    {
#line 214
    first = 0;
#line 215
    tmp = gethostname(domain, (size_t )64);
    }
#line 215
    if (tmp == 0) {
      {
#line 215
      s = strchr((char const   *)(domain), '.');
      }
#line 215
      if (s) {
        {
#line 217
        strlcpy(domain, (char const   *)(s + 1), sizeof(domain));
        }
      } else {
#line 219
        domain[0] = (char)0;
      }
    } else {
#line 219
      domain[0] = (char)0;
    }
  }
#line 222
  if (domain[0]) {
    {
#line 223
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 223
      cp = strchr((char const   *)cp, '.');
      }
#line 223
      if (! cp) {
#line 223
        goto while_break;
      }
      {
#line 224
      tmp___0 = strcasecmp((char const   *)(cp + 1), (char const   *)(domain));
      }
#line 224
      if (tmp___0) {
#line 228
        cp ++;
      } else {
#line 225
        *cp = (char)0;
#line 226
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 232
  return;
}
}
#line 234 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
static u_long forgemask(u_long a ) 
{ 
  u_long m ;

  {
#line 240
  if (((in_addr_t )a & 2147483648U) == 0U) {
#line 241
    m = (u_long )4278190080U;
  } else
#line 242
  if (((in_addr_t )a & 3221225472U) == 2147483648U) {
#line 243
    m = (u_long )4294901760U;
  } else {
#line 245
    m = (u_long )4294967040U;
  }
#line 246
  return (m);
}
}
#line 249 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
static void domask(char *dst , size_t len , u_long addr , u_long mask ) 
{ 
  int b ;
  int i ;
  u_long tmp ;
  int bb ;

  {
#line 253
  if (! mask) {
#line 254
    *dst = (char )'\000';
#line 255
    return;
  } else {
    {
#line 253
    tmp = forgemask(addr);
    }
#line 253
    if (tmp == mask) {
#line 254
      *dst = (char )'\000';
#line 255
      return;
    }
  }
#line 257
  i = 0;
#line 258
  b = 0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (b < 32)) {
#line 258
      goto while_break;
    }
#line 259
    if (mask & (unsigned long )(1 << b)) {
#line 262
      i = b;
#line 263
      bb = b + 1;
      {
#line 263
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 263
        if (! (bb < 32)) {
#line 263
          goto while_break___0;
        }
#line 264
        if (! (mask & (unsigned long )(1 << bb))) {
#line 265
          i = -1;
#line 266
          goto while_break___0;
        }
#line 263
        bb ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 268
      goto while_break;
    }
#line 258
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  if (i == -1) {
    {
#line 271
    snprintf((char */* __restrict  */)dst, len, (char const   */* __restrict  */)"&0x%lx",
             mask);
    }
  } else {
    {
#line 273
    snprintf((char */* __restrict  */)dst, len, (char const   */* __restrict  */)"/%d",
             32 - i);
    }
  }
#line 274
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
static char line[68]  ;
#line 280 "/home/wheatley/newnew/temp/pimd-2.1.8/inet.c"
char *netname(u_int32 addr , u_int32 mask ) 
{ 
  u_int32 omask ;
  u_int32 i ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 286
  i = ntohl(addr);
#line 287
  mask = ntohl(mask);
#line 287
  omask = mask;
  }
#line 288
  if ((i & 16777215U) == 0U) {
    {
#line 289
    snprintf((char */* __restrict  */)(line), sizeof(line), (char const   */* __restrict  */)"%u",
             (i >> 24) & 255U);
    }
  } else
#line 290
  if ((i & 65535U) == 0U) {
    {
#line 291
    snprintf((char */* __restrict  */)(line), sizeof(line), (char const   */* __restrict  */)"%u.%u",
             (i >> 24) & 255U, (i >> 16) & 255U);
    }
  } else
#line 292
  if ((i & 255U) == 0U) {
    {
#line 293
    snprintf((char */* __restrict  */)(line), sizeof(line), (char const   */* __restrict  */)"%u.%u.%u",
             (i >> 24) & 255U, (i >> 16) & 255U, (i >> 8) & 255U);
    }
  } else {
    {
#line 295
    snprintf((char */* __restrict  */)(line), sizeof(line), (char const   */* __restrict  */)"%u.%u.%u.%u",
             (i >> 24) & 255U, (i >> 16) & 255U, (i >> 8) & 255U, i & 255U);
    }
  }
  {
#line 297
  tmp = strlen((char const   *)(line));
#line 297
  tmp___0 = strlen((char const   *)(line));
#line 297
  domask(line + tmp___0, sizeof(line) - tmp, (u_long )i, (u_long )omask);
  }
#line 299
  return (line);
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 347
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 324 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 717
extern int system(char const   *__command ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 969 "/usr/include/unistd.h"
extern long gethostid(void) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 184
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setlogmask)(int __mask ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 44 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.h"
int log_nmsgs ;
#line 281 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
u_long virtual_time ;
#line 283
int haveterminal ;
#line 425
void callout_init(void) ;
#line 426
void free_all_callouts(void) ;
#line 427
void age_callout_queue(int elapsed_time ) ;
#line 428
int timer_nextTimer(void) ;
#line 443
void fdump(int i  __attribute__((__unused__)) ) ;
#line 444
void cdump(int i  __attribute__((__unused__)) ) ;
#line 557
int init_routesock(void) ;
#line 558
int routing_socket ;
#line 34 "/usr/include/err.h"
extern void ( /* format attribute */  warn)(char const   *__format  , ...) ;
#line 40
extern void ( /* format attribute */  warnx)(char const   *__format  , ...) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 53 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
char versionstring[100]  ;
#line 54 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
int disable_all_by_default  =    0;
#line 55 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
int haveterminal  =    1;
#line 56 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
struct rp_hold *g_rp_hold  =    (struct rp_hold *)((void *)0);
#line 58 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
char *configfilename  =    (char *)"/etc/pimd.conf";
#line 62 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static int sighandled  =    0;
#line 76 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static struct ihandler ihandlers[3]  ;
#line 80 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static int nhandlers  =    0;
#line 82 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static struct debugname debugnames[68]  = 
#line 82
  {      {(char *)"dvmrp_detail", (uint32_t )16777216, (size_t )5}, 
        {(char *)"dvmrp_prunes", (uint32_t )1, (size_t )8}, 
        {(char *)"dvmrp_pruning", (uint32_t )1, (size_t )8}, 
        {(char *)"dvmrp_routes", (uint32_t )2, (size_t )7}, 
        {(char *)"dvmrp_routing", (uint32_t )2, (size_t )7}, 
        {(char *)"dvmrp_mrt", (uint32_t )2, (size_t )7}, 
        {(char *)"dvmrp_neighbors", (uint32_t )4, (size_t )7}, 
        {(char *)"dvmrp_peers", (uint32_t )4, (size_t )8}, 
        {(char *)"dvmrp_hello", (uint32_t )4, (size_t )7}, 
        {(char *)"dvmrp_timers", (uint32_t )8, (size_t )7}, 
        {(char *)"dvmrp", (uint32_t )7, (size_t )1}, 
        {(char *)"igmp_proto", (uint32_t )16, (size_t )6}, 
        {(char *)"igmp_timers", (uint32_t )32, (size_t )6}, 
        {(char *)"igmp_members", (uint32_t )64, (size_t )6}, 
        {(char *)"groups", (uint32_t )64, (size_t )1}, 
        {(char *)"membership", (uint32_t )64, (size_t )2}, 
        {(char *)"igmp", (uint32_t )112, (size_t )1}, 
        {(char *)"trace", (uint32_t )128, (size_t )2}, 
        {(char *)"mtrace", (uint32_t )128, (size_t )2}, 
        {(char *)"traceroute", (uint32_t )128, (size_t )2}, 
        {(char *)"timeout", (uint32_t )256, (size_t )2}, 
        {(char *)"callout", (uint32_t )256, (size_t )3}, 
        {(char *)"packets", (uint32_t )512, (size_t )2}, 
        {(char *)"pkt", (uint32_t )512, (size_t )2}, 
        {(char *)"interfaces", (uint32_t )1024, (size_t )2}, 
        {(char *)"vif", (uint32_t )1024, (size_t )1}, 
        {(char *)"kernel", (uint32_t )2048, (size_t )2}, 
        {(char *)"cache", (uint32_t )4096, (size_t )1}, 
        {(char *)"mfc", (uint32_t )4096, (size_t )2}, 
        {(char *)"k_cache", (uint32_t )4096, (size_t )2}, 
        {(char *)"k_mfc", (uint32_t )4096, (size_t )2}, 
        {(char *)"rsrr", (uint32_t )8192, (size_t )2}, 
        {(char *)"pim_detail", (uint32_t )8388608, (size_t )5}, 
        {(char *)"pim_hello", (uint32_t )16384, (size_t )5}, 
        {(char *)"pim_neighbors", (uint32_t )16384, (size_t )5}, 
        {(char *)"pim_peers", (uint32_t )16384, (size_t )5}, 
        {(char *)"pim_register", (uint32_t )32768, (size_t )5}, 
        {(char *)"registers", (uint32_t )32768, (size_t )2}, 
        {(char *)"pim_join_prune", (uint32_t )65536, (size_t )5}, 
        {(char *)"pim_j_p", (uint32_t )65536, (size_t )5}, 
        {(char *)"pim_jp", (uint32_t )65536, (size_t )5}, 
        {(char *)"pim_bootstrap", (uint32_t )131072, (size_t )5}, 
        {(char *)"pim_bsr", (uint32_t )131072, (size_t )5}, 
        {(char *)"bsr", (uint32_t )131072, (size_t )1}, 
        {(char *)"bootstrap", (uint32_t )131072, (size_t )1}, 
        {(char *)"pim_asserts", (uint32_t )262144, (size_t )5}, 
        {(char *)"pim_cand_rp", (uint32_t )524288, (size_t )5}, 
        {(char *)"pim_c_rp", (uint32_t )524288, (size_t )5}, 
        {(char *)"pim_rp", (uint32_t )524288, (size_t )6}, 
        {(char *)"rp", (uint32_t )524288, (size_t )2}, 
        {(char *)"pim_routes", (uint32_t )1048576, (size_t )6}, 
        {(char *)"pim_routing", (uint32_t )1048576, (size_t )6}, 
        {(char *)"pim_mrt", (uint32_t )1048576, (size_t )5}, 
        {(char *)"pim_timers", (uint32_t )2097152, (size_t )5}, 
        {(char *)"pim_rpf", (uint32_t )4194304, (size_t )6}, 
        {(char *)"rpf", (uint32_t )4194304, (size_t )3}, 
        {(char *)"pim", (uint32_t )8372224, (size_t )1}, 
        {(char *)"routes", (uint32_t )1048578, (size_t )1}, 
        {(char *)"routing", (uint32_t )1048578, (size_t )1}, 
        {(char *)"mrt", (uint32_t )1048578, (size_t )1}, 
        {(char *)"neighbors", (uint32_t )16388, (size_t )1}, 
        {(char *)"routers", (uint32_t )16388, (size_t )6}, 
        {(char *)"mrouters", (uint32_t )16388, (size_t )7}, 
        {(char *)"peers", (uint32_t )16388, (size_t )1}, 
        {(char *)"timers", (uint32_t )2097192, (size_t )1}, 
        {(char *)"asserts", (uint32_t )262144, (size_t )1}, 
        {(char *)"all", 4294967295U, (size_t )2}, 
        {(char *)"3", 4294967295U, (size_t )1}};
#line 160
static void handler(int sig ) ;
#line 161
static void timer(void *i  __attribute__((__unused__)) ) ;
#line 162
static void cleanup(void) ;
#line 163
static void restart(int i  __attribute__((__unused__)) ) ;
#line 164
static void resetlogging(void *arg ) ;
#line 166 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
int register_input_handler(int fd , void (*func)(int  , fd_set * ) ) 
{ 
  int tmp ;

  {
#line 168
  if (nhandlers >= 3) {
#line 169
    return (-1);
  }
#line 171
  ihandlers[nhandlers].fd = fd;
#line 172
  tmp = nhandlers;
#line 172
  nhandlers ++;
#line 172
  ihandlers[tmp].func = func;
#line 174
  return (0);
}
}
#line 177 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static void do_randomize(void) 
{ 
  int fd ;
  unsigned int seed ;
  time_t tmp ;
  long tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 187
  tmp = time((time_t *)((void *)0));
#line 187
  tmp___0 = gethostid();
#line 187
  seed = (unsigned int )(tmp ^ tmp___0);
#line 189
  seed = (seed >> seed) | (seed << (32U - seed));
#line 191
  fd = open("/dev/urandom", 0);
  }
#line 192
  if (fd >= 0) {
    {
#line 193
    tmp___1 = read(fd, (void *)(& seed), sizeof(seed));
    }
#line 193
    if (-1L == tmp___1) {
      {
#line 194
      warn("Failed reading entropy from /dev/urandom");
      }
    }
    {
#line 195
    close(fd);
    }
  }
  {
#line 201
  srandom(seed);
  }
#line 203
  return;
}
}
#line 206 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static pid_t daemon_pid(void) 
{ 
  int result ;
  char *path ;
  FILE *fp ;
  pid_t pid___0 ;

  {
  {
#line 209
  path = (char *)((void *)0);
#line 211
  pid___0 = -1;
#line 213
  result = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s%s.pid",
                    "/var/run/", __progname);
  }
#line 214
  if (result == -1) {
#line 215
    return (-1);
  } else
#line 214
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 215
    return (-1);
  }
  {
#line 217
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 218
  if (! fp) {
    {
#line 219
    free((void *)path);
    }
#line 220
    return (-1);
  }
  {
#line 223
  result = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d",
                  & pid___0);
#line 224
  fclose(fp);
#line 225
  free((void *)path);
  }
#line 227
  return (pid___0);
}
}
#line 231 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static void killshow(int signo , char *file ) 
{ 
  pid_t pid___0 ;
  pid_t tmp ;
  char buf[100] ;
  int tmp___0 ;

  {
  {
#line 233
  tmp = daemon_pid();
#line 233
  pid___0 = tmp;
  }
#line 236
  if (pid___0 > 0) {
#line 237
    if (file) {
      {
#line 238
      remove((char const   *)file);
      }
    }
    {
#line 239
    kill(pid___0, signo);
    }
#line 240
    if (file) {
      {
#line 241
      usleep((__useconds_t )200);
#line 242
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"cat %s",
               file);
#line 243
      tmp___0 = system((char const   *)(buf));
      }
#line 243
      if (-1 == tmp___0) {
        {
#line 244
        warnx("Failed listing file %s\n", file);
        }
      }
    }
  }
#line 248
  return;
}
}
#line 250 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static int usage(void) 
{ 
  size_t i ;
  size_t j ;
  size_t k ;
  struct debugname *d ;
  size_t tmp ;

  {
  {
#line 255
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-fhlNqrv] [-c FILE] [-d [LEVEL][,LEVEL...]]\n\n",
          __progname);
#line 256
  fputs((char const   */* __restrict  */)"  -c, --config=FILE    Configuration file to use, default /etc/pimd.conf\n",
        (FILE */* __restrict  */)stderr);
#line 257
  fputs((char const   */* __restrict  */)"  -d, --debug[=LEVEL]  Debug level, see below for valid levels\n",
        (FILE */* __restrict  */)stderr);
#line 258
  fputs((char const   */* __restrict  */)"  -f, --foreground     Run in foreground, do not detach from calling terminal\n",
        (FILE */* __restrict  */)stderr);
#line 259
  fputs((char const   */* __restrict  */)"  -h, --help           Show this help text\n",
        (FILE */* __restrict  */)stderr);
#line 261
  fputs((char const   */* __restrict  */)"  -l, --reload-config  Tell a running pimd to reload its configuration\n",
        (FILE */* __restrict  */)stderr);
#line 262
  fputs((char const   */* __restrict  */)"  -N, --disable-vifs   Disable all virtual interfaces (phyint) by default\n",
        (FILE */* __restrict  */)stderr);
#line 264
  fputs((char const   */* __restrict  */)"  -q, --quit-daemon    Send SIGTERM to a running pimd\n",
        (FILE */* __restrict  */)stderr);
#line 265
  fputs((char const   */* __restrict  */)"  -r, --show-routes    Show state of VIFs and multicast routing tables\n",
        (FILE */* __restrict  */)stderr);
#line 266
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v, --version        Show %s version\n",
          __progname);
#line 267
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
#line 269
  j = (size_t )4294967295U;
#line 270
  k = (size_t )0;
#line 271
  fputs((char const   */* __restrict  */)"Valid debug levels:\n  ", (FILE */* __restrict  */)stderr);
#line 272
  i = (size_t )0;
#line 272
  d = debugnames;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < sizeof(debugnames) / sizeof(debugnames[0]))) {
#line 272
      goto while_break;
    }
#line 273
    if ((j & (unsigned long )d->level) == (unsigned long )d->level) {
#line 274
      tmp = k;
#line 274
      k ++;
#line 274
      if (tmp) {
#line 275
        if (! (k % 5UL)) {
          {
#line 276
          fputs((char const   */* __restrict  */)"\n  ", (FILE */* __restrict  */)stderr);
          }
        } else {
          {
#line 278
          fputs((char const   */* __restrict  */)", ", (FILE */* __restrict  */)stderr);
          }
        }
      }
      {
#line 280
      fputs((char const   */* __restrict  */)d->name, (FILE */* __restrict  */)stderr);
#line 281
      j &= (unsigned long )(~ d->level);
      }
    }
#line 272
    i ++;
#line 272
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  fputc('\n', stderr);
  }
#line 286
  return (1);
}
}
#line 289 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
int main(int argc , char **argv ) 
{ 
  int dummysigalrm ;
  int foreground ;
  struct timeval tv ;
  struct timeval difftime___0 ;
  struct timeval curtime ;
  struct timeval lasttime ;
  struct timeval *timeout ;
  fd_set rfds ;
  fd_set readers ;
  int nfds ;
  int n ;
  int i ;
  int secs ;
  int ch ;
  struct sigaction sa ;
  time_t boottime ;
  struct option long_options[10] ;
  char *p ;
  char *q ;
  size_t i___0 ;
  size_t len ;
  struct debugname *d ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  struct debugname *d___0 ;
  char c ;
  int tmpd ;
  int __d0 ;
  int __d1 ;
  __pid_t tmp___6 ;
  int tmp___7 ;
  time_t n___0 ;
  struct rp_hold *rph ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 291
  foreground = 0;
#line 297
  long_options[0].name = "config";
#line 297
  long_options[0].has_arg = 1;
#line 297
  long_options[0].flag = (int *)0;
#line 297
  long_options[0].val = 'c';
#line 297
  long_options[1].name = "debug";
#line 297
  long_options[1].has_arg = 2;
#line 297
  long_options[1].flag = (int *)0;
#line 297
  long_options[1].val = 'd';
#line 297
  long_options[2].name = "foreground";
#line 297
  long_options[2].has_arg = 0;
#line 297
  long_options[2].flag = (int *)0;
#line 297
  long_options[2].val = 'f';
#line 297
  long_options[3].name = "disable-vifs";
#line 297
  long_options[3].has_arg = 0;
#line 297
  long_options[3].flag = (int *)0;
#line 297
  long_options[3].val = 'N';
#line 297
  long_options[4].name = "help";
#line 297
  long_options[4].has_arg = 0;
#line 297
  long_options[4].flag = (int *)0;
#line 297
  long_options[4].val = 'h';
#line 297
  long_options[5].name = "version";
#line 297
  long_options[5].has_arg = 0;
#line 297
  long_options[5].flag = (int *)0;
#line 297
  long_options[5].val = 'v';
#line 297
  long_options[6].name = "quit-daemon";
#line 297
  long_options[6].has_arg = 0;
#line 297
  long_options[6].flag = (int *)0;
#line 297
  long_options[6].val = 'q';
#line 297
  long_options[7].name = "reload-config";
#line 297
  long_options[7].has_arg = 0;
#line 297
  long_options[7].flag = (int *)0;
#line 297
  long_options[7].val = 'l';
#line 297
  long_options[8].name = "show-routes";
#line 297
  long_options[8].has_arg = 0;
#line 297
  long_options[8].flag = (int *)0;
#line 297
  long_options[8].val = 'r';
#line 297
  long_options[9].name = (char const   *)0;
#line 297
  long_options[9].has_arg = 0;
#line 297
  long_options[9].flag = (int *)0;
#line 297
  long_options[9].val = 0;
#line 312
  snprintf((char */* __restrict  */)(versionstring), sizeof(versionstring), (char const   */* __restrict  */)"pimd version %s",
           todaysversion);
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    ch = getopt_long(argc, (char * const  *)argv, "c:d::fhlNP::vqr", (struct option  const  *)(long_options),
                     (int *)((void *)0));
    }
#line 314
    if (! (ch != -1)) {
#line 314
      goto while_break;
    }
    {
#line 316
    if (ch == 99) {
#line 316
      goto case_99;
    }
#line 320
    if (ch == 100) {
#line 320
      goto case_100;
    }
#line 348
    if (ch == 102) {
#line 348
      goto case_102;
    }
#line 352
    if (ch == 104) {
#line 352
      goto case_104;
    }
#line 355
    if (ch == 108) {
#line 355
      goto case_108;
    }
#line 359
    if (ch == 78) {
#line 359
      goto case_78;
    }
#line 363
    if (ch == 80) {
#line 363
      goto case_80;
    }
#line 379
    if (ch == 118) {
#line 379
      goto case_118;
    }
#line 383
    if (ch == 113) {
#line 383
      goto case_113;
    }
#line 387
    if (ch == 114) {
#line 387
      goto case_114;
    }
#line 399
    goto switch_default;
    case_99: /* CIL Label */ 
#line 317
    configfilename = optarg;
#line 318
    goto switch_break;
    case_100: /* CIL Label */ 
#line 321
    if (! optarg) {
#line 322
      debug = 4294967295UL;
    } else {
#line 328
      debug = 0UL;
#line 329
      p = optarg;
#line 329
      q = (char *)((void *)0);
      {
#line 330
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 330
        if (! p) {
#line 330
          goto while_break___0;
        }
        {
#line 331
        q = strchr((char const   *)p, ',');
        }
#line 332
        if (q) {
#line 333
          tmp = q;
#line 333
          q ++;
#line 333
          *tmp = (char )'\000';
        }
        {
#line 334
        len = strlen((char const   *)p);
#line 335
        i___0 = (size_t )0;
#line 335
        d = debugnames;
        }
        {
#line 335
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 335
          if (! (i___0 < sizeof(debugnames) / sizeof(debugnames[0]))) {
#line 335
            goto while_break___1;
          }
#line 336
          if (len >= d->nchars) {
            {
#line 336
            tmp___0 = strncmp((char const   *)d->name, (char const   *)p, len);
            }
#line 336
            if (tmp___0 == 0) {
#line 337
              goto while_break___1;
            }
          }
#line 335
          i___0 ++;
#line 335
          d ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 339
        if (i___0 == sizeof(debugnames) / sizeof(debugnames[0])) {
          {
#line 340
          tmp___1 = usage();
          }
#line 340
          return (tmp___1);
        }
#line 342
        debug |= (unsigned long )d->level;
#line 343
        p = q;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 346
    goto switch_break;
    case_102: /* CIL Label */ 
#line 349
    foreground = 1;
#line 350
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 353
    tmp___2 = usage();
    }
#line 353
    return (tmp___2);
    case_108: /* CIL Label */ 
    {
#line 356
    killshow(1, (char *)((void *)0));
    }
#line 357
    return (0);
    case_78: /* CIL Label */ 
#line 360
    disable_all_by_default = 1;
#line 361
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 375
    warnx("SNMP support missing, please feel free to submit a patch.");
    }
#line 377
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 380
    printf((char const   */* __restrict  */)"%s\n", versionstring);
    }
#line 381
    return (0);
    case_113: /* CIL Label */ 
    {
#line 384
    killshow(15, (char *)((void *)0));
    }
#line 385
    return (0);
    case_114: /* CIL Label */ 
    {
#line 388
    killshow(10, (char *)"/var/run/pimd/pimd.dump");
    }
#line 389
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 400
    tmp___3 = usage();
    }
#line 400
    return (tmp___3);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  argc -= optind;
#line 405
  argv += optind;
#line 407
  if (argc > 0) {
    {
#line 408
    tmp___4 = usage();
    }
#line 408
    return (tmp___4);
  }
  {
#line 411
  tmp___5 = geteuid();
  }
#line 411
  if (tmp___5 != 0U) {
    {
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: must be root\n",
            __progname);
#line 413
    exit(1);
    }
  }
  {
#line 415
  setlinebuf(stderr);
  }
#line 417
  if (debug != 0UL) {
    {
#line 420
    tmpd = (int )debug;
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"debug level 0x%lx ",
            debug);
#line 423
    c = (char )'(';
#line 424
    d___0 = debugnames;
    }
    {
#line 424
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 424
      if (! ((unsigned long )d___0 < (unsigned long )(debugnames + sizeof(debugnames) / sizeof(debugnames[0])))) {
#line 424
        goto while_break___2;
      }
#line 425
      if (((unsigned int )tmpd & d___0->level) == d___0->level) {
        {
#line 426
        tmpd = (int )((unsigned int )tmpd & ~ d___0->level);
#line 427
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c%s",
                (int )c, d___0->name);
#line 428
        c = (char )',';
        }
      }
#line 424
      d___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
    }
  }
  {
#line 437
  mkdir("/var/run/pimd", (__mode_t )493);
#line 443
  openlog("pimd", 1, 3 << 3);
#line 444
  setlogmask((1 << 6) - 1);
#line 449
  logit(7, 0, "%s starting", versionstring);
#line 451
  do_randomize();
#line 452
  time(& boottime);
#line 455
  resetlogging((void *)0);
#line 457
  callout_init();
#line 458
  init_igmp();
#line 459
  init_pim();
#line 461
  init_routesock();
#line 463
  init_pim_mrt();
#line 464
  init_timers();
#line 472
  init_vifs();
#line 473
  init_rp_and_bsr();
#line 479
  sa.__sigaction_handler.sa_handler = & handler;
#line 480
  sa.sa_flags = 0;
#line 481
  sigemptyset(& sa.sa_mask);
#line 482
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 483
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 484
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 485
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 486
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 487
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 489
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 489
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readers.fds_bits[0]): "memory");
#line 489
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 490
  readers.fds_bits[igmp_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << igmp_socket % (8 * (int )sizeof(__fd_mask ));
#line 491
  nfds = igmp_socket + 1;
#line 492
  i = 0;
  {
#line 492
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 492
    if (! (i < nhandlers)) {
#line 492
      goto while_break___4;
    }
#line 493
    readers.fds_bits[ihandlers[i].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ihandlers[i].fd % (8 * (int )sizeof(__fd_mask ));
#line 494
    if (ihandlers[i].fd >= nfds) {
#line 495
      nfds = ihandlers[i].fd + 1;
    }
#line 492
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 498
  if (debug) {
#line 498
    if (debug & 1024UL) {
      {
#line 499
      dump_vifs(stderr);
      }
    }
  }
#line 500
  if (debug) {
#line 500
    if (debug & 1048576UL) {
      {
#line 501
      dump_pim_mrt(stderr);
      }
    }
  }
  {
#line 504
  timer_setTimer(5, & timer, (void *)0);
  }
#line 506
  if (! debug) {
#line 506
    if (! foreground) {
      {
#line 508
      haveterminal = 0;
#line 509
      tmp___6 = fork();
      }
#line 509
      if (tmp___6) {
        {
#line 510
        exit(0);
        }
      }
      {
#line 511
      close(0);
#line 512
      close(1);
#line 513
      close(2);
#line 514
      open("/", 0);
#line 515
      dup2(0, 1);
#line 516
      dup2(0, 2);
#line 521
      n = open("/dev/tty", 2);
      }
#line 522
      if (n >= 0) {
        {
#line 523
        ioctl(n, 21538UL, (char *)0);
#line 524
        close(n);
        }
      }
    }
  }
  {
#line 533
  tmp___7 = pidfile((char const   *)((void *)0));
  }
#line 533
  if (tmp___7) {
    {
#line 534
    warn("Cannot create pidfile");
    }
  }
  {
#line 540
  dummysigalrm = 14;
#line 541
  difftime___0.tv_usec = (__suseconds_t )0;
#line 542
  gettimeofday((struct timeval */* __restrict  */)(& curtime), (__timezone_ptr_t )((void *)0));
#line 543
  lasttime = curtime;
  }
  {
#line 544
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 545
    memcpy((void */* __restrict  */)(& rfds), (void const   */* __restrict  */)(& readers),
           sizeof(rfds));
#line 546
    secs = timer_nextTimer();
    }
#line 547
    if (secs == -1) {
#line 548
      timeout = (struct timeval *)((void *)0);
    } else {
#line 550
      timeout = & tv;
#line 551
      timeout->tv_sec = (__time_t )secs;
#line 552
      timeout->tv_usec = (__suseconds_t )0;
    }
#line 555
    if (boottime) {
      {
#line 558
      time(& n___0);
      }
#line 559
      if (n___0 > boottime + 15L) {
#line 560
        rph = g_rp_hold;
        {
#line 562
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 562
          if (! rph) {
#line 562
            goto while_break___6;
          }
          {
#line 563
          add_rp_grp_entry(& cand_rp_list, & grp_mask_list, rph->address, (u_int8 )1,
                           (u_int16 )16777215, rph->group, rph->mask, curr_bsr_hash_mask,
                           curr_bsr_fragment_tag);
#line 566
          rph = rph->next;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 568
        boottime = (time_t )0;
      }
    }
#line 572
    if (sighandled) {
#line 573
      if (sighandled & 1) {
#line 574
        sighandled &= -2;
#line 575
        goto while_break___5;
      }
#line 577
      if (sighandled & 2) {
        {
#line 578
        sighandled &= -3;
#line 579
        restart(1);
        }
        {
#line 582
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 582
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& readers.fds_bits[0]): "memory");
#line 582
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 583
        readers.fds_bits[igmp_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << igmp_socket % (8 * (int )sizeof(__fd_mask ));
#line 584
        nfds = igmp_socket + 1;
#line 585
        i = 0;
        {
#line 585
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 585
          if (! (i < nhandlers)) {
#line 585
            goto while_break___8;
          }
#line 586
          readers.fds_bits[ihandlers[i].fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ihandlers[i].fd % (8 * (int )sizeof(__fd_mask ));
#line 587
          if (ihandlers[i].fd >= nfds) {
#line 588
            nfds = ihandlers[i].fd + 1;
          }
#line 585
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 590
        memcpy((void */* __restrict  */)(& rfds), (void const   */* __restrict  */)(& readers),
               sizeof(rfds));
        }
      }
#line 592
      if (sighandled & 4) {
        {
#line 593
        sighandled &= -5;
#line 594
        fdump(10);
        }
      }
#line 596
      if (sighandled & 8) {
        {
#line 597
        sighandled &= -9;
#line 598
        cdump(12);
        }
      }
#line 600
      if (sighandled & 16) {
        {
#line 601
        sighandled &= -17;
#line 602
        timer((void *)(& dummysigalrm));
        }
      }
    }
    {
#line 605
    n = select(nfds, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)timeout);
    }
#line 605
    if (n < 0) {
      {
#line 606
      tmp___9 = __errno_location();
      }
#line 606
      if (*tmp___9 != 4) {
        {
#line 607
        tmp___8 = __errno_location();
#line 607
        logit(4, *tmp___8, "select failed");
        }
      }
#line 608
      goto while_continue___5;
    }
#line 610
    if (n > 0) {
#line 612
      i = 0;
      {
#line 612
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 612
        if (! (i < nhandlers)) {
#line 612
          goto while_break___9;
        }
#line 613
        if ((rfds.fds_bits[ihandlers[i].fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ihandlers[i].fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 614
          (*(ihandlers[i].func))(ihandlers[i].fd, & rfds);
          }
        }
#line 612
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
    {
#line 632
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 638
      if (n == 0) {
#line 639
        curtime.tv_sec = lasttime.tv_sec + (__time_t )secs;
#line 640
        curtime.tv_usec = lasttime.tv_usec;
#line 641
        n = -1;
      } else {
        {
#line 643
        gettimeofday((struct timeval */* __restrict  */)(& curtime), (__timezone_ptr_t )((void *)0));
        }
      }
#line 644
      difftime___0.tv_sec = curtime.tv_sec - lasttime.tv_sec;
#line 645
      difftime___0.tv_usec += curtime.tv_usec - lasttime.tv_usec;
      {
#line 646
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 646
        if (! (difftime___0.tv_usec >= 1000000L)) {
#line 646
          goto while_break___11;
        }
#line 647
        (difftime___0.tv_sec) ++;
#line 648
        difftime___0.tv_usec -= 1000000L;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 650
      if (difftime___0.tv_usec < 0L) {
#line 651
        (difftime___0.tv_sec) --;
#line 652
        difftime___0.tv_usec += 1000000L;
      }
#line 654
      lasttime = curtime;
#line 655
      if (secs == 0) {
        {
#line 656
        age_callout_queue((int )difftime___0.tv_sec);
        }
      } else
#line 655
      if (difftime___0.tv_sec > 0L) {
        {
#line 656
        age_callout_queue((int )difftime___0.tv_sec);
        }
      }
#line 657
      secs = -1;
#line 632
      if (! (difftime___0.tv_sec > 0L)) {
#line 632
        goto while_break___10;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 661
  logit(5, 0, "%s exiting", versionstring);
#line 662
  cleanup();
#line 663
  exit(0);
  }
}
}
#line 683 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
u_long virtual_time  =    (u_long )0;
#line 690 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static void timer(void *i  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 692
  age_vifs();
#line 693
  age_routes();
#line 694
  age_misc();
#line 696
  virtual_time += 5UL;
#line 697
  timer_setTimer(5, & timer, (void *)0);
  }
#line 698
  return;
}
}
#line 704 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static void cleanup(void) 
{ 
  vifi_t vifi ;
  struct uvif *v ;

  {
#line 710
  vifi = (vifi_t )0;
#line 710
  v = uvifs;
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! ((int )vifi < (int )numvifs)) {
#line 710
      goto while_break;
    }
#line 711
    if ((v->uv_flags & 773U) == 0U) {
      {
#line 713
      send_pim_hello(v, (u_int16 )0);
      }
    }
#line 710
    vifi = (vifi_t )((int )vifi + 1);
#line 710
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 725
  k_stop_pim(igmp_socket);
  }
#line 726
  return;
}
}
#line 733 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static void handler(int sig ) 
{ 


  {
  {
#line 736
  if (sig == 14) {
#line 736
    goto case_14;
  }
#line 739
  if (sig == 15) {
#line 739
    goto case_15;
  }
#line 739
  if (sig == 2) {
#line 739
    goto case_15;
  }
#line 743
  if (sig == 1) {
#line 743
    goto case_1;
  }
#line 747
  if (sig == 10) {
#line 747
    goto case_10;
  }
#line 751
  if (sig == 12) {
#line 751
    goto case_12;
  }
#line 735
  goto switch_break;
  case_14: /* CIL Label */ 
#line 737
  sighandled |= 16;
  case_15: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 740
  sighandled |= 1;
#line 741
  goto switch_break;
  case_1: /* CIL Label */ 
#line 744
  sighandled |= 2;
#line 745
  goto switch_break;
  case_10: /* CIL Label */ 
#line 748
  sighandled |= 4;
#line 749
  goto switch_break;
  case_12: /* CIL Label */ 
#line 752
  sighandled |= 8;
#line 753
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 755
  return;
}
}
#line 762 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static void restart(int i  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 768
  logit(5, 0, "%s % restart", versionstring);
#line 776
  free_all_callouts();
#line 777
  stop_all_vifs();
#line 778
  k_stop_pim(igmp_socket);
#line 779
  nhandlers = 0;
#line 780
  close(igmp_socket);
#line 781
  close(pim_socket);
#line 791
  close(routing_socket);
#line 798
  init_igmp();
#line 799
  init_pim();
#line 801
  init_routesock();
#line 803
  init_pim_mrt();
#line 808
  init_vifs();
#line 811
  timer_setTimer(5, & timer, (void *)0);
  }
#line 812
  return;
}
}
#line 815 "/home/wheatley/newnew/temp/pimd-2.1.8/main.c"
static void resetlogging(void *arg ) 
{ 
  int nxttime ;
  void *narg ;

  {
#line 817
  nxttime = 60;
#line 818
  narg = (void *)0;
#line 820
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 820
    if (log_nmsgs > 20) {
      {
#line 821
      nxttime = 600;
#line 822
      narg = (void *)(& log_nmsgs);
#line 823
      syslog(4, "logging too fast, shutting up for %d minutes", 10);
      }
    } else {
#line 826
      log_nmsgs = 0;
    }
  } else {
#line 826
    log_nmsgs = 0;
  }
  {
#line 829
  timer_setTimer(nxttime, & resetlogging, narg);
  }
#line 830
  return;
}
}
#line 431 "/home/wheatley/newnew/temp/pimd-2.1.8/defs.h"
int timer_leftTimer(int timer_id ) ;
#line 16 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
static int id  =    0;
#line 17 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
static struct timeout_q *Q  =    (struct timeout_q *)0;
#line 37 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
void callout_init(void) 
{ 


  {
#line 40
  Q = (struct timeout_q *)0;
#line 41
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
void free_all_callouts(void) 
{ 
  struct timeout_q *p ;

  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! Q) {
#line 48
      goto while_break;
    }
    {
#line 49
    p = Q;
#line 50
    Q = Q->next;
#line 51
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
void age_callout_queue(int elapsed_time ) 
{ 
  struct timeout_q *ptr ;
  struct timeout_q *expQ ;

  {
#line 72
  expQ = Q;
#line 73
  ptr = (struct timeout_q *)((void *)0);
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! Q) {
#line 75
      goto while_break;
    }
#line 76
    if (Q->time > elapsed_time) {
#line 77
      Q->time -= elapsed_time;
#line 78
      if (ptr) {
#line 79
        ptr->next = (struct timeout_q *)((void *)0);
#line 80
        goto while_break;
      }
#line 82
      return;
    } else {
#line 84
      elapsed_time -= Q->time;
#line 85
      ptr = Q;
#line 86
      Q = Q->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! expQ) {
#line 91
      goto while_break___0;
    }
#line 92
    ptr = expQ;
#line 93
    if (ptr->func) {
      {
#line 94
      (*(ptr->func))(ptr->data);
      }
    }
    {
#line 95
    expQ = expQ->next;
#line 96
    free((void *)ptr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
int timer_nextTimer(void) 
{ 


  {
#line 107
  if (Q) {
#line 108
    if (Q->time < 0) {
      {
#line 109
      logit(4, 0, "timer_nextTimer top of queue says %d", Q->time);
      }
#line 111
      return (0);
    }
#line 113
    return (Q->time);
  }
#line 115
  return (-1);
}
}
#line 121 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
int timer_setTimer(int delay , void (*action)(void * ) , void *data ) 
{ 
  struct timeout_q *ptr ;
  struct timeout_q *node ;
  struct timeout_q *prev ;
  void *tmp ;

  {
  {
#line 136
  tmp = calloc((size_t )1, sizeof(struct timeout_q ));
#line 136
  node = (struct timeout_q *)tmp;
  }
#line 137
  if (! node) {
    {
#line 138
    logit(3, 0, "Failed calloc() in timer_settimer\n");
    }
#line 139
    return (-1);
  }
#line 141
  node->func = action;
#line 142
  node->data = data;
#line 143
  node->time = delay;
#line 144
  node->next = (struct timeout_q *)0;
#line 145
  id ++;
#line 145
  node->id = id;
#line 147
  ptr = Q;
#line 147
  prev = ptr;
#line 152
  if (! Q) {
#line 153
    Q = node;
  } else {
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! ptr) {
#line 156
        goto while_break;
      }
#line 158
      if (delay < ptr->time) {
#line 161
        node->next = ptr;
#line 162
        if ((unsigned long )ptr == (unsigned long )Q) {
#line 163
          Q = node;
        } else {
#line 165
          prev->next = node;
        }
#line 166
        ptr->time -= node->time;
#line 168
        return (node->id);
      } else {
#line 172
        delay -= ptr->time;
#line 172
        node->time = delay;
#line 173
        prev = ptr;
#line 174
        ptr = ptr->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 177
    prev->next = node;
  }
#line 180
  return (node->id);
}
}
#line 184 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
int timer_leftTimer(int timer_id ) 
{ 
  struct timeout_q *ptr ;
  int left ;

  {
#line 189
  left = 0;
#line 191
  if (! timer_id) {
#line 192
    return (-1);
  }
#line 194
  ptr = Q;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! ptr) {
#line 194
      goto while_break;
    }
#line 195
    left += ptr->time;
#line 196
    if (ptr->id == timer_id) {
#line 197
      return (left);
    }
#line 194
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (-1);
}
}
#line 203 "/home/wheatley/newnew/temp/pimd-2.1.8/callout.c"
void timer_clearTimer(int timer_id ) 
{ 
  struct timeout_q *ptr ;
  struct timeout_q *prev ;

  {
#line 209
  if (! timer_id) {
#line 210
    return;
  }
#line 212
  ptr = Q;
#line 212
  prev = ptr;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! ptr) {
#line 220
      goto while_break;
    }
#line 221
    if (ptr->id == timer_id) {
#line 225
      if ((unsigned long )ptr == (unsigned long )Q) {
#line 226
        Q = Q->next;
      } else {
#line 228
        prev->next = ptr->next;
      }
#line 231
      if ((unsigned long )ptr->next != (unsigned long )((struct timeout_q *)0)) {
#line 232
        (ptr->next)->time += ptr->time;
      }
#line 234
      if (ptr->data) {
        {
#line 235
        free(ptr->data);
        }
      }
      {
#line 236
      free((void *)ptr);
      }
#line 238
      return;
    }
#line 240
    prev = ptr;
#line 241
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return;
}
}
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 24 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
int routing_socket  =    -1;
#line 25 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
static __u32 pid  ;
#line 26 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
static __u32 seq  ;
#line 28
static int getmsg(struct rtmsg *rtm , int msglen , struct rpfctl *rpf ) ;
#line 30 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
static int addattr32(struct nlmsghdr *n , size_t maxlen , int type , __u32 data ) 
{ 
  int len ;
  struct rtattr *rta ;

  {
#line 32
  len = (int )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + 4UL);
#line 35
  if ((size_t )((((n->nlmsg_len + 4U) - 1U) & 4294967292U) + (unsigned int )len) > maxlen) {
#line 36
    return (-1);
  }
  {
#line 38
  rta = (struct rtattr *)((char *)n + (((n->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 39
  rta->rta_type = (unsigned short )type;
#line 40
  rta->rta_len = (unsigned short )len;
#line 41
  memcpy((void */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
         (void const   */* __restrict  */)(& data), (size_t )4);
#line 42
  n->nlmsg_len = (((n->nlmsg_len + 4U) - 1U) & 4294967292U) + (unsigned int )len;
  }
#line 44
  return (0);
}
}
#line 47 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
static int parse_rtattr(struct rtattr **tb , int max , struct rtattr *rta , int len ) 
{ 


  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (len >= (int )sizeof(struct rtattr )) {
#line 49
      if ((unsigned long )rta->rta_len >= sizeof(struct rtattr )) {
#line 49
        if (! ((int )rta->rta_len <= len)) {
#line 49
          goto while_break;
        }
      } else {
#line 49
        goto while_break;
      }
    } else {
#line 49
      goto while_break;
    }
#line 50
    if ((int )rta->rta_type <= max) {
#line 51
      *(tb + rta->rta_type) = rta;
    }
#line 52
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 52
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (len) {
    {
#line 55
    logit(4, 0, "NETLINK: Deficit in rtattr %d\n", len);
    }
  }
#line 56
  return (0);
}
}
#line 60 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
int init_routesock(void) 
{ 
  socklen_t addr_len ;
  struct sockaddr_nl local ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;

  {
  {
#line 65
  routing_socket = socket(16, 3, 0);
  }
#line 66
  if (routing_socket < 0) {
    {
#line 67
    tmp = __errno_location();
#line 67
    logit(3, *tmp, "netlink socket");
    }
#line 69
    return (-1);
  }
  {
#line 71
  memset((void *)(& local), 0, sizeof(local));
#line 72
  local.nl_family = (__kernel_sa_family_t )16;
#line 73
  local.nl_groups = (__u32 )0;
#line 75
  tmp___1 = bind(routing_socket, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& local)),
                 (socklen_t )sizeof(local));
  }
#line 75
  if (tmp___1 < 0) {
    {
#line 76
    tmp___0 = __errno_location();
#line 76
    logit(3, *tmp___0, "netlink bind");
    }
#line 78
    return (-1);
  }
  {
#line 80
  addr_len = (socklen_t )sizeof(local);
#line 81
  tmp___3 = getsockname(routing_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& local)),
                        (socklen_t */* __restrict  */)(& addr_len));
  }
#line 81
  if (tmp___3 < 0) {
    {
#line 82
    tmp___2 = __errno_location();
#line 82
    logit(3, *tmp___2, "netlink getsockname");
    }
#line 83
    return (-1);
  }
#line 85
  if ((unsigned long )addr_len != sizeof(local)) {
    {
#line 86
    logit(3, 0, "netlink wrong addr len");
    }
#line 88
    return (-1);
  }
#line 90
  if ((int )local.nl_family != 16) {
    {
#line 91
    logit(3, 0, "netlink wrong addr family");
    }
#line 93
    return (-1);
  }
  {
#line 95
  pid = local.nl_pid;
#line 96
  tmp___4 = time((time_t *)((void *)0));
#line 96
  seq = (__u32 )tmp___4;
  }
#line 98
  return (0);
}
}
#line 102 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
int k_req_incoming(u_int32 source , struct rpfctl *rpf ) 
{ 
  int rlen ;
  register int l ;
  char buf[512] ;
  struct nlmsghdr *n ;
  struct rtmsg *r ;
  struct sockaddr_nl addr ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  socklen_t alen ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 107
  n = (struct nlmsghdr *)(buf);
#line 108
  r = (struct rtmsg *)((void *)((char *)n + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 111
  rpf->source.s_addr = source;
#line 112
  rpf->iif = (vifi_t )-1;
#line 113
  rpf->rpfneighbor.s_addr = (in_addr_t )0;
#line 115
  n->nlmsg_type = (__u16 )26;
#line 116
  n->nlmsg_flags = (__u16 )1;
#line 117
  n->nlmsg_len = (__u32 )(sizeof(*r) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 118
  n->nlmsg_pid = pid;
#line 119
  seq ++;
#line 119
  n->nlmsg_seq = seq;
#line 121
  memset((void *)r, 0, sizeof(*r));
#line 122
  r->rtm_family = (unsigned char)2;
#line 123
  r->rtm_dst_len = (unsigned char)32;
#line 124
  addattr32(n, sizeof(buf), 1, rpf->source.s_addr);
#line 128
  addr.nl_family = (__kernel_sa_family_t )16;
#line 129
  addr.nl_groups = (__u32 )0;
#line 130
  addr.nl_pid = (__u32 )0;
#line 133
  tmp = inet_fmt(rpf->source.s_addr, s1, sizeof(s1));
#line 133
  logit(7, 0, "NETLINK: ask path to %s", tmp);
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 136
    tmp___2 = sendto(routing_socket, (void const   *)(buf), (size_t )n->nlmsg_len,
                     0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                     (socklen_t )sizeof(addr));
#line 136
    rlen = (int )tmp___2;
    }
#line 136
    if (! (rlen < 0)) {
#line 136
      goto while_break;
    }
    {
#line 137
    tmp___0 = __errno_location();
    }
#line 137
    if (*tmp___0 == 4) {
#line 138
      goto while_continue;
    }
    {
#line 139
    tmp___1 = __errno_location();
#line 139
    logit(4, *tmp___1, "Error writing to routing socket");
    }
#line 141
    return (0);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 144
    alen = (socklen_t )sizeof(addr);
#line 145
    tmp___3 = recvfrom(routing_socket, (void */* __restrict  */)(buf), sizeof(buf),
                       0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                       (socklen_t */* __restrict  */)(& alen));
#line 145
    l = (int )tmp___3;
    }
#line 146
    if (l < 0) {
      {
#line 147
      tmp___4 = __errno_location();
      }
#line 147
      if (*tmp___4 == 4) {
#line 148
        goto __Cont;
      }
      {
#line 149
      tmp___5 = __errno_location();
#line 149
      logit(4, *tmp___5, "Error writing to routing socket");
      }
#line 151
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 143
    if (! (n->nlmsg_seq != seq)) {
#line 143
      if (! (n->nlmsg_pid != pid)) {
#line 143
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 155
  if ((int )n->nlmsg_type != 24) {
#line 156
    if ((int )n->nlmsg_type != 2) {
      {
#line 157
      logit(4, 0, "netlink: wrong answer type %d", (int )n->nlmsg_type);
      }
    } else {
      {
#line 159
      logit(4, - *((int *)((void *)((char *)n + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)))),
            "netlink get_route");
      }
    }
#line 162
    return (0);
  }
  {
#line 165
  tmp___6 = getmsg((struct rtmsg *)((void *)((char *)n + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))),
                   (int )((unsigned long )l - sizeof(*n)), rpf);
  }
#line 165
  return (tmp___6);
}
}
#line 168 "/home/wheatley/newnew/temp/pimd-2.1.8/netlink.c"
static int getmsg(struct rtmsg *rtm , int msglen , struct rpfctl *rpf ) 
{ 
  vifi_t vifi ;
  struct uvif *v ;
  struct rtattr *rta[18] ;
  vifi_t tmp ;
  int ifindex ;
  __u32 gw ;
  char *tmp___0 ;

  {
#line 174
  if ((int )rtm->rtm_type == 2) {
    {
#line 176
    logit(7, 0, "NETLINK: local address");
#line 177
    tmp = local_address(rpf->source.s_addr);
#line 177
    rpf->iif = tmp;
    }
#line 177
    if ((int )tmp != 32) {
#line 178
      rpf->rpfneighbor.s_addr = rpf->source.s_addr;
#line 180
      return (1);
    }
#line 183
    return (0);
  }
#line 186
  rpf->rpfneighbor.s_addr = (in_addr_t )0;
#line 187
  if ((int )rtm->rtm_type != 1) {
    {
#line 189
    logit(7, 0, "NETLINK: route type is %d", (int )rtm->rtm_type);
    }
#line 191
    return (0);
  }
  {
#line 194
  memset((void *)(rta), 0, sizeof(rta));
#line 196
  parse_rtattr(rta, 17, (struct rtattr *)((char *)rtm + (((sizeof(struct rtmsg ) + 4UL) - 1UL) & 4294967292UL)),
               (int )((unsigned long )msglen - sizeof(*rtm)));
  }
#line 198
  if (rta[4]) {
#line 199
    ifindex = *((int *)((void *)((char *)rta[4] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
#line 201
    vifi = (vifi_t )0;
#line 201
    v = uvifs;
    {
#line 201
    while (1) {
      while_continue: /* CIL Label */ ;
#line 201
      if (! ((int )vifi < (int )numvifs)) {
#line 201
        goto while_break;
      }
#line 202
      if (v->uv_ifindex == ifindex) {
#line 203
        goto while_break;
      }
#line 201
      vifi = (vifi_t )((int )vifi + 1);
#line 201
      v ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 205
    if ((int )vifi >= (int )numvifs) {
      {
#line 206
      logit(4, 0, "NETLINK: ifindex=%d, but no vif", ifindex);
      }
#line 208
      return (0);
    }
    {
#line 211
    logit(7, 0, "NETLINK: vif %d, ifindex=%d", (int )vifi, ifindex);
    }
  } else {
    {
#line 213
    logit(4, 0, "NETLINK: no interface");
    }
#line 215
    return (0);
  }
#line 217
  if (rta[5]) {
    {
#line 218
    gw = *((__u32 *)((void *)((char *)rta[5] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
#line 220
    tmp___0 = inet_fmt(gw, s1, sizeof(s1));
#line 220
    logit(7, 0, "NETLINK: gateway is %s", tmp___0);
#line 221
    rpf->rpfneighbor.s_addr = gw;
    }
  } else {
#line 223
    rpf->rpfneighbor.s_addr = rpf->source.s_addr;
  }
#line 224
  rpf->iif = vifi;
#line 226
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 48 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
int log_nmsgs  =    0;
#line 49 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
unsigned long debug  =    0UL;
#line 53 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
static char dumpfilename[24]  = 
#line 53
  {      (char )'/',      (char )'v',      (char )'a',      (char )'r', 
        (char )'/',      (char )'r',      (char )'u',      (char )'n', 
        (char )'/',      (char )'p',      (char )'i',      (char )'m', 
        (char )'d',      (char )'/',      (char )'p',      (char )'i', 
        (char )'m',      (char )'d',      (char )'.',      (char )'d', 
        (char )'u',      (char )'m',      (char )'p',      (char )'\000'};
#line 54 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
static char cachefilename[25]  = 
#line 54
  {      (char )'/',      (char )'v',      (char )'a',      (char )'r', 
        (char )'/',      (char )'r',      (char )'u',      (char )'n', 
        (char )'/',      (char )'p',      (char )'i',      (char )'m', 
        (char )'d',      (char )'/',      (char )'p',      (char )'i', 
        (char )'m',      (char )'d',      (char )'.',      (char )'c', 
        (char )'a',      (char )'c',      (char )'h',      (char )'e', 
        (char )'\000'};
#line 59 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
static char unknown[60]  ;
#line 57 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
char *packet_kind(u_int proto , u_int type , u_int code ) 
{ 


  {
  {
#line 62
  if (proto == 2U) {
#line 62
    goto case_2;
  }
#line 112
  if (proto == 103U) {
#line 112
    goto case_103;
  }
#line 127
  goto switch_default___3;
  case_2: /* CIL Label */ 
  {
#line 64
  if (type == 17U) {
#line 64
    goto case_17;
  }
#line 65
  if (type == 18U) {
#line 65
    goto case_18;
  }
#line 66
  if (type == 22U) {
#line 66
    goto case_22;
  }
#line 67
  if (type == 23U) {
#line 67
    goto case_23;
  }
#line 68
  if (type == 19U) {
#line 68
    goto case_19;
  }
#line 85
  if (type == 20U) {
#line 85
    goto case_20;
  }
#line 106
  if (type == 31U) {
#line 106
    goto case_31;
  }
#line 107
  if (type == 30U) {
#line 107
    goto case_30;
  }
#line 108
  goto switch_default___1;
  case_17: /* CIL Label */ 
#line 64
  return ((char *)"IGMP Membership Query    ");
  case_18: /* CIL Label */ 
#line 65
  return ((char *)"IGMP v1 Member Report    ");
  case_22: /* CIL Label */ 
#line 66
  return ((char *)"IGMP v2 Member Report    ");
  case_23: /* CIL Label */ 
#line 67
  return ((char *)"IGMP Leave message       ");
  case_19: /* CIL Label */ 
  {
#line 70
  if (code == 1U) {
#line 70
    goto case_1;
  }
#line 71
  if (code == 2U) {
#line 71
    goto case_2___0;
  }
#line 72
  if (code == 3U) {
#line 72
    goto case_3;
  }
#line 73
  if (code == 4U) {
#line 73
    goto case_4;
  }
#line 74
  if (code == 5U) {
#line 74
    goto case_5;
  }
#line 75
  if (code == 6U) {
#line 75
    goto case_6;
  }
#line 76
  if (code == 7U) {
#line 76
    goto case_7;
  }
#line 77
  if (code == 8U) {
#line 77
    goto case_8;
  }
#line 78
  if (code == 9U) {
#line 78
    goto case_9;
  }
#line 79
  if (code == 10U) {
#line 79
    goto case_10;
  }
#line 80
  if (code == 11U) {
#line 80
    goto case_11;
  }
#line 81
  goto switch_default;
  case_1: /* CIL Label */ 
#line 70
  return ((char *)"DVMRP Neighbor Probe     ");
  case_2___0: /* CIL Label */ 
#line 71
  return ((char *)"DVMRP Route Report       ");
  case_3: /* CIL Label */ 
#line 72
  return ((char *)"DVMRP Neighbor Request   ");
  case_4: /* CIL Label */ 
#line 73
  return ((char *)"DVMRP Neighbor List      ");
  case_5: /* CIL Label */ 
#line 74
  return ((char *)"DVMRP Neighbor request 2 ");
  case_6: /* CIL Label */ 
#line 75
  return ((char *)"DVMRP Neighbor list 2    ");
  case_7: /* CIL Label */ 
#line 76
  return ((char *)"DVMRP Prune message      ");
  case_8: /* CIL Label */ 
#line 77
  return ((char *)"DVMRP Graft message      ");
  case_9: /* CIL Label */ 
#line 78
  return ((char *)"DVMRP Graft message ack  ");
  case_10: /* CIL Label */ 
#line 79
  return ((char *)"DVMRP Info Request       ");
  case_11: /* CIL Label */ 
#line 80
  return ((char *)"DVMRP Info Reply         ");
  switch_default: /* CIL Label */ 
  {
#line 82
  snprintf((char */* __restrict  */)(unknown), sizeof(unknown), (char const   */* __restrict  */)"UNKNOWN DVMRP message code = %3d ",
           code);
  }
#line 83
  return (unknown);
  switch_break___1: /* CIL Label */ ;
  }
  case_20: /* CIL Label */ 
  {
#line 93
  if (code == 0U) {
#line 93
    goto case_0;
  }
#line 94
  if (code == 1U) {
#line 94
    goto case_1___0;
  }
#line 95
  if (code == 2U) {
#line 95
    goto case_2___1;
  }
#line 96
  if (code == 3U) {
#line 96
    goto case_3___0;
  }
#line 97
  if (code == 4U) {
#line 97
    goto case_4___0;
  }
#line 99
  if (code == 5U) {
#line 99
    goto case_5___0;
  }
#line 100
  if (code == 6U) {
#line 100
    goto case_6___0;
  }
#line 101
  if (code == 7U) {
#line 101
    goto case_7___0;
  }
#line 102
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 93
  return ((char *)"PIM v1 Router-Query      ");
  case_1___0: /* CIL Label */ 
#line 94
  return ((char *)"PIM v1 Register          ");
  case_2___1: /* CIL Label */ 
#line 95
  return ((char *)"PIM v1 Register-Stop     ");
  case_3___0: /* CIL Label */ 
#line 96
  return ((char *)"PIM v1 Join/Prune        ");
  case_4___0: /* CIL Label */ 
#line 98
  return ((char *)"PIM v1 RP-Reachability   ");
  case_5___0: /* CIL Label */ 
#line 99
  return ((char *)"PIM v1 Assert            ");
  case_6___0: /* CIL Label */ 
#line 100
  return ((char *)"PIM v1 Graft             ");
  case_7___0: /* CIL Label */ 
#line 101
  return ((char *)"PIM v1 Graft_Ack         ");
  switch_default___0: /* CIL Label */ 
  {
#line 103
  snprintf((char */* __restrict  */)(unknown), sizeof(unknown), (char const   */* __restrict  */)"UNKNOWN PIM v1 message type =%3d ",
           code);
  }
#line 104
  return (unknown);
  switch_break___2: /* CIL Label */ ;
  }
  case_31: /* CIL Label */ 
#line 106
  return ((char *)"IGMP trace query         ");
  case_30: /* CIL Label */ 
#line 107
  return ((char *)"IGMP trace reply         ");
  switch_default___1: /* CIL Label */ 
  {
#line 109
  snprintf((char */* __restrict  */)(unknown), sizeof(unknown), (char const   */* __restrict  */)"UNKNOWN IGMP message: type = 0x%02x, code = 0x%02x ",
           type, code);
  }
#line 110
  return (unknown);
  switch_break___0: /* CIL Label */ ;
  }
  case_103: /* CIL Label */ 
  {
#line 114
  if (type == 0U) {
#line 114
    goto case_0___0;
  }
#line 115
  if (type == 1U) {
#line 115
    goto case_1___1;
  }
#line 116
  if (type == 2U) {
#line 116
    goto case_2___2;
  }
#line 117
  if (type == 3U) {
#line 117
    goto case_3___1;
  }
#line 118
  if (type == 4U) {
#line 118
    goto case_4___1;
  }
#line 119
  if (type == 5U) {
#line 119
    goto case_5___1;
  }
#line 120
  if (type == 6U) {
#line 120
    goto case_6___1;
  }
#line 121
  if (type == 7U) {
#line 121
    goto case_7___1;
  }
#line 122
  if (type == 8U) {
#line 122
    goto case_8___0;
  }
#line 123
  goto switch_default___2;
  case_0___0: /* CIL Label */ 
#line 114
  return ((char *)"PIM v2 Hello             ");
  case_1___1: /* CIL Label */ 
#line 115
  return ((char *)"PIM v2 Register          ");
  case_2___2: /* CIL Label */ 
#line 116
  return ((char *)"PIM v2 Register_Stop     ");
  case_3___1: /* CIL Label */ 
#line 117
  return ((char *)"PIM v2 Join/Prune        ");
  case_4___1: /* CIL Label */ 
#line 118
  return ((char *)"PIM v2 Bootstrap         ");
  case_5___1: /* CIL Label */ 
#line 119
  return ((char *)"PIM v2 Assert            ");
  case_6___1: /* CIL Label */ 
#line 120
  return ((char *)"PIM-DM v2 Graft          ");
  case_7___1: /* CIL Label */ 
#line 121
  return ((char *)"PIM-DM v2 Graft_Ack      ");
  case_8___0: /* CIL Label */ 
#line 122
  return ((char *)"PIM v2 Cand. RP Adv.     ");
  switch_default___2: /* CIL Label */ 
  {
#line 124
  snprintf((char */* __restrict  */)(unknown), sizeof(unknown), (char const   */* __restrict  */)"UNKNOWN PIM v2 message type =%3d ",
           type);
  }
#line 125
  return (unknown);
  switch_break___3: /* CIL Label */ ;
  }
  switch_default___3: /* CIL Label */ 
  {
#line 128
  snprintf((char */* __restrict  */)(unknown), sizeof(unknown), (char const   */* __restrict  */)"UNKNOWN proto =%3d               ",
           proto);
  }
#line 129
  return (unknown);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 137 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
int debug_kind(u_int proto , u_int type , u_int code ) 
{ 


  {
  {
#line 140
  if (proto == 2U) {
#line 140
    goto case_2;
  }
#line 178
  if (proto == 103U) {
#line 178
    goto case_103;
  }
#line 192
  goto switch_default___3;
  case_2: /* CIL Label */ 
  {
#line 142
  if (type == 17U) {
#line 142
    goto case_17;
  }
#line 143
  if (type == 18U) {
#line 143
    goto case_18;
  }
#line 144
  if (type == 22U) {
#line 144
    goto case_22;
  }
#line 145
  if (type == 23U) {
#line 145
    goto case_23;
  }
#line 146
  if (type == 19U) {
#line 146
    goto case_19;
  }
#line 161
  if (type == 20U) {
#line 161
    goto case_20;
  }
#line 174
  if (type == 31U) {
#line 174
    goto case_31;
  }
#line 175
  if (type == 30U) {
#line 175
    goto case_30;
  }
#line 176
  goto switch_default___1;
  case_17: /* CIL Label */ 
#line 142
  return (112);
  case_18: /* CIL Label */ 
#line 143
  return (112);
  case_22: /* CIL Label */ 
#line 144
  return (112);
  case_23: /* CIL Label */ 
#line 145
  return (112);
  case_19: /* CIL Label */ 
  {
#line 148
  if (code == 1U) {
#line 148
    goto case_1;
  }
#line 149
  if (code == 2U) {
#line 149
    goto case_2___0;
  }
#line 150
  if (code == 3U) {
#line 150
    goto case_3;
  }
#line 151
  if (code == 4U) {
#line 151
    goto case_4;
  }
#line 152
  if (code == 5U) {
#line 152
    goto case_5;
  }
#line 153
  if (code == 6U) {
#line 153
    goto case_6;
  }
#line 154
  if (code == 7U) {
#line 154
    goto case_7;
  }
#line 155
  if (code == 8U) {
#line 155
    goto case_8;
  }
#line 156
  if (code == 9U) {
#line 156
    goto case_9;
  }
#line 157
  if (code == 10U) {
#line 157
    goto case_10;
  }
#line 158
  if (code == 11U) {
#line 158
    goto case_11;
  }
#line 159
  goto switch_default;
  case_1: /* CIL Label */ 
#line 148
  return (4);
  case_2___0: /* CIL Label */ 
#line 149
  return (2);
  case_3: /* CIL Label */ 
#line 150
  return (0);
  case_4: /* CIL Label */ 
#line 151
  return (0);
  case_5: /* CIL Label */ 
#line 152
  return (0);
  case_6: /* CIL Label */ 
#line 153
  return (0);
  case_7: /* CIL Label */ 
#line 154
  return (1);
  case_8: /* CIL Label */ 
#line 155
  return (1);
  case_9: /* CIL Label */ 
#line 156
  return (1);
  case_10: /* CIL Label */ 
#line 157
  return (0);
  case_11: /* CIL Label */ 
#line 158
  return (0);
  switch_default: /* CIL Label */ 
#line 159
  return (0);
  switch_break___1: /* CIL Label */ ;
  }
  case_20: /* CIL Label */ 
  {
#line 164
  if (code == 0U) {
#line 164
    goto case_0;
  }
#line 165
  if (code == 1U) {
#line 165
    goto case_1___0;
  }
#line 166
  if (code == 2U) {
#line 166
    goto case_2___1;
  }
#line 167
  if (code == 3U) {
#line 167
    goto case_3___0;
  }
#line 168
  if (code == 4U) {
#line 168
    goto case_4___0;
  }
#line 169
  if (code == 5U) {
#line 169
    goto case_5___0;
  }
#line 170
  if (code == 6U) {
#line 170
    goto case_6___0;
  }
#line 171
  if (code == 7U) {
#line 171
    goto case_7___0;
  }
#line 172
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 164
  return (8372224);
  case_1___0: /* CIL Label */ 
#line 165
  return (8372224);
  case_2___1: /* CIL Label */ 
#line 166
  return (8372224);
  case_3___0: /* CIL Label */ 
#line 167
  return (8372224);
  case_4___0: /* CIL Label */ 
#line 168
  return (8372224);
  case_5___0: /* CIL Label */ 
#line 169
  return (8372224);
  case_6___0: /* CIL Label */ 
#line 170
  return (8372224);
  case_7___0: /* CIL Label */ 
#line 171
  return (8372224);
  switch_default___0: /* CIL Label */ 
#line 172
  return (8372224);
  switch_break___2: /* CIL Label */ ;
  }
  case_31: /* CIL Label */ 
#line 174
  return (128);
  case_30: /* CIL Label */ 
#line 175
  return (128);
  switch_default___1: /* CIL Label */ 
#line 176
  return (112);
  switch_break___0: /* CIL Label */ ;
  }
  case_103: /* CIL Label */ 
  {
#line 181
  if (type == 0U) {
#line 181
    goto case_0___0;
  }
#line 182
  if (type == 1U) {
#line 182
    goto case_1___1;
  }
#line 183
  if (type == 2U) {
#line 183
    goto case_2___2;
  }
#line 184
  if (type == 3U) {
#line 184
    goto case_3___1;
  }
#line 185
  if (type == 4U) {
#line 185
    goto case_4___1;
  }
#line 186
  if (type == 5U) {
#line 186
    goto case_5___1;
  }
#line 187
  if (type == 6U) {
#line 187
    goto case_6___1;
  }
#line 188
  if (type == 7U) {
#line 188
    goto case_7___1;
  }
#line 189
  if (type == 8U) {
#line 189
    goto case_8___0;
  }
#line 190
  goto switch_default___2;
  case_0___0: /* CIL Label */ 
#line 181
  return (8372224);
  case_1___1: /* CIL Label */ 
#line 182
  return (32768);
  case_2___2: /* CIL Label */ 
#line 183
  return (32768);
  case_3___1: /* CIL Label */ 
#line 184
  return (8372224);
  case_4___1: /* CIL Label */ 
#line 185
  return (131072);
  case_5___1: /* CIL Label */ 
#line 186
  return (8372224);
  case_6___1: /* CIL Label */ 
#line 187
  return (8372224);
  case_7___1: /* CIL Label */ 
#line 188
  return (8372224);
  case_8___0: /* CIL Label */ 
#line 189
  return (524288);
  switch_default___2: /* CIL Label */ 
#line 190
  return (8372224);
  switch_break___3: /* CIL Label */ ;
  }
  switch_default___3: /* CIL Label */ 
#line 192
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 194
  return (0);
}
}
#line 204 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
int log_level(u_int proto , u_int type , u_int code ) 
{ 


  {
  {
#line 209
  if (proto == 2U) {
#line 209
    goto case_2;
  }
#line 230
  if (proto == 103U) {
#line 230
    goto case_103;
  }
#line 236
  goto switch_default___2;
  case_2: /* CIL Label */ 
  {
#line 211
  if (type == 30U) {
#line 211
    goto case_30;
  }
#line 214
  if (type == 19U) {
#line 214
    goto case_19;
  }
#line 220
  if (type == 20U) {
#line 220
    goto case_20;
  }
#line 226
  goto switch_default___0;
  case_30: /* CIL Label */ 
#line 212
  return (6);
  case_19: /* CIL Label */ 
  {
#line 217
  if (code == 6U) {
#line 217
    goto case_6;
  }
#line 217
  if (code == 4U) {
#line 217
    goto case_6;
  }
#line 215
  goto switch_break___1;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 218
  return (6);
  switch_break___1: /* CIL Label */ ;
  }
  case_20: /* CIL Label */ 
  {
#line 223
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 224
  return (6);
  switch_break___2: /* CIL Label */ ;
  }
  switch_default___0: /* CIL Label */ 
#line 227
  return (4);
  switch_break___0: /* CIL Label */ ;
  }
  case_103: /* CIL Label */ 
  {
#line 233
  goto switch_default___1;
  switch_default___1: /* CIL Label */ 
#line 234
  return (6);
  switch_break___3: /* CIL Label */ ;
  }
  switch_default___2: /* CIL Label */ 
#line 237
  return (4);
  switch_break: /* CIL Label */ ;
  }
#line 239
  return (4);
}
}
#line 258 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
void fdump(int i  __attribute__((__unused__)) ) 
{ 
  FILE *fp ;

  {
  {
#line 262
  fp = fopen((char const   */* __restrict  */)(dumpfilename), (char const   */* __restrict  */)"w");
  }
#line 263
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 264
    dump_vifs(fp);
#line 265
    dump_pim_mrt(fp);
#line 266
    fclose(fp);
    }
  }
#line 268
  return;
}
}
#line 274 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
void cdump(int i  __attribute__((__unused__)) ) 
{ 
  FILE *fp ;

  {
  {
#line 278
  fp = fopen((char const   */* __restrict  */)(cachefilename), (char const   */* __restrict  */)"w");
  }
#line 279
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 283
    fclose(fp);
    }
  }
#line 285
  return;
}
}
#line 287 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
void dump_vifs(FILE *fp ) 
{ 
  vifi_t vifi ;
  register struct uvif *v ;
  pim_nbr_entry_t *n ;
  int width ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 295
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nVirtual Interface Table\n %-3s  %-15s  %-20s %-8s %-14s %s",
          "Vif", "Local-Address", "Subnet", "Thresh", "Flags", "Neighbors\n");
#line 299
  vifi = (vifi_t )0;
#line 299
  v = uvifs;
  }
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((int )vifi < (int )numvifs)) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp = inet_fmt(v->uv_lcl_addr, s1, sizeof(s1));
#line 300
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %3u  %-15s  ",
            (int )vifi, tmp);
    }
#line 301
    if (v->uv_flags & 4U) {
      {
#line 302
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-20s ",
              v->uv_name);
      }
    } else {
      {
#line 304
      tmp___0 = netname(v->uv_subnet, v->uv_subnetmask);
#line 304
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-20.20s ",
              tmp___0);
      }
    }
    {
#line 305
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-5u   ",
            (int )v->uv_threshold);
#line 307
    width = 0;
    }
#line 308
    if (v->uv_flags & 512U) {
      {
#line 309
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" DISABLED");
      }
    }
#line 310
    if (v->uv_flags & 256U) {
      {
#line 311
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" DOWN");
      }
    }
#line 312
    if (v->uv_flags & 262144U) {
      {
#line 313
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" DR");
#line 314
      width += 3;
      }
    }
#line 316
    if (v->uv_flags & 2097152U) {
      {
#line 317
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" PIM");
#line 318
      width += 4;
      }
    }
#line 320
    if (v->uv_flags & 4194304U) {
      {
#line 321
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" DVMRP");
#line 322
      width += 6;
      }
    }
#line 324
    if (v->uv_flags & 524288U) {
      {
#line 325
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-12s",
              "NO-NBR");
#line 326
      width += 6;
      }
    }
#line 329
    n = v->uv_pim_neighbors;
#line 329
    if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 331
      i = width;
      {
#line 331
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 331
        if (! (i <= 15)) {
#line 331
          goto while_break___0;
        }
        {
#line 332
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 331
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 333
      tmp___1 = inet_fmt(n->address, s1, sizeof(s1));
#line 333
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-15s\n",
              tmp___1);
#line 334
      n = n->next;
      }
      {
#line 334
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 334
        if (! ((unsigned long )n != (unsigned long )((void *)0))) {
#line 334
          goto while_break___1;
        }
        {
#line 335
        tmp___2 = inet_fmt(n->address, s1, sizeof(s1));
#line 335
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%64s %-15s\n",
                "", tmp___2);
#line 334
        n = n->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 339
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
      }
    }
#line 299
    vifi = (vifi_t )((int )vifi + 1);
#line 299
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 341
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
#line 342
  return;
}
}
#line 353 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
static char fmt[211]  = 
#line 353
  {      (char )'w',      (char )'a',      (char )'r',      (char )'n', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'-',      (char )' ',      (char )'\000'};
#line 350 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
void logit(int severity , int syserr , char const   *format  , ...) 
{ 
  va_list ap ;
  char *msg ;
  struct timeval now ;
  struct tm *thyme ;
  time_t lt ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 359
  __builtin_va_start(ap, format);
#line 360
  vsnprintf((char */* __restrict  */)(& fmt[10]), sizeof(fmt) - 10UL, (char const   */* __restrict  */)format,
            ap);
#line 361
  __builtin_va_end(ap);
  }
#line 362
  if (severity == 4) {
#line 362
    msg = fmt;
  } else {
#line 362
    msg = & fmt[10];
  }
#line 368
  if (haveterminal) {
#line 368
    if (debug) {
#line 368
      goto _L;
    } else
#line 368
    if (severity <= 4) {
      _L: /* CIL Label */ 
      {
#line 369
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 370
      lt = now.tv_sec;
#line 371
      thyme = localtime((time_t const   *)(& lt));
      }
#line 373
      if (! debug) {
        {
#line 374
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                __progname);
        }
      }
      {
#line 375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02d:%02d:%02d.%03ld %s",
              thyme->tm_hour, thyme->tm_min, thyme->tm_sec, now.tv_usec / 1000L, msg);
      }
#line 377
      if (syserr == 0) {
        {
#line 378
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 380
        tmp = strerror(syserr);
#line 380
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)":(error %d): %s\n",
                syserr, tmp);
        }
      }
    }
  }
#line 391
  if (severity < 4) {
#line 391
    goto _L___0;
  } else
#line 391
  if (log_nmsgs < 20) {
    _L___0: /* CIL Label */ 
#line 392
    if (severity < 7) {
#line 393
      log_nmsgs ++;
    }
#line 394
    if (syserr != 0) {
      {
#line 395
      tmp___0 = __errno_location();
#line 395
      *tmp___0 = syserr;
#line 396
      tmp___1 = strerror(syserr);
#line 396
      syslog(severity, "%s: %s", msg, tmp___1);
      }
    } else {
      {
#line 398
      syslog(severity, "%s", msg);
      }
    }
  }
#line 402
  if (severity <= 3) {
    {
#line 402
    exit(-1);
    }
  }
#line 403
  return;
}
}
#line 406 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
void dump_pim_mrt(FILE *fp ) 
{ 
  grpentry_t *g ;
  register mrtentry_t *r ;
  register vifi_t vifi ;
  u_int number_of_cache_mirrors ;
  u_int number_of_groups ;
  char oifs[(sizeof(vifbitmap_t ) << 3) + 1UL] ;
  char joined_oifs[(sizeof(vifbitmap_t ) << 3) + 1UL] ;
  char pruned_oifs[(sizeof(vifbitmap_t ) << 3) + 1UL] ;
  char leaves_oifs[(sizeof(vifbitmap_t ) << 3) + 1UL] ;
  char asserted_oifs[(sizeof(vifbitmap_t ) << 3) + 1UL] ;
  char incoming_iif[(sizeof(vifbitmap_t ) << 3) + 1UL] ;
  cand_rp_t *rp ;
  kernel_cache_t *kernel_cache ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 411
  number_of_cache_mirrors = (u_int )0;
#line 412
  number_of_groups = (u_int )0;
#line 422
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Multicast Routing Table\n%s",
          " Source          Group           RP-addr         Flags\n");
#line 426
  g = grplist->next;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! ((unsigned long )g != (unsigned long )((grpentry_t *)((void *)0)))) {
#line 426
      goto while_break;
    }
#line 427
    number_of_groups ++;
#line 428
    r = g->grp_route;
#line 428
    if ((unsigned long )r != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 429
      if ((int )r->flags & 512) {
#line 430
        kernel_cache = r->kernel_cache;
        {
#line 430
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 430
          if (! ((unsigned long )kernel_cache != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 430
            goto while_break___0;
          }
#line 433
          number_of_cache_mirrors ++;
#line 430
          kernel_cache = kernel_cache->next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 437
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"---------------------------(*,G)----------------------------\n");
#line 438
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-15s",
              "INADDR_ANY");
#line 439
      tmp = inet_fmt(g->group, s1, sizeof(s1));
#line 439
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-15s",
              tmp);
      }
#line 440
      if (g->active_rp_grp) {
        {
#line 440
        tmp___0 = inet_fmt(g->rpaddr, s2, sizeof(s2));
#line 440
        tmp___1 = (char const   *)tmp___0;
        }
      } else {
#line 440
        tmp___1 = "NULL";
      }
      {
#line 440
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-15s",
              tmp___1);
#line 443
      vifi = (vifi_t )0;
      }
      {
#line 443
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 443
        if (! ((int )vifi < (int )numvifs)) {
#line 443
          goto while_break___1;
        }
#line 444
        if (r->oifs & (unsigned long )(1 << (int )vifi)) {
#line 444
          oifs[vifi] = (char )'o';
        } else {
#line 444
          oifs[vifi] = (char )'.';
        }
#line 446
        if (r->joined_oifs & (unsigned long )(1 << (int )vifi)) {
#line 446
          joined_oifs[vifi] = (char )'j';
        } else {
#line 446
          joined_oifs[vifi] = (char )'.';
        }
#line 448
        if (r->pruned_oifs & (unsigned long )(1 << (int )vifi)) {
#line 448
          pruned_oifs[vifi] = (char )'p';
        } else {
#line 448
          pruned_oifs[vifi] = (char )'.';
        }
#line 450
        if (r->leaves & (unsigned long )(1 << (int )vifi)) {
#line 450
          leaves_oifs[vifi] = (char )'l';
        } else {
#line 450
          leaves_oifs[vifi] = (char )'.';
        }
#line 452
        if (r->asserted_oifs & (unsigned long )(1 << (int )vifi)) {
#line 452
          asserted_oifs[vifi] = (char )'a';
        } else {
#line 452
          asserted_oifs[vifi] = (char )'.';
        }
#line 454
        incoming_iif[vifi] = (char )'.';
#line 443
        vifi = (vifi_t )((int )vifi + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 456
      oifs[vifi] = (char)0;
#line 457
      joined_oifs[vifi] = (char)0;
#line 458
      pruned_oifs[vifi] = (char)0;
#line 459
      leaves_oifs[vifi] = (char)0;
#line 460
      asserted_oifs[vifi] = (char)0;
#line 461
      incoming_iif[vifi] = (char)0;
#line 462
      incoming_iif[r->incoming] = (char )'I';
#line 465
      if ((int )r->flags & 1) {
        {
#line 465
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" SPT");
        }
      }
#line 466
      if ((int )r->flags & 2) {
        {
#line 466
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" WC");
        }
      }
#line 467
      if ((int )r->flags & 4) {
        {
#line 467
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" RP");
        }
      }
#line 468
      if ((int )r->flags & 128) {
        {
#line 468
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" REG");
        }
      }
#line 469
      if ((int )r->flags & 32) {
        {
#line 469
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" IIF_REG");
        }
      }
#line 470
      if ((int )r->flags & 1024) {
        {
#line 470
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" NULL_OIF");
        }
      }
#line 471
      if ((int )r->flags & 512) {
        {
#line 471
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" CACHE");
        }
      }
#line 472
      if ((int )r->flags & 4096) {
        {
#line 472
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ASSERTED");
        }
      }
#line 473
      if ((int )r->flags & 2048) {
        {
#line 473
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" REG_SUPP");
        }
      }
#line 474
      if ((int )r->flags & 8192) {
        {
#line 474
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" SG");
        }
      }
#line 475
      if ((int )r->flags & 16384) {
        {
#line 475
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" PMBR");
        }
      }
      {
#line 476
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 478
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Joined   oifs: %-20s\n",
              joined_oifs);
#line 479
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Pruned   oifs: %-20s\n",
              pruned_oifs);
#line 480
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Leaves   oifs: %-20s\n",
              leaves_oifs);
#line 481
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Asserted oifs: %-20s\n",
              asserted_oifs);
#line 482
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Outgoing oifs: %-20s\n",
              oifs);
#line 483
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Incoming     : %-20s\n",
              incoming_iif);
#line 485
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nTIMERS:  Entry   JP   RS Assert VIFS:");
#line 486
      vifi = (vifi_t )0;
      }
      {
#line 486
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 486
        if (! ((int )vifi < (int )numvifs)) {
#line 486
          goto while_break___2;
        }
        {
#line 487
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %d",
                (int )vifi);
#line 486
        vifi = (vifi_t )((int )vifi + 1);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 488
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n           %d     %d    %d    %d        ",
              (int )r->timer, (int )r->jp_timer, (int )r->rs_timer, r->assert_timer);
#line 490
      vifi = (vifi_t )0;
      }
      {
#line 490
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 490
        if (! ((int )vifi < (int )numvifs)) {
#line 490
          goto while_break___3;
        }
        {
#line 491
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %d",
                (int )*(r->vif_timers + vifi));
#line 490
        vifi = (vifi_t )((int )vifi + 1);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 492
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
      }
    }
#line 496
    r = g->mrtlink;
    {
#line 496
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 496
      if (! ((unsigned long )r != (unsigned long )((mrtentry_t *)((void *)0)))) {
#line 496
        goto while_break___4;
      }
      {
#line 497
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"---------------------------(S,G)----------------------------\n");
      }
#line 498
      if ((int )r->flags & 512) {
#line 499
        number_of_cache_mirrors ++;
      }
      {
#line 502
      tmp___2 = inet_fmt((r->source)->address, s1, sizeof(s1));
#line 502
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-15s",
              tmp___2);
#line 503
      tmp___3 = inet_fmt(g->group, s2, sizeof(s2));
#line 503
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-15s",
              tmp___3);
      }
#line 504
      if (g->active_rp_grp) {
        {
#line 504
        tmp___4 = inet_fmt(g->rpaddr, s2, sizeof(s2));
#line 504
        tmp___5 = (char const   *)tmp___4;
        }
      } else {
#line 504
        tmp___5 = "NULL";
      }
      {
#line 504
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-15s",
              tmp___5);
#line 507
      vifi = (vifi_t )0;
      }
      {
#line 507
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 507
        if (! ((int )vifi < (int )numvifs)) {
#line 507
          goto while_break___5;
        }
#line 508
        if (r->oifs & (unsigned long )(1 << (int )vifi)) {
#line 508
          oifs[vifi] = (char )'o';
        } else {
#line 508
          oifs[vifi] = (char )'.';
        }
#line 510
        if (r->joined_oifs & (unsigned long )(1 << (int )vifi)) {
#line 510
          joined_oifs[vifi] = (char )'j';
        } else {
#line 510
          joined_oifs[vifi] = (char )'.';
        }
#line 512
        if (r->pruned_oifs & (unsigned long )(1 << (int )vifi)) {
#line 512
          pruned_oifs[vifi] = (char )'p';
        } else {
#line 512
          pruned_oifs[vifi] = (char )'.';
        }
#line 514
        if (r->leaves & (unsigned long )(1 << (int )vifi)) {
#line 514
          leaves_oifs[vifi] = (char )'l';
        } else {
#line 514
          leaves_oifs[vifi] = (char )'.';
        }
#line 516
        if (r->asserted_oifs & (unsigned long )(1 << (int )vifi)) {
#line 516
          asserted_oifs[vifi] = (char )'a';
        } else {
#line 516
          asserted_oifs[vifi] = (char )'.';
        }
#line 518
        incoming_iif[vifi] = (char )'.';
#line 507
        vifi = (vifi_t )((int )vifi + 1);
      }
      while_break___5: /* CIL Label */ ;
      }
#line 520
      oifs[vifi] = (char)0;
#line 521
      joined_oifs[vifi] = (char)0;
#line 522
      pruned_oifs[vifi] = (char)0;
#line 523
      leaves_oifs[vifi] = (char)0;
#line 524
      asserted_oifs[vifi] = (char)0;
#line 525
      incoming_iif[vifi] = (char)0;
#line 526
      incoming_iif[r->incoming] = (char )'I';
#line 529
      if ((int )r->flags & 1) {
        {
#line 529
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" SPT");
        }
      }
#line 530
      if ((int )r->flags & 2) {
        {
#line 530
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" WC");
        }
      }
#line 531
      if ((int )r->flags & 4) {
        {
#line 531
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" RP");
        }
      }
#line 532
      if ((int )r->flags & 128) {
        {
#line 532
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" REG");
        }
      }
#line 533
      if ((int )r->flags & 32) {
        {
#line 533
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" IIF_REG");
        }
      }
#line 534
      if ((int )r->flags & 1024) {
        {
#line 534
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" NULL_OIF");
        }
      }
#line 535
      if ((int )r->flags & 512) {
        {
#line 535
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" CACHE");
        }
      }
#line 536
      if ((int )r->flags & 4096) {
        {
#line 536
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ASSERTED");
        }
      }
#line 537
      if ((int )r->flags & 2048) {
        {
#line 537
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" REG_SUPP");
        }
      }
#line 538
      if ((int )r->flags & 8192) {
        {
#line 538
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" SG");
        }
      }
#line 539
      if ((int )r->flags & 16384) {
        {
#line 539
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" PMBR");
        }
      }
      {
#line 540
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 542
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Joined   oifs: %-20s\n",
              joined_oifs);
#line 543
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Pruned   oifs: %-20s\n",
              pruned_oifs);
#line 544
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Leaves   oifs: %-20s\n",
              leaves_oifs);
#line 545
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Asserted oifs: %-20s\n",
              asserted_oifs);
#line 546
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Outgoing oifs: %-20s\n",
              oifs);
#line 547
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Incoming     : %-20s\n",
              incoming_iif);
#line 549
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nTIMERS:  Entry   JP   RS Assert VIFS:");
#line 550
      vifi = (vifi_t )0;
      }
      {
#line 550
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 550
        if (! ((int )vifi < (int )numvifs)) {
#line 550
          goto while_break___6;
        }
        {
#line 551
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %d",
                (int )vifi);
#line 550
        vifi = (vifi_t )((int )vifi + 1);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 552
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n           %d    %d    %d    %d        ",
              (int )r->timer, (int )r->jp_timer, (int )r->rs_timer, r->assert_timer);
#line 554
      vifi = (vifi_t )0;
      }
      {
#line 554
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 554
        if (! ((int )vifi < (int )numvifs)) {
#line 554
          goto while_break___7;
        }
        {
#line 555
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d",
                (int )*(r->vif_timers + vifi));
#line 554
        vifi = (vifi_t )((int )vifi + 1);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 556
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 496
      r = r->grpnext;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 426
    g = g->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 561
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"--------------------------(*,*,RP)--------------------------\n");
#line 562
  rp = cand_rp_list;
  }
  {
#line 562
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 562
    if (! ((unsigned long )rp != (unsigned long )((cand_rp_t *)((void *)0)))) {
#line 562
      goto while_break___8;
    }
#line 563
    r = (rp->rpentry)->mrtlink;
#line 563
    if ((unsigned long )r != (unsigned long )((mrtentry_t *)((void *)0))) {
#line 564
      if ((int )r->flags & 512) {
#line 565
        kernel_cache = r->kernel_cache;
        {
#line 565
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 565
          if (! ((unsigned long )kernel_cache != (unsigned long )((kernel_cache_t *)((void *)0)))) {
#line 565
            goto while_break___9;
          }
#line 568
          number_of_cache_mirrors ++;
#line 565
          kernel_cache = kernel_cache->next;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      {
#line 572
      tmp___6 = inet_fmt((r->source)->address, s1, sizeof(s1));
#line 572
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" RP = %-15s",
              tmp___6);
#line 573
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %-15s",
              "INADDR_ANY");
#line 575
      vifi = (vifi_t )0;
      }
      {
#line 575
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 575
        if (! ((int )vifi < (int )numvifs)) {
#line 575
          goto while_break___10;
        }
#line 576
        if (r->oifs & (unsigned long )(1 << (int )vifi)) {
#line 576
          oifs[vifi] = (char )'o';
        } else {
#line 576
          oifs[vifi] = (char )'.';
        }
#line 578
        if (r->joined_oifs & (unsigned long )(1 << (int )vifi)) {
#line 578
          joined_oifs[vifi] = (char )'j';
        } else {
#line 578
          joined_oifs[vifi] = (char )'.';
        }
#line 580
        if (r->pruned_oifs & (unsigned long )(1 << (int )vifi)) {
#line 580
          pruned_oifs[vifi] = (char )'p';
        } else {
#line 580
          pruned_oifs[vifi] = (char )'.';
        }
#line 582
        if (r->leaves & (unsigned long )(1 << (int )vifi)) {
#line 582
          leaves_oifs[vifi] = (char )'l';
        } else {
#line 582
          leaves_oifs[vifi] = (char )'.';
        }
#line 584
        if (r->asserted_oifs & (unsigned long )(1 << (int )vifi)) {
#line 584
          asserted_oifs[vifi] = (char )'a';
        } else {
#line 584
          asserted_oifs[vifi] = (char )'.';
        }
#line 586
        incoming_iif[vifi] = (char )'.';
#line 575
        vifi = (vifi_t )((int )vifi + 1);
      }
      while_break___10: /* CIL Label */ ;
      }
#line 588
      oifs[vifi] = (char)0;
#line 589
      joined_oifs[vifi] = (char)0;
#line 590
      pruned_oifs[vifi] = (char)0;
#line 591
      leaves_oifs[vifi] = (char)0;
#line 592
      asserted_oifs[vifi] = (char)0;
#line 593
      incoming_iif[vifi] = (char)0;
#line 594
      incoming_iif[r->incoming] = (char )'I';
#line 597
      if ((int )r->flags & 1) {
        {
#line 597
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" SPT");
        }
      }
#line 598
      if ((int )r->flags & 2) {
        {
#line 598
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" WC");
        }
      }
#line 599
      if ((int )r->flags & 4) {
        {
#line 599
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" RP");
        }
      }
#line 600
      if ((int )r->flags & 128) {
        {
#line 600
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" REG");
        }
      }
#line 601
      if ((int )r->flags & 32) {
        {
#line 601
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" IIF_REG");
        }
      }
#line 602
      if ((int )r->flags & 1024) {
        {
#line 602
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" NULL_OIF");
        }
      }
#line 603
      if ((int )r->flags & 512) {
        {
#line 603
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" CACHE");
        }
      }
#line 604
      if ((int )r->flags & 4096) {
        {
#line 604
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ASSERTED");
        }
      }
#line 605
      if ((int )r->flags & 2048) {
        {
#line 605
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" REG_SUPP");
        }
      }
#line 606
      if ((int )r->flags & 8192) {
        {
#line 606
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" SG");
        }
      }
#line 607
      if ((int )r->flags & 16384) {
        {
#line 607
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" PMBR");
        }
      }
      {
#line 608
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 610
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Joined   oifs: %-20s\n",
              joined_oifs);
#line 611
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Pruned   oifs: %-20s\n",
              pruned_oifs);
#line 612
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Leaves   oifs: %-20s\n",
              leaves_oifs);
#line 613
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Asserted oifs: %-20s\n",
              asserted_oifs);
#line 614
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Outgoing oifs: %-20s\n",
              oifs);
#line 615
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Incoming     : %-20s\n",
              incoming_iif);
#line 617
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nTIMERS:  Entry   JP   RS Assert VIFS:");
#line 618
      vifi = (vifi_t )0;
      }
      {
#line 618
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 618
        if (! ((int )vifi < (int )numvifs)) {
#line 618
          goto while_break___11;
        }
        {
#line 619
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %d",
                (int )vifi);
#line 618
        vifi = (vifi_t )((int )vifi + 1);
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 620
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n           %d    %d    %d    %d        ",
              (int )r->timer, (int )r->jp_timer, (int )r->rs_timer, r->assert_timer);
#line 622
      vifi = (vifi_t )0;
      }
      {
#line 622
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 622
        if (! ((int )vifi < (int )numvifs)) {
#line 622
          goto while_break___12;
        }
        {
#line 623
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %d",
                (int )*(r->vif_timers + vifi));
#line 622
        vifi = (vifi_t )((int )vifi + 1);
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 624
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
      }
    }
#line 562
    rp = rp->next;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 628
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Number of Groups: %u\n",
          number_of_groups);
#line 629
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Number of Cache MIRRORs: %u\n\n",
          number_of_cache_mirrors);
  }
#line 630
  return;
}
}
#line 637 "/home/wheatley/newnew/temp/pimd-2.1.8/debug.c"
int dump_rp_set(FILE *fp ) 
{ 
  cand_rp_t *rp ;
  rp_grp_entry_t *rp_grp_entry ;
  grp_mask_t *grp_mask ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 643
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"---------------------------RP-Set----------------------------\n");
#line 644
  tmp = inet_fmt(curr_bsr_address, s1, sizeof(s1));
#line 644
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Current BSR address: %s\n",
          tmp);
#line 645
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"RP-address      Incoming   Group prefix   Priority   Holdtime \n");
#line 647
  rp = cand_rp_list;
  }
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! ((unsigned long )rp != (unsigned long )((cand_rp_t *)((void *)0)))) {
#line 647
      goto while_break;
    }
    {
#line 648
    tmp___0 = inet_fmt((rp->rpentry)->address, s1, sizeof(s1));
#line 648
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-15s %-3d        ",
            tmp___0, (int )(rp->rpentry)->incoming);
#line 650
    rp_grp_entry = rp->rp_grp_next;
    }
#line 650
    if ((unsigned long )rp_grp_entry != (unsigned long )((rp_grp_entry_t *)((void *)0))) {
      {
#line 651
      grp_mask = rp_grp_entry->group;
#line 652
      tmp___1 = netname(grp_mask->group_addr, grp_mask->group_mask);
#line 652
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-14.14s %-3u        %-3u\n",
              tmp___1, (int )rp_grp_entry->priority, (int )rp_grp_entry->holdtime);
#line 656
      rp_grp_entry = rp_grp_entry->rp_grp_next;
      }
      {
#line 656
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 656
        if (! ((unsigned long )rp_grp_entry != (unsigned long )((rp_grp_entry_t *)((void *)0)))) {
#line 656
          goto while_break___0;
        }
        {
#line 659
        grp_mask = rp_grp_entry->group;
#line 660
        tmp___2 = netname(grp_mask->group_addr, grp_mask->group_mask);
#line 660
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-14.14s %-3u        %-3u\n",
                tmp___2, (int )rp_grp_entry->priority, (int )rp_grp_entry->holdtime);
#line 656
        rp_grp_entry = rp_grp_entry->rp_grp_next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 647
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  return (1);
}
}
