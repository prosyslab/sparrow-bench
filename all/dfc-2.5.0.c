/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 29 "/usr/include/x86_64-linux-gnu/bits/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsfilcnt_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.h"
struct fsmntinfo {
   char *fsname ;
   char *dir ;
   char *type ;
   char *opts ;
   unsigned long bsize ;
   unsigned long frsize ;
   unsigned long blocks ;
   unsigned long bfree ;
   unsigned long bavail ;
   unsigned long files ;
   unsigned long ffree ;
   unsigned long favail ;
   struct fsmntinfo *next ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.h"
struct list {
   struct fsmntinfo *head ;
   struct fsmntinfo *tail ;
   int fsmaxlen ;
   int dirmaxlen ;
   int typemaxlen ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts )  __asm__("__posix_getopt")  ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 899
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2,3), __leaf__)) getsubopt)(char ** __restrict  __optionp ,
                                                                                                    char * const  * __restrict  __tokens ,
                                                                                                    char ** __restrict  __valuep ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 71 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 51 "/usr/include/x86_64-linux-gnu/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statvfs)(char const   * __restrict  __file ,
                                                                                                struct statvfs * __restrict  __buf ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int aflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int bflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int cflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int fflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int hflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int iflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int mflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int nflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int oflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int sflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int tflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int uflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int vflag  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int wflag  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int Tflag  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
int Wflag  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/extern.h"
char unitflag  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.h"
void init_queue(struct list *lst ) ;
#line 78
int enqueue(struct list *lst , struct fsmntinfo fmi ) ;
#line 79
struct fsmntinfo fmi_init(void) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/util.h"
int imax(int a , int b ) ;
#line 40
char *shortenstr(char *str , int len ) ;
#line 41
unsigned int getttywidth(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.h"
void disp(struct list *lst , char *fsfilter ) ;
#line 50
void change_color(double perct ) ;
#line 51
void reset_color(void) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/dfc.h"
void usage(int status ) ;
#line 43
void fetch_info(struct list *lst ) ;
#line 44
double cvrt(double n ) ;
#line 45
void humanize(double n , double perct ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/dfc.c"
int main(int argc , char **argv ) 
{ 
  struct list queue ;
  int ch ;
  unsigned int width ;
  char *fsfilter ;
  char *subopts ;
  char *value ;
  char *unit_opts[11] ;
  char *color_opts[4] ;
  int tmp ;
  int tmp___0 ;

  {
#line 78
  fsfilter = (char *)((void *)0);
#line 82
  unit_opts[0] = (char *)"h";
#line 82
  unit_opts[1] = (char *)"b";
#line 82
  unit_opts[2] = (char *)"k";
#line 82
  unit_opts[3] = (char *)"m";
#line 82
  unit_opts[4] = (char *)"g";
#line 82
  unit_opts[5] = (char *)"t";
#line 82
  unit_opts[6] = (char *)"p";
#line 82
  unit_opts[7] = (char *)"e";
#line 82
  unit_opts[8] = (char *)"z";
#line 82
  unit_opts[9] = (char *)"y";
#line 82
  unit_opts[10] = (char *)((void *)0);
#line 106
  color_opts[0] = (char *)"always";
#line 106
  color_opts[1] = (char *)"never";
#line 106
  color_opts[2] = (char *)"auto";
#line 106
  color_opts[3] = (char *)((void *)0);
#line 118
  cflag = 1;
#line 125
  unitflag = (char )'h';
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    ch = getopt(argc, (char * const  *)argv, "abc:fhimnost:Tu:vwW");
    }
#line 127
    if (! (ch != -1)) {
#line 127
      goto while_break;
    }
    {
#line 129
    if (ch == 97) {
#line 129
      goto case_97;
    }
#line 132
    if (ch == 98) {
#line 132
      goto case_98;
    }
#line 135
    if (ch == 99) {
#line 135
      goto case_99;
    }
#line 157
    if (ch == 102) {
#line 157
      goto case_102;
    }
#line 160
    if (ch == 104) {
#line 160
      goto case_104;
    }
#line 163
    if (ch == 105) {
#line 163
      goto case_105;
    }
#line 166
    if (ch == 109) {
#line 166
      goto case_109;
    }
#line 169
    if (ch == 110) {
#line 169
      goto case_110;
    }
#line 172
    if (ch == 111) {
#line 172
      goto case_111;
    }
#line 175
    if (ch == 115) {
#line 175
      goto case_115;
    }
#line 178
    if (ch == 116) {
#line 178
      goto case_116;
    }
#line 182
    if (ch == 84) {
#line 182
      goto case_84;
    }
#line 185
    if (ch == 117) {
#line 185
      goto case_117;
    }
#line 228
    if (ch == 118) {
#line 228
      goto case_118;
    }
#line 231
    if (ch == 119) {
#line 231
      goto case_119;
    }
#line 234
    if (ch == 87) {
#line 234
      goto case_87;
    }
#line 238
    goto switch_default;
    case_97: /* CIL Label */ 
#line 130
    aflag = 1;
#line 131
    goto switch_break;
    case_98: /* CIL Label */ 
#line 133
    bflag = 1;
#line 134
    goto switch_break;
    case_99: /* CIL Label */ 
#line 136
    subopts = optarg;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! *subopts) {
#line 137
        goto while_break___0;
      }
      {
#line 138
      tmp = getsubopt((char **/* __restrict  */)(& subopts), (char * const  */* __restrict  */)(color_opts),
                      (char **/* __restrict  */)(& value));
      }
      {
#line 139
      if (tmp == 0) {
#line 139
        goto case_0;
      }
#line 142
      if (tmp == 1) {
#line 142
        goto case_1;
      }
#line 145
      if (tmp == 2) {
#line 145
        goto case_2;
      }
#line 148
      if (tmp == -1) {
#line 148
        goto case_neg_1;
      }
#line 138
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 140
      cflag = 2;
#line 141
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 143
      cflag = 0;
#line 144
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 146
      cflag = 1;
#line 147
      goto switch_break___0;
      case_neg_1: /* CIL Label */ 
      {
#line 149
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-c: illegal sub option %s\n",
              subopts);
      }
#line 152
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    goto switch_break;
    case_102: /* CIL Label */ 
#line 158
    fflag = 1;
#line 159
    goto switch_break;
    case_104: /* CIL Label */ 
#line 161
    hflag = 1;
#line 162
    goto switch_break;
    case_105: /* CIL Label */ 
#line 164
    iflag = 1;
#line 165
    goto switch_break;
    case_109: /* CIL Label */ 
#line 167
    mflag = 1;
#line 168
    goto switch_break;
    case_110: /* CIL Label */ 
#line 170
    nflag = 1;
#line 171
    goto switch_break;
    case_111: /* CIL Label */ 
#line 173
    oflag = 1;
#line 174
    goto switch_break;
    case_115: /* CIL Label */ 
#line 176
    sflag = 1;
#line 177
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 179
    tflag = 1;
#line 180
    fsfilter = strdup((char const   *)optarg);
    }
#line 181
    goto switch_break;
    case_84: /* CIL Label */ 
#line 183
    Tflag = 1;
#line 184
    goto switch_break;
    case_117: /* CIL Label */ 
#line 186
    uflag = 1;
#line 187
    subopts = optarg;
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 188
      if (! *subopts) {
#line 188
        goto while_break___1;
      }
      {
#line 189
      tmp___0 = getsubopt((char **/* __restrict  */)(& subopts), (char * const  */* __restrict  */)(unit_opts),
                          (char **/* __restrict  */)(& value));
      }
      {
#line 190
      if (tmp___0 == 0) {
#line 190
        goto case_0___0;
      }
#line 193
      if (tmp___0 == 1) {
#line 193
        goto case_1___0;
      }
#line 196
      if (tmp___0 == 2) {
#line 196
        goto case_2___0;
      }
#line 199
      if (tmp___0 == 3) {
#line 199
        goto case_3;
      }
#line 202
      if (tmp___0 == 4) {
#line 202
        goto case_4;
      }
#line 205
      if (tmp___0 == 5) {
#line 205
        goto case_5;
      }
#line 208
      if (tmp___0 == 6) {
#line 208
        goto case_6;
      }
#line 211
      if (tmp___0 == 7) {
#line 211
        goto case_7;
      }
#line 214
      if (tmp___0 == 8) {
#line 214
        goto case_8;
      }
#line 217
      if (tmp___0 == 9) {
#line 217
        goto case_9;
      }
#line 219
      if (tmp___0 == -1) {
#line 219
        goto case_neg_1___0;
      }
#line 189
      goto switch_break___1;
      case_0___0: /* CIL Label */ 
#line 191
      unitflag = (char )'h';
#line 192
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
#line 194
      unitflag = (char )'b';
#line 195
      goto switch_break___1;
      case_2___0: /* CIL Label */ 
#line 197
      unitflag = (char )'k';
#line 198
      goto switch_break___1;
      case_3: /* CIL Label */ 
#line 200
      unitflag = (char )'m';
#line 201
      goto switch_break___1;
      case_4: /* CIL Label */ 
#line 203
      unitflag = (char )'g';
#line 204
      goto switch_break___1;
      case_5: /* CIL Label */ 
#line 206
      unitflag = (char )'t';
#line 207
      goto switch_break___1;
      case_6: /* CIL Label */ 
#line 209
      unitflag = (char )'p';
#line 210
      goto switch_break___1;
      case_7: /* CIL Label */ 
#line 212
      unitflag = (char )'e';
#line 213
      goto switch_break___1;
      case_8: /* CIL Label */ 
#line 215
      unitflag = (char )'z';
#line 216
      goto switch_break___1;
      case_9: /* CIL Label */ 
#line 217
      unitflag = (char )'y';
#line 218
      goto switch_break___1;
      case_neg_1___0: /* CIL Label */ 
      {
#line 220
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-u: illegal sub option %s\n",
              subopts);
      }
#line 223
      return (1);
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 227
    goto switch_break;
    case_118: /* CIL Label */ 
#line 229
    vflag = 1;
#line 230
    goto switch_break;
    case_119: /* CIL Label */ 
#line 232
    wflag = 1;
#line 233
    goto switch_break;
    case_87: /* CIL Label */ 
#line 235
    Wflag = 1;
#line 236
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 239
    usage(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  if (hflag) {
    {
#line 245
    usage(0);
    }
  }
#line 248
  if (vflag) {
    {
#line 249
    printf((char const   */* __restrict  */)"dfc %s\n", "2.5.0");
    }
#line 250
    return (0);
  }
  {
#line 254
  width = getttywidth();
  }
#line 257
  if (width == 0U) {
#line 257
    if (cflag != 2) {
#line 258
      cflag = 0;
    }
  }
#line 261
  if (! fflag) {
#line 262
    if (width < 151U) {
#line 263
      if (oflag) {
#line 264
        Tflag = 0;
#line 265
        bflag = 1;
      }
    }
#line 268
    if (width < 125U) {
#line 269
      oflag = 0;
    }
#line 270
    if (width < 81U) {
#line 271
      bflag = 1;
#line 272
      Tflag = 0;
    }
  }
  {
#line 277
  init_queue(& queue);
#line 280
  fetch_info(& queue);
#line 283
  disp(& queue, fsfilter);
  }
#line 285
  return (0);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/dfc.c"
void usage(int status ) 
{ 


  {
#line 296
  if (status != 0) {
    {
#line 297
    fputs((char const   */* __restrict  */)"Try dfc -h for more information\n", (FILE */* __restrict  */)stderr);
    }
  } else {
    {
#line 300
    fputs((char const   */* __restrict  */)"Usage: dfc [OPTIONS(S)] [-c WHEN] [-u UNIT][-t FILESYSTEM]\nAvailable options:\n\t-a\tprint all fs from mtab\n\t-b\tdo not show the graph bar\n\t-c\tchoose color mode. Read the manpage\n\t\tfor details\n",
          (FILE */* __restrict  */)stdout);
#line 308
    fputs((char const   */* __restrict  */)"\t-f\tdisable auto-adjust mode (force display)\n\t-h\tprint this message\n\t-i\tinfo about inodes\n\t-m\tuse metric (SI unit)\n\t-n\tdo not print header\n\t-o\tshow mount flags\n\t-s\tsum the total usage\n\t-t\tfilter filesystems. Read the manpage\n\t\tfor details\n\t-T\tshow filesystem type\n\t-u\tchoose the unit in which\n\t\tto show the values. Read the manpage\n\t\tfor details\n\t-v\tprint program version\n\t-w\tuse a wider bar\n\t-W\twide filename (un truncate)\n",
          (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 328
  exit(status);
  }
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/dfc.c"
void fetch_info(struct list *lst ) 
{ 
  FILE *mtab ;
  struct fsmntinfo *fmi ;
  struct mntent *entbuf ;
  struct statvfs vfsbuf ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 350
  tmp = malloc(sizeof(struct fsmntinfo ));
#line 350
  fmi = (struct fsmntinfo *)tmp;
  }
#line 350
  if ((unsigned long )fmi == (unsigned long )((void *)0)) {
    {
#line 351
    fputs((char const   */* __restrict  */)"Error while allocating memory to fmi",
          (FILE */* __restrict  */)stderr);
#line 352
    exit(1);
    }
  }
  {
#line 355
  *fmi = fmi_init();
#line 358
  mtab = fopen((char const   */* __restrict  */)"/etc/mtab", (char const   */* __restrict  */)"r");
  }
#line 358
  if ((unsigned long )mtab == (unsigned long )((void *)0)) {
    {
#line 359
    perror("Error while opening mtab file ");
#line 360
    exit(1);
    }
  }
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 365
    entbuf = getmntent(mtab);
    }
#line 365
    if (! ((unsigned long )entbuf != (unsigned long )((void *)0))) {
#line 365
      goto while_break;
    }
    {
#line 367
    tmp___13 = statvfs((char const   */* __restrict  */)entbuf->mnt_dir, (struct statvfs */* __restrict  */)(& vfsbuf));
    }
#line 367
    if (tmp___13 == -1) {
      {
#line 369
      tmp___0 = __errno_location();
      }
#line 369
      if (*tmp___0 == 13) {
        {
#line 370
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: %s was skipped because it cannot be stated",
                entbuf->mnt_dir);
#line 373
        perror(" ");
        }
      } else {
        {
#line 375
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error while stating %s",
                entbuf->mnt_dir);
#line 377
        perror(" ");
#line 378
        exit(1);
        }
      }
    } else {
#line 392
      if (Wflag) {
        {
#line 393
        tmp___1 = strdup((char const   *)entbuf->mnt_fsname);
#line 393
        fmi->fsname = tmp___1;
        }
#line 393
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 395
          fmi->fsname = (char *)"unknown";
        }
        {
#line 397
        tmp___2 = strdup((char const   *)entbuf->mnt_dir);
#line 397
        fmi->dir = tmp___2;
        }
#line 397
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 399
          fmi->dir = (char *)"unknown";
        }
      } else {
        {
#line 402
        tmp___4 = shortenstr(entbuf->mnt_fsname, 24);
#line 402
        tmp___3 = strdup((char const   *)tmp___4);
#line 402
        fmi->fsname = tmp___3;
        }
#line 402
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 405
          fmi->fsname = (char *)"unknown";
        }
        {
#line 407
        tmp___6 = shortenstr(entbuf->mnt_dir, 24);
#line 407
        tmp___5 = strdup((char const   *)tmp___6);
#line 407
        fmi->dir = tmp___5;
        }
#line 407
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 409
          fmi->dir = (char *)"unknown";
        }
      }
      {
#line 412
      tmp___8 = shortenstr(entbuf->mnt_type, 12);
#line 412
      tmp___7 = strdup((char const   *)tmp___8);
#line 412
      fmi->type = tmp___7;
      }
#line 412
      if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 414
        fmi->type = (char *)"unknown";
      }
      {
#line 416
      tmp___9 = strdup((char const   *)entbuf->mnt_opts);
#line 416
      fmi->opts = tmp___9;
      }
#line 416
      if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
#line 417
        fmi->opts = (char *)"none";
      }
      {
#line 456
      fmi->bsize = vfsbuf.f_bsize;
#line 458
      fmi->frsize = vfsbuf.f_frsize;
#line 462
      fmi->blocks = vfsbuf.f_blocks;
#line 463
      fmi->bfree = vfsbuf.f_bfree;
#line 464
      fmi->bavail = vfsbuf.f_bavail;
#line 465
      fmi->files = vfsbuf.f_files;
#line 466
      fmi->ffree = vfsbuf.f_ffree;
#line 468
      fmi->favail = vfsbuf.f_favail;
#line 473
      fmi->next = (struct fsmntinfo *)((void *)0);
#line 476
      enqueue(lst, *fmi);
      }
#line 479
      if (! aflag) {
#line 479
        if (fmi->blocks > 0UL) {
#line 479
          goto _L;
        } else {
#line 479
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 479
      if (aflag) {
        _L: /* CIL Label */ 
        {
#line 480
        tmp___10 = strlen((char const   *)fmi->fsname);
#line 480
        lst->fsmaxlen = imax((int )tmp___10, lst->fsmaxlen);
#line 482
        tmp___11 = strlen((char const   *)fmi->dir);
#line 482
        lst->dirmaxlen = imax((int )tmp___11, lst->dirmaxlen);
#line 484
        tmp___12 = strlen((char const   *)fmi->type);
#line 484
        lst->typemaxlen = imax((int )tmp___12, lst->typemaxlen);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 491
  tmp___14 = fclose(mtab);
  }
#line 491
  if (tmp___14 == -1) {
    {
#line 492
    perror("Could not close mtab file ");
    }
  }
#line 494
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/dfc.c"
double cvrt(double n ) 
{ 


  {
  {
#line 507
  if ((int )unitflag == 98) {
#line 507
    goto case_98;
  }
#line 510
  if ((int )unitflag == 101) {
#line 510
    goto case_101;
  }
#line 517
  if ((int )unitflag == 103) {
#line 517
    goto case_103;
  }
#line 524
  if ((int )unitflag == 107) {
#line 524
    goto case_107;
  }
#line 531
  if ((int )unitflag == 109) {
#line 531
    goto case_109;
  }
#line 538
  if ((int )unitflag == 112) {
#line 538
    goto case_112;
  }
#line 545
  if ((int )unitflag == 116) {
#line 545
    goto case_116;
  }
#line 552
  if ((int )unitflag == 121) {
#line 552
    goto case_121;
  }
#line 559
  if ((int )unitflag == 122) {
#line 559
    goto case_122;
  }
#line 506
  goto switch_break;
  case_98: /* CIL Label */ 
#line 508
  return (n);
  case_101: /* CIL Label */ 
#line 511
  if (mflag) {
#line 512
    return (n / 1000000000000000000.0);
  } else {
#line 515
    return (n / 1152921504606846976.0);
  }
  case_103: /* CIL Label */ 
#line 518
  if (mflag) {
#line 519
    return (n / 1000000000.0);
  } else {
#line 522
    return (n / 1073741824.0);
  }
  case_107: /* CIL Label */ 
#line 525
  if (mflag) {
#line 526
    return (n / 1000.0);
  } else {
#line 529
    return (n / 1024.0);
  }
  case_109: /* CIL Label */ 
#line 532
  if (mflag) {
#line 533
    return (n / 1000000.0);
  } else {
#line 536
    return (n / 1048576.0);
  }
  case_112: /* CIL Label */ 
#line 539
  if (mflag) {
#line 540
    return (n / 1000000000000000.0);
  } else {
#line 543
    return (n / 1125899906842624.0);
  }
  case_116: /* CIL Label */ 
#line 546
  if (mflag) {
#line 547
    return (n / 1000000000000.0);
  } else {
#line 550
    return (n / 1099511627776.0);
  }
  case_121: /* CIL Label */ 
#line 553
  if (mflag) {
#line 554
    return (n / 1000000000000000000000000.0);
  } else {
#line 557
    return (n / 1208925819614629174706176.0);
  }
  case_122: /* CIL Label */ 
#line 560
  if (mflag) {
#line 562
    return (n / 1000000000000000000000.0);
  } else {
#line 565
    return (n / 1180591620717411303424.0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 570
  return (n);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/dfc.c"
void humanize(double n , double perct ) 
{ 
  int i ;
  double divider ;

  {
#line 582
  i = 0;
#line 583
  divider = 1024.0;
#line 586
  if (mflag) {
#line 587
    divider = 1000.0;
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (n >= (double )1000) {
#line 589
      if (! (i < 8)) {
#line 589
        goto while_break;
      }
    } else {
#line 589
      goto while_break;
    }
#line 590
    n /= divider;
#line 591
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 594
  change_color(perct);
  }
#line 596
  if (i == 0) {
    {
#line 597
    printf((char const   */* __restrict  */)"%9.f", n);
    }
  } else {
    {
#line 599
    printf((char const   */* __restrict  */)"%9.1f", n);
    }
  }
  {
#line 601
  reset_color();
  }
  {
#line 604
  if (i == 0) {
#line 604
    goto case_0;
  }
#line 607
  if (i == 1) {
#line 607
    goto case_1;
  }
#line 610
  if (i == 2) {
#line 610
    goto case_2;
  }
#line 613
  if (i == 3) {
#line 613
    goto case_3;
  }
#line 616
  if (i == 4) {
#line 616
    goto case_4;
  }
#line 619
  if (i == 5) {
#line 619
    goto case_5;
  }
#line 622
  if (i == 6) {
#line 622
    goto case_6;
  }
#line 625
  if (i == 7) {
#line 625
    goto case_7;
  }
#line 628
  if (i == 8) {
#line 628
    goto case_8;
  }
#line 603
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 605
  printf((char const   */* __restrict  */)"B");
  }
#line 606
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 608
  printf((char const   */* __restrict  */)"K");
  }
#line 609
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 611
  printf((char const   */* __restrict  */)"M");
  }
#line 612
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 614
  printf((char const   */* __restrict  */)"G");
  }
#line 615
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 617
  printf((char const   */* __restrict  */)"T");
  }
#line 618
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 620
  printf((char const   */* __restrict  */)"P");
  }
#line 621
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 623
  printf((char const   */* __restrict  */)"E");
  }
#line 624
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 626
  printf((char const   */* __restrict  */)"Z");
  }
#line 627
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 629
  printf((char const   */* __restrict  */)"Y");
  }
#line 630
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 632
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.h"
void disp_header(struct list *lst ) ;
#line 44
void disp_sum(struct list *lst , double stot , double atot , double utot , double ifitot ,
              double ifatot ) ;
#line 46
void disp_bar(double perct ) ;
#line 47
void disp_at(double n , double perct ) ;
#line 48
void disp_perct(double perct ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void disp(struct list *lst , char *fsfilter ) 
{ 
  struct fsmntinfo *p ;
  int i ;
  int n ;
  int skip ;
  int nm ;
  double perctused ;
  double size ;
  double avail ;
  double used ;
  double stot ;
  double atot ;
  double utot ;
  double ifitot ;
  double ifatot ;
  char *stropt ;
  char *strtmp ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 50
  p = (struct fsmntinfo *)((void *)0);
#line 52
  skip = 1;
#line 53
  nm = 0;
#line 59
  n = 0;
#line 59
  ifatot = (double )n;
#line 59
  ifitot = ifatot;
#line 59
  utot = ifitot;
#line 59
  atot = utot;
#line 59
  stot = atot;
#line 62
  if (tflag) {
#line 63
    if ((int )*(fsfilter + 0) == 45) {
#line 64
      nm = 1;
#line 65
      skip = 0;
#line 66
      fsfilter ++;
    }
  }
#line 71
  if (! nflag) {
    {
#line 72
    disp_header(lst);
    }
  }
#line 74
  if (lst->fsmaxlen < 11) {
#line 75
    lst->fsmaxlen = 11;
  }
#line 77
  p = lst->head;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
#line 80
    if (! aflag) {
#line 82
      if (p->blocks == 0UL) {
#line 83
        p = p->next;
#line 84
        goto while_continue;
      }
    }
#line 90
    if (tflag) {
      {
#line 91
      strtmp = strdup((char const   *)fsfilter);
      }
#line 91
      if ((unsigned long )strtmp == (unsigned long )((void *)0)) {
        {
#line 92
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot duplicate fsfilter\n");
#line 94
        exit(1);
        }
      }
      {
#line 97
      stropt = strtok((char */* __restrict  */)fsfilter, (char const   */* __restrict  */)",");
      }
      {
#line 98
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 98
        if (! ((unsigned long )stropt != (unsigned long )((void *)0))) {
#line 98
          goto while_break___0;
        }
        {
#line 99
        tmp = strcmp((char const   *)p->type, (char const   *)stropt);
        }
#line 99
        if (tmp == 0) {
#line 100
          if (nm) {
#line 101
            skip = 1;
          } else {
#line 103
            skip = 0;
          }
        }
        {
#line 105
        stropt = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 108
      fsfilter = strdup((char const   *)strtmp);
      }
#line 109
      if (skip) {
#line 110
        if (nm) {
#line 111
          skip = 0;
        }
#line 112
        p = p->next;
#line 113
        goto while_continue;
      } else
#line 116
      if (! nm) {
#line 117
        skip = 1;
      }
    }
    {
#line 122
    printf((char const   */* __restrict  */)"%s", p->fsname);
#line 123
    tmp___0 = strlen((char const   *)p->fsname);
#line 123
    i = (int )tmp___0;
    }
    {
#line 123
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 123
      if (! (i < lst->fsmaxlen + 1)) {
#line 123
        goto while_break___1;
      }
      {
#line 124
      printf((char const   */* __restrict  */)" ");
#line 123
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 127
    if (Tflag) {
      {
#line 128
      printf((char const   */* __restrict  */)"%s", p->type);
#line 129
      tmp___1 = strlen((char const   *)p->type);
#line 129
      i = (int )tmp___1;
      }
      {
#line 129
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 129
        if (! (i < lst->typemaxlen + 1)) {
#line 129
          goto while_break___2;
        }
        {
#line 130
        printf((char const   */* __restrict  */)" ");
#line 129
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 133
    size = (double )p->blocks * (double )p->frsize;
#line 134
    avail = (double )p->bavail * (double )p->frsize;
#line 135
    used = size - avail;
#line 142
    if ((int )size == 0) {
#line 143
      perctused = 100.0;
    } else {
#line 145
      perctused = (used / size) * 100.0;
    }
#line 147
    if (sflag) {
#line 148
      stot += size;
#line 149
      atot += avail;
#line 150
      utot += used;
    }
#line 153
    if (! bflag) {
      {
#line 154
      disp_bar(perctused);
      }
    }
    {
#line 157
    disp_perct(perctused);
    }
#line 160
    if (uflag) {
      {
#line 161
      size = cvrt(size);
#line 162
      avail = cvrt(avail);
      }
    }
    {
#line 166
    disp_at(avail, perctused);
#line 167
    disp_at(size, perctused);
    }
#line 170
    if (iflag) {
      {
#line 171
      ifitot += (double )p->files;
#line 172
      ifatot += (double )p->favail;
#line 173
      printf((char const   */* __restrict  */)"%9ldk", p->files / 1000UL);
#line 174
      printf((char const   */* __restrict  */)"%9ldk", p->favail / 1000UL);
      }
    }
    {
#line 178
    printf((char const   */* __restrict  */)" %s", p->dir);
    }
#line 181
    if (oflag) {
      {
#line 182
      tmp___2 = strlen((char const   *)p->dir);
#line 182
      i = (int )tmp___2;
      }
      {
#line 182
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 182
        tmp___3 = imax(lst->dirmaxlen + 1, 11);
        }
#line 182
        if (! (i < tmp___3)) {
#line 182
          goto while_break___3;
        }
        {
#line 184
        printf((char const   */* __restrict  */)" ");
#line 182
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 185
      printf((char const   */* __restrict  */)"%s\n", p->opts);
      }
    } else {
      {
#line 187
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 189
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (sflag) {
    {
#line 193
    disp_sum(lst, stot, atot, utot, ifitot, ifatot);
    }
  }
#line 194
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void disp_header(struct list *lst ) 
{ 
  int i ;
  int barinc ;

  {
#line 204
  barinc = 5;
#line 207
  if (cflag) {
    {
#line 208
    printf((char const   */* __restrict  */)"\033[;34m");
    }
  }
  {
#line 210
  printf((char const   */* __restrict  */)"FILESYSTEM ");
#line 211
  i = 11;
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < lst->fsmaxlen)) {
#line 211
      goto while_break;
    }
    {
#line 212
    printf((char const   */* __restrict  */)" ");
#line 211
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  if (Tflag) {
    {
#line 215
    printf((char const   */* __restrict  */)" TYPE");
    }
#line 216
    if (lst->typemaxlen > 5) {
#line 217
      i = 5;
      {
#line 217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 217
        if (! (i < lst->typemaxlen + 1)) {
#line 217
          goto while_break___0;
        }
        {
#line 218
        printf((char const   */* __restrict  */)" ");
#line 217
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 220
      lst->typemaxlen = 5;
    }
  }
#line 224
  if (wflag) {
#line 225
    barinc = 35;
  }
#line 227
  if (! bflag) {
    {
#line 228
    printf((char const   */* __restrict  */)" (=) USED");
#line 229
    i = 0;
    }
    {
#line 229
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 229
      if (! (i < barinc + 1)) {
#line 229
        goto while_break___1;
      }
      {
#line 230
      printf((char const   */* __restrict  */)" ");
#line 229
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 231
    printf((char const   */* __restrict  */)"FREE (-) ");
    }
  }
  {
#line 234
  printf((char const   */* __restrict  */)"%%USED");
  }
#line 235
  if ((int )unitflag == 107) {
    {
#line 236
    printf((char const   */* __restrict  */)"  ");
    }
  } else
#line 237
  if ((int )unitflag == 98) {
    {
#line 238
    printf((char const   */* __restrict  */)"       ");
    }
  } else {
    {
#line 240
    printf((char const   */* __restrict  */)" ");
    }
  }
  {
#line 242
  printf((char const   */* __restrict  */)"AVAILABLE");
  }
#line 243
  if ((int )unitflag == 107) {
    {
#line 244
    printf((char const   */* __restrict  */)"      ");
    }
  } else
#line 245
  if ((int )unitflag == 109) {
    {
#line 246
    printf((char const   */* __restrict  */)"     ");
    }
  } else
#line 247
  if ((int )unitflag == 98) {
    {
#line 248
    printf((char const   */* __restrict  */)"           ");
    }
  } else {
    {
#line 250
    printf((char const   */* __restrict  */)"     ");
    }
  }
  {
#line 252
  printf((char const   */* __restrict  */)"TOTAL");
  }
#line 254
  if (iflag) {
    {
#line 255
    printf((char const   */* __restrict  */)"   #INODES");
#line 256
    printf((char const   */* __restrict  */)" AV.INODES");
    }
  }
  {
#line 259
  printf((char const   */* __restrict  */)" MOUNTED ON ");
  }
#line 261
  if (oflag) {
#line 262
    i = 10;
    {
#line 262
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 262
      if (! (i < lst->dirmaxlen)) {
#line 262
        goto while_break___2;
      }
      {
#line 263
      printf((char const   */* __restrict  */)" ");
#line 262
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 264
    printf((char const   */* __restrict  */)"MOUNT OPTIONS\n");
    }
  } else {
    {
#line 266
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 268
  reset_color();
  }
#line 269
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void disp_sum(struct list *lst , double stot , double atot , double utot , double ifitot ,
              double ifatot ) 
{ 
  int i ;
  int j ;
  double ptot ;

  {
#line 282
  ptot = (double )0;
#line 284
  if ((int )stot == 0) {
#line 285
    ptot = 100.0;
  } else {
#line 287
    ptot = (utot / stot) * 100.0;
  }
  {
#line 288
  printf((char const   */* __restrict  */)"SUM:");
#line 290
  j = lst->fsmaxlen + 1;
  }
#line 291
  if (Tflag) {
#line 292
    j += lst->typemaxlen + 1;
  }
#line 293
  i = 4;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < j)) {
#line 293
      goto while_break;
    }
    {
#line 294
    printf((char const   */* __restrict  */)" ");
#line 293
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (! bflag) {
    {
#line 297
    disp_bar(ptot);
    }
  }
  {
#line 299
  disp_perct(ptot);
  }
#line 301
  if (uflag) {
    {
#line 302
    stot = cvrt(stot);
#line 303
    atot = cvrt(atot);
    }
  }
  {
#line 306
  disp_at(atot, ptot);
#line 307
  disp_at(stot, ptot);
  }
#line 309
  if (ifitot) {
#line 309
    if (ifatot) {
      {
#line 310
      printf((char const   */* __restrict  */)"%9.fk", ifitot / (double )1000);
#line 311
      printf((char const   */* __restrict  */)"%9.fk", ifatot / (double )1000);
      }
    }
  }
  {
#line 314
  printf((char const   */* __restrict  */)"\n");
  }
#line 315
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void disp_bar(double perct ) 
{ 
  int i ;
  int j ;
  int barinc ;

  {
#line 325
  barinc = 5;
#line 328
  if (wflag) {
#line 329
    barinc = 2;
  }
  {
#line 333
  printf((char const   */* __restrict  */)"[");
  }
#line 335
  if (! cflag) {
#line 336
    i = 0;
    {
#line 336
    while (1) {
      while_continue: /* CIL Label */ ;
#line 336
      if (! ((double )i < perct)) {
#line 336
        goto while_break;
      }
      {
#line 337
      printf((char const   */* __restrict  */)"=");
#line 336
      i += barinc;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 339
    j = i;
    {
#line 339
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 339
      if (! (j < 100)) {
#line 339
        goto while_break___0;
      }
      {
#line 340
      printf((char const   */* __restrict  */)"-");
#line 339
      j += barinc;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 344
    printf((char const   */* __restrict  */)"\033[;32m");
#line 345
    i = 0;
    }
    {
#line 345
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 345
      if (i < 50) {
#line 345
        if (! ((double )i < perct)) {
#line 345
          goto while_break___1;
        }
      } else {
#line 345
        goto while_break___1;
      }
      {
#line 346
      printf((char const   */* __restrict  */)"=");
#line 345
      i += barinc;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 349
    printf((char const   */* __restrict  */)"\033[;33m");
    }
    {
#line 350
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 350
      if (i < 75) {
#line 350
        if (! ((double )i < perct)) {
#line 350
          goto while_break___2;
        }
      } else {
#line 350
        goto while_break___2;
      }
      {
#line 351
      printf((char const   */* __restrict  */)"=");
#line 350
      i += barinc;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 354
    printf((char const   */* __restrict  */)"\033[;31m");
    }
    {
#line 355
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 355
      if (i < 100) {
#line 355
        if (! ((double )i < perct)) {
#line 355
          goto while_break___3;
        }
      } else {
#line 355
        goto while_break___3;
      }
      {
#line 356
      printf((char const   */* __restrict  */)"=");
#line 355
      i += barinc;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 358
    reset_color();
#line 360
    j = i;
    }
    {
#line 360
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 360
      if (! (j < 100)) {
#line 360
        goto while_break___4;
      }
      {
#line 361
      printf((char const   */* __restrict  */)"-");
#line 360
      j += barinc;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 364
  printf((char const   */* __restrict  */)"]  ");
  }
#line 365
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void disp_at(double n , double perct ) 
{ 


  {
  {
#line 376
  change_color(perct);
  }
  {
#line 380
  if ((int )unitflag == 104) {
#line 380
    goto case_104;
  }
#line 384
  if ((int )unitflag == 98) {
#line 384
    goto case_98;
  }
#line 390
  if ((int )unitflag == 107) {
#line 390
    goto case_107;
  }
#line 379
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 381
  humanize(n, perct);
  }
#line 382
  return;
  case_98: /* CIL Label */ 
  {
#line 385
  printf((char const   */* __restrict  */)"%15.f", n);
#line 386
  reset_color();
#line 387
  printf((char const   */* __restrict  */)"B");
  }
#line 388
  return;
  case_107: /* CIL Label */ 
  {
#line 391
  printf((char const   */* __restrict  */)"%10.f", n);
#line 392
  reset_color();
#line 393
  printf((char const   */* __restrict  */)"K");
  }
#line 394
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 398
  printf((char const   */* __restrict  */)"%9.1f", n);
#line 399
  reset_color();
  }
  {
#line 402
  if ((int )unitflag == 109) {
#line 402
    goto case_109;
  }
#line 405
  if ((int )unitflag == 103) {
#line 405
    goto case_103;
  }
#line 408
  if ((int )unitflag == 116) {
#line 408
    goto case_116;
  }
#line 411
  if ((int )unitflag == 112) {
#line 411
    goto case_112;
  }
#line 414
  if ((int )unitflag == 101) {
#line 414
    goto case_101;
  }
#line 417
  if ((int )unitflag == 122) {
#line 417
    goto case_122;
  }
#line 420
  if ((int )unitflag == 121) {
#line 420
    goto case_121;
  }
#line 401
  goto switch_break___0;
  case_109: /* CIL Label */ 
  {
#line 403
  printf((char const   */* __restrict  */)"M");
  }
#line 404
  goto switch_break___0;
  case_103: /* CIL Label */ 
  {
#line 406
  printf((char const   */* __restrict  */)"G");
  }
#line 407
  goto switch_break___0;
  case_116: /* CIL Label */ 
  {
#line 409
  printf((char const   */* __restrict  */)"T");
  }
#line 410
  goto switch_break___0;
  case_112: /* CIL Label */ 
  {
#line 412
  printf((char const   */* __restrict  */)"P");
  }
#line 413
  goto switch_break___0;
  case_101: /* CIL Label */ 
  {
#line 415
  printf((char const   */* __restrict  */)"E");
  }
#line 416
  goto switch_break___0;
  case_122: /* CIL Label */ 
  {
#line 418
  printf((char const   */* __restrict  */)"Z");
  }
#line 419
  goto switch_break___0;
  case_121: /* CIL Label */ 
  {
#line 421
  printf((char const   */* __restrict  */)"Y");
  }
#line 422
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 424
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void disp_perct(double perct ) 
{ 


  {
#line 433
  if (! cflag) {
    {
#line 434
    printf((char const   */* __restrict  */)"%3.f%%", perct);
    }
  } else {
#line 436
    if (perct < 50.0) {
      {
#line 437
      printf((char const   */* __restrict  */)"\033[;32m");
      }
    } else
#line 438
    if (perct < 75.0) {
      {
#line 439
      printf((char const   */* __restrict  */)"\033[;33m");
      }
    } else {
      {
#line 441
      printf((char const   */* __restrict  */)"\033[;31m");
      }
    }
    {
#line 443
    printf((char const   */* __restrict  */)"%3.f", perct);
#line 444
    reset_color();
#line 445
    printf((char const   */* __restrict  */)"%%");
    }
  }
#line 447
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void change_color(double perct ) 
{ 


  {
#line 456
  if (cflag) {
#line 457
    if (perct < 50.0) {
      {
#line 458
      printf((char const   */* __restrict  */)"\033[;32m");
      }
    } else
#line 459
    if (perct < 75.0) {
      {
#line 460
      printf((char const   */* __restrict  */)"\033[;33m");
      }
    } else {
      {
#line 462
      printf((char const   */* __restrict  */)"\033[;31m");
      }
    }
  }
#line 464
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/disp.c"
void reset_color(void) 
{ 


  {
#line 472
  if (cflag) {
    {
#line 473
    printf((char const   */* __restrict  */)"\033[;m");
    }
  }
#line 474
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.h"
int is_empty(struct list lst ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.c"
void init_queue(struct list *lst ) 
{ 


  {
#line 45
  lst->head = (struct fsmntinfo *)((void *)0);
#line 46
  lst->tail = (struct fsmntinfo *)((void *)0);
#line 47
  lst->fsmaxlen = -1;
#line 48
  lst->dirmaxlen = -1;
#line 49
  lst->typemaxlen = -1;
#line 50
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.c"
int is_empty(struct list lst ) 
{ 


  {
#line 62
  if ((unsigned long )lst.head == (unsigned long )((void *)0)) {
#line 63
    return (1);
  } else {
#line 66
    return (0);
  }
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.c"
int enqueue(struct list *lst , struct fsmntinfo fmi ) 
{ 
  struct fsmntinfo *new_fmi ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 81
  tmp = malloc(sizeof(struct fsmntinfo ));
#line 81
  new_fmi = (struct fsmntinfo *)tmp;
  }
#line 83
  if ((unsigned long )new_fmi == (unsigned long )((void *)0)) {
    {
#line 84
    fputs((char const   */* __restrict  */)"Error while allocating memory to fmi",
          (FILE */* __restrict  */)stderr);
    }
#line 85
    return (-1);
  }
  {
#line 90
  *new_fmi = fmi;
#line 92
  tmp___0 = is_empty(*lst);
  }
#line 92
  if (tmp___0) {
#line 93
    lst->head = new_fmi;
  } else {
#line 95
    (lst->tail)->next = new_fmi;
  }
#line 97
  lst->tail = new_fmi;
#line 99
  return (0);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/list.c"
struct fsmntinfo fmi_init(void) 
{ 
  struct fsmntinfo fmi ;

  {
#line 113
  fmi.fsname = (char *)"unknown";
#line 114
  fmi.dir = (char *)"unknown";
#line 115
  fmi.type = (char *)"unknown";
#line 116
  fmi.opts = (char *)"none";
#line 118
  fmi.bsize = 0UL;
#line 119
  fmi.frsize = 0UL;
#line 120
  fmi.blocks = 0UL;
#line 121
  fmi.bfree = 0UL;
#line 122
  fmi.bavail = 0UL;
#line 123
  fmi.files = 0UL;
#line 124
  fmi.ffree = 0UL;
#line 125
  fmi.favail = 0UL;
#line 127
  fmi.next = (struct fsmntinfo *)((void *)0);
#line 129
  return (fmi);
}
}
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/util.c"
int imax(int a , int b ) 
{ 
  int tmp ;

  {
#line 48
  if (a > b) {
#line 48
    tmp = a;
  } else {
#line 48
    tmp = b;
  }
#line 48
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/util.c"
char *shortenstr(char *str , int len ) 
{ 
  int i ;
  int slen ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 60
  i = 0;
#line 61
  tmp = strlen((char const   *)str);
#line 61
  slen = (int )tmp;
  }
#line 63
  if (slen < len + 1) {
#line 64
    return (str);
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    tmp___0 = i;
#line 67
    i ++;
#line 67
    if (! (tmp___0 < slen - len)) {
#line 67
      goto while_break;
    }
#line 68
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  *(str + 0) = (char )'+';
#line 72
  return (str);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/dfc-2.5.0/src/util.c"
unsigned int getttywidth(void) 
{ 
  unsigned int width ;
  struct winsize win ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 83
  width = 0U;
#line 90
  tmp = isatty(1);
  }
#line 90
  if (! tmp) {
#line 91
    return (0U);
  }
  {
#line 102
  tmp___0 = ioctl(1, 21523UL, & win);
  }
#line 102
  if (tmp___0 == 0) {
#line 106
    width = (unsigned int )win.ws_col;
  }
#line 109
  if (width == 0U) {
#line 109
    tmp___1 = 80U;
  } else {
#line 109
    tmp___1 = width;
  }
#line 109
  return (tmp___1);
}
}
