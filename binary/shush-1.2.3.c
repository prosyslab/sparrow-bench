/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 27 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
struct __anonstruct_state_66 {
   time_t last ;
   time_t start ;
   time_t delay ;
   time_t run ;
   time_t timeout ;
   time_t end ;
   int locked ;
   int killed ;
   char *msg ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 215 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 215 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 231 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 234 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 233 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 16 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.c"
struct variable {
   char *name ;
   long value ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_53 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_53 regmatch_t;
#line 35 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
union __anonunion_val_55 {
   regex_t re ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
struct condition {
   int code ;
   char *expression ;
   union __anonunion_val_55 val ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
struct marker {
   size_t offset ;
   char type ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 313 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_55___0 {
   int __in ;
   int __i ;
};
#line 319 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_56___0 {
   int __in ;
   int __i ;
};
#line 319 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_57___0 {
   int __in ;
   int __i ;
};
#line 319 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_58___0 {
   int __in ;
   int __i ;
};
#line 319 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_59___0 {
   int __in ;
   int __i ;
};
#line 317 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_60___0 {
   int __in ;
   int __i ;
};
#line 317 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 311 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 311 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 469 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
#line 469 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 487 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 488 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 488 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 486 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_69 {
   int __in ;
   int __i ;
};
#line 486 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
union __anonunion_70 {
   int __in ;
   int __i ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 34 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
typedef void *any;
#line 35
struct list_;
#line 35 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
typedef struct list_ list;
#line 36 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
struct list_ {
   any value ;
   list *nextl ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
struct cfelmt {
   int code ;
   char *name ;
   char type ;
   void *(*valid)(char * ) ;
   any value ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
struct rptdef {
   char *name ;
   char type ;
   void *(*valid)(char * ) ;
};
#line 128 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.c"
struct codestr {
   char *name ;
   int code ;
};
#line 22 "ifparser.y"
union __anonunion_YYSTYPE_52 {
   long integer ;
   char *string ;
};
#line 22 "ifparser.y"
typedef union __anonunion_YYSTYPE_52 YYSTYPE;
#line 12 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/signals.h"
struct signame {
   char *name ;
   int num ;
};
#line 117 "ifparser.lex.c"
struct yy_buffer_state;
#line 117 "ifparser.lex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 159 "ifparser.lex.c"
typedef unsigned int yy_size_t;
#line 162 "ifparser.lex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 285 "ifparser.lex.c"
typedef unsigned char YY_CHAR;
#line 287 "ifparser.lex.c"
typedef int yy_state_type;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_7 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_8 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_7 __wait_terminated ;
   struct __anonstruct___wait_stopped_8 __wait_stopped ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 155 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_66 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_67 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_68 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_69 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_70 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_71 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_72 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_73 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_74 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_75 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_76 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_77 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_78 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_79 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_66 __annonCompField2 ;
   union __anonunion____missing_field_name_67 __annonCompField3 ;
   union __anonunion____missing_field_name_68 __annonCompField4 ;
   union __anonunion____missing_field_name_69 __annonCompField5 ;
   union __anonunion____missing_field_name_70 __annonCompField6 ;
   union __anonunion____missing_field_name_71 __annonCompField7 ;
   union __anonunion____missing_field_name_72 __annonCompField8 ;
   union __anonunion____missing_field_name_73 __annonCompField9 ;
   union __anonunion____missing_field_name_74 __annonCompField10 ;
   union __anonunion____missing_field_name_75 __annonCompField11 ;
   union __anonunion____missing_field_name_76 __annonCompField12 ;
   union __anonunion____missing_field_name_77 __annonCompField13 ;
   union __anonunion____missing_field_name_78 __annonCompField14 ;
   union __anonunion____missing_field_name_79 __annonCompField15 ;
};
#line 362 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 361 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 361 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 366 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 365 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 784 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_86 {
   int __in ;
   int __i ;
};
#line 784 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_87 {
   int __in ;
   int __i ;
};
#line 911 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_88 {
   int __in ;
   int __i ;
};
#line 912 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_89 {
   int __in ;
   int __i ;
};
#line 916 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_90 {
   int __in ;
   int __i ;
};
#line 920 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_91 {
   int __in ;
   int __i ;
};
#line 922 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_92 {
   int __in ;
   int __i ;
};
#line 926 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_93 {
   int __in ;
   int __i ;
};
#line 918 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_94 {
   int __in ;
   int __i ;
};
#line 909 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_95 {
   int __in ;
   int __i ;
};
#line 1085 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_96 {
   int __in ;
   int __i ;
};
#line 1089 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_97 {
   int __in ;
   int __i ;
};
#line 1090 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_98 {
   int __in ;
   int __i ;
};
#line 1084 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_99 {
   int __in ;
   int __i ;
};
#line 1145 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_100 {
   int __in ;
   int __i ;
};
#line 1145 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_101 {
   int __in ;
   int __i ;
};
#line 1161 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_102 {
   int __in ;
   int __i ;
};
#line 1160 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_103 {
   int __in ;
   int __i ;
};
#line 1160 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_104 {
   int __in ;
   int __i ;
};
#line 1164 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_105 {
   int __in ;
   int __i ;
};
#line 1163 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
union __anonunion_106 {
   int __in ;
   int __i ;
};
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.h"
void ( /* format attribute */  error)(char *format  , ...) ;
#line 23
 __attribute__((__noreturn__)) void myassert(char *assertion , char *file , char *function ,
                                             int line ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/mmap.h"
int mapfile(char *name , int fd___0 , void **mm , size_t *len ) ;
#line 17
struct stat *mapstat(void) ;
#line 18
int unmapfile(char *name , void *mm , size_t len ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/mmap.c"
static struct stat sb  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/mmap.c"
int mapfile(char *name , int fd___0 , void **mm , size_t *len ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 27
  *mm = (void *)0;
#line 29
  if (fd___0 < 0) {
    {
#line 31
    fd___0 = open((char const   *)name, 0, 0);
    }
#line 32
    if (fd___0 < 0) {
      {
#line 34
      tmp___1 = __errno_location();
      }
#line 34
      if (*tmp___1 == 2) {
#line 35
        return (1);
      } else {
        {
#line 38
        tmp = __errno_location();
#line 38
        tmp___0 = strerror(*tmp);
#line 38
        error((char *)"open(%s) failed: %s", name, tmp___0);
        }
#line 39
        return (-1);
      }
    }
#line 42
    fd___0 *= -1;
  }
  {
#line 45
  tmp___4 = abs(fd___0);
#line 45
  tmp___5 = fstat(tmp___4, & sb);
  }
#line 45
  if (tmp___5 == -1) {
    {
#line 48
    tmp___2 = __errno_location();
#line 48
    tmp___3 = strerror(*tmp___2);
#line 48
    error((char *)"fstat(%s) failed: %s", name, tmp___3);
    }
#line 49
    return (-1);
  }
#line 51
  *len = (size_t )sb.st_size;
#line 53
  if (*len == 0UL) {
#line 55
    if (fd___0 < 0) {
      {
#line 56
      tmp___6 = abs(fd___0);
#line 56
      close(tmp___6);
      }
    }
#line 57
    return (0);
  }
  {
#line 60
  tmp___7 = abs(fd___0);
#line 60
  *mm = mmap((void *)0, *len, 3, 2, tmp___7, (__off_t )0);
  }
#line 69
  if ((unsigned long )*mm == (unsigned long )((void *)-1)) {
    {
#line 72
    tmp___8 = __errno_location();
#line 72
    tmp___9 = strerror(*tmp___8);
#line 72
    error((char *)"mmap(%s) failed: %s", name, tmp___9);
    }
#line 73
    if (fd___0 < 0) {
      {
#line 74
      tmp___10 = abs(fd___0);
#line 74
      close(tmp___10);
      }
    }
#line 75
    return (-1);
  }
#line 78
  if (fd___0 < 0) {
    {
#line 79
    tmp___11 = abs(fd___0);
#line 79
    close(tmp___11);
    }
  }
#line 81
  return (0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/mmap.c"
struct stat *mapstat(void) 
{ 


  {
#line 91
  return (& sb);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/mmap.c"
int unmapfile(char *name , void *mm , size_t len ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 101
  if (! ((unsigned long )mm != (unsigned long )((void *)0))) {
    {
#line 101
    myassert((char *)"mm != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/mmap.c",
             (char *)((void *)0), 101);
    }
  }
#line 102
  if (! (len > 0UL)) {
    {
#line 102
    myassert((char *)"len > 0", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/mmap.c",
             (char *)((void *)0), 102);
    }
  }
  {
#line 104
  tmp___1 = munmap(mm, len);
  }
#line 104
  if (tmp___1 == -1) {
    {
#line 106
    tmp = __errno_location();
#line 106
    tmp___0 = strerror(*tmp);
#line 106
    error((char *)"munmap(%s) failed: %s", name, tmp___0);
    }
#line 107
    return (-1);
  } else {
#line 110
    return (0);
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.h"
void error_init(char *name , char *jid___0 , int copytosyslog ) ;
#line 36
 __attribute__((__noreturn__)) void myabort(char *file , char *function , int line ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/os.h"
char *myname ;
#line 200 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/gethostname.h"
char *get_hostname(int dots ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
static int prefix  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
static int tosyslog  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
static char *task  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
static char *id  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
void error_init(char *name , char *jid___0 , int copytosyslog ) 
{ 


  {
#line 30
  task = name;
#line 31
  id = jid___0;
#line 32
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 33
    prefix = 1;
  } else {
#line 35
    prefix = 0;
  }
#line 36
  tosyslog = copytosyslog;
#line 37
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
void ( /* format attribute */  error)(char *format  , ...) 
{ 
  va_list va ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 48
  if ((unsigned long )task != (unsigned long )((void *)0)) {
#line 50
    if ((int )*id != 0) {
      {
#line 51
      tmp = get_hostname(0);
#line 51
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s[%s] encountered the following error(s) while running \"%s\" on host %s:\n\n",
              myname, task, id, tmp);
      }
    } else {
      {
#line 53
      tmp___0 = get_hostname(0);
#line 53
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s encountered the following error(s) while running \"%s\" on host %s:\n\n",
              myname, task, tmp___0);
      }
    }
#line 54
    task = (char *)((void *)0);
  }
#line 57
  if (prefix) {
    {
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            myname);
    }
  }
  {
#line 59
  __builtin_va_start(va, format);
#line 60
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           va);
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 62
  fflush(stderr);
  }
#line 64
  if (tosyslog) {
    {
#line 65
    vsyslog(3, (char const   *)format, va);
    }
  }
  {
#line 67
  __builtin_va_end(va);
  }
#line 68
  return;
}
}
#line 76
 __attribute__((__noreturn__)) void myassert(char *assertion , char *file , char *function ,
                                             int line ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
void myassert(char *assertion , char *file , char *function , int line ) 
{ 


  {
#line 79
  if ((unsigned long )function != (unsigned long )((void *)0)) {
    {
#line 80
    error((char *)"Assertion failed: %s, file %s, function %s, line %d", assertion,
          file, function, line);
    }
  } else {
    {
#line 83
    error((char *)"Assertion failed: %s, file %s, line %d", assertion, file, line);
    }
  }
  {
#line 84
  abort();
  }
}
}
#line 91
 __attribute__((__noreturn__)) void myabort(char *file , char *function , int line ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/error.c"
void myabort(char *file , char *function , int line ) 
{ 


  {
#line 94
  if ((unsigned long )function != (unsigned long )((void *)0)) {
    {
#line 95
    error((char *)"The impossible just happened: line %d in function \"%s\" in file %s was reached!",
          line, function, file);
    }
  } else {
    {
#line 97
    error((char *)"The impossible just happened: line %d in file %s was reached!",
          line, file);
    }
  }
  {
#line 99
  abort();
  }
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 253
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.h"
void state_init(char *cfdir___0 , char *job___0 ) ;
#line 14
void state_delay(time_t delay ) ;
#line 15
void state_run(void) ;
#line 16
void state_timeout(void) ;
#line 20
void state_locked(int status ) ;
#line 21
void state_killed(void) ;
#line 22
void state_close(char *msg ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.h"
char *cf_getstr(int code ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
static char statepath[4096]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
static int fd  =    -1;
#line 27 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
struct __anonstruct_state_66 state  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
static void *state_save(void *null ) 
{ 
  char str[1024] ;
  char lock ;
  int len ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  time_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __off_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 48
  fd = open((char const   *)(statepath), 194, 420);
  }
#line 49
  if (fd == -1) {
    {
#line 51
    tmp___1 = __errno_location();
    }
#line 51
    if (*tmp___1 != 2) {
      {
#line 52
      tmp = __errno_location();
#line 52
      tmp___0 = strerror(*tmp);
#line 52
      error((char *)"open(%s) failed: %s", statepath, tmp___0);
      }
    } else {
      {
#line 51
      tmp___2 = cf_getstr(23);
      }
#line 51
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        {
#line 52
        tmp = __errno_location();
#line 52
        tmp___0 = strerror(*tmp);
#line 52
        error((char *)"open(%s) failed: %s", statepath, tmp___0);
        }
      }
    }
    {
#line 53
    pthread_exit((void *)0);
    }
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 58
    tmp___3 = time((time_t *)((void *)0));
    }
#line 58
    if (tmp___3 - state.last < 30L) {
      {
#line 60
      sleep(1U);
      }
#line 61
      goto while_continue;
    }
    {
#line 64
    tmp___6 = lseek(fd, (__off_t )0, 0);
    }
#line 64
    if (tmp___6 != 0L) {
      {
#line 66
      tmp___4 = __errno_location();
#line 66
      tmp___5 = strerror(*tmp___4);
#line 66
      error((char *)"lseek(%s, SEEK_SET, 0) failed, state lost: %s", statepath, tmp___5);
#line 68
      close(fd);
#line 69
      fd = -1;
#line 70
      pthread_exit((void *)0);
      }
    }
#line 73
    if (state.end == 0L) {
#line 73
      if ((unsigned long )state.msg == (unsigned long )((void *)0)) {
        {
#line 75
        state.last = time((time_t *)((void *)0));
        }
      } else {
#line 78
        state.last = (time_t )0;
      }
    } else {
#line 78
      state.last = (time_t )0;
    }
#line 80
    if (state.locked == 1) {
#line 81
      lock = (char )'L';
    } else
#line 82
    if (state.locked == 2) {
#line 83
      lock = (char )'I';
    } else
#line 84
    if (state.locked == 3) {
#line 85
      lock = (char )'F';
    } else {
#line 87
      lock = (char )'-';
    }
    {
#line 89
    len = snprintf((char */* __restrict  */)(str), (size_t )1024, (char const   */* __restrict  */)"%lu %lu %lu %lu %lu %lu %c %u %.80s\n",
                   state.last, state.start, state.delay, state.run, state.timeout,
                   state.end, (int )lock, state.killed, state.msg);
#line 93
    tmp___9 = write(fd, (void const   *)(str), (size_t )len);
    }
#line 93
    if (tmp___9 != (ssize_t )len) {
      {
#line 95
      tmp___7 = __errno_location();
#line 95
      tmp___8 = strerror(*tmp___7);
#line 95
      error((char *)"write(%s) failed, state lost: %s", statepath, tmp___8);
#line 96
      close(fd);
#line 97
      fd = -1;
#line 98
      pthread_exit((void *)0);
      }
    }
    {
#line 101
    tmp___12 = ftruncate(fd, (__off_t )len);
    }
#line 101
    if (tmp___12 != 0) {
      {
#line 103
      tmp___10 = __errno_location();
#line 103
      tmp___11 = strerror(*tmp___10);
#line 103
      error((char *)"ftruncate(%s, %d) failed, state lost: %s", statepath, len, tmp___11);
#line 105
      close(fd);
#line 106
      fd = -1;
#line 107
      pthread_exit((void *)0);
      }
    }
#line 110
    if (state.last == 0L) {
      {
#line 112
      close(fd);
#line 113
      fd = -1;
#line 114
      pthread_exit((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
void state_init(char *cfdir___0 , char *job___0 ) 
{ 
  pthread_t save ;
  char *sdir ;
  int status ;
  __pid_t tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 129
  state.start = time((time_t *)((void *)0));
#line 130
  state.last = (time_t )0;
#line 131
  state.delay = (time_t )0;
#line 132
  state.run = (time_t )0;
#line 133
  state.timeout = (time_t )0;
#line 134
  state.end = (time_t )0;
#line 135
  state.locked = 0;
#line 136
  state.killed = 0;
#line 137
  state.msg = (char *)"";
#line 139
  sdir = cf_getstr(23);
  }
#line 140
  if ((unsigned long )sdir == (unsigned long )((void *)0)) {
    {
#line 141
    tmp = getpid();
#line 141
    tmp___0 = get_hostname(0);
#line 141
    snprintf((char */* __restrict  */)(statepath), (size_t )4096, (char const   */* __restrict  */)"%s/.state/shtate-%lu-%s-%s-%u",
             cfdir___0, state.start, job___0, tmp___0, tmp);
    }
  } else
#line 143
  if ((int )*(sdir + 0) == 0) {
#line 144
    return;
  } else {
    {
#line 146
    tmp___1 = getpid();
#line 146
    tmp___2 = get_hostname(0);
#line 146
    snprintf((char */* __restrict  */)(statepath), (size_t )4096, (char const   */* __restrict  */)"%s/shtate-%lu-%s-%s-%u",
             sdir, state.start, job___0, tmp___2, tmp___1);
    }
  }
  {
#line 150
  status = pthread_create((pthread_t */* __restrict  */)(& save), (pthread_attr_t const   */* __restrict  */)((void *)0),
                          & state_save, (void */* __restrict  */)((void *)0));
  }
#line 151
  if (status != 0) {
    {
#line 152
    tmp___3 = strerror(status);
#line 152
    error((char *)"pthread_create(state_save) failed: %s", tmp___3);
    }
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
void state_delay(time_t delay ) 
{ 


  {
#line 159
  if (! (state.delay == 0L)) {
    {
#line 159
    myassert((char *)"state.delay == 0", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c",
             (char *)((void *)0), 159);
    }
  }
#line 160
  state.delay = delay;
#line 161
  state.last = (time_t )1;
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
void state_run(void) 
{ 


  {
#line 167
  if (! (state.run == 0L)) {
    {
#line 167
    myassert((char *)"state.run == 0", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c",
             (char *)((void *)0), 167);
    }
  }
  {
#line 168
  state.run = time((time_t *)((void *)0));
#line 169
  state.last = (time_t )1;
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
void state_timeout(void) 
{ 


  {
#line 175
  if (state.timeout == 0L) {
    {
#line 177
    state.timeout = time((time_t *)((void *)0));
#line 178
    state.last = (time_t )1;
    }
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
void state_locked(int status ) 
{ 


  {
#line 185
  state.locked = status;
#line 186
  state.last = (time_t )1;
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
void state_killed(void) 
{ 


  {
#line 192
  (state.killed) ++;
#line 193
  state.last = (time_t )1;
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/state.c"
void state_close(char *msg ) 
{ 
  int max ;
  int tmp ;

  {
#line 201
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
    {
#line 202
    state.end = time((time_t *)((void *)0));
    }
  } else {
#line 204
    state.msg = msg;
  }
#line 205
  state.last = (time_t )1;
#line 207
  max = 15;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    tmp = max;
#line 208
    max --;
#line 208
    if (tmp > 0) {
#line 208
      if (! (fd >= 0)) {
#line 208
        goto while_break;
      }
    } else {
#line 208
      goto while_break;
    }
    {
#line 209
    sleep(1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 379 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.h"
pid_t exec(int fd0 , int fd1 , int fd2 , int newgrp , char **cmd ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c"
static  __attribute__((__noreturn__)) void fatal(int fd___0 , char *format  , ...) ;
#line 39
static  __attribute__((__noreturn__)) void fatal(int fd___0 , char *format  , ...) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c"
static void fatal(int fd___0 , char *format  , ...) 
{ 
  char msg[1024] ;
  va_list va ;
  size_t tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 45
  __builtin_va_start(va, format);
#line 46
  vsprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)format,
           va);
#line 47
  __builtin_va_end(va);
#line 48
  tmp = strlen((char const   *)(msg));
#line 48
  write(fd___0, (void const   *)(msg), tmp + 1UL);
#line 49
  tmp___0 = getpid();
#line 49
  kill(9, tmp___0);
#line 50
  sleep(5U);
#line 51
  myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c",
          (char *)((void *)0), 51);
  }
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c"
pid_t exec(int fd0 , int fd1 , int fd2 , int newgrp , char **cmd ) 
{ 
  struct rlimit fdlimit ;
  pid_t child ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int fd___0 ;
  struct sigaction sa ;
  char *command ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  __pid_t tmp___26 ;
  __pid_t tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;

  {
#line 64
  if (! (fd0 == -1)) {
#line 64
    if (! (fd0 > 2)) {
      {
#line 64
      myassert((char *)"fd0 == -1 || fd0 > 2", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c",
               (char *)((void *)0), 64);
      }
    }
  }
#line 65
  if (! (fd1 >= 1)) {
    {
#line 65
    myassert((char *)"fd1 >= 1", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c",
             (char *)((void *)0), 65);
    }
  }
#line 66
  if (! (fd2 >= 2)) {
    {
#line 66
    myassert((char *)"fd2 >= 2", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c",
             (char *)((void *)0), 66);
    }
  }
#line 67
  if (! ((unsigned long )cmd != (unsigned long )((void *)0))) {
    {
#line 67
    myassert((char *)"cmd != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/exec.c",
             (char *)((void *)0), 67);
    }
  }
  {
#line 74
  tmp___1 = getrlimit(7, & fdlimit);
  }
#line 74
  if (tmp___1 == -1) {
    {
#line 76
    tmp = __errno_location();
#line 76
    tmp___0 = strerror(*tmp);
#line 76
    error((char *)"getrlimit(RLIMIT_NOFILE): %s", tmp___0);
#line 77
    fdlimit.rlim_cur = (rlim_t )1024;
    }
  }
  {
#line 81
  child = fork();
  }
#line 83
  if (child == -1) {
    {
#line 86
    tmp___2 = __errno_location();
#line 86
    tmp___3 = strerror(*tmp___2);
#line 86
    error((char *)"fork(): %s", tmp___3);
    }
#line 87
    return (-1);
  }
#line 91
  if (child > 0) {
#line 93
    if (fd0 >= 0) {
      {
#line 94
      close(fd0);
      }
    }
#line 95
    return (child);
  } else {
#line 104
    fd___0 = 0;
    {
#line 105
    while (1) {
      while_continue: /* CIL Label */ ;
#line 105
      if (! ((rlim_t )fd___0 <= fdlimit.rlim_cur)) {
#line 105
        goto while_break;
      }
#line 107
      if (fd___0 != fd0) {
#line 107
        if (fd___0 != fd1) {
#line 107
          if (fd___0 != fd2) {
            {
#line 108
            close(fd___0);
            }
          }
        }
      }
#line 109
      fd___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 112
    if (fd0 < 0) {
      {
#line 114
      fd0 = open("/dev/null", 0, 0);
      }
#line 115
      if (fd0 == -1) {
        {
#line 116
        tmp___4 = __errno_location();
#line 116
        tmp___5 = strerror(*tmp___4);
#line 116
        fatal(fd2, (char *)"%s: open(%s): %s\n", myname, "/dev/null", tmp___5);
        }
      }
#line 118
      if (fd0 != 0) {
        {
#line 119
        fatal(fd2, (char *)"%s: open(%s) returned %d (should have been 0!)\n", myname,
              "/dev/null", fd___0);
        }
      }
    } else {
      {
#line 122
      tmp___8 = dup(fd0);
      }
#line 122
      if (tmp___8 != 0) {
        {
#line 123
        tmp___6 = __errno_location();
#line 123
        tmp___7 = strerror(*tmp___6);
#line 123
        fatal(fd2, (char *)"%s: dup(in) failed: %s\n", myname, tmp___7);
        }
      }
    }
#line 125
    if (fd1 != 1) {
      {
#line 125
      tmp___11 = dup(fd1);
      }
#line 125
      if (tmp___11 != 1) {
        {
#line 126
        tmp___9 = __errno_location();
#line 126
        tmp___10 = strerror(*tmp___9);
#line 126
        fatal(fd2, (char *)"%s: dup(out) failed: %s\n", myname, tmp___10);
        }
      }
    }
#line 127
    if (fd2 != 2) {
      {
#line 127
      tmp___14 = dup(fd2);
      }
#line 127
      if (tmp___14 != 2) {
        {
#line 128
        tmp___12 = __errno_location();
#line 128
        tmp___13 = strerror(*tmp___12);
#line 128
        fatal(fd2, (char *)"%s: dup(out) failed: %s\n", myname, tmp___13);
        }
      }
    }
#line 129
    if (fd1 > 2) {
      {
#line 129
      tmp___17 = close(fd1);
      }
#line 129
      if (tmp___17 == -1) {
        {
#line 130
        tmp___15 = __errno_location();
#line 130
        tmp___16 = strerror(*tmp___15);
#line 130
        fatal(2, (char *)"%s: close(out) failed: %s\n", myname, tmp___16);
        }
      }
    }
#line 131
    if (fd2 > 2) {
#line 131
      if (fd2 != fd1) {
        {
#line 131
        tmp___20 = close(fd2);
        }
#line 131
        if (tmp___20 == -1) {
          {
#line 132
          tmp___18 = __errno_location();
#line 132
          tmp___19 = strerror(*tmp___18);
#line 132
          fatal(2, (char *)"%s: close(err) failed: %s\n", myname, tmp___19);
          }
        }
      }
    }
    {
#line 135
    sigemptyset(& sa.sa_mask);
#line 136
    sa.sa_flags = 0;
#line 137
    sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 138
    tmp___23 = sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa),
                         (struct sigaction */* __restrict  */)((void *)0));
    }
#line 138
    if (tmp___23 != 0) {
      {
#line 139
      tmp___21 = __errno_location();
#line 139
      tmp___22 = strerror(*tmp___21);
#line 139
      fatal(2, (char *)"sigaction(SIGPIPE, SIG_DFL, NULL) failed: %s", myname, tmp___22);
      }
    }
#line 143
    if (newgrp != 0) {
      {
#line 143
      tmp___26 = getpid();
#line 143
      tmp___27 = getpid();
#line 143
      tmp___28 = setpgid(tmp___27, tmp___26);
      }
#line 143
      if (tmp___28 != 0) {
        {
#line 144
        tmp___24 = __errno_location();
#line 144
        tmp___25 = strerror(*tmp___24);
#line 144
        fatal(2, (char *)"%s: setpgid() failed: %s\n", myname, tmp___25);
        }
      }
    }
    {
#line 147
    command = *(cmd + 0);
#line 148
    *(cmd + 0) = __xpg_basename(command);
#line 149
    execv((char const   *)command, (char * const  *)cmd);
#line 152
    tmp___29 = __errno_location();
#line 152
    tmp___30 = strerror(*tmp___29);
#line 152
    fatal(2, (char *)"%s: execv(%s): %s\n", myname, command, tmp___30);
    }
  }
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.h"
void checkrun(char *cfdir___0 , char *job___0 , char *outlog , char *errlog , char **to ,
              char **envp ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.h"
time_t out_timestamp ;
#line 13
time_t err_timestamp ;
#line 14
size_t out_size ;
#line 14
size_t err_size ;
#line 15
char out_md5[33] ;
#line 15
char err_md5[33] ;
#line 17
int analyzer_init(char *outdef , char *errdef ) ;
#line 18
int analyzer_run(char *ostr , size_t olen , char *estr , size_t elen ) ;
#line 19
int analyzer_output(FILE *mail , int format , int output , size_t limit , char *ostr ,
                    size_t olen , char *estr , size_t elen ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.h"
time_t cf_timestamp ;
#line 58
size_t cf_size ;
#line 59
char cf_md5[33] ;
#line 61
char *cf_load(char *fname , char *instance ) ;
#line 69
long cf_getrptnum(int report , int code ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/debug.h"
void ( /* format attribute */  debug)(int level , char *format  , ...) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.h"
int variable_get(char *name , long *value___3 ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
static char timestr[256]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
static char *mystrftime(char *format , time_t when___1 ) 
{ 
  struct tm *tm ;
  size_t tmp ;

  {
  {
#line 39
  tm = localtime((time_t const   *)(& when___1));
#line 40
  tmp = strftime((char */* __restrict  */)(timestr), (size_t )256, (char const   */* __restrict  */)format,
                 (struct tm  const  */* __restrict  */)tm);
  }
#line 40
  if (tmp == 0UL) {
#line 41
    timestr[255] = (char )'\000';
  }
#line 42
  return (timestr);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c"
void checkrun(char *cfdir___0 , char *job___0 , char *outlog , char *errlog , char **to ,
              char **envp ) 
{ 
  char fname[4096] ;
  char outre[4096] ;
  char errre[4096] ;
  char *outstr ;
  char *errstr ;
  size_t outlen ;
  size_t errlen ;
  int rpt ;
  struct passwd *pw___0 ;
  __uid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int mail[2] ;
  int smstatus ;
  int err___0 ;
  int env ;
  FILE *sm ;
  char *format ;
  char *argv[4] ;
  pid_t child ;
  char const   *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  __uid_t tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  long lines ;
  int tmp___22 ;
  long lines___0 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  union __anonunion_54 __constr_expr_0 ;
  union __anonunion_55 __constr_expr_1 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  union __anonunion_56 __constr_expr_2 ;
  union __anonunion_57 __constr_expr_3 ;
  union __anonunion_58 __constr_expr_4 ;
  union __anonunion_59 __constr_expr_5 ;
  char *tmp___39 ;
  union __anonunion_60 __constr_expr_6 ;

  {
#line 53
  if (! ((unsigned long )cfdir___0 != (unsigned long )((void *)0))) {
    {
#line 53
    myassert((char *)"cfdir != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c",
             (char *)((void *)0), 53);
    }
  }
#line 54
  if (! ((unsigned long )job___0 != (unsigned long )((void *)0))) {
    {
#line 54
    myassert((char *)"job != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c",
             (char *)((void *)0), 54);
    }
  }
#line 55
  if (! ((unsigned long )outlog != (unsigned long )((void *)0))) {
#line 55
    if (! ((unsigned long )errlog == (unsigned long )((void *)0))) {
      {
#line 55
      myassert((char *)"outlog != NULL || errlog == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c",
               (char *)((void *)0), 55);
      }
    }
  }
  {
#line 57
  tmp = getuid();
#line 57
  pw___0 = getpwuid(tmp);
#line 59
  snprintf((char */* __restrict  */)(fname), (size_t )4096, (char const   */* __restrict  */)"%s/%s",
           cfdir___0, job___0);
#line 60
  cf_load(fname, (char *)"");
  }
#line 61
  if (! (cf_timestamp != 0L)) {
    {
#line 61
    myassert((char *)"cf_timestamp != 0", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c",
             (char *)((void *)0), 61);
    }
  }
  {
#line 62
  tmp___0 = mystrftime((char *)"%Y/%m/%d %H:%M:%S", cf_timestamp);
#line 62
  printf((char const   */* __restrict  */)"%s: %s %ld %s\n", job___0, tmp___0, cf_size,
         cf_md5);
#line 64
  tmp___1 = cf_getstr(14);
#line 64
  snprintf((char */* __restrict  */)(outre), (size_t )4096, (char const   */* __restrict  */)"%s.stdout",
           tmp___1);
#line 65
  tmp___2 = cf_getstr(14);
#line 65
  snprintf((char */* __restrict  */)(errre), (size_t )4096, (char const   */* __restrict  */)"%s.stderr",
           tmp___2);
#line 66
  tmp___3 = analyzer_init(outre, errre);
  }
#line 66
  if (tmp___3 == -1) {
    {
#line 67
    exit(1);
    }
  }
#line 68
  if (out_timestamp != 0L) {
    {
#line 69
    tmp___4 = mystrftime((char *)"%Y/%m/%d %H:%M:%S", out_timestamp);
#line 69
    printf((char const   */* __restrict  */)"%s: stdout %s %ld %s\n", job___0, tmp___4,
           out_size, out_md5);
    }
  }
#line 72
  if (err_timestamp != 0L) {
    {
#line 73
    tmp___5 = mystrftime((char *)"%Y/%m/%d %H:%M:%S", err_timestamp);
#line 73
    printf((char const   */* __restrict  */)"%s: stderr %s %ld %s\n", job___0, tmp___5,
           err_size, err_md5);
    }
  }
#line 77
  if ((unsigned long )outlog == (unsigned long )((void *)0)) {
#line 77
    if ((unsigned long )errlog == (unsigned long )((void *)0)) {
#line 78
      return;
    }
  }
  {
#line 81
  tmp___6 = mapfile(outlog, -1, (void **)(& outstr), & outlen);
  }
#line 81
  if (tmp___6 != 0) {
    {
#line 82
    exit(1);
    }
  }
#line 83
  if ((unsigned long )errlog == (unsigned long )((void *)0)) {
#line 85
    errstr = (char *)((void *)0);
#line 86
    errlen = (size_t )0;
  } else {
    {
#line 88
    tmp___7 = mapfile(errlog, -1, (void **)(& errstr), & errlen);
    }
#line 88
    if (tmp___7 != 0) {
      {
#line 89
      exit(1);
      }
    }
  }
  {
#line 92
  tmp___8 = analyzer_run(outstr, outlen, errstr, errlen);
  }
#line 92
  if (tmp___8 != 0) {
    {
#line 93
    exit(1);
    }
  }
  {
#line 94
  debug(1, (char *)"Done with analysis.");
#line 97
  rpt = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (rpt < 3)) {
#line 98
      goto while_break;
    }
#line 106
    if ((unsigned long )*(to + rpt) == (unsigned long )((void *)0)) {
#line 108
      rpt ++;
#line 109
      goto while_continue;
    }
#line 111
    if (rpt == 0) {
#line 111
      format = (char *)"HTML";
    } else {
#line 111
      if (rpt == 1) {
#line 111
        tmp___9 = "Enriched";
      } else {
#line 111
        tmp___9 = "Text";
      }
#line 111
      format = (char *)tmp___9;
    }
    {
#line 112
    debug(1, (char *)"Generating %s report to \"%s\"...", format, *(to + rpt));
#line 115
    tmp___12 = pipe((int *)(mail));
    }
#line 115
    if (tmp___12 != 0) {
      {
#line 117
      tmp___10 = __errno_location();
#line 117
      tmp___11 = strerror(*tmp___10);
#line 117
      error((char *)"pipe() failed for %s report: %s", format, tmp___11);
      }
#line 118
      goto while_continue;
    }
    {
#line 120
    sm = fdopen(mail[1], "w");
    }
#line 121
    if ((unsigned long )sm == (unsigned long )((void *)0)) {
      {
#line 123
      tmp___13 = __errno_location();
#line 123
      tmp___14 = strerror(*tmp___13);
#line 123
      error((char *)"fdopen() failed for %s report: %s", format, tmp___14);
#line 124
      close(mail[0]);
#line 125
      close(mail[1]);
      }
#line 126
      goto while_continue;
    }
    {
#line 130
    argv[0] = cf_getstr(21);
#line 131
    argv[1] = (char *)"-t";
#line 132
    argv[2] = (char *)"-i";
#line 133
    argv[3] = (char *)((void *)0);
#line 134
    child = exec(mail[0], 1, 2, 0, argv);
    }
#line 135
    if (child < 0) {
      {
#line 137
      error((char *)"Failed to send %s report", format);
#line 138
      fclose(sm);
      }
#line 139
      goto while_continue;
    }
    {
#line 143
    err___0 = 1;
#line 144
    err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"To: %s\n",
                      *(to + rpt));
    }
#line 145
    if (err___0 > 0) {
      {
#line 146
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"Subject: %s report sample for %s\n",
                        format, job___0);
      }
    }
#line 148
    if (err___0 > 0) {
      {
#line 149
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Version: %s\n",
                        "1.0");
      }
    }
#line 150
    env = 0;
    {
#line 151
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 151
      if (err___0 > 0) {
#line 151
        if (! ((unsigned long )*(envp + env) != (unsigned long )((void *)0))) {
#line 151
          goto while_break___0;
        }
      } else {
#line 151
        goto while_break___0;
      }
      {
#line 152
      tmp___15 = env;
#line 152
      env ++;
#line 152
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Env: <%s>\n",
                        *(envp + tmp___15));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 153
    if (err___0 > 0) {
      {
#line 154
      tmp___16 = mystrftime((char *)"%Y/%m/%d %H:%M:%S", cf_timestamp);
#line 154
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Name: %s %s %ld %s\n",
                        job___0, tmp___16, cf_size, cf_md5);
      }
    }
#line 157
    if (err___0 > 0) {
#line 157
      if (out_timestamp != 0L) {
        {
#line 158
        tmp___17 = mystrftime((char *)"%Y/%m/%d %H:%M:%S", out_timestamp);
#line 158
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stdout: %s %ld %s\n",
                          tmp___17, out_size, out_md5);
        }
      }
    }
#line 161
    if (err___0 > 0) {
#line 161
      if (err_timestamp != 0L) {
        {
#line 162
        tmp___18 = mystrftime((char *)"%Y/%m/%d %H:%M:%S", err_timestamp);
#line 162
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stderr: %s %ld %s\n",
                          tmp___18, err_size, err_md5);
        }
      }
    }
#line 165
    if (err___0 > 0) {
      {
#line 166
      tmp___19 = getuid();
      }
#line 166
      if ((unsigned long )pw___0 != (unsigned long )((void *)0)) {
#line 166
        if ((unsigned long )pw___0->pw_name != (unsigned long )((void *)0)) {
#line 166
          tmp___20 = (char const   *)pw___0->pw_name;
        } else {
#line 166
          tmp___20 = "?";
        }
      } else {
#line 166
        tmp___20 = "?";
      }
      {
#line 166
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-User: %s [%u]\n",
                        tmp___20, tmp___19);
      }
    }
#line 169
    if (err___0 > 0) {
      {
#line 170
      tmp___21 = cf_getstr(13);
#line 170
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Command: %s\n",
                        tmp___21);
      }
    }
#line 171
    if (err___0 > 0) {
      {
#line 175
      tmp___22 = variable_get((char *)"outlines", & lines);
      }
#line 175
      if (tmp___22 != 0) {
        {
#line 176
        myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c",
                (char *)((void *)0), 176);
        }
      }
      {
#line 177
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stdout-Size: %ld lines, %ld Bytes\n",
                        lines, outlen);
      }
    }
#line 180
    if (err___0 > 0) {
      {
#line 184
      tmp___23 = variable_get((char *)"errlines", & lines___0);
      }
#line 184
      if (tmp___23 != 0) {
        {
#line 185
        myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/check.c",
                (char *)((void *)0), 185);
        }
      }
      {
#line 186
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stderr-Size: %ld lines, %ld Bytes\n",
                        lines___0, errlen);
      }
    }
#line 189
    if (err___0 > 0) {
#line 189
      if (rpt == 0) {
        {
#line 190
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"Content-Type: text/html\n");
        }
      }
    }
#line 191
    if (err___0 > 0) {
#line 191
      if (rpt == 1) {
        {
#line 192
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"Content-Type: text/enriched\n");
        }
      }
    }
#line 193
    if (err___0 > 0) {
      {
#line 194
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"\n");
      }
    }
#line 195
    if (err___0 <= 0) {
      {
#line 197
      tmp___24 = __errno_location();
#line 197
      tmp___25 = strerror(*tmp___24);
#line 197
      error((char *)"Error while writing mail headers for %s report: %s", format,
            tmp___25);
#line 199
      err___0 = -1;
      }
    } else {
      {
#line 201
      tmp___26 = cf_getrptnum(rpt, 7);
#line 201
      tmp___27 = cf_getrptnum(rpt, 10);
      }
#line 201
      if (rpt == 0) {
#line 201
        tmp___29 = 3;
      } else {
#line 201
        if (rpt == 1) {
#line 201
          tmp___28 = 2;
        } else {
#line 201
          tmp___28 = 1;
        }
#line 201
        tmp___29 = tmp___28;
      }
      {
#line 201
      tmp___30 = analyzer_output(sm, tmp___29, (int )tmp___27, (size_t )tmp___26,
                                 outstr, outlen, errstr, errlen);
      }
#line 201
      if (tmp___30 != 0) {
        {
#line 207
        error((char *)"Errors while sending output for %s report.", format);
        }
      }
    }
    {
#line 208
    tmp___33 = fclose(sm);
    }
#line 208
    if (tmp___33 != 0) {
#line 208
      if (err___0 == 0) {
        {
#line 209
        tmp___31 = __errno_location();
#line 209
        tmp___32 = strerror(*tmp___31);
#line 209
        error((char *)"Errors while sending %s report: %s", format, tmp___32);
        }
      }
    }
    {
#line 212
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 214
      err___0 = waitpid(child, & smstatus, 0);
      }
#line 215
      if (err___0 == child) {
#line 215
        __constr_expr_0.__in = smstatus;
#line 215
        if ((__constr_expr_0.__i & 127) == 0) {
#line 216
          goto while_break___1;
        } else {
#line 215
          __constr_expr_1.__in = smstatus;
#line 215
          if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 216
            goto while_break___1;
          }
        }
      }
#line 217
      if (err___0 == -1) {
        {
#line 219
        tmp___38 = __errno_location();
        }
#line 219
        if (*tmp___38 == 4) {
          {
#line 220
          tmp___34 = __errno_location();
#line 220
          tmp___35 = strerror(*tmp___34);
#line 220
          debug(1, (char *)"waitpid(%d): %s", child, tmp___35);
          }
        } else {
          {
#line 222
          tmp___36 = __errno_location();
#line 222
          tmp___37 = strerror(*tmp___36);
#line 222
          error((char *)"waitpid(%d[sendmail for %s report]) failed: %s", child, format,
                tmp___37);
          }
        }
      }
      {
#line 225
      sleep(1U);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 230
    __constr_expr_3.__in = smstatus;
#line 230
    if ((__constr_expr_3.__i & 127) == 0) {
#line 230
      __constr_expr_4.__in = smstatus;
#line 230
      if ((__constr_expr_4.__i & 65280) >> 8 != 0) {
        {
#line 231
        __constr_expr_2.__in = smstatus;
#line 231
        error((char *)"sendmail for %s report returned: %d", format, (__constr_expr_2.__i & 65280) >> 8);
        }
      }
    }
#line 233
    __constr_expr_6.__in = smstatus;
#line 233
    if ((int )((signed char )((__constr_expr_6.__i & 127) + 1)) >> 1 > 0) {
      {
#line 234
      __constr_expr_5.__in = smstatus;
#line 234
      tmp___39 = strsignal(__constr_expr_5.__i & 127);
#line 234
      error((char *)"sendmail for %s report died from %s", format, tmp___39);
      }
    }
#line 237
    rpt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/gethostname.c"
static char hostname[65]  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/gethostname.c"
char *get_hostname(int dots ) 
{ 
  char *dot ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 22
  tmp___1 = gethostname(hostname, (size_t )64);
  }
#line 22
  if (tmp___1 != 0) {
    {
#line 24
    tmp = __errno_location();
#line 24
    tmp___0 = strerror(*tmp);
#line 24
    error((char *)"gethostname() failed: %s", tmp___0);
    }
#line 25
    return ((char *)"");
  }
#line 27
  hostname[64] = (char )'\000';
#line 29
  if (dots > 0) {
#line 31
    dot = hostname;
    {
#line 32
    while (1) {
      while_continue: /* CIL Label */ ;
#line 32
      if ((int )*dot != 0) {
#line 32
        if (! (dots > 0)) {
#line 32
          goto while_break;
        }
      } else {
#line 32
        goto while_break;
      }
#line 34
      if ((int )*dot == 46) {
#line 35
        dots --;
      }
#line 36
      dot ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 38
    if (dots == 0) {
#line 39
      *(dot - 1) = (char )'\000';
    }
  } else
#line 41
  if (dots < 0) {
    {
#line 43
    tmp___2 = strlen((char const   *)(hostname));
#line 43
    dot = (hostname + tmp___2) - 1;
    }
    {
#line 44
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 44
      if ((unsigned long )dot != (unsigned long )(hostname)) {
#line 44
        if (! (dots < 0)) {
#line 44
          goto while_break___0;
        }
      } else {
#line 44
        goto while_break___0;
      }
#line 46
      if ((int )*dot == 46) {
#line 47
        dots ++;
      }
#line 48
      dot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 50
    if (dots == 0) {
#line 51
      *(dot + 1) = (char )'\000';
    }
  }
#line 54
  return (hostname);
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.h"
void variable_set(char *name , long value___3 ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.c"
static struct variable variables[12]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.c"
  {      {(char *)"exit", 0L}, 
        {(char *)"size", 0L}, 
        {(char *)"outsize", 0L}, 
        {(char *)"errsize", 0L}, 
        {(char *)"lines", 0L}, 
        {(char *)"outlines", 0L}, 
        {(char *)"errlines", 0L}, 
        {(char *)"runtime", 0L}, 
        {(char *)"utime", 0L}, 
        {(char *)"stime", 0L}, 
        {(char *)"tty", 0L}, 
        {(char *)((void *)0), -1L}};
#line 42 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.c"
void variable_set(char *name , long value___3 ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 47
  i___0 = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! ((unsigned long )variables[i___0].name != (unsigned long )((void *)0))) {
#line 48
      goto while_break;
    }
    {
#line 50
    tmp = strcasecmp((char const   *)variables[i___0].name, (char const   *)name);
    }
#line 50
    if (tmp == 0) {
#line 52
      variables[i___0].value = value___3;
#line 53
      return;
    }
#line 55
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.c",
          (char *)((void *)0), 58);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/variable.c"
int variable_get(char *name , long *value___3 ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 70
  i___0 = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )variables[i___0].name != (unsigned long )((void *)0))) {
#line 71
      goto while_break;
    }
    {
#line 73
    tmp = strcasecmp((char const   *)variables[i___0].name, (char const   *)name);
    }
#line 73
    if (tmp == 0) {
#line 75
      *value___3 = variables[i___0].value;
#line 76
      return (0);
    }
#line 78
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return (-1);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.h"
void byteset_init(char *definition , int value___3 ) ;
#line 14
void byteset_set(int byte , int value___3 ) ;
#line 15
int byteset_get(int byte ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c"
static long set[256]  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c"
static int once  =    1;
#line 23 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c"
void byteset_init(char *definition , int value___3 ) 
{ 
  char *str ;
  char *tok ;
  char *dash ;
  int i___0 ;
  int j ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
#line 29
  if (! ((unsigned long )definition != (unsigned long )((void *)0))) {
    {
#line 29
    myassert((char *)"definition != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c",
             (char *)((void *)0), 29);
    }
  }
#line 31
  if (once == 1) {
#line 33
    once = 0;
#line 34
    i___0 = 0;
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
#line 35
      if (! (i___0 < 256)) {
#line 35
        goto while_break;
      }
#line 36
      tmp = i___0;
#line 36
      i___0 ++;
#line 36
      set[tmp] = 0L;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 39
  str = strdup((char const   *)definition);
#line 40
  tok = strtok((char */* __restrict  */)str, (char const   */* __restrict  */)",");
  }
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 41
      goto while_break___0;
    }
#line 43
    if ((int )*(tok + 0) == 45) {
#line 44
      i___0 = 0;
    } else {
      {
#line 45
      tmp___0 = __ctype_b_loc();
      }
#line 45
      if (((int const   )*(*tmp___0 + (int )*(tok + 0)) & 2048) != 0) {
        {
#line 46
        i___0 = atoi((char const   *)tok);
        }
      } else {
#line 48
        i___0 = -1;
      }
    }
    {
#line 50
    j = i___0;
#line 51
    dash = index((char const   *)tok, '-');
    }
#line 52
    if ((unsigned long )dash != (unsigned long )((void *)0)) {
#line 54
      if ((int )*(dash + 1) != 0) {
        {
#line 56
        tmp___1 = __ctype_b_loc();
        }
#line 56
        if (((int const   )*(*tmp___1 + (int )*(dash + 1)) & 2048) != 0) {
          {
#line 57
          j = atoi((char const   *)(dash + 1));
          }
        } else {
#line 59
          j = -1;
        }
      } else {
#line 62
        j = 255;
      }
    }
#line 65
    if (i___0 < 0) {
      {
#line 67
      error((char *)"Invalid range: %s", tok);
#line 68
      exit(1);
      }
    } else
#line 65
    if (i___0 > 255) {
      {
#line 67
      error((char *)"Invalid range: %s", tok);
#line 68
      exit(1);
      }
    } else
#line 65
    if (j < 0) {
      {
#line 67
      error((char *)"Invalid range: %s", tok);
#line 68
      exit(1);
      }
    } else
#line 65
    if (j > 255) {
      {
#line 67
      error((char *)"Invalid range: %s", tok);
#line 68
      exit(1);
      }
    } else
#line 65
    if (j < i___0) {
      {
#line 67
      error((char *)"Invalid range: %s", tok);
#line 68
      exit(1);
      }
    }
    {
#line 71
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! (i___0 <= j)) {
#line 71
        goto while_break___1;
      }
#line 72
      tmp___2 = i___0;
#line 72
      i___0 ++;
#line 72
      set[tmp___2] = (long )value___3;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 74
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 76
  free((void *)str);
  }
#line 77
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c"
void byteset_set(int byte , int value___3 ) 
{ 


  {
#line 86
  if (byte >= 0) {
#line 86
    if (! (byte <= 255)) {
      {
#line 86
      myassert((char *)"byte >= 0 && byte <= 255", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c",
               (char *)((void *)0), 86);
      }
    }
  } else {
    {
#line 86
    myassert((char *)"byte >= 0 && byte <= 255", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c",
             (char *)((void *)0), 86);
    }
  }
#line 88
  set[byte] = (long )value___3;
#line 89
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c"
int byteset_get(int byte ) 
{ 


  {
#line 98
  if (byte >= 0) {
#line 98
    if (! (byte <= 255)) {
      {
#line 98
      myassert((char *)"byte >= 0 && byte <= 255", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c",
               (char *)((void *)0), 98);
      }
    }
  } else {
    {
#line 98
    myassert((char *)"byte >= 0 && byte <= 255", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/byteset.c",
             (char *)((void *)0), 98);
    }
  }
#line 100
  return ((int )set[byte]);
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/debug.h"
void debug_init(int level ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/debug.c"
static int debug_level  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/debug.c"
void debug_init(int level ) 
{ 


  {
#line 26
  debug_level = level;
#line 27
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/debug.c"
void ( /* format attribute */  debug)(int level , char *format  , ...) 
{ 
  va_list va ;

  {
#line 38
  if (level > debug_level) {
#line 39
    return;
  }
  {
#line 41
  __builtin_va_start(va, format);
#line 42
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           va);
#line 43
  __builtin_va_end(va);
#line 44
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 45
  fflush(stderr);
  }
#line 46
  return;
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/os.h"
char *myname  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.h"
void crontab(char *mypath , char *cfdir___0 , int action ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.h"
void run(char *cfdir___0 , char *myjob , char *myid , char *slfac , int options ,
         char **envp ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/shush.c"
static void usage(int detailed ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/shush.c"
static void usage(int detailed ) 
{ 


  {
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [ -h | [ -v ] -V ]\n",
          myname);
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [ -c <dir> ] [ -s <facility> | -S ] [ -vfmk ] <name> [ <ID> ]\n",
          myname);
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [ -c <dir> ] [ -H <to> ] [ -R <to> ] [ -T <to> ] -C <name> [ <stdout> [ <stderr> ] ]\n",
          myname);
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [ -c <dir> ] [ -i | -u | -r ]\n",
          myname);
  }
#line 40
  if (detailed == 0) {
    {
#line 41
    exit(0);
    }
  }
  {
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h            Print this message.\n");
#line 43
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -V            Output version info.\n");
#line 44
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -c <dir>      Specify configuration directory.\n");
#line 46
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d <level>    Enable debugging.\n");
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 48
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -s <facility> Use specified syslog facility.\n");
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -S            Disable use of syslog.\n");
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v            Copy syslog messages to the standard output.\n");
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f            Run the command without any (random) delay.\n");
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -m            Monitor the command output while it is running.\n");
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -k            Keep the command output log files.\n");
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -C            Configuration check.\n");
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -H <to>       HTML report recipient(s).\n");
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -R <to>       Enriched report recipient(s).\n");
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -T <to>       Text report recipient(s).\n");
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -i            Install crontab.\n");
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -u            Update crontab.\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r            Remove any entry from crontab.\n");
#line 67
  exit(1);
  }
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/shush.c"
int main(int argc , char **argv , char **envp ) 
{ 
  int badopt ;
  int check ;
  int ctab ;
  int runopts ;
  char cfdir___0[4097] ;
  char *slfac ;
  char *to[3] ;
  int c ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *job___0 ;
  char *id___1 ;
  char *tmp___2 ;
  char *job___1 ;
  char *outlog ;
  char *errlog ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 76
  myname = __xpg_basename(*(argv + 0));
#line 78
  runopts = 0;
#line 78
  ctab = runopts;
#line 78
  check = ctab;
#line 79
  cfdir___0[1] = (char )'\000';
#line 80
  slfac = (char *)"cron";
#line 81
  to[2] = (char *)((void *)0);
#line 81
  to[1] = to[2];
#line 81
  to[0] = to[1];
#line 83
  badopt = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 88
    c = getopt(argc, (char * const  *)argv, "c:Cd:fhH:ikmrR:s:ST:vVu");
    }
#line 91
    if (c == -1) {
#line 92
      goto while_break;
    }
    {
#line 96
    if (c == 99) {
#line 96
      goto case_99;
    }
#line 100
    if (c == 67) {
#line 100
      goto case_67;
    }
#line 103
    if (c == 100) {
#line 103
      goto case_100;
    }
#line 106
    if (c == 102) {
#line 106
      goto case_102;
    }
#line 109
    if (c == 104) {
#line 109
      goto case_104;
    }
#line 111
    if (c == 72) {
#line 111
      goto case_72;
    }
#line 114
    if (c == 105) {
#line 114
      goto case_105;
    }
#line 117
    if (c == 107) {
#line 117
      goto case_107;
    }
#line 120
    if (c == 109) {
#line 120
      goto case_109;
    }
#line 130
    if (c == 114) {
#line 130
      goto case_114;
    }
#line 133
    if (c == 82) {
#line 133
      goto case_82;
    }
#line 136
    if (c == 115) {
#line 136
      goto case_115;
    }
#line 139
    if (c == 83) {
#line 139
      goto case_83;
    }
#line 142
    if (c == 84) {
#line 142
      goto case_84;
    }
#line 145
    if (c == 118) {
#line 145
      goto case_118;
    }
#line 148
    if (c == 86) {
#line 148
      goto case_86;
    }
#line 161
    if (c == 117) {
#line 161
      goto case_117;
    }
#line 164
    if (c == 63) {
#line 164
      goto case_63;
    }
#line 167
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 97
    cfdir___0[0] = (char )'1';
#line 98
    strcpy((char */* __restrict  */)(cfdir___0 + 1), (char const   */* __restrict  */)optarg);
    }
#line 99
    goto switch_break;
    case_67: /* CIL Label */ 
#line 101
    check = 1;
#line 102
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 104
    tmp = atoi((char const   *)optarg);
#line 104
    debug_init(tmp);
    }
#line 105
    goto switch_break;
    case_102: /* CIL Label */ 
#line 107
    runopts |= 1;
#line 108
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 110
    usage(1);
    }
    case_72: /* CIL Label */ 
#line 112
    to[0] = optarg;
#line 113
    goto switch_break;
    case_105: /* CIL Label */ 
#line 115
    ctab = 1;
#line 116
    goto switch_break;
    case_107: /* CIL Label */ 
#line 118
    runopts |= 8;
#line 119
    goto switch_break;
    case_109: /* CIL Label */ 
#line 122
    runopts |= 2;
#line 123
    goto switch_break;
    case_114: /* CIL Label */ 
#line 131
    ctab = 3;
#line 132
    goto switch_break;
    case_82: /* CIL Label */ 
#line 134
    to[1] = optarg;
#line 135
    goto switch_break;
    case_115: /* CIL Label */ 
#line 137
    slfac = optarg;
#line 138
    goto switch_break;
    case_83: /* CIL Label */ 
#line 140
    slfac = (char *)"";
#line 141
    goto switch_break;
    case_84: /* CIL Label */ 
#line 143
    to[2] = optarg;
#line 144
    goto switch_break;
    case_118: /* CIL Label */ 
#line 146
    runopts |= 4;
#line 147
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 150
    printf((char const   */* __restrict  */)"%s version %s\n", myname, "1.0");
    }
#line 155
    if ((runopts & 4) != 0) {
      {
#line 157
      printf((char const   */* __restrict  */)"\tDefault \"syslog\"   : %s\n", "cron");
#line 158
      printf((char const   */* __restrict  */)"\tDefault \"sizelimit\": %s\n", "1000k");
      }
    }
    {
#line 160
    exit(0);
    }
    case_117: /* CIL Label */ 
#line 162
    ctab = 2;
#line 163
    goto switch_break;
    case_63: /* CIL Label */ 
#line 165
    badopt ++;
#line 166
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 168
    myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/shush.c",
            (char *)((void *)0), 168);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  if ((ctab | check) == 0) {
#line 173
    if (optind == argc) {
      {
#line 182
      usage(0);
#line 183
      exit(1);
      }
    } else
#line 173
    if (optind < argc - 2) {
      {
#line 182
      usage(0);
#line 183
      exit(1);
      }
    } else {
#line 173
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 173
  if (check != 0) {
#line 173
    if ((ctab | runopts) != 0) {
      {
#line 182
      usage(0);
#line 183
      exit(1);
      }
    } else
#line 173
    if (optind >= argc) {
      {
#line 182
      usage(0);
#line 183
      exit(1);
      }
    } else
#line 173
    if (optind < argc - 3) {
      {
#line 182
      usage(0);
#line 183
      exit(1);
      }
    } else {
#line 173
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 173
  if (ctab != 0) {
#line 173
    if ((check | runopts) != 0) {
      {
#line 182
      usage(0);
#line 183
      exit(1);
      }
    } else
#line 173
    if (optind != argc) {
      {
#line 182
      usage(0);
#line 183
      exit(1);
      }
    } else {
#line 173
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 173
  if (badopt > 0) {
    {
#line 182
    usage(0);
#line 183
    exit(1);
    }
  }
#line 186
  if ((int )cfdir___0[1] == 0) {
    {
#line 189
    tmp___0 = getenv("HOME");
    }
#line 189
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 191
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: HOME is not set, you must use -c!\n",
              myname);
#line 192
      exit(1);
      }
    }
    {
#line 194
    cfdir___0[0] = (char)0;
#line 195
    tmp___1 = getenv("HOME");
#line 195
    snprintf((char */* __restrict  */)(cfdir___0 + 1), (size_t )4096, (char const   */* __restrict  */)"%s/.shush",
             tmp___1);
    }
  }
#line 198
  if ((check | ctab) == 0) {
#line 203
    if ((unsigned long )to[0] != (unsigned long )((void *)0)) {
      {
#line 205
      usage(0);
#line 206
      exit(1);
      }
    } else
#line 203
    if ((unsigned long )to[1] != (unsigned long )((void *)0)) {
      {
#line 205
      usage(0);
#line 206
      exit(1);
      }
    } else
#line 203
    if ((unsigned long )to[2] != (unsigned long )((void *)0)) {
      {
#line 205
      usage(0);
#line 206
      exit(1);
      }
    }
#line 209
    job___0 = *(argv + optind);
#line 210
    if (optind == argc - 1) {
#line 211
      id___1 = (char *)"";
    } else {
#line 213
      id___1 = *(argv + (argc - 1));
    }
#line 214
    if ((runopts & 4) != 0) {
#line 214
      tmp___2 = (char *)((void *)0);
    } else {
#line 214
      tmp___2 = job___0;
    }
    {
#line 214
    error_init(tmp___2, id___1, (int )*(slfac + 0) != 0);
#line 216
    run(cfdir___0 + 1, job___0, id___1, slfac, runopts, envp);
    }
  } else
#line 218
  if (check != 0) {
#line 223
    job___1 = *(argv + optind);
#line 224
    if (optind < argc - 1) {
#line 224
      outlog = *(argv + (optind + 1));
    } else {
#line 224
      outlog = (char *)((void *)0);
    }
#line 225
    if (optind < argc - 2) {
#line 225
      errlog = *(argv + (optind + 2));
    } else {
#line 225
      errlog = (char *)((void *)0);
    }
    {
#line 226
    error_init((char *)((void *)0), (char *)((void *)0), 0);
#line 227
    checkrun(cfdir___0 + 1, job___1, outlog, errlog, to, envp);
    }
  } else
#line 229
  if (ctab != 0) {
#line 232
    if ((unsigned long )to[0] != (unsigned long )((void *)0)) {
      {
#line 234
      usage(0);
#line 235
      exit(1);
      }
    } else
#line 232
    if ((unsigned long )to[1] != (unsigned long )((void *)0)) {
      {
#line 234
      usage(0);
#line 235
      exit(1);
      }
    } else
#line 232
    if ((unsigned long )to[2] != (unsigned long )((void *)0)) {
      {
#line 234
      usage(0);
#line 235
      exit(1);
      }
    }
    {
#line 238
    error_init((char *)((void *)0), (char *)((void *)0), 0);
#line 239
    tmp___4 = strcasecmp((char const   *)slfac, "cron");
    }
#line 239
    if (tmp___4 != 0) {
#line 240
      if ((unsigned long )slfac != (unsigned long )((void *)0)) {
#line 240
        tmp___3 = 's';
      } else {
#line 240
        tmp___3 = 'S';
      }
      {
#line 240
      error((char *)"-%c argument ignored.", tmp___3);
      }
    }
    {
#line 241
    crontab(*(argv + 0), cfdir___0, ctab);
    }
  }
  {
#line 244
  exit(0);
  }
}
}
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.h"
time_t out_timestamp  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.h"
time_t err_timestamp  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.h"
size_t out_size  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.h"
size_t err_size  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.h"
char out_md5[33]  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.h"
char err_md5[33]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static int outtype  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static int errtype  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static struct condition *out  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static struct condition *err  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static struct marker *outmarks  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static struct marker *errmarks  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static int compile_re(void *reptr , char *str ) 
{ 
  regex_t *re ;
  int errcode ;
  char buf[1024] ;
  size_t tmp ;

  {
  {
#line 78
  re = (regex_t *)reptr;
#line 79
  errcode = regcomp((regex_t */* __restrict  */)re, (char const   */* __restrict  */)str,
                    1);
  }
#line 80
  if (errcode != 0) {
    {
#line 84
    tmp = regerror(errcode, (regex_t const   */* __restrict  */)re, (char */* __restrict  */)(buf),
                   (size_t )1024);
    }
#line 84
    if (tmp != 0UL) {
      {
#line 85
      error((char *)"Bad regular expression: %s", buf);
      }
    } else {
      {
#line 87
      error((char *)"Failed to compile regular expression and to obtain error code: %s",
            str);
      }
    }
#line 88
    return (-1);
  }
#line 90
  return (0);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static int loadfile(int *type , char *file , struct condition **list ) 
{ 
  int lineno___0 ;
  int cond ;
  int max ;
  size_t len ;
  char *str ;
  char *ln___0 ;
  char *lndup___0 ;
  char *nl ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct stat *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 127
  if (! ((unsigned long )*list == (unsigned long )((void *)0))) {
    {
#line 127
    myassert((char *)"*list == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
             (char *)((void *)0), 127);
    }
  }
  {
#line 129
  *type = 1;
#line 132
  max = 10;
#line 133
  tmp = malloc((unsigned long )max * sizeof(struct condition ));
#line 133
  *list = (struct condition *)tmp;
  }
#line 134
  if ((unsigned long )*list == (unsigned long )((void *)0)) {
    {
#line 136
    tmp___0 = __errno_location();
#line 136
    tmp___1 = strerror(*tmp___0);
#line 136
    error((char *)"malloc() failed: %s", tmp___1);
    }
#line 137
    return (-1);
  }
  {
#line 139
  cond = 0;
#line 140
  (*list + cond)->code = -1;
#line 142
  err_timestamp = (time_t )0;
#line 144
  tmp___2 = mapfile(file, -1, (void **)(& str), & len);
  }
  {
#line 146
  if (tmp___2 == 0) {
#line 146
    goto case_0;
  }
#line 150
  if (tmp___2 == 1) {
#line 150
    goto case_1;
  }
#line 153
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 148
  tmp___3 = mapstat();
#line 148
  err_timestamp = tmp___3->st_mtim.tv_sec;
  }
#line 149
  goto switch_break;
  case_1: /* CIL Label */ 
#line 152
  return (0);
  switch_default: /* CIL Label */ 
#line 155
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 158
  if (len == 0UL) {
#line 159
    return (0);
  }
#line 161
  err_size = len;
#line 162
  err_md5[0] = (char )'\000';
#line 164
  ln___0 = str;
#line 164
  nl = str;
#line 165
  lineno___0 = 1;
#line 166
  lndup___0 = (char *)((void *)0);
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! ((size_t )(ln___0 - str) < len)) {
#line 167
      goto while_break;
    }
    {
#line 170
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 170
      if ((size_t )(nl - str) < len) {
#line 170
        if (! ((int )*nl != 10)) {
#line 170
          goto while_break___0;
        }
      } else {
#line 170
        goto while_break___0;
      }
#line 171
      nl ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    if ((size_t )(nl - str) == len) {
#line 175
      if ((int )*(nl - 1) != 0) {
#line 177
        if (! ((unsigned long )lndup___0 == (unsigned long )((void *)0))) {
          {
#line 177
          myassert((char *)"lndup == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
                   (char *)((void *)0), 177);
          }
        }
        {
#line 178
        tmp___4 = malloc((len - (size_t )(ln___0 - str)) + 1UL);
#line 178
        lndup___0 = (char *)tmp___4;
        }
#line 179
        if ((unsigned long )lndup___0 == (unsigned long )((void *)0)) {
          {
#line 181
          tmp___5 = __errno_location();
#line 181
          tmp___6 = strerror(*tmp___5);
#line 181
          error((char *)"malloc() failed: %s", tmp___6);
          }
#line 182
          return (-1);
        }
        {
#line 184
        memcpy((void */* __restrict  */)lndup___0, (void const   */* __restrict  */)ln___0,
               len - (size_t )(ln___0 - str));
#line 185
        *(lndup___0 + (len - (size_t )(ln___0 - str))) = (char )'\000';
#line 186
        ln___0 = lndup___0;
        }
      }
    } else {
#line 190
      *nl = (char )'\000';
    }
#line 192
    if ((int )*ln___0 == 35) {
      {
#line 195
      tmp___7 = strcasecmp((char const   *)ln___0, "#pcre");
      }
#line 195
      if (tmp___7 == 0) {
#line 197
        if (cond != 0) {
          {
#line 199
          error((char *)"\"#pcre\" directive must be specified before any condition.");
          }
#line 200
          if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
            {
#line 201
            free((void *)lndup___0);
            }
          }
#line 202
          return (-1);
        } else {
          {
#line 209
          error((char *)"This binary was built without PCRE support.");
          }
#line 210
          if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
            {
#line 211
            free((void *)lndup___0);
            }
          }
#line 212
          return (-1);
        }
      }
    } else {
#line 220
      if (cond == max - 2) {
        {
#line 222
        max *= 2;
#line 223
        tmp___8 = realloc((void *)*list, (unsigned long )max * sizeof(struct condition ));
#line 223
        *list = (struct condition *)tmp___8;
        }
#line 225
        if ((unsigned long )*list == (unsigned long )((void *)0)) {
          {
#line 227
          tmp___9 = __errno_location();
#line 227
          tmp___10 = strerror(*tmp___9);
#line 227
          error((char *)"realloc() failed: %s", tmp___10);
          }
#line 228
          if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
            {
#line 229
            free((void *)lndup___0);
            }
          }
#line 230
          return (-1);
        }
      }
#line 235
      if ((int )*ln___0 != 0) {
        {
#line 237
        (*list + cond)->code = (int )*ln___0;
#line 238
        (*list + cond)->expression = strdup((char const   *)(ln___0 + 1));
        }
#line 239
        if ((unsigned long )(*list + cond)->expression == (unsigned long )((void *)0)) {
          {
#line 241
          tmp___11 = __errno_location();
#line 241
          tmp___12 = strerror(*tmp___11);
#line 241
          error((char *)"strdup() failed: %s", tmp___12);
          }
#line 242
          if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
            {
#line 243
            free((void *)lndup___0);
            }
          }
#line 244
          return (-1);
        }
#line 246
        if (*type == 1) {
          {
#line 248
          tmp___13 = compile_re((void *)(& (*list + cond)->val.re), ln___0 + 1);
          }
#line 248
          if (tmp___13 != 0) {
#line 250
            if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
              {
#line 251
              free((void *)lndup___0);
              }
            }
#line 252
            return (-1);
          }
        } else
#line 255
        if (*type == 2) {
          {
#line 265
          error((char *)"This binary was built without PCRE support.");
          }
#line 266
          if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
            {
#line 267
            free((void *)lndup___0);
            }
          }
#line 268
          return (-1);
        } else {
          {
#line 272
          myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
                  (char *)((void *)0), 272);
          }
        }
#line 273
        cond ++;
      }
    }
#line 276
    ln___0 = nl + 1;
#line 277
    lineno___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
    {
#line 281
    free((void *)lndup___0);
    }
  }
  {
#line 283
  (*list + cond)->code = -1;
#line 285
  tmp___14 = unmapfile(file, (void *)str, len);
  }
#line 285
  if (tmp___14 != 0) {
#line 286
    return (-1);
  }
#line 288
  return (0);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
int analyzer_init(char *outdef , char *errdef ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 298
  if ((unsigned long )outdef != (unsigned long )((void *)0)) {
#line 298
    if (! ((unsigned long )errdef != (unsigned long )((void *)0))) {
      {
#line 298
      myassert((char *)"outdef != NULL && errdef != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
               (char *)((void *)0), 298);
      }
    }
  } else {
    {
#line 298
    myassert((char *)"outdef != NULL && errdef != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
             (char *)((void *)0), 298);
    }
  }
  {
#line 300
  errmarks = (struct marker *)((void *)0);
#line 300
  outmarks = errmarks;
#line 301
  tmp = loadfile(& outtype, outdef, & out);
  }
#line 301
  if (tmp != 0) {
#line 302
    return (-1);
  }
  {
#line 303
  out_timestamp = err_timestamp;
#line 303
  err_timestamp = (time_t )0;
#line 304
  out_size = err_size;
#line 305
  strcpy((char */* __restrict  */)(out_md5), (char const   */* __restrict  */)(err_md5));
#line 306
  tmp___1 = cf_getrptnum(0, 10);
  }
#line 306
  if (tmp___1 != 1L) {
    {
#line 307
    tmp___0 = loadfile(& errtype, errdef, & err);
    }
#line 307
    return (tmp___0);
  } else {
#line 309
    return (0);
  }
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static void grow_marks(struct marker **marks , int *max ) 
{ 
  struct marker *new ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 321
  *max *= 2;
#line 322
  tmp = realloc((void *)*marks, (unsigned long )*max * sizeof(struct marker ));
#line 322
  new = (struct marker *)tmp;
  }
#line 323
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 325
    tmp___0 = __errno_location();
#line 325
    tmp___1 = strerror(*tmp___0);
#line 325
    error((char *)"realloc() failed: %s", tmp___1);
#line 326
    free((void *)*marks);
#line 327
    *marks = (struct marker *)((void *)0);
    }
  } else {
#line 330
    *marks = new;
  }
#line 331
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static void set_mark(struct marker **marks , int *mark , int *max , size_t offset ,
                     int type ) 
{ 
  int i___0 ;
  int j ;

  {
#line 342
  i___0 = *mark - 1;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (i___0 >= 0) {
#line 343
      if (! ((*marks + i___0)->offset > offset)) {
#line 343
        goto while_break;
      }
    } else {
#line 343
      goto while_break;
    }
#line 344
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  if (i___0 >= 0) {
#line 346
    if ((*marks + i___0)->offset == offset) {
#line 347
      (*marks + i___0)->type = (char )((int )(*marks + i___0)->type | type);
    } else {
#line 346
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 352
    if (*mark == *max - 2) {
      {
#line 353
      grow_marks(marks, max);
      }
    }
#line 355
    j = *mark;
    {
#line 356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 356
      if (! (j > i___0)) {
#line 356
        goto while_break___0;
      }
#line 358
      (*marks + (j + 1))->offset = (*marks + j)->offset;
#line 359
      (*marks + (j + 1))->type = (*marks + j)->type;
#line 360
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 362
    (*marks + (i___0 + 1))->type = (char )type;
#line 363
    (*marks + (i___0 + 1))->offset = offset;
#line 364
    (*mark) ++;
  }
#line 366
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static int analyze_file(char *str , size_t len , int type , struct condition *list ,
                        struct marker **marks ) 
{ 
  char *ln___0 ;
  char *lndup___0 ;
  char *nl ;
  int max ;
  int mark ;
  int lineno___0 ;
  int condno ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int r ;
  regmatch_t pmatch[1024] ;
  char buf[1024] ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 379
  if (! (type == 1)) {
#line 379
    if (! (type == 2)) {
      {
#line 379
      myassert((char *)"type == RE || type == PCRE", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
               (char *)((void *)0), 379);
      }
    }
  }
#line 380
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 380
    myassert((char *)"list != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
             (char *)((void *)0), 380);
    }
  }
#line 381
  if (! ((unsigned long )*marks == (unsigned long )((void *)0))) {
    {
#line 381
    myassert((char *)"*marks == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
             (char *)((void *)0), 381);
    }
  }
#line 383
  if (len == 0UL) {
#line 384
    return (0);
  }
#line 386
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 386
    myassert((char *)"str != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
             (char *)((void *)0), 386);
    }
  }
  {
#line 389
  max = 10;
#line 390
  tmp = malloc((unsigned long )max * sizeof(struct marker ));
#line 390
  *marks = (struct marker *)tmp;
  }
#line 391
  if ((unsigned long )*marks == (unsigned long )((void *)0)) {
    {
#line 393
    tmp___0 = __errno_location();
#line 393
    tmp___1 = strerror(*tmp___0);
#line 393
    error((char *)"malloc() failed: %s", tmp___1);
    }
#line 394
    return (-1);
  }
#line 396
  mark = 0;
#line 397
  (*marks + mark)->type = (char)0;
#line 399
  ln___0 = str;
#line 399
  nl = str;
#line 400
  lineno___0 = 0;
#line 401
  lndup___0 = (char *)((void *)0);
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! ((size_t )(ln___0 - str) < len)) {
#line 402
      goto while_break;
    }
    {
#line 405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 405
      if ((size_t )(nl - str) < len) {
#line 405
        if ((int )*nl != 10) {
#line 405
          if (! ((int )*nl != 0)) {
#line 405
            goto while_break___0;
          }
        } else {
#line 405
          goto while_break___0;
        }
      } else {
#line 405
        goto while_break___0;
      }
#line 407
      if ((unsigned long )*marks != (unsigned long )((void *)0)) {
#line 409
        if ((int )*nl == 60) {
          {
#line 410
          set_mark(marks, & mark, & max, (size_t )(nl - str), 1);
          }
        } else
#line 411
        if ((int )*nl == 62) {
          {
#line 412
          set_mark(marks, & mark, & max, (size_t )(nl - str), 2);
          }
        } else
#line 413
        if ((int )*nl == 38) {
          {
#line 414
          set_mark(marks, & mark, & max, (size_t )(nl - str), 4);
          }
        }
      }
#line 416
      nl ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    if ((int )*nl == 0) {
#line 420
      goto while_break;
    }
#line 422
    if ((int )*nl == 10) {
      {
#line 424
      set_mark(marks, & mark, & max, (size_t )(nl - str), 64);
#line 425
      *nl = (char )'\000';
      }
    }
#line 427
    lineno___0 ++;
#line 429
    if ((int )*nl != 0) {
#line 429
      if ((size_t )(nl - str) == len) {
#line 431
        if (! ((unsigned long )lndup___0 == (unsigned long )((void *)0))) {
          {
#line 431
          myassert((char *)"lndup == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
                   (char *)((void *)0), 431);
          }
        }
        {
#line 432
        tmp___2 = malloc((size_t )((nl - str) + 1L));
#line 432
        lndup___0 = (char *)tmp___2;
        }
#line 433
        if ((unsigned long )lndup___0 == (unsigned long )((void *)0)) {
          {
#line 435
          tmp___3 = __errno_location();
#line 435
          tmp___4 = strerror(*tmp___3);
#line 435
          error((char *)"malloc() failed: %s", tmp___4);
          }
#line 436
          return (-1);
        }
        {
#line 438
        memcpy((void */* __restrict  */)lndup___0, (void const   */* __restrict  */)ln___0,
               (size_t )(nl - str));
#line 439
        *(lndup___0 + (nl - str)) = (char )'\000';
#line 440
        ln___0 = lndup___0;
        }
      }
    }
    {
#line 443
    debug(3, (char *)"Data line: [%s]", ln___0);
#line 445
    condno = 0;
    }
    {
#line 446
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 446
      if (! ((list + condno)->code != -1)) {
#line 446
        goto while_break___1;
      }
#line 450
      if (type == 1) {
        {
#line 454
        r = regexec((regex_t const   */* __restrict  */)(& (list + condno)->val.re),
                    (char const   */* __restrict  */)ln___0, (size_t )1024, (regmatch_t */* __restrict  */)(pmatch),
                    0);
        }
#line 455
        if (r != 0) {
#line 455
          if (r != 1) {
            {
#line 460
            tmp___5 = regerror(r, (regex_t const   */* __restrict  */)(& (list + condno)->val.re),
                               (char */* __restrict  */)(buf), (size_t )1024);
            }
#line 460
            if (tmp___5 != 0UL) {
              {
#line 461
              error((char *)"Fatal error during output analysis: regexec() failed: %s",
                    buf);
              }
            } else {
              {
#line 463
              error((char *)"Fatal error during output analysis: regexec() failed with code %d",
                    r);
              }
            }
            {
#line 464
            error((char *)"Regular expression used was: %s", (list + condno)->expression);
#line 466
            error((char *)"Trying to match the following line of data: %s", buf);
            }
#line 467
            if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
              {
#line 468
              free((void *)lndup___0);
              }
            } else {
#line 470
              *nl = (char )'\n';
            }
#line 471
            return (-1);
          } else {
#line 455
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 475
        if (r == 0) {
          {
#line 478
          debug(3, (char *)"Matched: #%d %d[%c] (REG_NOMATCH=%d)", condno + 1, r,
                (list + condno)->code, 1);
#line 480
          tmp___6 = byteset_get((list + condno)->code);
#line 480
          byteset_set((list + condno)->code, 1 + tmp___6);
#line 483
          r = 1;
          }
          {
#line 484
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 484
            if (! (r < 1024)) {
#line 484
              goto while_break___2;
            }
#line 486
            if (pmatch[r].rm_so == -1) {
#line 487
              goto while_break___2;
            }
            {
#line 488
            set_mark(marks, & mark, & max, (size_t )((ln___0 - str) + (long )pmatch[r].rm_so),
                     16);
#line 490
            set_mark(marks, & mark, & max, (size_t )((ln___0 - str) + (long )pmatch[r].rm_eo),
                     16);
#line 492
            r ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 494
          goto while_break___1;
        } else {
          {
#line 497
          debug(4, (char *)"Failed: #%d %d[%c] (REG_NOMATCH=%d)", condno + 1, r, (list + condno)->code,
                1);
          }
        }
      } else {
        {
#line 555
        myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
                (char *)((void *)0), 555);
        }
      }
#line 557
      condno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 559
    if ((list + condno)->code == -1) {
      {
#line 560
      debug(3, (char *)"No match!");
      }
    }
#line 562
    if ((unsigned long )lndup___0 == (unsigned long )((void *)0)) {
#line 563
      *nl = (char )'\n';
    }
#line 565
    nl ++;
#line 565
    ln___0 = nl;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
    {
#line 569
    free((void *)lndup___0);
    }
  }
#line 571
  return (lineno___0);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
int analyzer_run(char *ostr , size_t olen , char *estr , size_t elen ) 
{ 
  int o ;
  int e ;

  {
  {
#line 583
  o = analyze_file(ostr, olen, outtype, out, & outmarks);
  }
#line 584
  if ((unsigned long )estr != (unsigned long )((void *)0)) {
    {
#line 585
    e = analyze_file(estr, elen, errtype, err, & errmarks);
    }
  } else {
#line 587
    e = 0;
  }
  {
#line 589
  variable_set((char *)"lines", (long )(o + e));
#line 590
  variable_set((char *)"outlines", (long )o);
#line 591
  variable_set((char *)"errlines", (long )e);
  }
#line 593
  if (o < 0) {
#line 594
    return (-1);
  } else
#line 593
  if (e < 0) {
#line 594
    return (-1);
  }
#line 595
  return (0);
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
static int output_file(FILE *mail , char *name , int format , size_t limit , char *str ,
                       size_t len , struct marker *marks ) 
{ 
  size_t ptr ;
  char toggle ;
  char trunc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tag ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  char *esc ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  struct marker *hole ;
  u_long lines ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;

  {
#line 609
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 611
    if (format == 2) {
      {
#line 612
      tmp = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"<Center>----- <Underline>Command standard %s follows</Underline> -----</Center>",
                    name);
#line 612
      toggle = (char )tmp;
      }
    } else
#line 613
    if (format == 3) {
      {
#line 614
      tmp___0 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"<p align=center>----- <em>Command standard %s follows</em> -----</p>",
                        name);
#line 614
      toggle = (char )tmp___0;
      }
    } else {
#line 616
      toggle = (char)1;
    }
#line 617
    if ((int )toggle <= 0) {
      {
#line 619
      tmp___1 = __errno_location();
#line 619
      tmp___2 = strerror(*tmp___1);
#line 619
      error((char *)"fprintf() failed: %s", tmp___2);
      }
#line 620
      return (-1);
    }
  }
#line 624
  if (format == 2) {
    {
#line 624
    tmp___5 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"<Nofill>");
    }
#line 624
    if (tmp___5 != 8) {
      {
#line 626
      tmp___3 = __errno_location();
#line 626
      tmp___4 = strerror(*tmp___3);
#line 626
      error((char *)"fprintf() failed: %s", tmp___4);
      }
#line 627
      return (-1);
    }
  }
#line 629
  if (format == 3) {
    {
#line 629
    tmp___8 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"<pre>");
    }
#line 629
    if (tmp___8 != 5) {
      {
#line 631
      tmp___6 = __errno_location();
#line 631
      tmp___7 = strerror(*tmp___6);
#line 631
      error((char *)"fprintf() failed: %s", tmp___7);
      }
#line 632
      return (-1);
    }
  }
#line 634
  ptr = (size_t )0;
#line 635
  toggle = (char)0;
#line 635
  trunc = (char)0;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! ((int )marks->type != 0)) {
#line 636
      goto while_break;
    }
#line 638
    if (marks->offset - ptr > 0UL) {
      {
#line 640
      tmp___11 = fwrite((void const   */* __restrict  */)(str + ptr), marks->offset - ptr,
                        (size_t )1, (FILE */* __restrict  */)mail);
      }
#line 640
      if (tmp___11 != 1UL) {
        {
#line 642
        tmp___9 = __errno_location();
#line 642
        tmp___10 = strerror(*tmp___9);
#line 642
        error((char *)"fwrite() failed: %s", tmp___10);
        }
#line 643
        return (-1);
      }
#line 645
      ptr = marks->offset;
    }
#line 648
    if (format != 1) {
#line 648
      if (((int )marks->type & 16) == 16) {
#line 652
        if ((int )toggle == 0) {
#line 653
          if (format == 2) {
#line 653
            tag = (char *)"<Bold>";
          } else {
#line 653
            tag = (char *)"<b>";
          }
        } else
#line 655
        if (format == 2) {
#line 655
          tag = (char *)"</Bold>";
        } else {
#line 655
          tag = (char *)"</b>";
        }
        {
#line 657
        tmp___14 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"%s",
                           tag);
#line 657
        tmp___15 = strlen((char const   *)tag);
        }
#line 657
        if ((size_t )tmp___14 != tmp___15) {
          {
#line 659
          tmp___12 = __errno_location();
#line 659
          tmp___13 = strerror(*tmp___12);
#line 659
          error((char *)"fprintf() failed: %s", tmp___13);
          }
#line 660
          return (-1);
        }
#line 662
        toggle = (char )(1 - (int )toggle);
      }
    }
#line 665
    if (format == 3) {
#line 665
      if (((int )marks->type & 7) != 0) {
#line 669
        if (((int )marks->type & 1) == 1) {
#line 670
          esc = (char *)"&lt;";
        } else
#line 671
        if (((int )marks->type & 2) == 2) {
#line 672
          esc = (char *)"&gt;";
        } else
#line 673
        if (((int )marks->type & 4) == 4) {
#line 674
          esc = (char *)"&amp;";
        } else {
          {
#line 676
          myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c",
                  (char *)((void *)0), 676);
          }
        }
        {
#line 678
        tmp___18 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"%s",
                           esc);
#line 678
        tmp___19 = strlen((char const   *)esc);
        }
#line 678
        if ((size_t )tmp___18 != tmp___19) {
          {
#line 680
          tmp___16 = __errno_location();
#line 680
          tmp___17 = strerror(*tmp___16);
#line 680
          error((char *)"fprintf() failed: %s", tmp___17);
          }
#line 681
          return (-1);
        }
#line 685
        ptr ++;
      }
    }
#line 688
    if (format == 2) {
#line 688
      if (((int )marks->type & 1) == 1) {
        {
#line 688
        tmp___22 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"<");
        }
#line 688
        if (tmp___22 != 1) {
          {
#line 691
          tmp___20 = __errno_location();
#line 691
          tmp___21 = strerror(*tmp___20);
#line 691
          error((char *)"fprintf() failed: %s", tmp___21);
          }
#line 692
          return (-1);
        }
      }
    }
#line 695
    if ((int )trunc == 0) {
#line 695
      if (((int )marks->type & 64) == 64) {
#line 697
        if (len > limit) {
#line 697
          if (marks->offset > limit / 2UL) {
#line 702
            lines = (u_long )0;
#line 703
            hole = marks;
            {
#line 704
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 704
              if (! (((int )marks->type & 64) != 64)) {
#line 704
                if (! ((hole->offset + len) - marks->offset > limit)) {
#line 704
                  goto while_break___0;
                }
              }
#line 707
              if (((int )marks->type & 64) == 64) {
#line 708
                lines ++;
              }
#line 709
              marks ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 712
            if (format == 1) {
              {
#line 712
              tmp___25 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"\n[... %lu lines (%ld bytes) of output truncated ...]\n",
                                 lines, marks->offset - hole->offset);
              }
#line 712
              if (tmp___25 <= 0) {
                {
#line 715
                tmp___23 = __errno_location();
#line 715
                tmp___24 = strerror(*tmp___23);
#line 715
                error((char *)"fprintf() failed: %s", tmp___24);
                }
#line 716
                return (-1);
              }
            }
#line 718
            if (format == 2) {
              {
#line 718
              tmp___28 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"</Nofill><Center>----- <Underline>%lu lines (%ld bytes) of output truncated</Underline> -----</Center><Nofill>",
                                 lines, marks->offset - hole->offset);
              }
#line 718
              if (tmp___28 <= 0) {
                {
#line 721
                tmp___26 = __errno_location();
#line 721
                tmp___27 = strerror(*tmp___26);
#line 721
                error((char *)"fprintf() failed: %s", tmp___27);
                }
#line 722
                return (-1);
              }
            }
#line 724
            if (format == 3) {
              {
#line 724
              tmp___31 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"</pre><p align=center>----- <em>%lu lines (%ld bytes) of output truncated</em> -----</p><pre>",
                                 lines, marks->offset - hole->offset);
              }
#line 724
              if (tmp___31 <= 0) {
                {
#line 727
                tmp___29 = __errno_location();
#line 727
                tmp___30 = strerror(*tmp___29);
#line 727
                error((char *)"fprintf() failed: %s", tmp___30);
                }
#line 728
                return (-1);
              }
            }
#line 731
            ptr = marks->offset + 1UL;
#line 732
            trunc = (char)1;
          }
        }
      }
    }
#line 736
    marks ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  if (ptr < len) {
    {
#line 739
    tmp___34 = fwrite((void const   */* __restrict  */)(str + ptr), len - ptr, (size_t )1,
                      (FILE */* __restrict  */)mail);
    }
#line 739
    if (tmp___34 != 1UL) {
      {
#line 741
      tmp___32 = __errno_location();
#line 741
      tmp___33 = strerror(*tmp___32);
#line 741
      error((char *)"fwrite() failed: %s", tmp___33);
      }
#line 742
      return (-1);
    }
  }
#line 744
  if ((int )*(str + (len - 1UL)) != 10) {
    {
#line 744
    tmp___37 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"\n");
    }
#line 744
    if (tmp___37 != 1) {
      {
#line 746
      tmp___35 = __errno_location();
#line 746
      tmp___36 = strerror(*tmp___35);
#line 746
      error((char *)"fprintf() failed: %s", tmp___36);
      }
#line 747
      return (-1);
    }
  }
#line 750
  if (format == 2) {
    {
#line 750
    tmp___40 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"</Nofill>");
    }
#line 750
    if (tmp___40 != 9) {
      {
#line 752
      tmp___38 = __errno_location();
#line 752
      tmp___39 = strerror(*tmp___38);
#line 752
      error((char *)"fprintf() failed: %s", tmp___39);
      }
#line 753
      return (-1);
    }
  }
#line 755
  if (format == 3) {
    {
#line 755
    tmp___43 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"</pre>");
    }
#line 755
    if (tmp___43 != 6) {
      {
#line 757
      tmp___41 = __errno_location();
#line 757
      tmp___42 = strerror(*tmp___41);
#line 757
      error((char *)"fprintf() failed: %s", tmp___42);
      }
#line 758
      return (-1);
    }
  }
#line 761
  return (0);
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/analyzer.c"
int analyzer_output(FILE *mail , int format , int output , size_t limit , char *ostr ,
                    size_t olen , char *estr , size_t elen ) 
{ 
  size_t olimit ;
  size_t elimit ;
  int o ;
  int e ;
  int over ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 775
  over = 0;
#line 776
  if (limit <= 0UL) {
#line 777
    elimit = olen + elen;
#line 777
    olimit = elimit;
  } else
#line 778
  if (output == 4) {
#line 780
    elimit = limit;
#line 780
    olimit = elimit;
#line 781
    if (olen > limit) {
#line 782
      over = 1;
    }
  } else
#line 784
  if (output == 5) {
#line 786
    elimit = limit;
#line 786
    olimit = elimit;
#line 787
    if (elen > limit) {
#line 788
      over = 1;
    }
  } else {
#line 792
    if (output == 1) {
#line 793
      olimit = limit;
    } else {
#line 796
      elimit = limit / 2UL;
#line 796
      olimit = elimit;
#line 797
      if (olen < olimit) {
#line 798
        elimit = limit - olen;
      }
#line 799
      if (elen < elimit) {
#line 800
        olimit = limit - elen;
      }
    }
#line 802
    if (olen + elen > limit) {
#line 803
      over = 1;
    }
  }
#line 806
  if (over == 1) {
#line 808
    if (format == 1) {
      {
#line 808
      tmp___1 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"WARNING: The following output is truncated!\n         (Total of %ld bytes is over the limit of %ld)\n\n",
                        olen + elen, limit);
      }
#line 808
      if (tmp___1 <= 0) {
        {
#line 811
        tmp = __errno_location();
#line 811
        tmp___0 = strerror(*tmp);
#line 811
        error((char *)"fprintf() failed: %s", tmp___0);
        }
#line 812
        return (-1);
      }
    }
#line 814
    if (format == 2) {
      {
#line 814
      tmp___4 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"<Nofill><Bold>WARNING</Bold>: The following output is truncated!\n         (Total of %ld bytes is over the limit of %ld)</Nofill>\n\n",
                        olen + elen, limit);
      }
#line 814
      if (tmp___4 <= 0) {
        {
#line 817
        tmp___2 = __errno_location();
#line 817
        tmp___3 = strerror(*tmp___2);
#line 817
        error((char *)"fprintf() failed: %s", tmp___3);
        }
#line 818
        return (-1);
      }
    }
#line 820
    if (format == 3) {
      {
#line 820
      tmp___7 = fprintf((FILE */* __restrict  */)mail, (char const   */* __restrict  */)"<p><b>WARNING</b>: The following output is truncated! (Total of %ld bytes is over the limit of %ld)</p>",
                        olen + elen, limit);
      }
#line 820
      if (tmp___7 <= 0) {
        {
#line 823
        tmp___5 = __errno_location();
#line 823
        tmp___6 = strerror(*tmp___5);
#line 823
        error((char *)"fprintf() failed: %s", tmp___6);
        }
#line 824
        return (-1);
      }
    }
  }
#line 828
  e = 0;
#line 828
  o = e;
#line 829
  if (output == 5) {
#line 831
    if (elen > 0UL) {
      {
#line 832
      e = output_file(mail, (char *)"error ", format, elimit, estr, elen, errmarks);
      }
    }
  } else
#line 835
  if (output == 4) {
#line 837
    if (olen > 0UL) {
      {
#line 838
      o = output_file(mail, (char *)"output ", format, olimit, ostr, olen, outmarks);
      }
    }
  } else {
#line 843
    if (elen > 0UL) {
#line 843
      if (output == 2) {
#line 844
        if (olen > 0UL) {
#line 844
          tmp___8 = "error ";
        } else {
#line 844
          tmp___8 = (char const   *)((void *)0);
        }
        {
#line 844
        e = output_file(mail, (char *)tmp___8, format, elimit, estr, elen, errmarks);
        }
      }
    }
#line 846
    if (olen > 0UL) {
#line 847
      if (output != 1) {
#line 847
        if (elen > 0UL) {
#line 847
          tmp___9 = "output";
        } else {
#line 847
          tmp___9 = (char const   *)((void *)0);
        }
      } else {
#line 847
        tmp___9 = (char const   *)((void *)0);
      }
      {
#line 847
      o = output_file(mail, (char *)tmp___9, format, olimit, ostr, olen, outmarks);
      }
    }
#line 851
    if (elen > 0UL) {
#line 851
      if (output == 3) {
#line 852
        if (olen > 0UL) {
#line 852
          tmp___10 = "error ";
        } else {
#line 852
          tmp___10 = (char const   *)((void *)0);
        }
        {
#line 852
        e = output_file(mail, (char *)tmp___10, format, elimit, estr, elen, errmarks);
        }
      }
    }
  }
#line 856
  if (o != 0) {
#line 857
    return (-1);
  } else
#line 856
  if (e != 0) {
#line 857
    return (-1);
  }
#line 858
  return (0);
}
}
#line 195 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.h"
char *cf_nextid(char *id___1 ) ;
#line 63
void cf_unload(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static int getnext(char *cfdname , char **schedule , char **job___0 , char **id___1 ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static DIR *cfdir  =    (DIR *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static char *calendar  =    (char *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static char *last  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static char *lastid  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static int lineno  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static size_t clen  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static char cfname[4096]  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static char *ln  =    (char *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static char *lndup  =    (char *)((void *)0);
#line 32 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
static int getnext(char *cfdname , char **schedule , char **job___0 , char **id___1 ) 
{ 
  struct dirent *entry ;
  struct stat sb___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *token ;
  char *jid___0 ;
  char *nl ;
  char *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  struct stat sb___1 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 42
  if ((unsigned long )calendar == (unsigned long )((void *)0)) {
#line 42
    if ((unsigned long )cfdir == (unsigned long )((void *)0)) {
      {
#line 46
      tmp___1 = stat((char const   */* __restrict  */)cfdname, (struct stat */* __restrict  */)(& sb___0));
      }
#line 46
      if (tmp___1 != 0) {
        {
#line 48
        tmp = __errno_location();
#line 48
        tmp___0 = strerror(*tmp);
#line 48
        error((char *)"stat(%s) failed: %s", cfdname, tmp___0);
#line 49
        exit(1);
        }
      }
#line 52
      if ((sb___0.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
        {
#line 54
        error((char *)"%s must not be group or world writable!", cfdname);
#line 55
        exit(1);
        }
      }
      {
#line 58
      tmp___2 = geteuid();
      }
#line 58
      if (sb___0.st_uid != tmp___2) {
        {
#line 60
        error((char *)"someone else owns %s!", cfdname);
#line 61
        exit(1);
        }
      }
      {
#line 64
      snprintf((char */* __restrict  */)(cfname), (size_t )4096, (char const   */* __restrict  */)"%s/schedule",
               cfdname);
#line 65
      tmp___3 = mapfile(cfname, -1, (void **)(& calendar), & clen);
      }
      {
#line 68
      if (tmp___3 == 1) {
#line 68
        goto case_1;
      }
#line 68
      if (tmp___3 == 0) {
#line 68
        goto case_1;
      }
#line 70
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 69
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 71
      exit(1);
      }
      switch_break: /* CIL Label */ ;
      }
#line 73
      lineno = 0;
#line 75
      if ((unsigned long )calendar == (unsigned long )((void *)0)) {
        {
#line 77
        cfdir = opendir((char const   *)cfdname);
        }
#line 78
        if ((unsigned long )cfdir == (unsigned long )((void *)0)) {
          {
#line 80
          tmp___4 = __errno_location();
#line 80
          tmp___5 = strerror(*tmp___4);
#line 80
          error((char *)"opendir(%s) failed: %s", cfdname, tmp___5);
#line 81
          exit(1);
          }
        }
      } else {
        {
#line 85
        printf((char const   */* __restrict  */)"%s: Using schedule found in %s.\n",
               myname, cfdname);
        }
      }
#line 87
      last = (char *)((void *)0);
#line 88
      lastid = (char *)((void *)0);
    }
  }
#line 91
  if ((unsigned long )last != (unsigned long )((void *)0)) {
    {
#line 93
    *schedule = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)";",
                         (char **/* __restrict  */)(& last));
    }
#line 94
    if ((unsigned long )*schedule != (unsigned long )((void *)0)) {
#line 95
      return (0);
    }
  }
#line 98
  if ((unsigned long )lastid != (unsigned long )((void *)0)) {
    {
#line 98
    lastid = cf_nextid(lastid);
    }
#line 98
    if ((unsigned long )lastid != (unsigned long )((void *)0)) {
      {
#line 100
      *id___1 = strdup((char const   *)lastid);
      }
#line 101
      if ((unsigned long )*id___1 == (unsigned long )((void *)0)) {
        {
#line 103
        tmp___6 = __errno_location();
#line 103
        tmp___7 = strerror(*tmp___6);
#line 103
        error((char *)"strdup(%s) failed: %s", lastid, tmp___7);
#line 104
        exit(1);
        }
      }
      {
#line 106
      cf_unload();
#line 107
      lastid = cf_load(cfname, *id___1);
#line 108
      free((void *)*id___1);
#line 109
      *id___1 = lastid;
#line 110
      *schedule = cf_getstr(20);
      }
    } else {
#line 98
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 112
  if ((unsigned long )calendar != (unsigned long )((void *)0)) {
#line 117
    if ((unsigned long )ln == (unsigned long )((void *)0)) {
#line 118
      ln = calendar;
    } else
#line 119
    if ((size_t )(ln - calendar) >= clen) {
#line 121
      if ((unsigned long )lndup != (unsigned long )((void *)0)) {
        {
#line 122
        free((void *)lndup);
        }
      }
      {
#line 123
      tmp___9 = unmapfile(cfdname, (void *)calendar, clen);
      }
#line 123
      if (tmp___9 != 0) {
        {
#line 124
        exit(1);
        }
      }
#line 125
      return (-1);
    }
#line 128
    nl = ln;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if ((size_t )(nl - calendar) < clen) {
#line 129
        if ((int )*nl != 10) {
#line 129
          if (! ((int )*nl != 0)) {
#line 129
            goto while_break;
          }
        } else {
#line 129
          goto while_break;
        }
      } else {
#line 129
        goto while_break;
      }
#line 130
      nl ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 131
    if ((size_t )(nl - calendar) == clen) {
#line 133
      if ((int )*(nl - 1) != 0) {
#line 135
        if (! ((unsigned long )lndup == (unsigned long )((void *)0))) {
          {
#line 135
          myassert((char *)"lndup == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c",
                   (char *)((void *)0), 135);
          }
        }
        {
#line 136
        tmp___10 = malloc((clen - (size_t )(ln - calendar)) + 1UL);
#line 136
        lndup = (char *)tmp___10;
        }
#line 137
        if ((unsigned long )lndup == (unsigned long )((void *)0)) {
          {
#line 139
          tmp___11 = __errno_location();
#line 139
          tmp___12 = strerror(*tmp___11);
#line 139
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: malloc() failed: %s",
                  myname, tmp___12);
#line 140
          exit(1);
          }
        }
        {
#line 142
        memcpy((void */* __restrict  */)lndup, (void const   */* __restrict  */)ln,
               clen - (size_t )(ln - calendar));
#line 143
        *(lndup + (clen - (size_t )(ln - calendar))) = (char )'\000';
#line 144
        ln = lndup;
        }
      }
    } else {
#line 148
      *nl = (char )'\000';
    }
#line 150
    lineno ++;
#line 152
    if ((int )*(ln + 0) == 35) {
      {
#line 154
      ln = nl + 1;
#line 155
      tmp___13 = getnext(cfdname, schedule, job___0, id___1);
      }
#line 155
      return (tmp___13);
    } else
#line 152
    if ((int )*(ln + 0) == 0) {
      {
#line 154
      ln = nl + 1;
#line 155
      tmp___13 = getnext(cfdname, schedule, job___0, id___1);
      }
#line 155
      return (tmp___13);
    }
    {
#line 158
    token = strtok_r((char */* __restrict  */)ln, (char const   */* __restrict  */)" \t",
                     (char **/* __restrict  */)(& tmp___8));
#line 159
    ln = nl + 1;
#line 160
    tmp___15 = strcmp((char const   *)token, "*");
    }
#line 160
    if (tmp___15 != 0) {
      {
#line 160
      tmp___16 = get_hostname(0);
#line 160
      tmp___17 = strcasecmp((char const   *)token, (char const   *)tmp___16);
      }
#line 160
      if (tmp___17 != 0) {
        {
#line 161
        tmp___14 = getnext(cfdname, schedule, job___0, id___1);
        }
#line 161
        return (tmp___14);
      }
    }
    {
#line 162
    token = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t",
                     (char **/* __restrict  */)(& tmp___8));
    }
#line 163
    if ((unsigned long )token == (unsigned long )((void *)0)) {
      {
#line 165
      error((char *)"Invalid syntax on line %d in schedule file", lineno);
#line 166
      exit(1);
      }
    }
    {
#line 168
    jid___0 = strchr((char const   *)token, ':');
    }
#line 169
    if ((unsigned long )jid___0 == (unsigned long )((void *)0)) {
#line 170
      jid___0 = (char *)"";
    } else {
#line 172
      tmp___18 = jid___0;
#line 172
      jid___0 ++;
#line 172
      *tmp___18 = (char )'\000';
    }
    {
#line 174
    snprintf((char */* __restrict  */)(cfname), (size_t )4096, (char const   */* __restrict  */)"%s/%s",
             cfdname, token);
#line 176
    cf_unload();
#line 177
    cf_load(cfname, jid___0);
#line 179
    *job___0 = token;
#line 180
    *id___1 = jid___0;
#line 181
    *schedule = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"",
                         (char **/* __restrict  */)(& tmp___8));
    }
#line 182
    if ((unsigned long )*schedule == (unsigned long )((void *)0)) {
      {
#line 184
      error((char *)"Invalid syntax on line %d in schedule file", lineno);
#line 185
      exit(1);
      }
    }
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      if (! ((int )*(*schedule) == 32)) {
#line 187
        if (! ((int )*(*schedule) == 9)) {
#line 187
          goto while_break___0;
        }
      }
#line 188
      (*schedule) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 190
  if ((unsigned long )cfdir != (unsigned long )((void *)0)) {
    {
#line 194
    entry = readdir(cfdir);
    }
#line 195
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
      {
#line 197
      tmp___21 = closedir(cfdir);
      }
#line 197
      if (tmp___21 != 0) {
        {
#line 198
        tmp___19 = __errno_location();
#line 198
        tmp___20 = strerror(*tmp___19);
#line 198
        error((char *)"closedir(%s) failed: %s", cfdname, tmp___20);
        }
      }
#line 199
      return (-1);
    }
    {
#line 202
    snprintf((char */* __restrict  */)(cfname), (size_t )4096, (char const   */* __restrict  */)"%s/%s",
             cfdname, entry->d_name);
#line 203
    tmp___24 = stat((char const   */* __restrict  */)(cfname), (struct stat */* __restrict  */)(& sb___1));
    }
#line 203
    if (tmp___24 != 0) {
      {
#line 205
      tmp___22 = __errno_location();
#line 205
      tmp___23 = strerror(*tmp___22);
#line 205
      error((char *)"stat(%s) failed: %s", cfname, tmp___23);
#line 206
      exit(1);
      }
    }
#line 209
    if (! ((sb___1.st_mode & 61440U) == 32768U)) {
      {
#line 211
      tmp___25 = getnext(cfdname, schedule, job___0, id___1);
      }
#line 211
      return (tmp___25);
    }
#line 213
    if ((int )entry->d_name[0] == 46) {
      {
#line 216
      tmp___26 = getnext(cfdname, schedule, job___0, id___1);
      }
#line 216
      return (tmp___26);
    } else
#line 213
    if ((int )entry->d_name[0] == 35) {
      {
#line 216
      tmp___26 = getnext(cfdname, schedule, job___0, id___1);
      }
#line 216
      return (tmp___26);
    } else {
      {
#line 213
      tmp___27 = strlen((char const   *)(entry->d_name));
      }
#line 213
      if ((int )entry->d_name[tmp___27 - 1UL] == 126) {
        {
#line 216
        tmp___26 = getnext(cfdname, schedule, job___0, id___1);
        }
#line 216
        return (tmp___26);
      }
    }
    {
#line 218
    tmp___29 = strlen((char const   *)(entry->d_name));
    }
#line 218
    if (tmp___29 > 7UL) {
      {
#line 218
      tmp___30 = strlen((char const   *)(entry->d_name));
#line 218
      tmp___31 = strcmp((char const   *)((entry->d_name + tmp___30) - 7), ".stdout");
      }
#line 218
      if (tmp___31 == 0) {
        {
#line 224
        tmp___28 = getnext(cfdname, schedule, job___0, id___1);
        }
#line 224
        return (tmp___28);
      } else {
        {
#line 218
        tmp___32 = strlen((char const   *)(entry->d_name));
#line 218
        tmp___33 = strcmp((char const   *)((entry->d_name + tmp___32) - 7), ".stderr");
        }
#line 218
        if (tmp___33 == 0) {
          {
#line 224
          tmp___28 = getnext(cfdname, schedule, job___0, id___1);
          }
#line 224
          return (tmp___28);
        }
      }
    }
    {
#line 226
    cf_unload();
#line 227
    lastid = cf_load(cfname, (char *)((void *)0));
#line 229
    *job___0 = entry->d_name;
#line 230
    *id___1 = lastid;
#line 231
    *schedule = cf_getstr(20);
    }
  } else {
    {
#line 234
    myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c",
            (char *)((void *)0), 234);
    }
  }
#line 236
  if ((unsigned long )*schedule == (unsigned long )((void *)0)) {
    {
#line 237
    tmp___34 = getnext(cfdname, schedule, job___0, id___1);
    }
#line 237
    return (tmp___34);
  } else
#line 236
  if ((int )*(*schedule) == 35) {
    {
#line 237
    tmp___34 = getnext(cfdname, schedule, job___0, id___1);
    }
#line 237
    return (tmp___34);
  } else
#line 236
  if ((int )*(*schedule) == 0) {
    {
#line 237
    tmp___34 = getnext(cfdname, schedule, job___0, id___1);
    }
#line 237
    return (tmp___34);
  }
  {
#line 239
  *schedule = strtok_r((char */* __restrict  */)*schedule, (char const   */* __restrict  */)";",
                       (char **/* __restrict  */)(& last));
  }
#line 240
  return (0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c"
void crontab(char *mypath , char *cfdir___0 , int action ) 
{ 
  char tag[4176] ;
  char *oldtab ;
  char *mytab ;
  char newtab[4096] ;
  char *schedule ;
  char *job___0 ;
  char *jid___0 ;
  char *argv[3] ;
  size_t oldlen ;
  size_t len ;
  int status ;
  int newfd ;
  FILE *old ;
  FILE *new ;
  pid_t child ;
  struct stat sb___0 ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  __pid_t tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  ssize_t tmp___16 ;
  union __anonunion_55___0 __constr_expr_7 ;
  union __anonunion_57___0 __constr_expr_9 ;
  union __anonunion_58___0 __constr_expr_10 ;
  int tmp___17 ;
  union __anonunion_59___0 __constr_expr_11 ;
  char *tmp___18 ;
  union __anonunion_60___0 __constr_expr_12 ;
  union __anonunion_61 __constr_expr_13 ;
  union __anonunion_62 __constr_expr_14 ;
  union __anonunion_63 __constr_expr_15 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  int r ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *slfac ;
  int tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  __pid_t tmp___50 ;
  int tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  union __anonunion_64 __constr_expr_16 ;
  union __anonunion_65 __constr_expr_17 ;
  union __anonunion_66 __constr_expr_18 ;
  union __anonunion_67 __constr_expr_19 ;
  union __anonunion_68 __constr_expr_20 ;
  union __anonunion_69 __constr_expr_21 ;
  union __anonunion_70 __constr_expr_22 ;

  {
#line 256
  if ((int )*(cfdir___0 + 0) == 0) {
    {
#line 257
    strcpy((char */* __restrict  */)(tag), (char const   */* __restrict  */)"# DO NOT MODIFY THIS LINE -- shush depends on it!");
    }
  } else {
    {
#line 259
    sprintf((char */* __restrict  */)(tag), (char const   */* __restrict  */)"%s [%s]",
            "# DO NOT MODIFY THIS LINE -- shush depends on it!", cfdir___0 + 1);
    }
  }
  {
#line 260
  strcat((char */* __restrict  */)(tag), (char const   */* __restrict  */)"\n");
#line 263
  old = tmpfile();
  }
#line 264
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    {
#line 266
    tmp = __errno_location();
#line 266
    tmp___0 = strerror(*tmp);
#line 266
    error((char *)"Failed to create temporary file: %s", tmp___0);
#line 267
    exit(1);
    }
  }
  {
#line 269
  tmp___4 = getenv("TMPDIR");
  }
#line 269
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 269
    tmp___2 = getenv("TMPDIR");
#line 269
    tmp___3 = (char const   *)tmp___2;
    }
  } else {
#line 269
    tmp___3 = "/tmp/";
  }
  {
#line 269
  snprintf((char */* __restrict  */)(newtab), (size_t )4096, (char const   */* __restrict  */)"%s/%s-crontab.XXXXXX",
           tmp___3, myname);
#line 272
  newfd = mkstemp(newtab);
  }
#line 273
  if (newfd < 0) {
    {
#line 275
    tmp___5 = __errno_location();
#line 275
    tmp___6 = strerror(*tmp___5);
#line 275
    error((char *)"Failed to create temporary file: %s", tmp___6);
#line 276
    exit(1);
    }
  }
  {
#line 278
  new = fdopen(newfd, "w");
  }
#line 279
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 281
    tmp___7 = __errno_location();
#line 281
    tmp___8 = strerror(*tmp___7);
#line 281
    error((char *)"Failed to create temporary file: %s", tmp___8);
#line 282
    exit(1);
    }
  }
  {
#line 286
  argv[0] = (char *)"/usr/bin/crontab";
#line 287
  argv[1] = (char *)"-l";
#line 288
  argv[2] = (char *)((void *)0);
#line 289
  tmp___9 = fileno(old);
#line 289
  child = exec(-1, tmp___9, 2, 0, argv);
  }
#line 290
  if (child < 0) {
    {
#line 291
    exit(1);
    }
  }
  {
#line 293
  tmp___12 = waitpid(child, & status, 0);
  }
#line 293
  if (tmp___12 == -1) {
    {
#line 295
    tmp___10 = __errno_location();
#line 295
    tmp___11 = strerror(*tmp___10);
#line 295
    error((char *)"waitpid(%d) failed: %s", child, tmp___11);
#line 296
    exit(1);
    }
  }
  {
#line 300
  tmp___15 = fileno(old);
#line 300
  tmp___16 = write(tmp___15, (void const   *)"\000", (size_t )1);
  }
#line 300
  if (tmp___16 != 1L) {
    {
#line 301
    tmp___13 = __errno_location();
#line 301
    tmp___14 = strerror(*tmp___13);
#line 301
    error((char *)"write() failed: %s", tmp___14);
#line 302
    exit(1);
    }
  }
#line 309
  if (action != 1) {
#line 311
    __constr_expr_14.__in = status;
#line 311
    if ((__constr_expr_14.__i & 127) == 0) {
#line 311
      __constr_expr_15.__in = status;
#line 311
      if ((__constr_expr_15.__i & 65280) >> 8 != 0) {
        {
#line 313
        __constr_expr_7.__in = status;
#line 313
        error((char *)"\"crontab -l\" failed with error code %d)", (__constr_expr_7.__i & 65280) >> 8);
#line 315
        exit(1);
        }
      } else {
#line 311
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 317
      __constr_expr_12.__in = status;
#line 317
      if ((int )((signed char )((__constr_expr_12.__i & 127) + 1)) >> 1 > 0) {
#line 317
        goto _L;
      } else {
#line 317
        __constr_expr_13.__in = status;
#line 317
        if ((__constr_expr_13.__i & 255) == 127) {
          _L: /* CIL Label */ 
#line 319
          __constr_expr_11.__in = status;
#line 319
          if ((int )((signed char )((__constr_expr_11.__i & 127) + 1)) >> 1 > 0) {
#line 319
            __constr_expr_9.__in = status;
#line 319
            tmp___17 = __constr_expr_9.__i & 127;
          } else {
#line 319
            __constr_expr_10.__in = status;
#line 319
            tmp___17 = (__constr_expr_10.__i & 65280) >> 8;
          }
          {
#line 319
          tmp___18 = strsignal(tmp___17);
#line 319
          error((char *)"\"crontab -l\" terminated or stopped abnormally (%s)", tmp___18);
#line 322
          exit(1);
          }
        }
      }
    }
  }
  {
#line 326
  tmp___19 = fileno(old);
#line 326
  tmp___20 = mapfile((char *)"tmpfile", tmp___19, (void **)(& oldtab), & oldlen);
  }
#line 326
  if (tmp___20 != 0) {
    {
#line 327
    exit(1);
    }
  }
#line 330
  if (oldlen > 1UL) {
    {
#line 331
    mytab = strstr((char const   *)oldtab, (char const   *)(tag));
    }
  } else {
#line 333
    mytab = (char *)((void *)0);
  }
#line 336
  if (action == 1) {
#line 336
    goto _L___1;
  } else
#line 336
  if (action == 2) {
    _L___1: /* CIL Label */ 
    {
#line 338
    tmp___21 = getnext(cfdir___0 + 1, & schedule, & job___0, & jid___0);
    }
#line 338
    if (tmp___21 != 0) {
#line 340
      if ((unsigned long )mytab == (unsigned long )((void *)0)) {
        {
#line 342
        printf((char const   */* __restrict  */)"%s: Nothing to do.\n", myname);
#line 343
        exit(0);
        }
      } else {
#line 347
        if (! (action == 2)) {
          {
#line 347
          myassert((char *)"action == CRONTAB_UPDATE", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c",
                   (char *)((void *)0), 347);
          }
        }
#line 348
        action = 3;
      }
    }
#line 352
    if (action == 1) {
#line 352
      if (oldlen > 1UL) {
        {
#line 354
        error((char *)"ERROR: You already have a crontab!");
#line 355
        exit(1);
        }
      }
    }
  } else
#line 358
  if (action == 3) {
#line 360
    if ((unsigned long )mytab == (unsigned long )((void *)0)) {
      {
#line 362
      printf((char const   */* __restrict  */)"%s: Nothing to do.\n", myname);
#line 363
      exit(0);
      }
    }
  } else {
    {
#line 367
    myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/crontab.c",
            (char *)((void *)0), 367);
    }
  }
#line 370
  if ((unsigned long )mytab != (unsigned long )((void *)0)) {
#line 371
    len = (size_t )(mytab - oldtab);
  } else {
#line 373
    len = oldlen - 1UL;
  }
  {
#line 375
  tmp___24 = fwrite((void const   */* __restrict  */)((void *)oldtab), sizeof(char ),
                    len, (FILE */* __restrict  */)new);
  }
#line 375
  if (tmp___24 != len) {
    {
#line 377
    tmp___22 = __errno_location();
#line 377
    tmp___23 = strerror(*tmp___22);
#line 377
    error((char *)"fwrite(%s) failed: %s", newtab, tmp___23);
#line 378
    exit(1);
    }
  }
#line 381
  if (action == 2) {
#line 381
    goto _L___2;
  } else
#line 381
  if (action == 1) {
    _L___2: /* CIL Label */ 
    {
#line 385
    tmp___27 = fprintf((FILE */* __restrict  */)new, (char const   */* __restrict  */)"%s",
                       tag);
    }
#line 385
    if (tmp___27 < 0) {
      {
#line 387
      tmp___25 = __errno_location();
#line 387
      tmp___26 = strerror(*tmp___25);
#line 387
      error((char *)"fprintf(%s) failed: %s", newtab, tmp___26);
#line 388
      exit(1);
      }
    }
    {
#line 390
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 394
      r = fprintf((FILE */* __restrict  */)new, (char const   */* __restrict  */)"%s %s ",
                  schedule, mypath);
      }
#line 395
      if (r > 0) {
#line 395
        if ((int )*(cfdir___0 + 0) != 0) {
          {
#line 396
          r = fprintf((FILE */* __restrict  */)new, (char const   */* __restrict  */)"-c \"%s\" ",
                      cfdir___0 + 1);
          }
        }
      }
      {
#line 397
      slfac = cf_getstr(24);
      }
#line 398
      if ((unsigned long )slfac != (unsigned long )((void *)0)) {
#line 400
        if (r > 0) {
          {
#line 400
          tmp___28 = strcasecmp((char const   *)slfac, "cron");
          }
#line 400
          if (tmp___28 != 0) {
#line 402
            if ((int )*(slfac + 0) != 0) {
              {
#line 403
              r = fprintf((FILE */* __restrict  */)new, (char const   */* __restrict  */)"-s %s ",
                          slfac);
              }
            } else {
              {
#line 405
              r = fprintf((FILE */* __restrict  */)new, (char const   */* __restrict  */)"-S ");
              }
            }
          }
        }
      }
#line 408
      if (r > 0) {
        {
#line 409
        r = fprintf((FILE */* __restrict  */)new, (char const   */* __restrict  */)"\"%s\" %s\n",
                    job___0, jid___0);
        }
      }
#line 390
      if (r > 0) {
        {
#line 390
        tmp___29 = getnext(cfdir___0 + 1, & schedule, & job___0, & jid___0);
        }
#line 390
        if (! (tmp___29 == 0)) {
#line 390
          goto while_break;
        }
      } else {
#line 390
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 412
    if (r > 0) {
      {
#line 413
      r = fprintf((FILE */* __restrict  */)new, (char const   */* __restrict  */)"%s",
                  tag);
      }
    }
#line 414
    if (r <= 0) {
      {
#line 416
      tmp___30 = __errno_location();
#line 416
      tmp___31 = strerror(*tmp___30);
#line 416
      error((char *)"fprintf(%s) failed: %s", newtab, tmp___31);
#line 417
      exit(1);
      }
    }
  }
#line 422
  if ((unsigned long )mytab != (unsigned long )((void *)0)) {
    {
#line 424
    mytab = strstr((char const   *)(mytab + 1), (char const   *)(tag));
    }
#line 425
    if ((unsigned long )mytab == (unsigned long )((void *)0)) {
      {
#line 427
      error((char *)"Current crontab seems to be corrupted.");
#line 428
      tmp___34 = unlink((char const   *)(newtab));
      }
#line 428
      if (tmp___34 != 0) {
        {
#line 429
        tmp___32 = __errno_location();
#line 429
        tmp___33 = strerror(*tmp___32);
#line 429
        error((char *)"Failed to remove temporary file \"%s\": %s", newtab, tmp___33);
        }
      }
      {
#line 431
      exit(1);
      }
    }
    {
#line 433
    tmp___35 = strlen((char const   *)(tag));
#line 433
    mytab += tmp___35;
    }
#line 434
    if ((int )*mytab != 0) {
      {
#line 434
      tmp___38 = strlen((char const   *)mytab);
#line 434
      tmp___39 = fwrite((void const   */* __restrict  */)((void *)mytab), sizeof(char ),
                        tmp___38, (FILE */* __restrict  */)new);
#line 434
      tmp___40 = strlen((char const   *)mytab);
      }
#line 434
      if (tmp___39 != tmp___40) {
        {
#line 438
        tmp___36 = __errno_location();
#line 438
        tmp___37 = strerror(*tmp___36);
#line 438
        error((char *)"fwrite(%s) failed: %s", newtab, tmp___37);
#line 439
        exit(1);
        }
      }
    }
  }
  {
#line 442
  tmp___43 = fflush(new);
  }
#line 442
  if (tmp___43 != 0) {
    {
#line 444
    tmp___41 = __errno_location();
#line 444
    tmp___42 = strerror(*tmp___41);
#line 444
    error((char *)"fflush(%s) failed: %s", newtab, tmp___42);
#line 445
    exit(1);
    }
  }
  {
#line 448
  tmp___46 = fstat(newfd, & sb___0);
  }
#line 448
  if (tmp___46 != 0) {
    {
#line 450
    tmp___44 = __errno_location();
#line 450
    tmp___45 = strerror(*tmp___44);
#line 450
    error((char *)"fstat(%s) failed: %s", newtab, tmp___45);
#line 451
    exit(1);
    }
  }
#line 455
  if (sb___0.st_size > 0L) {
#line 456
    argv[1] = newtab;
  } else {
#line 458
    argv[1] = (char *)"-r";
  }
  {
#line 459
  tmp___47 = fileno(new);
#line 459
  child = exec(tmp___47, 1, 2, 0, argv);
  }
#line 460
  if (child < 0) {
    {
#line 461
    exit(1);
    }
  }
  {
#line 463
  tmp___50 = waitpid(child, & status, 0);
  }
#line 463
  if (tmp___50 == -1) {
    {
#line 465
    tmp___48 = __errno_location();
#line 465
    tmp___49 = strerror(*tmp___48);
#line 465
    error((char *)"waitpid(%d) failed: %s", child, tmp___49);
#line 466
    exit(1);
    }
  }
#line 469
  __constr_expr_16.__in = status;
#line 469
  if ((__constr_expr_16.__i & 127) == 0) {
#line 469
    __constr_expr_17.__in = status;
#line 469
    if ((__constr_expr_17.__i & 65280) >> 8 == 0) {
#line 471
      if (sb___0.st_size > 0L) {
        {
#line 472
        printf((char const   */* __restrict  */)"%s: crontab updated.\n", myname);
        }
      } else {
        {
#line 474
        printf((char const   */* __restrict  */)"%s: crontab removed.\n", myname);
        }
      }
      {
#line 475
      tmp___51 = unlink((char const   *)(newtab));
      }
#line 475
      if (tmp___51 == 0) {
        {
#line 476
        exit(0);
        }
      }
      {
#line 477
      tmp___52 = __errno_location();
#line 477
      tmp___53 = strerror(*tmp___52);
#line 477
      error((char *)"Failed to remove temporary file \"%s\": %s", newtab, tmp___53);
#line 478
      exit(1);
      }
    }
  }
#line 481
  if (sb___0.st_size > 0L) {
    {
#line 482
    error((char *)"Something went wrong while trying to save new crontab!");
    }
  } else {
    {
#line 484
    error((char *)"Something went wrong while trying to remove crontab!");
    }
  }
#line 486
  __constr_expr_21.__in = status;
#line 486
  if ((__constr_expr_21.__i & 127) == 0) {
#line 486
    __constr_expr_22.__in = status;
#line 486
    if ((__constr_expr_22.__i & 65280) >> 8 != 0) {
      {
#line 487
      __constr_expr_18.__in = status;
#line 487
      error((char *)"\"crontab %s\" returned %d?!", argv[1], (__constr_expr_18.__i & 65280) >> 8);
      }
    } else {
#line 486
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 488
    __constr_expr_19.__in = status;
#line 488
    if ((int )((signed char )((__constr_expr_19.__i & 127) + 1)) >> 1 > 0) {
      {
#line 489
      error((char *)"\"crontab %s\" terminated or stopped abnormally.", argv[1]);
      }
    } else {
#line 488
      __constr_expr_20.__in = status;
#line 488
      if ((__constr_expr_20.__i & 255) == 127) {
        {
#line 489
        error((char *)"\"crontab %s\" terminated or stopped abnormally.", argv[1]);
        }
      }
    }
  }
  {
#line 491
  exit(1);
  }
}
}
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.h"
time_t cf_timestamp  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.h"
size_t cf_size  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.h"
char cf_md5[33]  ;
#line 65
long cf_getnum(int code ) ;
#line 66
int cf_getrptcnt(void) ;
#line 67
char *cf_getrptstr(int report , int code ) ;
#line 68
char *cf_getrptstrlist(int report , int code ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/ifparser.h"
void ifparser_init(char *str ) ;
#line 15
int ifparser_parse(void) ;
#line 18
char const   *ifparser_errmsg ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/siglist.h"
int getsignumbyname(char *name ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.h"
u_int unit_time(char *timestr___2 ) ;
#line 15
u_int unit_size(char *sizestr ) ;
#line 16
int syslog_facility(char *name ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2format(char *str ) ;
#line 44
static void *str2lock(char *str ) ;
#line 45
static void *str2size(char *str ) ;
#line 46
static void *str2stderr(char *str ) ;
#line 47
static void *str2sysfac(char *str ) ;
#line 48
static void *str2time(char *str ) ;
#line 49
static void *str2timeout(char *str ) ;
#line 50
static void *str2header(char *str ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static struct cfelmt globalconfig[15]  = 
#line 62
  {      {14, (char *)"config", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {13, (char *)"command", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {15,
      (char *)"lock", (char)1, & str2lock, (void *)0}, 
        {16, (char *)"lockfile", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {17,
      (char *)"lockmsg", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {18, (char *)"path", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {19, (char *)"randomdelay", (char)0, & str2time, (void *)0}, 
        {20, (char *)"schedule", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {21,
      (char *)"sendmail", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {22, (char *)"shell", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {23, (char *)"statedir", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {24,
      (char *)"syslog", (char)1, & str2sysfac, (void *)0}, 
        {25, (char *)"timeout", (char)1, & str2timeout, (void *)0}, 
        {26, (char *)"timeoutmsg", (char)1, (void *(*)(char * ))((void *)0), (void *)0}, 
        {0,
      (char *)((void *)0), (char)1, (void *(*)(char * ))((void *)0), (void *)0}};
#line 91 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static struct rptdef  const  reportconfig[13]  = 
#line 91
  {      {(char *)"name", (char)1, (void *(*)(char * ))((void *)0)}, 
        {(char *)"to", (char)1, (void *(*)(char * ))((void *)0)}, 
        {(char *)"cc", (char)1, (void *(*)(char * ))((void *)0)}, 
        {(char *)"bcc", (char)1, (void *(*)(char * ))((void *)0)}, 
        {(char *)"subject", (char)1, (void *(*)(char * ))((void *)0)}, 
        {(char *)"userprefix", (char)0, (void *(*)(char * ))((void *)0)}, 
        {(char *)"hostprefix", (char)0, (void *(*)(char * ))((void *)0)}, 
        {(char *)"sizelimit", (char)0, & str2size}, 
        {(char *)"if", (char)1, (void *(*)(char * ))((void *)0)}, 
        {(char *)"format", (char)0, & str2format}, 
        {(char *)"stderr", (char)0, & str2stderr}, 
        {(char *)"header", (char)2, & str2header}, 
        {(char *)((void *)0), (char)1, (void *(*)(char * ))((void *)0)}};
#line 109 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static any *reports  =    (any *)((void *)0);
#line 110 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static int reportssz  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static char **idlist  =    (char **)((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static int idlistsz  ;
#line 121 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static long value  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2format(char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 123
  value = 1L;
#line 124
  tmp___1 = strcasecmp((char const   *)str, "text");
  }
#line 124
  if (tmp___1 == 0) {
#line 125
    value = 1L;
  } else {
    {
#line 126
    tmp___0 = strcasecmp((char const   *)str, "rich");
    }
#line 126
    if (tmp___0 == 0) {
#line 127
      value = 2L;
    } else {
      {
#line 128
      tmp = strcasecmp((char const   *)str, "html");
      }
#line 128
      if (tmp == 0) {
#line 129
        value = 3L;
      } else {
        {
#line 131
        error((char *)"Invalid \"format\" setting: %s", str);
        }
      }
    }
  }
#line 132
  return ((void *)(& value));
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2lock(char *str ) 
{ 
  char *str2 ;
  char *tmp ;
  char *last___0 ;
  int endless ;
  int silent ;
  int loop ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 145
  str2 = strdup((char const   *)str);
  }
#line 146
  if ((unsigned long )str2 == (unsigned long )((void *)0)) {
    {
#line 148
    tmp___0 = __errno_location();
#line 148
    tmp___1 = strerror(*tmp___0);
#line 148
    error((char *)"strdup(%s) failed: %s", str, tmp___1);
#line 149
    exit(1);
    }
  }
  {
#line 152
  endless = 1;
#line 152
  silent = 1;
#line 152
  loop = 0;
#line 153
  tmp = strtok_r((char */* __restrict  */)str2, (char const   */* __restrict  */)",",
                 (char **/* __restrict  */)(& last___0));
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 154
      goto while_break;
    }
    {
#line 156
    tmp___6 = __ctype_b_loc();
    }
#line 156
    if ((int const   )*(*tmp___6 + (int )*(tmp + 0)) & 2048) {
#line 158
      if (loop == 1) {
#line 159
        loop = 2;
      }
      {
#line 160
      unit_time(tmp);
      }
    } else {
      {
#line 162
      tmp___5 = strcasecmp((char const   *)tmp, "abort");
      }
#line 162
      if (tmp___5 == 0) {
#line 163
        endless = 0;
      } else {
        {
#line 164
        tmp___4 = strcasecmp((char const   *)tmp, "ignore");
        }
#line 164
        if (tmp___4 == 0) {
#line 165
          endless = 0;
        } else {
          {
#line 166
          tmp___3 = strncmp((char const   *)tmp, "notify=", (size_t )7);
          }
#line 166
          if (tmp___3 == 0) {
#line 167
            silent = 0;
          } else {
            {
#line 168
            tmp___2 = strcmp((char const   *)tmp, "loop");
            }
#line 168
            if (tmp___2 == 0) {
#line 170
              if (loop > 0) {
                {
#line 171
                error((char *)"Only one `loop\' supported in locking strategy!");
                }
              }
#line 172
              silent = 1;
#line 173
              loop = 1;
            } else {
              {
#line 176
              error((char *)"Invalid \"lock\" action: %s", tmp);
              }
            }
          }
        }
      }
    }
    {
#line 177
    tmp = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                   (char **/* __restrict  */)(& last___0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  free((void *)str2);
  }
#line 181
  if (endless == 1) {
#line 181
    if (silent == 1) {
      {
#line 182
      error((char *)"Defined locking strategy (\"%s\") may result in a silent endless wait!",
            str);
      }
    }
  }
#line 183
  if (loop == 1) {
    {
#line 185
    error((char *)"Defined locking strategy (\"%s\") contains an invalid loop!", str);
#line 187
    exit(1);
    }
  }
#line 190
  return ((void *)str);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static long value___0  ;
#line 197 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2size(char *str ) 
{ 
  u_int tmp ;

  {
  {
#line 202
  tmp = unit_size(str);
#line 202
  value___0 = (long )tmp;
  }
#line 203
  return ((void *)(& value___0));
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static long value___1  ;
#line 210 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2stderr(char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 215
  value___1 = 2L;
#line 216
  tmp___5 = strcasecmp((char const   *)str, "errfirst");
  }
#line 216
  if (tmp___5 == 0) {
#line 219
    value___1 = 2L;
  } else {
    {
#line 216
    tmp___6 = strcasecmp((char const   *)str, "first");
    }
#line 216
    if (tmp___6 == 0) {
#line 219
      value___1 = 2L;
    } else {
      {
#line 216
      tmp___7 = strcasecmp((char const   *)str, "outlast");
      }
#line 216
      if (tmp___7 == 0) {
#line 219
        value___1 = 2L;
      } else {
        {
#line 220
        tmp___2 = strcasecmp((char const   *)str, "errlast");
        }
#line 220
        if (tmp___2 == 0) {
#line 223
          value___1 = 3L;
        } else {
          {
#line 220
          tmp___3 = strcasecmp((char const   *)str, "last");
          }
#line 220
          if (tmp___3 == 0) {
#line 223
            value___1 = 3L;
          } else {
            {
#line 220
            tmp___4 = strcasecmp((char const   *)str, "outfirst");
            }
#line 220
            if (tmp___4 == 0) {
#line 223
              value___1 = 3L;
            } else {
              {
#line 224
              tmp___1 = strcasecmp((char const   *)str, "mixed");
              }
#line 224
              if (tmp___1 == 0) {
#line 225
                value___1 = 1L;
              } else {
                {
#line 226
                tmp___0 = strcasecmp((char const   *)str, "outonly");
                }
#line 226
                if (tmp___0 == 0) {
#line 227
                  value___1 = 4L;
                } else {
                  {
#line 228
                  tmp = strcasecmp((char const   *)str, "erronly");
                  }
#line 228
                  if (tmp == 0) {
#line 229
                    value___1 = 5L;
                  } else {
                    {
#line 231
                    error((char *)"Invalid \"stderr\" setting: %s", str);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 232
  return ((void *)(& value___1));
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2sysfac(char *str ) 
{ 


  {
#line 242
  if ((int )*(str + 0) != 0) {
    {
#line 243
    syslog_facility(str);
    }
  }
#line 244
  return ((void *)str);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static long value___2  ;
#line 251 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2time(char *str ) 
{ 
  u_int tmp ;

  {
  {
#line 256
  tmp = unit_time(str);
#line 256
  value___2 = (long )tmp;
  }
#line 257
  return ((void *)(& value___2));
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2timeout(char *str ) 
{ 
  char *str2 ;
  char *tmp ;
  char *last___0 ;
  int useful ;
  int loop ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;

  {
  {
#line 270
  str2 = strdup((char const   *)str);
  }
#line 271
  if ((unsigned long )str2 == (unsigned long )((void *)0)) {
    {
#line 273
    tmp___0 = __errno_location();
#line 273
    tmp___1 = strerror(*tmp___0);
#line 273
    error((char *)"strdup(%s) failed: %s", str, tmp___1);
#line 274
    exit(1);
    }
  }
  {
#line 277
  tmp = strtok_r((char */* __restrict  */)str2, (char const   */* __restrict  */)",",
                 (char **/* __restrict  */)(& last___0));
#line 278
  unit_time(tmp);
#line 279
  useful = 0;
#line 279
  loop = 0;
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 280
    tmp = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                   (char **/* __restrict  */)(& last___0));
    }
#line 280
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 280
      goto while_break;
    }
    {
#line 282
    tmp___10 = __ctype_b_loc();
    }
#line 282
    if ((int const   )*(*tmp___10 + (int )*(tmp + 0)) & 2048) {
#line 284
      if (loop == 1) {
#line 285
        loop = 2;
      }
      {
#line 286
      unit_time(tmp);
      }
    } else
#line 288
    if ((int )*(tmp + 0) == 45) {
      {
#line 288
      tmp___9 = __ctype_b_loc();
      }
#line 288
      if ((int const   )*(*tmp___9 + (int )*(tmp + 1)) & 2048) {
#line 289
        useful = 1;
      } else {
#line 288
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 290
      tmp___8 = strncmp((char const   *)tmp, "SIG", (size_t )3);
      }
#line 290
      if (tmp___8 == 0) {
        {
#line 292
        tmp___2 = getsignumbyname(tmp + 3);
        }
#line 292
        if (tmp___2 < 0) {
          {
#line 293
          error((char *)"Invalid \"timeout\" signal: %s", tmp);
          }
        }
#line 294
        useful = 1;
      } else
#line 296
      if ((int )*(tmp + 0) == 61) {
        {
#line 296
        tmp___7 = __ctype_b_loc();
        }
#line 296
        if ((int const   )*(*tmp___7 + (int )*(tmp + 1)) & 2048) {
#line 297
          useful = 1;
        } else {
#line 296
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 298
        tmp___6 = strncmp((char const   *)tmp, "=SIG", (size_t )4);
        }
#line 298
        if (tmp___6 == 0) {
          {
#line 300
          tmp___3 = getsignumbyname(tmp + 4);
          }
#line 300
          if (tmp___3 < 0) {
            {
#line 301
            error((char *)"Invalid \"timeout\" signal: %s", tmp);
            }
          }
#line 302
          useful = 1;
        } else {
          {
#line 304
          tmp___5 = strncmp((char const   *)tmp, "notify=", (size_t )7);
          }
#line 304
          if (tmp___5 == 0) {
#line 305
            useful = 1;
          } else {
            {
#line 306
            tmp___4 = strcmp((char const   *)tmp, "loop");
            }
#line 306
            if (tmp___4 == 0) {
#line 308
              if (loop > 0) {
                {
#line 309
                error((char *)"Only one `loop\' supported in \"timeout\" action!");
                }
              }
#line 310
              loop = 1;
            } else {
              {
#line 313
              error((char *)"Invalid \"timeout\" action: %s", tmp);
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  free((void *)str2);
  }
#line 317
  if (useful == 0) {
    {
#line 318
    error((char *)"Defined \"timeout\" action (\"%s\") has no effect.", str);
    }
  }
#line 319
  if (loop == 1) {
    {
#line 321
    error((char *)"Defined \"timeout\" action (\"%s\") contains an invalid loop!",
          str);
#line 323
    exit(1);
    }
  }
#line 326
  return ((void *)str);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void *str2header(char *str ) 
{ 
  char *tmp ;

  {
#line 338
  tmp = str;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! ((int )*tmp != 0)) {
#line 339
      goto while_break;
    }
#line 341
    if ((int )*tmp == 58) {
#line 342
      goto while_break;
    }
#line 343
    if ((int )*tmp < 33) {
#line 344
      goto while_break;
    } else
#line 343
    if ((int )*tmp > 126) {
#line 344
      goto while_break;
    }
#line 345
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  if ((int )*tmp != 58) {
    {
#line 348
    error((char *)"Defined \"header\" (\"%s\") is NOT RFC2822 compliant.", str);
    }
  }
#line 350
  return ((void *)str);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void myldup(long **var , long val ) 
{ 
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 360
  if ((unsigned long )*var != (unsigned long )((void *)0)) {
    {
#line 361
    free((void *)*var);
    }
  }
  {
#line 362
  tmp = malloc(sizeof(long ));
#line 362
  *var = (long *)tmp;
  }
#line 363
  if ((unsigned long )*var == (unsigned long )((void *)0)) {
    {
#line 365
    tmp___0 = __errno_location();
#line 365
    tmp___1 = strerror(*tmp___0);
#line 365
    error((char *)"malloc() failed: %s", tmp___1);
#line 366
    exit(1);
    }
  }
#line 368
  *(*var) = val;
#line 369
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static void mystrdup(char **var , char *str ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 378
  if ((unsigned long )*var != (unsigned long )((void *)0)) {
    {
#line 379
    free((void *)*var);
    }
  }
  {
#line 380
  *var = strdup((char const   *)str);
  }
#line 381
  if ((unsigned long )*var == (unsigned long )((void *)0)) {
    {
#line 383
    tmp = __errno_location();
#line 383
    tmp___0 = strerror(*tmp);
#line 383
    error((char *)"strdup(%s) failed: %s", str, tmp___0);
#line 384
    exit(1);
    }
  }
#line 386
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
char *cf_load(char *fname , char *instance ) 
{ 
  char *conf ;
  char *ln___0 ;
  char *lndup___0 ;
  char *nl ;
  int lncnt ;
  int idl ;
  int rpt ;
  int std ;
  size_t cflen ;
  int tmp ;
  struct stat *tmp___0 ;
  struct stat *tmp___1 ;
  struct stat *tmp___2 ;
  __uid_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  any tmp___10 ;
  any tmp___11 ;
  u_int tmp___12 ;
  void *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int i___0 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int i___1 ;
  char *val ;
  char *at ;
  char *pc ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  long tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  list **alist ;
  long tmp___38 ;
  void *tmp___39 ;
  void *tmp___40 ;
  void *tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  void *tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  size_t tmp___50 ;
  char const   *tmp___51 ;
  int tmp___52 ;

  {
#line 399
  if (! ((unsigned long )reports == (unsigned long )((void *)0))) {
    {
#line 399
    myassert((char *)"reports == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 399);
    }
  }
  {
#line 401
  cf_timestamp = (time_t )0;
#line 403
  tmp = mapfile(fname, -1, (void **)(& conf), & cflen);
  }
  {
#line 405
  if (tmp == 0) {
#line 405
    goto case_0;
  }
#line 415
  if (tmp == 1) {
#line 415
    goto case_1;
  }
#line 418
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 407
  tmp___0 = mapstat();
#line 407
  cf_timestamp = tmp___0->st_mtim.tv_sec;
#line 408
  tmp___2 = mapstat();
#line 408
  tmp___3 = geteuid();
  }
#line 408
  if (tmp___2->st_uid != tmp___3) {
    {
#line 409
    error((char *)"someone else owns %s!", fname);
    }
  } else {
    {
#line 410
    tmp___1 = mapstat();
    }
#line 410
    if ((tmp___1->st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
      {
#line 411
      error((char *)"%s must not be group or world writable!", fname);
      }
    } else {
#line 413
      goto switch_break;
    }
  }
  {
#line 414
  exit(1);
  }
  case_1: /* CIL Label */ 
  {
#line 416
  error((char *)"Configuration file \"%s\" does not exist.", fname);
  }
  switch_default: /* CIL Label */ 
  {
#line 419
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 423
  if (cflen == 0UL) {
    {
#line 425
    error((char *)"Configuration file (%s) is empty!", fname);
#line 426
    exit(1);
    }
  }
  {
#line 429
  cf_size = cflen;
#line 430
  cf_md5[0] = (char )'\000';
#line 433
  mystrdup((char **)(& globalconfig[0].value), fname);
#line 436
  idlistsz = 5;
#line 437
  tmp___4 = malloc((unsigned long )idlistsz * sizeof(char **));
#line 437
  idlist = (char **)tmp___4;
  }
#line 438
  if ((unsigned long )idlist == (unsigned long )((void *)0)) {
    {
#line 440
    tmp___5 = __errno_location();
#line 440
    tmp___6 = strerror(*tmp___5);
#line 440
    error((char *)"malloc() failed: %s", tmp___6);
#line 441
    exit(1);
    }
  }
  {
#line 443
  *(idlist + 0) = (char *)((void *)0);
#line 444
  idl = -1;
#line 447
  reportssz = 5;
#line 448
  tmp___7 = malloc((unsigned long )(reportssz * 12) * sizeof(any ));
#line 448
  reports = (any *)tmp___7;
  }
#line 449
  if ((unsigned long )reports == (unsigned long )((void *)0)) {
    {
#line 451
    tmp___8 = __errno_location();
#line 451
    tmp___9 = strerror(*tmp___8);
#line 451
    error((char *)"malloc() failed: %s", tmp___9);
#line 452
    exit(1);
    }
  }
  {
#line 454
  rpt = 0;
#line 455
  *(reports + 0) = (void *)0;
#line 456
  mystrdup((char **)(reports + 0), (char *)"<defaults>");
#line 457
  tmp___11 = (void *)0;
#line 457
  *(reports + 3) = tmp___11;
#line 457
  tmp___10 = tmp___11;
#line 457
  *(reports + 2) = tmp___10;
#line 457
  *(reports + 1) = tmp___10;
#line 458
  *(reports + 4) = (void *)0;
#line 459
  *(reports + 5) = (void *)0;
#line 459
  *(reports + 6) = (void *)0;
#line 460
  myldup((long **)(reports + 5), 1L);
#line 461
  myldup((long **)(reports + 6), 255L);
#line 462
  *(reports + 7) = (void *)0;
  }
#line 463
  if ((unsigned long )"1000k" == (unsigned long )((void *)0)) {
    {
#line 464
    myldup((long **)(reports + 7), -1L);
    }
  } else {
    {
#line 466
    tmp___12 = unit_size((char *)"1000k");
#line 466
    myldup((long **)(reports + 7), (long )tmp___12);
    }
  }
  {
#line 467
  *(reports + 8) = (void *)0;
#line 468
  *(reports + 9) = (void *)0;
#line 469
  myldup((long **)(reports + 9), 2L);
#line 470
  *(reports + 10) = (void *)0;
#line 471
  myldup((long **)(reports + 10), 2L);
#line 472
  *(reports + 11) = (void *)0;
#line 475
  ln___0 = conf;
#line 475
  lncnt = 1;
#line 476
  lndup___0 = (char *)((void *)0);
  }
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    nl = ln___0;
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if ((size_t )(nl - conf) < cflen) {
#line 480
        if ((int )*nl != 10) {
#line 480
          if (! ((int )*nl != 0)) {
#line 480
            goto while_break___0;
          }
        } else {
#line 480
          goto while_break___0;
        }
      } else {
#line 480
        goto while_break___0;
      }
#line 481
      nl ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 482
    if ((size_t )(nl - conf) == cflen) {
#line 484
      if ((int )*(nl - 1) != 0) {
#line 486
        if (! ((unsigned long )lndup___0 == (unsigned long )((void *)0))) {
          {
#line 486
          myassert((char *)"lndup == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
                   (char *)((void *)0), 486);
          }
        }
        {
#line 487
        tmp___13 = malloc((cflen - (size_t )(ln___0 - conf)) + 1UL);
#line 487
        lndup___0 = (char *)tmp___13;
        }
#line 488
        if ((unsigned long )lndup___0 == (unsigned long )((void *)0)) {
          {
#line 490
          tmp___14 = __errno_location();
#line 490
          tmp___15 = strerror(*tmp___14);
#line 490
          error((char *)"malloc() failed: %s", tmp___15);
#line 491
          exit(1);
          }
        }
        {
#line 493
        memcpy((void */* __restrict  */)lndup___0, (void const   */* __restrict  */)ln___0,
               cflen - (size_t )(ln___0 - conf));
#line 494
        *(lndup___0 + (cflen - (size_t )(ln___0 - conf))) = (char )'\000';
#line 495
        ln___0 = lndup___0;
        }
      }
    } else {
#line 499
      *nl = (char )'\000';
    }
#line 501
    if (! ((int )*ln___0 == 35)) {
#line 501
      if (! ((int )*ln___0 == 0)) {
#line 503
        if ((int )*ln___0 == 91) {
          {
#line 503
          tmp___50 = strlen((char const   *)ln___0);
          }
#line 503
          if ((int )*(ln___0 + (tmp___50 - 1UL)) == 93) {
            {
#line 508
            tmp___16 = strlen((char const   *)ln___0);
#line 508
            *(ln___0 + (tmp___16 - 1UL)) = (char )'\000';
#line 509
            ln___0 ++;
#line 510
            rpt += 12;
            }
#line 511
            if (rpt == reportssz * 12) {
              {
#line 514
              reportssz *= 2;
#line 515
              tmp___17 = realloc((void *)reports, (unsigned long )(reportssz * 12) * sizeof(any ));
#line 515
              reports = (any *)tmp___17;
              }
#line 517
              if ((unsigned long )reports == (unsigned long )((void *)0)) {
                {
#line 519
                tmp___18 = __errno_location();
#line 519
                tmp___19 = strerror(*tmp___18);
#line 519
                error((char *)"realloc() failed: %s", tmp___19);
#line 520
                exit(1);
                }
              }
            }
#line 523
            i___0 = rpt;
            {
#line 524
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 524
              if (! (i___0 < rpt + 12)) {
#line 524
                goto while_break___1;
              }
#line 525
              tmp___20 = i___0;
#line 525
              i___0 ++;
#line 525
              *(reports + tmp___20) = (void *)0;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 526
            mystrdup((char **)(reports + rpt), ln___0);
            }
          } else {
#line 503
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 534
          val = strchr((char const   *)ln___0, '=');
          }
#line 535
          if ((unsigned long )val == (unsigned long )((void *)0)) {
            {
#line 537
            error((char *)"Invalid option in %s, line %d: %s", fname, lncnt, ln___0);
#line 538
            exit(1);
            }
          }
          {
#line 540
          *val = (char )'\000';
#line 540
          val ++;
#line 542
          pc = strchr((char const   *)ln___0, '%');
          }
#line 543
          if ((unsigned long )pc != (unsigned long )((void *)0)) {
#line 544
            tmp___21 = pc;
#line 544
            pc ++;
#line 544
            *tmp___21 = (char )'\000';
          }
          {
#line 545
          at = strchr((char const   *)ln___0, '@');
          }
#line 546
          if ((unsigned long )at != (unsigned long )((void *)0)) {
            {
#line 548
            tmp___22 = at;
#line 548
            at ++;
#line 548
            *tmp___22 = (char )'\000';
#line 549
            tmp___23 = get_hostname(0);
#line 549
            tmp___24 = strcasecmp((char const   *)tmp___23, (char const   *)at);
            }
#line 549
            if (tmp___24 != 0) {
#line 551
              goto next;
            }
          }
#line 554
          if ((unsigned long )pc != (unsigned long )((void *)0)) {
#line 556
            i___1 = 0;
            {
#line 557
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 557
              if ((unsigned long )*(idlist + i___1) != (unsigned long )((void *)0)) {
                {
#line 557
                tmp___25 = strcasecmp((char const   *)pc, (char const   *)*(idlist + i___1));
                }
#line 557
                if (! (tmp___25 != 0)) {
#line 557
                  goto while_break___2;
                }
              } else {
#line 557
                goto while_break___2;
              }
#line 558
              i___1 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 559
            if ((unsigned long )*(idlist + i___1) == (unsigned long )((void *)0)) {
              {
#line 561
              *(idlist + i___1) = strdup((char const   *)pc);
              }
#line 562
              if ((unsigned long )*(idlist + i___1) == (unsigned long )((void *)0)) {
                {
#line 564
                tmp___26 = __errno_location();
#line 564
                tmp___27 = strerror(*tmp___26);
#line 564
                error((char *)"strdup(%s) failed: %s", pc, tmp___27);
#line 565
                exit(1);
                }
              }
#line 567
              if ((unsigned long )instance == (unsigned long )((void *)0)) {
#line 569
                idl = i___1;
              } else {
                {
#line 567
                tmp___28 = strcasecmp((char const   *)instance, (char const   *)*(idlist + i___1));
                }
#line 567
                if (tmp___28 == 0) {
#line 569
                  idl = i___1;
                }
              }
#line 570
              i___1 ++;
#line 571
              if (i___1 == idlistsz) {
                {
#line 574
                idlistsz *= 2;
#line 575
                tmp___29 = realloc((void *)idlist, (unsigned long )idlistsz * sizeof(char **));
#line 575
                idlist = (char **)tmp___29;
                }
#line 577
                if ((unsigned long )idlist == (unsigned long )((void *)0)) {
                  {
#line 579
                  tmp___30 = __errno_location();
#line 579
                  tmp___31 = strerror(*tmp___30);
#line 579
                  error((char *)"realloc() failed: %s", tmp___31);
#line 580
                  exit(1);
                  }
                }
              }
#line 583
              *(idlist + i___1) = (char *)((void *)0);
            }
#line 585
            if ((unsigned long )instance == (unsigned long )((void *)0)) {
#line 586
              instance = *(idlist + (i___1 - 1));
            }
#line 587
            if ((int )*instance == 0) {
              {
#line 589
              error((char *)"Configuration requires the use of an instance ID.");
#line 590
              exit(1);
              }
            }
            {
#line 593
            tmp___32 = strcasecmp((char const   *)instance, (char const   *)pc);
            }
#line 593
            if (tmp___32 != 0) {
#line 595
              goto next;
            }
          }
#line 598
          i___1 = 0;
#line 599
          if (rpt == 0) {
            {
#line 602
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 602
              if (! ((unsigned long )globalconfig[i___1].name != (unsigned long )((void *)0))) {
#line 602
                goto while_break___3;
              }
              {
#line 604
              tmp___36 = strcasecmp((char const   *)globalconfig[i___1].name, (char const   *)ln___0);
              }
#line 604
              if (tmp___36 == 0) {
                {
#line 608
                if ((int )globalconfig[i___1].type == 0) {
#line 608
                  goto case_0___0;
                }
#line 616
                if ((int )globalconfig[i___1].type == 1) {
#line 616
                  goto case_1___0;
                }
#line 624
                goto switch_default___0;
                case_0___0: /* CIL Label */ 
#line 609
                if ((unsigned long )globalconfig[i___1].valid == (unsigned long )((void *)0)) {
                  {
#line 610
                  tmp___33 = atol((char const   *)val);
#line 610
                  myldup((long **)(& globalconfig[i___1].value), tmp___33);
                  }
                } else {
                  {
#line 613
                  tmp___34 = (*(globalconfig[i___1].valid))(val);
#line 613
                  myldup((long **)(& globalconfig[i___1].value), *((long *)tmp___34));
                  }
                }
#line 615
                goto switch_break___0;
                case_1___0: /* CIL Label */ 
#line 617
                if ((unsigned long )globalconfig[i___1].valid == (unsigned long )((void *)0)) {
                  {
#line 618
                  mystrdup((char **)(& globalconfig[i___1].value), val);
                  }
                } else {
                  {
#line 621
                  tmp___35 = (*(globalconfig[i___1].valid))(val);
#line 621
                  mystrdup((char **)(& globalconfig[i___1].value), (char *)tmp___35);
                  }
                }
#line 623
                goto switch_break___0;
                switch_default___0: /* CIL Label */ 
                {
#line 625
                myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
                        (char *)((void *)0), 625);
                }
                switch_break___0: /* CIL Label */ ;
                }
#line 627
                val = (char *)((void *)0);
#line 628
                goto while_break___3;
              }
#line 630
              i___1 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 634
          i___1 = 0;
#line 635
          if ((unsigned long )val != (unsigned long )((void *)0)) {
            {
#line 638
            tmp___37 = strcasecmp("output", (char const   *)ln___0);
            }
#line 638
            if (tmp___37 == 0) {
#line 639
              ln___0 = (char *)"stderr";
            }
            {
#line 640
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 640
              if (! ((unsigned long )reportconfig[i___1].name != (unsigned long )((void *)0))) {
#line 640
                goto while_break___4;
              }
              {
#line 642
              tmp___49 = strcasecmp((char const   *)reportconfig[i___1].name, (char const   *)ln___0);
              }
#line 642
              if (tmp___49 == 0) {
                {
#line 648
                if ((int const   )reportconfig[i___1].type == 0) {
#line 648
                  goto case_0___1;
                }
#line 655
                if ((int const   )reportconfig[i___1].type == 1) {
#line 655
                  goto case_1___1;
                }
#line 662
                if ((int const   )reportconfig[i___1].type == 2) {
#line 662
                  goto case_2;
                }
#line 683
                goto switch_default___1;
                case_0___1: /* CIL Label */ 
#line 649
                if ((unsigned long )reportconfig[i___1].valid == (unsigned long )((void *)0)) {
                  {
#line 650
                  tmp___38 = atol((char const   *)val);
#line 650
                  myldup((long **)(reports + (rpt + i___1)), tmp___38);
                  }
                } else {
                  {
#line 652
                  tmp___39 = (*(reportconfig[i___1].valid))(val);
#line 652
                  myldup((long **)(reports + (rpt + i___1)), *((long *)tmp___39));
                  }
                }
#line 654
                goto switch_break___1;
                case_1___1: /* CIL Label */ 
#line 656
                if ((unsigned long )reportconfig[i___1].valid == (unsigned long )((void *)0)) {
                  {
#line 657
                  mystrdup((char **)(reports + (rpt + i___1)), val);
                  }
                } else {
                  {
#line 659
                  tmp___40 = (*(reportconfig[i___1].valid))(val);
#line 659
                  mystrdup((char **)(reports + (rpt + i___1)), (char *)tmp___40);
                  }
                }
#line 661
                goto switch_break___1;
                case_2: /* CIL Label */ 
#line 663
                alist = (list **)(reports + (rpt + i___1));
                {
#line 664
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 664
                  if (! ((unsigned long )*alist != (unsigned long )((void *)0))) {
#line 664
                    goto while_break___5;
                  }
#line 665
                  alist = & (*alist)->nextl;
                }
                while_break___5: /* CIL Label */ ;
                }
                {
#line 666
                tmp___41 = malloc(sizeof(list ));
#line 666
                *alist = (list *)tmp___41;
                }
#line 667
                if ((unsigned long )*alist == (unsigned long )((void *)0)) {
                  {
#line 669
                  tmp___42 = __errno_location();
#line 669
                  tmp___43 = strerror(*tmp___42);
#line 669
                  error((char *)"malloc() failed: %s", tmp___43);
#line 670
                  exit(1);
                  }
                }
#line 672
                (*alist)->nextl = (list *)((void *)0);
#line 673
                if ((unsigned long )reportconfig[i___1].valid == (unsigned long )((void *)0)) {
                  {
#line 674
                  tmp___44 = strdup((char const   *)val);
#line 674
                  (*alist)->value = (any )tmp___44;
                  }
                } else {
                  {
#line 676
                  tmp___45 = (*(reportconfig[i___1].valid))(val);
#line 676
                  tmp___46 = strdup((char const   *)((char *)tmp___45));
#line 676
                  (*alist)->value = (any )tmp___46;
                  }
                }
#line 677
                if ((unsigned long )(*alist)->value == (unsigned long )((void *)0)) {
                  {
#line 679
                  tmp___47 = __errno_location();
#line 679
                  tmp___48 = strerror(*tmp___47);
#line 679
                  error((char *)"strdup() failed: %s", tmp___48);
#line 680
                  exit(1);
                  }
                }
#line 682
                goto switch_break___1;
                switch_default___1: /* CIL Label */ 
                {
#line 684
                myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
                        (char *)((void *)0), 684);
                }
                switch_break___1: /* CIL Label */ ;
                }
#line 686
                val = (char *)((void *)0);
#line 687
                goto while_break___4;
              }
#line 689
              i___1 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 693
          if ((unsigned long )val != (unsigned long )((void *)0)) {
            {
#line 694
            error((char *)"Invalid option \"%s\" in %s, line %d", ln___0, fname, lncnt);
            }
          }
        }
      }
    }
    next: 
#line 698
    ln___0 = nl + 1;
#line 699
    lncnt ++;
#line 477
    if (! ((size_t )(ln___0 - conf) < cflen)) {
#line 477
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  if ((unsigned long )lndup___0 != (unsigned long )((void *)0)) {
    {
#line 703
    free((void *)lndup___0);
    }
  }
#line 704
  *(reports + (rpt + 12)) = (void *)0;
#line 706
  std = (int )*((long *)*(reports + 10));
#line 707
  if (std == 4) {
#line 707
    goto _L___0;
  } else
#line 707
  if (std == 5) {
    _L___0: /* CIL Label */ 
#line 709
    if (std == 4) {
#line 709
      tmp___51 = "outonly";
    } else {
#line 709
      tmp___51 = "erronly";
    }
    {
#line 709
    error((char *)"Invalid default output: \"%s\"!", tmp___51);
#line 711
    exit(1);
    }
  }
  {
#line 713
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 713
    if (! (rpt > 0)) {
#line 713
      goto while_break___6;
    }
#line 715
    if (! ((unsigned long )*(reports + rpt) != (unsigned long )((void *)0))) {
      {
#line 715
      myassert((char *)"reports[rpt+CF_RPTNAME] != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
               (char *)((void *)0), 715);
      }
    }
#line 716
    if ((unsigned long )*(reports + 1) == (unsigned long )((void *)0)) {
#line 716
      if ((unsigned long )*(reports + 2) == (unsigned long )((void *)0)) {
#line 716
        if ((unsigned long )*(reports + 3) == (unsigned long )((void *)0)) {
#line 716
          if ((unsigned long )*(reports + (rpt + 1)) == (unsigned long )((void *)0)) {
#line 716
            if ((unsigned long )*(reports + (rpt + 2)) == (unsigned long )((void *)0)) {
#line 716
              if ((unsigned long )*(reports + (rpt + 3)) == (unsigned long )((void *)0)) {
                {
#line 720
                error((char *)"No recipient specified for report \"%s\"!", (char *)*(reports + rpt));
#line 722
                exit(1);
                }
              }
            }
          }
        }
      }
    }
#line 728
    if ((unsigned long )*(reports + (rpt + 8)) != (unsigned long )((void *)0)) {
      {
#line 730
      ifparser_init((char *)*(reports + (rpt + 8)));
      }
#line 731
      if ((unsigned long )*(reports + (rpt + 8)) != (unsigned long )((void *)0)) {
        {
#line 731
        tmp___52 = ifparser_parse();
        }
#line 731
        if (tmp___52 != 0) {
          {
#line 733
          error((char *)"%s in if clause for report \"%s\"!", ifparser_errmsg, (char *)*(reports + rpt));
#line 735
          exit(1);
          }
        }
      }
    }
#line 738
    if (std == 1) {
#line 738
      if ((unsigned long )*(reports + (rpt + 10)) != (unsigned long )((void *)0)) {
#line 738
        if (*((long *)*(reports + (rpt + 10))) != (long )std) {
          {
#line 746
          error((char *)"Invalid output option for report \"%s\"!", (char *)*(reports + rpt));
#line 748
          exit(1);
          }
        } else {
#line 738
          goto _L___2;
        }
      } else {
#line 738
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 738
    if (std != 1) {
#line 738
      if ((unsigned long )*(reports + (rpt + 10)) != (unsigned long )((void *)0)) {
#line 738
        if (*((long *)*(reports + (rpt + 10))) == 1L) {
          {
#line 746
          error((char *)"Invalid output option for report \"%s\"!", (char *)*(reports + rpt));
#line 748
          exit(1);
          }
        }
      }
    }
#line 750
    rpt -= 12;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 753
  if ((unsigned long )*(idlist + 0) == (unsigned long )((void *)0)) {
#line 753
    if ((unsigned long )instance == (unsigned long )((void *)0)) {
#line 754
      return ((char *)"");
    }
  }
#line 755
  if ((unsigned long )instance != (unsigned long )((void *)0)) {
#line 755
    if ((int )*instance != 0) {
#line 755
      if (idl == -1) {
        {
#line 757
        error((char *)"Instance ID \"%s\" not found in configuration!", instance);
#line 758
        exit(1);
        }
      }
    }
  }
#line 760
  if (! ((unsigned long )instance != (unsigned long )((void *)0))) {
    {
#line 760
    myassert((char *)"instance != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 760);
    }
  }
#line 761
  return (instance);
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
char *cf_nextid(char *id___1 ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 771
  i___0 = 0;
#line 773
  if (! ((unsigned long )idlist != (unsigned long )((void *)0))) {
    {
#line 773
    myassert((char *)"idlist != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 773);
    }
  }
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if ((unsigned long )*(idlist + i___0) != (unsigned long )((void *)0)) {
      {
#line 775
      tmp = strcasecmp((char const   *)id___1, (char const   *)*(idlist + i___0));
      }
#line 775
      if (! (tmp != 0)) {
#line 775
        goto while_break;
      }
    } else {
#line 775
      goto while_break;
    }
#line 776
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  if ((unsigned long )*(idlist + i___0) == (unsigned long )((void *)0)) {
#line 779
    return ((char *)((void *)0));
  } else {
#line 781
    return (*(idlist + (i___0 + 1)));
  }
}
}
#line 788 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
void cf_unload(void) 
{ 
  int i___0 ;

  {
#line 793
  i___0 = 0;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! ((unsigned long )globalconfig[i___0].name != (unsigned long )((void *)0))) {
#line 793
      goto while_break;
    }
#line 795
    if ((unsigned long )globalconfig[i___0].value != (unsigned long )((void *)0)) {
      {
#line 797
      free(globalconfig[i___0].value);
#line 798
      globalconfig[i___0].value = (void *)0;
      }
    }
#line 793
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 801
  if ((unsigned long )reports != (unsigned long )((void *)0)) {
#line 803
    i___0 = 0;
    {
#line 803
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 803
      if (! ((unsigned long )*(reports + i___0) != (unsigned long )((void *)0))) {
#line 803
        if (! (i___0 % 12 != 0)) {
#line 803
          goto while_break___0;
        }
      }
#line 804
      if ((unsigned long )*(reports + i___0) != (unsigned long )((void *)0)) {
        {
#line 805
        free(*(reports + i___0));
        }
      }
#line 803
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 806
    free((void *)reports);
#line 807
    reports = (any *)((void *)0);
    }
  }
#line 809
  if ((unsigned long )idlist != (unsigned long )((void *)0)) {
#line 811
    i___0 = 0;
    {
#line 811
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 811
      if (! ((unsigned long )*(idlist + i___0) != (unsigned long )((void *)0))) {
#line 811
        goto while_break___1;
      }
      {
#line 812
      free((void *)*(idlist + i___0));
#line 811
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 813
    free((void *)idlist);
#line 814
    idlist = (char **)((void *)0);
    }
  }
#line 816
  return;
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
char *cf_getstr(int code ) 
{ 
  int i___0 ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 827
  if (code > 12) {
#line 827
    if (! (code < 27)) {
      {
#line 827
      myassert((char *)"code > CF_RPT_MAX && code < CF_MAX", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
               (char *)((void *)0), 827);
      }
    }
  } else {
    {
#line 827
    myassert((char *)"code > CF_RPT_MAX && code < CF_MAX", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 827);
    }
  }
#line 829
  i___0 = 0;
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (! ((unsigned long )globalconfig[i___0].name != (unsigned long )((void *)0))) {
#line 830
      goto while_break;
    }
#line 831
    if (globalconfig[i___0].code == code) {
#line 832
      goto while_break;
    } else {
#line 834
      i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 836
  if (! (i___0 < 27)) {
    {
#line 836
    myassert((char *)"i < CF_MAX", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 836);
    }
  }
#line 837
  if (! ((int )globalconfig[i___0].type == 1)) {
    {
#line 837
    myassert((char *)"globalconfig[i].type == CFS", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 837);
    }
  }
#line 840
  if (code == 17) {
#line 840
    if ((unsigned long )globalconfig[i___0].value == (unsigned long )((void *)0)) {
#line 841
      return ((char *)"[%u@%h] **PENDING** %N [%t]");
    }
  }
#line 842
  if (code == 21) {
    {
#line 844
    tmp___0 = getenv("SHUSH_SENDMAIL");
    }
#line 844
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
#line 845
      tmp = getenv("SHUSH_SENDMAIL");
      }
#line 845
      return (tmp);
    } else
#line 846
    if ((unsigned long )globalconfig[i___0].value == (unsigned long )((void *)0)) {
#line 847
      return ((char *)"/usr/lib/sendmail");
    }
  }
#line 849
  if (code == 22) {
#line 849
    if ((unsigned long )globalconfig[i___0].value == (unsigned long )((void *)0)) {
#line 850
      return ((char *)"/bin/sh");
    }
  }
#line 851
  if (code == 26) {
#line 851
    if ((unsigned long )globalconfig[i___0].value == (unsigned long )((void *)0)) {
#line 852
      return ((char *)"[%u@%h] **TIMEOUT** %N [%t]");
    }
  }
#line 854
  return ((char *)globalconfig[i___0].value);
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
long cf_getnum(int code ) 
{ 
  int i___0 ;

  {
#line 866
  if (code > 12) {
#line 866
    if (! (code < 27)) {
      {
#line 866
      myassert((char *)"code > CF_RPT_MAX && code < CF_MAX", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
               (char *)((void *)0), 866);
      }
    }
  } else {
    {
#line 866
    myassert((char *)"code > CF_RPT_MAX && code < CF_MAX", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 866);
    }
  }
#line 868
  i___0 = 0;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! ((unsigned long )globalconfig[i___0].name != (unsigned long )((void *)0))) {
#line 869
      goto while_break;
    }
#line 870
    if (globalconfig[i___0].code == code) {
#line 871
      goto while_break;
    } else {
#line 873
      i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  if (! (i___0 < 27)) {
    {
#line 875
    myassert((char *)"i < CF_MAX", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 875);
    }
  }
#line 876
  if (! ((int )globalconfig[i___0].type == 0)) {
    {
#line 876
    myassert((char *)"globalconfig[i].type == CFN", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 876);
    }
  }
#line 878
  if ((unsigned long )globalconfig[i___0].value != (unsigned long )((void *)0)) {
#line 879
    return (*((long *)globalconfig[i___0].value));
  } else {
#line 881
    return (-1L);
  }
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static int i  =    -1;
#line 888 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
int cf_getrptcnt(void) 
{ 


  {
#line 893
  if (i == -1) {
#line 895
    i = 0;
    {
#line 896
    while (1) {
      while_continue: /* CIL Label */ ;
#line 896
      if (! ((unsigned long )*(reports + i * 12) != (unsigned long )((void *)0))) {
#line 896
        goto while_break;
      }
#line 897
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 900
  if (! ((unsigned long )*(reports + i * 12) == (unsigned long )((void *)0))) {
    {
#line 900
    myassert((char *)"reports[i * CF_RPT_MAX] == NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 900);
    }
  }
#line 902
  return (i);
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
char *cf_getrptstr(int report , int code ) 
{ 
  int tmp ;

  {
  {
#line 912
  tmp = cf_getrptcnt();
  }
#line 912
  if (! (report < tmp)) {
    {
#line 912
    myassert((char *)"report < cf_getrptcnt()", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 912);
    }
  }
#line 913
  if (code < 12) {
#line 913
    if (! ((int const   )reportconfig[code].type == 1)) {
      {
#line 913
      myassert((char *)"code < CF_RPT_MAX && reportconfig[code].type == CFS", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
               (char *)((void *)0), 913);
      }
    }
  } else {
    {
#line 913
    myassert((char *)"code < CF_RPT_MAX && reportconfig[code].type == CFS", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 913);
    }
  }
#line 915
  if ((unsigned long )*(reports + (report * 12 + code)) != (unsigned long )((void *)0)) {
#line 916
    return ((char *)*(reports + (report * 12 + code)));
  } else {
#line 918
    return ((char *)*(reports + code));
  }
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
static int which  ;
#line 926 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
char *cf_getrptstrlist(int report , int code ) 
{ 
  int i___0 ;
  list *alist ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 933
  tmp = cf_getrptcnt();
  }
#line 933
  if (! (report < tmp)) {
    {
#line 933
    myassert((char *)"report < cf_getrptcnt()", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 933);
    }
  }
#line 934
  if (code < 12) {
#line 934
    if (! ((int const   )reportconfig[code].type == 2)) {
      {
#line 934
      myassert((char *)"code < CF_RPT_MAX && reportconfig[code].type == CFSL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
               (char *)((void *)0), 934);
      }
    }
  } else {
    {
#line 934
    myassert((char *)"code < CF_RPT_MAX && reportconfig[code].type == CFSL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 934);
    }
  }
#line 936
  if (report < 0) {
#line 938
    which = 0;
#line 939
    return ((char *)((void *)0));
  }
#line 942
  if ((unsigned long )*(reports + (report * 12 + code)) != (unsigned long )((void *)0)) {
#line 943
    alist = (list *)*(reports + (report * 12 + code));
  } else {
#line 945
    alist = (list *)*(reports + code);
  }
#line 947
  i___0 = 0;
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    tmp___0 = i___0;
#line 948
    i___0 ++;
#line 948
    if (tmp___0 < which) {
#line 948
      if (! ((unsigned long )alist != (unsigned long )((void *)0))) {
#line 948
        goto while_break;
      }
    } else {
#line 948
      goto while_break;
    }
#line 949
    alist = alist->nextl;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  which ++;
#line 951
  if ((unsigned long )alist != (unsigned long )((void *)0)) {
#line 952
    return ((char *)alist->value);
  }
#line 953
  return ((char *)((void *)0));
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c"
long cf_getrptnum(int report , int code ) 
{ 
  int tmp ;

  {
  {
#line 963
  tmp = cf_getrptcnt();
  }
#line 963
  if (! (report < tmp)) {
    {
#line 963
    myassert((char *)"report < cf_getrptcnt()", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 963);
    }
  }
#line 964
  if (code < 12) {
#line 964
    if (reportconfig) {
#line 964
      if (! ((int const   )reportconfig[code].type == 0)) {
        {
#line 964
        myassert((char *)"code < CF_RPT_MAX && reportconfig && reportconfig[code].type == CFN",
                 (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
                 (char *)((void *)0), 965);
        }
      }
    } else {
      {
#line 964
      myassert((char *)"code < CF_RPT_MAX && reportconfig && reportconfig[code].type == CFN",
               (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
               (char *)((void *)0), 965);
      }
    }
  } else {
    {
#line 964
    myassert((char *)"code < CF_RPT_MAX && reportconfig && reportconfig[code].type == CFN",
             (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/cf.c",
             (char *)((void *)0), 965);
    }
  }
#line 967
  if ((unsigned long )*(reports + (report * 12 + code)) != (unsigned long )((void *)0)) {
#line 968
    return (*((long *)*(reports + (report * 12 + code))));
  } else
#line 969
  if ((unsigned long )*(reports + code) != (unsigned long )((void *)0)) {
#line 970
    return (*((long *)*(reports + code)));
  } else {
#line 972
    return (-1L);
  }
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.h"
char *unit_rtime(u_int timeval ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.c"
u_int unit_time(char *timestr___2 ) 
{ 
  char *unit ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 23
  unit = timestr___2;
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if ((int )*unit != 0) {
      {
#line 24
      tmp = __ctype_b_loc();
      }
#line 24
      if (! (((int const   )*(*tmp + (int )*unit) & 2048) != 0)) {
#line 24
        goto while_break;
      }
    } else {
#line 24
      goto while_break;
    }
#line 25
    unit ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 29
  if ((int )*unit == 119) {
#line 29
    goto case_119;
  }
#line 29
  if ((int )*unit == 87) {
#line 29
    goto case_119;
  }
#line 32
  if ((int )*unit == 100) {
#line 32
    goto case_100;
  }
#line 32
  if ((int )*unit == 68) {
#line 32
    goto case_100;
  }
#line 35
  if ((int )*unit == 104) {
#line 35
    goto case_104;
  }
#line 35
  if ((int )*unit == 72) {
#line 35
    goto case_104;
  }
#line 39
  if ((int )*unit == 109) {
#line 39
    goto case_109;
  }
#line 39
  if ((int )*unit == 77) {
#line 39
    goto case_109;
  }
#line 39
  if ((int )*unit == 0) {
#line 39
    goto case_109;
  }
#line 42
  if ((int )*unit == 115) {
#line 42
    goto case_115;
  }
#line 42
  if ((int )*unit == 83) {
#line 42
    goto case_115;
  }
#line 44
  goto switch_default;
  case_119: /* CIL Label */ 
  case_87: /* CIL Label */ 
  {
#line 30
  tmp___0 = atoi((char const   *)timestr___2);
  }
#line 30
  return ((u_int )(604800 * tmp___0));
  case_100: /* CIL Label */ 
  case_68: /* CIL Label */ 
  {
#line 33
  tmp___1 = atoi((char const   *)timestr___2);
  }
#line 33
  return ((u_int )(86400 * tmp___1));
  case_104: /* CIL Label */ 
  case_72: /* CIL Label */ 
  {
#line 36
  tmp___2 = atoi((char const   *)timestr___2);
  }
#line 36
  return ((u_int )(3600 * tmp___2));
  case_109: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 40
  tmp___3 = atoi((char const   *)timestr___2);
  }
#line 40
  return ((u_int )(60 * tmp___3));
  case_115: /* CIL Label */ 
  case_83: /* CIL Label */ 
  {
#line 43
  tmp___4 = atoi((char const   *)timestr___2);
  }
#line 43
  return ((u_int )tmp___4);
  switch_default: /* CIL Label */ 
  {
#line 45
  error((char *)"Invalid time unit: %c", (int )*unit);
#line 46
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.c"
static char timestr___0[80]  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.c"
char *unit_rtime(u_int timeval ) 
{ 
  int width ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 56
  if (timeval == 0U) {
#line 57
    return ((char *)"0s");
  }
#line 59
  timestr___0[0] = (char )'\000';
#line 60
  if (timeval > 604800U) {
    {
#line 62
    tmp = strlen((char const   *)(timestr___0));
#line 62
    sprintf((char */* __restrict  */)(timestr___0 + tmp), (char const   */* __restrict  */)"%uw",
            timeval / 604800U);
#line 64
    width = 2;
    }
  } else {
#line 67
    width = 1;
  }
#line 68
  timeval %= 604800U;
#line 69
  if (timeval > 86400U) {
    {
#line 71
    tmp___0 = strlen((char const   *)(timestr___0));
#line 71
    sprintf((char */* __restrict  */)(timestr___0 + tmp___0), (char const   */* __restrict  */)"%ud",
            timeval / 86400U);
#line 73
    width = 2;
    }
  }
#line 75
  timeval %= 86400U;
#line 76
  if (timeval > 3600U) {
    {
#line 78
    tmp___1 = strlen((char const   *)(timestr___0));
#line 78
    sprintf((char */* __restrict  */)(timestr___0 + tmp___1), (char const   */* __restrict  */)"%.*uh",
            width, timeval / 3600U);
#line 80
    width = 2;
    }
  }
#line 82
  timeval %= 3600U;
#line 83
  if (timeval > 60U) {
    {
#line 85
    tmp___2 = strlen((char const   *)(timestr___0));
#line 85
    sprintf((char */* __restrict  */)(timestr___0 + tmp___2), (char const   */* __restrict  */)"%.*um",
            width, timeval / 60U);
#line 87
    width = 2;
    }
  }
#line 89
  timeval %= 60U;
#line 90
  if (timeval > 0U) {
    {
#line 91
    tmp___3 = strlen((char const   *)(timestr___0));
#line 91
    sprintf((char */* __restrict  */)(timestr___0 + tmp___3), (char const   */* __restrict  */)"%.*us",
            width, timeval);
    }
  }
#line 93
  return (timestr___0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.c"
u_int unit_size(char *sizestr ) 
{ 
  char *unit ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 102
  unit = sizestr;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if ((int )*unit != 0) {
      {
#line 103
      tmp = __ctype_b_loc();
      }
#line 103
      if (! (((int const   )*(*tmp + (int )*unit) & 2048) != 0)) {
#line 103
        goto while_break;
      }
    } else {
#line 103
      goto while_break;
    }
#line 104
    unit ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  if ((int )*unit == 103) {
#line 108
    goto case_103;
  }
#line 108
  if ((int )*unit == 71) {
#line 108
    goto case_103;
  }
#line 111
  if ((int )*unit == 109) {
#line 111
    goto case_109;
  }
#line 111
  if ((int )*unit == 77) {
#line 111
    goto case_109;
  }
#line 115
  if ((int )*unit == 107) {
#line 115
    goto case_107;
  }
#line 115
  if ((int )*unit == 75) {
#line 115
    goto case_107;
  }
#line 115
  if ((int )*unit == 0) {
#line 115
    goto case_107;
  }
#line 120
  if ((int )*unit == 99) {
#line 120
    goto case_99;
  }
#line 120
  if ((int )*unit == 67) {
#line 120
    goto case_99;
  }
#line 120
  if ((int )*unit == 98) {
#line 120
    goto case_99;
  }
#line 120
  if ((int )*unit == 66) {
#line 120
    goto case_99;
  }
#line 122
  goto switch_default;
  case_103: /* CIL Label */ 
  case_71: /* CIL Label */ 
  {
#line 109
  tmp___0 = atoi((char const   *)sizestr);
  }
#line 109
  return ((u_int )(1073741824 * tmp___0));
  case_109: /* CIL Label */ 
  case_77: /* CIL Label */ 
  {
#line 112
  tmp___1 = atoi((char const   *)sizestr);
  }
#line 112
  return ((u_int )(1048576 * tmp___1));
  case_107: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 116
  tmp___2 = atoi((char const   *)sizestr);
  }
#line 116
  return ((u_int )(1024 * tmp___2));
  case_99: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_66: /* CIL Label */ 
  {
#line 121
  tmp___3 = atoi((char const   *)sizestr);
  }
#line 121
  return ((u_int )tmp___3);
  switch_default: /* CIL Label */ 
  {
#line 123
  error((char *)"Invalid size unit: %c", (int )*unit);
#line 124
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.c"
static struct codestr sysfac[20]  = 
#line 134
  {      {(char *)"kern", 0}, 
        {(char *)"user", 1 << 3}, 
        {(char *)"mail", 2 << 3}, 
        {(char *)"daemon", 3 << 3}, 
        {(char *)"auth", 4 << 3}, 
        {(char *)"security", 4 << 3}, 
        {(char *)"syslog", 5 << 3}, 
        {(char *)"lpr", 6 << 3}, 
        {(char *)"news", 7 << 3}, 
        {(char *)"uucp", 8 << 3}, 
        {(char *)"cron", 9 << 3}, 
        {(char *)"local0", 16 << 3}, 
        {(char *)"local1", 17 << 3}, 
        {(char *)"local2", 18 << 3}, 
        {(char *)"local3", 19 << 3}, 
        {(char *)"local4", 20 << 3}, 
        {(char *)"local5", 21 << 3}, 
        {(char *)"local6", 22 << 3}, 
        {(char *)"local7", 23 << 3}, 
        {(char *)((void *)0), -1}};
#line 158 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/units.c"
int syslog_facility(char *name ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 163
  i___0 = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! ((unsigned long )sysfac[i___0].name != (unsigned long )((void *)0))) {
#line 164
      goto while_break;
    }
    {
#line 166
    tmp = strcasecmp((char const   *)sysfac[i___0].name, (char const   *)name);
    }
#line 166
    if (tmp == 0) {
#line 167
      return (sysfac[i___0].code);
    }
#line 168
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  error((char *)"Invalid syslog facility: %s", name);
#line 171
  exit(1);
  }
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/ifparser.h"
int ifparser_lex(void) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/ifparser.h"
int ifparser_result  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/ifparser.h"
char const   *ifparser_errmsg  ;
#line 90 "ifparser.tab.c"
short const   ifparser_lhs[18]  = 
#line 90 "ifparser.tab.c"
  {      (short const   )-1,      (short const   )0,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1};
#line 94 "ifparser.tab.c"
short const   ifparser_len[18]  = 
#line 94
  {      (short const   )2,      (short const   )1,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )2,      (short const   )2,      (short const   )1, 
        (short const   )1,      (short const   )1};
#line 98 "ifparser.tab.c"
short const   ifparser_defred[33]  = 
#line 98
  {      (short const   )0,      (short const   )15,      (short const   )16,      (short const   )17, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )13,      (short const   )0,      (short const   )14, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )12,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )2, 
        (short const   )3};
#line 104 "ifparser.tab.c"
short const   ifparser_dgoto[2]  = {      (short const   )7,      (short const   )8};
#line 107 "ifparser.tab.c"
short const   ifparser_sindex[33]  = 
#line 107
  {      (short const   )-33,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-33,      (short const   )-33,      (short const   )-33,      (short const   )0, 
        (short const   )42,      (short const   )0,      (short const   )-27,      (short const   )0, 
        (short const   )-33,      (short const   )-33,      (short const   )-33,      (short const   )-33, 
        (short const   )-33,      (short const   )-33,      (short const   )-33,      (short const   )-33, 
        (short const   )-33,      (short const   )-33,      (short const   )0,      (short const   )-41, 
        (short const   )-41,      (short const   )-41,      (short const   )-41,      (short const   )29, 
        (short const   )29,      (short const   )-41,      (short const   )-41,      (short const   )0, 
        (short const   )0};
#line 113 "ifparser.tab.c"
short const   ifparser_rindex[33]  = 
#line 113
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )6,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )1, 
        (short const   )5,      (short const   )9,      (short const   )13,      (short const   )3, 
        (short const   )15,      (short const   )17,      (short const   )21,      (short const   )0, 
        (short const   )0};
#line 119 "ifparser.tab.c"
short const   ifparser_gindex[2]  = {      (short const   )0,      (short const   )94};
#line 123 "ifparser.tab.c"
short const   ifparser_table[305]  = 
#line 123
  {      (short const   )6,      (short const   )4,      (short const   )20,      (short const   )10, 
        (short const   )21,      (short const   )5,      (short const   )1,      (short const   )5, 
        (short const   )0,      (short const   )7,      (short const   )0,      (short const   )16, 
        (short const   )4,      (short const   )9,      (short const   )22,      (short const   )11, 
        (short const   )20,      (short const   )6,      (short const   )21,      (short const   )0, 
        (short const   )0,      (short const   )8,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )18,      (short const   )0,      (short const   )19, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )4, 
        (short const   )0,      (short const   )10,      (short const   )4,      (short const   )5, 
        (short const   )10,      (short const   )0,      (short const   )5,      (short const   )7, 
        (short const   )0,      (short const   )0,      (short const   )7,      (short const   )9, 
        (short const   )0,      (short const   )11,      (short const   )9,      (short const   )6, 
        (short const   )11,      (short const   )0,      (short const   )6,      (short const   )8, 
        (short const   )0,      (short const   )4,      (short const   )8,      (short const   )4, 
        (short const   )0,      (short const   )5,      (short const   )0,      (short const   )5, 
        (short const   )0,      (short const   )7,      (short const   )0,      (short const   )7, 
        (short const   )20,      (short const   )9,      (short const   )21,      (short const   )9, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )6, 
        (short const   )16,      (short const   )8,      (short const   )0,      (short const   )8, 
        (short const   )0,      (short const   )20,      (short const   )0,      (short const   )21, 
        (short const   )0,      (short const   )18,      (short const   )0,      (short const   )19, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )17,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )0,      (short const   )18,      (short const   )0, 
        (short const   )19,      (short const   )0,      (short const   )23,      (short const   )24, 
        (short const   )25,      (short const   )26,      (short const   )27,      (short const   )28, 
        (short const   )29,      (short const   )30,      (short const   )31,      (short const   )32, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )10, 
        (short const   )0,      (short const   )5,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )7,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )9,      (short const   )0,      (short const   )11, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )8,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )17,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )1,      (short const   )2,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )3,      (short const   )0, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )4,      (short const   )4,      (short const   )4,      (short const   )4, 
        (short const   )5,      (short const   )5,      (short const   )5,      (short const   )5, 
        (short const   )7,      (short const   )7,      (short const   )7,      (short const   )7, 
        (short const   )9,      (short const   )9,      (short const   )9,      (short const   )9, 
        (short const   )6,      (short const   )6,      (short const   )6,      (short const   )6, 
        (short const   )8,      (short const   )8,      (short const   )8,      (short const   )8, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )12,      (short const   )13,      (short const   )14, 
        (short const   )15};
#line 156 "ifparser.tab.c"
short const   ifparser_check[305]  = 
#line 156
  {      (short const   )33,      (short const   )0,      (short const   )43,      (short const   )0, 
        (short const   )45,      (short const   )0,      (short const   )0,      (short const   )40, 
        (short const   )-1,      (short const   )0,      (short const   )-1,      (short const   )38, 
        (short const   )45,      (short const   )0,      (short const   )41,      (short const   )0, 
        (short const   )43,      (short const   )0,      (short const   )45,      (short const   )-1, 
        (short const   )-1,      (short const   )0,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )38, 
        (short const   )-1,      (short const   )38,      (short const   )41,      (short const   )38, 
        (short const   )41,      (short const   )-1,      (short const   )41,      (short const   )38, 
        (short const   )-1,      (short const   )-1,      (short const   )41,      (short const   )38, 
        (short const   )-1,      (short const   )38,      (short const   )41,      (short const   )38, 
        (short const   )41,      (short const   )-1,      (short const   )41,      (short const   )38, 
        (short const   )-1,      (short const   )60,      (short const   )41,      (short const   )62, 
        (short const   )-1,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )-1,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )43,      (short const   )60,      (short const   )45,      (short const   )62, 
        (short const   )-1,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )38,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )-1,      (short const   )43,      (short const   )-1,      (short const   )45, 
        (short const   )-1,      (short const   )60,      (short const   )-1,      (short const   )62, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )124,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )-1,      (short const   )60,      (short const   )-1, 
        (short const   )62,      (short const   )-1,      (short const   )12,      (short const   )13, 
        (short const   )14,      (short const   )15,      (short const   )16,      (short const   )17, 
        (short const   )18,      (short const   )19,      (short const   )20,      (short const   )21, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )124,      (short const   )-1,      (short const   )124, 
        (short const   )-1,      (short const   )124,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )124,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )124,      (short const   )-1,      (short const   )124, 
        (short const   )-1,      (short const   )124,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )124,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )124,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )257,      (short const   )258,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )263,      (short const   )-1, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )259,      (short const   )260,      (short const   )261,      (short const   )262, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )259,      (short const   )260,      (short const   )261, 
        (short const   )262};
#line 195 "ifparser.tab.c"
char const   * const  ifparser_name[267]  = 
#line 195
  {      (char const   */* const  */)"end-of-file",      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)"\'!\'",      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)"\'&\'",      (char const   */* const  */)0, 
        (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'",      (char const   */* const  */)0,      (char const   */* const  */)"\'+\'", 
        (char const   */* const  */)0,      (char const   */* const  */)"\'-\'",      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)"\'<\'",      (char const   */* const  */)0,      (char const   */* const  */)"\'>\'",      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)"\'|\'",      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)0, 
        (char const   */* const  */)0,      (char const   */* const  */)"NUMBER",      (char const   */* const  */)"UVARNAME",      (char const   */* const  */)"EQ", 
        (char const   */* const  */)"NE",      (char const   */* const  */)"LE",      (char const   */* const  */)"GE",      (char const   */* const  */)"IVARNAME", 
        (char const   */* const  */)"NOT",      (char const   */* const  */)"MINUS",      (char const   */* const  */)"DOLLAR"};
#line 205 "ifparser.tab.c"
char const   * const  ifparser_rule[18]  = 
#line 205
  {      (char const   */* const  */)"$accept : condition",      (char const   */* const  */)"condition : expr",      (char const   */* const  */)"expr : expr \'+\' expr",      (char const   */* const  */)"expr : expr \'-\' expr", 
        (char const   */* const  */)"expr : expr EQ expr",      (char const   */* const  */)"expr : expr NE expr",      (char const   */* const  */)"expr : expr \'<\' expr",      (char const   */* const  */)"expr : expr LE expr", 
        (char const   */* const  */)"expr : expr \'>\' expr",      (char const   */* const  */)"expr : expr GE expr",      (char const   */* const  */)"expr : expr \'&\' expr",      (char const   */* const  */)"expr : expr \'|\' expr", 
        (char const   */* const  */)"expr : \'(\' expr \')\'",      (char const   */* const  */)"expr : \'-\' expr",      (char const   */* const  */)"expr : \'!\' expr",      (char const   */* const  */)"expr : NUMBER", 
        (char const   */* const  */)"expr : UVARNAME",      (char const   */* const  */)"expr : IVARNAME"};
#line 238 "ifparser.tab.c"
int ifparser_debug  ;
#line 239 "ifparser.tab.c"
int ifparser_nerrs  ;
#line 240 "ifparser.tab.c"
int ifparser_errflag  ;
#line 241 "ifparser.tab.c"
int ifparser_char  ;
#line 242 "ifparser.tab.c"
short *ifparser_ssp  ;
#line 243 "ifparser.tab.c"
YYSTYPE *ifparser_vsp  ;
#line 244 "ifparser.tab.c"
YYSTYPE ifparser_val  ;
#line 245 "ifparser.tab.c"
YYSTYPE ifparser_lval  ;
#line 246 "ifparser.tab.c"
short *ifparser_ss  ;
#line 247 "ifparser.tab.c"
short *ifparser_sslim  ;
#line 248 "ifparser.tab.c"
YYSTYPE *ifparser_vs  ;
#line 249 "ifparser.tab.c"
int ifparser_stacksize  ;
#line 68 "ifparser.y"
static int ifparser_error(char const   *msg ) 
{ 


  {
#line 71
  ifparser_errmsg = msg;
#line 72
  return (0);
}
}
#line 261 "ifparser.tab.c"
static int yygrowstack(void) ;
#line 262 "ifparser.tab.c"
static int yygrowstack(void) 
{ 
  int newsize ;
  int i___0 ;
  short *newss ;
  YYSTYPE *newvs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 268
  newsize = ifparser_stacksize;
#line 268
  if (newsize == 0) {
#line 269
    newsize = 200;
  } else
#line 270
  if (newsize >= 10000) {
#line 271
    return (-1);
  } else {
#line 272
    newsize *= 2;
#line 272
    if (newsize > 10000) {
#line 273
      newsize = 10000;
    }
  }
  {
#line 274
  i___0 = (int )(ifparser_ssp - ifparser_ss);
#line 275
  tmp = realloc((void *)ifparser_ss, (unsigned long )newsize * sizeof(*newss));
#line 275
  newss = (short *)tmp;
  }
#line 275
  if ((unsigned long )newss == (unsigned long )((void *)0)) {
#line 276
    return (-1);
  }
  {
#line 277
  ifparser_ss = newss;
#line 278
  ifparser_ssp = newss + i___0;
#line 279
  tmp___0 = realloc((void *)ifparser_vs, (unsigned long )newsize * sizeof(*newvs));
#line 279
  newvs = (YYSTYPE *)tmp___0;
  }
#line 279
  if ((unsigned long )newvs == (unsigned long )((void *)0)) {
#line 280
    return (-1);
  }
#line 281
  ifparser_vs = newvs;
#line 282
  ifparser_vsp = newvs + i___0;
#line 283
  ifparser_stacksize = newsize;
#line 284
  ifparser_sslim = (ifparser_ss + newsize) - 1;
#line 285
  return (0);
}
}
#line 292 "ifparser.tab.c"
int ifparser_parse(void) 
{ 
  int yym ;
  int yyn ;
  int yystate ;
  char const   *yys ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 299
  tmp = getenv("YYDEBUG");
#line 299
  yys = (char const   *)tmp;
  }
#line 299
  if ((unsigned long )yys != (unsigned long )((void *)0)) {
#line 301
    yyn = (int )*yys;
#line 302
    if (yyn >= 48) {
#line 302
      if (yyn <= 57) {
#line 303
        ifparser_debug = yyn - 48;
      }
    }
  }
#line 307
  ifparser_nerrs = 0;
#line 308
  ifparser_errflag = 0;
#line 309
  ifparser_char = -1;
#line 311
  if ((unsigned long )ifparser_ss == (unsigned long )((void *)0)) {
    {
#line 311
    tmp___0 = yygrowstack();
    }
#line 311
    if (tmp___0) {
#line 311
      goto yyoverflow;
    }
  }
#line 312
  ifparser_ssp = ifparser_ss;
#line 313
  ifparser_vsp = ifparser_vs;
#line 314
  yystate = 0;
#line 314
  *ifparser_ssp = (short )yystate;
  yyloop: 
#line 317
  yyn = (int )ifparser_defred[yystate];
#line 317
  if (yyn != 0) {
#line 317
    goto yyreduce;
  }
#line 318
  if (ifparser_char < 0) {
    {
#line 320
    ifparser_char = ifparser_lex();
    }
#line 320
    if (ifparser_char < 0) {
#line 320
      ifparser_char = 0;
    }
#line 322
    if (ifparser_debug) {
#line 324
      yys = (char const   *)0;
#line 325
      if (ifparser_char <= 266) {
#line 325
        yys = (char const   *)ifparser_name[ifparser_char];
      }
#line 326
      if (! yys) {
#line 326
        yys = "illegal-symbol";
      }
      {
#line 327
      printf((char const   */* __restrict  */)"%sdebug: state %d, reading %d (%s)\n",
             "ifparser_", yystate, ifparser_char, yys);
      }
    }
  }
#line 332
  yyn = (int )ifparser_sindex[yystate];
#line 332
  if (yyn) {
#line 332
    yyn += ifparser_char;
#line 332
    if (yyn >= 0) {
#line 332
      if (yyn <= 304) {
#line 332
        if ((int const   )ifparser_check[yyn] == (int const   )ifparser_char) {
#line 336
          if (ifparser_debug) {
            {
#line 337
            printf((char const   */* __restrict  */)"%sdebug: state %d, shifting to state %d\n",
                   "ifparser_", yystate, (int const   )ifparser_table[yyn]);
            }
          }
#line 340
          if ((unsigned long )ifparser_ssp >= (unsigned long )ifparser_sslim) {
            {
#line 340
            tmp___1 = yygrowstack();
            }
#line 340
            if (tmp___1) {
#line 342
              goto yyoverflow;
            }
          }
#line 344
          ifparser_ssp ++;
#line 344
          yystate = (int )ifparser_table[yyn];
#line 344
          *ifparser_ssp = (short )yystate;
#line 345
          ifparser_vsp ++;
#line 345
          *ifparser_vsp = ifparser_lval;
#line 346
          ifparser_char = -1;
#line 347
          if (ifparser_errflag > 0) {
#line 347
            ifparser_errflag --;
          }
#line 348
          goto yyloop;
        }
      }
    }
  }
#line 350
  yyn = (int )ifparser_rindex[yystate];
#line 350
  if (yyn) {
#line 350
    yyn += ifparser_char;
#line 350
    if (yyn >= 0) {
#line 350
      if (yyn <= 304) {
#line 350
        if ((int const   )ifparser_check[yyn] == (int const   )ifparser_char) {
#line 353
          yyn = (int )ifparser_table[yyn];
#line 354
          goto yyreduce;
        }
      }
    }
  }
#line 356
  if (ifparser_errflag) {
#line 356
    goto yyinrecovery;
  }
#line 357
  goto yynewerror;
  yynewerror: 
  {
#line 359
  ifparser_error("syntax error");
  }
#line 360
  goto yyerrlab;
  yyerrlab: 
#line 362
  ifparser_nerrs ++;
  yyinrecovery: 
#line 364
  if (ifparser_errflag < 3) {
#line 366
    ifparser_errflag = 3;
    {
#line 367
    while (1) {
      while_continue: /* CIL Label */ ;
#line 369
      yyn = (int )ifparser_sindex[*ifparser_ssp];
#line 369
      if (yyn) {
#line 369
        yyn += 256;
#line 369
        if (yyn >= 0) {
#line 369
          if (yyn <= 304) {
#line 369
            if ((int const   )ifparser_check[yyn] == 256) {
#line 373
              if (ifparser_debug) {
                {
#line 374
                printf((char const   */* __restrict  */)"%sdebug: state %d, error recovery shifting to state %d\n",
                       "ifparser_", (int )*ifparser_ssp, (int const   )ifparser_table[yyn]);
                }
              }
#line 377
              if ((unsigned long )ifparser_ssp >= (unsigned long )ifparser_sslim) {
                {
#line 377
                tmp___2 = yygrowstack();
                }
#line 377
                if (tmp___2) {
#line 379
                  goto yyoverflow;
                }
              }
#line 381
              ifparser_ssp ++;
#line 381
              yystate = (int )ifparser_table[yyn];
#line 381
              *ifparser_ssp = (short )yystate;
#line 382
              ifparser_vsp ++;
#line 382
              *ifparser_vsp = ifparser_lval;
#line 383
              goto yyloop;
            } else {
#line 369
              goto _L___1;
            }
          } else {
#line 369
            goto _L___1;
          }
        } else {
#line 369
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 388
        if (ifparser_debug) {
          {
#line 389
          printf((char const   */* __restrict  */)"%sdebug: error recovery discarding state %d\n",
                 "ifparser_", (int )*ifparser_ssp);
          }
        }
#line 392
        if ((unsigned long )ifparser_ssp <= (unsigned long )ifparser_ss) {
#line 392
          goto yyabort;
        }
#line 393
        ifparser_ssp --;
#line 394
        ifparser_vsp --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 400
    if (ifparser_char == 0) {
#line 400
      goto yyabort;
    }
#line 402
    if (ifparser_debug) {
#line 404
      yys = (char const   *)0;
#line 405
      if (ifparser_char <= 266) {
#line 405
        yys = (char const   *)ifparser_name[ifparser_char];
      }
#line 406
      if (! yys) {
#line 406
        yys = "illegal-symbol";
      }
      {
#line 407
      printf((char const   */* __restrict  */)"%sdebug: state %d, error recovery discards token %d (%s)\n",
             "ifparser_", yystate, ifparser_char, yys);
      }
    }
#line 411
    ifparser_char = -1;
#line 412
    goto yyloop;
  }
  yyreduce: 
#line 416
  if (ifparser_debug) {
    {
#line 417
    printf((char const   */* __restrict  */)"%sdebug: state %d, reducing by rule %d (%s)\n",
           "ifparser_", yystate, yyn, ifparser_rule[yyn]);
    }
  }
#line 420
  yym = (int )ifparser_len[yyn];
#line 421
  ifparser_val = *(ifparser_vsp + (1 - yym));
  {
#line 424
  if (yyn == 1) {
#line 424
    goto case_1;
  }
#line 42
  if (yyn == 2) {
#line 42 "ifparser.y"
    goto case_2;
  }
#line 43
  if (yyn == 3) {
#line 43
    goto case_3;
  }
#line 44
  if (yyn == 4) {
#line 44
    goto case_4;
  }
#line 45
  if (yyn == 5) {
#line 45
    goto case_5;
  }
#line 46
  if (yyn == 6) {
#line 46
    goto case_6;
  }
#line 47
  if (yyn == 7) {
#line 47
    goto case_7;
  }
#line 48
  if (yyn == 8) {
#line 48
    goto case_8;
  }
#line 49
  if (yyn == 9) {
#line 49
    goto case_9;
  }
#line 50
  if (yyn == 10) {
#line 50
    goto case_10;
  }
#line 51
  if (yyn == 11) {
#line 51
    goto case_11;
  }
#line 52
  if (yyn == 12) {
#line 52
    goto case_12;
  }
#line 53
  if (yyn == 13) {
#line 53
    goto case_13;
  }
#line 54
  if (yyn == 14) {
#line 54
    goto case_14;
  }
#line 56
  if (yyn == 15) {
#line 56
    goto case_15;
  }
#line 58
  if (yyn == 16) {
#line 58
    goto case_16;
  }
#line 59
  if (yyn == 17) {
#line 59
    goto case_17;
  }
#line 422 "ifparser.tab.c"
  goto switch_break;
  case_1: /* CIL Label */ 
#line 40 "ifparser.y"
  ifparser_result = (int )ifparser_val.integer;
#line 41
  goto switch_break;
  case_2: /* CIL Label */ 
#line 41
  ifparser_val.integer = (ifparser_vsp + -2)->integer + (ifparser_vsp + 0)->integer;
#line 42
  goto switch_break;
  case_3: /* CIL Label */ 
#line 42
  ifparser_val.integer = (ifparser_vsp + -2)->integer - (ifparser_vsp + 0)->integer;
#line 43
  goto switch_break;
  case_4: /* CIL Label */ 
#line 43
  ifparser_val.integer = (long )((ifparser_vsp + -2)->integer == (ifparser_vsp + 0)->integer);
#line 44
  goto switch_break;
  case_5: /* CIL Label */ 
#line 44
  ifparser_val.integer = (long )((ifparser_vsp + -2)->integer != (ifparser_vsp + 0)->integer);
#line 45
  goto switch_break;
  case_6: /* CIL Label */ 
#line 45
  ifparser_val.integer = (long )((ifparser_vsp + -2)->integer < (ifparser_vsp + 0)->integer);
#line 46
  goto switch_break;
  case_7: /* CIL Label */ 
#line 46
  ifparser_val.integer = (long )((ifparser_vsp + -2)->integer <= (ifparser_vsp + 0)->integer);
#line 47
  goto switch_break;
  case_8: /* CIL Label */ 
#line 47
  ifparser_val.integer = (long )((ifparser_vsp + -2)->integer > (ifparser_vsp + 0)->integer);
#line 48
  goto switch_break;
  case_9: /* CIL Label */ 
#line 48
  ifparser_val.integer = (long )((ifparser_vsp + -2)->integer >= (ifparser_vsp + 0)->integer);
#line 49
  goto switch_break;
  case_10: /* CIL Label */ 
#line 49
  if ((ifparser_vsp + -2)->integer) {
#line 49
    if ((ifparser_vsp + 0)->integer) {
#line 49
      tmp___3 = 1;
    } else {
#line 49
      tmp___3 = 0;
    }
  } else {
#line 49
    tmp___3 = 0;
  }
#line 49
  ifparser_val.integer = (long )tmp___3;
#line 50
  goto switch_break;
  case_11: /* CIL Label */ 
#line 50
  if ((ifparser_vsp + -2)->integer) {
#line 50
    tmp___4 = 1;
  } else
#line 50
  if ((ifparser_vsp + 0)->integer) {
#line 50
    tmp___4 = 1;
  } else {
#line 50
    tmp___4 = 0;
  }
#line 50
  ifparser_val.integer = (long )tmp___4;
#line 51
  goto switch_break;
  case_12: /* CIL Label */ 
#line 51
  ifparser_val.integer = (ifparser_vsp + -1)->integer;
#line 52
  goto switch_break;
  case_13: /* CIL Label */ 
#line 52
  ifparser_val.integer = - (ifparser_vsp + 0)->integer;
#line 53
  goto switch_break;
  case_14: /* CIL Label */ 
#line 54
  ifparser_val.integer = (long )(! (ifparser_vsp + 0)->integer);
#line 55
  goto switch_break;
  case_15: /* CIL Label */ 
#line 56
  ifparser_val.integer = (ifparser_vsp + 0)->integer;
#line 57
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 57
  tmp___5 = byteset_get((int )(ifparser_vsp + 0)->integer);
#line 57
  ifparser_val.integer = (long )tmp___5;
  }
#line 58
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 58
  tmp___6 = variable_get((ifparser_vsp + 0)->string, & ifparser_val.integer);
  }
#line 58
  if (tmp___6 != 0) {
    {
#line 60
    ifparser_error("Unknown variable used");
    }
#line 61
    goto yyerrlab;
  }
#line 64
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 499 "ifparser.tab.c"
  ifparser_ssp -= yym;
#line 500
  yystate = (int )*ifparser_ssp;
#line 501
  ifparser_vsp -= yym;
#line 502
  yym = (int )ifparser_lhs[yyn];
#line 503
  if (yystate == 0) {
#line 503
    if (yym == 0) {
#line 506
      if (ifparser_debug) {
        {
#line 507
        printf((char const   */* __restrict  */)"%sdebug: after reduction, shifting from state 0 to state %d\n",
               "ifparser_", 7);
        }
      }
#line 510
      yystate = 7;
#line 511
      ifparser_ssp ++;
#line 511
      *ifparser_ssp = (short)7;
#line 512
      ifparser_vsp ++;
#line 512
      *ifparser_vsp = ifparser_val;
#line 513
      if (ifparser_char < 0) {
        {
#line 515
        ifparser_char = ifparser_lex();
        }
#line 515
        if (ifparser_char < 0) {
#line 515
          ifparser_char = 0;
        }
#line 517
        if (ifparser_debug) {
#line 519
          yys = (char const   *)0;
#line 520
          if (ifparser_char <= 266) {
#line 520
            yys = (char const   *)ifparser_name[ifparser_char];
          }
#line 521
          if (! yys) {
#line 521
            yys = "illegal-symbol";
          }
          {
#line 522
          printf((char const   */* __restrict  */)"%sdebug: state %d, reading %d (%s)\n",
                 "ifparser_", 7, ifparser_char, yys);
          }
        }
      }
#line 527
      if (ifparser_char == 0) {
#line 527
        goto yyaccept;
      }
#line 528
      goto yyloop;
    }
  }
#line 530
  yyn = (int )ifparser_gindex[yym];
#line 530
  if (yyn) {
#line 530
    yyn += yystate;
#line 530
    if (yyn >= 0) {
#line 530
      if (yyn <= 304) {
#line 530
        if ((int const   )ifparser_check[yyn] == (int const   )yystate) {
#line 532
          yystate = (int )ifparser_table[yyn];
        } else {
#line 534
          yystate = (int )ifparser_dgoto[yym];
        }
      } else {
#line 534
        yystate = (int )ifparser_dgoto[yym];
      }
    } else {
#line 534
      yystate = (int )ifparser_dgoto[yym];
    }
  } else {
#line 534
    yystate = (int )ifparser_dgoto[yym];
  }
#line 536
  if (ifparser_debug) {
    {
#line 537
    printf((char const   */* __restrict  */)"%sdebug: after reduction, shifting from state %d to state %d\n",
           "ifparser_", (int )*ifparser_ssp, yystate);
    }
  }
#line 540
  if ((unsigned long )ifparser_ssp >= (unsigned long )ifparser_sslim) {
    {
#line 540
    tmp___7 = yygrowstack();
    }
#line 540
    if (tmp___7) {
#line 542
      goto yyoverflow;
    }
  }
#line 544
  ifparser_ssp ++;
#line 544
  *ifparser_ssp = (short )yystate;
#line 545
  ifparser_vsp ++;
#line 545
  *ifparser_vsp = ifparser_val;
#line 546
  goto yyloop;
  yyoverflow: 
  {
#line 548
  ifparser_error("yacc stack overflow");
  }
  yyabort: 
#line 550
  return (1);
  yyaccept: 
#line 552
  return (0);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/siglist.h"
char *getsignamebynum(int num ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/signals.h"
struct signame signame[1]  = {      {(char *)((void *)0), 0}};
#line 19 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/siglist.c"
int getsignumbyname(char *name ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 24
  i___0 = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! ((unsigned long )signame[i___0].name != (unsigned long )((void *)0))) {
#line 31
      goto while_break;
    }
    {
#line 33
    tmp = strcmp((char const   *)signame[i___0].name, (char const   *)name);
    }
#line 33
    if (tmp == 0) {
#line 34
      return (signame[i___0].num);
    }
#line 36
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (-1);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/siglist.c"
char *getsignamebynum(int num ) 
{ 
  int i___0 ;

  {
#line 46
  i___0 = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((unsigned long )signame[i___0].name != (unsigned long )((void *)0))) {
#line 51
      goto while_break;
    }
#line 53
    if (signame[i___0].num == num) {
#line 54
      return (signame[i___0].name);
    }
#line 55
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return ((char *)"???");
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 119 "ifparser.lex.c"
int ifparser_leng  ;
#line 120
FILE *ifparser_in ;
#line 120
FILE *ifparser_out ;
#line 219 "ifparser.lex.c"
static YY_BUFFER_STATE yy_current_buffer  =    (YY_BUFFER_STATE )0;
#line 229 "ifparser.lex.c"
static char yy_hold_char  ;
#line 231 "ifparser.lex.c"
static int yy_n_chars  ;
#line 237 "ifparser.lex.c"
static char *yy_c_buf_p  =    (char *)0;
#line 238 "ifparser.lex.c"
static int yy_init  =    1;
#line 239 "ifparser.lex.c"
static int yy_start  =    0;
#line 244 "ifparser.lex.c"
static int yy_did_buffer_switch_on_eof  ;
#line 246
void ifparser_restart(FILE *input_file ) ;
#line 248
void ifparser__switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 249
void ifparser__load_buffer_state(void) ;
#line 250
YY_BUFFER_STATE ifparser__create_buffer(FILE *file , int size ) ;
#line 251
void ifparser__delete_buffer(YY_BUFFER_STATE b ) ;
#line 252
void ifparser__init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 253
void ifparser__flush_buffer(YY_BUFFER_STATE b ) ;
#line 256
YY_BUFFER_STATE ifparser__scan_buffer(char *base , yy_size_t size ) ;
#line 257
YY_BUFFER_STATE ifparser__scan_string(char const   *yy_str ) ;
#line 258
YY_BUFFER_STATE ifparser__scan_bytes(char const   *bytes , int len ) ;
#line 260
static void *yy_flex_alloc(yy_size_t size ) ;
#line 261
static void *yy_flex_realloc(void *ptr , yy_size_t size ) ;
#line 262
static void yy_flex_free(void *ptr ) ;
#line 286 "ifparser.lex.c"
FILE *ifparser_in  =    (FILE *)0;
#line 286 "ifparser.lex.c"
FILE *ifparser_out  =    (FILE *)0;
#line 288 "ifparser.lex.c"
char *ifparser_text  ;
#line 291
static yy_state_type yy_get_previous_state(void) ;
#line 292
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 293
static int yy_get_next_buffer(void) ;
#line 294
static void yy_fatal_error(char const   *msg ) ;
#line 308 "ifparser.lex.c"
static short const   yy_accept[25]  = 
#line 308
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )12, 
        (short const   )10,      (short const   )1,      (short const   )8,      (short const   )10, 
        (short const   )10,      (short const   )8,      (short const   )10,      (short const   )2, 
        (short const   )8,      (short const   )10,      (short const   )8,      (short const   )10, 
        (short const   )1,      (short const   )5,      (short const   )9,      (short const   )3, 
        (short const   )2,      (short const   )6,      (short const   )4,      (short const   )7, 
        (short const   )0};
#line 315 "ifparser.lex.c"
static int const   yy_ec[256]  = 
#line 315
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )1,      (int const   )1, 
        (int const   )4,      (int const   )1,      (int const   )5,      (int const   )1, 
        (int const   )6,      (int const   )6,      (int const   )6,      (int const   )6, 
        (int const   )1,      (int const   )7,      (int const   )1,      (int const   )1, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )1,      (int const   )1, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )1, 
        (int const   )1,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )12,      (int const   )12,      (int const   )12,      (int const   )1, 
        (int const   )13,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 347 "ifparser.lex.c"
static int const   yy_meta[14]  = 
#line 347
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1};
#line 353 "ifparser.lex.c"
static short const   yy_base[25]  = 
#line 353
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )27, 
        (short const   )28,      (short const   )24,      (short const   )15,      (short const   )12, 
        (short const   )18,      (short const   )28,      (short const   )14,      (short const   )13, 
        (short const   )10,      (short const   )9,      (short const   )8,      (short const   )4, 
        (short const   )14,      (short const   )28,      (short const   )3,      (short const   )28, 
        (short const   )6,      (short const   )28,      (short const   )28,      (short const   )28, 
        (short const   )28};
#line 360 "ifparser.lex.c"
static short const   yy_def[25]  = 
#line 360
  {      (short const   )0,      (short const   )24,      (short const   )1,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )0};
#line 367 "ifparser.lex.c"
static short const   yy_nxt[42]  = 
#line 367
  {      (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )13,      (short const   )14, 
        (short const   )4,      (short const   )15,      (short const   )20,      (short const   )18, 
        (short const   )16,      (short const   )19,      (short const   )23,      (short const   )22, 
        (short const   )21,      (short const   )20,      (short const   )20,      (short const   )19, 
        (short const   )18,      (short const   )17,      (short const   )16,      (short const   )24, 
        (short const   )3,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24};
#line 376 "ifparser.lex.c"
static short const   yy_chk[42]  = 
#line 376
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )20,      (short const   )18, 
        (short const   )16,      (short const   )15,      (short const   )14,      (short const   )13, 
        (short const   )12,      (short const   )11,      (short const   )10,      (short const   )8, 
        (short const   )7,      (short const   )6,      (short const   )5,      (short const   )3, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24};
#line 385 "ifparser.lex.c"
static yy_state_type yy_last_accepting_state  ;
#line 386 "ifparser.lex.c"
static char *yy_last_accepting_cpos  ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 16 "ifparser.l"
static char *inputstr  ;
#line 17 "ifparser.l"
static int inputstrcur  ;
#line 17 "ifparser.l"
static int inputstrlen  ;
#line 19
static int ifparser_input(char *buf , int max_size ) ;
#line 566 "ifparser.lex.c"
int ifparser_lex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  register YY_CHAR yy_c ;
  int tmp ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___0 ;

  {
#line 577
  if (yy_init) {
#line 579
    yy_init = 0;
#line 585
    if (! yy_start) {
#line 586
      yy_start = 1;
    }
#line 588
    if (! ifparser_in) {
#line 589
      ifparser_in = stdin;
    }
#line 591
    if (! ifparser_out) {
#line 592
      ifparser_out = stdout;
    }
#line 594
    if (! yy_current_buffer) {
      {
#line 595
      yy_current_buffer = ifparser__create_buffer(ifparser_in, 16384);
      }
    }
    {
#line 598
    ifparser__load_buffer_state();
    }
  }
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    yy_cp = yy_c_buf_p;
#line 606
    *yy_cp = yy_hold_char;
#line 611
    yy_bp = yy_cp;
#line 613
    yy_current_state = yy_start;
    yy_match: 
    {
#line 615
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 617
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 618
      if (yy_accept[yy_current_state]) {
#line 620
        yy_last_accepting_state = yy_current_state;
#line 621
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 623
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 623
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 623
          goto while_break___1;
        }
#line 625
        yy_current_state = (int )yy_def[yy_current_state];
#line 626
        if (yy_current_state >= 25) {
#line 627
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 629
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 630
      yy_cp ++;
#line 615
      if (! ((int const   )yy_base[yy_current_state] != 28)) {
#line 615
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 635
    yy_act = (int )yy_accept[yy_current_state];
#line 636
    if (yy_act == 0) {
#line 638
      yy_cp = yy_last_accepting_cpos;
#line 639
      yy_current_state = yy_last_accepting_state;
#line 640
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 643
    ifparser_text = yy_bp;
#line 643
    ifparser_leng = (int )(yy_cp - yy_bp);
#line 643
    yy_hold_char = *yy_cp;
#line 643
    *yy_cp = (char )'\000';
#line 643
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 651
    if (yy_act == 0) {
#line 651
      goto case_0;
    }
#line 658
    if (yy_act == 1) {
#line 658
      goto case_1;
    }
#line 32
    if (yy_act == 2) {
#line 32 "ifparser.l"
      goto case_2;
    }
#line 34
    if (yy_act == 3) {
#line 34
      goto case_3;
    }
#line 36
    if (yy_act == 4) {
#line 36
      goto case_4;
    }
#line 37
    if (yy_act == 5) {
#line 37
      goto case_5;
    }
#line 38
    if (yy_act == 6) {
#line 38
      goto case_6;
    }
#line 39
    if (yy_act == 7) {
#line 39
      goto case_7;
    }
#line 40
    if (yy_act == 8) {
#line 40
      goto case_8;
    }
#line 41
    if (yy_act == 9) {
#line 41
      goto case_9;
    }
#line 43
    if (yy_act == 10) {
#line 43
      goto case_10;
    }
#line 44
    if (yy_act == 11) {
#line 44
      goto case_11;
    }
#line 714
    if (yy_act == 13) {
#line 714 "ifparser.lex.c"
      goto case_13;
    }
#line 717
    if (yy_act == 12) {
#line 717
      goto case_12;
    }
#line 839
    goto switch_default;
    case_0: /* CIL Label */ 
#line 653
    *yy_cp = yy_hold_char;
#line 654
    yy_cp = yy_last_accepting_cpos;
#line 655
    yy_current_state = yy_last_accepting_state;
#line 656
    goto yy_find_action;
    case_1: /* CIL Label */ ;
#line 31 "ifparser.l"
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 32
    tmp = atoi((char const   *)ifparser_text);
#line 32
    ifparser_lval.integer = (long )tmp;
    }
#line 32
    return (257);
#line 33
    goto switch_break;
    case_3: /* CIL Label */ 
#line 34
    return ((int )*(ifparser_text + 0));
#line 35
    goto switch_break;
    case_4: /* CIL Label */ 
#line 35
    return (259);
#line 36
    goto switch_break;
    case_5: /* CIL Label */ 
#line 36
    return (260);
#line 37
    goto switch_break;
    case_6: /* CIL Label */ 
#line 37
    return (261);
#line 38
    goto switch_break;
    case_7: /* CIL Label */ 
#line 38
    return (262);
#line 39
    goto switch_break;
    case_8: /* CIL Label */ 
#line 39
    return ((int )*(ifparser_text + 0));
#line 40
    goto switch_break;
    case_9: /* CIL Label */ 
#line 41
    ifparser_lval.string = ifparser_text + 1;
#line 41
    return (263);
#line 42
    goto switch_break;
    case_10: /* CIL Label */ 
#line 42
    ifparser_lval.integer = (long )*(ifparser_text + 0);
#line 42
    return (258);
#line 43
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 44
    yy_fatal_error("flex scanner jammed");
    }
#line 45
    goto switch_break;
    case_13: /* CIL Label */ 
#line 715 "ifparser.lex.c"
    return (0);
    case_12: /* CIL Label */ 
#line 720
    yy_amount_of_matched_text = (int )(yy_cp - ifparser_text) - 1;
#line 723
    *yy_cp = yy_hold_char;
#line 726
    if (yy_current_buffer->yy_buffer_status == 0) {
#line 737
      yy_n_chars = yy_current_buffer->yy_n_chars;
#line 738
      yy_current_buffer->yy_input_file = ifparser_in;
#line 739
      yy_current_buffer->yy_buffer_status = 1;
    }
#line 749
    if ((unsigned long )yy_c_buf_p <= (unsigned long )(yy_current_buffer->yy_ch_buf + yy_n_chars)) {
      {
#line 753
      yy_c_buf_p = ifparser_text + yy_amount_of_matched_text;
#line 755
      yy_current_state = yy_get_previous_state();
#line 766
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 768
      yy_bp = ifparser_text + 0;
      }
#line 770
      if (yy_next_state) {
#line 773
        yy_c_buf_p ++;
#line 773
        yy_cp = yy_c_buf_p;
#line 774
        yy_current_state = yy_next_state;
#line 775
        goto yy_match;
      } else {
#line 780
        yy_cp = yy_c_buf_p;
#line 781
        goto yy_find_action;
      }
    } else {
      {
#line 785
      tmp___0 = yy_get_next_buffer();
      }
      {
#line 787
      if (tmp___0 == 1) {
#line 787
        goto case_1___0;
      }
#line 816
      if (tmp___0 == 0) {
#line 816
        goto case_0___0;
      }
#line 826
      if (tmp___0 == 2) {
#line 826
        goto case_2___0;
      }
#line 785
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 789
      yy_did_buffer_switch_on_eof = 0;
#line 802
      yy_c_buf_p = ifparser_text + 0;
#line 804
      yy_act = (12 + (yy_start - 1) / 2) + 1;
#line 805
      goto do_action;
#line 813
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 817
      yy_c_buf_p = ifparser_text + yy_amount_of_matched_text;
#line 820
      yy_current_state = yy_get_previous_state();
#line 822
      yy_cp = yy_c_buf_p;
#line 823
      yy_bp = ifparser_text + 0;
      }
#line 824
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 827
      yy_c_buf_p = yy_current_buffer->yy_ch_buf + yy_n_chars;
#line 830
      yy_current_state = yy_get_previous_state();
#line 832
      yy_cp = yy_c_buf_p;
#line 833
      yy_bp = ifparser_text + 0;
      }
#line 834
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 836
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 840
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 855 "ifparser.lex.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i___0 ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___1 ;

  {
#line 857
  dest = yy_current_buffer->yy_ch_buf;
#line 858
  source = ifparser_text;
#line 862
  if ((unsigned long )yy_c_buf_p > (unsigned long )(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 863
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 866
  if (yy_current_buffer->yy_fill_buffer == 0) {
#line 868
    if (yy_c_buf_p - ifparser_text == 1L) {
#line 873
      return (1);
    } else {
#line 881
      return (2);
    }
  }
#line 888
  number_to_move = (int )(yy_c_buf_p - ifparser_text) - 1;
#line 890
  i___0 = 0;
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (! (i___0 < number_to_move)) {
#line 890
      goto while_break;
    }
#line 891
    tmp = dest;
#line 891
    dest ++;
#line 891
    tmp___0 = source;
#line 891
    source ++;
#line 891
    *tmp = *tmp___0;
#line 890
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 893
  if (yy_current_buffer->yy_buffer_status == 2) {
#line 897
    yy_n_chars = 0;
#line 897
    yy_current_buffer->yy_n_chars = yy_n_chars;
  } else {
#line 901
    num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 904
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 904
      if (! (num_to_read <= 0)) {
#line 904
        goto while_break___0;
      }
#line 912
      b = yy_current_buffer;
#line 914
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 917
      if (b->yy_is_our_buffer) {
#line 919
        new_size = (int )(b->yy_buf_size * 2U);
#line 921
        if (new_size <= 0) {
#line 922
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 924
          b->yy_buf_size *= 2U;
        }
        {
#line 926
        tmp___1 = yy_flex_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 926
        b->yy_ch_buf = (char *)tmp___1;
        }
      } else {
#line 933
        b->yy_ch_buf = (char *)0;
      }
#line 935
      if (! b->yy_ch_buf) {
        {
#line 936
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 939
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 941
      num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 946
    if (num_to_read > 8192) {
#line 947
      num_to_read = 8192;
    }
    {
#line 950
    yy_n_chars = ifparser_input(yy_current_buffer->yy_ch_buf + number_to_move, num_to_read);
#line 953
    yy_current_buffer->yy_n_chars = yy_n_chars;
    }
  }
#line 956
  if (yy_n_chars == 0) {
#line 958
    if (number_to_move == 0) {
      {
#line 960
      ret_val = 1;
#line 961
      ifparser_restart(ifparser_in);
      }
    } else {
#line 966
      ret_val = 2;
#line 967
      yy_current_buffer->yy_buffer_status = 2;
    }
  } else {
#line 973
    ret_val = 0;
  }
#line 975
  yy_n_chars += number_to_move;
#line 976
  *(yy_current_buffer->yy_ch_buf + yy_n_chars) = (char)0;
#line 977
  *(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 979
  ifparser_text = yy_current_buffer->yy_ch_buf + 0;
#line 981
  return (ret_val);
}
}
#line 987 "ifparser.lex.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 992
  yy_current_state = yy_start;
#line 994
  yy_cp = ifparser_text + 0;
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 994
      goto while_break;
    }
#line 996
    if (*yy_cp) {
#line 996
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 996
      tmp = (int const   )1;
    }
#line 996
    yy_c = (YY_CHAR )tmp;
#line 997
    if (yy_accept[yy_current_state]) {
#line 999
      yy_last_accepting_state = yy_current_state;
#line 1000
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1002
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1002
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1002
        goto while_break___0;
      }
#line 1004
      yy_current_state = (int )yy_def[yy_current_state];
#line 1005
      if (yy_current_state >= 25) {
#line 1006
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1008
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 994
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1011
  return (yy_current_state);
}
}
#line 1022 "ifparser.lex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1029
  yy_cp = yy_c_buf_p;
#line 1031
  yy_c = (YY_CHAR )1;
#line 1032
  if (yy_accept[yy_current_state]) {
#line 1034
    yy_last_accepting_state = yy_current_state;
#line 1035
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1037
      goto while_break;
    }
#line 1039
    yy_current_state = (int )yy_def[yy_current_state];
#line 1040
    if (yy_current_state >= 25) {
#line 1041
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1043
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1044
  yy_is_jam = yy_current_state == 24;
#line 1046
  if (yy_is_jam) {
#line 1046
    tmp = 0;
  } else {
#line 1046
    tmp = yy_current_state;
  }
#line 1046
  return (tmp);
}
}
#line 1169 "ifparser.lex.c"
void ifparser_restart(FILE *input_file ) 
{ 


  {
#line 1175
  if (! yy_current_buffer) {
    {
#line 1176
    yy_current_buffer = ifparser__create_buffer(ifparser_in, 16384);
    }
  }
  {
#line 1178
  ifparser__init_buffer(yy_current_buffer, input_file);
#line 1179
  ifparser__load_buffer_state();
  }
#line 1180
  return;
}
}
#line 1184 "ifparser.lex.c"
void ifparser__switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 


  {
#line 1190
  if ((unsigned long )yy_current_buffer == (unsigned long )new_buffer) {
#line 1191
    return;
  }
#line 1193
  if (yy_current_buffer) {
#line 1196
    *yy_c_buf_p = yy_hold_char;
#line 1197
    yy_current_buffer->yy_buf_pos = yy_c_buf_p;
#line 1198
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
  {
#line 1201
  yy_current_buffer = new_buffer;
#line 1202
  ifparser__load_buffer_state();
#line 1209
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1210
  return;
}
}
#line 1214 "ifparser.lex.c"
void ifparser__load_buffer_state(void) 
{ 


  {
#line 1219
  yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1220
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
#line 1220
  ifparser_text = yy_c_buf_p;
#line 1221
  ifparser_in = yy_current_buffer->yy_input_file;
#line 1222
  yy_hold_char = *yy_c_buf_p;
#line 1223
  return;
}
}
#line 1227 "ifparser.lex.c"
YY_BUFFER_STATE ifparser__create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1236
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1236
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1237
  if (! b) {
    {
#line 1238
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1240
  b->yy_buf_size = (yy_size_t )size;
#line 1245
  tmp___0 = yy_flex_alloc(b->yy_buf_size + 2U);
#line 1245
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1246
  if (! b->yy_ch_buf) {
    {
#line 1247
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1249
  b->yy_is_our_buffer = 1;
#line 1251
  ifparser__init_buffer(b, file);
  }
#line 1253
  return (b);
}
}
#line 1258 "ifparser.lex.c"
void ifparser__delete_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1264
  if (! b) {
#line 1265
    return;
  }
#line 1267
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
#line 1268
    yy_current_buffer = (YY_BUFFER_STATE )0;
  }
#line 1270
  if (b->yy_is_our_buffer) {
    {
#line 1271
    yy_flex_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1273
  yy_flex_free((void *)b);
  }
#line 1274
  return;
}
}
#line 1284 "ifparser.lex.c"
void ifparser__init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1293
  ifparser__flush_buffer(b);
#line 1295
  b->yy_input_file = file;
#line 1296
  b->yy_fill_buffer = 1;
  }
#line 1304
  if (file) {
    {
#line 1304
    tmp = fileno(file);
#line 1304
    tmp___0 = isatty(tmp);
#line 1304
    b->yy_is_interactive = tmp___0 > 0;
    }
  } else {
#line 1304
    b->yy_is_interactive = 0;
  }
#line 1307
  return;
}
}
#line 1311 "ifparser.lex.c"
void ifparser__flush_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1318
  if (! b) {
#line 1319
    return;
  }
#line 1321
  b->yy_n_chars = 0;
#line 1327
  *(b->yy_ch_buf + 0) = (char)0;
#line 1328
  *(b->yy_ch_buf + 1) = (char)0;
#line 1330
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1332
  b->yy_at_bol = 1;
#line 1333
  b->yy_buffer_status = 0;
#line 1335
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
    {
#line 1336
    ifparser__load_buffer_state();
    }
  }
#line 1337
  return;
}
}
#line 1342 "ifparser.lex.c"
YY_BUFFER_STATE ifparser__scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1351
  if (size < 2U) {
#line 1355
    return ((YY_BUFFER_STATE )0);
  } else
#line 1351
  if ((int )*(base + (size - 2U)) != 0) {
#line 1355
    return ((YY_BUFFER_STATE )0);
  } else
#line 1351
  if ((int )*(base + (size - 1U)) != 0) {
#line 1355
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1357
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1357
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1358
  if (! b) {
    {
#line 1359
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1361
  b->yy_buf_size = size - 2U;
#line 1362
  tmp___0 = base;
#line 1362
  b->yy_ch_buf = tmp___0;
#line 1362
  b->yy_buf_pos = tmp___0;
#line 1363
  b->yy_is_our_buffer = 0;
#line 1364
  b->yy_input_file = (FILE *)0;
#line 1365
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1366
  b->yy_is_interactive = 0;
#line 1367
  b->yy_at_bol = 1;
#line 1368
  b->yy_fill_buffer = 0;
#line 1369
  b->yy_buffer_status = 0;
#line 1371
  ifparser__switch_to_buffer(b);
  }
#line 1373
  return (b);
}
}
#line 1380 "ifparser.lex.c"
YY_BUFFER_STATE ifparser__scan_string(char const   *yy_str ) 
{ 
  int len ;
  YY_BUFFER_STATE tmp ;

  {
#line 1387
  len = 0;
  {
#line 1387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    if (! *(yy_str + len)) {
#line 1387
      goto while_break;
    }
#line 1387
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1390
  tmp = ifparser__scan_bytes(yy_str, len);
  }
#line 1390
  return (tmp);
}
}
#line 1397 "ifparser.lex.c"
YY_BUFFER_STATE ifparser__scan_bytes(char const   *bytes , int len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i___0 ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1410
  n = (yy_size_t )(len + 2);
#line 1411
  tmp = yy_flex_alloc(n);
#line 1411
  buf = (char *)tmp;
  }
#line 1412
  if (! buf) {
    {
#line 1413
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1415
  i___0 = 0;
  {
#line 1415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1415
    if (! (i___0 < len)) {
#line 1415
      goto while_break;
    }
#line 1416
    *(buf + i___0) = (char )*(bytes + i___0);
#line 1415
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1418
  tmp___0 = (char)0;
#line 1418
  *(buf + (len + 1)) = tmp___0;
#line 1418
  *(buf + len) = tmp___0;
#line 1420
  b = ifparser__scan_buffer(buf, n);
  }
#line 1421
  if (! b) {
    {
#line 1422
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1427
  b->yy_is_our_buffer = 1;
#line 1429
  return (b);
}
}
#line 1491 "ifparser.lex.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 1497
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1498
  exit(2);
  }
}
}
#line 1555 "ifparser.lex.c"
static void *yy_flex_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1561
  tmp = malloc((size_t )size);
  }
#line 1561
  return (tmp);
}
}
#line 1565 "ifparser.lex.c"
static void *yy_flex_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1579
  tmp = realloc((void *)((char *)ptr), (size_t )size);
  }
#line 1579
  return (tmp);
}
}
#line 1583 "ifparser.lex.c"
static void yy_flex_free(void *ptr ) 
{ 


  {
  {
#line 1589
  free(ptr);
  }
#line 1590
  return;
}
}
#line 46 "ifparser.l"
void ifparser_init(char *str ) 
{ 
  size_t tmp ;

  {
  {
#line 49
  inputstr = str;
#line 50
  inputstrcur = 0;
#line 51
  tmp = strlen((char const   *)str);
#line 51
  inputstrlen = (int )tmp;
  }
#line 52
  return;
}
}
#line 54 "ifparser.l"
static int ifparser_input(char *buf , int max_size ) 
{ 
  int count ;

  {
#line 59
  count = inputstrlen - inputstrcur;
#line 60
  if (count > max_size) {
#line 61
    count = max_size;
  }
#line 63
  if (count == 0) {
#line 64
    return (0);
  }
  {
#line 66
  memcpy((void */* __restrict  */)((void *)buf), (void const   */* __restrict  */)((void *)(inputstr + inputstrcur)),
         (size_t )count);
#line 67
  inputstrcur += count;
  }
#line 68
  return (count);
}
}
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 376 "/usr/include/unistd.h"
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 770
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 261 "/usr/include/pthread.h"
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 168 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , union wait *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static char *mylock  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static char *job  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static char *id___0  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static char *jid  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static time_t start  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static struct passwd *pw  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static void remove_lock(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 53
  if ((unsigned long )mylock != (unsigned long )((void *)0)) {
    {
#line 55
    tmp___1 = unlink((char const   *)mylock);
    }
#line 55
    if (tmp___1 != 0) {
      {
#line 56
      tmp = __errno_location();
#line 56
      tmp___0 = strerror(*tmp);
#line 56
      error((char *)"Failed to remove lock file (%s): %s", mylock, tmp___0);
      }
    }
    {
#line 57
    free((void *)mylock);
#line 58
    mylock = (char *)((void *)0);
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static int copyslog  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static int copyout  ;
#line 64
static void ( /* format attribute */  log)(int level , char *format  , ...) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static void ( /* format attribute */  log)(int level , char *format  , ...) 
{ 
  va_list va ;

  {
  {
#line 75
  __builtin_va_start(va, format);
  }
#line 76
  if (copyslog) {
    {
#line 77
    vsyslog(level, (char const   *)format, va);
    }
  }
#line 78
  if (copyout) {
    {
#line 79
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
             va);
    }
  }
  {
#line 80
  __builtin_va_end(va);
  }
#line 81
  if (copyout) {
    {
#line 82
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
    }
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static void sighandler(int sig ) 
{ 
  char *tmp ;

  {
  {
#line 88
  tmp = getsignamebynum(sig);
#line 88
  log(6, (char *)"%s: Caught SIG%s (%d)", jid, tmp, sig);
  }
#line 89
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static char timestr___1[256]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static char *mystrftime___0(char *format , time_t when___1 ) 
{ 
  struct tm *tm ;
  size_t tmp ;

  {
  {
#line 97
  tm = localtime((time_t const   *)(& when___1));
#line 98
  tmp = strftime((char */* __restrict  */)(timestr___1), (size_t )256, (char const   */* __restrict  */)format,
                 (struct tm  const  */* __restrict  */)tm);
  }
#line 98
  if (tmp == 0UL) {
#line 99
    timestr___1[255] = (char )'\000';
  }
#line 100
  return (timestr___1);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static void myputenv(char *var , char *val ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 108
  tmp___0 = strlen((char const   *)var);
#line 108
  tmp___1 = strlen((char const   *)val);
#line 108
  tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 108
  tmp = (char *)tmp___2;
  }
#line 109
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 111
    tmp___3 = __errno_location();
#line 111
    tmp___4 = strerror(*tmp___3);
#line 111
    error((char *)"malloc() failed: %s", tmp___4);
#line 112
    exit(1);
    }
  }
  {
#line 114
  sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)"%s=%s",
          var, val);
#line 115
  tmp___7 = putenv(tmp);
  }
#line 115
  if (tmp___7 != 0) {
    {
#line 117
    tmp___5 = __errno_location();
#line 117
    tmp___6 = strerror(*tmp___5);
#line 117
    error((char *)"putenv(%s) failed: %s", tmp, tmp___6);
#line 118
    exit(1);
    }
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static int mailsubject(FILE *stream , int cf ) 
{ 
  char *format ;
  int err___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char const   *tmp___5 ;
  long tmp___6 ;
  char const   *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  char *tmp___10 ;
  long tmp___11 ;
  char const   *tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  time_t tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  __uid_t tmp___24 ;
  char *tmp___25 ;
  unsigned short const   **tmp___26 ;

  {
#line 126
  err___0 = 1;
#line 128
  if (! ((unsigned long )stream != (unsigned long )((void *)0))) {
    {
#line 128
    myassert((char *)"stream != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
             (char *)((void *)0), 128);
    }
  }
#line 129
  if (! (cf == 26)) {
#line 129
    if (! (cf == 17)) {
#line 129
      if (! (cf < 0)) {
        {
#line 129
        myassert((char *)"cf == CF_TIMEOUTSUBJECT || cf == CF_LOCKSUBJECT || cf < 0",
                 (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
                 (char *)((void *)0), 129);
        }
      }
    }
  }
#line 131
  if (cf < 0) {
    {
#line 134
    format = cf_getrptstr(- cf, 4);
    }
#line 135
    if ((unsigned long )format == (unsigned long )((void *)0)) {
#line 136
      return (err___0);
    }
    {
#line 137
    tmp___17 = strchr((char const   *)format, '%');
    }
#line 137
    if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
      {
#line 140
      tmp___2 = cf_getrptnum(- cf, 6);
      }
#line 140
      if (tmp___2 != 0L) {
#line 140
        tmp___1 = "[";
      } else {
        {
#line 140
        tmp___3 = cf_getrptnum(- cf, 5);
        }
#line 140
        if (tmp___3 != 0L) {
#line 140
          tmp___1 = "[";
        } else {
#line 140
          tmp___1 = "";
        }
      }
      {
#line 140
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Subject: %s",
                        tmp___1);
      }
#line 143
      if (err___0 > 0) {
        {
#line 143
        tmp___8 = cf_getrptnum(- cf, 5);
        }
#line 143
        if (tmp___8 != 0L) {
          {
#line 144
          tmp___6 = cf_getrptnum(- cf, 6);
          }
#line 144
          if (tmp___6 != 0L) {
#line 144
            tmp___5 = "@";
          } else {
#line 144
            tmp___5 = "";
          }
#line 144
          if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 144
            if ((unsigned long )pw->pw_name != (unsigned long )((void *)0)) {
#line 144
              tmp___7 = (char const   *)pw->pw_name;
            } else {
#line 144
              tmp___7 = "?";
            }
          } else {
#line 144
            tmp___7 = "?";
          }
          {
#line 144
          err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s%s",
                            tmp___7, tmp___5);
          }
        }
      }
#line 148
      if (err___0 > 0) {
        {
#line 148
        tmp___11 = cf_getrptnum(- cf, 6);
        }
#line 148
        if (tmp___11 != 0L) {
          {
#line 149
          tmp___9 = cf_getrptnum(- cf, 6);
#line 149
          tmp___10 = get_hostname((int )tmp___9);
#line 149
          err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                            tmp___10);
          }
        }
      }
#line 151
      if (err___0 > 0) {
        {
#line 152
        tmp___15 = cf_getrptnum(- cf, 6);
        }
#line 152
        if (tmp___15 != 0L) {
#line 152
          tmp___14 = "] ";
        } else {
          {
#line 152
          tmp___16 = cf_getrptnum(- cf, 5);
          }
#line 152
          if (tmp___16 != 0L) {
#line 152
            tmp___14 = "] ";
          } else {
#line 152
            tmp___14 = "";
          }
        }
        {
#line 152
        err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s%s\n",
                          tmp___14, format);
        }
      }
#line 156
      return (err___0);
    }
  } else {
    {
#line 160
    format = cf_getstr(cf);
    }
  }
#line 162
  if (! ((unsigned long )format != (unsigned long )((void *)0))) {
    {
#line 162
    myassert((char *)"format != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
             (char *)((void *)0), 162);
    }
  }
  {
#line 164
  err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Subject: ");
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (err___0 > 0) {
#line 165
      if (! ((int )*format != 0)) {
#line 165
        goto while_break;
      }
    } else {
#line 165
      goto while_break;
    }
#line 167
    if ((int )*format != 37) {
      {
#line 168
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%c",
                        (int )*format);
      }
    } else {
#line 171
      format ++;
      {
#line 174
      if ((int )*format == 37) {
#line 174
        goto case_37;
      }
#line 177
      if ((int )*format == 0) {
#line 177
        goto case_0;
      }
#line 179
      if ((int )*format == 57) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 56) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 55) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 54) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 53) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 52) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 51) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 50) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 49) {
#line 179
        goto case_57;
      }
#line 179
      if ((int )*format == 48) {
#line 179
        goto case_57;
      }
#line 182
      if ((int )*format == 104) {
#line 182
        goto case_104;
      }
#line 185
      if ((int )*format == 105) {
#line 185
        goto case_105;
      }
#line 188
      if ((int )*format == 110) {
#line 188
        goto case_110;
      }
#line 191
      if ((int )*format == 78) {
#line 191
        goto case_78;
      }
#line 194
      if ((int )*format == 114) {
#line 194
        goto case_114;
      }
#line 199
      if ((int )*format == 116) {
#line 199
        goto case_116;
      }
#line 203
      if ((int )*format == 117) {
#line 203
        goto case_117;
      }
#line 208
      if ((int )*format == 85) {
#line 208
        goto case_85;
      }
#line 211
      if ((int )*format == 45) {
#line 211
        goto case_45;
      }
#line 220
      goto switch_default;
      case_37: /* CIL Label */ 
      {
#line 175
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%");
      }
#line 176
      goto switch_break;
      case_0: /* CIL Label */ 
#line 177
      return (err___0);
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      {
#line 180
      tmp___18 = get_hostname((int )*format - 48);
#line 180
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                        tmp___18);
      }
#line 181
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 183
      tmp___19 = get_hostname(0);
#line 183
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                        tmp___19);
      }
#line 184
      goto switch_break;
      case_105: /* CIL Label */ 
#line 186
      if ((int )*id___0 != 0) {
        {
#line 186
        err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                          id___0);
        }
      }
#line 187
      goto switch_break;
      case_110: /* CIL Label */ 
      {
#line 189
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                        job);
      }
#line 190
      goto switch_break;
      case_78: /* CIL Label */ 
      {
#line 192
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                        jid);
      }
#line 193
      goto switch_break;
      case_114: /* CIL Label */ 
#line 195
      if (cf >= 0) {
#line 196
        goto switch_break;
      }
      {
#line 197
      tmp___20 = cf_getrptstr(- cf, 0);
#line 197
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                        tmp___20);
      }
#line 198
      goto switch_break;
      case_116: /* CIL Label */ 
      {
#line 200
      tmp___21 = time((time_t *)((void *)0));
#line 200
      tmp___22 = unit_rtime((u_int )(tmp___21 - start));
#line 200
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                        tmp___22);
      }
#line 202
      goto switch_break;
      case_117: /* CIL Label */ 
#line 204
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 204
        if ((unsigned long )pw->pw_name != (unsigned long )((void *)0)) {
#line 204
          tmp___23 = (char const   *)pw->pw_name;
        } else {
#line 204
          tmp___23 = "?";
        }
      } else {
#line 204
        tmp___23 = "?";
      }
      {
#line 204
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                        tmp___23);
      }
#line 207
      goto switch_break;
      case_85: /* CIL Label */ 
      {
#line 209
      tmp___24 = getuid();
#line 209
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%u",
                        tmp___24);
      }
#line 210
      goto switch_break;
      case_45: /* CIL Label */ 
#line 212
      if ((int )*(format + 1) != 0) {
        {
#line 212
        tmp___26 = __ctype_b_loc();
        }
#line 212
        if ((int const   )*(*tmp___26 + (int )*(format + 1)) & 2048) {
          {
#line 214
          tmp___25 = get_hostname(48 - (int )*(format + 1));
#line 214
          err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                            tmp___25);
#line 216
          format ++;
          }
#line 217
          goto switch_break;
        }
      }
      switch_default: /* CIL Label */ 
      {
#line 221
      err___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%c",
                        (int )*format);
      }
#line 222
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 225
    format ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  if (err___0 > 0) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n");
    }
  }
#line 230
  return (err___0);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static int tails[6]  ;
#line 236 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static void *tail(void *fdarray ) 
{ 
  int *fd___0 ;
  int nl ;
  int ptr ;
  int len ;
  char buffer[16384] ;
  time_t stop ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  time_t tmp___5 ;
  time_t tmp___6 ;
  char const   *tmp___8 ;
  int tmp___9 ;

  {
#line 243
  fd___0 = (int *)fdarray;
#line 244
  ptr = 0;
#line 244
  stop = (time_t )0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (stop == 0L)) {
#line 245
      if (ptr < *(fd___0 + 2)) {
        {
#line 245
        tmp___6 = time((time_t *)((void *)0));
        }
#line 245
        if (! (tmp___6 < stop)) {
#line 245
          goto while_break;
        }
      } else {
#line 245
        goto while_break;
      }
    }
    {
#line 247
    tmp = pread(*(fd___0 + 0), (void *)(buffer), (size_t )16384, (__off_t )ptr);
#line 247
    len = (int )tmp;
    }
#line 248
    if (len < 0) {
      {
#line 250
      tmp___0 = __errno_location();
#line 250
      tmp___1 = strerror(*tmp___0);
#line 250
      error((char *)"tail pread() failed: %s", tmp___1);
#line 251
      pthread_exit((void *)0);
      }
    }
#line 253
    nl = len;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! (nl > 0)) {
#line 254
        goto while_break___0;
      }
#line 256
      if ((int )buffer[nl - 1] == 10) {
#line 257
        goto while_break___0;
      }
#line 258
      nl --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    ptr += nl;
#line 261
    if (nl >= 0) {
      {
#line 261
      tmp___4 = write(*(fd___0 + 1), (void const   *)(buffer), (size_t )nl);
      }
#line 261
      if (tmp___4 != (ssize_t )nl) {
        {
#line 263
        tmp___2 = __errno_location();
#line 263
        tmp___3 = strerror(*tmp___2);
#line 263
        error((char *)"tail write(%d) failed: %s", *(fd___0 + 1), tmp___3);
#line 264
        pthread_exit((void *)0);
        }
      } else {
        {
#line 267
        sleep(1U);
        }
      }
    } else {
      {
#line 267
      sleep(1U);
      }
    }
#line 268
    if (*(fd___0 + 2) >= 0) {
#line 268
      if (stop == 0L) {
        {
#line 269
        tmp___5 = time((time_t *)((void *)0));
#line 269
        stop = tmp___5 + 5L;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  if (ptr < *(fd___0 + 2)) {
    {
#line 272
    tmp___9 = fileno(stdout);
    }
#line 272
    if (*(fd___0 + 1) == tmp___9) {
#line 272
      tmp___8 = "output";
    } else {
#line 272
      tmp___8 = "error";
    }
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Standard %s truncated (%d bytes out of %d).\n",
            jid, tmp___8, ptr, *(fd___0 + 2));
    }
  }
  {
#line 274
  pthread_exit((void *)0);
  }
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static void send_notification(int type , char *to , pid_t pid , int ptr ) 
{ 
  int mail[2] ;
  int err___0 ;
  int smstatus ;
  FILE *sm ;
  char *smv[4] ;
  pid_t sendmail ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  time_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  time_t tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char const   *tmp___30 ;
  union __anonunion_81 __constr_expr_23 ;
  char const   *tmp___31 ;
  union __anonunion_82 __constr_expr_24 ;
  union __anonunion_83 __constr_expr_25 ;
  union __anonunion_84 __constr_expr_26 ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  union __anonunion_85 __constr_expr_27 ;

  {
#line 288
  if (! (type == 1)) {
#line 288
    if (! (type == 2)) {
      {
#line 288
      myassert((char *)"type == SM_TIMEOUT || type == SM_LOCK", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
               (char *)((void *)0), 288);
      }
    }
  }
  {
#line 291
  tmp___2 = pipe((int *)(mail));
  }
#line 291
  if (tmp___2 != 0) {
    {
#line 293
    tmp = __errno_location();
#line 293
    tmp___0 = strerror(*tmp);
    }
#line 293
    if (type == 1) {
#line 293
      tmp___1 = "timeout";
    } else {
#line 293
      tmp___1 = "lock";
    }
    {
#line 293
    error((char *)"pipe() failed for %s notification to %s: %s", tmp___1, to, tmp___0);
    }
#line 295
    return;
  }
  {
#line 298
  sm = fdopen(mail[1], "w");
  }
#line 299
  if ((unsigned long )sm == (unsigned long )((void *)0)) {
    {
#line 301
    tmp___3 = __errno_location();
#line 301
    tmp___4 = strerror(*tmp___3);
    }
#line 301
    if (type == 1) {
#line 301
      tmp___5 = "timeout";
    } else {
#line 301
      tmp___5 = "lock";
    }
    {
#line 301
    error((char *)"fdopen() failed for %s notification to %s: %s", tmp___5, to, tmp___4);
#line 303
    close(mail[0]);
#line 304
    close(mail[1]);
    }
#line 305
    return;
  }
  {
#line 309
  smv[0] = cf_getstr(21);
#line 310
  smv[1] = (char *)"-t";
#line 311
  smv[2] = (char *)"-i";
#line 312
  smv[3] = (char *)((void *)0);
#line 313
  sendmail = exec(mail[0], 1, 2, 0, smv);
  }
#line 314
  if (sendmail < 0) {
#line 316
    if (type == 1) {
#line 316
      tmp___6 = "timeout";
    } else {
#line 316
      tmp___6 = "lock";
    }
    {
#line 316
    error((char *)"Failed to send %s notification to %s", tmp___6, to);
#line 318
    fclose(sm);
    }
#line 319
    return;
  }
  {
#line 323
  err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"To: %s\n",
                    to);
  }
#line 324
  if (type == 1) {
#line 326
    if (err___0 > 0) {
      {
#line 327
      mailsubject(sm, 26);
      }
    }
#line 328
    if (err___0 > 0) {
      {
#line 329
      tmp___7 = cf_getstr(25);
#line 329
      tmp___8 = cf_getstr(25);
#line 329
      tmp___9 = strlen((char const   *)tmp___8);
#line 329
      tmp___10 = cf_getstr(25);
#line 329
      tmp___11 = time((time_t *)((void *)0));
#line 329
      tmp___12 = unit_rtime((u_int )(tmp___11 - start));
#line 329
      tmp___13 = get_hostname(0);
#line 329
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"\n\"%s\" has timed out while running on host \"%s\".\nProcess %d has been running for %s.\n\nDefined timeout actions are: %s\nPending timeout actions are: %*s\n",
                        jid, tmp___13, pid, tmp___12, tmp___10, tmp___9, tmp___7 + ptr);
      }
    }
  } else
#line 331
  if (type == 2) {
#line 333
    if (err___0 > 0) {
      {
#line 334
      mailsubject(sm, 17);
      }
    }
#line 335
    if (err___0 > 0) {
      {
#line 336
      tmp___14 = cf_getstr(15);
#line 336
      tmp___15 = cf_getstr(15);
#line 336
      tmp___16 = strlen((char const   *)tmp___15);
#line 336
      tmp___17 = cf_getstr(15);
#line 336
      tmp___18 = get_hostname(0);
#line 336
      tmp___19 = time((time_t *)((void *)0));
#line 336
      tmp___20 = unit_rtime((u_int )(tmp___19 - start));
#line 336
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"\n\"%s\" has been trying to obtain its lock for %s while running on host \"%s\" (process id %d).\n\nDefined lock actions are: %s\nPending lock actions are: %*s\n",
                        jid, tmp___20, tmp___18, pid, tmp___17, tmp___16, tmp___14 + ptr);
      }
    }
  }
#line 339
  if (err___0 > 0) {
    {
#line 340
    err___0 = fflush(sm);
    }
  }
#line 341
  if (err___0 == -1) {
    {
#line 342
    tmp___21 = __errno_location();
#line 342
    tmp___22 = strerror(*tmp___21);
    }
#line 342
    if (type == 1) {
#line 342
      tmp___23 = "timeout";
    } else {
#line 342
      tmp___23 = "lock";
    }
    {
#line 342
    error((char *)"Error while writing mail for %s notification to \"%s\": %s", tmp___23,
          to, tmp___22);
    }
  }
  {
#line 344
  tmp___27 = fclose(sm);
  }
#line 344
  if (tmp___27 != 0) {
#line 344
    if (err___0 > 0) {
      {
#line 345
      tmp___24 = __errno_location();
#line 345
      tmp___25 = strerror(*tmp___24);
      }
#line 345
      if (type == 1) {
#line 345
        tmp___26 = "timeout";
      } else {
#line 345
        tmp___26 = "lock";
      }
      {
#line 345
      error((char *)"fclose([sendmail for %s notification]) failed: %s", tmp___26,
            tmp___25);
      }
    }
  }
  {
#line 353
  err___0 = waitpid(sendmail, & smstatus, 1);
  }
#line 354
  if (err___0 == -1) {
    {
#line 355
    tmp___28 = __errno_location();
#line 355
    tmp___29 = strerror(*tmp___28);
    }
#line 355
    if (type == 1) {
#line 355
      tmp___30 = "timeout";
    } else {
#line 355
      tmp___30 = "lock";
    }
    {
#line 355
    error((char *)"waitpid(%d[sendmail for %s notification]) failed: %s", sendmail,
          tmp___30, tmp___29);
    }
  }
#line 358
  if (err___0 == sendmail) {
#line 361
    __constr_expr_24.__in = smstatus;
#line 361
    if ((__constr_expr_24.__i & 127) == 0) {
#line 361
      __constr_expr_25.__in = smstatus;
#line 361
      if ((__constr_expr_25.__i & 65280) >> 8 != 0) {
#line 362
        __constr_expr_23.__in = smstatus;
#line 362
        if (type == 1) {
#line 362
          tmp___31 = "timeout";
        } else {
#line 362
          tmp___31 = "lock";
        }
        {
#line 362
        error((char *)"sendmail for %s notification returned: %d", tmp___31, (__constr_expr_23.__i & 65280) >> 8);
        }
      }
    }
#line 365
    __constr_expr_27.__in = smstatus;
#line 365
    if ((int )((signed char )((__constr_expr_27.__i & 127) + 1)) >> 1 > 0) {
      {
#line 366
      __constr_expr_26.__in = smstatus;
#line 366
      tmp___32 = strsignal(__constr_expr_26.__i & 127);
      }
#line 366
      if (type == 1) {
#line 366
        tmp___33 = "timeout";
      } else {
#line 366
        tmp___33 = "lock";
      }
      {
#line 366
      error((char *)"sendmail for %s notification died: %s", tmp___33, tmp___32);
      }
    }
  }
#line 370
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static pid_t lockedby  =    0;
#line 558 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static time_t when  =    (time_t )0;
#line 598 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
static time_t when___0  =    (time_t )0;
#line 372 "/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c"
void run(char *cfdir___0 , char *myjob , char *myid , char *slfac , int options ,
         char **envp ) 
{ 
  struct sigaction sa ;
  char fname[4096] ;
  char outlog[4096] ;
  char errlog[4096] ;
  char *outstr ;
  char *errstr ;
  char *action ;
  char *tmpstr ;
  char *last___0 ;
  char *loop ;
  char *argv[4] ;
  int outfd ;
  int errfd ;
  int err___0 ;
  int status ;
  int rpt ;
  pthread_t outthd ;
  pthread_t errthd ;
  size_t outlen ;
  size_t errlen ;
  time_t delay ;
  time_t end ;
  char *utimestr ;
  char *stimestr ;
  pid_t child ;
  struct rusage ru ;
  __uid_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  __uid_t tmp___8 ;
  char const   *tmp___9 ;
  __uid_t tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  __pid_t tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  long tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  unsigned int tmp___45 ;
  long tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  int *tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  int lockfd ;
  int *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int *tmp___65 ;
  char *tmp___66 ;
  int *tmp___67 ;
  char *locked ;
  size_t lockedlen ;
  int tmp___68 ;
  time_t tmp___69 ;
  time_t tmp___70 ;
  int tmp___71 ;
  long tmp___72 ;
  long tmp___73 ;
  long tmp___74 ;
  long tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int *tmp___78 ;
  char *tmp___79 ;
  time_t tmp___80 ;
  time_t tmp___81 ;
  int *tmp___82 ;
  char *tmp___83 ;
  int *tmp___84 ;
  int tmp___85 ;
  long tmp___86 ;
  time_t tmp___87 ;
  u_int tmp___88 ;
  __pid_t tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  unsigned short const   **tmp___94 ;
  char *tmp___95 ;
  time_t tmp___96 ;
  char mypid[16] ;
  __pid_t tmp___97 ;
  int *tmp___98 ;
  char *tmp___99 ;
  time_t tmp___100 ;
  char *tmp___101 ;
  size_t tmp___102 ;
  ssize_t tmp___103 ;
  size_t tmp___104 ;
  int *tmp___105 ;
  char *tmp___106 ;
  int *tmp___107 ;
  char *tmp___108 ;
  int tmp___109 ;
  char *tmp___111 ;
  char const   *tmp___112 ;
  char *tmp___113 ;
  int *tmp___114 ;
  char *tmp___115 ;
  char *tmp___116 ;
  char *tmp___118 ;
  char const   *tmp___119 ;
  char *tmp___120 ;
  int *tmp___121 ;
  char *tmp___122 ;
  char *tmp___123 ;
  long tmp___124 ;
  char *tmp___125 ;
  char *tmp___126 ;
  int *tmp___127 ;
  char *tmp___128 ;
  char *tmp___129 ;
  u_int tmp___130 ;
  union __anonunion_86 __constr_expr_28 ;
  union __anonunion_87 __constr_expr_29 ;
  int *tmp___131 ;
  char *tmp___132 ;
  int *tmp___133 ;
  char *tmp___134 ;
  int *tmp___135 ;
  time_t tmp___136 ;
  char *tmp___137 ;
  char *tmp___138 ;
  time_t tmp___139 ;
  u_int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int *tmp___143 ;
  char *tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int *tmp___148 ;
  char *tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int *tmp___154 ;
  char *tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int *tmp___159 ;
  char *tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  unsigned short const   **tmp___166 ;
  int tmp___167 ;
  unsigned short const   **tmp___168 ;
  unsigned short const   **tmp___169 ;
  time_t tmp___170 ;
  char *tmp___171 ;
  int *tmp___172 ;
  char *tmp___173 ;
  char *tmp___174 ;
  char *tmp___175 ;
  int *tmp___176 ;
  char *tmp___177 ;
  char *tmp___178 ;
  union __anonunion_88 __constr_expr_30 ;
  char *tmp___179 ;
  union __anonunion_89 __constr_expr_31 ;
  union __anonunion_90 __constr_expr_32 ;
  union __anonunion_91 __constr_expr_33 ;
  char *tmp___180 ;
  char *tmp___181 ;
  union __anonunion_92 __constr_expr_34 ;
  char *tmp___182 ;
  union __anonunion_93 __constr_expr_35 ;
  union __anonunion_94 __constr_expr_36 ;
  union __anonunion_95 __constr_expr_37 ;
  int tmp___183 ;
  int tmp___184 ;
  long outlines ;
  long errlines ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;
  int mail[2] ;
  int smstatus ;
  int env ;
  FILE *sm ;
  char *header ;
  char *tmp___188 ;
  char *tmp___189 ;
  char *tmp___190 ;
  char *tmp___191 ;
  char *tmp___192 ;
  char *tmp___193 ;
  char *tmp___194 ;
  int *tmp___195 ;
  char *tmp___196 ;
  char *tmp___197 ;
  int tmp___198 ;
  int *tmp___199 ;
  char *tmp___200 ;
  char *tmp___201 ;
  char *tmp___202 ;
  char *tmp___203 ;
  char *tmp___204 ;
  char *tmp___205 ;
  char *tmp___206 ;
  char *tmp___207 ;
  char *tmp___208 ;
  char *tmp___209 ;
  char *tmp___210 ;
  char *tmp___211 ;
  char *tmp___212 ;
  char *tmp___213 ;
  int tmp___214 ;
  char *tmp___215 ;
  char *tmp___216 ;
  char *tmp___217 ;
  char *tmp___218 ;
  __uid_t tmp___219 ;
  char const   *tmp___220 ;
  char *tmp___221 ;
  char *tmp___222 ;
  union __anonunion_96 __constr_expr_38 ;
  union __anonunion_97 __constr_expr_39 ;
  union __anonunion_98 __constr_expr_40 ;
  char *tmp___223 ;
  union __anonunion_99 __constr_expr_41 ;
  long lines ;
  int tmp___224 ;
  long lines___0 ;
  int tmp___225 ;
  char *tmp___226 ;
  long tmp___227 ;
  long tmp___228 ;
  int *tmp___229 ;
  char *tmp___230 ;
  char *tmp___231 ;
  char *tmp___232 ;
  long tmp___233 ;
  long tmp___234 ;
  long tmp___235 ;
  int tmp___236 ;
  int *tmp___237 ;
  char *tmp___238 ;
  char *tmp___239 ;
  int tmp___240 ;
  union __anonunion_100 __constr_expr_42 ;
  union __anonunion_101 __constr_expr_43 ;
  int *tmp___241 ;
  char *tmp___242 ;
  int *tmp___243 ;
  char *tmp___244 ;
  char *tmp___245 ;
  int *tmp___246 ;
  union __anonunion_102 __constr_expr_44 ;
  char *tmp___247 ;
  union __anonunion_103 __constr_expr_45 ;
  union __anonunion_104 __constr_expr_46 ;
  union __anonunion_105 __constr_expr_47 ;
  char *tmp___248 ;
  char *tmp___249 ;
  union __anonunion_106 __constr_expr_48 ;
  int tmp___250 ;
  int *tmp___251 ;
  char *tmp___252 ;
  int tmp___253 ;
  int *tmp___254 ;
  char *tmp___255 ;
  long tmp___256 ;
  int tmp___257 ;
  char *tmp___258 ;
  char *tmp___259 ;

  {
#line 389
  if (! ((unsigned long )cfdir___0 != (unsigned long )((void *)0))) {
    {
#line 389
    myassert((char *)"cfdir != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
             (char *)((void *)0), 389);
    }
  }
#line 390
  if (! ((unsigned long )myjob != (unsigned long )((void *)0))) {
    {
#line 390
    myassert((char *)"myjob != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
             (char *)((void *)0), 390);
    }
  }
#line 391
  if (! ((unsigned long )myid != (unsigned long )((void *)0))) {
    {
#line 391
    myassert((char *)"myid != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
             (char *)((void *)0), 391);
    }
  }
#line 392
  if (! ((unsigned long )slfac != (unsigned long )((void *)0))) {
    {
#line 392
    myassert((char *)"slfac != NULL", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
             (char *)((void *)0), 392);
    }
  }
  {
#line 394
  tmp = getuid();
#line 394
  pw = getpwuid(tmp);
#line 396
  copyout = (options & 4) != 0;
#line 397
  job = myjob;
#line 398
  id___0 = myid;
#line 399
  tmp___0 = strlen((char const   *)job);
#line 399
  tmp___1 = strlen((char const   *)myid);
#line 399
  tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 399
  jid = (char *)tmp___2;
  }
#line 400
  if ((unsigned long )jid == (unsigned long )((void *)0)) {
    {
#line 402
    tmp___3 = __errno_location();
#line 402
    tmp___4 = strerror(*tmp___3);
#line 402
    error((char *)"malloc() failed: %s", tmp___4);
#line 403
    exit(1);
    }
  }
#line 405
  if ((int )*(myid + 0) != 0) {
    {
#line 406
    sprintf((char */* __restrict  */)jid, (char const   */* __restrict  */)"%s[%s]",
            job, myid);
    }
  } else {
    {
#line 408
    strcpy((char */* __restrict  */)jid, (char const   */* __restrict  */)job);
    }
  }
#line 409
  if ((int )*(slfac + 0) != 0) {
    {
#line 411
    tmp___5 = syslog_facility(slfac);
#line 411
    openlog((char const   *)myname, 1, tmp___5);
#line 412
    copyslog = 1;
#line 413
    tmp___12 = fileno(stdin);
#line 413
    tmp___13 = ttyname(tmp___12);
    }
#line 413
    if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
      {
#line 415
      tmp___6 = fileno(stdin);
#line 415
      tmp___7 = ttyname(tmp___6);
#line 415
      tmp___8 = getuid();
      }
#line 415
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 415
        if ((unsigned long )pw->pw_name != (unsigned long )((void *)0)) {
#line 415
          tmp___9 = (char const   *)pw->pw_name;
        } else {
#line 415
          tmp___9 = "?";
        }
      } else {
#line 415
        tmp___9 = "?";
      }
      {
#line 415
      log(6, (char *)"Running \"%s\" as %s [%u] on %s (version %s)", jid, tmp___9,
          tmp___8, tmp___7, "1.0");
#line 418
      variable_set((char *)"tty", 1L);
      }
    } else {
      {
#line 422
      tmp___10 = getuid();
      }
#line 422
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 422
        if ((unsigned long )pw->pw_name != (unsigned long )((void *)0)) {
#line 422
          tmp___11 = (char const   *)pw->pw_name;
        } else {
#line 422
          tmp___11 = "?";
        }
      } else {
#line 422
        tmp___11 = "?";
      }
      {
#line 422
      log(6, (char *)"Running \"%s\" as %s [%u] (version %s)", jid, tmp___11, tmp___10,
          "1.0");
#line 425
      variable_set((char *)"tty", 0L);
      }
    }
  }
  {
#line 430
  sigemptyset(& sa.sa_mask);
#line 431
  sa.sa_flags = 0;
#line 432
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 433
  tmp___16 = sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 433
  if (tmp___16 != 0) {
    {
#line 434
    tmp___14 = __errno_location();
#line 434
    tmp___15 = strerror(*tmp___14);
#line 434
    error((char *)"sigaction(SIGPIPE, SIG_IGN, NULL) failed: %s", tmp___15);
    }
  }
  {
#line 437
  snprintf((char */* __restrict  */)(fname), (size_t )4096, (char const   */* __restrict  */)"%s/%s",
           cfdir___0, job);
#line 438
  cf_load(fname, myid);
  }
#line 439
  if (! (cf_timestamp != 0L)) {
    {
#line 439
    myassert((char *)"cf_timestamp != 0", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
             (char *)((void *)0), 439);
    }
  }
  {
#line 440
  tmp___17 = mystrftime___0((char *)"%Y/%m/%d %H:%M:%S", cf_timestamp);
#line 440
  log(6, (char *)"%s: %s %ld %s", jid, tmp___17, cf_size, cf_md5);
#line 442
  tmp___18 = cf_getstr(24);
  }
#line 442
  if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
    {
#line 442
    tmp___19 = strcasecmp((char const   *)slfac, "cron");
    }
#line 442
    if (tmp___19 != 0) {
      {
#line 445
      error((char *)"Current and configuration syslog setting mismatch");
      }
    } else {
#line 442
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 442
    tmp___20 = cf_getstr(24);
    }
#line 442
    if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
      {
#line 442
      tmp___21 = cf_getstr(24);
#line 442
      tmp___22 = strcasecmp((char const   *)slfac, (char const   *)tmp___21);
      }
#line 442
      if (tmp___22 != 0) {
        {
#line 445
        error((char *)"Current and configuration syslog setting mismatch");
        }
      }
    }
  }
  {
#line 446
  tmp___23 = cf_getstr(14);
#line 446
  snprintf((char */* __restrict  */)(outlog), (size_t )4096, (char const   */* __restrict  */)"%s.stdout",
           tmp___23);
#line 447
  tmp___24 = cf_getstr(14);
#line 447
  snprintf((char */* __restrict  */)(errlog), (size_t )4096, (char const   */* __restrict  */)"%s.stderr",
           tmp___24);
#line 448
  tmp___25 = analyzer_init(outlog, errlog);
  }
#line 448
  if (tmp___25 == -1) {
    {
#line 449
    exit(1);
    }
  }
#line 450
  if (out_timestamp != 0L) {
    {
#line 451
    tmp___26 = mystrftime___0((char *)"%Y/%m/%d %H:%M:%S", out_timestamp);
#line 451
    log(6, (char *)"%s: stdout %s %ld %s", jid, tmp___26, out_size, out_md5);
    }
  }
#line 453
  if (err_timestamp != 0L) {
    {
#line 454
    tmp___27 = mystrftime___0((char *)"%Y/%m/%d %H:%M:%S", err_timestamp);
#line 454
    log(6, (char *)"%s: stderr %s %ld %s", jid, tmp___27, err_size, err_md5);
    }
  }
  {
#line 458
  state_init(cfdir___0, job);
#line 461
  tmp___46 = cf_getnum(19);
  }
#line 461
  if (tmp___46 > 0L) {
#line 463
    if ((options & 1) == 0) {
      {
#line 465
      tmp___28 = getpid();
#line 465
      srandom((unsigned int )tmp___28);
#line 466
      tmp___29 = random();
#line 466
      tmp___30 = cf_getnum(19);
#line 466
      delay = tmp___29 % tmp___30;
#line 467
      tmp___31 = cf_getnum(19);
#line 467
      debug(1, (char *)"Sleeping %lu (< %lu) seconds before starting...", delay, tmp___31);
#line 469
      state_delay(delay);
#line 470
      tmp___32 = unit_rtime((u_int )delay);
#line 470
      log(6, (char *)"%s: Delaying start by %s", jid, tmp___32);
#line 473
      sigemptyset(& sa.sa_mask);
#line 474
      sa.sa_flags = 0;
#line 475
      sa.__sigaction_handler.sa_handler = & sighandler;
#line 476
      tmp___35 = sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa),
                           (struct sigaction */* __restrict  */)((void *)0));
      }
#line 476
      if (tmp___35 != 0) {
        {
#line 477
        tmp___33 = __errno_location();
#line 477
        tmp___34 = strerror(*tmp___33);
#line 477
        error((char *)"sigaction(SIGHUP, handler, NULL) failed: %s", tmp___34);
        }
      }
      {
#line 478
      tmp___38 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa),
                           (struct sigaction */* __restrict  */)((void *)0));
      }
#line 478
      if (tmp___38 != 0) {
        {
#line 479
        tmp___36 = __errno_location();
#line 479
        tmp___37 = strerror(*tmp___36);
#line 479
        error((char *)"sigaction(SIGINT, handler, NULL) failed: %s", tmp___37);
        }
      }
      {
#line 480
      tmp___41 = sigaction(3, (struct sigaction  const  */* __restrict  */)(& sa),
                           (struct sigaction */* __restrict  */)((void *)0));
      }
#line 480
      if (tmp___41 != 0) {
        {
#line 481
        tmp___39 = __errno_location();
#line 481
        tmp___40 = strerror(*tmp___39);
#line 481
        error((char *)"sigaction(SIGQUIT, handler, NULL) failed: %s", tmp___40);
        }
      }
      {
#line 482
      tmp___44 = sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa),
                           (struct sigaction */* __restrict  */)((void *)0));
      }
#line 482
      if (tmp___44 != 0) {
        {
#line 483
        tmp___42 = __errno_location();
#line 483
        tmp___43 = strerror(*tmp___42);
#line 483
        error((char *)"sigaction(SIGTERM, handler, NULL) failed: %s", tmp___43);
        }
      }
      {
#line 485
      tmp___45 = sleep((unsigned int )delay);
      }
#line 485
      if (tmp___45 != 0U) {
        {
#line 487
        debug(1, (char *)"Sleep interrupted, aborting.");
#line 488
        log(6, (char *)"%s: Sleep interrupted, aborting", jid);
#line 489
        state_close((char *)"Aborted: sleep interrupted");
#line 490
        exit(0);
        }
      }
    } else {
      {
#line 495
      debug(1, (char *)"\"randomdelay\" option disabled by user");
#line 496
      log(6, (char *)"%s: \"randomdelay\" option disabled by user", jid);
      }
    }
  }
  {
#line 501
  sigemptyset(& sa.sa_mask);
#line 502
  sa.sa_flags = 268435456;
#line 503
  sa.__sigaction_handler.sa_handler = & sighandler;
#line 504
  tmp___49 = sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 504
  if (tmp___49 != 0) {
    {
#line 505
    tmp___47 = __errno_location();
#line 505
    tmp___48 = strerror(*tmp___47);
#line 505
    error((char *)"sigaction(SIGHUP, SA_RESTART, NULL) failed: %s", tmp___48);
    }
  }
  {
#line 506
  tmp___52 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 506
  if (tmp___52 != 0) {
    {
#line 507
    tmp___50 = __errno_location();
#line 507
    tmp___51 = strerror(*tmp___50);
#line 507
    error((char *)"sigaction(SIGINT, SA_RESTART, NULL) failed: %s", tmp___51);
    }
  }
  {
#line 508
  tmp___55 = sigaction(3, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 508
  if (tmp___55 != 0) {
    {
#line 509
    tmp___53 = __errno_location();
#line 509
    tmp___54 = strerror(*tmp___53);
#line 509
    error((char *)"sigaction(SIGQUIT, SA_RESTART, NULL) failed: %s", tmp___54);
    }
  }
  {
#line 510
  tmp___58 = sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 510
  if (tmp___58 != 0) {
    {
#line 511
    tmp___56 = __errno_location();
#line 511
    tmp___57 = strerror(*tmp___56);
#line 511
    error((char *)"sigaction(SIGTERM, SA_RESTART, NULL) failed: %s", tmp___57);
    }
  }
  {
#line 514
  tmpstr = cf_getstr(15);
  }
#line 515
  if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
    {
#line 519
    tmpstr = strdup((char const   *)tmpstr);
    }
#line 520
    if ((unsigned long )tmpstr == (unsigned long )((void *)0)) {
      {
#line 522
      tmp___59 = __errno_location();
#line 522
      tmp___60 = strerror(*tmp___59);
#line 522
      tmp___61 = cf_getstr(15);
#line 522
      error((char *)"strdup(%s) failed: %s", tmp___61, tmp___60);
#line 523
      exit(1);
      }
    }
    {
#line 525
    action = strtok_r((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)",",
                      (char **/* __restrict  */)(& last___0));
#line 525
    loop = (char *)((void *)0);
#line 526
    tmp___64 = cf_getstr(16);
    }
#line 526
    if ((unsigned long )tmp___64 == (unsigned long )((void *)0)) {
      {
#line 527
      tmp___62 = get_hostname(0);
#line 527
      snprintf((char */* __restrict  */)(fname), (size_t )4096, (char const   */* __restrict  */)"%s/.%s-%s",
               cfdir___0, jid, tmp___62);
      }
    } else {
      {
#line 529
      tmp___63 = cf_getstr(16);
#line 529
      strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)tmp___63);
      }
    }
    {
#line 530
    start = time((time_t *)((void *)0));
#line 531
    end = (time_t )0;
    }
    {
#line 532
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 532
      lockfd = open((char const   *)(fname), 193, 292);
      }
#line 532
      if (! (lockfd < 0)) {
#line 532
        goto while_break;
      }
      {
#line 536
      tmp___67 = __errno_location();
      }
#line 536
      if (*tmp___67 != 17) {
        {
#line 538
        tmp___65 = __errno_location();
#line 538
        tmp___66 = strerror(*tmp___65);
#line 538
        error((char *)"Failed to create lock file (%s): %s", fname, tmp___66);
#line 539
        state_close((char *)"Aborted: fatal lock creation failure");
#line 540
        exit(1);
        }
      }
      {
#line 543
      lockfd = open((char const   *)(fname), 0, 0);
      }
#line 544
      if (lockfd >= 0) {
        {
#line 549
        tmp___68 = mapfile(fname, lockfd, (void **)(& locked), & lockedlen);
        }
#line 549
        if (tmp___68 != 0) {
          {
#line 551
          state_close((char *)"Aborted: fatal lock access failure");
#line 552
          exit(1);
          }
        }
#line 554
        if (lockedlen > 0UL) {
#line 555
          *(locked + (lockedlen - 1UL)) = (char )'\000';
        }
#line 556
        if (lockedlen == 0UL) {
#line 556
          goto _L___0;
        } else {
          {
#line 556
          tmp___86 = atol((char const   *)locked);
          }
#line 556
          if (tmp___86 == 0L) {
            _L___0: /* CIL Label */ 
            {
#line 560
            tmp___70 = time((time_t *)((void *)0));
            }
#line 560
            if (tmp___70 > when) {
              {
#line 562
              log(4, (char *)"%s: lock file %s exists but contains no PID.", jid,
                  fname);
#line 565
              tmp___69 = time((time_t *)((void *)0));
#line 565
              when = tmp___69 + 300L;
              }
            }
#line 568
            if (lockedlen > 0UL) {
              {
#line 569
              tmp___71 = unmapfile(fname, (void *)locked, lockedlen);
              }
#line 569
              if (tmp___71 != 0) {
                {
#line 571
                state_close((char *)"Aborted: fatal lock access failure");
#line 572
                exit(1);
                }
              }
            }
            {
#line 574
            close(lockfd);
            }
          } else {
#line 578
            if (lockedby == 0) {
              {
#line 579
              tmp___72 = atol((char const   *)locked);
#line 579
              log(6, (char *)"%s: lock is held by process id %ld", jid, tmp___72);
              }
            } else {
              {
#line 581
              tmp___74 = atol((char const   *)locked);
              }
#line 581
              if ((long )lockedby != tmp___74) {
                {
#line 582
                tmp___73 = atol((char const   *)locked);
#line 582
                log(6, (char *)"%s: lock is now held by process id %ld (was %ld)",
                    jid, tmp___73, (long )lockedby);
                }
              }
            }
            {
#line 585
            tmp___75 = atol((char const   *)locked);
#line 585
            lockedby = (pid_t )tmp___75;
#line 587
            tmp___76 = unmapfile(fname, (void *)locked, lockedlen);
            }
#line 587
            if (tmp___76 != 0) {
              {
#line 589
              state_close((char *)"Aborted: fatal lock access failure");
#line 590
              exit(1);
              }
            }
            {
#line 592
            close(lockfd);
#line 594
            tmp___85 = kill(lockedby, 0);
            }
#line 594
            if (tmp___85 == -1) {
              {
#line 596
              tmp___84 = __errno_location();
              }
#line 596
              if (*tmp___84 == 3) {
                {
#line 600
                log(4, (char *)"%s: Breaking apparently stale lock (%s) left by process id %ld",
                    jid, fname, (long )lockedby);
#line 601
                tmp___77 = unlink((char const   *)(fname));
                }
#line 601
                if (tmp___77 == 0) {
#line 602
                  goto while_continue;
                }
                {
#line 603
                tmp___81 = time((time_t *)((void *)0));
                }
#line 603
                if (tmp___81 > when___0) {
                  {
#line 605
                  tmp___78 = __errno_location();
#line 605
                  tmp___79 = strerror(*tmp___78);
#line 605
                  error((char *)"Failed to break stale lock (%s): %s", fname, tmp___79);
#line 607
                  tmp___80 = time((time_t *)((void *)0));
#line 607
                  when___0 = tmp___80 + 300L;
                  }
                }
              } else {
                {
#line 612
                tmp___82 = __errno_location();
#line 612
                tmp___83 = strerror(*tmp___82);
#line 612
                error((char *)"kill(%ld, 0) failed: %s", (long )lockedby, tmp___83);
#line 614
                state_close((char *)"Aborted: fatal lock check failure");
#line 615
                exit(1);
                }
              }
            }
          }
        }
      }
      {
#line 621
      tmp___96 = time((time_t *)((void *)0));
      }
#line 621
      if (tmp___96 > end) {
#line 621
        if ((unsigned long )action != (unsigned long )((void *)0)) {
          {
#line 624
          tmp___94 = __ctype_b_loc();
          }
#line 624
          if ((int const   )*(*tmp___94 + (int )*(action + 0)) & 2048) {
            {
#line 626
            tmp___87 = time((time_t *)((void *)0));
#line 626
            tmp___88 = unit_time(action);
#line 626
            end = tmp___87 + (time_t )tmp___88;
#line 627
            log(6, (char *)"%s: Will wait up to %s for lock", jid, action);
            }
          } else {
            {
#line 630
            tmp___93 = strcasecmp((char const   *)action, "abort");
            }
#line 630
            if (tmp___93 == 0) {
              {
#line 632
              log(6, (char *)"%s: Giving up.", jid);
#line 633
              state_locked(3);
#line 634
              state_close((char *)"");
#line 635
              exit(0);
              }
            } else {
              {
#line 637
              tmp___92 = strcasecmp((char const   *)action, "ignore");
              }
#line 637
              if (tmp___92 == 0) {
                {
#line 639
                log(4, (char *)"%s: Ignoring lock!", jid);
#line 640
                state_locked(2);
                }
#line 641
                goto while_break;
              } else {
                {
#line 643
                tmp___91 = strncmp((char const   *)action, "notify=", (size_t )7);
                }
#line 643
                if (tmp___91 == 0) {
                  {
#line 644
                  tmp___89 = getpid();
#line 644
                  send_notification(2, action + 7, tmp___89, (int )(action - tmpstr));
                  }
                } else {
                  {
#line 646
                  tmp___90 = strcmp((char const   *)action, "loop");
                  }
#line 646
                  if (tmp___90 == 0) {
#line 647
                    loop = last___0;
                  } else {
                    {
#line 649
                    error((char *)"Invalid \"lock\" action: %s", action);
                    }
                  }
                }
              }
            }
          }
          {
#line 650
          action = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                            (char **/* __restrict  */)(& last___0));
          }
#line 651
          if ((unsigned long )action == (unsigned long )((void *)0)) {
#line 653
            if ((unsigned long )loop == (unsigned long )((void *)0)) {
              {
#line 654
              log(6, (char *)"%s: Will keeping waiting for lock", jid);
              }
            } else {
              {
#line 658
              tmp___95 = cf_getstr(15);
#line 658
              strcpy((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)tmp___95);
#line 659
              last___0 = loop;
#line 660
              action = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                                (char **/* __restrict  */)(& last___0));
              }
            }
          }
        } else {
          {
#line 665
          sleep(1U);
          }
        }
      } else {
        {
#line 665
        sleep(1U);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 667
    if (lockfd >= 0) {
      {
#line 671
      state_locked(1);
#line 672
      tmp___97 = getpid();
#line 672
      sprintf((char */* __restrict  */)(mypid), (char const   */* __restrict  */)"%ld\n",
              (long )tmp___97);
#line 673
      tmp___102 = strlen((char const   *)(mypid));
#line 673
      tmp___103 = write(lockfd, (void const   *)(mypid), tmp___102 + 1UL);
#line 673
      tmp___104 = strlen((char const   *)(mypid));
      }
#line 673
      if ((size_t )tmp___103 != tmp___104 + 1UL) {
        {
#line 675
        tmp___98 = __errno_location();
#line 675
        tmp___99 = strerror(*tmp___98);
#line 675
        error((char *)"Failed to write process id in new lock file (%s): %s", fname,
              tmp___99);
        }
      } else {
        {
#line 679
        tmp___100 = time((time_t *)((void *)0));
#line 679
        tmp___101 = unit_rtime((u_int )(tmp___100 - start));
#line 679
        log(6, (char *)"%s: Created lock file (%s) after %s", jid, fname, tmp___101);
        }
      }
      {
#line 681
      close(lockfd);
#line 682
      mylock = strdup((char const   *)(fname));
      }
#line 683
      if ((unsigned long )mylock == (unsigned long )((void *)0)) {
        {
#line 685
        tmp___105 = __errno_location();
#line 685
        tmp___106 = strerror(*tmp___105);
#line 685
        error((char *)"strdup(%s) failed: %s", fname, tmp___106);
#line 686
        tmp___109 = unlink((char const   *)(fname));
        }
#line 686
        if (tmp___109 != 0) {
          {
#line 687
          tmp___107 = __errno_location();
#line 687
          tmp___108 = strerror(*tmp___107);
#line 687
          error((char *)"Failed to remove lock file: %s", tmp___108);
          }
        }
        {
#line 688
        exit(1);
        }
      }
      {
#line 690
      atexit(& remove_lock);
      }
    }
  }
  {
#line 693
  free((void *)tmpstr);
#line 696
  tmp___113 = getenv("TMPDIR");
  }
#line 696
  if ((unsigned long )tmp___113 != (unsigned long )((void *)0)) {
    {
#line 696
    tmp___111 = getenv("TMPDIR");
#line 696
    tmp___112 = (char const   *)tmp___111;
    }
  } else {
#line 696
    tmp___112 = "/tmp/";
  }
  {
#line 696
  snprintf((char */* __restrict  */)(outlog), (size_t )4096, (char const   */* __restrict  */)"%s/%s-%s.stdout.XXXXXX",
           tmp___112, myname, job);
#line 699
  outfd = mkstemp(outlog);
  }
#line 700
  if (outfd < 0) {
    {
#line 702
    tmp___114 = __errno_location();
#line 702
    tmp___115 = strerror(*tmp___114);
#line 702
    error((char *)"Failed to create temporary file: %s", tmp___115);
#line 703
    state_close((char *)"Aborted: temporary file failure");
#line 704
    exit(1);
    }
  } else
#line 707
  if ((options & 2) != 0) {
    {
#line 709
    tails[0] = outfd;
#line 709
    tails[1] = fileno(stdout);
#line 709
    tails[2] = -1;
#line 710
    status = pthread_create((pthread_t */* __restrict  */)(& outthd), (pthread_attr_t const   */* __restrict  */)((void *)0),
                            & tail, (void */* __restrict  */)((void *)(& tails[0])));
    }
#line 711
    if (status != 0) {
      {
#line 712
      tmp___116 = strerror(status);
#line 712
      error((char *)"Failed to create thread to tail standard output: %s", tmp___116);
      }
    }
  }
  {
#line 716
  tmp___124 = cf_getrptnum(0, 10);
  }
#line 716
  if (tmp___124 != 1L) {
    {
#line 718
    tmp___120 = getenv("TMPDIR");
    }
#line 718
    if ((unsigned long )tmp___120 != (unsigned long )((void *)0)) {
      {
#line 718
      tmp___118 = getenv("TMPDIR");
#line 718
      tmp___119 = (char const   *)tmp___118;
      }
    } else {
#line 718
      tmp___119 = "/tmp/";
    }
    {
#line 718
    snprintf((char */* __restrict  */)(errlog), (size_t )4096, (char const   */* __restrict  */)"%s/%s-%s.stderr.XXXXXX",
             tmp___119, myname, job);
#line 721
    errfd = mkstemp(errlog);
    }
#line 722
    if (errfd < 0) {
      {
#line 724
      tmp___121 = __errno_location();
#line 724
      tmp___122 = strerror(*tmp___121);
#line 724
      error((char *)"Failed to create temporary file: %s", tmp___122);
#line 725
      state_close((char *)"Aborted: temporary file failure");
#line 726
      exit(1);
      }
    } else
#line 729
    if ((options & 2) != 0) {
      {
#line 731
      tails[3] = errfd;
#line 731
      tails[4] = fileno(stderr);
#line 731
      tails[5] = -1;
#line 732
      status = pthread_create((pthread_t */* __restrict  */)(& errthd), (pthread_attr_t const   */* __restrict  */)((void *)0),
                              & tail, (void */* __restrict  */)((void *)(& tails[3])));
      }
#line 733
      if (status != 0) {
        {
#line 734
        tmp___123 = strerror(status);
#line 734
        error((char *)"Failed to create thread to tail standard error: %s", tmp___123);
        }
      }
    }
  } else {
#line 740
    errfd = outfd;
  }
  {
#line 743
  tmp___126 = cf_getstr(18);
  }
#line 743
  if ((unsigned long )tmp___126 != (unsigned long )((void *)0)) {
    {
#line 744
    tmp___125 = cf_getstr(18);
#line 744
    myputenv((char *)"PATH", tmp___125);
    }
  }
  {
#line 745
  myputenv((char *)"SHUSH_NAME", job);
#line 746
  myputenv((char *)"SHUSH_ID", myid);
#line 749
  start = time((time_t *)((void *)0));
#line 750
  tmpstr = cf_getstr(25);
#line 750
  last___0 = (char *)((void *)0);
#line 750
  loop = (char *)((void *)0);
  }
#line 751
  if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
    {
#line 753
    tmpstr = strdup((char const   *)tmpstr);
    }
#line 754
    if ((unsigned long )tmpstr == (unsigned long )((void *)0)) {
      {
#line 756
      tmp___127 = __errno_location();
#line 756
      tmp___128 = strerror(*tmp___127);
#line 756
      tmp___129 = cf_getstr(25);
#line 756
      error((char *)"strdup(%s) failed: %s", tmp___129, tmp___128);
#line 757
      exit(1);
      }
    }
    {
#line 759
    debug(1, (char *)"Initialized timeout: %s", tmpstr);
#line 760
    action = strtok_r((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)",",
                      (char **/* __restrict  */)(& last___0));
#line 761
    tmp___130 = unit_time(action);
#line 761
    end = start + (time_t )tmp___130;
    }
  } else {
#line 764
    end = (time_t )0;
  }
  {
#line 767
  argv[0] = cf_getstr(22);
#line 768
  argv[1] = (char *)"-c";
#line 769
  argv[2] = cf_getstr(13);
#line 770
  argv[3] = (char *)((void *)0);
#line 771
  child = exec(-1, outfd, errfd, 1, argv);
  }
#line 772
  if (child < 0) {
    {
#line 774
    state_close((char *)"Aborted: spawn failed");
#line 775
    exit(1);
    }
  }
  {
#line 777
  debug(1, (char *)"Spawned child process (pid %d), waiting..", child);
#line 778
  state_run();
  }
  {
#line 781
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 783
    err___0 = wait4(child, (union wait *)(& status), 1, & ru);
    }
#line 784
    if (err___0 == child) {
#line 784
      __constr_expr_28.__in = status;
#line 784
      if ((__constr_expr_28.__i & 127) == 0) {
#line 785
        goto while_break___0;
      } else {
#line 784
        __constr_expr_29.__in = status;
#line 784
        if ((int )((signed char )((__constr_expr_29.__i & 127) + 1)) >> 1 > 0) {
#line 785
          goto while_break___0;
        }
      }
    }
#line 786
    if (err___0 == -1) {
      {
#line 788
      tmp___135 = __errno_location();
      }
#line 788
      if (*tmp___135 == 4) {
        {
#line 789
        tmp___131 = __errno_location();
#line 789
        tmp___132 = strerror(*tmp___131);
#line 789
        debug(1, (char *)"wait4(%d): %s", child, tmp___132);
        }
      } else {
        {
#line 792
        tmp___133 = __errno_location();
#line 792
        tmp___134 = strerror(*tmp___133);
#line 792
        error((char *)"wait4(%d) failed: %s", child, tmp___134);
#line 793
        state_close((char *)"Aborted: fatal wait4() failure");
#line 794
        exit(1);
        }
      }
    }
#line 797
    if (end != 0L) {
      {
#line 797
      tmp___170 = time((time_t *)((void *)0));
      }
#line 797
      if (tmp___170 > end) {
        {
#line 799
        state_timeout();
#line 801
        tmp___136 = time((time_t *)((void *)0));
#line 801
        tmp___137 = unit_rtime((u_int )(tmp___136 - start));
#line 801
        debug(1, (char *)"Timeout expired, job has been running for %s", tmp___137);
#line 803
        action = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                          (char **/* __restrict  */)(& last___0));
        }
#line 804
        if ((unsigned long )action == (unsigned long )((void *)0)) {
#line 804
          if ((unsigned long )loop == (unsigned long )((void *)0)) {
#line 805
            end = (time_t )0;
          } else {
#line 804
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 808
          if ((unsigned long )action == (unsigned long )((void *)0)) {
            {
#line 810
            tmp___138 = cf_getstr(25);
#line 810
            strcpy((char */* __restrict  */)tmpstr, (char const   */* __restrict  */)tmp___138);
#line 811
            last___0 = loop;
#line 812
            action = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                              (char **/* __restrict  */)(& last___0));
            }
          }
          {
#line 814
          tmp___169 = __ctype_b_loc();
          }
#line 814
          if ((int const   )*(*tmp___169 + (int )*(action + 0)) & 2048) {
            {
#line 816
            tmp___139 = time((time_t *)((void *)0));
#line 816
            tmp___140 = unit_time(action);
#line 816
            end = tmp___139 + (time_t )tmp___140;
#line 817
            debug(1, (char *)"Armed new timeout: %s", action);
            }
          } else
#line 819
          if ((int )*(action + 0) == 45) {
            {
#line 819
            tmp___168 = __ctype_b_loc();
            }
#line 819
            if ((int const   )*(*tmp___168 + (int )*(action + 1)) & 2048) {
              {
#line 821
              tmp___141 = atoi((char const   *)(action + 1));
#line 821
              debug(1, (char *)"Sending signal %d to child process group", tmp___141);
#line 823
              state_killed();
#line 824
              tmp___146 = atoi((char const   *)(action + 1));
#line 824
              tmp___147 = kill(child * -1, tmp___146);
              }
#line 824
              if (tmp___147 == 0) {
                {
#line 825
                tmp___142 = atoi((char const   *)(action + 1));
#line 825
                log(6, (char *)"%s: Sent signal %d to child process group", jid, tmp___142);
                }
              } else {
                {
#line 829
                tmp___143 = __errno_location();
#line 829
                tmp___144 = strerror(*tmp___143);
#line 829
                tmp___145 = atoi((char const   *)(action + 1));
#line 829
                log(4, (char *)"%s: Failed to send signal %d to child process group: %s",
                    jid, tmp___145, tmp___144);
                }
              }
            } else {
#line 819
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
            {
#line 833
            tmp___167 = strncmp((char const   *)action, "SIG", (size_t )3);
            }
#line 833
            if (tmp___167 == 0) {
              {
#line 835
              debug(1, (char *)"Sending signal %s to child process group", action);
#line 837
              state_killed();
#line 838
              tmp___150 = getsignumbyname(action + 3);
#line 838
              tmp___151 = kill(child * -1, tmp___150);
              }
#line 838
              if (tmp___151 == 0) {
                {
#line 839
                log(6, (char *)"%s: Sent signal %s to child process group", jid, action);
                }
              } else {
                {
#line 843
                tmp___148 = __errno_location();
#line 843
                tmp___149 = strerror(*tmp___148);
#line 843
                log(4, (char *)"%s: Failed to send signal %s to child process group: %s",
                    jid, action, tmp___149);
                }
              }
            } else
#line 846
            if ((int )*(action + 0) == 61) {
              {
#line 846
              tmp___166 = __ctype_b_loc();
              }
#line 846
              if ((int const   )*(*tmp___166 + (int )*(action + 1)) & 2048) {
                {
#line 848
                tmp___152 = atoi((char const   *)(action + 1));
#line 848
                debug(1, (char *)"Sending signal %d to child", tmp___152);
#line 849
                state_killed();
#line 850
                tmp___157 = atoi((char const   *)(action + 1));
#line 850
                tmp___158 = kill(child, tmp___157);
                }
#line 850
                if (tmp___158 == 0) {
                  {
#line 851
                  tmp___153 = atoi((char const   *)(action + 1));
#line 851
                  log(6, (char *)"%s: Sent signal %d to child", jid, tmp___153);
                  }
                } else {
                  {
#line 854
                  tmp___154 = __errno_location();
#line 854
                  tmp___155 = strerror(*tmp___154);
#line 854
                  tmp___156 = atoi((char const   *)(action + 1));
#line 854
                  log(4, (char *)"%s: Failed to send signal %d to child: %s", jid,
                      tmp___156, tmp___155);
                  }
                }
              } else {
#line 846
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
#line 858
              tmp___165 = strncmp((char const   *)action, "=SIG", (size_t )4);
              }
#line 858
              if (tmp___165 == 0) {
                {
#line 860
                debug(1, (char *)"Sending signal %s to child", action);
#line 861
                state_killed();
#line 862
                tmp___161 = getsignumbyname(action + 4);
#line 862
                tmp___162 = kill(child, tmp___161);
                }
#line 862
                if (tmp___162 == 0) {
                  {
#line 863
                  log(6, (char *)"%s: Sent signal %s to child", jid, action);
                  }
                } else {
                  {
#line 866
                  tmp___159 = __errno_location();
#line 866
                  tmp___160 = strerror(*tmp___159);
#line 866
                  log(4, (char *)"%s: Failed to send signal %s to child: %s", jid,
                      action, tmp___160);
                  }
                }
              } else {
                {
#line 870
                tmp___164 = strncmp((char const   *)action, "notify=", (size_t )7);
                }
#line 870
                if (tmp___164 == 0) {
                  {
#line 872
                  debug(1, (char *)"Sending timeout notification to %s", action + 7);
#line 874
                  log(6, (char *)"%s: Sending timeout notification to %s", jid, action + 7);
#line 877
                  send_notification(1, action + 7, child, (int )(action - tmpstr));
                  }
                } else {
                  {
#line 880
                  tmp___163 = strcmp((char const   *)action, "loop");
                  }
#line 880
                  if (tmp___163 == 0) {
#line 881
                    loop = last___0;
                  } else {
                    {
#line 883
                    error((char *)"Invalid \"timeout\" action: %s", action);
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        {
#line 887
        sleep(1U);
        }
      }
    } else {
      {
#line 887
      sleep(1U);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 889
  end = time((time_t *)((void *)0));
#line 890
  state_close((char *)((void *)0));
#line 891
  free((void *)tmpstr);
#line 894
  remove_lock();
#line 895
  tmp___171 = unit_rtime((u_int )ru.ru_utime.tv_sec);
#line 895
  utimestr = strdup((char const   *)tmp___171);
  }
#line 896
  if ((unsigned long )utimestr == (unsigned long )((void *)0)) {
    {
#line 898
    tmp___172 = __errno_location();
#line 898
    tmp___173 = strerror(*tmp___172);
#line 898
    tmp___174 = unit_rtime((u_int )ru.ru_utime.tv_sec);
#line 898
    error((char *)"strdup(%s) failed: %s", tmp___174, tmp___173);
#line 899
    utimestr = (char *)"??";
    }
  }
  {
#line 901
  tmp___175 = unit_rtime((u_int )ru.ru_stime.tv_sec);
#line 901
  stimestr = strdup((char const   *)tmp___175);
  }
#line 902
  if ((unsigned long )stimestr == (unsigned long )((void *)0)) {
    {
#line 904
    tmp___176 = __errno_location();
#line 904
    tmp___177 = strerror(*tmp___176);
#line 904
    tmp___178 = unit_rtime((u_int )ru.ru_stime.tv_sec);
#line 904
    error((char *)"strdup(%s) failed: %s", tmp___178, tmp___177);
#line 905
    stimestr = (char *)"??";
    }
  }
#line 909
  __constr_expr_37.__in = status;
#line 909
  if ((__constr_expr_37.__i & 127) == 0) {
    {
#line 911
    __constr_expr_30.__in = status;
#line 911
    debug(1, (char *)"Normal termination, returned %d", (__constr_expr_30.__i & 65280) >> 8);
#line 912
    tmp___179 = unit_rtime((u_int )(end - start));
#line 912
    __constr_expr_31.__in = status;
#line 912
    log(6, (char *)"%s: Command returned %d after %s (%s user, %s sys)", jid, (__constr_expr_31.__i & 65280) >> 8,
        tmp___179, utimestr, stimestr);
#line 916
    __constr_expr_32.__in = status;
#line 916
    variable_set((char *)"exit", (long )((__constr_expr_32.__i & 65280) >> 8));
    }
  } else {
#line 918
    __constr_expr_36.__in = status;
#line 918
    if ((int )((signed char )((__constr_expr_36.__i & 127) + 1)) >> 1 > 0) {
      {
#line 920
      __constr_expr_33.__in = status;
#line 920
      tmp___180 = strsignal(__constr_expr_33.__i & 127);
#line 920
      debug(1, (char *)"Child died from a signal: %s", tmp___180);
#line 922
      tmp___181 = unit_rtime((u_int )(end - start));
#line 922
      __constr_expr_34.__in = status;
#line 922
      tmp___182 = strsignal(__constr_expr_34.__i & 127);
#line 922
      log(4, (char *)"%s: Command died form a signal (%s) after %s (%s user, %s sys)",
          jid, tmp___182, tmp___181, utimestr, stimestr);
#line 926
      __constr_expr_35.__in = status;
#line 926
      variable_set((char *)"exit", (long )(-1 * (__constr_expr_35.__i & 127)));
      }
    } else {
      {
#line 929
      myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
              (char *)((void *)0), 929);
      }
    }
  }
  {
#line 932
  tmp___183 = mapfile(outlog, outfd, (void **)(& outstr), & outlen);
  }
#line 932
  if (tmp___183 != 0) {
    {
#line 933
    exit(1);
    }
  }
#line 934
  if (errfd == outfd) {
#line 936
    errstr = (char *)((void *)0);
#line 937
    errlen = (size_t )0;
  } else {
    {
#line 939
    tmp___184 = mapfile(errlog, errfd, (void **)(& errstr), & errlen);
    }
#line 939
    if (tmp___184 != 0) {
      {
#line 940
      exit(1);
      }
    }
  }
  {
#line 943
  tails[2] = (int )outlen;
#line 943
  tails[5] = (int )errlen;
#line 946
  variable_set((char *)"size", (long )(outlen + errlen));
#line 947
  variable_set((char *)"outsize", (long )outlen);
#line 948
  variable_set((char *)"errsize", (long )errlen);
#line 949
  variable_set((char *)"runtime", end - start);
#line 950
  variable_set((char *)"utime", ru.ru_utime.tv_sec);
#line 951
  variable_set((char *)"stime", ru.ru_stime.tv_sec);
#line 954
  tmp___187 = analyzer_run(outstr, outlen, errstr, errlen);
  }
#line 954
  if (tmp___187 != 0) {
    {
#line 955
    exit(1);
    }
  } else {
    {
#line 960
    tmp___185 = variable_get((char *)"outlines", & outlines);
    }
#line 960
    if (tmp___185 != 0) {
      {
#line 961
      myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
              (char *)((void *)0), 961);
      }
    }
    {
#line 962
    tmp___186 = variable_get((char *)"errlines", & errlines);
    }
#line 962
    if (tmp___186 != 0) {
      {
#line 963
      myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
              (char *)((void *)0), 963);
      }
    }
    {
#line 964
    log(6, (char *)"%s: Command produced %ld lines (%ld Bytes) on stdout and %ld lines (%ld Bytes) on stderr",
        jid, outlines, outlen, errlines, errlen);
    }
  }
  {
#line 968
  debug(1, (char *)"Done with analysis.");
#line 971
  rpt = 0;
  }
  {
#line 972
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 972
    tmp___250 = cf_getrptcnt();
    }
#line 972
    if (! (rpt + 1 < tmp___250)) {
#line 972
      goto while_break___1;
    }
    {
#line 978
    rpt ++;
#line 981
    tmp___192 = cf_getrptstr(rpt, 8);
    }
#line 981
    if ((unsigned long )tmp___192 != (unsigned long )((void *)0)) {
      {
#line 983
      tmp___188 = cf_getrptstr(rpt, 8);
#line 983
      ifparser_init(tmp___188);
#line 984
      err___0 = ifparser_parse();
      }
#line 985
      if (err___0 != 0) {
        {
#line 986
        tmp___189 = cf_getrptstr(rpt, 0);
#line 986
        tmp___190 = cf_getrptstr(rpt, 8);
#line 986
        error((char *)"%s while evaluating \"%s\" for report \"%s\"", ifparser_errmsg,
              tmp___190, tmp___189);
        }
      }
#line 989
      if (err___0 == 0) {
#line 989
        if (! ifparser_result) {
          {
#line 991
          tmp___191 = cf_getrptstr(rpt, 0);
#line 991
          debug(1, (char *)"Skipping report \"%s\"", tmp___191);
          }
#line 993
          goto while_continue___1;
        }
      }
    }
    {
#line 996
    tmp___193 = cf_getrptstr(rpt, 0);
#line 996
    log(6, (char *)"%s: Sending \"%s\" report", jid, tmp___193);
#line 998
    tmp___194 = cf_getrptstr(rpt, 0);
#line 998
    debug(1, (char *)"Generating \"%s\" report...", tmp___194);
#line 1002
    tmp___198 = pipe((int *)(mail));
    }
#line 1002
    if (tmp___198 != 0) {
      {
#line 1004
      tmp___195 = __errno_location();
#line 1004
      tmp___196 = strerror(*tmp___195);
#line 1004
      tmp___197 = cf_getrptstr(rpt, 0);
#line 1004
      error((char *)"pipe() failed for report \"%s\": %s", tmp___197, tmp___196);
      }
#line 1006
      goto while_continue___1;
    }
    {
#line 1008
    sm = fdopen(mail[1], "w");
    }
#line 1009
    if ((unsigned long )sm == (unsigned long )((void *)0)) {
      {
#line 1011
      tmp___199 = __errno_location();
#line 1011
      tmp___200 = strerror(*tmp___199);
#line 1011
      tmp___201 = cf_getrptstr(rpt, 0);
#line 1011
      error((char *)"fdopen() failed for report \"%s\": %s", tmp___201, tmp___200);
#line 1013
      close(mail[0]);
#line 1014
      close(mail[1]);
      }
#line 1015
      goto while_continue___1;
    }
    {
#line 1019
    argv[0] = cf_getstr(21);
#line 1020
    argv[1] = (char *)"-t";
#line 1021
    argv[2] = (char *)"-i";
#line 1022
    argv[3] = (char *)((void *)0);
#line 1023
    child = exec(mail[0], 1, 2, 0, argv);
    }
#line 1024
    if (child < 0) {
      {
#line 1026
      tmp___202 = cf_getrptstr(rpt, 0);
#line 1026
      error((char *)"Failed to send report \"%s\"", tmp___202);
#line 1028
      fclose(sm);
      }
#line 1029
      goto while_continue___1;
    }
    {
#line 1033
    err___0 = 1;
#line 1034
    tmp___205 = cf_getrptstr(rpt, 1);
    }
#line 1034
    if ((unsigned long )tmp___205 != (unsigned long )((void *)0)) {
      {
#line 1036
      tmp___203 = cf_getrptstr(rpt, 1);
#line 1036
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"To: %s\n",
                        tmp___203);
#line 1037
      tmp___204 = cf_getrptstr(rpt, 1);
#line 1037
      debug(1, (char *)"-> To: %s", tmp___204);
      }
    }
#line 1039
    if (err___0 > 0) {
      {
#line 1039
      tmp___208 = cf_getrptstr(rpt, 2);
      }
#line 1039
      if ((unsigned long )tmp___208 != (unsigned long )((void *)0)) {
        {
#line 1041
        tmp___206 = cf_getrptstr(rpt, 2);
#line 1041
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"Cc: %s\n",
                          tmp___206);
#line 1042
        tmp___207 = cf_getrptstr(rpt, 2);
#line 1042
        debug(1, (char *)"-> Cc: %s", tmp___207);
        }
      }
    }
#line 1044
    if (err___0 > 0) {
      {
#line 1044
      tmp___211 = cf_getrptstr(rpt, 3);
      }
#line 1044
      if ((unsigned long )tmp___211 != (unsigned long )((void *)0)) {
        {
#line 1046
        tmp___209 = cf_getrptstr(rpt, 3);
#line 1046
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"Bcc: %s\n",
                          tmp___209);
#line 1047
        tmp___210 = cf_getrptstr(rpt, 3);
#line 1047
        debug(1, (char *)"-> Bcc: %s", tmp___210);
        }
      }
    }
#line 1049
    if (err___0 > 0) {
      {
#line 1049
      tmp___213 = cf_getrptstr(rpt, 4);
      }
#line 1049
      if ((unsigned long )tmp___213 != (unsigned long )((void *)0)) {
        {
#line 1051
        err___0 = mailsubject(sm, - rpt);
#line 1052
        tmp___212 = cf_getrptstr(rpt, 4);
#line 1052
        debug(1, (char *)"-> Subject: %s", tmp___212);
        }
      }
    }
#line 1054
    if (err___0 > 0) {
      {
#line 1055
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Version: %s\n",
                        "1.0");
      }
    }
#line 1056
    env = 0;
    {
#line 1057
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1057
      if (err___0 > 0) {
#line 1057
        if (! ((unsigned long )*(envp + env) != (unsigned long )((void *)0))) {
#line 1057
          goto while_break___2;
        }
      } else {
#line 1057
        goto while_break___2;
      }
      {
#line 1058
      tmp___214 = env;
#line 1058
      env ++;
#line 1058
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Env: <%s>\n",
                        *(envp + tmp___214));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1059
    if (err___0 > 0) {
      {
#line 1060
      tmp___215 = get_hostname(0);
#line 1060
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Host-Name: %s\n",
                        tmp___215);
      }
    }
#line 1061
    if (err___0 > 0) {
      {
#line 1062
      tmp___216 = mystrftime___0((char *)"%Y/%m/%d %H:%M:%S", cf_timestamp);
#line 1062
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Name: %s %s %ld %s\n",
                        jid, tmp___216, cf_size, cf_md5);
      }
    }
#line 1065
    if (err___0 > 0) {
#line 1065
      if (out_timestamp != 0L) {
        {
#line 1066
        tmp___217 = mystrftime___0((char *)"%Y/%m/%d %H:%M:%S", out_timestamp);
#line 1066
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stdout: %s %ld %s\n",
                          tmp___217, out_size, out_md5);
        }
      }
    }
#line 1069
    if (err___0 > 0) {
#line 1069
      if (err_timestamp != 0L) {
        {
#line 1070
        tmp___218 = mystrftime___0((char *)"%Y/%m/%d %H:%M:%S", err_timestamp);
#line 1070
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stderr: %s %ld %s\n",
                          tmp___218, err_size, err_md5);
        }
      }
    }
#line 1073
    if (err___0 > 0) {
      {
#line 1074
      tmp___219 = getuid();
      }
#line 1074
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 1074
        if ((unsigned long )pw->pw_name != (unsigned long )((void *)0)) {
#line 1074
          tmp___220 = (char const   *)pw->pw_name;
        } else {
#line 1074
          tmp___220 = "?";
        }
      } else {
#line 1074
        tmp___220 = "?";
      }
      {
#line 1074
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-User: %s [%u]\n",
                        tmp___220, tmp___219);
      }
    }
#line 1077
    if (err___0 > 0) {
      {
#line 1078
      tmp___221 = cf_getrptstr(rpt, 0);
#line 1078
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Report-Name: %s\n",
                        tmp___221);
      }
    }
#line 1080
    if (err___0 > 0) {
      {
#line 1081
      tmp___222 = cf_getstr(13);
#line 1081
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Command: %s\n",
                        tmp___222);
      }
    }
#line 1082
    if (err___0 > 0) {
#line 1084
      __constr_expr_41.__in = status;
#line 1084
      if ((__constr_expr_41.__i & 127) == 0) {
        {
#line 1085
        __constr_expr_38.__in = status;
#line 1085
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Exit-Status: %d\n",
                          (__constr_expr_38.__i & 65280) >> 8);
        }
      } else {
#line 1089
        __constr_expr_39.__in = status;
#line 1089
        if (! ((int )((signed char )((__constr_expr_39.__i & 127) + 1)) >> 1 > 0)) {
          {
#line 1089
          myassert((char *)"WIFSIGNALED(status)", (char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
                   (char *)((void *)0), 1089);
          }
        }
        {
#line 1090
        __constr_expr_40.__in = status;
#line 1090
        tmp___223 = strsignal(__constr_expr_40.__i & 127);
#line 1090
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Exit-Status: %s\n",
                          tmp___223);
        }
      }
    }
#line 1094
    if (err___0 > 0) {
      {
#line 1098
      tmp___224 = variable_get((char *)"outlines", & lines);
      }
#line 1098
      if (tmp___224 != 0) {
        {
#line 1099
        myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
                (char *)((void *)0), 1099);
        }
      }
      {
#line 1100
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stdout-Size: %ld lines, %ld Bytes\n",
                        lines, outlen);
      }
    }
#line 1103
    if (err___0 > 0) {
      {
#line 1107
      tmp___225 = variable_get((char *)"errlines", & lines___0);
      }
#line 1107
      if (tmp___225 != 0) {
        {
#line 1108
        myabort((char *)"/home/june/repo/benchmarks/collector/temp/shush-1.2.3/src/run.c",
                (char *)((void *)0), 1108);
        }
      }
      {
#line 1109
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Stderr-Size: %ld lines, %ld Bytes\n",
                        lines___0, errlen);
      }
    }
#line 1112
    if (err___0 > 0) {
      {
#line 1113
      tmp___226 = unit_rtime((u_int )(end - start));
#line 1113
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"X-Shush-Rusage: %s (%s user, %s sys)\n",
                        tmp___226, utimestr, stimestr);
      }
    }
    {
#line 1115
    cf_getrptstrlist(-1, 11);
    }
    {
#line 1116
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1116
      if (err___0 > 0) {
        {
#line 1116
        header = cf_getrptstrlist(rpt, 11);
        }
#line 1116
        if (! ((unsigned long )header != (unsigned long )((void *)0))) {
#line 1116
          goto while_break___3;
        }
      } else {
#line 1116
        goto while_break___3;
      }
      {
#line 1118
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"%s\n",
                        header);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1119
    if (err___0 > 0) {
      {
#line 1119
      tmp___227 = cf_getrptnum(rpt, 9);
      }
#line 1119
      if (tmp___227 == 2L) {
        {
#line 1120
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"Content-Type: text/enriched\n");
        }
      }
    }
#line 1121
    if (err___0 > 0) {
      {
#line 1121
      tmp___228 = cf_getrptnum(rpt, 9);
      }
#line 1121
      if (tmp___228 == 3L) {
        {
#line 1122
        err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"Content-Type: text/html\n");
        }
      }
    }
#line 1123
    if (err___0 > 0) {
      {
#line 1124
      err___0 = fprintf((FILE */* __restrict  */)sm, (char const   */* __restrict  */)"\n");
      }
    }
#line 1125
    if (err___0 <= 0) {
      {
#line 1127
      tmp___229 = __errno_location();
#line 1127
      tmp___230 = strerror(*tmp___229);
#line 1127
      tmp___231 = cf_getrptstr(rpt, 0);
#line 1127
      error((char *)"Error while writing mail headers for report \"%s\": %s", tmp___231,
            tmp___230);
#line 1129
      err___0 = -1;
      }
    } else {
      {
#line 1131
      tmp___233 = cf_getrptnum(rpt, 7);
#line 1131
      tmp___234 = cf_getrptnum(rpt, 10);
#line 1131
      tmp___235 = cf_getrptnum(rpt, 9);
#line 1131
      tmp___236 = analyzer_output(sm, (int )tmp___235, (int )tmp___234, (size_t )tmp___233,
                                  outstr, outlen, errstr, errlen);
      }
#line 1131
      if (tmp___236 != 0) {
        {
#line 1135
        tmp___232 = cf_getrptstr(rpt, 0);
#line 1135
        error((char *)"Errors while sending output for report \"%s\".", tmp___232);
        }
      }
    }
    {
#line 1137
    tmp___240 = fclose(sm);
    }
#line 1137
    if (tmp___240 != 0) {
#line 1137
      if (err___0 == 0) {
        {
#line 1138
        tmp___237 = __errno_location();
#line 1138
        tmp___238 = strerror(*tmp___237);
#line 1138
        tmp___239 = cf_getrptstr(rpt, 0);
#line 1138
        error((char *)"Errors while sending report \"%s\": %s", tmp___239, tmp___238);
        }
      }
    }
    {
#line 1142
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1144
      err___0 = waitpid(child, & smstatus, 0);
      }
#line 1145
      if (err___0 == child) {
#line 1145
        __constr_expr_42.__in = smstatus;
#line 1145
        if ((__constr_expr_42.__i & 127) == 0) {
#line 1146
          goto while_break___4;
        } else {
#line 1145
          __constr_expr_43.__in = smstatus;
#line 1145
          if ((int )((signed char )((__constr_expr_43.__i & 127) + 1)) >> 1 > 0) {
#line 1146
            goto while_break___4;
          }
        }
      }
#line 1147
      if (err___0 == -1) {
        {
#line 1149
        tmp___246 = __errno_location();
        }
#line 1149
        if (*tmp___246 == 4) {
          {
#line 1150
          tmp___241 = __errno_location();
#line 1150
          tmp___242 = strerror(*tmp___241);
#line 1150
          debug(1, (char *)"waitpid(%d): %s", child, tmp___242);
          }
        } else {
          {
#line 1152
          tmp___243 = __errno_location();
#line 1152
          tmp___244 = strerror(*tmp___243);
#line 1152
          tmp___245 = cf_getrptstr(rpt, 0);
#line 1152
          error((char *)"waitpid(%d[sendmail for report \"%s\"]) failed: %s", child,
                tmp___245, tmp___244);
          }
        }
      }
      {
#line 1155
      sleep(1U);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1160
    __constr_expr_45.__in = smstatus;
#line 1160
    if ((__constr_expr_45.__i & 127) == 0) {
#line 1160
      __constr_expr_46.__in = smstatus;
#line 1160
      if ((__constr_expr_46.__i & 65280) >> 8 != 0) {
        {
#line 1161
        __constr_expr_44.__in = smstatus;
#line 1161
        tmp___247 = cf_getrptstr(rpt, 0);
#line 1161
        error((char *)"sendmail for report \"%s\" returned: %d", tmp___247, (__constr_expr_44.__i & 65280) >> 8);
        }
      }
    }
#line 1163
    __constr_expr_48.__in = smstatus;
#line 1163
    if ((int )((signed char )((__constr_expr_48.__i & 127) + 1)) >> 1 > 0) {
      {
#line 1164
      __constr_expr_47.__in = smstatus;
#line 1164
      tmp___248 = strsignal(__constr_expr_47.__i & 127);
#line 1164
      tmp___249 = cf_getrptstr(rpt, 0);
#line 1164
      error((char *)"sendmail for report \"%s\" died from %s", tmp___249, tmp___248);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1168
  if ((options & 8) == 0) {
    {
#line 1170
    tmp___253 = unlink((char const   *)(outlog));
    }
#line 1170
    if (tmp___253 != 0) {
      {
#line 1171
      tmp___251 = __errno_location();
#line 1171
      tmp___252 = strerror(*tmp___251);
#line 1171
      error((char *)"Failed to remove \"%s\": %s", outlog, tmp___252);
      }
    }
    {
#line 1172
    tmp___256 = cf_getrptnum(0, 10);
    }
#line 1172
    if (tmp___256 != 1L) {
      {
#line 1172
      tmp___257 = unlink((char const   *)(errlog));
      }
#line 1172
      if (tmp___257 != 0) {
        {
#line 1174
        tmp___254 = __errno_location();
#line 1174
        tmp___255 = strerror(*tmp___254);
#line 1174
        error((char *)"Failed to remove \"%s\": %s", errlog, tmp___255);
        }
      }
    }
  } else {
    {
#line 1178
    log(6, (char *)"Standard output file: %s", outlog);
#line 1179
    log(6, (char *)"Standard error  file: %s", errlog);
    }
  }
#line 1183
  if ((options & 2) != 0) {
    {
#line 1185
    err___0 = pthread_join(outthd, (void **)((void *)0));
    }
#line 1186
    if (err___0 != 0) {
#line 1186
      if (err___0 != 3) {
        {
#line 1187
        tmp___258 = strerror(err___0);
#line 1187
        error((char *)"pthread_join() failed unexpectedly: %s", tmp___258);
        }
      }
    }
    {
#line 1188
    err___0 = pthread_join(errthd, (void **)((void *)0));
    }
#line 1189
    if (err___0 != 0) {
#line 1189
      if (err___0 != 3) {
        {
#line 1190
        tmp___259 = strerror(err___0);
#line 1190
        error((char *)"pthread_join() failed unexpectedly: %s", tmp___259);
        }
      }
    }
  }
  {
#line 1194
  log(6, (char *)"%s: Done.", jid);
  }
#line 1195
  return;
}
}
