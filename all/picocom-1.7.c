/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_29 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_32 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_33 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_34 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_27 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_28 _kill ;
   struct __anonstruct__timer_29 _timer ;
   struct __anonstruct__rt_30 _rt ;
   struct __anonstruct__sigchld_31 _sigchld ;
   struct __anonstruct__sigfault_32 _sigfault ;
   struct __anonstruct__sigpoll_33 _sigpoll ;
   struct __anonstruct__sigsys_34 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_26 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_27 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_26 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_46 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_46 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 144 "/home/wheatley/newnew/temp/picocom-1.7/term.h"
enum parity_e {
    P_NONE = 0,
    P_EVEN = 1,
    P_ODD = 2
} ;
#line 160
enum flowcntrl_e {
    FC_NONE = 0,
    FC_RTSCTS = 1,
    FC_XONXOFF = 2
} ;
#line 85 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
struct map_names_s {
   char *name ;
   int flag ;
};
#line 136 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
struct __anonstruct_opts_53 {
   char port[128] ;
   int baud ;
   enum flowcntrl_e flow ;
   char *flow_str ;
   enum parity_e parity ;
   char *parity_str ;
   int databits ;
   int lecho ;
   int noinit ;
   int noreset ;
   int nolock ;
   unsigned char escape ;
   char send_cmd[128] ;
   char receive_cmd[128] ;
   int imap ;
   int omap ;
   int emap ;
};
#line 594 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 596 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 593 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 644 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 644 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 653 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
struct tty_q {
   int len ;
   unsigned char buff[256] ;
};
#line 663
enum __anonenum_state_59 {
    ST_COMMAND = 0,
    ST_TRANSPARENT = 1
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 46 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
struct term_s {
   int init ;
   int fd[16] ;
   struct termios origtermios[16] ;
   struct termios currtermios[16] ;
   struct termios nexttermios[16] ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 173 "/home/wheatley/newnew/temp/picocom-1.7/term.h"
int term_errno ;
#line 189
char const   *term_strerror(int terrnum , int errnum ) ;
#line 224
int term_lib_init(void) ;
#line 235
int term_add(int fd ) ;
#line 247
int term_remove(int fd ) ;
#line 257
int term_erase(int fd ) ;
#line 293
int term_apply(int fd ) ;
#line 320
int term_reset(int fd ) ;
#line 353
int term_set_raw(int fd ) ;
#line 368
int term_set_baudrate(int fd , int baudrate ) ;
#line 382
int term_set_parity(int fd , enum parity_e parity ) ;
#line 396
int term_set_databits(int fd , int databits ) ;
#line 411
int term_set_flowcntrl(int fd , enum flowcntrl_e flowcntl ) ;
#line 424
int term_set_hupcl(int fd , int on ) ;
#line 464
int term_set(int fd , int raw , int baud , enum parity_e parity , int bits , enum flowcntrl_e fc ,
             int local , int hup_close ) ;
#line 478
int term_pulse_dtr(int fd ) ;
#line 487
int term_lower_dtr(int fd ) ;
#line 496
int term_raise_dtr(int fd ) ;
#line 518
int term_flush(int fd ) ;
#line 529
int term_break(int fd ) ;
#line 85 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
struct map_names_s map_names[9]  = 
#line 85 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
  {      {(char *)"crlf", 1}, 
        {(char *)"crcrlf", 1 << 1}, 
        {(char *)"igncr", 1 << 2}, 
        {(char *)"lfcr", 1 << 3}, 
        {(char *)"lfcrlf", 1 << 4}, 
        {(char *)"ignlf", 1 << 5}, 
        {(char *)"delbs", 1 << 6}, 
        {(char *)"bsdel", 1 << 7}, 
        {(char *)((void *)0), 0}};
#line 101 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int parse_map(char *s ) 
{ 
  char *m ;
  char *t ;
  int f ;
  int flags ;
  int i ;
  int tmp ;

  {
#line 107
  flags = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    t = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)", \t");
    }
#line 108
    if (! t) {
#line 108
      goto while_break;
    }
#line 109
    i = 0;
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      m = map_names[i].name;
#line 109
      if (! m) {
#line 109
        goto while_break___0;
      }
      {
#line 110
      tmp = strcmp((char const   *)t, (char const   *)m);
      }
#line 110
      if (! tmp) {
#line 111
        f = map_names[i].flag;
#line 112
        goto while_break___0;
      }
#line 109
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    if (m) {
#line 115
      flags |= f;
    } else {
#line 116
      flags = -1;
#line 116
      goto while_break;
    }
#line 117
    s = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (flags);
}
}
#line 123 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void print_map(int flags ) 
{ 
  int i ;

  {
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < 8)) {
#line 128
      goto while_break;
    }
#line 129
    if (flags & (1 << i)) {
      {
#line 130
      printf((char const   */* __restrict  */)"%s,", map_names[i].name);
      }
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  printf((char const   */* __restrict  */)"\n");
  }
#line 132
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
struct __anonstruct_opts_53 opts  = 
#line 136
     {{(char )'\000'}, 9600, (enum flowcntrl_e )0, (char *)"none", (enum parity_e )0,
    (char *)"none", 8, 0, 0, 0, 0, (unsigned char )'\001', {(char )'s', (char )'z',
                                                            (char )' ', (char )'-',
                                                            (char )'v', (char )'v',
                                                            (char )'\000'}, {(char )'r',
                                                                             (char )'z',
                                                                             (char )' ',
                                                                             (char )'-',
                                                                             (char )'v',
                                                                             (char )'v',
                                                                             (char )'\000'},
    0, 0, (1 << 6) | (1 << 1)};
#line 178 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int tty_fd  ;
#line 188 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
char lockname[256]  = {      (char )'\000'};
#line 190 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int uucp_lockname(char const   *dir , char const   *file ) 
{ 
  char *p ;
  char *cp ;
  struct stat sb ;
  int tmp ;
  char *tmp___0 ;

  {
#line 196
  if (! dir) {
#line 197
    return (-1);
  } else
#line 196
  if ((int const   )*dir == 0) {
#line 197
    return (-1);
  } else {
    {
#line 196
    tmp = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& sb));
    }
#line 196
    if (tmp != 0) {
#line 197
      return (-1);
    }
  }
  {
#line 200
  p = strchr(file + 1, '/');
  }
#line 201
  if (p) {
#line 201
    p ++;
  } else {
#line 201
    p = (char *)file;
  }
  {
#line 203
  cp = strdup((char const   *)p);
#line 203
  p = cp;
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if ((int )*p == 47) {
#line 204
      *p = (char )'_';
    }
#line 204
    tmp___0 = p;
#line 204
    p ++;
#line 204
    if (! *tmp___0) {
#line 204
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  snprintf((char */* __restrict  */)(lockname), sizeof(lockname), (char const   */* __restrict  */)"%s/LCK..%s",
           dir, cp);
#line 208
  free((void *)cp);
  }
#line 210
  return (0);
}
}
#line 213 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int uucp_lock(void) 
{ 
  int r ;
  int fd ;
  int pid ;
  char buf[16] ;
  mode_t m ;
  ssize_t tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  __pid_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 220
  if ((int )lockname[0] == 0) {
#line 220
    return (0);
  }
  {
#line 222
  fd = open((char const   *)(lockname), 0);
  }
#line 223
  if (fd >= 0) {
    {
#line 224
    tmp = read(fd, (void *)(buf), sizeof(buf));
#line 224
    r = (int )tmp;
#line 225
    close(fd);
    }
#line 227
    if (r == 4) {
#line 227
      pid = *((int *)(buf));
    } else {
      {
#line 227
      tmp___0 = strtol((char const   */* __restrict  */)(buf), (char **/* __restrict  */)((void *)0),
                       10);
#line 227
      pid = (int )tmp___0;
      }
    }
#line 228
    if (pid > 0) {
      {
#line 228
      tmp___2 = kill(pid, 0);
      }
#line 228
      if (tmp___2 < 0) {
        {
#line 228
        tmp___3 = __errno_location();
        }
#line 228
        if (*tmp___3 == 3) {
          {
#line 232
          printf((char const   */* __restrict  */)"Removing stale lock: %s\n", lockname);
#line 233
          sleep(1U);
#line 234
          unlink((char const   *)(lockname));
          }
        } else {
          {
#line 236
          lockname[0] = (char )'\000';
#line 237
          tmp___1 = __errno_location();
#line 237
          *tmp___1 = 17;
          }
#line 238
          return (-1);
        }
      } else {
        {
#line 236
        lockname[0] = (char )'\000';
#line 237
        tmp___1 = __errno_location();
#line 237
        *tmp___1 = 17;
        }
#line 238
        return (-1);
      }
    } else {
      {
#line 236
      lockname[0] = (char )'\000';
#line 237
      tmp___1 = __errno_location();
#line 237
      *tmp___1 = 17;
      }
#line 238
      return (-1);
    }
  }
  {
#line 242
  m = umask((__mode_t )18);
#line 243
  fd = open((char const   *)(lockname), 193, 438);
  }
#line 244
  if (fd < 0) {
#line 244
    lockname[0] = (char )'\000';
#line 244
    return (-1);
  }
  {
#line 245
  umask(m);
#line 246
  tmp___4 = getpid();
#line 246
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%04d\n",
           tmp___4);
#line 247
  tmp___5 = strlen((char const   *)(buf));
#line 247
  write(fd, (void const   *)(buf), tmp___5);
#line 248
  close(fd);
  }
#line 250
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int uucp_unlock(void) 
{ 


  {
#line 256
  if (lockname[0]) {
    {
#line 256
    unlink((char const   *)(lockname));
    }
  }
#line 257
  return (0);
}
}
#line 264 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
ssize_t writen_ni(int fd , void const   *buff , size_t n ) 
{ 
  size_t nl ;
  ssize_t nw ;
  char const   *p ;
  int *tmp ;

  {
#line 271
  p = (char const   *)buff;
#line 272
  nl = n;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (nl > 0UL)) {
#line 273
      goto while_break;
    }
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 275
      nw = write(fd, (void const   *)p, nl);
      }
#line 274
      if (nw < 0L) {
        {
#line 274
        tmp = __errno_location();
        }
#line 274
        if (! (*tmp == 4)) {
#line 274
          goto while_break___0;
        }
      } else {
#line 274
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 277
    if (nw <= 0L) {
#line 277
      goto while_break;
    }
#line 278
    nl -= (size_t )nw;
#line 279
    p += nw;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return ((ssize_t )(n - nl));
}
}
#line 285 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int fd_printf(int fd , char const   *format  , ...) 
{ 
  char buf[256] ;
  va_list args ;
  int len ;
  ssize_t tmp ;

  {
  {
#line 292
  __builtin_va_start(args, format);
#line 293
  len = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                  args);
#line 294
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 295
  __builtin_va_end(args);
#line 297
  tmp = writen_ni(fd, (void const   *)(buf), (size_t )len);
  }
#line 297
  return ((int )tmp);
}
}
#line 300 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void fatal(char const   *format  , ...) 
{ 
  char *s ;
  char buf[256] ;
  va_list args ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 307
  term_reset(1);
#line 308
  term_reset(0);
#line 310
  __builtin_va_start(args, format);
#line 311
  len = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                  args);
#line 312
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 313
  __builtin_va_end(args);
#line 315
  s = (char *)"\r\nFATAL: ";
#line 316
  tmp = strlen((char const   *)s);
#line 316
  writen_ni(1, (void const   *)s, tmp);
#line 317
  writen_ni(1, (void const   *)(buf), (size_t )len);
#line 318
  s = (char *)"\r\n";
#line 319
  tmp___0 = strlen((char const   *)s);
#line 319
  writen_ni(1, (void const   *)s, tmp___0);
#line 322
  sleep(1U);
#line 325
  uucp_unlock();
#line 328
  exit(1);
  }
}
}
#line 333 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int fd_readline(int fdi , int fdo , char *b , int bsz ) 
{ 
  int r ;
  unsigned char c ;
  unsigned char *bp ;
  unsigned char *bpe ;
  ssize_t tmp ;
  int cl ;
  int cl___0 ;
  int cl___1 ;
  int cl___2 ;
  unsigned char *tmp___0 ;
  int cl___3 ;
  int cl___4 ;

  {
#line 340
  bp = (unsigned char *)b;
#line 341
  bpe = ((unsigned char *)b + bsz) - 1;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 344
    tmp = read(fdi, (void *)(& c), (size_t )1);
#line 344
    r = (int )tmp;
    }
#line 345
    if (r <= 0) {
#line 345
      r --;
#line 345
      goto out;
    }
    {
#line 348
    if ((int )c == 8) {
#line 348
      goto case_8;
    }
#line 356
    if ((int )c == 13) {
#line 356
      goto case_13;
    }
#line 360
    goto switch_default;
    case_8: /* CIL Label */ 
#line 349
    if ((unsigned long )bp > (unsigned long )((unsigned char *)b)) {
#line 350
      bp --;
      {
#line 351
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 351
        cl = (int )c;
#line 351
        write(fdo, (void const   *)(& cl), (size_t )1);
        }
#line 351
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 351
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 351
        cl___0 = ' ';
#line 351
        write(fdo, (void const   *)(& cl___0), (size_t )1);
        }
#line 351
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 351
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 351
        cl___1 = (int )c;
#line 351
        write(fdo, (void const   *)(& cl___1), (size_t )1);
        }
#line 351
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 353
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 353
        cl___2 = '\a';
#line 353
        write(fdo, (void const   *)(& cl___2), (size_t )1);
        }
#line 353
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 355
    goto switch_break;
    case_13: /* CIL Label */ 
#line 357
    *bp = (unsigned char )'\000';
#line 358
    r = (int )(bp - (unsigned char *)b);
#line 359
    goto out;
    switch_default: /* CIL Label */ 
#line 361
    if ((unsigned long )bp < (unsigned long )bpe) {
#line 361
      tmp___0 = bp;
#line 361
      bp ++;
#line 361
      *tmp___0 = c;
      {
#line 361
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 361
        cl___3 = (int )c;
#line 361
        write(fdo, (void const   *)(& cl___3), (size_t )1);
        }
#line 361
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 362
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 362
        cl___4 = '\a';
#line 362
        write(fdo, (void const   *)(& cl___4), (size_t )1);
        }
#line 362
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 363
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 368
  return (r);
}
}
#line 377 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int do_map(char *b , int map , char c ) 
{ 
  int n ;

  {
  {
#line 383
  if ((int )c == 127) {
#line 383
    goto case_127;
  }
#line 391
  if ((int )c == 8) {
#line 391
    goto case_8;
  }
#line 399
  if ((int )c == 13) {
#line 399
    goto case_13;
  }
#line 411
  if ((int )c == 10) {
#line 411
    goto case_10;
  }
#line 423
  goto switch_default;
  case_127: /* CIL Label */ 
#line 385
  if (map & (1 << 6)) {
#line 386
    *(b + 0) = (char )'\b';
#line 386
    n = 1;
  } else {
#line 388
    *(b + 0) = c;
#line 388
    n = 1;
  }
#line 390
  goto switch_break;
  case_8: /* CIL Label */ 
#line 393
  if (map & (1 << 7)) {
#line 394
    *(b + 0) = (char )'\177';
#line 394
    n = 1;
  } else {
#line 396
    *(b + 0) = c;
#line 396
    n = 1;
  }
#line 398
  goto switch_break;
  case_13: /* CIL Label */ 
#line 401
  if (map & 1) {
#line 402
    *(b + 0) = (char )'\n';
#line 402
    n = 1;
  } else
#line 403
  if (map & (1 << 1)) {
#line 404
    *(b + 0) = (char )'\r';
#line 404
    *(b + 1) = (char )'\n';
#line 404
    n = 2;
  } else
#line 405
  if (map & (1 << 2)) {
#line 406
    n = 0;
  } else {
#line 408
    *(b + 0) = c;
#line 408
    n = 1;
  }
#line 410
  goto switch_break;
  case_10: /* CIL Label */ 
#line 413
  if (map & (1 << 3)) {
#line 414
    *(b + 0) = (char )'\r';
#line 414
    n = 1;
  } else
#line 415
  if (map & (1 << 4)) {
#line 416
    *(b + 0) = (char )'\r';
#line 416
    *(b + 1) = (char )'\n';
#line 416
    n = 2;
  } else
#line 417
  if (map & (1 << 5)) {
#line 418
    n = 0;
  } else {
#line 420
    *(b + 0) = c;
#line 420
    n = 1;
  }
#line 422
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 424
  *(b + 0) = c;
#line 424
  n = 1;
#line 425
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 428
  return (n);
}
}
#line 431 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void map_and_write(int fd , int map , char c ) 
{ 
  char b[4] ;
  int n ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 437
  n = do_map(b, map, c);
  }
#line 438
  if (n) {
    {
#line 439
    tmp___1 = writen_ni(fd, (void const   *)(b), (size_t )n);
    }
#line 439
    if (tmp___1 < (ssize_t )n) {
      {
#line 440
      tmp = __errno_location();
#line 440
      tmp___0 = strerror(*tmp);
#line 440
      fatal("write to stdout failed: %s", tmp___0);
      }
    }
  }
#line 441
  return;
}
}
#line 445 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int baud_up(int baud ) 
{ 


  {
#line 448
  if (baud < 300) {
#line 449
    baud = 300;
  } else
#line 450
  if (baud == 38400) {
#line 451
    baud = 57600;
  } else {
#line 453
    baud *= 2;
  }
#line 458
  if (baud > 921600) {
#line 459
    baud = 921600;
  }
#line 462
  return (baud);
}
}
#line 465 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int baud_down(int baud ) 
{ 


  {
#line 472
  if (baud > 921600) {
#line 473
    baud = 921600;
  } else
#line 475
  if (baud == 57600) {
#line 476
    baud = 38400;
  } else {
#line 478
    baud /= 2;
  }
#line 480
  if (baud < 300) {
#line 481
    baud = 300;
  }
#line 483
  return (baud);
}
}
#line 486 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int flow_next(int flow , char **flow_str ) 
{ 


  {
  {
#line 490
  if (flow == 0) {
#line 490
    goto case_0;
  }
#line 494
  if (flow == 1) {
#line 494
    goto case_1;
  }
#line 498
  if (flow == 2) {
#line 498
    goto case_2;
  }
#line 502
  goto switch_default;
  case_0: /* CIL Label */ 
#line 491
  flow = 1;
#line 492
  *flow_str = (char *)"RTS/CTS";
#line 493
  goto switch_break;
  case_1: /* CIL Label */ 
#line 495
  flow = 2;
#line 496
  *flow_str = (char *)"xon/xoff";
#line 497
  goto switch_break;
  case_2: /* CIL Label */ 
#line 499
  flow = 0;
#line 500
  *flow_str = (char *)"none";
#line 501
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 503
  flow = 0;
#line 504
  *flow_str = (char *)"none";
#line 505
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 508
  return (flow);
}
}
#line 511 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int parity_next(int parity , char **parity_str ) 
{ 


  {
  {
#line 515
  if (parity == 0) {
#line 515
    goto case_0;
  }
#line 519
  if (parity == 1) {
#line 519
    goto case_1;
  }
#line 523
  if (parity == 2) {
#line 523
    goto case_2;
  }
#line 527
  goto switch_default;
  case_0: /* CIL Label */ 
#line 516
  parity = 1;
#line 517
  *parity_str = (char *)"even";
#line 518
  goto switch_break;
  case_1: /* CIL Label */ 
#line 520
  parity = 2;
#line 521
  *parity_str = (char *)"odd";
#line 522
  goto switch_break;
  case_2: /* CIL Label */ 
#line 524
  parity = 0;
#line 525
  *parity_str = (char *)"none";
#line 526
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 528
  parity = 0;
#line 529
  *parity_str = (char *)"none";
#line 530
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 533
  return (parity);
}
}
#line 536 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int bits_next(int bits ) 
{ 


  {
#line 539
  bits ++;
#line 540
  if (bits > 8) {
#line 540
    bits = 5;
  }
#line 542
  return (bits);
}
}
#line 547 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void child_empty_handler(int signum ) 
{ 


  {
#line 550
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void establish_child_signal_handlers(void) 
{ 
  struct sigaction empty_action ;

  {
  {
#line 558
  empty_action.__sigaction_handler.sa_handler = & child_empty_handler;
#line 559
  sigemptyset(& empty_action.sa_mask);
#line 560
  empty_action.sa_flags = 0;
#line 562
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& empty_action), (struct sigaction */* __restrict  */)((void *)0));
#line 563
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& empty_action), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 564
  return;
}
}
#line 566 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int run_cmd(int fd  , ...) 
{ 
  pid_t pid ;
  sigset_t sigm ;
  sigset_t sigm_old ;
  int *tmp ;
  char *tmp___0 ;
  int r ;
  union __anonunion_54 __constr_expr_0 ;
  union __anonunion_55 __constr_expr_1 ;
  union __anonunion_56 __constr_expr_2 ;
  int r___0 ;
  long fl ;
  char cmd[512] ;
  int tmp___1 ;
  char *c ;
  char *ce ;
  char const   *s ;
  int n ;
  va_list vls ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  union __anonunion_57 __constr_expr_3 ;
  union __anonunion_58 __constr_expr_4 ;

  {
  {
#line 573
  sigemptyset(& sigm);
#line 574
  sigaddset(& sigm, 15);
#line 575
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sigm), (sigset_t */* __restrict  */)(& sigm_old));
#line 577
  pid = fork();
  }
#line 578
  if (pid < 0) {
    {
#line 579
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& sigm_old), (sigset_t */* __restrict  */)((void *)0));
#line 580
    tmp = __errno_location();
#line 580
    tmp___0 = strerror(*tmp);
#line 580
    fd_printf(1, "*** cannot fork: %s\n", tmp___0);
    }
#line 581
    return (-1);
  } else
#line 582
  if (pid) {
    {
#line 587
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& sigm_old), (sigset_t */* __restrict  */)((void *)0));
#line 589
    waitpid(pid, & r, 0);
#line 591
    term_apply(0);
#line 593
    __constr_expr_2.__in = r;
    }
#line 593
    if ((__constr_expr_2.__i & 127) == 0) {
      {
#line 594
      __constr_expr_0.__in = r;
#line 594
      fd_printf(1, "\r\n*** exit status: %d\r\n", (__constr_expr_0.__i & 65280) >> 8);
#line 596
      __constr_expr_1.__in = r;
      }
#line 596
      return ((__constr_expr_1.__i & 65280) >> 8);
    } else {
      {
#line 598
      fd_printf(1, "\r\n*** abnormal termination: 0x%x\r\n", r);
      }
#line 599
      return (-1);
    }
  } else {
    {
#line 607
    establish_child_signal_handlers();
#line 608
    sigprocmask(2, (sigset_t const   */* __restrict  */)(& sigm_old), (sigset_t */* __restrict  */)((void *)0));
#line 610
    term_remove(0);
#line 612
    term_erase(fd);
#line 614
    tmp___1 = fcntl(fd, 3);
#line 614
    fl = (long )tmp___1;
#line 615
    fl &= -2049L;
#line 616
    fcntl(fd, 4, fl);
#line 618
    close(0);
#line 619
    close(1);
#line 620
    dup2(fd, 0);
#line 621
    dup2(fd, 1);
#line 629
    c = cmd;
#line 630
    ce = (cmd + sizeof(cmd)) - 1;
#line 631
    __builtin_va_start(vls, fd);
    }
    {
#line 632
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 632
      tmp___4 = __builtin_va_arg(vls, char const   *);
#line 632
      s = tmp___4;
      }
#line 632
      if (! s) {
#line 632
        goto while_break;
      }
      {
#line 633
      tmp___2 = strlen(s);
#line 633
      n = (int )tmp___2;
      }
#line 634
      if ((unsigned long )((c + n) + 1) >= (unsigned long )ce) {
#line 634
        goto while_break;
      }
      {
#line 635
      memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)s, (size_t )n);
#line 635
      c += n;
#line 636
      tmp___3 = c;
#line 636
      c ++;
#line 636
      *tmp___3 = (char )' ';
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 638
    __builtin_va_end(vls);
#line 639
    *c = (char )'\000';
#line 642
    fd_printf(2, "%s\n", cmd);
#line 643
    r___0 = system((char const   *)(cmd));
#line 644
    __constr_expr_4.__in = r___0;
    }
#line 644
    if ((__constr_expr_4.__i & 127) == 0) {
      {
#line 644
      __constr_expr_3.__in = r___0;
#line 644
      exit((__constr_expr_3.__i & 65280) >> 8);
      }
    } else {
      {
#line 645
      exit(128);
      }
    }
  }
}
}
#line 653 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
struct tty_q tty_q  ;
#line 660 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void loop(void) 
{ 
  enum __anonenum_state_59 state ;
  int dtr_up ;
  fd_set rdset ;
  fd_set wrset ;
  int newbaud ;
  int newflow ;
  int newparity ;
  int newbits ;
  char *newflow_str ;
  char *newparity_str ;
  char fname[128] ;
  int r ;
  int n ;
  unsigned char c ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  ssize_t tmp___24 ;
  int *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;
  ssize_t tmp___30 ;
  int *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;

  {
#line 676
  tty_q.len = 0;
#line 677
  state = (enum __anonenum_state_59 )1;
#line 678
  dtr_up = 0;
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 681
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 681
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rdset.__fds_bits[0]): "memory");
#line 681
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 682
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 682
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wrset.__fds_bits[0]): "memory");
#line 682
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 683
    rdset.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 684
    rdset.__fds_bits[tty_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << tty_fd % (8 * (int )sizeof(__fd_mask ));
#line 685
    if (tty_q.len) {
#line 685
      wrset.__fds_bits[tty_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << tty_fd % (8 * (int )sizeof(__fd_mask ));
    }
    {
#line 687
    tmp___2 = select(tty_fd + 1, (fd_set */* __restrict  */)(& rdset), (fd_set */* __restrict  */)(& wrset),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 687
    if (tmp___2 < 0) {
      {
#line 688
      tmp = __errno_location();
#line 688
      tmp___0 = strerror(*tmp);
#line 688
      tmp___1 = __errno_location();
#line 688
      fatal("select failed: %d : %s", *tmp___1, tmp___0);
      }
    }
#line 690
    if ((rdset.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 694
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 695
        tmp___3 = read(0, (void *)(& c), (size_t )1);
#line 695
        n = (int )tmp___3;
        }
#line 694
        if (n < 0) {
          {
#line 694
          tmp___4 = __errno_location();
          }
#line 694
          if (! (*tmp___4 == 4)) {
#line 694
            goto while_break___2;
          }
        } else {
#line 694
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 697
      if (n == 0) {
        {
#line 698
        fatal("stdin closed");
        }
      } else
#line 699
      if (n < 0) {
        {
#line 701
        tmp___7 = __errno_location();
        }
#line 701
        if (*tmp___7 != 11) {
          {
#line 701
          tmp___8 = __errno_location();
          }
#line 701
          if (*tmp___8 != 11) {
            {
#line 702
            tmp___5 = __errno_location();
#line 702
            tmp___6 = strerror(*tmp___5);
#line 702
            fatal("read from stdin failed: %s", tmp___6);
            }
          } else {
#line 704
            goto skip_proc_STI;
          }
        } else {
#line 704
          goto skip_proc_STI;
        }
      }
      {
#line 709
      if ((unsigned int )state == 0U) {
#line 709
        goto case_0;
      }
#line 833
      if ((unsigned int )state == 1U) {
#line 833
        goto case_1;
      }
#line 848
      goto switch_default___0;
      case_0: /* CIL Label */ 
#line 710
      if ((int )c == (int )opts.escape) {
#line 711
        state = (enum __anonenum_state_59 )1;
#line 713
        if (tty_q.len + 4 <= 256) {
          {
#line 714
          n = do_map((char *)(tty_q.buff) + tty_q.len, opts.omap, (char )c);
#line 716
          tty_q.len += n;
          }
#line 717
          if (opts.lecho) {
            {
#line 718
            map_and_write(1, opts.emap, (char )c);
            }
          }
        } else {
          {
#line 720
          fd_printf(1, "\a");
          }
        }
#line 721
        goto switch_break;
      }
#line 723
      state = (enum __anonenum_state_59 )1;
      {
#line 725
      if ((int )c == 24) {
#line 725
        goto case_24;
      }
#line 727
      if ((int )c == 17) {
#line 727
        goto case_17;
      }
#line 733
      if ((int )c == 22) {
#line 733
        goto case_22;
      }
#line 741
      if ((int )c == 16) {
#line 741
        goto case_16;
      }
#line 746
      if ((int )c == 20) {
#line 746
        goto case_20;
      }
#line 755
      if ((int )c == 21) {
#line 755
        goto case_21;
      }
#line 762
      if ((int )c == 4) {
#line 762
        goto case_4;
      }
#line 769
      if ((int )c == 6) {
#line 769
        goto case_6;
      }
#line 779
      if ((int )c == 25) {
#line 779
        goto case_25;
      }
#line 790
      if ((int )c == 2) {
#line 790
        goto case_2;
      }
#line 798
      if ((int )c == 3) {
#line 798
        goto case_3;
      }
#line 803
      if ((int )c == 19) {
#line 803
        goto case_19;
      }
#line 812
      if ((int )c == 18) {
#line 812
        goto case_18;
      }
#line 824
      if ((int )c == 28) {
#line 824
        goto case_28;
      }
#line 828
      goto switch_default;
      case_24: /* CIL Label */ 
#line 726
      return;
      case_17: /* CIL Label */ 
      {
#line 728
      term_set_hupcl(tty_fd, 0);
#line 729
      term_flush(tty_fd);
#line 730
      term_apply(tty_fd);
#line 731
      term_erase(tty_fd);
      }
#line 732
      return;
      case_22: /* CIL Label */ 
      {
#line 734
      fd_printf(1, "\r\n");
#line 735
      fd_printf(1, "*** baud: %d\r\n", opts.baud);
#line 736
      fd_printf(1, "*** flow: %s\r\n", opts.flow_str);
#line 737
      fd_printf(1, "*** parity: %s\r\n", opts.parity_str);
#line 738
      fd_printf(1, "*** databits: %d\r\n", opts.databits);
      }
#line 739
      if (dtr_up) {
#line 739
        tmp___9 = "up";
      } else {
#line 739
        tmp___9 = "down";
      }
      {
#line 739
      fd_printf(1, "*** dtr: %s\r\n", tmp___9);
      }
#line 740
      goto switch_break___0;
      case_16: /* CIL Label */ 
      {
#line 742
      fd_printf(1, "\r\n*** pulse DTR ***\r\n");
#line 743
      tmp___10 = term_pulse_dtr(tty_fd);
      }
#line 743
      if (tmp___10 < 0) {
        {
#line 744
        fd_printf(1, "*** FAILED\r\n");
        }
      }
#line 745
      goto switch_break___0;
      case_20: /* CIL Label */ 
#line 747
      if (dtr_up) {
        {
#line 748
        r = term_lower_dtr(tty_fd);
        }
      } else {
        {
#line 750
        r = term_raise_dtr(tty_fd);
        }
      }
#line 751
      if (r >= 0) {
#line 751
        dtr_up = ! dtr_up;
      }
#line 752
      if (dtr_up) {
#line 752
        tmp___11 = "up";
      } else {
#line 752
        tmp___11 = "down";
      }
      {
#line 752
      fd_printf(1, "\r\n*** DTR: %s ***\r\n", tmp___11);
      }
#line 754
      goto switch_break___0;
      case_21: /* CIL Label */ 
      {
#line 756
      newbaud = baud_up(opts.baud);
#line 757
      term_set_baudrate(tty_fd, newbaud);
#line 758
      tty_q.len = 0;
#line 758
      term_flush(tty_fd);
#line 759
      tmp___12 = term_apply(tty_fd);
      }
#line 759
      if (tmp___12 >= 0) {
#line 759
        opts.baud = newbaud;
      }
      {
#line 760
      fd_printf(1, "\r\n*** baud: %d ***\r\n", opts.baud);
      }
#line 761
      goto switch_break___0;
      case_4: /* CIL Label */ 
      {
#line 763
      newbaud = baud_down(opts.baud);
#line 764
      term_set_baudrate(tty_fd, newbaud);
#line 765
      tty_q.len = 0;
#line 765
      term_flush(tty_fd);
#line 766
      tmp___13 = term_apply(tty_fd);
      }
#line 766
      if (tmp___13 >= 0) {
#line 766
        opts.baud = newbaud;
      }
      {
#line 767
      fd_printf(1, "\r\n*** baud: %d ***\r\n", opts.baud);
      }
#line 768
      goto switch_break___0;
      case_6: /* CIL Label */ 
      {
#line 770
      newflow = flow_next((int )opts.flow, & newflow_str);
#line 771
      term_set_flowcntrl(tty_fd, (enum flowcntrl_e )newflow);
#line 772
      tty_q.len = 0;
#line 772
      term_flush(tty_fd);
#line 773
      tmp___14 = term_apply(tty_fd);
      }
#line 773
      if (tmp___14 >= 0) {
#line 774
        opts.flow = (enum flowcntrl_e )newflow;
#line 775
        opts.flow_str = newflow_str;
      }
      {
#line 777
      fd_printf(1, "\r\n*** flow: %s ***\r\n", opts.flow_str);
      }
#line 778
      goto switch_break___0;
      case_25: /* CIL Label */ 
      {
#line 780
      newparity = parity_next((int )opts.parity, & newparity_str);
#line 781
      term_set_parity(tty_fd, (enum parity_e )newparity);
#line 782
      tty_q.len = 0;
#line 782
      term_flush(tty_fd);
#line 783
      tmp___15 = term_apply(tty_fd);
      }
#line 783
      if (tmp___15 >= 0) {
#line 784
        opts.parity = (enum parity_e )newparity;
#line 785
        opts.parity_str = newparity_str;
      }
      {
#line 787
      fd_printf(1, "\r\n*** parity: %s ***\r\n", opts.parity_str);
      }
#line 789
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 791
      newbits = bits_next(opts.databits);
#line 792
      term_set_databits(tty_fd, newbits);
#line 793
      tty_q.len = 0;
#line 793
      term_flush(tty_fd);
#line 794
      tmp___16 = term_apply(tty_fd);
      }
#line 794
      if (tmp___16 >= 0) {
#line 794
        opts.databits = newbits;
      }
      {
#line 795
      fd_printf(1, "\r\n*** databits: %d ***\r\n", opts.databits);
      }
#line 797
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 799
      opts.lecho = ! opts.lecho;
#line 800
      if (opts.lecho) {
#line 800
        tmp___17 = "yes";
      } else {
#line 800
        tmp___17 = "no";
      }
      {
#line 800
      fd_printf(1, "\r\n*** local echo: %s ***\r\n", tmp___17);
      }
#line 802
      goto switch_break___0;
      case_19: /* CIL Label */ 
      {
#line 804
      fd_printf(1, "\r\n*** file: ");
#line 805
      r = fd_readline(0, 1, fname, (int )sizeof(fname));
#line 806
      fd_printf(1, "\r\n");
      }
#line 807
      if (r < -1) {
        {
#line 807
        tmp___18 = __errno_location();
        }
#line 807
        if (*tmp___18 == 4) {
#line 807
          goto switch_break___0;
        }
      }
#line 808
      if (r <= -1) {
        {
#line 809
        tmp___19 = __errno_location();
#line 809
        tmp___20 = strerror(*tmp___19);
#line 809
        fatal("cannot read filename: %s", tmp___20);
        }
      }
      {
#line 810
      run_cmd(tty_fd, opts.send_cmd, fname, (void *)0);
      }
#line 811
      goto switch_break___0;
      case_18: /* CIL Label */ 
      {
#line 813
      fd_printf(1, "*** file: ");
#line 814
      r = fd_readline(0, 1, fname, (int )sizeof(fname));
#line 815
      fd_printf(1, "\r\n");
      }
#line 816
      if (r < -1) {
        {
#line 816
        tmp___21 = __errno_location();
        }
#line 816
        if (*tmp___21 == 4) {
#line 816
          goto switch_break___0;
        }
      }
#line 817
      if (r <= -1) {
        {
#line 818
        tmp___22 = __errno_location();
#line 818
        tmp___23 = strerror(*tmp___22);
#line 818
        fatal("cannot read filename: %s", tmp___23);
        }
      }
#line 819
      if (fname[0]) {
        {
#line 820
        run_cmd(tty_fd, opts.receive_cmd, fname, (void *)0);
        }
      } else {
        {
#line 822
        run_cmd(tty_fd, opts.receive_cmd, (void *)0);
        }
      }
#line 823
      goto switch_break___0;
      case_28: /* CIL Label */ 
      {
#line 825
      term_break(tty_fd);
#line 826
      fd_printf(1, "\r\n*** break sent ***\r\n");
      }
#line 827
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 829
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 831
      goto switch_break;
      case_1: /* CIL Label */ 
#line 834
      if ((int )c == (int )opts.escape) {
#line 835
        state = (enum __anonenum_state_59 )0;
      } else
#line 837
      if (tty_q.len + 4 <= 256) {
        {
#line 838
        n = do_map((char *)(tty_q.buff) + tty_q.len, opts.omap, (char )c);
#line 840
        tty_q.len += n;
        }
#line 841
        if (opts.lecho) {
          {
#line 842
          map_and_write(1, opts.emap, (char )c);
          }
        }
      } else {
        {
#line 844
        fd_printf(1, "\a");
        }
      }
#line 846
      goto switch_break;
      switch_default___0: /* CIL Label */ 
      {
#line 849
      __assert_fail("0", "/home/wheatley/newnew/temp/picocom-1.7/picocom.c", 849U,
                    "loop");
      }
#line 850
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    skip_proc_STI: 
#line 855
    if ((rdset.__fds_bits[tty_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << tty_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 859
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 860
        tmp___24 = read(tty_fd, (void *)(& c), (size_t )1);
#line 860
        n = (int )tmp___24;
        }
#line 859
        if (n < 0) {
          {
#line 859
          tmp___25 = __errno_location();
          }
#line 859
          if (! (*tmp___25 == 4)) {
#line 859
            goto while_break___3;
          }
        } else {
#line 859
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 862
      if (n == 0) {
        {
#line 863
        fatal("term closed");
        }
      } else
#line 864
      if (n < 0) {
        {
#line 865
        tmp___28 = __errno_location();
        }
#line 865
        if (*tmp___28 != 11) {
          {
#line 865
          tmp___29 = __errno_location();
          }
#line 865
          if (*tmp___29 != 11) {
            {
#line 866
            tmp___26 = __errno_location();
#line 866
            tmp___27 = strerror(*tmp___26);
#line 866
            fatal("read from term failed: %s", tmp___27);
            }
          }
        }
      } else {
        {
#line 868
        map_and_write(1, opts.imap, (char )c);
        }
      }
    }
#line 872
    if ((wrset.__fds_bits[tty_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << tty_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 876
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 877
        tmp___30 = write(tty_fd, (void const   *)(tty_q.buff), (size_t )tty_q.len);
#line 877
        n = (int )tmp___30;
        }
#line 876
        if (n < 0) {
          {
#line 876
          tmp___31 = __errno_location();
          }
#line 876
          if (! (*tmp___31 == 4)) {
#line 876
            goto while_break___4;
          }
        } else {
#line 876
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 879
      if (n <= 0) {
        {
#line 880
        tmp___32 = __errno_location();
#line 880
        tmp___33 = strerror(*tmp___32);
#line 880
        fatal("write to term failed: %s", tmp___33);
        }
      }
      {
#line 881
      memcpy((void */* __restrict  */)(tty_q.buff), (void const   */* __restrict  */)(tty_q.buff + n),
             (size_t )(tty_q.len - n));
#line 882
      tty_q.len -= n;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 889 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void deadly_handler(int signum ) 
{ 


  {
  {
#line 892
  kill(0, 15);
#line 893
  sleep(1U);
#line 895
  uucp_unlock();
#line 897
  exit(1);
  }
}
}
#line 900 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void establish_signal_handlers(void) 
{ 
  struct sigaction exit_action ;
  struct sigaction ign_action ;

  {
  {
#line 906
  exit_action.__sigaction_handler.sa_handler = & deadly_handler;
#line 907
  sigemptyset(& exit_action.sa_mask);
#line 908
  exit_action.sa_flags = 0;
#line 911
  ign_action.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 912
  sigemptyset(& ign_action.sa_mask);
#line 913
  ign_action.sa_flags = 0;
#line 915
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& exit_action), (struct sigaction */* __restrict  */)((void *)0));
#line 917
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& ign_action), (struct sigaction */* __restrict  */)((void *)0));
#line 918
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& ign_action), (struct sigaction */* __restrict  */)((void *)0));
#line 919
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& ign_action), (struct sigaction */* __restrict  */)((void *)0));
#line 920
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& ign_action), (struct sigaction */* __restrict  */)((void *)0));
#line 921
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& ign_action), (struct sigaction */* __restrict  */)((void *)0));
#line 922
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& ign_action), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 923
  return;
}
}
#line 927 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void show_usage(char *name ) 
{ 
  char *s ;

  {
  {
#line 932
  s = strrchr((char const   *)name, '/');
  }
#line 933
  if (s) {
#line 933
    s ++;
  } else {
#line 933
    s = name;
  }
  {
#line 935
  printf((char const   */* __restrict  */)"picocom v%s\n", "1.7");
#line 936
  printf((char const   */* __restrict  */)"Usage is: %s [options] <tty device>\n",
         s);
#line 937
  printf((char const   */* __restrict  */)"Options are:\n");
#line 938
  printf((char const   */* __restrict  */)"  --<b>aud <baudrate>\n");
#line 939
  printf((char const   */* __restrict  */)"  --<f>low s (=soft) | h (=hard) | n (=none)\n");
#line 940
  printf((char const   */* __restrict  */)"  --<p>arity o (=odd) | e (=even) | n (=none)\n");
#line 941
  printf((char const   */* __restrict  */)"  --<d>atabits 5 | 6 | 7 | 8\n");
#line 942
  printf((char const   */* __restrict  */)"  --<e>scape <char>\n");
#line 943
  printf((char const   */* __restrict  */)"  --e<c>ho\n");
#line 944
  printf((char const   */* __restrict  */)"  --no<i>nit\n");
#line 945
  printf((char const   */* __restrict  */)"  --no<r>eset\n");
#line 946
  printf((char const   */* __restrict  */)"  --no<l>ock\n");
#line 947
  printf((char const   */* __restrict  */)"  --<s>end-cmd <command>\n");
#line 948
  printf((char const   */* __restrict  */)"  --recei<v>e-cmd <command>\n");
#line 949
  printf((char const   */* __restrict  */)"  --imap <map> (input mappings)\n");
#line 950
  printf((char const   */* __restrict  */)"  --omap <map> (output mappings)\n");
#line 951
  printf((char const   */* __restrict  */)"  --emap <map> (local-echo mappings)\n");
#line 952
  printf((char const   */* __restrict  */)"  --<h>elp\n");
#line 953
  printf((char const   */* __restrict  */)"<map> is a comma-separated list of one or more of:\n");
#line 954
  printf((char const   */* __restrict  */)"  crlf : map CR --> LF\n");
#line 955
  printf((char const   */* __restrict  */)"  crcrlf : map CR --> CR + LF\n");
#line 956
  printf((char const   */* __restrict  */)"  igncr : ignore CR\n");
#line 957
  printf((char const   */* __restrict  */)"  lfcr : map LF --> CR\n");
#line 958
  printf((char const   */* __restrict  */)"  lfcrlf : map LF --> CR + LF\n");
#line 959
  printf((char const   */* __restrict  */)"  ignlf : ignore LF\n");
#line 960
  printf((char const   */* __restrict  */)"  bsdel : map BS --> DEL\n");
#line 961
  printf((char const   */* __restrict  */)"  delbs : map DEL --> BS\n");
#line 962
  printf((char const   */* __restrict  */)"<?> indicates the equivalent short option.\n");
#line 963
  printf((char const   */* __restrict  */)"Short options are prefixed by \"-\" instead of by \"--\".\n");
  }
#line 964
  return;
}
}
#line 971
void parse_args(int argc , char **argv ) ;
#line 971 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
static struct option longOptions[16]  = 
#line 971
  {      {"receive-cmd", 1, (int *)0, 'v'}, 
        {"send-cmd", 1, (int *)0, 's'}, 
        {"imap", 1, (int *)0, 'I'}, 
        {"omap", 1, (int *)0, 'O'}, 
        {"emap", 1, (int *)0, 'E'}, 
        {"escape", 1, (int *)0, 'e'}, 
        {"echo", 0, (int *)0, 'c'}, 
        {"noinit", 0, (int *)0, 'i'}, 
        {"noreset", 0, (int *)0, 'r'}, 
        {"nolock", 0, (int *)0, 'l'}, 
        {"flow", 1, (int *)0, 'f'}, 
        {"baud", 1, (int *)0, 'b'}, 
        {"parity", 1, (int *)0, 'p'}, 
        {"databits", 1, (int *)0, 'd'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 968 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
void parse_args(int argc , char **argv ) 
{ 
  int optionIndex ;
  int c ;
  int map ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 992
    optionIndex = 0;
#line 997
    opterr = 0;
#line 999
    c = getopt_long(argc, (char * const  *)argv, "hirlcv:s:r:e:f:b:p:d:", (struct option  const  *)(longOptions),
                    & optionIndex);
    }
#line 1002
    if (c < 0) {
#line 1003
      goto while_break;
    }
    {
#line 1006
    if (c == 115) {
#line 1006
      goto case_115;
    }
#line 1010
    if (c == 118) {
#line 1010
      goto case_118;
    }
#line 1014
    if (c == 73) {
#line 1014
      goto case_73;
    }
#line 1019
    if (c == 79) {
#line 1019
      goto case_79;
    }
#line 1024
    if (c == 69) {
#line 1024
      goto case_69;
    }
#line 1029
    if (c == 99) {
#line 1029
      goto case_99;
    }
#line 1032
    if (c == 105) {
#line 1032
      goto case_105;
    }
#line 1035
    if (c == 114) {
#line 1035
      goto case_114;
    }
#line 1038
    if (c == 108) {
#line 1038
      goto case_108;
    }
#line 1043
    if (c == 101) {
#line 1043
      goto case_101;
    }
#line 1046
    if (c == 102) {
#line 1046
      goto case_102;
    }
#line 1069
    if (c == 98) {
#line 1069
      goto case_98;
    }
#line 1072
    if (c == 112) {
#line 1072
      goto case_112;
    }
#line 1092
    if (c == 100) {
#line 1092
      goto case_100;
    }
#line 1112
    if (c == 104) {
#line 1112
      goto case_104___0;
    }
#line 1116
    goto switch_default___2;
    case_115: /* CIL Label */ 
    {
#line 1007
    strncpy((char */* __restrict  */)(opts.send_cmd), (char const   */* __restrict  */)optarg,
            sizeof(opts.send_cmd));
#line 1008
    opts.send_cmd[sizeof(opts.send_cmd) - 1UL] = (char )'\000';
    }
#line 1009
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 1011
    strncpy((char */* __restrict  */)(opts.receive_cmd), (char const   */* __restrict  */)optarg,
            sizeof(opts.receive_cmd));
#line 1012
    opts.receive_cmd[sizeof(opts.receive_cmd) - 1UL] = (char )'\000';
    }
#line 1013
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 1015
    map = parse_map(optarg);
    }
#line 1016
    if (map >= 0) {
#line 1016
      opts.imap = map;
    } else {
      {
#line 1017
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid imap, ignored\n");
      }
    }
#line 1018
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 1020
    map = parse_map(optarg);
    }
#line 1021
    if (map >= 0) {
#line 1021
      opts.omap = map;
    } else {
      {
#line 1022
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid omap, ignored\n");
      }
    }
#line 1023
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 1025
    map = parse_map(optarg);
    }
#line 1026
    if (map >= 0) {
#line 1026
      opts.emap = map;
    } else {
      {
#line 1027
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid emap, ignored\n");
      }
    }
#line 1028
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1030
    opts.lecho = 1;
#line 1031
    goto switch_break;
    case_105: /* CIL Label */ 
#line 1033
    opts.noinit = 1;
#line 1034
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1036
    opts.noreset = 1;
#line 1037
    goto switch_break;
    case_108: /* CIL Label */ 
#line 1040
    opts.nolock = 1;
#line 1042
    goto switch_break;
    case_101: /* CIL Label */ 
#line 1044
    opts.escape = (unsigned char )((int )*(optarg + 0) & 31);
#line 1045
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 1049
    if ((int )*(optarg + 0) == 120) {
#line 1049
      goto case_120;
    }
#line 1049
    if ((int )*(optarg + 0) == 88) {
#line 1049
      goto case_120;
    }
#line 1054
    if ((int )*(optarg + 0) == 104) {
#line 1054
      goto case_104;
    }
#line 1054
    if ((int )*(optarg + 0) == 72) {
#line 1054
      goto case_104;
    }
#line 1059
    if ((int )*(optarg + 0) == 110) {
#line 1059
      goto case_110;
    }
#line 1059
    if ((int )*(optarg + 0) == 78) {
#line 1059
      goto case_110;
    }
#line 1063
    goto switch_default;
    case_120: /* CIL Label */ 
    case_88: /* CIL Label */ 
#line 1050
    opts.flow_str = (char *)"xon/xoff";
#line 1051
    opts.flow = (enum flowcntrl_e )2;
#line 1052
    goto switch_break___0;
    case_104: /* CIL Label */ 
    case_72: /* CIL Label */ 
#line 1055
    opts.flow_str = (char *)"RTS/CTS";
#line 1056
    opts.flow = (enum flowcntrl_e )1;
#line 1057
    goto switch_break___0;
    case_110: /* CIL Label */ 
    case_78: /* CIL Label */ 
#line 1060
    opts.flow_str = (char *)"none";
#line 1061
    opts.flow = (enum flowcntrl_e )0;
#line 1062
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1064
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--flow \'%c\' ignored.\n",
            (int )*(optarg + 0));
#line 1065
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--flow can be one off: \'x\', \'h\', or \'n\'\n");
    }
#line 1066
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1068
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 1070
    opts.baud = atoi((char const   *)optarg);
    }
#line 1071
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 1074
    if ((int )*(optarg + 0) == 101) {
#line 1074
      goto case_101___0;
    }
#line 1078
    if ((int )*(optarg + 0) == 111) {
#line 1078
      goto case_111;
    }
#line 1082
    if ((int )*(optarg + 0) == 110) {
#line 1082
      goto case_110___0;
    }
#line 1086
    goto switch_default___0;
    case_101___0: /* CIL Label */ 
#line 1075
    opts.parity_str = (char *)"even";
#line 1076
    opts.parity = (enum parity_e )1;
#line 1077
    goto switch_break___1;
    case_111: /* CIL Label */ 
#line 1079
    opts.parity_str = (char *)"odd";
#line 1080
    opts.parity = (enum parity_e )2;
#line 1081
    goto switch_break___1;
    case_110___0: /* CIL Label */ 
#line 1083
    opts.parity_str = (char *)"none";
#line 1084
    opts.parity = (enum parity_e )0;
#line 1085
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 1087
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--parity \'%c\' ignored.\n",
            (int )*(optarg + 0));
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--parity can be one off: \'o\', \'e\', or \'n\'\n");
    }
#line 1089
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1091
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 1094
    if ((int )*(optarg + 0) == 53) {
#line 1094
      goto case_53;
    }
#line 1097
    if ((int )*(optarg + 0) == 54) {
#line 1097
      goto case_54;
    }
#line 1100
    if ((int )*(optarg + 0) == 55) {
#line 1100
      goto case_55;
    }
#line 1103
    if ((int )*(optarg + 0) == 56) {
#line 1103
      goto case_56;
    }
#line 1106
    goto switch_default___1;
    case_53: /* CIL Label */ 
#line 1095
    opts.databits = 5;
#line 1096
    goto switch_break___2;
    case_54: /* CIL Label */ 
#line 1098
    opts.databits = 6;
#line 1099
    goto switch_break___2;
    case_55: /* CIL Label */ 
#line 1101
    opts.databits = 7;
#line 1102
    goto switch_break___2;
    case_56: /* CIL Label */ 
#line 1104
    opts.databits = 8;
#line 1105
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 1107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--databits \'%c\' ignored.\n",
            (int )*(optarg + 0));
#line 1108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--databits can be one off: 5, 6, 7 or 8\n");
    }
#line 1109
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1111
    goto switch_break;
    case_104___0: /* CIL Label */ 
    {
#line 1113
    show_usage(*(argv + 0));
#line 1114
    exit(0);
    }
    switch_default___2: /* CIL Label */ 
    {
#line 1117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unrecognized option.\n");
#line 1118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Run with \'--help\'.\n");
#line 1119
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1123
  if (argc - optind < 1) {
    {
#line 1124
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No port given\n");
#line 1125
    exit(1);
    }
  }
  {
#line 1127
  strncpy((char */* __restrict  */)(opts.port), (char const   */* __restrict  */)*(argv + optind),
          sizeof(opts.port) - 1UL);
#line 1128
  opts.port[sizeof(opts.port) - 1UL] = (char )'\000';
#line 1130
  printf((char const   */* __restrict  */)"picocom v%s\n", "1.7");
#line 1131
  printf((char const   */* __restrict  */)"\n");
#line 1132
  printf((char const   */* __restrict  */)"port is        : %s\n", opts.port);
#line 1133
  printf((char const   */* __restrict  */)"flowcontrol    : %s\n", opts.flow_str);
#line 1134
  printf((char const   */* __restrict  */)"baudrate is    : %d\n", opts.baud);
#line 1135
  printf((char const   */* __restrict  */)"parity is      : %s\n", opts.parity_str);
#line 1136
  printf((char const   */* __restrict  */)"databits are   : %d\n", opts.databits);
#line 1137
  printf((char const   */* __restrict  */)"escape is      : C-%c\n", (97 + (int )opts.escape) - 1);
  }
#line 1138
  if (opts.lecho) {
#line 1138
    tmp = "yes";
  } else {
#line 1138
    tmp = "no";
  }
  {
#line 1138
  printf((char const   */* __restrict  */)"local echo is  : %s\n", tmp);
  }
#line 1139
  if (opts.noinit) {
#line 1139
    tmp___0 = "yes";
  } else {
#line 1139
    tmp___0 = "no";
  }
  {
#line 1139
  printf((char const   */* __restrict  */)"noinit is      : %s\n", tmp___0);
  }
#line 1140
  if (opts.noreset) {
#line 1140
    tmp___1 = "yes";
  } else {
#line 1140
    tmp___1 = "no";
  }
  {
#line 1140
  printf((char const   */* __restrict  */)"noreset is     : %s\n", tmp___1);
  }
#line 1142
  if (opts.nolock) {
#line 1142
    tmp___2 = "yes";
  } else {
#line 1142
    tmp___2 = "no";
  }
  {
#line 1142
  printf((char const   */* __restrict  */)"nolock is      : %s\n", tmp___2);
#line 1144
  printf((char const   */* __restrict  */)"send_cmd is    : %s\n", opts.send_cmd);
#line 1145
  printf((char const   */* __restrict  */)"receive_cmd is : %s\n", opts.receive_cmd);
#line 1146
  printf((char const   */* __restrict  */)"imap is        : ");
#line 1146
  print_map(opts.imap);
#line 1147
  printf((char const   */* __restrict  */)"omap is        : ");
#line 1147
  print_map(opts.omap);
#line 1148
  printf((char const   */* __restrict  */)"emap is        : ");
#line 1148
  print_map(opts.emap);
#line 1149
  printf((char const   */* __restrict  */)"\n");
  }
#line 1150
  return;
}
}
#line 1155 "/home/wheatley/newnew/temp/picocom-1.7/picocom.c"
int main(int argc , char **argv ) 
{ 
  int r ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  int *tmp___10 ;
  char const   *tmp___11 ;
  int *tmp___12 ;
  char const   *tmp___13 ;

  {
  {
#line 1160
  parse_args(argc, argv);
#line 1162
  establish_signal_handlers();
#line 1164
  r = term_lib_init();
  }
#line 1165
  if (r < 0) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    tmp___0 = term_strerror(term_errno, *tmp);
#line 1166
    fatal("term_init failed: %s", tmp___0);
    }
  }
#line 1169
  if (! opts.nolock) {
    {
#line 1169
    uucp_lockname("/var/lock", (char const   *)(opts.port));
    }
  }
  {
#line 1170
  tmp___3 = uucp_lock();
  }
#line 1170
  if (tmp___3 < 0) {
    {
#line 1171
    tmp___1 = __errno_location();
#line 1171
    tmp___2 = strerror(*tmp___1);
#line 1171
    fatal("cannot lock %s: %s", opts.port, tmp___2);
    }
  }
  {
#line 1174
  tty_fd = open((char const   *)(opts.port), 2306);
  }
#line 1175
  if (tty_fd < 0) {
    {
#line 1176
    tmp___4 = __errno_location();
#line 1176
    tmp___5 = strerror(*tmp___4);
#line 1176
    fatal("cannot open %s: %s", opts.port, tmp___5);
    }
  }
#line 1178
  if (opts.noinit) {
    {
#line 1179
    r = term_add(tty_fd);
    }
  } else {
    {
#line 1181
    r = term_set(tty_fd, 1, opts.baud, opts.parity, opts.databits, opts.flow, 1, ! opts.noreset);
    }
  }
#line 1190
  if (r < 0) {
    {
#line 1191
    tmp___6 = __errno_location();
#line 1191
    tmp___7 = term_strerror(term_errno, *tmp___6);
#line 1191
    fatal("failed to add device %s: %s", opts.port, tmp___7);
    }
  }
  {
#line 1193
  r = term_apply(tty_fd);
  }
#line 1194
  if (r < 0) {
    {
#line 1195
    tmp___8 = __errno_location();
#line 1195
    tmp___9 = term_strerror(term_errno, *tmp___8);
#line 1195
    fatal("failed to config device %s: %s", opts.port, tmp___9);
    }
  }
  {
#line 1198
  r = term_add(0);
  }
#line 1199
  if (r < 0) {
    {
#line 1200
    tmp___10 = __errno_location();
#line 1200
    tmp___11 = term_strerror(term_errno, *tmp___10);
#line 1200
    fatal("failed to add I/O device: %s", tmp___11);
    }
  }
  {
#line 1202
  term_set_raw(0);
#line 1203
  r = term_apply(0);
  }
#line 1204
  if (r < 0) {
    {
#line 1205
    tmp___12 = __errno_location();
#line 1205
    tmp___13 = term_strerror(term_errno, *tmp___12);
#line 1205
    fatal("failed to set I/O device to raw mode: %s", tmp___13);
    }
  }
  {
#line 1208
  fd_printf(1, "Terminal ready\r\n");
#line 1209
  loop();
#line 1211
  fd_printf(1, "\r\n");
  }
#line 1212
  if (opts.noreset) {
    {
#line 1213
    fd_printf(1, "Skipping tty reset...\r\n");
#line 1214
    term_erase(tty_fd);
    }
  }
  {
#line 1217
  fd_printf(1, "Thanks for using picocom\r\n");
#line 1219
  sleep(1U);
#line 1222
  uucp_unlock();
  }
#line 1225
  return (0);
}
}
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 770 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 76
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) cfmakeraw)(struct termios *__termios_p ) ;
#line 80
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsendbreak)(int __fd ,
                                                                                  int __duration ) ;
#line 86
extern int tcdrain(int __fd ) ;
#line 90
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflush)(int __fd ,
                                                                              int __queue_selector ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 173 "/home/wheatley/newnew/temp/picocom-1.7/term.h"
int term_errno  ;
#line 205
int term_perror(char const   *prefix ) ;
#line 281
int term_replace(int oldfd , int newfd ) ;
#line 306
int term_revert(int fd ) ;
#line 332
int term_refresh(int fd ) ;
#line 437
int term_set_local(int fd , int local ) ;
#line 506
int term_drain(int fd ) ;
#line 46 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
static struct term_s term  ;
#line 58 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
static char const   * const  term_err_str[20]  = 
#line 58
  {      (char const   */* const  */)"No error",      (char const   */* const  */)"Framework is uninitialized",      (char const   */* const  */)"Framework is full",      (char const   */* const  */)"Filedes not in the framework", 
        (char const   */* const  */)"Filedes already in the framework",      (char const   */* const  */)"Cannot install atexit handler",      (char const   */* const  */)"Filedes is not a tty",      (char const   */* const  */)"Cannot flush the device", 
        (char const   */* const  */)"Cannot get the device attributes",      (char const   */* const  */)"Cannot set the device attributes",      (char const   */* const  */)"Invalid baud rate",      (char const   */* const  */)"Cannot set the output speed", 
        (char const   */* const  */)"Cannot set the input speed",      (char const   */* const  */)"Invalid parity mode",      (char const   */* const  */)"Invalid number of databits",      (char const   */* const  */)"Invalid flowcontrol mode", 
        (char const   */* const  */)"Cannot lower DTR",      (char const   */* const  */)"Cannot raise DTR",      (char const   */* const  */)"Cannot drain the device",      (char const   */* const  */)"Cannot send break sequence"};
#line 81 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
static char term_err_buff[1024]  ;
#line 83 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
char const   *term_strerror(int terrnum , int errnum ) 
{ 
  char const   *rval ;
  char *tmp ;

  {
  {
#line 95
  if (terrnum == 19) {
#line 95
    goto case_19;
  }
#line 95
  if (terrnum == 18) {
#line 95
    goto case_19;
  }
#line 95
  if (terrnum == 12) {
#line 95
    goto case_19;
  }
#line 95
  if (terrnum == 11) {
#line 95
    goto case_19;
  }
#line 95
  if (terrnum == 9) {
#line 95
    goto case_19;
  }
#line 95
  if (terrnum == 8) {
#line 95
    goto case_19;
  }
#line 95
  if (terrnum == 7) {
#line 95
    goto case_19;
  }
#line 112
  if (terrnum == 17) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 16) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 15) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 14) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 13) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 10) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 6) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 5) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 4) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 3) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 2) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 1) {
#line 112
    goto case_17;
  }
#line 112
  if (terrnum == 0) {
#line 112
    goto case_17;
  }
#line 117
  goto switch_default;
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  {
#line 96
  tmp = strerror(errnum);
#line 96
  snprintf((char */* __restrict  */)(term_err_buff), sizeof(term_err_buff), (char const   */* __restrict  */)"%s: %s",
           term_err_str[terrnum], tmp);
#line 98
  rval = (char const   *)(term_err_buff);
  }
#line 99
  goto switch_break;
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 113
  snprintf((char */* __restrict  */)(term_err_buff), sizeof(term_err_buff), (char const   */* __restrict  */)"%s",
           term_err_str[terrnum]);
#line 115
  rval = (char const   *)(term_err_buff);
  }
#line 116
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 118
  rval = (char const   *)((void *)0);
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 122
  return (rval);
}
}
#line 125 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_perror(char const   *prefix ) 
{ 
  int *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  tmp = __errno_location();
#line 128
  tmp___0 = term_strerror(term_errno, *tmp);
#line 128
  tmp___1 = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s\n",
                    prefix, tmp___0);
  }
#line 128
  return (tmp___1);
}
}
#line 134 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
static int term_find_next_free(void) 
{ 
  int rval ;
  int i ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! term.init) {
#line 141
      term_errno = 1;
#line 142
      rval = -1;
#line 143
      goto while_break;
    }
#line 146
    i = 0;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      if (! (i < 16)) {
#line 146
        goto while_break___0;
      }
#line 147
      if (term.fd[i] == -1) {
#line 147
        goto while_break___0;
      }
#line 146
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 149
    if (i == 16) {
#line 150
      term_errno = 2;
#line 151
      rval = -1;
#line 152
      goto while_break;
    }
#line 155
    rval = i;
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (rval);
}
}
#line 163 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
static int term_find(int fd ) 
{ 
  int rval ;
  int i ;

  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! term.init) {
#line 170
      term_errno = 1;
#line 171
      rval = -1;
#line 172
      goto while_break;
    }
#line 175
    i = 0;
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 175
      if (! (i < 16)) {
#line 175
        goto while_break___0;
      }
#line 176
      if (term.fd[i] == fd) {
#line 176
        goto while_break___0;
      }
#line 175
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 178
    if (i == 16) {
#line 179
      term_errno = 3;
#line 180
      rval = -1;
#line 181
      goto while_break;
    }
#line 184
    rval = i;
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return (rval);
}
}
#line 192 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
static void term_exitfunc(void) 
{ 
  int r ;
  int i ;
  char *tname ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! term.init) {
#line 199
      goto while_break;
    }
#line 201
    i = 0;
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! (i < 16)) {
#line 201
        goto while_break___0;
      }
#line 202
      if (term.fd[i] == -1) {
#line 203
        goto __Cont;
      }
      {
#line 204
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 205
        r = tcflush(term.fd[i], 2);
        }
#line 206
        if (r < 0) {
#line 206
          goto while_break___1;
        }
        {
#line 207
        r = tcsetattr(term.fd[i], 2, (struct termios  const  *)(& term.origtermios[i]));
        }
#line 208
        if (r < 0) {
#line 208
          goto while_break___1;
        }
#line 204
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 210
      if (r < 0) {
        {
#line 213
        tname = ttyname(term.fd[i]);
        }
#line 214
        if (! tname) {
#line 214
          tname = (char *)"UNKNOWN";
        }
        {
#line 215
        tmp = __errno_location();
#line 215
        tmp___0 = strerror(*tmp);
#line 215
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: reset failed for dev %s: %s\n",
                "term_exitfunc", tname, tmp___0);
        }
      }
#line 218
      term.fd[i] = -1;
      __Cont: /* CIL Label */ 
#line 201
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 197
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 225 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_lib_init(void) 
{ 
  int rval ;
  int r ;
  int i ;
  char *tname ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 230
  rval = 0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (term.init) {
#line 235
      i = 0;
      {
#line 235
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 235
        if (! (i < 16)) {
#line 235
          goto while_break___0;
        }
#line 236
        if (term.fd[i] == -1) {
#line 237
          goto __Cont;
        }
        {
#line 238
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 239
          r = tcflush(term.fd[i], 2);
          }
#line 240
          if (r < 0) {
#line 240
            goto while_break___1;
          }
          {
#line 241
          r = tcsetattr(term.fd[i], 2, (struct termios  const  *)(& term.origtermios[i]));
          }
#line 242
          if (r < 0) {
#line 242
            goto while_break___1;
          }
#line 238
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 244
        if (r < 0) {
          {
#line 247
          tname = ttyname(term.fd[i]);
          }
#line 248
          if (! tname) {
#line 248
            tname = (char *)"UNKNOWN";
          }
          {
#line 249
          tmp = __errno_location();
#line 249
          tmp___0 = strerror(*tmp);
#line 249
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: reset failed for dev %s: %s\n",
                  "term_lib_init", tname, tmp___0);
          }
        }
#line 252
        term.fd[i] = -1;
        __Cont: /* CIL Label */ 
#line 235
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 256
      i = 0;
      {
#line 256
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 256
        if (! (i < 16)) {
#line 256
          goto while_break___2;
        }
#line 257
        term.fd[i] = -1;
#line 256
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 258
      tmp___1 = atexit(& term_exitfunc);
      }
#line 258
      if (tmp___1 != 0) {
#line 259
        term_errno = 5;
#line 260
        rval = -1;
#line 261
        goto while_break;
      }
#line 264
      term.init = 1;
    }
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (rval);
}
}
#line 273 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_add(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;
  int tmp ;

  {
#line 278
  rval = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 281
    i = term_find(fd);
    }
#line 282
    if (i >= 0) {
#line 283
      term_errno = 4;
#line 284
      rval = -1;
#line 285
      goto while_break;
    }
    {
#line 288
    tmp = isatty(fd);
    }
#line 288
    if (! tmp) {
#line 289
      term_errno = 6;
#line 290
      rval = -1;
#line 291
      goto while_break;
    }
    {
#line 294
    i = term_find_next_free();
    }
#line 295
    if (i < 0) {
#line 296
      rval = -1;
#line 297
      goto while_break;
    }
    {
#line 300
    r = tcgetattr(fd, & term.origtermios[i]);
    }
#line 301
    if (r < 0) {
#line 302
      term_errno = 8;
#line 303
      rval = -1;
#line 304
      goto while_break;
    }
#line 307
    term.currtermios[i] = term.origtermios[i];
#line 308
    term.nexttermios[i] = term.origtermios[i];
#line 309
    term.fd[i] = fd;
#line 280
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return (rval);
}
}
#line 317 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_remove(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;

  {
#line 322
  rval = 0;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 325
    i = term_find(fd);
    }
#line 326
    if (i < 0) {
#line 327
      rval = -1;
#line 328
      goto while_break;
    }
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 332
      r = tcflush(term.fd[i], 2);
      }
#line 333
      if (r < 0) {
#line 334
        term_errno = 7;
#line 335
        rval = -1;
#line 336
        goto while_break___0;
      }
      {
#line 338
      r = tcsetattr(term.fd[i], 2, (struct termios  const  *)(& term.origtermios[i]));
      }
#line 339
      if (r < 0) {
#line 340
        term_errno = 9;
#line 341
        rval = -1;
#line 342
        goto while_break___0;
      }
#line 331
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 346
    term.fd[i] = -1;
#line 324
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (rval);
}
}
#line 354 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_erase(int fd ) 
{ 
  int rval ;
  int i ;

  {
#line 359
  rval = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 362
    i = term_find(fd);
    }
#line 363
    if (i < 0) {
#line 364
      rval = -1;
#line 365
      goto while_break;
    }
#line 368
    term.fd[i] = -1;
#line 361
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return (rval);
}
}
#line 376 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_replace(int oldfd , int newfd ) 
{ 
  int rval ;
  int r ;
  int i ;

  {
#line 381
  rval = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    i = term_find(oldfd);
    }
#line 386
    if (i < 0) {
#line 387
      rval = -1;
#line 388
      goto while_break;
    }
    {
#line 391
    r = tcsetattr(newfd, 2, (struct termios  const  *)(& term.currtermios[i]));
    }
#line 392
    if (r < 0) {
#line 393
      term_errno = 9;
#line 394
      rval = -1;
#line 395
      goto while_break;
    }
#line 398
    term.fd[i] = newfd;
#line 383
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  return (rval);
}
}
#line 407 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_reset(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;

  {
#line 412
  rval = 0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 416
    i = term_find(fd);
    }
#line 417
    if (i < 0) {
#line 418
      rval = -1;
#line 419
      goto while_break;
    }
    {
#line 422
    r = tcflush(term.fd[i], 2);
    }
#line 423
    if (r < 0) {
#line 424
      term_errno = 7;
#line 425
      rval = -1;
#line 426
      goto while_break;
    }
    {
#line 428
    r = tcsetattr(term.fd[i], 2, (struct termios  const  *)(& term.origtermios[i]));
    }
#line 429
    if (r < 0) {
#line 430
      term_errno = 9;
#line 431
      rval = -1;
#line 432
      goto while_break;
    }
#line 435
    term.currtermios[i] = term.origtermios[i];
#line 436
    term.nexttermios[i] = term.origtermios[i];
#line 414
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  return (rval);
}
}
#line 444 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_revert(int fd ) 
{ 
  int rval ;
  int i ;

  {
#line 449
  rval = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 453
    i = term_find(fd);
    }
#line 454
    if (i < 0) {
#line 455
      rval = -1;
#line 456
      goto while_break;
    }
#line 459
    term.nexttermios[i] = term.currtermios[i];
#line 451
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return (rval);
}
}
#line 468 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_refresh(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;

  {
#line 473
  rval = 0;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 477
    i = term_find(fd);
    }
#line 478
    if (i < 0) {
#line 479
      rval = -1;
#line 480
      goto while_break;
    }
    {
#line 483
    r = tcgetattr(fd, & term.currtermios[i]);
    }
#line 484
    if (r < 0) {
#line 485
      term_errno = 8;
#line 486
      rval = -1;
#line 487
      goto while_break;
    }
#line 475
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  return (rval);
}
}
#line 497 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_apply(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;

  {
#line 502
  rval = 0;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 506
    i = term_find(fd);
    }
#line 507
    if (i < 0) {
#line 508
      rval = -1;
#line 509
      goto while_break;
    }
    {
#line 512
    r = tcsetattr(term.fd[i], 2, (struct termios  const  *)(& term.nexttermios[i]));
    }
#line 513
    if (r < 0) {
#line 514
      term_errno = 9;
#line 515
      rval = -1;
#line 516
      goto while_break;
    }
#line 519
    term.currtermios[i] = term.nexttermios[i];
#line 504
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  return (rval);
}
}
#line 528 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set_raw(int fd ) 
{ 
  int rval ;
  int i ;

  {
#line 533
  rval = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 537
    i = term_find(fd);
    }
#line 538
    if (i < 0) {
#line 539
      rval = -1;
#line 540
      goto while_break;
    }
    {
#line 544
    cfmakeraw(& term.nexttermios[i]);
#line 546
    term.nexttermios[i].c_cc[6] = (cc_t )1;
#line 547
    term.nexttermios[i].c_cc[5] = (cc_t )0;
    }
#line 535
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  return (rval);
}
}
#line 556 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set_baudrate(int fd , int baudrate ) 
{ 
  int rval ;
  int r ;
  int i ;
  speed_t spd ;
  struct termios tio ;

  {
#line 563
  rval = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 567
    i = term_find(fd);
    }
#line 568
    if (i < 0) {
#line 569
      rval = -1;
#line 570
      goto while_break;
    }
#line 573
    tio = term.nexttermios[i];
    {
#line 576
    if (baudrate == 0) {
#line 576
      goto case_0;
    }
#line 579
    if (baudrate == 50) {
#line 579
      goto case_50;
    }
#line 582
    if (baudrate == 75) {
#line 582
      goto case_75;
    }
#line 585
    if (baudrate == 110) {
#line 585
      goto case_110;
    }
#line 588
    if (baudrate == 134) {
#line 588
      goto case_134;
    }
#line 591
    if (baudrate == 150) {
#line 591
      goto case_150;
    }
#line 594
    if (baudrate == 200) {
#line 594
      goto case_200;
    }
#line 597
    if (baudrate == 300) {
#line 597
      goto case_300;
    }
#line 600
    if (baudrate == 600) {
#line 600
      goto case_600;
    }
#line 603
    if (baudrate == 1200) {
#line 603
      goto case_1200;
    }
#line 606
    if (baudrate == 1800) {
#line 606
      goto case_1800;
    }
#line 609
    if (baudrate == 2400) {
#line 609
      goto case_2400;
    }
#line 612
    if (baudrate == 4800) {
#line 612
      goto case_4800;
    }
#line 615
    if (baudrate == 9600) {
#line 615
      goto case_9600;
    }
#line 618
    if (baudrate == 19200) {
#line 618
      goto case_19200;
    }
#line 621
    if (baudrate == 38400) {
#line 621
      goto case_38400;
    }
#line 624
    if (baudrate == 57600) {
#line 624
      goto case_57600;
    }
#line 627
    if (baudrate == 115200) {
#line 627
      goto case_115200;
    }
#line 631
    if (baudrate == 230400) {
#line 631
      goto case_230400;
    }
#line 634
    if (baudrate == 460800) {
#line 634
      goto case_460800;
    }
#line 637
    if (baudrate == 921600) {
#line 637
      goto case_921600;
    }
#line 641
    goto switch_default;
    case_0: /* CIL Label */ 
#line 577
    spd = (speed_t )0;
#line 578
    goto switch_break;
    case_50: /* CIL Label */ 
#line 580
    spd = (speed_t )1;
#line 581
    goto switch_break;
    case_75: /* CIL Label */ 
#line 583
    spd = (speed_t )2;
#line 584
    goto switch_break;
    case_110: /* CIL Label */ 
#line 586
    spd = (speed_t )3;
#line 587
    goto switch_break;
    case_134: /* CIL Label */ 
#line 589
    spd = (speed_t )4;
#line 590
    goto switch_break;
    case_150: /* CIL Label */ 
#line 592
    spd = (speed_t )5;
#line 593
    goto switch_break;
    case_200: /* CIL Label */ 
#line 595
    spd = (speed_t )6;
#line 596
    goto switch_break;
    case_300: /* CIL Label */ 
#line 598
    spd = (speed_t )7;
#line 599
    goto switch_break;
    case_600: /* CIL Label */ 
#line 601
    spd = (speed_t )8;
#line 602
    goto switch_break;
    case_1200: /* CIL Label */ 
#line 604
    spd = (speed_t )9;
#line 605
    goto switch_break;
    case_1800: /* CIL Label */ 
#line 607
    spd = (speed_t )10;
#line 608
    goto switch_break;
    case_2400: /* CIL Label */ 
#line 610
    spd = (speed_t )11;
#line 611
    goto switch_break;
    case_4800: /* CIL Label */ 
#line 613
    spd = (speed_t )12;
#line 614
    goto switch_break;
    case_9600: /* CIL Label */ 
#line 616
    spd = (speed_t )13;
#line 617
    goto switch_break;
    case_19200: /* CIL Label */ 
#line 619
    spd = (speed_t )14;
#line 620
    goto switch_break;
    case_38400: /* CIL Label */ 
#line 622
    spd = (speed_t )15;
#line 623
    goto switch_break;
    case_57600: /* CIL Label */ 
#line 625
    spd = (speed_t )4097;
#line 626
    goto switch_break;
    case_115200: /* CIL Label */ 
#line 628
    spd = (speed_t )4098;
#line 629
    goto switch_break;
    case_230400: /* CIL Label */ 
#line 632
    spd = (speed_t )4099;
#line 633
    goto switch_break;
    case_460800: /* CIL Label */ 
#line 635
    spd = (speed_t )4100;
#line 636
    goto switch_break;
    case_921600: /* CIL Label */ 
#line 638
    spd = (speed_t )4103;
#line 639
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 642
    term_errno = 10;
#line 643
    rval = -1;
#line 644
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 646
    if (rval < 0) {
#line 646
      goto while_break;
    }
    {
#line 648
    r = cfsetospeed(& tio, spd);
    }
#line 649
    if (r < 0) {
#line 650
      term_errno = 11;
#line 651
      rval = -1;
#line 652
      goto while_break;
    }
    {
#line 655
    r = cfsetispeed(& tio, spd);
    }
#line 656
    if (r < 0) {
#line 657
      term_errno = 12;
#line 658
      rval = -1;
#line 659
      goto while_break;
    }
#line 662
    term.nexttermios[i] = tio;
#line 565
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  return (rval);
}
}
#line 671 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set_parity(int fd , enum parity_e parity ) 
{ 
  int rval ;
  int i ;
  struct termios *tiop ;

  {
#line 677
  rval = 0;
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 681
    i = term_find(fd);
    }
#line 682
    if (i < 0) {
#line 683
      rval = -1;
#line 684
      goto while_break;
    }
#line 687
    tiop = & term.nexttermios[i];
    {
#line 690
    if ((unsigned int )parity == 1U) {
#line 690
      goto case_1;
    }
#line 694
    if ((unsigned int )parity == 2U) {
#line 694
      goto case_2;
    }
#line 697
    if ((unsigned int )parity == 0U) {
#line 697
      goto case_0;
    }
#line 700
    goto switch_default;
    case_1: /* CIL Label */ 
#line 691
    tiop->c_cflag &= 4294966783U;
#line 692
    tiop->c_cflag |= 256U;
#line 693
    goto switch_break;
    case_2: /* CIL Label */ 
#line 695
    tiop->c_cflag |= 768U;
#line 696
    goto switch_break;
    case_0: /* CIL Label */ 
#line 698
    tiop->c_cflag &= 4294966527U;
#line 699
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 701
    term_errno = 13;
#line 702
    rval = -1;
#line 703
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 705
    if (rval < 0) {
#line 705
      goto while_break;
    }
#line 679
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return (rval);
}
}
#line 714 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set_databits(int fd , int databits ) 
{ 
  int rval ;
  int i ;
  struct termios *tiop ;

  {
#line 720
  rval = 0;
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 724
    i = term_find(fd);
    }
#line 725
    if (i < 0) {
#line 726
      rval = -1;
#line 727
      goto while_break;
    }
#line 730
    tiop = & term.nexttermios[i];
    {
#line 733
    if (databits == 5) {
#line 733
      goto case_5;
    }
#line 736
    if (databits == 6) {
#line 736
      goto case_6;
    }
#line 739
    if (databits == 7) {
#line 739
      goto case_7;
    }
#line 742
    if (databits == 8) {
#line 742
      goto case_8;
    }
#line 745
    goto switch_default;
    case_5: /* CIL Label */ 
#line 734
    tiop->c_cflag &= 4294967247U;
#line 735
    goto switch_break;
    case_6: /* CIL Label */ 
#line 737
    tiop->c_cflag = (tiop->c_cflag & 4294967247U) | 16U;
#line 738
    goto switch_break;
    case_7: /* CIL Label */ 
#line 740
    tiop->c_cflag = (tiop->c_cflag & 4294967247U) | 32U;
#line 741
    goto switch_break;
    case_8: /* CIL Label */ 
#line 743
    tiop->c_cflag = (tiop->c_cflag & 4294967247U) | 48U;
#line 744
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 746
    term_errno = 14;
#line 747
    rval = -1;
#line 748
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 750
    if (rval < 0) {
#line 750
      goto while_break;
    }
#line 722
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  return (rval);
}
}
#line 759 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set_flowcntrl(int fd , enum flowcntrl_e flowcntl ) 
{ 
  int rval ;
  int i ;
  struct termios *tiop ;

  {
#line 765
  rval = 0;
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 769
    i = term_find(fd);
    }
#line 770
    if (i < 0) {
#line 771
      rval = -1;
#line 772
      goto while_break;
    }
#line 775
    tiop = & term.nexttermios[i];
    {
#line 778
    if ((unsigned int )flowcntl == 1U) {
#line 778
      goto case_1;
    }
#line 782
    if ((unsigned int )flowcntl == 2U) {
#line 782
      goto case_2;
    }
#line 786
    if ((unsigned int )flowcntl == 0U) {
#line 786
      goto case_0;
    }
#line 790
    goto switch_default;
    case_1: /* CIL Label */ 
#line 779
    tiop->c_cflag |= 2147483648U;
#line 780
    tiop->c_iflag &= 4294960127U;
#line 781
    goto switch_break;
    case_2: /* CIL Label */ 
#line 783
    tiop->c_cflag &= 2147483647U;
#line 784
    tiop->c_iflag |= 5120U;
#line 785
    goto switch_break;
    case_0: /* CIL Label */ 
#line 787
    tiop->c_cflag &= 2147483647U;
#line 788
    tiop->c_iflag &= 4294960127U;
#line 789
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 791
    term_errno = 15;
#line 792
    rval = -1;
#line 793
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 795
    if (rval < 0) {
#line 795
      goto while_break;
    }
#line 767
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  return (rval);
}
}
#line 804 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set_local(int fd , int local ) 
{ 
  int rval ;
  int i ;
  struct termios *tiop ;

  {
#line 810
  rval = 0;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 814
    i = term_find(fd);
    }
#line 815
    if (i < 0) {
#line 816
      rval = -1;
#line 817
      goto while_break;
    }
#line 820
    tiop = & term.nexttermios[i];
#line 822
    if (local) {
#line 823
      tiop->c_cflag |= 2048U;
    } else {
#line 825
      tiop->c_cflag &= 4294965247U;
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 829
  return (rval);
}
}
#line 834 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set_hupcl(int fd , int on ) 
{ 
  int rval ;
  int i ;
  struct termios *tiop ;

  {
#line 840
  rval = 0;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 844
    i = term_find(fd);
    }
#line 845
    if (i < 0) {
#line 846
      rval = -1;
#line 847
      goto while_break;
    }
#line 850
    tiop = & term.nexttermios[i];
#line 852
    if (on) {
#line 853
      tiop->c_cflag |= 1024U;
    } else {
#line 855
      tiop->c_cflag &= 4294966271U;
    }
#line 842
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 859
  return (rval);
}
}
#line 864 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_set(int fd , int raw , int baud , enum parity_e parity , int bits , enum flowcntrl_e fc ,
             int local , int hup_close ) 
{ 
  int rval ;
  int r ;
  int i ;
  int ni ;
  struct termios tio ;

  {
#line 873
  rval = 0;
  {
#line 875
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 877
    i = term_find(fd);
    }
#line 878
    if (i < 0) {
      {
#line 879
      ni = term_add(fd);
      }
#line 880
      if (ni < 0) {
#line 881
        rval = -1;
#line 882
        goto while_break;
      }
    } else {
#line 885
      ni = i;
    }
#line 888
    tio = term.nexttermios[ni];
    {
#line 890
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 892
      if (raw) {
        {
#line 893
        r = term_set_raw(fd);
        }
#line 894
        if (r < 0) {
#line 894
          rval = -1;
#line 894
          goto while_break___0;
        }
      }
      {
#line 897
      r = term_set_baudrate(fd, baud);
      }
#line 898
      if (r < 0) {
#line 898
        rval = -1;
#line 898
        goto while_break___0;
      }
      {
#line 900
      r = term_set_parity(fd, parity);
      }
#line 901
      if (r < 0) {
#line 901
        rval = -1;
#line 901
        goto while_break___0;
      }
      {
#line 903
      r = term_set_databits(fd, bits);
      }
#line 904
      if (r < 0) {
#line 904
        rval = -1;
#line 904
        goto while_break___0;
      }
      {
#line 906
      r = term_set_flowcntrl(fd, fc);
      }
#line 907
      if (r < 0) {
#line 907
        rval = -1;
#line 907
        goto while_break___0;
      }
      {
#line 909
      r = term_set_local(fd, local);
      }
#line 910
      if (r < 0) {
#line 910
        rval = -1;
#line 910
        goto while_break___0;
      }
      {
#line 912
      r = term_set_hupcl(fd, hup_close);
      }
#line 913
      if (r < 0) {
#line 913
        rval = -1;
#line 913
        goto while_break___0;
      }
#line 890
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 917
    if (rval < 0) {
#line 918
      if (i < 0) {
#line 920
        term.fd[ni] = -1;
      } else {
#line 923
        term.nexttermios[ni] = tio;
      }
    }
#line 875
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  return (rval);
}
}
#line 933 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_pulse_dtr(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;
  int opins ;

  {
#line 938
  rval = 0;
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 942
    i = term_find(fd);
    }
#line 943
    if (i < 0) {
#line 944
      rval = -1;
#line 945
      goto while_break;
    }
    {
#line 950
    opins = 2;
#line 952
    r = ioctl(fd, 21527UL, & opins);
    }
#line 953
    if (r < 0) {
#line 954
      term_errno = 16;
#line 955
      rval = -1;
#line 956
      goto while_break;
    }
    {
#line 959
    sleep(1U);
#line 961
    r = ioctl(fd, 21526UL, & opins);
    }
#line 962
    if (r < 0) {
#line 963
      term_errno = 17;
#line 964
      rval = -1;
#line 965
      goto while_break;
    }
#line 940
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  return (rval);
}
}
#line 1009 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_raise_dtr(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;
  int opins ;

  {
#line 1014
  rval = 0;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1018
    i = term_find(fd);
    }
#line 1019
    if (i < 0) {
#line 1020
      rval = -1;
#line 1021
      goto while_break;
    }
    {
#line 1026
    opins = 2;
#line 1028
    r = ioctl(fd, 21526UL, & opins);
    }
#line 1029
    if (r < 0) {
#line 1030
      term_errno = 17;
#line 1031
      rval = -1;
#line 1032
      goto while_break;
    }
#line 1016
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1046
  return (rval);
}
}
#line 1052 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_lower_dtr(int fd ) 
{ 
  int rval ;
  int r ;
  int i ;
  int opins ;

  {
#line 1057
  rval = 0;
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1061
    i = term_find(fd);
    }
#line 1062
    if (i < 0) {
#line 1063
      rval = -1;
#line 1064
      goto while_break;
    }
    {
#line 1069
    opins = 2;
#line 1071
    r = ioctl(fd, 21527UL, & opins);
    }
#line 1072
    if (r < 0) {
#line 1073
      term_errno = 16;
#line 1074
      rval = -1;
#line 1075
      goto while_break;
    }
#line 1059
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1103
  return (rval);
}
}
#line 1108 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_drain(int fd ) 
{ 
  int rval ;
  int r ;
  int *tmp ;

  {
#line 1113
  rval = 0;
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1117
    r = term_find(fd);
    }
#line 1118
    if (r < 0) {
#line 1119
      rval = -1;
#line 1120
      goto while_break;
    }
    {
#line 1123
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1124
      r = tcdrain(fd);
      }
#line 1123
      if (r < 0) {
        {
#line 1123
        tmp = __errno_location();
        }
#line 1123
        if (! (*tmp == 4)) {
#line 1123
          goto while_break___0;
        }
      } else {
#line 1123
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1126
    if (r < 0) {
#line 1127
      term_errno = 18;
#line 1128
      rval = -1;
#line 1129
      goto while_break;
    }
#line 1115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1134
  return (rval);
}
}
#line 1139 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_flush(int fd ) 
{ 
  int rval ;
  int r ;

  {
#line 1144
  rval = 0;
  {
#line 1146
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1148
    r = term_find(fd);
    }
#line 1149
    if (r < 0) {
#line 1150
      rval = -1;
#line 1151
      goto while_break;
    }
    {
#line 1154
    r = tcflush(fd, 2);
    }
#line 1155
    if (r < 0) {
#line 1156
      rval = -1;
#line 1157
      goto while_break;
    }
#line 1146
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1162
  return (rval);
}
}
#line 1167 "/home/wheatley/newnew/temp/picocom-1.7/term.c"
int term_break(int fd ) 
{ 
  int rval ;
  int r ;

  {
#line 1172
  rval = 0;
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1176
    r = term_find(fd);
    }
#line 1177
    if (r < 0) {
#line 1178
      rval = -1;
#line 1179
      goto while_break;
    }
    {
#line 1182
    r = tcsendbreak(fd, 0);
    }
#line 1183
    if (r < 0) {
#line 1184
      term_errno = 19;
#line 1185
      rval = -1;
#line 1186
      goto while_break;
    }
#line 1174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1191
  return (rval);
}
}
