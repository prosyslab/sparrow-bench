/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_28 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_28 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 4 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/util.h"
void print_hostname(void) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 8 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/util.c"
void print_hostname(void) 
{ 
  char hostname[255] ;
  struct hostent *h ;
  char const   *tmp ;

  {
  {
#line 13
  gethostname(hostname, sizeof(hostname));
#line 14
  h = gethostbyname((char const   *)(hostname));
  }
#line 15
  if (h) {
#line 15
    tmp = (char const   *)h->h_name;
  } else {
#line 15
    tmp = "(none)";
  }
  {
#line 15
  printf((char const   */* __restrict  */)"%s\n", tmp);
  }
#line 16
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 62 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) struct utmp *( __attribute__((__leaf__)) getutent)(void) ;
#line 65
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setutent)(void) ;
#line 68
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endutent)(void) ;
#line 4 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.h"
void loadavg(double *av1 , double *av5 , double *av15 ) ;
#line 5
void print_uptime(void) ;
#line 11 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static char buf[128]  ;
#line 12 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static double av[3]  ;
#line 13
static int uptime(double *uptime_secs , double *idle_secs ) ;
#line 14
static char *sprint_uptime(void) ;
#line 16 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static int uptime(double *uptime_secs , double *idle_secs ) 
{ 
  double up ;
  double idle ;
  FILE *f ;
  int tmp ;

  {
  {
#line 17
  up = (double )0;
#line 17
  idle = (double )0;
#line 19
  f = fopen((char const   */* __restrict  */)"/proc/uptime", (char const   */* __restrict  */)"r");
  }
#line 20
  if (! f) {
#line 20
    return (-1);
  }
  {
#line 21
  tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lf %lf",
               & up, & idle);
  }
#line 21
  if (tmp < 2) {
    {
#line 22
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad data in /proc/uptime\n");
    }
#line 23
    return (0);
  }
  {
#line 25
  fclose(f);
  }
#line 26
  if (uptime_secs) {
#line 26
    *uptime_secs = up;
  }
#line 27
  if (idle_secs) {
#line 27
    *idle_secs = idle;
  }
#line 28
  return ((int )up);
}
}
#line 31 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
void loadavg(double *av1 , double *av5 , double *av15 ) 
{ 
  double avg_1 ;
  double avg_5 ;
  double avg_15 ;
  FILE *f ;
  int tmp ;

  {
  {
#line 32
  avg_1 = (double )0;
#line 32
  avg_5 = (double )0;
#line 32
  avg_15 = (double )0;
#line 35
  f = fopen((char const   */* __restrict  */)"/proc/loadavg", (char const   */* __restrict  */)"r");
  }
#line 36
  if (! f) {
#line 36
    return;
  }
  {
#line 37
  tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lf %lf %lf",
               & avg_1, & avg_5, & avg_15);
  }
#line 37
  if (tmp < 3) {
    {
#line 38
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad data in /proc/loadavg\n");
#line 39
    exit(1);
    }
  }
#line 41
  if (av1) {
#line 41
    *av1 = avg_1;
  }
#line 42
  if (av5) {
#line 42
    *av5 = avg_5;
  }
#line 43
  if (av15) {
#line 43
    *av15 = avg_15;
  }
#line 44
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static char *sprint_uptime(void) 
{ 
  struct utmp *utmpstruct ;
  int upminutes ;
  int uphours ;
  int updays ;
  int pos ;
  struct tm *realtime ;
  time_t realseconds ;
  int numuser ;
  double uptime_secs ;
  double idle_secs ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 57
  time(& realseconds);
#line 58
  realtime = localtime((time_t const   *)(& realseconds));
  }
#line 59
  if (realtime->tm_hour > 11) {
#line 59
    tmp = "pm";
  } else {
#line 59
    tmp = "am";
  }
#line 59
  if (realtime->tm_hour % 12) {
#line 59
    tmp___0 = realtime->tm_hour % 12;
  } else {
#line 59
    tmp___0 = 12;
  }
  {
#line 59
  pos = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)" %2d:%02d%s  ",
                tmp___0, realtime->tm_min, tmp);
#line 65
  uptime(& uptime_secs, & idle_secs);
#line 67
  updays = (int )uptime_secs / 86400;
#line 68
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"up ");
#line 69
  pos += 3;
  }
#line 70
  if (updays) {
#line 71
    if (updays != 1) {
#line 71
      tmp___1 = "s";
    } else {
#line 71
      tmp___1 = "";
    }
    {
#line 71
    tmp___2 = sprintf((char */* __restrict  */)(buf + pos), (char const   */* __restrict  */)"%d day%s, ",
                      updays, tmp___1);
#line 71
    pos += tmp___2;
    }
  }
#line 72
  upminutes = (int )uptime_secs / 60;
#line 73
  uphours = upminutes / 60;
#line 74
  uphours %= 24;
#line 75
  upminutes %= 60;
#line 76
  if (uphours) {
    {
#line 77
    tmp___3 = sprintf((char */* __restrict  */)(buf + pos), (char const   */* __restrict  */)"%2d:%02d, ",
                      uphours, upminutes);
#line 77
    pos += tmp___3;
    }
  } else {
    {
#line 79
    tmp___4 = sprintf((char */* __restrict  */)(buf + pos), (char const   */* __restrict  */)"%d min, ",
                      upminutes);
#line 79
    pos += tmp___4;
    }
  }
  {
#line 83
  numuser = 0;
#line 84
  setutent();
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    utmpstruct = getutent();
    }
#line 85
    if (! utmpstruct) {
#line 85
      goto while_break;
    }
#line 86
    if ((int )utmpstruct->ut_type == 7) {
#line 86
      if ((int )utmpstruct->ut_user[0] != 0) {
#line 88
        numuser ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  endutent();
  }
#line 92
  if (numuser == 1) {
#line 92
    tmp___5 = "";
  } else {
#line 92
    tmp___5 = "s";
  }
  {
#line 92
  tmp___6 = sprintf((char */* __restrict  */)(buf + pos), (char const   */* __restrict  */)"%2d user%s, ",
                    numuser, tmp___5);
#line 92
  pos += tmp___6;
#line 94
  loadavg(& av[0], & av[1], & av[2]);
#line 96
  tmp___7 = sprintf((char */* __restrict  */)(buf + pos), (char const   */* __restrict  */)" load average: %.2f, %.2f, %.2f",
                    av[0], av[1], av[2]);
#line 96
  pos += tmp___7;
  }
#line 99
  return (buf);
}
}
#line 102 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
void print_uptime(void) 
{ 
  char *tmp ;

  {
  {
#line 104
  tmp = sprint_uptime();
#line 104
  printf((char const   */* __restrict  */)"%s\n", tmp);
  }
#line 105
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 7 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/mrtg-load.c"
int main(int argc , char **argv ) 
{ 
  double avg ;
  int c ;
  int mult ;

  {
  {
#line 10
  mult = 1;
#line 11
  loadavg((double *)0, & avg, (double *)0);
  }
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 13
    c = getopt(argc, (char * const  *)argv, "m:");
    }
#line 13
    if (! (c > 0)) {
#line 13
      goto while_break;
    }
    {
#line 15
    if (c == 109) {
#line 15
      goto case_109;
    }
#line 16
    goto switch_default;
    case_109: /* CIL Label */ 
    {
#line 15
    mult = atoi((char const   *)optarg);
    }
#line 15
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 17
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: mrtg-load [-m multiplier]\n");
    }
#line 18
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 22
  printf((char const   */* __restrict  */)"0\n%.0f\n", avg * (double )mult);
#line 23
  print_uptime();
#line 24
  print_hostname();
  }
#line 25
  return (0);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 16 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/mrtg-apache.c"
static int quiet  =    0;
#line 18 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/mrtg-apache.c"
void print_accesses(char *hostname , int port , char *statusdir , int multiplier ) 
{ 
  int s ;
  int bytesread ;
  char buf___2[2048] ;
  char input[256] ;
  char *p ;
  struct sockaddr_in addr ;
  struct hostent *h ;
  struct hostent *tmp ;
  unsigned long accesses ;
  int tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 23
  tmp = gethostbyname((char const   *)hostname);
#line 23
  h = tmp;
#line 24
  accesses = 0UL;
#line 26
  memset((void *)(& addr), 0, sizeof(addr));
  }
#line 27
  if (! h) {
#line 28
    if (quiet) {
      {
#line 29
      printf((char const   */* __restrict  */)"0\n");
      }
#line 30
      return;
    } else {
      {
#line 32
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 32
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot resolve %s\n",
                hostname);
#line 32
        exit(1);
        }
#line 32
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 35
  addr.sin_family = (sa_family_t )2;
#line 36
  addr.sin_port = htons((uint16_t )port);
#line 37
  memcpy((void */* __restrict  */)(& addr.sin_addr), (void const   */* __restrict  */)*(h->h_addr_list + 0),
         sizeof(addr.sin_addr));
#line 39
  snprintf((char */* __restrict  */)(buf___2), sizeof(buf___2), (char const   */* __restrict  */)"GET /%s?auto\n",
           statusdir);
#line 41
  s = socket(2, 1, 0);
  }
#line 41
  if (s < 0) {
    {
#line 41
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 41
      perror("socket");
#line 41
      exit(1);
      }
#line 41
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 42
  tmp___0 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 42
  if (tmp___0 < 0) {
    {
#line 42
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 42
      perror("connect");
#line 42
      exit(1);
      }
#line 42
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 43
  tmp___1 = strlen((char const   *)(buf___2));
#line 43
  tmp___2 = write(s, (void const   *)(buf___2), tmp___1 + 1UL);
  }
#line 43
  if (tmp___2 < 0L) {
    {
#line 43
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 43
      perror("write");
#line 43
      exit(1);
      }
#line 43
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 45
  p = buf___2;
#line 45
  *p = (char)0;
  {
#line 46
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 46
    tmp___3 = read(s, (void *)(input), sizeof(input));
#line 46
    bytesread = (int )tmp___3;
    }
#line 46
    if (! (bytesread > 0)) {
#line 46
      goto while_break___3;
    }
#line 47
    if (sizeof(buf___2) - (unsigned long )(p - buf___2) > (unsigned long )bytesread) {
      {
#line 48
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(input),
             (size_t )bytesread);
#line 49
      p += bytesread;
      }
    } else {
#line 54
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 57
  p = strstr((char const   *)(buf___2), "Total Accesses: ");
  }
#line 57
  if (p) {
    {
#line 58
    accesses = strtoul((char const   */* __restrict  */)(p + 16), (char **/* __restrict  */)((void *)0),
                       0);
    }
  }
  {
#line 61
  printf((char const   */* __restrict  */)"%lu\n", accesses * (unsigned long )multiplier);
#line 63
  close(s);
  }
#line 64
  return;
}
}
#line 11 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static char buf___0[128]  ;
#line 12 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static double av___0[3]  ;
#line 13
static int uptime___0(double *uptime_secs , double *idle_secs ) ;
#line 14
static char *sprint_uptime___0(void) ;
#line 16 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static int uptime___0(double *uptime_secs , double *idle_secs ) 
{ 
  double up ;
  double idle ;
  FILE *f ;
  int tmp ;

  {
  {
#line 17
  up = (double )0;
#line 17
  idle = (double )0;
#line 19
  f = fopen((char const   */* __restrict  */)"/proc/uptime", (char const   */* __restrict  */)"r");
  }
#line 20
  if (! f) {
#line 20
    return (-1);
  }
  {
#line 21
  tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lf %lf",
               & up, & idle);
  }
#line 21
  if (tmp < 2) {
    {
#line 22
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad data in /proc/uptime\n");
    }
#line 23
    return (0);
  }
  {
#line 25
  fclose(f);
  }
#line 26
  if (uptime_secs) {
#line 26
    *uptime_secs = up;
  }
#line 27
  if (idle_secs) {
#line 27
    *idle_secs = idle;
  }
#line 28
  return ((int )up);
}
}
#line 46 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static char *sprint_uptime___0(void) 
{ 
  struct utmp *utmpstruct ;
  int upminutes ;
  int uphours ;
  int updays ;
  int pos ;
  struct tm *realtime ;
  time_t realseconds ;
  int numuser ;
  double uptime_secs ;
  double idle_secs ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 57
  time(& realseconds);
#line 58
  realtime = localtime((time_t const   *)(& realseconds));
  }
#line 59
  if (realtime->tm_hour > 11) {
#line 59
    tmp = "pm";
  } else {
#line 59
    tmp = "am";
  }
#line 59
  if (realtime->tm_hour % 12) {
#line 59
    tmp___0 = realtime->tm_hour % 12;
  } else {
#line 59
    tmp___0 = 12;
  }
  {
#line 59
  pos = sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" %2d:%02d%s  ",
                tmp___0, realtime->tm_min, tmp);
#line 65
  uptime___0(& uptime_secs, & idle_secs);
#line 67
  updays = (int )uptime_secs / 86400;
#line 68
  strcat((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"up ");
#line 69
  pos += 3;
  }
#line 70
  if (updays) {
#line 71
    if (updays != 1) {
#line 71
      tmp___1 = "s";
    } else {
#line 71
      tmp___1 = "";
    }
    {
#line 71
    tmp___2 = sprintf((char */* __restrict  */)(buf___0 + pos), (char const   */* __restrict  */)"%d day%s, ",
                      updays, tmp___1);
#line 71
    pos += tmp___2;
    }
  }
#line 72
  upminutes = (int )uptime_secs / 60;
#line 73
  uphours = upminutes / 60;
#line 74
  uphours %= 24;
#line 75
  upminutes %= 60;
#line 76
  if (uphours) {
    {
#line 77
    tmp___3 = sprintf((char */* __restrict  */)(buf___0 + pos), (char const   */* __restrict  */)"%2d:%02d, ",
                      uphours, upminutes);
#line 77
    pos += tmp___3;
    }
  } else {
    {
#line 79
    tmp___4 = sprintf((char */* __restrict  */)(buf___0 + pos), (char const   */* __restrict  */)"%d min, ",
                      upminutes);
#line 79
    pos += tmp___4;
    }
  }
  {
#line 83
  numuser = 0;
#line 84
  setutent();
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    utmpstruct = getutent();
    }
#line 85
    if (! utmpstruct) {
#line 85
      goto while_break;
    }
#line 86
    if ((int )utmpstruct->ut_type == 7) {
#line 86
      if ((int )utmpstruct->ut_user[0] != 0) {
#line 88
        numuser ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  endutent();
  }
#line 92
  if (numuser == 1) {
#line 92
    tmp___5 = "";
  } else {
#line 92
    tmp___5 = "s";
  }
  {
#line 92
  tmp___6 = sprintf((char */* __restrict  */)(buf___0 + pos), (char const   */* __restrict  */)"%2d user%s, ",
                    numuser, tmp___5);
#line 92
  pos += tmp___6;
#line 94
  loadavg(& av___0[0], & av___0[1], & av___0[2]);
#line 96
  tmp___7 = sprintf((char */* __restrict  */)(buf___0 + pos), (char const   */* __restrict  */)" load average: %.2f, %.2f, %.2f",
                    av___0[0], av___0[1], av___0[2]);
#line 96
  pos += tmp___7;
  }
#line 99
  return (buf___0);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 7 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/mrtg-ip-acct.c"
void print_ipacct(char *dev , int packets ) 
{ 
  char buf___2[1024] ;
  char *p ;
  FILE *f ;
  unsigned long long in ;
  unsigned long long out ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 12
  in = 0ULL;
#line 12
  out = 0ULL;
#line 14
  f = fopen((char const   */* __restrict  */)"/proc/net/dev", (char const   */* __restrict  */)"r");
  }
#line 15
  if (! f) {
#line 15
    return;
  }
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 16
    tmp___2 = feof(f);
    }
#line 16
    if (tmp___2) {
#line 16
      goto while_break;
    }
    {
#line 17
    fgets((char */* __restrict  */)(buf___2), (int )sizeof(buf___2), (FILE */* __restrict  */)f);
#line 18
    p = buf___2;
    }
    {
#line 19
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 19
      tmp = __ctype_b_loc();
      }
#line 19
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 19
        goto while_break___0;
      }
#line 19
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 20
    tmp___0 = strlen((char const   *)dev);
#line 20
    tmp___1 = strncmp((char const   *)dev, (char const   *)p, tmp___0);
    }
#line 20
    if (tmp___1 == 0) {
      {
#line 21
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 21
        if (! ((int )*p != 58)) {
#line 21
          goto while_break___1;
        }
#line 21
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 21
      p ++;
#line 22
      if (packets) {
        {
#line 23
        sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%*d %Lu %*d %*d %*d %*d %*d %*d %*d %Lu %*d %*d %*d %*d %*d %*d",
               & in, & out);
        }
      } else {
        {
#line 25
        sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%Lu %*d %*d %*d %*d %*d %*d %*d %Lu %*d %*d %*d %*d %*d %*d %*d",
               & in, & out);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 28
  fclose(f);
#line 30
  printf((char const   */* __restrict  */)"%Lu\n%Lu\n", in, out);
  }
#line 31
  return;
}
}
#line 11 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static char buf___1[128]  ;
#line 12 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static double av___1[3]  ;
#line 13
static int uptime___1(double *uptime_secs , double *idle_secs ) ;
#line 14
static char *sprint_uptime___1(void) ;
#line 16 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static int uptime___1(double *uptime_secs , double *idle_secs ) 
{ 
  double up ;
  double idle ;
  FILE *f ;
  int tmp ;

  {
  {
#line 17
  up = (double )0;
#line 17
  idle = (double )0;
#line 19
  f = fopen((char const   */* __restrict  */)"/proc/uptime", (char const   */* __restrict  */)"r");
  }
#line 20
  if (! f) {
#line 20
    return (-1);
  }
  {
#line 21
  tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lf %lf",
               & up, & idle);
  }
#line 21
  if (tmp < 2) {
    {
#line 22
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad data in /proc/uptime\n");
    }
#line 23
    return (0);
  }
  {
#line 25
  fclose(f);
  }
#line 26
  if (uptime_secs) {
#line 26
    *uptime_secs = up;
  }
#line 27
  if (idle_secs) {
#line 27
    *idle_secs = idle;
  }
#line 28
  return ((int )up);
}
}
#line 46 "/home/wheatley/newnew/temp/mrtgutils-0.8.1ubuntu1/uptime.c"
static char *sprint_uptime___1(void) 
{ 
  struct utmp *utmpstruct ;
  int upminutes ;
  int uphours ;
  int updays ;
  int pos ;
  struct tm *realtime ;
  time_t realseconds ;
  int numuser ;
  double uptime_secs ;
  double idle_secs ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 57
  time(& realseconds);
#line 58
  realtime = localtime((time_t const   *)(& realseconds));
  }
#line 59
  if (realtime->tm_hour > 11) {
#line 59
    tmp = "pm";
  } else {
#line 59
    tmp = "am";
  }
#line 59
  if (realtime->tm_hour % 12) {
#line 59
    tmp___0 = realtime->tm_hour % 12;
  } else {
#line 59
    tmp___0 = 12;
  }
  {
#line 59
  pos = sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)" %2d:%02d%s  ",
                tmp___0, realtime->tm_min, tmp);
#line 65
  uptime___1(& uptime_secs, & idle_secs);
#line 67
  updays = (int )uptime_secs / 86400;
#line 68
  strcat((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"up ");
#line 69
  pos += 3;
  }
#line 70
  if (updays) {
#line 71
    if (updays != 1) {
#line 71
      tmp___1 = "s";
    } else {
#line 71
      tmp___1 = "";
    }
    {
#line 71
    tmp___2 = sprintf((char */* __restrict  */)(buf___1 + pos), (char const   */* __restrict  */)"%d day%s, ",
                      updays, tmp___1);
#line 71
    pos += tmp___2;
    }
  }
#line 72
  upminutes = (int )uptime_secs / 60;
#line 73
  uphours = upminutes / 60;
#line 74
  uphours %= 24;
#line 75
  upminutes %= 60;
#line 76
  if (uphours) {
    {
#line 77
    tmp___3 = sprintf((char */* __restrict  */)(buf___1 + pos), (char const   */* __restrict  */)"%2d:%02d, ",
                      uphours, upminutes);
#line 77
    pos += tmp___3;
    }
  } else {
    {
#line 79
    tmp___4 = sprintf((char */* __restrict  */)(buf___1 + pos), (char const   */* __restrict  */)"%d min, ",
                      upminutes);
#line 79
    pos += tmp___4;
    }
  }
  {
#line 83
  numuser = 0;
#line 84
  setutent();
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    utmpstruct = getutent();
    }
#line 85
    if (! utmpstruct) {
#line 85
      goto while_break;
    }
#line 86
    if ((int )utmpstruct->ut_type == 7) {
#line 86
      if ((int )utmpstruct->ut_user[0] != 0) {
#line 88
        numuser ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  endutent();
  }
#line 92
  if (numuser == 1) {
#line 92
    tmp___5 = "";
  } else {
#line 92
    tmp___5 = "s";
  }
  {
#line 92
  tmp___6 = sprintf((char */* __restrict  */)(buf___1 + pos), (char const   */* __restrict  */)"%2d user%s, ",
                    numuser, tmp___5);
#line 92
  pos += tmp___6;
#line 94
  loadavg(& av___1[0], & av___1[1], & av___1[2]);
#line 96
  tmp___7 = sprintf((char */* __restrict  */)(buf___1 + pos), (char const   */* __restrict  */)" load average: %.2f, %.2f, %.2f",
                    av___1[0], av___1[1], av___1[2]);
#line 96
  pos += tmp___7;
  }
#line 99
  return (buf___1);
}
}
