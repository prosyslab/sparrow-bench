/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.h"
struct _hfsvol_;
#line 30 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.h"
typedef struct _hfsvol_ hfsvol;
#line 31
struct _hfsfile_;
#line 31 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.h"
typedef struct _hfsfile_ hfsfile;
#line 32
struct _hfsdir_;
#line 32 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.h"
typedef struct _hfsdir_ hfsdir;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef signed char Char;
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef signed char SignedByte;
#line 25 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef short Integer;
#line 26 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef unsigned short UInteger;
#line 27 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef long LongInt;
#line 28 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef unsigned long ULongInt;
#line 30 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef char Str31[32];
#line 31 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef long OSType;
#line 47 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_Partition_29 {
   Integer pmSig ;
   Integer pmSigPad ;
   LongInt pmMapBlkCnt ;
   LongInt pmPyPartStart ;
   LongInt pmPartBlkCnt ;
   Char pmPartName[33] ;
   Char pmParType[33] ;
   LongInt pmLgDataStart ;
   LongInt pmDataCnt ;
   LongInt pmPartStatus ;
   LongInt pmLgBootStart ;
   LongInt pmBootSize ;
   LongInt pmBootAddr ;
   LongInt pmBootAddr2 ;
   LongInt pmBootEntry ;
   LongInt pmBootEntry2 ;
   LongInt pmBootCksum ;
   Char pmProcessor[17] ;
   Integer pmPad[188] ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_Partition_29 Partition;
#line 91 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_ExtDescriptor_31 {
   UInteger xdrStABN ;
   UInteger xdrNumABlks ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_ExtDescriptor_31 ExtDescriptor;
#line 96 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef ExtDescriptor ExtDataRec[3];
#line 98 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_ExtKeyRec_32 {
   SignedByte xkrKeyLen ;
   SignedByte xkrFkType ;
   ULongInt xkrFNum ;
   UInteger xkrFABN ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_ExtKeyRec_32 ExtKeyRec;
#line 105 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_CatKeyRec_33 {
   SignedByte ckrKeyLen ;
   SignedByte ckrResrv1 ;
   ULongInt ckrParID ;
   Str31 ckrCName ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_CatKeyRec_33 CatKeyRec;
#line 112 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_Point_34 {
   Integer v ;
   Integer h ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_Point_34 Point;
#line 117 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_Rect_35 {
   Integer top ;
   Integer left ;
   Integer bottom ;
   Integer right ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_Rect_35 Rect;
#line 124 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_DInfo_36 {
   Rect frRect ;
   Integer frFlags ;
   Point frLocation ;
   Integer frView ;
};
#line 124 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_DInfo_36 DInfo;
#line 131 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_DXInfo_37 {
   Point frScroll ;
   LongInt frOpenChain ;
   Integer frUnused ;
   Integer frComment ;
   LongInt frPutAway ;
};
#line 131 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_DXInfo_37 DXInfo;
#line 139 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_FInfo_38 {
   OSType fdType ;
   OSType fdCreator ;
   Integer fdFlags ;
   Point fdLocation ;
   Integer fdFldr ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_FInfo_38 FInfo;
#line 147 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_FXInfo_39 {
   Integer fdIconID ;
   Integer fdUnused[4] ;
   Integer fdComment ;
   LongInt fdPutAway ;
};
#line 147 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_FXInfo_39 FXInfo;
#line 154 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_MDB_40 {
   Integer drSigWord ;
   LongInt drCrDate ;
   LongInt drLsMod ;
   Integer drAtrb ;
   UInteger drNmFls ;
   UInteger drVBMSt ;
   UInteger drAllocPtr ;
   UInteger drNmAlBlks ;
   ULongInt drAlBlkSiz ;
   ULongInt drClpSiz ;
   UInteger drAlBlSt ;
   LongInt drNxtCNID ;
   UInteger drFreeBks ;
   char drVN[28] ;
   LongInt drVolBkUp ;
   Integer drVSeqNum ;
   ULongInt drWrCnt ;
   ULongInt drXTClpSiz ;
   ULongInt drCTClpSiz ;
   UInteger drNmRtDirs ;
   ULongInt drFilCnt ;
   ULongInt drDirCnt ;
   LongInt drFndrInfo[8] ;
   UInteger drEmbedSigWord ;
   ExtDescriptor drEmbedExtent ;
   ULongInt drXTFlSize ;
   ExtDataRec drXTExtRec ;
   ULongInt drCTFlSize ;
   ExtDataRec drCTExtRec ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_MDB_40 MDB;
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_dir_44 {
   Integer dirFlags ;
   UInteger dirVal ;
   ULongInt dirDirID ;
   LongInt dirCrDat ;
   LongInt dirMdDat ;
   LongInt dirBkDat ;
   DInfo dirUsrInfo ;
   DXInfo dirFndrInfo ;
   LongInt dirResrv[4] ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_fil_45 {
   SignedByte filFlags ;
   SignedByte filTyp ;
   FInfo filUsrWds ;
   ULongInt filFlNum ;
   UInteger filStBlk ;
   ULongInt filLgLen ;
   ULongInt filPyLen ;
   UInteger filRStBlk ;
   ULongInt filRLgLen ;
   ULongInt filRPyLen ;
   LongInt filCrDat ;
   LongInt filMdDat ;
   LongInt filBkDat ;
   FXInfo filFndrInfo ;
   UInteger filClpSize ;
   ExtDataRec filExtRec ;
   ExtDataRec filRExtRec ;
   LongInt filResrv ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_dthd_46 {
   LongInt thdResrv[2] ;
   ULongInt thdParID ;
   Str31 thdCName ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_fthd_47 {
   LongInt fthdResrv[2] ;
   ULongInt fthdParID ;
   Str31 fthdCName ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
union __anonunion_u_43 {
   struct __anonstruct_dir_44 dir ;
   struct __anonstruct_fil_45 fil ;
   struct __anonstruct_dthd_46 dthd ;
   struct __anonstruct_fthd_47 fthd ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_CatDataRec_42 {
   SignedByte cdrType ;
   SignedByte cdrResrv2 ;
   union __anonunion_u_43 u ;
};
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_CatDataRec_42 CatDataRec;
#line 245 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_NodeDescriptor_48 {
   ULongInt ndFLink ;
   ULongInt ndBLink ;
   SignedByte ndType ;
   SignedByte ndNHeight ;
   UInteger ndNRecs ;
   Integer ndResv2 ;
};
#line 245 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_NodeDescriptor_48 NodeDescriptor;
#line 261 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_BTHdrRec_50 {
   UInteger bthDepth ;
   ULongInt bthRoot ;
   ULongInt bthNRecs ;
   ULongInt bthFNode ;
   ULongInt bthLNode ;
   UInteger bthNodeSize ;
   UInteger bthKeyLen ;
   ULongInt bthNNodes ;
   ULongInt bthFree ;
   SignedByte bthResv[76] ;
};
#line 261 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_BTHdrRec_50 BTHdrRec;
#line 56 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
typedef unsigned char byte;
#line 57 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
typedef byte block[512];
#line 59 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
struct _bucket_ {
   int flags ;
   unsigned int count ;
   unsigned long bnum ;
   block *data ;
   struct _bucket_ *cnext ;
   struct _bucket_ *cprev ;
   struct _bucket_ *hnext ;
   struct _bucket_ **hprev ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
typedef struct _bucket_ bucket;
#line 80 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
struct __anonstruct_bcache_51 {
   struct _hfsvol_ *vol ;
   bucket *tail ;
   unsigned int hits ;
   unsigned int misses ;
   bucket chain[128] ;
   bucket *hash[32] ;
   block pool[128] ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
typedef struct __anonstruct_bcache_51 bcache;
#line 130 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
struct _hfsfile_ {
   struct _hfsvol_ *vol ;
   unsigned long parid ;
   char name[32] ;
   CatDataRec cat ;
   ExtDataRec ext ;
   unsigned int fabn ;
   int fork ;
   unsigned long pos ;
   int flags ;
   struct _hfsfile_ *prev ;
   struct _hfsfile_ *next ;
};
#line 149
struct _btree_;
#line 149 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
struct _node_ {
   struct _btree_ *bt ;
   unsigned long nnum ;
   NodeDescriptor nd ;
   int rnum ;
   UInteger roff[36] ;
   block data ;
};
#line 149 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
typedef struct _node_ node;
#line 159 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
struct _hfsdir_ {
   struct _hfsvol_ *vol ;
   unsigned long dirid ;
   node n ;
   struct _hfsvol_ *vptr ;
   struct _hfsdir_ *prev ;
   struct _hfsdir_ *next ;
};
#line 173 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
struct _btree_ {
   hfsfile f ;
   node hdrnd ;
   BTHdrRec hdr ;
   byte *map ;
   unsigned long mapsz ;
   int flags ;
   void (*keyunpack)(byte const   * , void * ) ;
   int (*keycompare)(void const   * , void const   * ) ;
};
#line 173 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
typedef struct _btree_ btree;
#line 187 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
struct _hfsvol_ {
   void *priv ;
   int flags ;
   int pnum ;
   unsigned long vstart ;
   unsigned long vlen ;
   unsigned int lpa ;
   bcache *cache ;
   MDB mdb ;
   block *vbm ;
   unsigned short vbmsz ;
   btree ext ;
   btree cat ;
   unsigned long cwd ;
   int refs ;
   hfsfile *files ;
   hfsdir *dirs ;
   struct _hfsvol_ *prev ;
   struct _hfsvol_ *next ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 34 "libhfs/hfs.h"
struct __anonstruct_hfsvolent_25 {
   char name[28] ;
   int flags ;
   unsigned long totbytes ;
   unsigned long freebytes ;
   unsigned long alblocksz ;
   unsigned long clumpsz ;
   unsigned long numfiles ;
   unsigned long numdirs ;
   time_t crdate ;
   time_t mddate ;
   time_t bkdate ;
   unsigned long blessed ;
};
#line 34 "libhfs/hfs.h"
typedef struct __anonstruct_hfsvolent_25 hfsvolent;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.h"
struct __anonstruct_mountent_32 {
   char vname[28] ;
   long vcrdate ;
   char *path ;
   int partno ;
   char *cwd ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.h"
typedef struct __anonstruct_mountent_32 mountent;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 54 "libhfs/hfs.h"
struct __anonstruct_fdlocation_27 {
   short v ;
   short h ;
};
#line 54 "libhfs/hfs.h"
struct __anonstruct_file_29 {
   unsigned long dsize ;
   unsigned long rsize ;
   char type[5] ;
   char creator[5] ;
};
#line 54 "libhfs/hfs.h"
struct __anonstruct_rect_31 {
   short top ;
   short left ;
   short bottom ;
   short right ;
};
#line 54 "libhfs/hfs.h"
struct __anonstruct_dir_30 {
   unsigned short valence ;
   struct __anonstruct_rect_31 rect ;
};
#line 54 "libhfs/hfs.h"
union __anonunion_u_28 {
   struct __anonstruct_file_29 file ;
   struct __anonstruct_dir_30 dir ;
};
#line 54 "libhfs/hfs.h"
struct __anonstruct_hfsdirent_26 {
   char name[32] ;
   int flags ;
   unsigned long cnid ;
   unsigned long parid ;
   time_t crdate ;
   time_t mddate ;
   time_t bkdate ;
   short fdflags ;
   struct __anonstruct_fdlocation_27 fdlocation ;
   union __anonunion_u_28 u ;
};
#line 54 "libhfs/hfs.h"
typedef struct __anonstruct_hfsdirent_26 hfsdirent;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.h"
struct __anonstruct_dlist_21 {
   char *mem ;
   size_t memsz ;
   char **eltend ;
   char *strs ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.h"
typedef struct __anonstruct_dlist_21 dlist;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.h"
typedef unsigned short UCS2;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.h"
struct _darray_;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.h"
typedef struct _darray_ darray;
#line 31 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
struct _darray_ {
   char *mem ;
   size_t memsz ;
   char *eltend ;
   size_t elemsz ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef char Str15[16];
#line 33 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_Block0_28 {
   Integer sbSig ;
   Integer sbBlkSize ;
   LongInt sbBlkCount ;
   Integer sbDevType ;
   Integer sbDevId ;
   LongInt sbData ;
   Integer sbDrvrCount ;
   LongInt ddBlock ;
   Integer ddSize ;
   Integer ddType ;
   Integer ddPad[243] ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_Block0_28 Block0;
#line 69 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
struct __anonstruct_BootBlkHdr_30 {
   Integer bbID ;
   LongInt bbEntry ;
   Integer bbVersion ;
   Integer bbPageFlags ;
   Str15 bbSysName ;
   Str15 bbShellName ;
   Str15 bbDbg1Name ;
   Str15 bbDbg2Name ;
   Str15 bbScreenName ;
   Str15 bbHelloName ;
   Str15 bbScrapName ;
   Integer bbCntFCBs ;
   Integer bbCntEvts ;
   LongInt bb128KSHeap ;
   LongInt bb256KSHeap ;
   LongInt bbSysHeapSize ;
   Integer filler ;
   LongInt bbSysHeapExtra ;
   LongInt bbSysHeapFract ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/apple.h"
typedef struct __anonstruct_BootBlkHdr_30 BootBlkHdr;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
struct __anonstruct_list_37 {
   char const   *name ;
   int (*func)(int  , char ** ) ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.h"
struct __anonstruct_dstring_21 {
   char *str ;
   size_t len ;
   size_t space ;
   char sbuf[50] ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.h"
typedef struct __anonstruct_dstring_21 dstring;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
struct _queueent_ {
   char *path ;
   hfsdirent dirent ;
   void (*free)(struct _queueent_ * ) ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
typedef struct _queueent_ queueent;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 47 "/usr/include/fcntl.h"
typedef __off_t off_t;
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.h"
typedef int (*cpifunc)(char const   * , hfsvol * , char const   * );
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.h"
typedef int (*cpofunc)(hfsvol * , char const   * , char const   * );
#line 53 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.c"
struct __anonstruct_exts_36 {
   char const   *ext ;
   int (*func)(char const   * , hfsvol * , char const   * ) ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 117 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.h"
char const   *hfs_error ;
#line 226 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
hfsvol *hfs_mounts ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.h"
void v_init(hfsvol *vol , int flags ) ;
#line 24
int v_open(hfsvol *vol , char const   *path , int mode ) ;
#line 25
int v_flush(hfsvol *vol ) ;
#line 26
int v_close(hfsvol *vol ) ;
#line 28
int v_same(hfsvol *vol , char const   *path ) ;
#line 29
int v_geometry(hfsvol *vol , int pnum ) ;
#line 31
int v_readmdb(hfsvol *vol ) ;
#line 32
int v_writemdb(hfsvol *vol ) ;
#line 34
int v_readvbm(hfsvol *vol ) ;
#line 35
int v_writevbm(hfsvol *vol ) ;
#line 37
int v_mount(hfsvol *vol ) ;
#line 38
int v_dirty(hfsvol *vol ) ;
#line 40
int v_catsearch(hfsvol *vol , unsigned long parid , char const   *name___1 , CatDataRec *data ,
                char *cname , node *np ) ;
#line 42
int v_extsearch(hfsfile *file___0 , unsigned int fabn , ExtDataRec *data , node *np ) ;
#line 44
int v_getthread(hfsvol *vol , unsigned long id , CatDataRec *thread , node *np , int type ) ;
#line 51
int v_putcatrec(CatDataRec const   *data , node *np ) ;
#line 52
int v_putextrec(ExtDataRec const   *data , node *np ) ;
#line 54
int v_allocblocks(hfsvol *vol , ExtDescriptor *blocks ) ;
#line 55
int v_freeblocks(hfsvol *vol , ExtDescriptor const   *blocks ) ;
#line 57
int v_resolve(hfsvol **vol , char const   *path , CatDataRec *data , long *parid ,
              char *fname , node *np ) ;
#line 59
int v_adjvalence(hfsvol *vol , unsigned long parid , int isdir , int adj ) ;
#line 60
int v_mkdir(hfsvol *vol , unsigned long parid , char const   *name___1 ) ;
#line 62
int v_scavenge(hfsvol *vol ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.h"
int d_relstring(char const   *str1 , char const   *str2 ) ;
#line 58
unsigned long d_mtime(time_t ltime ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.h"
int b_init(hfsvol *vol ) ;
#line 23
int b_flush(hfsvol *vol ) ;
#line 24
int b_finish(hfsvol *vol ) ;
#line 29
int b_readlb(hfsvol *vol , unsigned long bnum , block *bp ) ;
#line 30
int b_writelb(hfsvol *vol , unsigned long bnum , block const   *bp ) ;
#line 33
int b_writeab(hfsvol *vol , unsigned int anum , unsigned int index___0 , block const   *bp ) ;
#line 35
unsigned long b_size(hfsvol *vol ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.h"
int l_getmdb(hfsvol *vol , MDB *mdb , int backup ) ;
#line 44
int l_putmdb(hfsvol *vol , MDB const   *mdb , int backup ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/medium.h"
int m_findpmentry(hfsvol *vol , char const   *type , Partition *map , unsigned long *start ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.h"
void f_init(hfsfile *file___0 , hfsvol *vol , long cnid , char const   *name___1 ) ;
#line 28
void f_selectfork(hfsfile *file___0 , int fork ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.h"
int bt_getnode(node *np , btree *bt , unsigned long nnum ) ;
#line 23
int bt_putnode(node *np ) ;
#line 25
int bt_readhdr(btree *bt ) ;
#line 26
int bt_writehdr(btree *bt ) ;
#line 28
int bt_space(btree *bt , unsigned int nrecs ) ;
#line 30
int bt_insert(btree *bt , byte const   *record , unsigned int reclen ) ;
#line 33
int bt_search(btree *bt , byte const   *key , node *np ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.h"
void r_packcatkey(CatKeyRec const   *key , byte *pkey , unsigned int *len ) ;
#line 23
void r_unpackcatkey(byte const   *pkey , CatKeyRec *key ) ;
#line 25
void r_packextkey(ExtKeyRec const   *key , byte *pkey , unsigned int *len ) ;
#line 26
void r_unpackextkey(byte const   *pkey , ExtKeyRec *key ) ;
#line 28
int r_comparecatkeys(CatKeyRec const   *key1 , CatKeyRec const   *key2 ) ;
#line 29
int r_compareextkeys(ExtKeyRec const   *key1 , ExtKeyRec const   *key2 ) ;
#line 31
void r_packcatdata(CatDataRec const   *data , byte *pdata , unsigned int *len ) ;
#line 32
void r_unpackcatdata(byte const   *pdata , CatDataRec *data ) ;
#line 34
void r_packextdata(ExtDataRec const   *data , byte *pdata , unsigned int *len ) ;
#line 35
void r_unpackextdata(byte const   *pdata , ExtDataRec *data ) ;
#line 37
void r_makecatkey(CatKeyRec *key , unsigned long parid , char const   *name___1 ) ;
#line 38
void r_makeextkey(ExtKeyRec *key , int fork , unsigned long fnum , unsigned int fabn ) ;
#line 40
void r_packcatrec(CatKeyRec const   *key , CatDataRec const   *data , byte *precord ,
                  unsigned int *len ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.h"
int os_open(void **priv , char const   *path , int mode ) ;
#line 23
int os_close(void **priv ) ;
#line 25
int os_same(void **priv , char const   *path ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
void v_init(hfsvol *vol , int flags ) 
{ 
  btree *ext ;
  btree *cat ;

  {
  {
#line 48
  ext = & vol->ext;
#line 49
  cat = & vol->cat;
#line 51
  vol->priv = (void *)0;
#line 52
  vol->flags = flags & 65280;
#line 54
  vol->pnum = -1;
#line 55
  vol->vstart = 0UL;
#line 56
  vol->vlen = 0UL;
#line 57
  vol->lpa = 0U;
#line 59
  vol->cache = (bcache *)0;
#line 61
  vol->vbm = (block *)0;
#line 62
  vol->vbmsz = (unsigned short)0;
#line 64
  f_init(& ext->f, vol, 3L, "extents overflow");
#line 66
  ext->map = (byte *)0;
#line 67
  ext->mapsz = 0UL;
#line 68
  ext->flags = 0;
#line 70
  ext->keyunpack = (void (*)(byte const   * , void * ))(& r_unpackextkey);
#line 71
  ext->keycompare = (int (*)(void const   * , void const   * ))(& r_compareextkeys);
#line 73
  f_init(& cat->f, vol, 4L, "catalog");
#line 75
  cat->map = (byte *)0;
#line 76
  cat->mapsz = 0UL;
#line 77
  cat->flags = 0;
#line 79
  cat->keyunpack = (void (*)(byte const   * , void * ))(& r_unpackcatkey);
#line 80
  cat->keycompare = (int (*)(void const   * , void const   * ))(& r_comparecatkeys);
#line 82
  vol->cwd = 2UL;
#line 84
  vol->refs = 0;
#line 85
  vol->files = (hfsfile *)0;
#line 86
  vol->dirs = (hfsdir *)0;
#line 88
  vol->prev = (struct _hfsvol_ *)0;
#line 89
  vol->next = (struct _hfsvol_ *)0;
  }
#line 90
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_open(hfsvol *vol , char const   *path , int mode ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 98
  if (vol->flags & 1) {
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 99
      hfs_error = "volume already open";
#line 99
      tmp = __errno_location();
#line 99
      *tmp = 22;
      }
#line 99
      goto fail;
#line 99
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 101
  tmp___0 = os_open(& vol->priv, path, mode);
  }
#line 101
  if (tmp___0 == -1) {
#line 102
    goto fail;
  }
#line 104
  vol->flags |= 1;
#line 108
  if (! (vol->flags & 256)) {
    {
#line 108
    tmp___1 = b_init(vol);
    }
#line 108
    if (tmp___1 != -1) {
#line 110
      vol->flags |= 8;
    }
  }
#line 112
  return (0);
  fail: 
#line 115
  return (-1);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
static int flushvol(hfsvol *vol , int umount ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 125
  if (vol->flags & 4) {
#line 126
    goto done;
  }
#line 128
  if (vol->ext.flags & 1) {
    {
#line 128
    tmp = bt_writehdr(& vol->ext);
    }
#line 128
    if (tmp == -1) {
#line 130
      goto fail;
    }
  }
#line 132
  if (vol->cat.flags & 1) {
    {
#line 132
    tmp___0 = bt_writehdr(& vol->cat);
    }
#line 132
    if (tmp___0 == -1) {
#line 134
      goto fail;
    }
  }
#line 136
  if (vol->flags & 64) {
    {
#line 136
    tmp___1 = v_writevbm(vol);
    }
#line 136
    if (tmp___1 == -1) {
#line 138
      goto fail;
    }
  }
#line 140
  if (umount) {
#line 140
    if (! ((int )vol->mdb.drAtrb & (1 << 8))) {
#line 142
      vol->mdb.drAtrb = (Integer )((int )vol->mdb.drAtrb | (1 << 8));
#line 143
      vol->flags |= 16;
    }
  }
#line 146
  if (vol->flags & 48) {
    {
#line 146
    tmp___2 = v_writemdb(vol);
    }
#line 146
    if (tmp___2 == -1) {
#line 148
      goto fail;
    }
  }
  done: 
#line 151
  return (0);
  fail: 
#line 154
  return (-1);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_flush(hfsvol *vol ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 163
  tmp = flushvol(vol, 0);
  }
#line 163
  if (tmp == -1) {
#line 164
    goto fail;
  }
#line 166
  if (vol->flags & 8) {
    {
#line 166
    tmp___0 = b_flush(vol);
    }
#line 166
    if (tmp___0 == -1) {
#line 168
      goto fail;
    }
  }
#line 170
  return (0);
  fail: 
#line 173
  return (-1);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_close(hfsvol *vol ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 182
  result = 0;
#line 184
  if (! (vol->flags & 1)) {
#line 185
    goto done;
  }
#line 187
  if (vol->flags & 2) {
    {
#line 187
    tmp = flushvol(vol, 1);
    }
#line 187
    if (tmp == -1) {
#line 189
      result = -1;
    }
  }
#line 191
  if (vol->flags & 8) {
    {
#line 191
    tmp___0 = b_finish(vol);
    }
#line 191
    if (tmp___0 == -1) {
#line 193
      result = -1;
    }
  }
  {
#line 195
  tmp___1 = os_close(& vol->priv);
  }
#line 195
  if (tmp___1 == -1) {
#line 196
    result = -1;
  }
#line 198
  vol->flags &= -12;
#line 202
  if (vol->vbm) {
    {
#line 202
    free((void *)vol->vbm);
    }
  }
#line 204
  vol->vbm = (block *)0;
#line 205
  vol->vbmsz = (unsigned short)0;
#line 207
  if (vol->ext.map) {
    {
#line 207
    free((void *)vol->ext.map);
    }
  }
#line 208
  if (vol->cat.map) {
    {
#line 208
    free((void *)vol->cat.map);
    }
  }
#line 210
  vol->ext.map = (byte *)0;
#line 211
  vol->cat.map = (byte *)0;
  done: 
#line 214
  return (result);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_same(hfsvol *vol , char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 223
  tmp = os_same(& vol->priv, path);
  }
#line 223
  return (tmp);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_geometry(hfsvol *vol , int pnum ) 
{ 
  Partition map ;
  unsigned long bnum ;
  int found ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 233
  bnum = 0UL;
#line 236
  vol->pnum = pnum;
#line 238
  if (pnum == 0) {
    {
#line 240
    vol->vstart = 0UL;
#line 241
    vol->vlen = b_size(vol);
    }
#line 243
    if (vol->vlen == 0UL) {
#line 244
      goto fail;
    }
  } else {
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      tmp = pnum;
#line 248
      pnum --;
#line 248
      if (! tmp) {
#line 248
        goto while_break;
      }
      {
#line 250
      found = m_findpmentry(vol, "Apple_HFS", & map, & bnum);
      }
#line 251
      if (found == -1) {
#line 252
        goto fail;
      } else
#line 251
      if (! found) {
#line 252
        goto fail;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 255
    vol->vstart = (unsigned long )map.pmPyPartStart;
#line 256
    vol->vlen = (unsigned long )map.pmPartBlkCnt;
#line 258
    if (map.pmDataCnt) {
#line 260
      if ((unsigned long )map.pmLgDataStart + (unsigned long )map.pmDataCnt > vol->vlen) {
        {
#line 262
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 262
          hfs_error = "partition data overflows partition";
#line 262
          tmp___0 = __errno_location();
#line 262
          *tmp___0 = 22;
          }
#line 262
          goto fail;
#line 262
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 264
      vol->vstart += (unsigned long )map.pmLgDataStart;
#line 265
      vol->vlen = (unsigned long )map.pmDataCnt;
    }
#line 268
    if (vol->vlen == 0UL) {
      {
#line 269
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 269
        hfs_error = "volume partition is empty";
#line 269
        tmp___1 = __errno_location();
#line 269
        *tmp___1 = 22;
        }
#line 269
        goto fail;
#line 269
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 272
  if (vol->vlen < (unsigned long )(800 * (1024 >> 9))) {
    {
#line 273
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 273
      hfs_error = "volume is smaller than 800K";
#line 273
      tmp___2 = __errno_location();
#line 273
      *tmp___2 = 22;
      }
#line 273
      goto fail;
#line 273
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 275
  return (0);
  fail: 
#line 278
  return (-1);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_readmdb(hfsvol *vol ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 287
  tmp = l_getmdb(vol, & vol->mdb, 0);
  }
#line 287
  if (tmp == -1) {
#line 288
    goto fail;
  }
#line 290
  if ((int )vol->mdb.drSigWord != 16964) {
#line 292
    if ((int )vol->mdb.drSigWord == -11561) {
      {
#line 293
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 293
        hfs_error = "MFS volume format not supported";
#line 293
        tmp___0 = __errno_location();
#line 293
        *tmp___0 = 22;
        }
#line 293
        goto fail;
#line 293
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 295
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 295
        hfs_error = "not a Macintosh HFS volume";
#line 295
        tmp___1 = __errno_location();
#line 295
        *tmp___1 = 22;
        }
#line 295
        goto fail;
#line 295
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 298
  if (vol->mdb.drAlBlkSiz % 512UL != 0UL) {
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 299
      hfs_error = "bad volume allocation block size";
#line 299
      tmp___2 = __errno_location();
#line 299
      *tmp___2 = 22;
      }
#line 299
      goto fail;
#line 299
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 301
  vol->lpa = (unsigned int )(vol->mdb.drAlBlkSiz >> 9);
#line 305
  vol->ext.f.cat.u.fil.filStBlk = vol->mdb.drXTExtRec[0].xdrStABN;
#line 306
  vol->ext.f.cat.u.fil.filLgLen = vol->mdb.drXTFlSize;
#line 307
  vol->ext.f.cat.u.fil.filPyLen = vol->mdb.drXTFlSize;
#line 309
  vol->ext.f.cat.u.fil.filCrDat = vol->mdb.drCrDate;
#line 310
  vol->ext.f.cat.u.fil.filMdDat = vol->mdb.drLsMod;
#line 312
  memcpy((void */* __restrict  */)(& vol->ext.f.cat.u.fil.filExtRec), (void const   */* __restrict  */)(& vol->mdb.drXTExtRec),
         sizeof(ExtDataRec ));
#line 315
  f_selectfork(& vol->ext.f, 0);
#line 319
  vol->cat.f.cat.u.fil.filStBlk = vol->mdb.drCTExtRec[0].xdrStABN;
#line 320
  vol->cat.f.cat.u.fil.filLgLen = vol->mdb.drCTFlSize;
#line 321
  vol->cat.f.cat.u.fil.filPyLen = vol->mdb.drCTFlSize;
#line 323
  vol->cat.f.cat.u.fil.filCrDat = vol->mdb.drCrDate;
#line 324
  vol->cat.f.cat.u.fil.filMdDat = vol->mdb.drLsMod;
#line 326
  memcpy((void */* __restrict  */)(& vol->cat.f.cat.u.fil.filExtRec), (void const   */* __restrict  */)(& vol->mdb.drCTExtRec),
         sizeof(ExtDataRec ));
#line 329
  f_selectfork(& vol->cat.f, 0);
  }
#line 331
  return (0);
  fail: 
#line 334
  return (-1);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_writemdb(hfsvol *vol ) 
{ 
  time_t tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 343
  tmp = time((time_t *)0);
#line 343
  tmp___0 = d_mtime(tmp);
#line 343
  vol->mdb.drLsMod = (LongInt )tmp___0;
#line 345
  vol->mdb.drXTFlSize = vol->ext.f.cat.u.fil.filPyLen;
#line 346
  memcpy((void */* __restrict  */)(& vol->mdb.drXTExtRec), (void const   */* __restrict  */)(& vol->ext.f.cat.u.fil.filExtRec),
         sizeof(ExtDataRec ));
#line 349
  vol->mdb.drCTFlSize = vol->cat.f.cat.u.fil.filPyLen;
#line 350
  memcpy((void */* __restrict  */)(& vol->mdb.drCTExtRec), (void const   */* __restrict  */)(& vol->cat.f.cat.u.fil.filExtRec),
         sizeof(ExtDataRec ));
#line 353
  tmp___1 = l_putmdb(vol, (MDB const   *)(& vol->mdb), vol->flags & 32);
  }
#line 353
  if (tmp___1 == -1) {
#line 354
    goto fail;
  }
#line 356
  vol->flags &= -49;
#line 358
  return (0);
  fail: 
#line 361
  return (-1);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_readvbm(hfsvol *vol ) 
{ 
  unsigned int vbmst ;
  unsigned int vbmsz ;
  block *bp ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 370
  vbmst = (unsigned int )vol->mdb.drVBMSt;
#line 371
  vbmsz = (unsigned int )(((int )vol->mdb.drNmAlBlks + 4095) >> 12);
#line 376
  if ((unsigned int )vol->mdb.drAlBlSt - vbmst < vbmsz) {
    {
#line 377
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 377
      hfs_error = "volume bitmap collides with volume data";
#line 377
      tmp = __errno_location();
#line 377
      *tmp = 5;
      }
#line 377
      goto fail;
#line 377
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 379
  tmp___0 = malloc(sizeof(block ) * (unsigned long )vbmsz);
#line 379
  vol->vbm = (block *)tmp___0;
  }
#line 380
  if ((unsigned long )vol->vbm == (unsigned long )((block *)0)) {
    {
#line 381
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 381
      hfs_error = (char const   *)0;
#line 381
      tmp___1 = __errno_location();
#line 381
      *tmp___1 = 12;
      }
#line 381
      goto fail;
#line 381
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 383
  vol->vbmsz = (unsigned short )vbmsz;
#line 385
  bp = vol->vbm;
  {
#line 385
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 385
    tmp___4 = vbmsz;
#line 385
    vbmsz --;
#line 385
    if (! tmp___4) {
#line 385
      goto while_break___1;
    }
    {
#line 387
    tmp___2 = vbmst;
#line 387
    vbmst ++;
#line 387
    tmp___3 = b_readlb(vol, (unsigned long )tmp___2, bp);
    }
#line 387
    if (tmp___3 == -1) {
#line 388
      goto fail;
    }
#line 385
    bp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 391
  return (0);
  fail: 
#line 394
  if (vol->vbm) {
    {
#line 394
    free((void *)vol->vbm);
    }
  }
#line 396
  vol->vbm = (block *)0;
#line 397
  vol->vbmsz = (unsigned short)0;
#line 399
  return (-1);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_writevbm(hfsvol *vol ) 
{ 
  unsigned int vbmst ;
  unsigned int vbmsz ;
  block const   *bp ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 408
  vbmst = (unsigned int )vol->mdb.drVBMSt;
#line 409
  vbmsz = (unsigned int )vol->vbmsz;
#line 412
  bp = (block const   *)vol->vbm;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    tmp___1 = vbmsz;
#line 412
    vbmsz --;
#line 412
    if (! tmp___1) {
#line 412
      goto while_break;
    }
    {
#line 414
    tmp = vbmst;
#line 414
    vbmst ++;
#line 414
    tmp___0 = b_writelb(vol, (unsigned long )tmp, bp);
    }
#line 414
    if (tmp___0 == -1) {
#line 415
      goto fail;
    }
#line 412
    bp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  vol->flags &= -65;
#line 420
  return (0);
  fail: 
#line 423
  return (-1);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_mount(hfsvol *vol ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 434
  tmp = v_readmdb(vol);
  }
#line 434
  if (tmp == -1) {
#line 438
    goto fail;
  } else {
    {
#line 434
    tmp___0 = v_readvbm(vol);
    }
#line 434
    if (tmp___0 == -1) {
#line 438
      goto fail;
    } else {
      {
#line 434
      tmp___1 = bt_readhdr(& vol->ext);
      }
#line 434
      if (tmp___1 == -1) {
#line 438
        goto fail;
      } else {
        {
#line 434
        tmp___2 = bt_readhdr(& vol->cat);
        }
#line 434
        if (tmp___2 == -1) {
#line 438
          goto fail;
        }
      }
    }
  }
#line 440
  if (! ((int )vol->mdb.drAtrb & (1 << 8))) {
    {
#line 440
    tmp___3 = v_scavenge(vol);
    }
#line 440
    if (tmp___3 == -1) {
#line 442
      goto fail;
    }
  }
#line 444
  if ((int )vol->mdb.drAtrb & (1 << 15)) {
#line 445
    vol->flags |= 4;
  } else
#line 446
  if (vol->flags & 4) {
#line 447
    vol->mdb.drAtrb = (Integer )((int )vol->mdb.drAtrb | (1 << 7));
  } else {
#line 449
    vol->mdb.drAtrb = (Integer )((int )vol->mdb.drAtrb & ~ (1 << 7));
  }
#line 451
  vol->flags |= 2;
#line 453
  return (0);
  fail: 
#line 456
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_dirty(hfsvol *vol ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 465
  if ((int )vol->mdb.drAtrb & (1 << 8)) {
    {
#line 467
    vol->mdb.drAtrb = (Integer )((int )vol->mdb.drAtrb & ~ (1 << 8));
#line 468
    (vol->mdb.drWrCnt) ++;
#line 470
    tmp = v_writemdb(vol);
    }
#line 470
    if (tmp == -1) {
#line 471
      goto fail;
    }
#line 473
    if (vol->flags & 8) {
      {
#line 473
      tmp___0 = b_flush(vol);
      }
#line 473
      if (tmp___0 == -1) {
#line 475
        goto fail;
      }
    }
  }
#line 478
  return (0);
  fail: 
#line 481
  return (-1);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_catsearch(hfsvol *vol , unsigned long parid , char const   *name___1 , CatDataRec *data ,
                char *cname , node *np ) 
{ 
  CatKeyRec key ;
  byte pkey[sizeof(CatKeyRec )] ;
  byte const   *ptr ;
  node n ;
  int found ;

  {
#line 497
  if ((unsigned long )np == (unsigned long )((node *)0)) {
#line 498
    np = & n;
  }
  {
#line 500
  r_makecatkey(& key, parid, name___1);
#line 501
  r_packcatkey((CatKeyRec const   *)(& key), pkey, (unsigned int *)0);
#line 503
  found = bt_search(& vol->cat, (byte const   *)(pkey), np);
  }
#line 504
  if (found <= 0) {
#line 505
    return (found);
  }
#line 507
  ptr = (byte const   *)(np->data + (int )np->roff[np->rnum]);
#line 509
  if (cname) {
    {
#line 511
    r_unpackcatkey(ptr, & key);
#line 512
    strcpy((char */* __restrict  */)cname, (char const   */* __restrict  */)(key.ckrCName));
    }
  }
#line 515
  if (data) {
    {
#line 516
    r_unpackcatdata(ptr + (size_t )(((1 + (int )*ptr) + 1) & -2), data);
    }
  }
#line 518
  return (1);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_extsearch(hfsfile *file___0 , unsigned int fabn , ExtDataRec *data , node *np ) 
{ 
  ExtKeyRec key ;
  ExtDataRec extsave ;
  unsigned int fabnsave ;
  byte pkey[sizeof(ExtKeyRec )] ;
  byte const   *ptr ;
  node n ;
  int found ;

  {
#line 536
  if ((unsigned long )np == (unsigned long )((node *)0)) {
#line 537
    np = & n;
  }
  {
#line 539
  r_makeextkey(& key, file___0->fork, file___0->cat.u.fil.filFlNum, fabn);
#line 540
  r_packextkey((ExtKeyRec const   *)(& key), pkey, (unsigned int *)0);
#line 544
  memcpy((void */* __restrict  */)(& extsave), (void const   */* __restrict  */)(& file___0->ext),
         sizeof(ExtDataRec ));
#line 545
  fabnsave = file___0->fabn;
#line 547
  found = bt_search(& (file___0->vol)->ext, (byte const   *)(pkey), np);
#line 549
  memcpy((void */* __restrict  */)(& file___0->ext), (void const   */* __restrict  */)(& extsave),
         sizeof(ExtDataRec ));
#line 550
  file___0->fabn = fabnsave;
  }
#line 552
  if (found <= 0) {
#line 553
    return (found);
  }
#line 555
  if (data) {
    {
#line 557
    ptr = (byte const   *)(np->data + (int )np->roff[np->rnum]);
#line 558
    r_unpackextdata(ptr + (size_t )(((1 + (int )*ptr) + 1) & -2), data);
    }
  }
#line 561
  return (1);
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_getthread(hfsvol *vol , unsigned long id , CatDataRec *thread , node *np , int type ) 
{ 
  CatDataRec rec ;
  int found ;
  int *tmp ;

  {
#line 574
  if ((unsigned long )thread == (unsigned long )((CatDataRec *)0)) {
#line 575
    thread = & rec;
  }
  {
#line 577
  found = v_catsearch(vol, id, "", thread, (char *)0, np);
  }
#line 578
  if (found == 1) {
#line 578
    if ((int )thread->cdrType != type) {
      {
#line 579
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 579
        hfs_error = "bad thread record";
#line 579
        tmp = __errno_location();
#line 579
        *tmp = 5;
        }
#line 579
        goto fail;
#line 579
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 581
  return (found);
  fail: 
#line 584
  return (-1);
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_putcatrec(CatDataRec const   *data , node *np ) 
{ 
  byte pdata[sizeof(CatDataRec )] ;
  byte *ptr ;
  unsigned int len ;
  int tmp ;

  {
  {
#line 594
  len = 0U;
#line 596
  r_packcatdata(data, pdata, & len);
#line 598
  ptr = np->data + (int )np->roff[np->rnum];
#line 599
  memcpy((void */* __restrict  */)(ptr + (size_t )(((1 + (int )*((byte const   *)ptr)) + 1) & -2)),
         (void const   */* __restrict  */)(pdata), (size_t )len);
#line 601
  tmp = bt_putnode(np);
  }
#line 601
  return (tmp);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_putextrec(ExtDataRec const   *data , node *np ) 
{ 
  byte pdata[sizeof(ExtDataRec )] ;
  byte *ptr ;
  unsigned int len ;
  int tmp ;

  {
  {
#line 611
  len = 0U;
#line 613
  r_packextdata(data, pdata, & len);
#line 615
  ptr = np->data + (int )np->roff[np->rnum];
#line 616
  memcpy((void */* __restrict  */)(ptr + (size_t )(((1 + (int )*((byte const   *)ptr)) + 1) & -2)),
         (void const   */* __restrict  */)(pdata), (size_t )len);
#line 618
  tmp = bt_putnode(np);
  }
#line 618
  return (tmp);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_allocblocks(hfsvol *vol , ExtDescriptor *blocks ) 
{ 
  unsigned int request ;
  unsigned int found ;
  unsigned int foundat ;
  unsigned int start ;
  unsigned int end ;
  register unsigned int pt ;
  block *vbm ;
  int wrap ;
  int *tmp ;
  unsigned int mark ;
  int *tmp___0 ;
  int tmp___1 ;
  block b ;
  unsigned int i ;

  {
#line 630
  wrap = 0;
#line 632
  if ((int )vol->mdb.drFreeBks == 0) {
    {
#line 633
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 633
      hfs_error = "volume full";
#line 633
      tmp = __errno_location();
#line 633
      *tmp = 28;
      }
#line 633
      goto fail;
#line 633
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 635
  request = (unsigned int )blocks->xdrNumABlks;
#line 636
  found = 0U;
#line 637
  foundat = 0U;
#line 638
  start = (unsigned int )vol->mdb.drAllocPtr;
#line 639
  end = (unsigned int )vol->mdb.drNmAlBlks;
#line 640
  vbm = vol->vbm;
#line 646
  if (! ((int const   )*((byte const   *)vbm + (start >> 3)) & (int const   )(128 >> (start & 7U)))) {
    {
#line 648
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 648
      if (start > 0U) {
#line 648
        if (! (! ((int const   )*((byte const   *)vbm + ((start - 1U) >> 3)) & (int const   )(128 >> ((start - 1U) & 7U))))) {
#line 648
          goto while_break___0;
        }
      } else {
#line 648
        goto while_break___0;
      }
#line 649
      start --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 654
  pt = start;
  {
#line 656
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 662
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 662
      if (pt < end) {
#line 662
        if (! ((int const   )*((byte const   *)vbm + (pt >> 3)) & (int const   )(128 >> (pt & 7U)))) {
#line 662
          goto while_break___2;
        }
      } else {
#line 662
        goto while_break___2;
      }
#line 663
      pt ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 665
    if (wrap) {
#line 665
      if (pt >= start) {
#line 666
        goto while_break___1;
      }
    }
#line 670
    mark = pt;
    {
#line 671
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 671
      if (pt < end) {
#line 671
        if (pt - mark < request) {
#line 671
          if (! (! ((int const   )*((byte const   *)vbm + (pt >> 3)) & (int const   )(128 >> (pt & 7U))))) {
#line 671
            goto while_break___3;
          }
        } else {
#line 671
          goto while_break___3;
        }
      } else {
#line 671
        goto while_break___3;
      }
#line 672
      pt ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 674
    if (pt - mark > found) {
#line 676
      found = pt - mark;
#line 677
      foundat = mark;
    }
#line 680
    if (wrap) {
#line 680
      if (pt >= start) {
#line 681
        goto while_break___1;
      }
    }
#line 683
    if (pt == end) {
#line 684
      pt = 0U;
#line 684
      wrap = 1;
    }
#line 686
    if (found == request) {
#line 687
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 690
  if (found == 0U) {
#line 690
    goto _L;
  } else
#line 690
  if (found > (unsigned int )vol->mdb.drFreeBks) {
    _L: /* CIL Label */ 
    {
#line 691
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 691
      hfs_error = "bad volume bitmap or free block count";
#line 691
      tmp___0 = __errno_location();
#line 691
      *tmp___0 = 5;
      }
#line 691
      goto fail;
#line 691
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 693
  blocks->xdrStABN = (UInteger )foundat;
#line 694
  blocks->xdrNumABlks = (UInteger )found;
#line 696
  tmp___1 = v_dirty(vol);
  }
#line 696
  if (tmp___1 == -1) {
#line 697
    goto fail;
  }
#line 699
  vol->mdb.drAllocPtr = (UInteger )pt;
#line 700
  vol->mdb.drFreeBks = (UInteger )((unsigned int )vol->mdb.drFreeBks - found);
#line 702
  pt = foundat;
  {
#line 702
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 702
    if (! (pt < foundat + found)) {
#line 702
      goto while_break___5;
    }
#line 703
    *((byte *)vbm + (pt >> 3)) = (byte )((int )*((byte *)vbm + (pt >> 3)) | (128 >> (pt & 7U)));
#line 702
    pt ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 705
  vol->flags |= 80;
#line 707
  if (vol->flags & 1024) {
    {
#line 712
    memset((void *)(& b), 0, sizeof(b));
#line 714
    pt = foundat;
    }
    {
#line 714
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 714
      if (! (pt < foundat + found)) {
#line 714
        goto while_break___6;
      }
#line 716
      i = 0U;
      {
#line 716
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 716
        if (! (i < vol->lpa)) {
#line 716
          goto while_break___7;
        }
        {
#line 717
        b_writeab(vol, pt, i, (block const   *)(& b));
#line 716
        i ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 714
      pt ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 721
  return (0);
  fail: 
#line 724
  return (-1);
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_freeblocks(hfsvol *vol , ExtDescriptor const   *blocks ) 
{ 
  unsigned int start ;
  unsigned int len ;
  unsigned int pt ;
  block *vbm ;
  int tmp ;

  {
  {
#line 736
  start = (unsigned int )blocks->xdrStABN;
#line 737
  len = (unsigned int )blocks->xdrNumABlks;
#line 738
  vbm = vol->vbm;
#line 740
  tmp = v_dirty(vol);
  }
#line 740
  if (tmp == -1) {
#line 741
    goto fail;
  }
#line 743
  vol->mdb.drFreeBks = (UInteger )((unsigned int )vol->mdb.drFreeBks + len);
#line 745
  pt = start;
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! (pt < start + len)) {
#line 745
      goto while_break;
    }
#line 746
    *((byte *)vbm + (pt >> 3)) = (byte )((int )*((byte *)vbm + (pt >> 3)) & ~ (128 >> (pt & 7U)));
#line 745
    pt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  vol->flags |= 80;
#line 750
  return (0);
  fail: 
#line 753
  return (-1);
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_resolve(hfsvol **vol , char const   *path , CatDataRec *data , long *parid ,
              char *fname , node *np ) 
{ 
  unsigned long dirid ;
  char name___1[32] ;
  char *nptr ;
  int found ;
  int *tmp ;
  hfsvol *check ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 765
  found = 0;
#line 767
  if ((int const   )*path == 0) {
    {
#line 768
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 768
      hfs_error = "empty path";
#line 768
      tmp = __errno_location();
#line 768
      *tmp = 2;
      }
#line 768
      goto fail;
#line 768
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 770
  if (parid) {
#line 771
    *parid = 0L;
  }
  {
#line 773
  nptr = strchr(path, ':');
  }
#line 775
  if ((int const   )*path == 58) {
#line 775
    goto _L;
  } else
#line 775
  if ((unsigned long )nptr == (unsigned long )((char *)0)) {
    _L: /* CIL Label */ 
#line 777
    dirid = (*vol)->cwd;
#line 779
    if ((int const   )*path == 58) {
#line 780
      path ++;
    }
#line 782
    if ((int const   )*path == 0) {
      {
#line 784
      found = v_getthread(*vol, dirid, data, (node *)0, 3);
      }
#line 785
      if (found == -1) {
#line 786
        goto fail;
      }
#line 788
      if (found) {
#line 790
        if (parid) {
#line 791
          *parid = (long )data->u.dthd.thdParID;
        }
        {
#line 793
        found = v_catsearch(*vol, data->u.dthd.thdParID, (char const   *)(data->u.dthd.thdCName),
                            data, fname, np);
        }
#line 795
        if (found == -1) {
#line 796
          goto fail;
        }
      }
#line 799
      goto done;
    }
  } else {
#line 806
    dirid = 1UL;
#line 808
    if (nptr - (char *)path > 27L) {
      {
#line 809
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 809
        hfs_error = (char const   *)0;
#line 809
        tmp___0 = __errno_location();
#line 809
        *tmp___0 = 36;
        }
#line 809
        goto fail;
#line 809
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 811
    strncpy((char */* __restrict  */)(name___1), (char const   */* __restrict  */)path,
            (size_t )(nptr - (char *)path));
#line 812
    name___1[nptr - (char *)path] = (char)0;
#line 814
    check = hfs_mounts;
    }
    {
#line 814
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 814
      if (! check) {
#line 814
        goto while_break___1;
      }
      {
#line 816
      tmp___1 = d_relstring((char const   *)(check->mdb.drVN), (char const   *)(name___1));
      }
#line 816
      if (tmp___1 == 0) {
#line 818
        *vol = check;
#line 819
        goto while_break___1;
      }
#line 814
      check = check->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 824
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 826
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 826
      if (! ((int const   )*path == 58)) {
#line 826
        goto while_break___3;
      }
      {
#line 828
      path ++;
#line 830
      found = v_getthread(*vol, dirid, data, (node *)0, 3);
      }
#line 831
      if (found == -1) {
#line 832
        goto fail;
      } else
#line 833
      if (! found) {
#line 834
        goto done;
      }
#line 836
      dirid = data->u.dthd.thdParID;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 839
    if ((int const   )*path == 0) {
      {
#line 841
      found = v_getthread(*vol, dirid, data, (node *)0, 3);
      }
#line 842
      if (found == -1) {
#line 843
        goto fail;
      }
#line 845
      if (found) {
#line 847
        if (parid) {
#line 848
          *parid = (long )data->u.dthd.thdParID;
        }
        {
#line 850
        found = v_catsearch(*vol, data->u.dthd.thdParID, (char const   *)(data->u.dthd.thdCName),
                            data, fname, np);
        }
#line 852
        if (found == -1) {
#line 853
          goto fail;
        }
      }
#line 856
      goto done;
    }
#line 859
    nptr = name___1;
    {
#line 860
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 860
      if ((unsigned long )nptr < (unsigned long )((name___1 + sizeof(name___1)) - 1)) {
#line 860
        if (*path) {
#line 860
          if (! ((int const   )*path != 58)) {
#line 860
            goto while_break___4;
          }
        } else {
#line 860
          goto while_break___4;
        }
      } else {
#line 860
        goto while_break___4;
      }
#line 861
      tmp___2 = nptr;
#line 861
      nptr ++;
#line 861
      tmp___3 = path;
#line 861
      path ++;
#line 861
      *tmp___2 = (char )*tmp___3;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 863
    if (*path) {
#line 863
      if ((int const   )*path != 58) {
        {
#line 864
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 864
          hfs_error = (char const   *)0;
#line 864
          tmp___4 = __errno_location();
#line 864
          *tmp___4 = 36;
          }
#line 864
          goto fail;
#line 864
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
#line 866
    *nptr = (char)0;
#line 867
    if ((int const   )*path == 58) {
#line 868
      path ++;
    }
#line 870
    if (parid) {
#line 871
      *parid = (long )dirid;
    }
    {
#line 873
    found = v_catsearch(*vol, dirid, (char const   *)(name___1), data, fname, np);
    }
#line 874
    if (found == -1) {
#line 875
      goto fail;
    }
#line 877
    if (! found) {
#line 879
      if (*path) {
#line 879
        if (parid) {
#line 880
          *parid = 0L;
        }
      }
#line 882
      if ((int const   )*path == 0) {
#line 882
        if (fname) {
          {
#line 883
          strcpy((char */* __restrict  */)fname, (char const   */* __restrict  */)(name___1));
          }
        }
      }
#line 885
      goto done;
    }
    {
#line 890
    if ((int )data->cdrType == 1) {
#line 890
      goto case_1;
    }
#line 897
    if ((int )data->cdrType == 2) {
#line 897
      goto case_2;
    }
#line 903
    goto switch_default;
    case_1: /* CIL Label */ 
#line 891
    if ((int const   )*path == 0) {
#line 892
      goto done;
    }
#line 894
    dirid = data->u.dir.dirDirID;
#line 895
    goto switch_break;
    case_2: /* CIL Label */ 
#line 898
    if ((int const   )*path == 0) {
#line 899
      goto done;
    }
    {
#line 901
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 901
      hfs_error = "invalid pathname";
#line 901
      tmp___5 = __errno_location();
#line 901
      *tmp___5 = 20;
      }
#line 901
      goto fail;
#line 901
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    switch_default: /* CIL Label */ 
    {
#line 904
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 904
      hfs_error = "unexpected catalog record";
#line 904
      tmp___6 = __errno_location();
#line 904
      *tmp___6 = 5;
      }
#line 904
      goto fail;
#line 904
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  done: 
#line 909
  return (found);
  fail: 
#line 912
  return (-1);
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_adjvalence(hfsvol *vol , unsigned long parid , int isdir , int adj ) 
{ 
  node n ;
  CatDataRec data ;
  int result ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 923
  result = 0;
#line 925
  if (isdir) {
#line 926
    vol->mdb.drDirCnt += (ULongInt )adj;
  } else {
#line 928
    vol->mdb.drFilCnt += (ULongInt )adj;
  }
#line 930
  vol->flags |= 16;
#line 932
  if (parid == 2UL) {
#line 934
    if (isdir) {
#line 935
      vol->mdb.drNmRtDirs = (UInteger )((int )vol->mdb.drNmRtDirs + adj);
    } else {
#line 937
      vol->mdb.drNmFls = (UInteger )((int )vol->mdb.drNmFls + adj);
    }
  } else
#line 939
  if (parid == 1UL) {
#line 940
    goto done;
  }
  {
#line 942
  tmp___0 = v_getthread(vol, parid, & data, (node *)0, 3);
  }
#line 942
  if (tmp___0 <= 0) {
#line 942
    goto _L;
  } else {
    {
#line 942
    tmp___1 = v_catsearch(vol, data.u.dthd.thdParID, (char const   *)(data.u.dthd.thdCName),
                          & data, (char *)0, & n);
    }
#line 942
    if (tmp___1 <= 0) {
#line 942
      goto _L;
    } else
#line 942
    if ((int )data.cdrType != 1) {
      _L: /* CIL Label */ 
      {
#line 946
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 946
        hfs_error = "can\'t find parent directory";
#line 946
        tmp = __errno_location();
#line 946
        *tmp = 5;
        }
#line 946
        goto fail;
#line 946
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 948
  data.u.dir.dirVal = (UInteger )((int )data.u.dir.dirVal + adj);
#line 949
  tmp___2 = time((time_t *)0);
#line 949
  tmp___3 = d_mtime(tmp___2);
#line 949
  data.u.dir.dirMdDat = (LongInt )tmp___3;
#line 951
  result = v_putcatrec((CatDataRec const   *)(& data), & n);
  }
  done: 
#line 954
  return (result);
  fail: 
#line 957
  return (-1);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_mkdir(hfsvol *vol , unsigned long parid , char const   *name___1 ) 
{ 
  CatKeyRec key ;
  CatDataRec data ;
  unsigned long id ;
  byte record[sizeof(CatKeyRec ) + sizeof(CatDataRec )] ;
  unsigned int reclen ;
  int i ;
  int tmp ;
  LongInt tmp___0 ;
  time_t tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 973
  tmp = bt_space(& vol->cat, 2U);
  }
#line 973
  if (tmp == -1) {
#line 974
    goto fail;
  }
  {
#line 976
  tmp___0 = vol->mdb.drNxtCNID;
#line 976
  (vol->mdb.drNxtCNID) ++;
#line 976
  id = (unsigned long )tmp___0;
#line 977
  vol->flags |= 16;
#line 981
  data.cdrType = (SignedByte )1;
#line 982
  data.cdrResrv2 = (SignedByte )0;
#line 984
  data.u.dir.dirFlags = (Integer )0;
#line 985
  data.u.dir.dirVal = (UInteger )0;
#line 986
  data.u.dir.dirDirID = id;
#line 987
  tmp___1 = time((time_t *)0);
#line 987
  tmp___2 = d_mtime(tmp___1);
#line 987
  data.u.dir.dirCrDat = (LongInt )tmp___2;
#line 988
  data.u.dir.dirMdDat = data.u.dir.dirCrDat;
#line 989
  data.u.dir.dirBkDat = (LongInt )0;
#line 991
  memset((void *)(& data.u.dir.dirUsrInfo), 0, sizeof(data.u.dir.dirUsrInfo));
#line 992
  memset((void *)(& data.u.dir.dirFndrInfo), 0, sizeof(data.u.dir.dirFndrInfo));
#line 993
  i = 0;
  }
  {
#line 993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 993
    if (! (i < 4)) {
#line 993
      goto while_break;
    }
#line 994
    data.u.dir.dirResrv[i] = (LongInt )0;
#line 993
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 996
  r_makecatkey(& key, parid, name___1);
#line 997
  r_packcatrec((CatKeyRec const   *)(& key), (CatDataRec const   *)(& data), record,
               & reclen);
#line 999
  tmp___3 = bt_insert(& vol->cat, (byte const   *)(record), reclen);
  }
#line 999
  if (tmp___3 == -1) {
#line 1000
    goto fail;
  }
  {
#line 1004
  data.cdrType = (SignedByte )3;
#line 1005
  data.cdrResrv2 = (SignedByte )0;
#line 1007
  data.u.dthd.thdResrv[0] = (LongInt )0;
#line 1008
  data.u.dthd.thdResrv[1] = (LongInt )0;
#line 1009
  data.u.dthd.thdParID = parid;
#line 1010
  strcpy((char */* __restrict  */)(data.u.dthd.thdCName), (char const   */* __restrict  */)name___1);
#line 1012
  r_makecatkey(& key, id, "");
#line 1013
  r_packcatrec((CatKeyRec const   *)(& key), (CatDataRec const   *)(& data), record,
               & reclen);
#line 1015
  tmp___4 = bt_insert(& vol->cat, (byte const   *)(record), reclen);
  }
#line 1015
  if (tmp___4 == -1) {
#line 1017
    goto fail;
  } else {
    {
#line 1015
    tmp___5 = v_adjvalence(vol, parid, 1, 1);
    }
#line 1015
    if (tmp___5 == -1) {
#line 1017
      goto fail;
    }
  }
#line 1019
  return (0);
  fail: 
#line 1022
  return (-1);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
static void markexts(block *vbm , ExtDataRec const   *exts ) 
{ 
  int i ;
  unsigned int pt ;
  unsigned int len ;
  unsigned int tmp ;

  {
#line 1035
  i = 0;
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1035
    if (! (i < 3)) {
#line 1035
      goto while_break;
    }
#line 1037
    pt = (unsigned int )(*exts)[i].xdrStABN;
#line 1037
    len = (unsigned int )(*exts)[i].xdrNumABlks;
    {
#line 1037
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1037
      tmp = len;
#line 1037
      len --;
#line 1037
      if (! tmp) {
#line 1037
        goto while_break___0;
      }
#line 1039
      *((byte *)vbm + (pt >> 3)) = (byte )((int )*((byte *)vbm + (pt >> 3)) | (128 >> (pt & 7U)));
#line 1037
      pt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1035
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  return;
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/volume.c"
int v_scavenge(hfsvol *vol ) 
{ 
  block *vbm ;
  node n ;
  unsigned int pt ;
  unsigned int blks ;
  unsigned long lastcnid ;
  int tmp ;
  int tmp___0 ;
  ExtDataRec data ;
  byte const   *ptr ;
  int tmp___1 ;
  int tmp___2 ;
  CatDataRec data___0 ;
  byte const   *ptr___0 ;
  int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 1049
  vbm = vol->vbm;
#line 1052
  lastcnid = 15UL;
#line 1059
  if (vol->flags & 4) {
#line 1060
    goto done;
  }
  {
#line 1068
  vol->mdb.drAtrb = (Integer )((int )vol->mdb.drAtrb | (1 << 8));
#line 1069
  tmp = v_dirty(vol);
  }
#line 1069
  if (tmp == -1) {
#line 1070
    goto fail;
  }
  {
#line 1074
  markexts(vbm, (ExtDataRec const   *)(& vol->mdb.drXTExtRec));
#line 1075
  markexts(vbm, (ExtDataRec const   *)(& vol->mdb.drCTExtRec));
#line 1077
  vol->flags |= 64;
  }
#line 1081
  if (vol->ext.hdr.bthFNode > 0UL) {
    {
#line 1083
    tmp___0 = bt_getnode(& n, & vol->ext, vol->ext.hdr.bthFNode);
    }
#line 1083
    if (tmp___0 == -1) {
#line 1084
      goto fail;
    }
#line 1086
    n.rnum = 0;
    {
#line 1088
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1093
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1093
        if (n.rnum >= (int )n.nd.ndNRecs) {
#line 1093
          if (! (n.nd.ndFLink > 0UL)) {
#line 1093
            goto while_break___0;
          }
        } else {
#line 1093
          goto while_break___0;
        }
        {
#line 1095
        tmp___1 = bt_getnode(& n, & vol->ext, n.nd.ndFLink);
        }
#line 1095
        if (tmp___1 == -1) {
#line 1096
          goto fail;
        }
#line 1098
        n.rnum = 0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1101
      if (n.rnum >= (int )n.nd.ndNRecs) {
#line 1101
        if (n.nd.ndFLink == 0UL) {
#line 1102
          goto while_break;
        }
      }
      {
#line 1104
      ptr = (byte const   *)(n.data + (int )n.roff[n.rnum]);
#line 1105
      r_unpackextdata(ptr + (size_t )(((1 + (int )*ptr) + 1) & -2), & data);
#line 1107
      markexts(vbm, (ExtDataRec const   *)(& data));
#line 1109
      (n.rnum) ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1115
  if (vol->cat.hdr.bthFNode > 0UL) {
    {
#line 1117
    tmp___2 = bt_getnode(& n, & vol->cat, vol->cat.hdr.bthFNode);
    }
#line 1117
    if (tmp___2 == -1) {
#line 1118
      goto fail;
    }
#line 1120
    n.rnum = 0;
    {
#line 1122
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1127
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1127
        if (n.rnum >= (int )n.nd.ndNRecs) {
#line 1127
          if (! (n.nd.ndFLink > 0UL)) {
#line 1127
            goto while_break___2;
          }
        } else {
#line 1127
          goto while_break___2;
        }
        {
#line 1129
        tmp___3 = bt_getnode(& n, & vol->cat, n.nd.ndFLink);
        }
#line 1129
        if (tmp___3 == -1) {
#line 1130
          goto fail;
        }
#line 1132
        n.rnum = 0;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1135
      if (n.rnum >= (int )n.nd.ndNRecs) {
#line 1135
        if (n.nd.ndFLink == 0UL) {
#line 1136
          goto while_break___1;
        }
      }
      {
#line 1138
      ptr___0 = (byte const   *)(n.data + (int )n.roff[n.rnum]);
#line 1139
      r_unpackcatdata(ptr___0 + (size_t )(((1 + (int )*ptr___0) + 1) & -2), & data___0);
      }
      {
#line 1143
      if ((int )data___0.cdrType == 2) {
#line 1143
        goto case_2;
      }
#line 1151
      if ((int )data___0.cdrType == 1) {
#line 1151
        goto case_1;
      }
#line 1141
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1144
      markexts(vbm, (ExtDataRec const   *)(& data___0.u.fil.filExtRec));
#line 1145
      markexts(vbm, (ExtDataRec const   *)(& data___0.u.fil.filRExtRec));
      }
#line 1147
      if (data___0.u.fil.filFlNum > lastcnid) {
#line 1148
        lastcnid = data___0.u.fil.filFlNum;
      }
#line 1149
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1152
      if (data___0.u.dir.dirDirID > lastcnid) {
#line 1153
        lastcnid = data___0.u.dir.dirDirID;
      }
#line 1154
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1157
      (n.rnum) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1163
  blks = 0U;
#line 1163
  pt = (unsigned int )vol->mdb.drNmAlBlks;
  {
#line 1163
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1163
    tmp___4 = pt;
#line 1163
    pt --;
#line 1163
    if (! tmp___4) {
#line 1163
      goto while_break___3;
    }
#line 1165
    if (! ((int const   )*((byte const   *)vbm + (pt >> 3)) & (int const   )(128 >> (pt & 7U)))) {
#line 1166
      blks ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1169
  if ((unsigned int )vol->mdb.drFreeBks != blks) {
#line 1176
    vol->mdb.drFreeBks = (UInteger )blks;
#line 1177
    vol->flags |= 16;
  }
#line 1182
  if ((unsigned long )vol->mdb.drNxtCNID <= lastcnid) {
#line 1189
    vol->mdb.drNxtCNID = (LongInt )(lastcnid + 1UL);
#line 1190
    vol->flags |= 16;
  }
  done: 
#line 1198
  return (0);
  fail: 
#line 1201
  return (-1);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 142 "libhfs/hfs.h"
int hfs_vstat(hfsvol *vol , hfsvolent *ent ) ;
#line 145
int hfs_chdir(hfsvol *vol , char const   *path ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.h"
mountent *hcwd_getvol(int vol ) ;
#line 37
int hcwd_setcwd(mountent *ent , char const   *newcwd ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.h"
char const   *argv0 ;
#line 28
void hfsutil_perror(char const   *msg ) ;
#line 29
void hfsutil_perrorp(char const   *path ) ;
#line 31
hfsvol *hfsutil_remount(mountent *ment , int flags ) ;
#line 32
void hfsutil_unmount(hfsvol *vol , int *result ) ;
#line 35
char **hfsutil_glob(hfsvol *vol , int argc , char **argv , int *nelts , int *result ) ;
#line 36
char *hfsutil_getcwd(hfsvol *vol ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcd.h"
int hcd_main(int argc , char **argv ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcd.c"
int hcd_main(int argc , char **argv ) 
{ 
  mountent *ment ;
  hfsvol *vol ;
  hfsvolent vent ;
  char *path ;
  char root[29] ;
  int fargc ;
  char **fargv ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 46
  fargv = (char **)0;
#line 47
  result = 0;
#line 49
  if (argc > 2) {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [hfs-path]\n",
            argv0);
    }
#line 52
    return (1);
  }
  {
#line 55
  ment = hcwd_getvol(-1);
#line 55
  vol = hfsutil_remount(ment, 0);
  }
#line 56
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 57
    return (1);
  }
#line 59
  if (argc == 2) {
    {
#line 61
    fargv = hfsutil_glob(vol, 1, argv + 1, & fargc, & result);
    }
#line 62
    if (result == 0) {
#line 64
      if (fargc != 1) {
        {
#line 66
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ambiguous path\n",
                argv0, *(argv + 1));
#line 67
        result = 1;
        }
      } else {
#line 70
        path = *(fargv + 0);
      }
    }
  } else {
    {
#line 75
    hfs_vstat(vol, & vent);
#line 77
    strcpy((char */* __restrict  */)(root), (char const   */* __restrict  */)(vent.name));
#line 78
    strcat((char */* __restrict  */)(root), (char const   */* __restrict  */)":");
#line 79
    path = root;
    }
  }
#line 82
  if (result == 0) {
    {
#line 84
    tmp___0 = hfs_chdir(vol, (char const   *)path);
    }
#line 84
    if (tmp___0 == -1) {
      {
#line 86
      hfsutil_perrorp((char const   *)path);
#line 87
      result = 1;
      }
    } else {
      {
#line 91
      path = hfsutil_getcwd(vol);
      }
#line 92
      if ((unsigned long )path == (unsigned long )((char *)0)) {
        {
#line 94
        hfsutil_perror("Can\'t get new HFS directory path");
#line 95
        result = 1;
        }
      }
#line 98
      if (result == 0) {
        {
#line 98
        tmp = hcwd_setcwd(ment, (char const   *)path);
        }
#line 98
        if (tmp == -1) {
          {
#line 100
          perror("Can\'t set new HFS directory");
#line 101
          result = 1;
          }
        }
      }
#line 104
      if (path) {
        {
#line 105
        free((void *)path);
        }
      }
    }
  }
  {
#line 109
  hfsutil_unmount(vol, & result);
  }
#line 111
  if (fargv) {
    {
#line 112
    free((void *)fargv);
    }
  }
#line 114
  return (result);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.h"
char const   *bh_error ;
#line 24
int bh_start(int fd ) ;
#line 25
int bh_insert(void const   *buf , int len ) ;
#line 26
int bh_insertcrc(void) ;
#line 27
int bh_end(void) ;
#line 29
int bh_open(int fd ) ;
#line 30
int bh_read(void *buf , int len ) ;
#line 31
int bh_readcrc(void) ;
#line 32
int bh_close(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/crc.h"
unsigned short crc_binh(unsigned char const   *ptr , int count , unsigned short crc___0 ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
char const   *bh_error  =    "no error";
#line 43 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static FILE *file  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static char line[67]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int lptr  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int state86  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static unsigned char lastch  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int runlen  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static unsigned short crc  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static unsigned char const   zero[2]  = {      (unsigned char const   )0,      (unsigned char const   )0};
#line 54 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static char const   hqxheader[47]  = 
#line 54
  {      (char const   )'(',      (char const   )'T',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'u',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )' ',      (char const   )'B',      (char const   )'i', 
        (char const   )'n',      (char const   )'H',      (char const   )'e',      (char const   )'x', 
        (char const   )' ',      (char const   )'4',      (char const   )'.',      (char const   )'0', 
        (char const   )')',      (char const   )'\n',      (char const   )'\000'};
#line 57 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static char const   enmap[65]  = 
#line 57
  {      (char const   )'!',      (char const   )'\"',      (char const   )'#',      (char const   )'$', 
        (char const   )'%',      (char const   )'&',      (char const   )'\'',      (char const   )'(', 
        (char const   )')',      (char const   )'*',      (char const   )'+',      (char const   )',', 
        (char const   )'-',      (char const   )'0',      (char const   )'1',      (char const   )'2', 
        (char const   )'3',      (char const   )'4',      (char const   )'5',      (char const   )'6', 
        (char const   )'8',      (char const   )'9',      (char const   )'@',      (char const   )'A', 
        (char const   )'B',      (char const   )'C',      (char const   )'D',      (char const   )'E', 
        (char const   )'F',      (char const   )'G',      (char const   )'H',      (char const   )'I', 
        (char const   )'J',      (char const   )'K',      (char const   )'L',      (char const   )'M', 
        (char const   )'N',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )'[', 
        (char const   )'`',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static signed char const   demap[256]  = 
#line 61
  {      (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )-1,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )-1,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )10,      (signed char const   )11, 
        (signed char const   )12,      (signed char const   )13,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )14,      (signed char const   )15,      (signed char const   )16,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )20,      (signed char const   )0, 
        (signed char const   )21,      (signed char const   )22,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )26, 
        (signed char const   )27,      (signed char const   )28,      (signed char const   )29,      (signed char const   )30, 
        (signed char const   )31,      (signed char const   )32,      (signed char const   )33,      (signed char const   )34, 
        (signed char const   )35,      (signed char const   )36,      (signed char const   )37,      (signed char const   )0, 
        (signed char const   )38,      (signed char const   )39,      (signed char const   )40,      (signed char const   )41, 
        (signed char const   )42,      (signed char const   )43,      (signed char const   )44,      (signed char const   )0, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )52, 
        (signed char const   )53,      (signed char const   )54,      (signed char const   )55,      (signed char const   )0, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )62,      (signed char const   )63,      (signed char const   )64,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0, 
        (signed char const   )0,      (signed char const   )0,      (signed char const   )0,      (signed char const   )0};
#line 91 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_start(int fd ) 
{ 
  int dupfd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 95
  dupfd = dup(fd);
  }
#line 96
  if (dupfd == -1) {
    {
#line 98
    bh_error = "error duplicating output stream";
#line 98
    tmp = __errno_location();
#line 98
    tmp___0 = __errno_location();
#line 98
    *tmp = *tmp___0;
    }
#line 99
    return (-1);
  }
  {
#line 102
  file = fdopen(dupfd, "ab");
  }
#line 103
  if ((unsigned long )file == (unsigned long )((FILE *)0)) {
    {
#line 105
    bh_error = "error creating output buffer";
#line 105
    tmp___1 = __errno_location();
#line 105
    tmp___2 = __errno_location();
#line 105
    *tmp___1 = *tmp___2;
#line 107
    close(dupfd);
    }
#line 108
    return (-1);
  }
  {
#line 111
  line[0] = (char )':';
#line 112
  lptr = 1;
#line 114
  state86 = 0;
#line 115
  runlen = 0;
#line 117
  crc = (unsigned short)0;
#line 119
  tmp___4 = fputs((char const   */* __restrict  */)(hqxheader), (FILE */* __restrict  */)file);
  }
#line 119
  if (tmp___4 == -1) {
    {
#line 121
    bh_error = "error writing hqx header";
#line 121
    tmp___3 = __errno_location();
#line 121
    *tmp___3 = 5;
#line 123
    fclose(file);
    }
#line 124
    return (-1);
  }
#line 127
  return (0);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int flushline(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 137
  tmp = lptr;
#line 137
  lptr ++;
#line 137
  line[tmp] = (char )'\n';
#line 138
  tmp___0 = lptr;
#line 138
  lptr ++;
#line 138
  line[tmp___0] = (char)0;
#line 140
  tmp___2 = fputs((char const   */* __restrict  */)(line), (FILE */* __restrict  */)file);
  }
#line 140
  if (tmp___2 == -1) {
    {
#line 142
    bh_error = "error writing output data";
#line 142
    tmp___1 = __errno_location();
#line 142
    *tmp___1 = 5;
    }
#line 143
    return (-1);
  }
#line 146
  lptr = 0;
#line 148
  return (0);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int addchars(unsigned char const   *data , int len ) 
{ 
  register unsigned char c ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    tmp___6 = len;
#line 160
    len --;
#line 160
    if (! tmp___6) {
#line 160
      goto while_break;
    }
#line 162
    tmp = data;
#line 162
    data ++;
#line 162
    c = (unsigned char )*tmp;
#line 164
    if (lptr == 64) {
      {
#line 164
      tmp___0 = flushline();
      }
#line 164
      if (tmp___0 == -1) {
#line 166
        return (-1);
      }
    }
    {
#line 170
    if ((state86 & 65280) == 0) {
#line 170
      goto case_0;
    }
#line 175
    if ((state86 & 65280) == 256) {
#line 175
      goto case_256;
    }
#line 180
    if ((state86 & 65280) == 512) {
#line 180
      goto case_512;
    }
#line 168
    goto switch_break;
    case_0: /* CIL Label */ 
#line 171
    tmp___1 = lptr;
#line 171
    lptr ++;
#line 171
    line[tmp___1] = (char )enmap[(int )c >> 2];
#line 172
    state86 = 256 | ((int )c & 3);
#line 173
    goto switch_break;
    case_256: /* CIL Label */ 
#line 176
    tmp___2 = lptr;
#line 176
    lptr ++;
#line 176
    line[tmp___2] = (char )enmap[((state86 & 3) << 4) | ((int )c >> 4)];
#line 177
    state86 = 512 | ((int )c & 15);
#line 178
    goto switch_break;
    case_512: /* CIL Label */ 
#line 181
    tmp___3 = lptr;
#line 181
    lptr ++;
#line 181
    line[tmp___3] = (char )enmap[((state86 & 15) << 2) | ((int )c >> 6)];
#line 183
    if (lptr == 64) {
      {
#line 183
      tmp___4 = flushline();
      }
#line 183
      if (tmp___4 == -1) {
#line 185
        return (-1);
      }
    }
#line 187
    tmp___5 = lptr;
#line 187
    lptr ++;
#line 187
    line[tmp___5] = (char )enmap[(int )c & 63];
#line 188
    state86 = 0;
#line 189
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return (0);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int rleflush(void) 
{ 
  unsigned char rle[4] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 203
  rle[0] = (unsigned char)144;
#line 203
  rle[1] = (unsigned char)0;
#line 203
  rle[2] = (unsigned char)144;
#line 203
  rle[3] = (unsigned char)0;
#line 205
  if ((int )lastch != 144) {
#line 205
    if (runlen < 4) {
#line 205
      goto _L;
    } else {
#line 205
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 205
  if ((int )lastch == 144) {
#line 205
    if (runlen < 3) {
      _L: /* CIL Label */ 
#line 210
      if ((int )lastch == 144) {
        {
#line 212
        while (1) {
          while_continue: /* CIL Label */ ;
#line 212
          tmp___0 = runlen;
#line 212
          runlen --;
#line 212
          if (! tmp___0) {
#line 212
            goto while_break;
          }
          {
#line 213
          tmp = addchars((unsigned char const   *)(rle), 2);
          }
#line 213
          if (tmp == -1) {
#line 214
            return (-1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 218
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 218
          tmp___2 = runlen;
#line 218
          runlen --;
#line 218
          if (! tmp___2) {
#line 218
            goto while_break___0;
          }
          {
#line 219
          tmp___1 = addchars((unsigned char const   *)(& lastch), 1);
          }
#line 219
          if (tmp___1 == -1) {
#line 220
            return (-1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 205
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 227
  if ((int )lastch == 144) {
    {
#line 229
    rle[3] = (unsigned char )runlen;
#line 231
    tmp___3 = addchars((unsigned char const   *)(rle), 4);
    }
#line 231
    if (tmp___3 == -1) {
#line 232
      return (-1);
    }
  } else {
    {
#line 236
    rle[1] = lastch;
#line 237
    rle[3] = (unsigned char )runlen;
#line 239
    tmp___4 = addchars((unsigned char const   *)(& rle[1]), 3);
    }
#line 239
    if (tmp___4 == -1) {
#line 240
      return (-1);
    }
  }
#line 244
  runlen = 0;
#line 246
  return (0);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_insert(void const   *buf , int len ) 
{ 
  register unsigned char const   *data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 255
  data = (unsigned char const   *)buf;
#line 257
  crc = crc_binh(data, len, crc);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    tmp___0 = len;
#line 259
    len --;
#line 259
    if (! tmp___0) {
#line 259
      goto while_break;
    }
#line 261
    if (runlen) {
#line 263
      if (runlen == 255) {
#line 263
        goto _L;
      } else
#line 263
      if ((int )lastch != (int )*data) {
        _L: /* CIL Label */ 
        {
#line 265
        tmp = rleflush();
        }
#line 265
        if (tmp == -1) {
#line 266
          return (-1);
        }
      }
#line 269
      if ((int )lastch == (int )*data) {
#line 271
        runlen ++;
#line 272
        goto __Cont;
      }
    }
#line 276
    lastch = (unsigned char )*data;
#line 277
    runlen = 1;
    __Cont: /* CIL Label */ 
#line 259
    data ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return (0);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_insertcrc(void) 
{ 
  unsigned char word[2] ;
  int tmp ;

  {
  {
#line 291
  crc = crc_binh(zero, 2, crc);
#line 293
  word[0] = (unsigned char )(((int )crc & 65280) >> 8);
#line 294
  word[1] = (unsigned char )((int )crc & 255);
#line 296
  tmp = bh_insert((void const   *)(word), 2);
  }
#line 296
  if (tmp == -1) {
#line 297
    return (-1);
  }
#line 299
  crc = (unsigned short)0;
#line 301
  return (0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_end(void) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 310
  result = 0;
#line 312
  if (runlen) {
    {
#line 312
    tmp = rleflush();
    }
#line 312
    if (tmp == -1) {
#line 314
      result = -1;
    }
  }
#line 316
  if (state86) {
#line 316
    if (result == 0) {
      {
#line 316
      tmp___0 = addchars(zero, 1);
      }
#line 316
      if (tmp___0 == -1) {
#line 318
        result = -1;
      }
    }
  }
#line 320
  tmp___1 = lptr;
#line 320
  lptr ++;
#line 320
  line[tmp___1] = (char )':';
#line 322
  if (result == 0) {
    {
#line 322
    tmp___2 = flushline();
    }
#line 322
    if (tmp___2 == -1) {
#line 324
      result = -1;
    }
  }
  {
#line 326
  tmp___5 = fclose(file);
  }
#line 326
  if (tmp___5 == -1) {
#line 326
    if (result == 0) {
      {
#line 328
      bh_error = "error flushing output data";
#line 328
      tmp___3 = __errno_location();
#line 328
      tmp___4 = __errno_location();
#line 328
      *tmp___3 = *tmp___4;
#line 329
      result = -1;
      }
    }
  }
#line 332
  return (result);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_open(int fd ) 
{ 
  int dupfd ;
  int c ;
  char const   *ptr ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
  {
#line 346
  dupfd = dup(fd);
  }
#line 347
  if (dupfd == -1) {
    {
#line 349
    bh_error = "error duplicating input stream";
#line 349
    tmp = __errno_location();
#line 349
    tmp___0 = __errno_location();
#line 349
    *tmp = *tmp___0;
    }
#line 350
    return (-1);
  }
  {
#line 353
  file = fdopen(dupfd, "rb");
  }
#line 354
  if ((unsigned long )file == (unsigned long )((FILE *)0)) {
    {
#line 356
    bh_error = "error creating input buffer";
#line 356
    tmp___1 = __errno_location();
#line 356
    tmp___2 = __errno_location();
#line 356
    *tmp___1 = *tmp___2;
#line 358
    close(dupfd);
    }
#line 359
    return (-1);
  }
#line 362
  state86 = 0;
#line 363
  runlen = 0;
#line 365
  crc = (unsigned short)0;
#line 369
  ptr = hqxheader;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! ((unsigned long )ptr == (unsigned long )((char const   *)0))) {
#line 370
      if (! (ptr - hqxheader < 40L)) {
#line 370
        goto while_break;
      }
    }
    {
#line 372
    c = _IO_getc(file);
    }
#line 373
    if (c == -1) {
      {
#line 375
      bh_error = "hqx file header not found";
#line 375
      tmp___3 = __errno_location();
#line 375
      *tmp___3 = 22;
#line 377
      fclose(file);
      }
#line 378
      return (-1);
    }
#line 381
    if (c == 10) {
#line 383
      ptr = hqxheader;
#line 384
      goto while_continue;
    } else
#line 381
    if (c == 13) {
#line 383
      ptr = hqxheader;
#line 384
      goto while_continue;
    }
#line 387
    if (ptr) {
#line 387
      tmp___4 = ptr;
#line 387
      ptr ++;
#line 387
      if (c != (int )*tmp___4) {
#line 388
        ptr = (char const   *)0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 393
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 395
    c = _IO_getc(file);
    }
#line 396
    if (c == -1) {
      {
#line 398
      bh_error = "corrupt hqx file";
#line 398
      tmp___5 = __errno_location();
#line 398
      *tmp___5 = 22;
#line 400
      fclose(file);
      }
#line 401
      return (-1);
    }
#line 393
    if (c != 10) {
#line 393
      if (! (c != 13)) {
#line 393
        goto while_break___0;
      }
    } else {
#line 393
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 408
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 410
    c = _IO_getc(file);
    }
#line 411
    if (c == -1) {
      {
#line 413
      bh_error = "corrupt hqx file";
#line 413
      tmp___6 = __errno_location();
#line 413
      *tmp___6 = 22;
#line 415
      fclose(file);
      }
#line 416
      return (-1);
    }
#line 408
    if (! ((int const   )demap[(unsigned char )c] == -1)) {
#line 408
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 421
  if (c != 58) {
    {
#line 423
    bh_error = "corrupt hqx file";
#line 423
    tmp___7 = __errno_location();
#line 423
    *tmp___7 = 22;
#line 425
    fclose(file);
    }
#line 426
    return (-1);
  }
#line 429
  return (0);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int hqxchar(void) 
{ 
  int c ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 442
    c = _IO_getc(file);
    }
#line 441
    if (c != -1) {
#line 441
      if (! ((int const   )demap[(unsigned char )c] == -1)) {
#line 441
        goto while_break;
      }
    } else {
#line 441
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  if (c == -1) {
    {
#line 447
    tmp___1 = feof(file);
    }
#line 447
    if (tmp___1) {
      {
#line 448
      bh_error = "unexpected end of file";
#line 448
      tmp = __errno_location();
#line 448
      *tmp = 22;
      }
    } else {
      {
#line 450
      bh_error = "error reading input file";
#line 450
      tmp___0 = __errno_location();
#line 450
      *tmp___0 = 5;
      }
    }
#line 452
    return (-1);
  }
#line 455
  c = (int )demap[(unsigned char )c];
#line 456
  if (c == 0) {
    {
#line 458
    bh_error = "illegal character in hqx file";
#line 458
    tmp___2 = __errno_location();
#line 458
    *tmp___2 = 22;
    }
#line 459
    return (-1);
  }
#line 462
  return (c - 1);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
static int nextchar(void) 
{ 
  int c ;
  int c2 ;
  int ch ;

  {
  {
#line 474
  c = hqxchar();
  }
#line 475
  if (c == -1) {
#line 476
    return (-1);
  }
  {
#line 480
  if ((state86 & 65280) == 0) {
#line 480
    goto case_0;
  }
#line 489
  if ((state86 & 65280) == 256) {
#line 489
    goto case_256;
  }
#line 494
  if ((state86 & 65280) == 512) {
#line 494
    goto case_512;
  }
#line 478
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 481
  c2 = hqxchar();
  }
#line 482
  if (c2 == -1) {
#line 483
    return (-1);
  }
#line 485
  ch = (c << 2) | (c2 >> 4);
#line 486
  state86 = 256 | (c2 & 15);
#line 487
  goto switch_break;
  case_256: /* CIL Label */ 
#line 490
  ch = ((state86 & 15) << 4) | (c >> 2);
#line 491
  state86 = 512 | (c & 3);
#line 492
  goto switch_break;
  case_512: /* CIL Label */ 
#line 495
  ch = ((state86 & 3) << 6) | c;
#line 496
  state86 = 0;
#line 497
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 500
  return (ch);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_read(void *buf , int len ) 
{ 
  register unsigned char *data ;
  unsigned char const   *ptr ;
  int c ;
  int rl ;
  int count ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
#line 509
  data = (unsigned char *)buf;
#line 510
  ptr = (unsigned char const   *)data;
#line 511
  count = len;
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    tmp___1 = len;
#line 513
    len --;
#line 513
    if (! tmp___1) {
#line 513
      goto while_break;
    }
#line 515
    if (runlen) {
#line 517
      tmp = data;
#line 517
      data ++;
#line 517
      *tmp = lastch;
#line 518
      runlen --;
#line 519
      goto while_continue;
    }
    {
#line 522
    c = nextchar();
    }
#line 523
    if (c == -1) {
#line 524
      return (-1);
    }
#line 526
    if (c == 144) {
      {
#line 528
      rl = nextchar();
      }
#line 529
      if (rl == -1) {
#line 530
        return (-1);
      }
#line 532
      if (rl > 0) {
#line 534
        runlen = rl - 1;
#line 535
        len ++;
#line 536
        goto while_continue;
      }
    }
#line 540
    tmp___0 = data;
#line 540
    data ++;
#line 540
    lastch = (unsigned char )c;
#line 540
    *tmp___0 = lastch;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 543
  crc = crc_binh(ptr, count, crc);
  }
#line 545
  return (count);
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_readcrc(void) 
{ 
  unsigned short check ;
  unsigned char word[2] ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 557
  check = crc_binh(zero, 2, crc);
#line 559
  tmp = bh_read((void *)(word), 2);
  }
#line 559
  if (tmp < 2) {
#line 560
    return (-1);
  }
#line 562
  crc = (unsigned short )(((int )word[0] << 8) | (int )word[1]);
#line 565
  if ((int )crc != (int )check) {
    {
#line 567
    bh_error = "CRC checksum error";
#line 567
    tmp___0 = __errno_location();
#line 567
    *tmp___0 = 22;
    }
#line 568
    return (-1);
  }
#line 571
  crc = (unsigned short)0;
#line 573
  return (0);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/binhex.c"
int bh_close(void) 
{ 
  int c ;
  int result ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 582
  result = 0;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 587
    c = _IO_getc(file);
    }
#line 586
    if (c != -1) {
#line 586
      if (! ((int const   )demap[(unsigned char )c] == -1)) {
#line 586
        goto while_break;
      }
    } else {
#line 586
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  if (c == 33) {
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 595
      c = _IO_getc(file);
      }
#line 594
      if (c != -1) {
#line 594
        if (! ((int const   )demap[(unsigned char )c] == -1)) {
#line 594
          goto while_break___0;
        }
      } else {
#line 594
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 601
  if (c != 58) {
    {
#line 603
    bh_error = "corrupt end of hqx file";
#line 603
    tmp = __errno_location();
#line 603
    *tmp = 22;
#line 604
    result = -1;
    }
  }
  {
#line 607
  tmp___2 = fclose(file);
  }
#line 607
  if (tmp___2 == -1) {
#line 607
    if (result == 0) {
      {
#line 609
      bh_error = "error closing input file";
#line 609
      tmp___0 = __errno_location();
#line 609
      tmp___1 = __errno_location();
#line 609
      *tmp___0 = *tmp___1;
#line 610
      result = -1;
      }
    }
  }
#line 613
  return (result);
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 143 "libhfs/hfs.h"
int hfs_vsetattr(hfsvol *vol , hfsvolent *ent ) ;
#line 164
int hfs_stat(hfsvol *vol , char const   *path , hfsdirent *ent ) ;
#line 166
int hfs_setattr(hfsvol *vol , char const   *path , hfsdirent const   *ent ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hattrib.h"
int hattrib_main(int argc , char **argv ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hattrib.c"
static int usage(void) 
{ 


  {
  {
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-t TYPE] [-c CREA] [-|+i] [-|+l] hfs-path [...]\n       %s -b hfs-path\n",
          argv0, argv0);
  }
#line 47
  return (1);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hattrib.c"
int hattrib_main(int argc , char **argv ) 
{ 
  char const   *type ;
  char const   *crea ;
  int invis ;
  int lock ;
  int bless ;
  hfsvol *vol ;
  int fargc ;
  char **fargv ;
  int i ;
  int result ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  mountent *tmp___7 ;
  hfsdirent ent ;
  hfsvolent volent ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 56
  type = (char const   *)0;
#line 56
  crea = (char const   *)0;
#line 57
  invis = 0;
#line 57
  lock = 0;
#line 57
  bless = 0;
#line 61
  result = 0;
#line 63
  i = 1;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < argc)) {
#line 63
      goto while_break;
    }
    {
#line 67
    if ((int )*(*(argv + i) + 0) == 45) {
#line 67
      goto case_45;
    }
#line 115
    if ((int )*(*(argv + i) + 0) == 43) {
#line 115
      goto case_43;
    }
#line 65
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 70
    if ((int )*(*(argv + i) + 1) == 116) {
#line 70
      goto case_116;
    }
#line 84
    if ((int )*(*(argv + i) + 1) == 99) {
#line 84
      goto case_99;
    }
#line 98
    if ((int )*(*(argv + i) + 1) == 105) {
#line 98
      goto case_105;
    }
#line 102
    if ((int )*(*(argv + i) + 1) == 108) {
#line 102
      goto case_108;
    }
#line 106
    if ((int )*(*(argv + i) + 1) == 98) {
#line 106
      goto case_98;
    }
#line 110
    goto switch_default;
    case_116: /* CIL Label */ 
#line 71
    i ++;
#line 71
    type = (char const   *)*(argv + i);
#line 73
    if ((unsigned long )type == (unsigned long )((char const   *)0)) {
      {
#line 74
      tmp = usage();
      }
#line 74
      return (tmp);
    }
    {
#line 76
    tmp___0 = strlen(type);
    }
#line 76
    if (tmp___0 != 4UL) {
      {
#line 78
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: file type must be 4 characters\n",
              argv0);
      }
#line 80
      return (1);
    }
#line 82
    goto __Cont;
    case_99: /* CIL Label */ 
#line 85
    i ++;
#line 85
    crea = (char const   *)*(argv + i);
#line 87
    if ((unsigned long )crea == (unsigned long )((char const   *)0)) {
      {
#line 88
      tmp___1 = usage();
      }
#line 88
      return (tmp___1);
    }
    {
#line 90
    tmp___2 = strlen(crea);
    }
#line 90
    if (tmp___2 != 4UL) {
      {
#line 92
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: file creator must be 4 characters\n",
              argv0);
      }
#line 94
      return (1);
    }
#line 96
    goto __Cont;
    case_105: /* CIL Label */ 
#line 99
    invis = -1;
#line 100
    goto __Cont;
    case_108: /* CIL Label */ 
#line 103
    lock = -1;
#line 104
    goto __Cont;
    case_98: /* CIL Label */ 
#line 107
    bless = 1;
#line 108
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 111
    tmp___3 = usage();
    }
#line 111
    return (tmp___3);
    switch_break___0: /* CIL Label */ ;
    }
#line 113
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 118
    if ((int )*(*(argv + i) + 1) == 105) {
#line 118
      goto case_105___0;
    }
#line 122
    if ((int )*(*(argv + i) + 1) == 108) {
#line 122
      goto case_108___0;
    }
#line 126
    goto switch_default___0;
    case_105___0: /* CIL Label */ 
#line 119
    invis = 1;
#line 120
    goto __Cont;
    case_108___0: /* CIL Label */ 
#line 123
    lock = 1;
#line 124
    goto __Cont;
    switch_default___0: /* CIL Label */ 
    {
#line 127
    tmp___4 = usage();
    }
#line 127
    return (tmp___4);
    switch_break___1: /* CIL Label */ ;
    }
#line 129
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 132
    goto while_break;
    __Cont: /* CIL Label */ 
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (argc - i == 0) {
    {
#line 136
    tmp___5 = usage();
    }
#line 136
    return (tmp___5);
  }
#line 138
  if (i == 1) {
    {
#line 140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no attributes specified\n",
            argv0);
    }
#line 141
    return (1);
  }
#line 144
  if (bless) {
#line 144
    if (lock) {
      {
#line 145
      tmp___6 = usage();
      }
#line 145
      return (tmp___6);
    } else
#line 144
    if (invis) {
      {
#line 145
      tmp___6 = usage();
      }
#line 145
      return (tmp___6);
    } else
#line 144
    if (type) {
      {
#line 145
      tmp___6 = usage();
      }
#line 145
      return (tmp___6);
    } else
#line 144
    if (crea) {
      {
#line 145
      tmp___6 = usage();
      }
#line 145
      return (tmp___6);
    } else
#line 144
    if (argc - i > 1) {
      {
#line 145
      tmp___6 = usage();
      }
#line 145
      return (tmp___6);
    }
  }
  {
#line 147
  tmp___7 = hcwd_getvol(-1);
#line 147
  vol = hfsutil_remount(tmp___7, 2);
  }
#line 148
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 149
    return (1);
  }
  {
#line 151
  fargv = hfsutil_glob(vol, argc - i, argv + i, & fargc, & result);
  }
#line 153
  if (result == 0) {
#line 157
    if (bless) {
#line 159
      if (fargc != 1) {
        {
#line 161
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ambiguous path\n",
                argv0, *(argv + i));
#line 162
        result = 1;
        }
      } else {
        {
#line 168
        tmp___9 = hfs_stat(vol, (char const   *)*(fargv + 0), & ent);
        }
#line 168
        if (tmp___9 == -1) {
          {
#line 171
          hfsutil_perrorp((char const   *)*(fargv + 0));
#line 172
          result = 1;
          }
        } else {
          {
#line 168
          tmp___10 = hfs_vstat(vol, & volent);
          }
#line 168
          if (tmp___10 == -1) {
            {
#line 171
            hfsutil_perrorp((char const   *)*(fargv + 0));
#line 172
            result = 1;
            }
          } else {
            {
#line 176
            volent.blessed = ent.cnid;
#line 178
            tmp___8 = hfs_vsetattr(vol, & volent);
            }
#line 178
            if (tmp___8 == -1) {
              {
#line 180
              hfsutil_perrorp((char const   *)*(fargv + 0));
#line 181
              result = 1;
              }
            }
          }
        }
      }
    } else {
#line 188
      i = 0;
      {
#line 188
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 188
        if (! (i < fargc)) {
#line 188
          goto while_break___0;
        }
        {
#line 190
        tmp___12 = hfs_stat(vol, (char const   *)*(fargv + i), & ent);
        }
#line 190
        if (tmp___12 == -1) {
          {
#line 192
          hfsutil_perrorp((char const   *)*(fargv + i));
#line 193
          result = 1;
          }
        } else {
#line 197
          if (! (ent.flags & 1)) {
#line 199
            if (type) {
              {
#line 200
              memcpy((void */* __restrict  */)(ent.u.file.type), (void const   */* __restrict  */)type,
                     (size_t )4);
              }
            }
#line 201
            if (crea) {
              {
#line 202
              memcpy((void */* __restrict  */)(ent.u.file.creator), (void const   */* __restrict  */)crea,
                     (size_t )4);
              }
            }
          }
#line 205
          if (invis < 0) {
#line 206
            ent.fdflags = (short )((int )ent.fdflags & ~ (1 << 14));
          } else
#line 207
          if (invis > 0) {
#line 208
            ent.fdflags = (short )((int )ent.fdflags | (1 << 14));
          }
#line 210
          if (lock < 0) {
#line 211
            ent.flags &= -3;
          } else
#line 212
          if (lock > 0) {
#line 213
            ent.flags |= 2;
          }
          {
#line 215
          tmp___11 = hfs_setattr(vol, (char const   *)*(fargv + i), (hfsdirent const   *)(& ent));
          }
#line 215
          if (tmp___11 == -1) {
            {
#line 217
            hfsutil_perrorp((char const   *)*(fargv + i));
#line 218
            result = 1;
            }
          }
        }
#line 188
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 225
  hfsutil_unmount(vol, & result);
  }
#line 227
  if (fargv) {
    {
#line 228
    free((void *)fargv);
    }
  }
#line 230
  return (result);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.h"
hfsvol *hfs_mount(char const   *path , int pnum , int mode ) ;
#line 135
int hfs_flush(hfsvol *vol ) ;
#line 136
void hfs_flushall(void) ;
#line 137
int hfs_umount(hfsvol *vol ) ;
#line 138
void hfs_umountall(void) ;
#line 139
hfsvol *hfs_getvol(char const   *name___1 ) ;
#line 140
void hfs_setvol(hfsvol *vol ) ;
#line 146
unsigned long hfs_getcwd(hfsvol *vol ) ;
#line 147
int hfs_setcwd(hfsvol *vol , unsigned long id ) ;
#line 148
int hfs_dirinfo(hfsvol *vol , unsigned long *id , char *name___1 ) ;
#line 150
hfsdir *hfs_opendir(hfsvol *vol , char const   *path ) ;
#line 151
int hfs_readdir(hfsdir *dir , hfsdirent *ent ) ;
#line 152
int hfs_closedir(hfsdir *dir ) ;
#line 154
hfsfile *hfs_create(hfsvol *vol , char const   *path , char const   *type , char const   *creator ) ;
#line 155
hfsfile *hfs_open(hfsvol *vol , char const   *path ) ;
#line 156
int hfs_setfork(hfsfile *file___0 , int fork ) ;
#line 157
int hfs_getfork(hfsfile *file___0 ) ;
#line 158
unsigned long hfs_read(hfsfile *file___0 , void *buf , unsigned long len ) ;
#line 159
unsigned long hfs_write(hfsfile *file___0 , void const   *buf , unsigned long len ) ;
#line 160
int hfs_truncate(hfsfile *file___0 , unsigned long len ) ;
#line 161
unsigned long hfs_seek(hfsfile *file___0 , long offset , int from ) ;
#line 162
int hfs_close(hfsfile *file___0 ) ;
#line 165
int hfs_fstat(hfsfile *file___0 , hfsdirent *ent ) ;
#line 167
int hfs_fsetattr(hfsfile *file___0 , hfsdirent const   *ent ) ;
#line 169
int hfs_mkdir(hfsvol *vol , char const   *path ) ;
#line 170
int hfs_rmdir(hfsvol *vol , char const   *path ) ;
#line 172
int hfs_delete(hfsvol *vol , char const   *path ) ;
#line 173
int hfs_rename(hfsvol *vol , char const   *srcpath , char const   *dstpath ) ;
#line 175
int hfs_zero(char const   *path , unsigned int maxparts , unsigned long *blocks ) ;
#line 176
int hfs_mkpart(char const   *path , unsigned long len ) ;
#line 177
int hfs_nparts(char const   *path ) ;
#line 179
int hfs_format(char const   *path , int pnum , int mode , char const   *vname , unsigned int nbadblocks ,
               unsigned long const   *badblocks ) ;
#line 226 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/libhfs.h"
hfsvol *hfs_mounts  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.h"
long d_getsl(unsigned char const   *ptr ) ;
#line 57
time_t d_ltime(unsigned long mtime ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.h"
int b_readab(hfsvol *vol , unsigned int anum , unsigned int index___0 , block *bp ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/medium.h"
int m_zeroddr(hfsvol *vol ) ;
#line 38
int m_zeropm(hfsvol *vol , unsigned int maxparts ) ;
#line 40
int m_mkpart(hfsvol *vol , char const   *name___1 , char const   *type , unsigned long len ) ;
#line 42
int m_zerobb(hfsvol *vol ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.h"
void f_getptrs(hfsfile *file___0 , ExtDataRec **extrec , unsigned long **lglen , unsigned long **pylen ) ;
#line 31
int f_doblock(hfsfile *file___0 , unsigned long num , block *bp , int (*func)(hfsvol * ,
                                                                              unsigned int  ,
                                                                              unsigned int  ,
                                                                              block * ) ) ;
#line 41
int f_addextent(hfsfile *file___0 , ExtDescriptor *blocks ) ;
#line 42
long f_alloc(hfsfile *file___0 ) ;
#line 44
int f_trunc(hfsfile *file___0 ) ;
#line 45
int f_flush(hfsfile *file___0 ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.h"
int bt_delete(btree *bt , byte const   *key ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.h"
void n_init(node *np , btree *bt , int type , int height ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.h"
void r_packextrec(ExtKeyRec const   *key , ExtDataRec const   *data , byte *precord ,
                  unsigned int *len ) ;
#line 45
void r_packdirent(CatDataRec *data , hfsdirent const   *ent ) ;
#line 46
void r_unpackdirent(unsigned long parid , char const   *name___1 , CatDataRec const   *data ,
                    hfsdirent *ent ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
char const   *hfs_error  =    "no error";
#line 45 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
static hfsvol *curvol  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
static int validvname(char const   *name___1 ) 
{ 
  int len ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 57
  tmp = strlen(name___1);
#line 57
  len = (int )tmp;
  }
#line 58
  if (len < 1) {
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 59
      hfs_error = "volume name cannot be empty";
#line 59
      tmp___0 = __errno_location();
#line 59
      *tmp___0 = 22;
      }
#line 59
      goto fail;
#line 59
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 60
  if (len > 27) {
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 61
      hfs_error = "volume name can be at most 27 chars";
#line 61
      tmp___1 = __errno_location();
#line 61
      *tmp___1 = 36;
      }
#line 61
      goto fail;
#line 61
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 64
  tmp___3 = strchr(name___1, ':');
  }
#line 64
  if (tmp___3) {
    {
#line 65
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 65
      hfs_error = "volume name may not contain colons";
#line 65
      tmp___2 = __errno_location();
#line 65
      *tmp___2 = 22;
      }
#line 65
      goto fail;
#line 65
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 67
  return (1);
  fail: 
#line 70
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
static int getvol(hfsvol **vol ) 
{ 
  int *tmp ;

  {
#line 80
  if ((unsigned long )*vol == (unsigned long )((hfsvol *)0)) {
#line 82
    if ((unsigned long )curvol == (unsigned long )((hfsvol *)0)) {
      {
#line 83
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 83
        hfs_error = "no volume is current";
#line 83
        tmp = __errno_location();
#line 83
        *tmp = 22;
        }
#line 83
        goto fail;
#line 83
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 85
    *vol = curvol;
  }
#line 88
  return (0);
  fail: 
#line 91
  return (-1);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
hfsvol *hfs_mount(char const   *path , int pnum , int mode ) 
{ 
  hfsvol *vol ;
  hfsvol *check ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 106
  check = hfs_mounts;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! check) {
#line 106
      goto while_break;
    }
#line 108
    if (check->pnum == pnum) {
      {
#line 108
      tmp = v_same(check, path);
      }
#line 108
      if (tmp == 1) {
#line 112
        if (check->flags & 4) {
#line 112
          if (! (mode & 1)) {
#line 117
            vol = check;
#line 118
            goto done;
          } else {
#line 112
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 112
        if (! (check->flags & 4)) {
#line 112
          if (mode & 3) {
#line 117
            vol = check;
#line 118
            goto done;
          }
        }
      }
    }
#line 106
    check = check->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  tmp___0 = malloc(sizeof(hfsvol ));
#line 123
  vol = (hfsvol *)tmp___0;
  }
#line 124
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 125
      hfs_error = (char const   *)0;
#line 125
      tmp___1 = __errno_location();
#line 125
      *tmp___1 = 12;
      }
#line 125
      goto fail;
#line 125
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 127
  v_init(vol, mode);
  }
  {
#line 134
  if ((mode & 3) == 2) {
#line 134
    goto case_2;
  }
#line 134
  if ((mode & 3) == 1) {
#line 134
    goto case_2;
  }
#line 142
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 135
  tmp___2 = v_open(vol, path, 1);
  }
#line 135
  if (tmp___2 != -1) {
#line 136
    goto switch_break;
  }
#line 138
  if ((mode & 3) == 1) {
#line 139
    goto fail;
  }
  switch_default: /* CIL Label */ 
  {
#line 143
  vol->flags |= 4;
#line 145
  tmp___3 = v_open(vol, path, 0);
  }
#line 145
  if (tmp___3 == -1) {
#line 146
    goto fail;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 151
  tmp___4 = v_geometry(vol, pnum);
  }
#line 151
  if (tmp___4 == -1) {
#line 153
    goto fail;
  } else {
    {
#line 151
    tmp___5 = v_mount(vol);
    }
#line 151
    if (tmp___5 == -1) {
#line 153
      goto fail;
    }
  }
#line 157
  vol->prev = (struct _hfsvol_ *)0;
#line 158
  vol->next = hfs_mounts;
#line 160
  if (hfs_mounts) {
#line 161
    hfs_mounts->prev = vol;
  }
#line 163
  hfs_mounts = vol;
  done: 
#line 166
  (vol->refs) ++;
#line 167
  curvol = vol;
#line 169
  return (vol);
  fail: 
#line 172
  if (vol) {
    {
#line 174
    v_close(vol);
    }
#line 175
    if (vol) {
      {
#line 175
      free((void *)vol);
      }
    }
  }
#line 178
  return ((hfsvol *)0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_flush(hfsvol *vol ) 
{ 
  hfsfile *file___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 189
  tmp = getvol(& vol);
  }
#line 189
  if (tmp == -1) {
#line 190
    goto fail;
  }
#line 192
  file___0 = vol->files;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! file___0) {
#line 192
      goto while_break;
    }
    {
#line 194
    tmp___0 = f_flush(file___0);
    }
#line 194
    if (tmp___0 == -1) {
#line 195
      goto fail;
    }
#line 192
    file___0 = file___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  tmp___1 = v_flush(vol);
  }
#line 198
  if (tmp___1 == -1) {
#line 199
    goto fail;
  }
#line 201
  return (0);
  fail: 
#line 204
  return (-1);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
void hfs_flushall(void) 
{ 
  hfsvol *vol ;

  {
#line 215
  vol = hfs_mounts;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! vol) {
#line 215
      goto while_break;
    }
    {
#line 216
    hfs_flush(vol);
#line 215
    vol = vol->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_umount(hfsvol *vol ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 225
  result = 0;
#line 227
  tmp = getvol(& vol);
  }
#line 227
  if (tmp == -1) {
#line 228
    goto fail;
  }
#line 230
  (vol->refs) --;
#line 230
  if (vol->refs) {
    {
#line 232
    result = v_flush(vol);
    }
#line 233
    goto done;
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! vol->files) {
#line 238
      goto while_break;
    }
    {
#line 240
    tmp___0 = hfs_close(vol->files);
    }
#line 240
    if (tmp___0 == -1) {
#line 241
      result = -1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! vol->dirs) {
#line 244
      goto while_break___0;
    }
    {
#line 246
    tmp___1 = hfs_closedir(vol->dirs);
    }
#line 246
    if (tmp___1 == -1) {
#line 247
      result = -1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 252
  tmp___2 = v_close(vol);
  }
#line 252
  if (tmp___2 == -1) {
#line 253
    result = -1;
  }
#line 257
  if (vol->prev) {
#line 258
    (vol->prev)->next = vol->next;
  }
#line 259
  if (vol->next) {
#line 260
    (vol->next)->prev = vol->prev;
  }
#line 262
  if ((unsigned long )vol == (unsigned long )hfs_mounts) {
#line 263
    hfs_mounts = vol->next;
  }
#line 264
  if ((unsigned long )vol == (unsigned long )curvol) {
#line 265
    curvol = (hfsvol *)0;
  }
#line 267
  if (vol) {
    {
#line 267
    free((void *)vol);
    }
  }
  done: 
#line 270
  return (result);
  fail: 
#line 273
  return (-1);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
void hfs_umountall(void) 
{ 


  {
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! hfs_mounts) {
#line 282
      goto while_break;
    }
    {
#line 283
    hfs_umount(hfs_mounts);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
hfsvol *hfs_getvol(char const   *name___1 ) 
{ 
  hfsvol *vol ;
  int tmp ;

  {
#line 294
  if ((unsigned long )name___1 == (unsigned long )((char const   *)0)) {
#line 295
    return (curvol);
  }
#line 297
  vol = hfs_mounts;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! vol) {
#line 297
      goto while_break;
    }
    {
#line 299
    tmp = d_relstring(name___1, (char const   *)(vol->mdb.drVN));
    }
#line 299
    if (tmp == 0) {
#line 300
      return (vol);
    }
#line 297
    vol = vol->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return ((hfsvol *)0);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
void hfs_setvol(hfsvol *vol ) 
{ 


  {
#line 312
  curvol = vol;
#line 313
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_vstat(hfsvol *vol , hfsvolent *ent ) 
{ 
  int tmp ;

  {
  {
#line 321
  tmp = getvol(& vol);
  }
#line 321
  if (tmp == -1) {
#line 322
    goto fail;
  }
  {
#line 324
  strcpy((char */* __restrict  */)(ent->name), (char const   */* __restrict  */)(vol->mdb.drVN));
  }
#line 326
  if (vol->flags & 4) {
#line 326
    ent->flags = 2;
  } else {
#line 326
    ent->flags = 0;
  }
  {
#line 328
  ent->totbytes = (ULongInt )vol->mdb.drNmAlBlks * vol->mdb.drAlBlkSiz;
#line 329
  ent->freebytes = (ULongInt )vol->mdb.drFreeBks * vol->mdb.drAlBlkSiz;
#line 331
  ent->alblocksz = vol->mdb.drAlBlkSiz;
#line 332
  ent->clumpsz = vol->mdb.drClpSiz;
#line 334
  ent->numfiles = vol->mdb.drFilCnt;
#line 335
  ent->numdirs = vol->mdb.drDirCnt;
#line 337
  ent->crdate = d_ltime((unsigned long )vol->mdb.drCrDate);
#line 338
  ent->mddate = d_ltime((unsigned long )vol->mdb.drLsMod);
#line 339
  ent->bkdate = d_ltime((unsigned long )vol->mdb.drVolBkUp);
#line 341
  ent->blessed = (unsigned long )vol->mdb.drFndrInfo[0];
  }
#line 343
  return (0);
  fail: 
#line 346
  return (-1);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_vsetattr(hfsvol *vol , hfsvolent *ent ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
  {
#line 355
  tmp = getvol(& vol);
  }
#line 355
  if (tmp == -1) {
#line 356
    goto fail;
  }
#line 358
  if (ent->clumpsz % vol->mdb.drAlBlkSiz != 0UL) {
    {
#line 359
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 359
      hfs_error = "illegal clump size";
#line 359
      tmp___0 = __errno_location();
#line 359
      *tmp___0 = 22;
      }
#line 359
      goto fail;
#line 359
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 363
  if (ent->blessed) {
    {
#line 363
    tmp___2 = v_getthread(vol, ent->blessed, (CatDataRec *)0, (node *)0, 3);
    }
#line 363
    if (tmp___2 <= 0) {
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 365
        hfs_error = "illegal blessed folder";
#line 365
        tmp___1 = __errno_location();
#line 365
        *tmp___1 = 22;
        }
#line 365
        goto fail;
#line 365
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 367
  if (vol->flags & 4) {
    {
#line 368
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 368
      hfs_error = (char const   *)0;
#line 368
      tmp___3 = __errno_location();
#line 368
      *tmp___3 = 30;
      }
#line 368
      goto fail;
#line 368
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 370
  vol->mdb.drClpSiz = ent->clumpsz;
#line 372
  tmp___4 = d_mtime(ent->crdate);
#line 372
  vol->mdb.drCrDate = (LongInt )tmp___4;
#line 373
  tmp___5 = d_mtime(ent->mddate);
#line 373
  vol->mdb.drLsMod = (LongInt )tmp___5;
#line 374
  tmp___6 = d_mtime(ent->bkdate);
#line 374
  vol->mdb.drVolBkUp = (LongInt )tmp___6;
#line 376
  vol->mdb.drFndrInfo[0] = (LongInt )ent->blessed;
#line 378
  vol->flags |= 16;
  }
#line 380
  return (0);
  fail: 
#line 383
  return (-1);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_chdir(hfsvol *vol , char const   *path ) 
{ 
  CatDataRec data ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 396
  tmp = getvol(& vol);
  }
#line 396
  if (tmp == -1) {
#line 398
    goto fail;
  } else {
    {
#line 396
    tmp___0 = v_resolve(& vol, path, & data, (long *)0, (char *)0, (node *)0);
    }
#line 396
    if (tmp___0 <= 0) {
#line 398
      goto fail;
    }
  }
#line 400
  if ((int )data.cdrType != 1) {
    {
#line 401
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 401
      hfs_error = (char const   *)0;
#line 401
      tmp___1 = __errno_location();
#line 401
      *tmp___1 = 20;
      }
#line 401
      goto fail;
#line 401
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 403
  vol->cwd = data.u.dir.dirDirID;
#line 405
  return (0);
  fail: 
#line 408
  return (-1);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
unsigned long hfs_getcwd(hfsvol *vol ) 
{ 
  int tmp ;

  {
  {
#line 417
  tmp = getvol(& vol);
  }
#line 417
  if (tmp == -1) {
#line 418
    return (0UL);
  }
#line 420
  return (vol->cwd);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_setcwd(hfsvol *vol , unsigned long id ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 429
  tmp = getvol(& vol);
  }
#line 429
  if (tmp == -1) {
#line 430
    goto fail;
  }
#line 432
  if (id == vol->cwd) {
#line 433
    goto done;
  }
  {
#line 437
  tmp___0 = v_getthread(vol, id, (CatDataRec *)0, (node *)0, 3);
  }
#line 437
  if (tmp___0 <= 0) {
#line 438
    goto fail;
  }
#line 440
  vol->cwd = id;
  done: 
#line 443
  return (0);
  fail: 
#line 446
  return (-1);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_dirinfo(hfsvol *vol , unsigned long *id , char *name___1 ) 
{ 
  CatDataRec thread ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 457
  tmp = getvol(& vol);
  }
#line 457
  if (tmp == -1) {
#line 459
    goto fail;
  } else {
    {
#line 457
    tmp___0 = v_getthread(vol, *id, & thread, (node *)0, 3);
    }
#line 457
    if (tmp___0 <= 0) {
#line 459
      goto fail;
    }
  }
#line 461
  *id = thread.u.dthd.thdParID;
#line 463
  if (name___1) {
    {
#line 464
    strcpy((char */* __restrict  */)name___1, (char const   */* __restrict  */)(thread.u.dthd.thdCName));
    }
  }
#line 466
  return (0);
  fail: 
#line 469
  return (-1);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
hfsdir *hfs_opendir(hfsvol *vol , char const   *path ) 
{ 
  hfsdir *dir ;
  CatKeyRec key ;
  CatDataRec data ;
  byte pkey[sizeof(CatKeyRec )] ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 478
  dir = (hfsdir *)0;
#line 483
  tmp = getvol(& vol);
  }
#line 483
  if (tmp == -1) {
#line 484
    goto fail;
  }
  {
#line 486
  tmp___0 = malloc(sizeof(hfsdir ));
#line 486
  dir = (hfsdir *)tmp___0;
  }
#line 487
  if ((unsigned long )dir == (unsigned long )((hfsdir *)0)) {
    {
#line 488
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 488
      hfs_error = (char const   *)0;
#line 488
      tmp___1 = __errno_location();
#line 488
      *tmp___1 = 12;
      }
#line 488
      goto fail;
#line 488
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 490
  dir->vol = vol;
#line 492
  if ((int const   )*path == 0) {
#line 496
    dir->dirid = 0UL;
#line 497
    dir->vptr = hfs_mounts;
  } else {
    {
#line 501
    tmp___2 = v_resolve(& vol, path, & data, (long *)0, (char *)0, (node *)0);
    }
#line 501
    if (tmp___2 <= 0) {
#line 502
      goto fail;
    }
#line 504
    if ((int )data.cdrType != 1) {
      {
#line 505
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 505
        hfs_error = (char const   *)0;
#line 505
        tmp___3 = __errno_location();
#line 505
        *tmp___3 = 20;
        }
#line 505
        goto fail;
#line 505
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 507
    dir->dirid = data.u.dir.dirDirID;
#line 508
    dir->vptr = (struct _hfsvol_ *)0;
#line 510
    r_makecatkey(& key, dir->dirid, "");
#line 511
    r_packcatkey((CatKeyRec const   *)(& key), pkey, (unsigned int *)0);
#line 513
    tmp___4 = bt_search(& vol->cat, (byte const   *)(pkey), & dir->n);
    }
#line 513
    if (tmp___4 <= 0) {
#line 514
      goto fail;
    }
  }
#line 517
  dir->prev = (struct _hfsdir_ *)0;
#line 518
  dir->next = vol->dirs;
#line 520
  if (vol->dirs) {
#line 521
    (vol->dirs)->prev = dir;
  }
#line 523
  vol->dirs = dir;
#line 525
  return (dir);
  fail: 
#line 528
  if (dir) {
    {
#line 528
    free((void *)dir);
    }
  }
#line 529
  return ((hfsdir *)0);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_readdir(hfsdir *dir , hfsdirent *ent ) 
{ 
  CatKeyRec key ;
  CatDataRec data ;
  byte const   *ptr ;
  hfsvol *vol ;
  char cname[32] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 542
  if (dir->dirid == 0UL) {
#line 547
    vol = hfs_mounts;
    {
#line 547
    while (1) {
      while_continue: /* CIL Label */ ;
#line 547
      if (! vol) {
#line 547
        goto while_break;
      }
#line 549
      if ((unsigned long )vol == (unsigned long )dir->vptr) {
#line 550
        goto while_break;
      }
#line 547
      vol = vol->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 553
    if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
      {
#line 554
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 554
        hfs_error = "no more entries";
#line 554
        tmp = __errno_location();
#line 554
        *tmp = 2;
        }
#line 554
        goto fail;
#line 554
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 556
    tmp___0 = v_getthread(vol, 2UL, & data, (node *)0, 3);
    }
#line 556
    if (tmp___0 <= 0) {
#line 559
      goto fail;
    } else {
      {
#line 556
      tmp___1 = v_catsearch(vol, 1UL, (char const   *)(data.u.dthd.thdCName), & data,
                            cname, (node *)0);
      }
#line 556
      if (tmp___1 <= 0) {
#line 559
        goto fail;
      }
    }
    {
#line 561
    r_unpackdirent(1UL, (char const   *)(cname), (CatDataRec const   *)(& data), ent);
#line 563
    dir->vptr = vol->next;
    }
#line 565
    goto done;
  }
#line 568
  if (dir->n.rnum == -1) {
    {
#line 569
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 569
      hfs_error = "no more entries";
#line 569
      tmp___2 = __errno_location();
#line 569
      *tmp___2 = 2;
      }
#line 569
      goto fail;
#line 569
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 571
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 573
    (dir->n.rnum) ++;
    {
#line 575
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 575
      if (! (dir->n.rnum >= (int )dir->n.nd.ndNRecs)) {
#line 575
        goto while_break___3;
      }
#line 577
      if (dir->n.nd.ndFLink == 0UL) {
#line 579
        dir->n.rnum = -1;
        {
#line 580
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 580
          hfs_error = "no more entries";
#line 580
          tmp___3 = __errno_location();
#line 580
          *tmp___3 = 2;
          }
#line 580
          goto fail;
#line 580
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 583
      tmp___4 = bt_getnode(& dir->n, dir->n.bt, dir->n.nd.ndFLink);
      }
#line 583
      if (tmp___4 == -1) {
#line 585
        dir->n.rnum = -1;
#line 586
        goto fail;
      }
#line 589
      dir->n.rnum = 0;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 592
    ptr = (byte const   *)(dir->n.data + (int )dir->n.roff[dir->n.rnum]);
#line 594
    r_unpackcatkey(ptr, & key);
    }
#line 596
    if (key.ckrParID != dir->dirid) {
#line 598
      dir->n.rnum = -1;
      {
#line 599
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 599
        hfs_error = "no more entries";
#line 599
        tmp___5 = __errno_location();
#line 599
        *tmp___5 = 2;
        }
#line 599
        goto fail;
#line 599
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 602
    r_unpackcatdata(ptr + (size_t )(((1 + (int )*ptr) + 1) & -2), & data);
    }
    {
#line 607
    if ((int )data.cdrType == 2) {
#line 607
      goto case_2;
    }
#line 607
    if ((int )data.cdrType == 1) {
#line 607
      goto case_2;
    }
#line 612
    if ((int )data.cdrType == 4) {
#line 612
      goto case_4;
    }
#line 612
    if ((int )data.cdrType == 3) {
#line 612
      goto case_4;
    }
#line 615
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 608
    r_unpackdirent(key.ckrParID, (char const   *)(key.ckrCName), (CatDataRec const   *)(& data),
                   ent);
    }
#line 609
    goto done;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 613
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 616
    dir->n.rnum = -1;
    {
#line 617
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 617
      hfs_error = "unexpected directory entry found";
#line 617
      tmp___6 = __errno_location();
#line 617
      *tmp___6 = 5;
      }
#line 617
      goto fail;
#line 617
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  done: 
#line 622
  return (0);
  fail: 
#line 625
  return (-1);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_closedir(hfsdir *dir ) 
{ 
  hfsvol *vol ;

  {
#line 634
  vol = dir->vol;
#line 636
  if (dir->prev) {
#line 637
    (dir->prev)->next = dir->next;
  }
#line 638
  if (dir->next) {
#line 639
    (dir->next)->prev = dir->prev;
  }
#line 640
  if ((unsigned long )dir == (unsigned long )vol->dirs) {
#line 641
    vol->dirs = dir->next;
  }
#line 643
  if (dir) {
    {
#line 643
    free((void *)dir);
    }
  }
#line 645
  return (0);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
hfsfile *hfs_create(hfsvol *vol , char const   *path , char const   *type , char const   *creator ) 
{ 
  hfsfile *file___0 ;
  unsigned long parid ;
  char name___1[32] ;
  CatKeyRec key ;
  byte record[sizeof(CatKeyRec ) + sizeof(CatDataRec )] ;
  unsigned int reclen ;
  int found ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  LongInt tmp___6 ;
  time_t tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 657
  file___0 = (hfsfile *)0;
#line 665
  tmp = getvol(& vol);
  }
#line 665
  if (tmp == -1) {
#line 666
    goto fail;
  }
  {
#line 668
  tmp___0 = malloc(sizeof(hfsfile ));
#line 668
  file___0 = (hfsfile *)tmp___0;
  }
#line 669
  if ((unsigned long )file___0 == (unsigned long )((hfsfile *)0)) {
    {
#line 670
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 670
      hfs_error = (char const   *)0;
#line 670
      tmp___1 = __errno_location();
#line 670
      *tmp___1 = 12;
      }
#line 670
      goto fail;
#line 670
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 672
  found = v_resolve(& vol, path, & file___0->cat, (long *)(& parid), name___1, (node *)0);
  }
#line 673
  if (found == -1) {
#line 674
    goto fail;
  } else
#line 673
  if (parid == 0UL) {
#line 674
    goto fail;
  }
#line 676
  if (found) {
    {
#line 677
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 677
      hfs_error = (char const   *)0;
#line 677
      tmp___2 = __errno_location();
#line 677
      *tmp___2 = 17;
      }
#line 677
      goto fail;
#line 677
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 679
  if (parid == 1UL) {
    {
#line 680
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 680
      hfs_error = (char const   *)0;
#line 680
      tmp___3 = __errno_location();
#line 680
      *tmp___3 = 22;
      }
#line 680
      goto fail;
#line 680
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 682
  if (vol->flags & 4) {
    {
#line 683
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 683
      hfs_error = (char const   *)0;
#line 683
      tmp___4 = __errno_location();
#line 683
      *tmp___4 = 30;
      }
#line 683
      goto fail;
#line 683
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 687
  tmp___5 = bt_space(& vol->cat, 1U);
  }
#line 687
  if (tmp___5 == -1) {
#line 688
    goto fail;
  }
  {
#line 690
  tmp___6 = vol->mdb.drNxtCNID;
#line 690
  (vol->mdb.drNxtCNID) ++;
#line 690
  f_init(file___0, vol, tmp___6, (char const   *)(name___1));
#line 691
  vol->flags |= 16;
#line 693
  file___0->parid = parid;
#line 697
  file___0->cat.u.fil.filUsrWds.fdType = d_getsl((unsigned char const   *)type);
#line 699
  file___0->cat.u.fil.filUsrWds.fdCreator = d_getsl((unsigned char const   *)creator);
#line 702
  tmp___7 = time((time_t *)0);
#line 702
  tmp___8 = d_mtime(tmp___7);
#line 702
  file___0->cat.u.fil.filCrDat = (LongInt )tmp___8;
#line 703
  file___0->cat.u.fil.filMdDat = file___0->cat.u.fil.filCrDat;
#line 705
  r_makecatkey(& key, file___0->parid, (char const   *)(file___0->name));
#line 706
  r_packcatrec((CatKeyRec const   *)(& key), (CatDataRec const   *)(& file___0->cat),
               record, & reclen);
#line 708
  tmp___9 = bt_insert(& vol->cat, (byte const   *)(record), reclen);
  }
#line 708
  if (tmp___9 == -1) {
#line 710
    goto fail;
  } else {
    {
#line 708
    tmp___10 = v_adjvalence(vol, file___0->parid, 0, 1);
    }
#line 708
    if (tmp___10 == -1) {
#line 710
      goto fail;
    }
  }
#line 714
  file___0->next = vol->files;
#line 716
  if (vol->files) {
#line 717
    (vol->files)->prev = file___0;
  }
#line 719
  vol->files = file___0;
#line 721
  return (file___0);
  fail: 
#line 724
  if (file___0) {
    {
#line 724
    free((void *)file___0);
    }
  }
#line 725
  return ((hfsfile *)0);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
hfsfile *hfs_open(hfsvol *vol , char const   *path ) 
{ 
  hfsfile *file___0 ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 734
  file___0 = (hfsfile *)0;
#line 736
  tmp = getvol(& vol);
  }
#line 736
  if (tmp == -1) {
#line 737
    goto fail;
  }
  {
#line 739
  tmp___0 = malloc(sizeof(hfsfile ));
#line 739
  file___0 = (hfsfile *)tmp___0;
  }
#line 740
  if ((unsigned long )file___0 == (unsigned long )((hfsfile *)0)) {
    {
#line 741
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 741
      hfs_error = (char const   *)0;
#line 741
      tmp___1 = __errno_location();
#line 741
      *tmp___1 = 12;
      }
#line 741
      goto fail;
#line 741
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 743
  tmp___2 = v_resolve(& vol, path, & file___0->cat, (long *)(& file___0->parid), file___0->name,
                      (node *)0);
  }
#line 743
  if (tmp___2 <= 0) {
#line 744
    goto fail;
  }
#line 746
  if ((int )file___0->cat.cdrType != 2) {
    {
#line 747
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 747
      hfs_error = (char const   *)0;
#line 747
      tmp___3 = __errno_location();
#line 747
      *tmp___3 = 21;
      }
#line 747
      goto fail;
#line 747
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 751
  file___0->vol = vol;
#line 752
  file___0->flags = 0;
#line 754
  f_selectfork(file___0, 0);
#line 756
  file___0->prev = (struct _hfsfile_ *)0;
#line 757
  file___0->next = vol->files;
  }
#line 759
  if (vol->files) {
#line 760
    (vol->files)->prev = file___0;
  }
#line 762
  vol->files = file___0;
#line 764
  return (file___0);
  fail: 
#line 767
  if (file___0) {
    {
#line 767
    free((void *)file___0);
    }
  }
#line 768
  return ((hfsfile *)0);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_setfork(hfsfile *file___0 , int fork ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 777
  result = 0;
#line 779
  tmp = f_trunc(file___0);
  }
#line 779
  if (tmp == -1) {
#line 780
    result = -1;
  }
#line 782
  if (fork) {
#line 782
    tmp___0 = 255;
  } else {
#line 782
    tmp___0 = 0;
  }
  {
#line 782
  f_selectfork(file___0, tmp___0);
  }
#line 784
  return (result);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_getfork(hfsfile *file___0 ) 
{ 


  {
#line 793
  return (file___0->fork != 0);
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
unsigned long hfs_read(hfsfile *file___0 , void *buf , unsigned long len ) 
{ 
  unsigned long *lglen ;
  unsigned long count ;
  byte *ptr ;
  unsigned long bnum ;
  unsigned long offs ;
  unsigned long chunk ;
  int tmp ;
  block b ;
  int tmp___0 ;

  {
  {
#line 803
  ptr = (byte *)buf;
#line 805
  f_getptrs(file___0, (ExtDataRec **)0, & lglen, (unsigned long **)0);
  }
#line 807
  if (file___0->pos + len > *lglen) {
#line 808
    len = *lglen - file___0->pos;
  }
#line 810
  count = len;
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (! count) {
#line 811
      goto while_break;
    }
#line 815
    bnum = file___0->pos >> 9;
#line 816
    offs = file___0->pos & 511UL;
#line 818
    chunk = 512UL - offs;
#line 819
    if (chunk > count) {
#line 820
      chunk = count;
    }
#line 822
    if (offs == 0UL) {
#line 822
      if (chunk == 512UL) {
        {
#line 824
        tmp = f_doblock(file___0, bnum, (block *)ptr, & b_readab);
        }
#line 824
        if (tmp == -1) {
#line 825
          goto fail;
        }
      } else {
#line 822
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 831
      tmp___0 = f_doblock(file___0, bnum, & b, & b_readab);
      }
#line 831
      if (tmp___0 == -1) {
#line 832
        goto fail;
      }
      {
#line 834
      memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(b + offs),
             chunk);
      }
    }
#line 837
    ptr += chunk;
#line 839
    file___0->pos += chunk;
#line 840
    count -= chunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 843
  return (len);
  fail: 
#line 846
  return (0xffffffffffffffffUL);
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
unsigned long hfs_write(hfsfile *file___0 , void const   *buf , unsigned long len ) 
{ 
  unsigned long *lglen ;
  unsigned long *pylen ;
  unsigned long count ;
  byte const   *ptr ;
  int *tmp ;
  time_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long bnum ;
  unsigned long offs ;
  unsigned long chunk ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  block b ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 856
  ptr = (byte const   *)buf;
#line 858
  if ((file___0->vol)->flags & 4) {
    {
#line 859
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 859
      hfs_error = (char const   *)0;
#line 859
      tmp = __errno_location();
#line 859
      *tmp = 30;
      }
#line 859
      goto fail;
#line 859
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 861
  f_getptrs(file___0, (ExtDataRec **)0, & lglen, & pylen);
#line 863
  count = len;
  }
#line 867
  if (count) {
    {
#line 869
    tmp___0 = time((time_t *)0);
#line 869
    tmp___1 = d_mtime(tmp___0);
#line 869
    file___0->cat.u.fil.filMdDat = (LongInt )tmp___1;
#line 870
    file___0->flags |= 1;
    }
  }
  {
#line 873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 873
    if (! count) {
#line 873
      goto while_break___0;
    }
#line 877
    bnum = file___0->pos >> 9;
#line 878
    offs = file___0->pos & 511UL;
#line 880
    chunk = 512UL - offs;
#line 881
    if (chunk > count) {
#line 882
      chunk = count;
    }
#line 884
    if (file___0->pos + chunk > *pylen) {
      {
#line 886
      tmp___2 = bt_space(& (file___0->vol)->ext, 1U);
      }
#line 886
      if (tmp___2 == -1) {
#line 888
        goto fail;
      } else {
        {
#line 886
        tmp___3 = f_alloc(file___0);
        }
#line 886
        if (tmp___3 == -1L) {
#line 888
          goto fail;
        }
      }
    }
#line 891
    if (offs == 0UL) {
#line 891
      if (chunk == 512UL) {
        {
#line 893
        tmp___4 = f_doblock(file___0, bnum, (block *)ptr, (int (*)(hfsvol * , unsigned int  ,
                                                                   unsigned int  ,
                                                                   block * ))(& b_writeab));
        }
#line 893
        if (tmp___4 == -1) {
#line 894
          goto fail;
        }
      } else {
#line 891
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 900
      tmp___5 = f_doblock(file___0, bnum, & b, & b_readab);
      }
#line 900
      if (tmp___5 == -1) {
#line 901
        goto fail;
      }
      {
#line 903
      memcpy((void */* __restrict  */)(b + offs), (void const   */* __restrict  */)ptr,
             chunk);
#line 905
      tmp___6 = f_doblock(file___0, bnum, & b, (int (*)(hfsvol * , unsigned int  ,
                                                        unsigned int  , block * ))(& b_writeab));
      }
#line 905
      if (tmp___6 == -1) {
#line 906
        goto fail;
      }
    }
#line 909
    ptr += chunk;
#line 911
    file___0->pos += chunk;
#line 912
    count -= chunk;
#line 914
    if (file___0->pos > *lglen) {
#line 915
      *lglen = file___0->pos;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 918
  return (len);
  fail: 
#line 921
  return (0xffffffffffffffffUL);
}
}
#line 928 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_truncate(hfsfile *file___0 , unsigned long len ) 
{ 
  unsigned long *lglen ;
  int *tmp ;
  time_t tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 932
  f_getptrs(file___0, (ExtDataRec **)0, & lglen, (unsigned long **)0);
  }
#line 934
  if (*lglen > len) {
#line 936
    if ((file___0->vol)->flags & 4) {
      {
#line 937
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 937
        hfs_error = (char const   *)0;
#line 937
        tmp = __errno_location();
#line 937
        *tmp = 30;
        }
#line 937
        goto fail;
#line 937
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 939
    *lglen = len;
#line 941
    tmp___0 = time((time_t *)0);
#line 941
    tmp___1 = d_mtime(tmp___0);
#line 941
    file___0->cat.u.fil.filMdDat = (LongInt )tmp___1;
#line 942
    file___0->flags |= 1;
    }
#line 944
    if (file___0->pos > len) {
#line 945
      file___0->pos = len;
    }
  }
#line 948
  return (0);
  fail: 
#line 951
  return (-1);
}
}
#line 958 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
unsigned long hfs_seek(hfsfile *file___0 , long offset , int from ) 
{ 
  unsigned long *lglen ;
  unsigned long newpos ;
  int *tmp ;

  {
  {
#line 962
  f_getptrs(file___0, (ExtDataRec **)0, & lglen, (unsigned long **)0);
  }
  {
#line 966
  if (from == 0) {
#line 966
    goto case_0;
  }
#line 970
  if (from == 1) {
#line 970
    goto case_1;
  }
#line 977
  if (from == 2) {
#line 977
    goto case_2;
  }
#line 984
  goto switch_default;
  case_0: /* CIL Label */ 
#line 967
  if (offset < 0L) {
#line 967
    newpos = 0UL;
  } else {
#line 967
    newpos = (unsigned long )offset;
  }
#line 968
  goto switch_break;
  case_1: /* CIL Label */ 
#line 971
  if (offset < 0L) {
#line 971
    if ((unsigned long )(- offset) > file___0->pos) {
#line 972
      newpos = 0UL;
    } else {
#line 974
      newpos = file___0->pos + (unsigned long )offset;
    }
  } else {
#line 974
    newpos = file___0->pos + (unsigned long )offset;
  }
#line 975
  goto switch_break;
  case_2: /* CIL Label */ 
#line 978
  if (offset < 0L) {
#line 978
    if ((unsigned long )(- offset) > *lglen) {
#line 979
      newpos = 0UL;
    } else {
#line 981
      newpos = *lglen + (unsigned long )offset;
    }
  } else {
#line 981
    newpos = *lglen + (unsigned long )offset;
  }
#line 982
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 985
    hfs_error = (char const   *)0;
#line 985
    tmp = __errno_location();
#line 985
    *tmp = 22;
    }
#line 985
    goto fail;
#line 985
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 988
  if (newpos > *lglen) {
#line 989
    newpos = *lglen;
  }
#line 991
  file___0->pos = newpos;
#line 993
  return (newpos);
  fail: 
#line 996
  return (0xffffffffffffffffUL);
}
}
#line 1003 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_close(hfsfile *file___0 ) 
{ 
  hfsvol *vol ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1005
  vol = file___0->vol;
#line 1006
  result = 0;
#line 1008
  tmp = f_trunc(file___0);
  }
#line 1008
  if (tmp == -1) {
#line 1010
    result = -1;
  } else {
    {
#line 1008
    tmp___0 = f_flush(file___0);
    }
#line 1008
    if (tmp___0 == -1) {
#line 1010
      result = -1;
    }
  }
#line 1012
  if (file___0->prev) {
#line 1013
    (file___0->prev)->next = file___0->next;
  }
#line 1014
  if (file___0->next) {
#line 1015
    (file___0->next)->prev = file___0->prev;
  }
#line 1016
  if ((unsigned long )file___0 == (unsigned long )vol->files) {
#line 1017
    vol->files = file___0->next;
  }
#line 1019
  if (file___0) {
    {
#line 1019
    free((void *)file___0);
    }
  }
#line 1021
  return (result);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_stat(hfsvol *vol , char const   *path , hfsdirent *ent ) 
{ 
  CatDataRec data ;
  unsigned long parid ;
  char name___1[32] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1036
  tmp = getvol(& vol);
  }
#line 1036
  if (tmp == -1) {
#line 1038
    goto fail;
  } else {
    {
#line 1036
    tmp___0 = v_resolve(& vol, path, & data, (long *)(& parid), name___1, (node *)0);
    }
#line 1036
    if (tmp___0 <= 0) {
#line 1038
      goto fail;
    }
  }
  {
#line 1040
  r_unpackdirent(parid, (char const   *)(name___1), (CatDataRec const   *)(& data),
                 ent);
  }
#line 1042
  return (0);
  fail: 
#line 1045
  return (-1);
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_fstat(hfsfile *file___0 , hfsdirent *ent ) 
{ 


  {
  {
#line 1054
  r_unpackdirent(file___0->parid, (char const   *)(file___0->name), (CatDataRec const   *)(& file___0->cat),
                 ent);
  }
#line 1056
  return (0);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_setattr(hfsvol *vol , char const   *path , hfsdirent const   *ent ) 
{ 
  CatDataRec data ;
  node n ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1068
  tmp = getvol(& vol);
  }
#line 1068
  if (tmp == -1) {
#line 1070
    goto fail;
  } else {
    {
#line 1068
    tmp___0 = v_resolve(& vol, path, & data, (long *)0, (char *)0, & n);
    }
#line 1068
    if (tmp___0 <= 0) {
#line 1070
      goto fail;
    }
  }
#line 1072
  if (vol->flags & 4) {
    {
#line 1073
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1073
      hfs_error = (char const   *)0;
#line 1073
      tmp___1 = __errno_location();
#line 1073
      *tmp___1 = 30;
      }
#line 1073
      goto fail;
#line 1073
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1075
  r_packdirent(& data, ent);
#line 1077
  tmp___2 = v_putcatrec((CatDataRec const   *)(& data), & n);
  }
#line 1077
  return (tmp___2);
  fail: 
#line 1080
  return (-1);
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_fsetattr(hfsfile *file___0 , hfsdirent const   *ent ) 
{ 
  int *tmp ;

  {
#line 1089
  if ((file___0->vol)->flags & 4) {
    {
#line 1090
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1090
      hfs_error = (char const   *)0;
#line 1090
      tmp = __errno_location();
#line 1090
      *tmp = 30;
      }
#line 1090
      goto fail;
#line 1090
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1092
  r_packdirent(& file___0->cat, ent);
#line 1094
  file___0->flags |= 1;
  }
#line 1096
  return (0);
  fail: 
#line 1099
  return (-1);
}
}
#line 1106 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_mkdir(hfsvol *vol , char const   *path ) 
{ 
  CatDataRec data ;
  unsigned long parid ;
  char name___1[32] ;
  int found ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1113
  tmp = getvol(& vol);
  }
#line 1113
  if (tmp == -1) {
#line 1114
    goto fail;
  }
  {
#line 1116
  found = v_resolve(& vol, path, & data, (long *)(& parid), name___1, (node *)0);
  }
#line 1117
  if (found == -1) {
#line 1118
    goto fail;
  } else
#line 1117
  if (parid == 0UL) {
#line 1118
    goto fail;
  }
#line 1120
  if (found) {
    {
#line 1121
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1121
      hfs_error = (char const   *)0;
#line 1121
      tmp___0 = __errno_location();
#line 1121
      *tmp___0 = 17;
      }
#line 1121
      goto fail;
#line 1121
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1123
  if (parid == 1UL) {
    {
#line 1124
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1124
      hfs_error = (char const   *)0;
#line 1124
      tmp___1 = __errno_location();
#line 1124
      *tmp___1 = 22;
      }
#line 1124
      goto fail;
#line 1124
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1126
  if (vol->flags & 4) {
    {
#line 1127
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1127
      hfs_error = (char const   *)0;
#line 1127
      tmp___2 = __errno_location();
#line 1127
      *tmp___2 = 30;
      }
#line 1127
      goto fail;
#line 1127
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1129
  tmp___3 = v_mkdir(vol, parid, (char const   *)(name___1));
  }
#line 1129
  return (tmp___3);
  fail: 
#line 1132
  return (-1);
}
}
#line 1139 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_rmdir(hfsvol *vol , char const   *path ) 
{ 
  CatKeyRec key ;
  CatDataRec data ;
  unsigned long parid ;
  char name___1[32] ;
  byte pkey[sizeof(CatKeyRec )] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1147
  tmp = getvol(& vol);
  }
#line 1147
  if (tmp == -1) {
#line 1149
    goto fail;
  } else {
    {
#line 1147
    tmp___0 = v_resolve(& vol, path, & data, (long *)(& parid), name___1, (node *)0);
    }
#line 1147
    if (tmp___0 <= 0) {
#line 1149
      goto fail;
    }
  }
#line 1151
  if ((int )data.cdrType != 1) {
    {
#line 1152
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1152
      hfs_error = (char const   *)0;
#line 1152
      tmp___1 = __errno_location();
#line 1152
      *tmp___1 = 20;
      }
#line 1152
      goto fail;
#line 1152
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1154
  if ((int )data.u.dir.dirVal != 0) {
    {
#line 1155
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1155
      hfs_error = (char const   *)0;
#line 1155
      tmp___2 = __errno_location();
#line 1155
      *tmp___2 = 39;
      }
#line 1155
      goto fail;
#line 1155
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1157
  if (parid == 1UL) {
    {
#line 1158
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1158
      hfs_error = (char const   *)0;
#line 1158
      tmp___3 = __errno_location();
#line 1158
      *tmp___3 = 22;
      }
#line 1158
      goto fail;
#line 1158
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1160
  if (vol->flags & 4) {
    {
#line 1161
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1161
      hfs_error = (char const   *)0;
#line 1161
      tmp___4 = __errno_location();
#line 1161
      *tmp___4 = 30;
      }
#line 1161
      goto fail;
#line 1161
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1165
  r_makecatkey(& key, parid, (char const   *)(name___1));
#line 1166
  r_packcatkey((CatKeyRec const   *)(& key), pkey, (unsigned int *)0);
#line 1168
  tmp___5 = bt_delete(& vol->cat, (byte const   *)(pkey));
  }
#line 1168
  if (tmp___5 == -1) {
#line 1169
    goto fail;
  }
  {
#line 1173
  r_makecatkey(& key, data.u.dir.dirDirID, "");
#line 1174
  r_packcatkey((CatKeyRec const   *)(& key), pkey, (unsigned int *)0);
#line 1176
  tmp___6 = bt_delete(& vol->cat, (byte const   *)(pkey));
  }
#line 1176
  if (tmp___6 == -1) {
#line 1178
    goto fail;
  } else {
    {
#line 1176
    tmp___7 = v_adjvalence(vol, parid, 1, -1);
    }
#line 1176
    if (tmp___7 == -1) {
#line 1178
      goto fail;
    }
  }
#line 1180
  return (0);
  fail: 
#line 1183
  return (-1);
}
}
#line 1190 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_delete(hfsvol *vol , char const   *path ) 
{ 
  hfsfile file___0 ;
  CatKeyRec key ;
  byte pkey[sizeof(CatKeyRec )] ;
  int found ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1197
  tmp = getvol(& vol);
  }
#line 1197
  if (tmp == -1) {
#line 1199
    goto fail;
  } else {
    {
#line 1197
    tmp___0 = v_resolve(& vol, path, & file___0.cat, (long *)(& file___0.parid), file___0.name,
                        (node *)0);
    }
#line 1197
    if (tmp___0 <= 0) {
#line 1199
      goto fail;
    }
  }
#line 1201
  if ((int )file___0.cat.cdrType != 2) {
    {
#line 1202
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1202
      hfs_error = (char const   *)0;
#line 1202
      tmp___1 = __errno_location();
#line 1202
      *tmp___1 = 21;
      }
#line 1202
      goto fail;
#line 1202
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1204
  if (file___0.parid == 1UL) {
    {
#line 1205
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1205
      hfs_error = (char const   *)0;
#line 1205
      tmp___2 = __errno_location();
#line 1205
      *tmp___2 = 22;
      }
#line 1205
      goto fail;
#line 1205
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1207
  if (vol->flags & 4) {
    {
#line 1208
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1208
      hfs_error = (char const   *)0;
#line 1208
      tmp___3 = __errno_location();
#line 1208
      *tmp___3 = 30;
      }
#line 1208
      goto fail;
#line 1208
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1212
  file___0.vol = vol;
#line 1213
  file___0.flags = 0;
#line 1215
  file___0.cat.u.fil.filLgLen = (ULongInt )0;
#line 1216
  file___0.cat.u.fil.filRLgLen = (ULongInt )0;
#line 1218
  f_selectfork(& file___0, 0);
#line 1219
  tmp___4 = f_trunc(& file___0);
  }
#line 1219
  if (tmp___4 == -1) {
#line 1220
    goto fail;
  }
  {
#line 1222
  f_selectfork(& file___0, 255);
#line 1223
  tmp___5 = f_trunc(& file___0);
  }
#line 1223
  if (tmp___5 == -1) {
#line 1224
    goto fail;
  }
  {
#line 1228
  r_makecatkey(& key, file___0.parid, (char const   *)(file___0.name));
#line 1229
  r_packcatkey((CatKeyRec const   *)(& key), pkey, (unsigned int *)0);
#line 1231
  tmp___6 = bt_delete(& vol->cat, (byte const   *)(pkey));
  }
#line 1231
  if (tmp___6 == -1) {
#line 1233
    goto fail;
  } else {
    {
#line 1231
    tmp___7 = v_adjvalence(vol, file___0.parid, 0, -1);
    }
#line 1231
    if (tmp___7 == -1) {
#line 1233
      goto fail;
    }
  }
  {
#line 1237
  found = v_getthread(vol, file___0.cat.u.fil.filFlNum, (CatDataRec *)0, (node *)0,
                      4);
  }
#line 1238
  if (found == -1) {
#line 1239
    goto fail;
  }
#line 1241
  if (found) {
    {
#line 1243
    r_makecatkey(& key, file___0.cat.u.fil.filFlNum, "");
#line 1244
    r_packcatkey((CatKeyRec const   *)(& key), pkey, (unsigned int *)0);
#line 1246
    tmp___8 = bt_delete(& vol->cat, (byte const   *)(pkey));
    }
#line 1246
    if (tmp___8 == -1) {
#line 1247
      goto fail;
    }
  }
#line 1250
  return (0);
  fail: 
#line 1253
  return (-1);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_rename(hfsvol *vol , char const   *srcpath , char const   *dstpath ) 
{ 
  hfsvol *srcvol ;
  CatDataRec src ;
  CatDataRec dst ;
  unsigned long srcid ;
  unsigned long dstid ;
  CatKeyRec key ;
  char srcname[32] ;
  char dstname[32] ;
  byte record[sizeof(CatKeyRec ) + sizeof(CatDataRec )] ;
  unsigned int reclen ;
  int found ;
  int isdir ;
  int moving ;
  node n ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *ptr ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  unsigned long id ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 1272
  tmp = getvol(& vol);
  }
#line 1272
  if (tmp == -1) {
#line 1274
    goto fail;
  } else {
    {
#line 1272
    tmp___0 = v_resolve(& vol, srcpath, & src, (long *)(& srcid), srcname, (node *)0);
    }
#line 1272
    if (tmp___0 <= 0) {
#line 1274
      goto fail;
    }
  }
  {
#line 1276
  isdir = (int )src.cdrType == 1;
#line 1277
  srcvol = vol;
#line 1279
  found = v_resolve(& vol, dstpath, & dst, (long *)(& dstid), dstname, (node *)0);
  }
#line 1280
  if (found == -1) {
#line 1281
    goto fail;
  }
#line 1283
  if ((unsigned long )vol != (unsigned long )srcvol) {
    {
#line 1284
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1284
      hfs_error = "can\'t move across volumes";
#line 1284
      tmp___1 = __errno_location();
#line 1284
      *tmp___1 = 22;
      }
#line 1284
      goto fail;
#line 1284
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1286
  if (dstid == 0UL) {
    {
#line 1287
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1287
      hfs_error = "bad destination path";
#line 1287
      tmp___2 = __errno_location();
#line 1287
      *tmp___2 = 2;
      }
#line 1287
      goto fail;
#line 1287
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1289
  if (found) {
#line 1289
    if ((int )dst.cdrType == 1) {
#line 1289
      if (dst.u.dir.dirDirID != src.u.dir.dirDirID) {
        {
#line 1293
        dstid = dst.u.dir.dirDirID;
#line 1294
        strcpy((char */* __restrict  */)(dstname), (char const   */* __restrict  */)(srcname));
#line 1296
        found = v_catsearch(vol, dstid, (char const   *)(dstname), (CatDataRec *)0,
                            (char *)0, (node *)0);
        }
#line 1297
        if (found == -1) {
#line 1298
          goto fail;
        }
      }
    }
  }
#line 1301
  moving = srcid != dstid;
#line 1303
  if (found) {
    {
#line 1307
    tmp___3 = strrchr(dstpath, ':');
#line 1307
    ptr = (char const   *)tmp___3;
    }
#line 1308
    if ((unsigned long )ptr == (unsigned long )((char const   *)0)) {
#line 1309
      ptr = dstpath;
    } else {
#line 1311
      ptr ++;
    }
#line 1313
    if (*ptr) {
      {
#line 1314
      strcpy((char */* __restrict  */)(dstname), (char const   */* __restrict  */)ptr);
      }
    }
#line 1316
    if (! moving) {
      {
#line 1316
      tmp___4 = strcmp((char const   *)(srcname), (char const   *)(dstname));
      }
#line 1316
      if (tmp___4 == 0) {
#line 1317
        goto done;
      }
    }
#line 1319
    if (moving) {
#line 1319
      goto _L;
    } else {
      {
#line 1319
      tmp___6 = d_relstring((char const   *)(srcname), (char const   *)(dstname));
      }
#line 1319
      if (tmp___6) {
        _L: /* CIL Label */ 
        {
#line 1320
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1320
          hfs_error = "can\'t use destination name";
#line 1320
          tmp___5 = __errno_location();
#line 1320
          *tmp___5 = 17;
          }
#line 1320
          goto fail;
#line 1320
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 1325
  if (moving) {
#line 1325
    if (dstid == 1UL) {
      {
#line 1326
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1326
        hfs_error = "can\'t move above root directory";
#line 1326
        tmp___7 = __errno_location();
#line 1326
        *tmp___7 = 22;
        }
#line 1326
        goto fail;
#line 1326
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1328
  if (moving) {
#line 1328
    if (isdir) {
#line 1334
      if (src.u.dir.dirDirID == 2UL) {
        {
#line 1335
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1335
          hfs_error = "can\'t move root directory";
#line 1335
          tmp___8 = __errno_location();
#line 1335
          *tmp___8 = 22;
          }
#line 1335
          goto fail;
#line 1335
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1339
      id = dstid;
      {
#line 1339
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1339
        if (! (id != 2UL)) {
#line 1339
          goto while_break___4;
        }
#line 1341
        if (id == src.u.dir.dirDirID) {
          {
#line 1342
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 1342
            hfs_error = "can\'t move directory inside itself";
#line 1342
            tmp___9 = __errno_location();
#line 1342
            *tmp___9 = 22;
            }
#line 1342
            goto fail;
#line 1342
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
        {
#line 1344
        tmp___10 = v_getthread(vol, id, & dst, (node *)0, 3);
        }
#line 1344
        if (tmp___10 <= 0) {
#line 1345
          goto fail;
        }
#line 1339
        id = dst.u.dthd.thdParID;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1349
  if (vol->flags & 4) {
    {
#line 1350
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 1350
      hfs_error = (char const   *)0;
#line 1350
      tmp___11 = __errno_location();
#line 1350
      *tmp___11 = 30;
      }
#line 1350
      goto fail;
#line 1350
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1354
  if (dstid == 1UL) {
    {
#line 1356
    tmp___12 = validvname((char const   *)(dstname));
    }
#line 1356
    if (! tmp___12) {
#line 1357
      goto fail;
    }
    {
#line 1359
    strcpy((char */* __restrict  */)(vol->mdb.drVN), (char const   */* __restrict  */)(dstname));
#line 1360
    vol->flags |= 16;
    }
  }
  {
#line 1365
  r_makecatkey(& key, srcid, (char const   *)(srcname));
#line 1366
  r_packcatkey((CatKeyRec const   *)(& key), record, (unsigned int *)0);
#line 1368
  tmp___13 = bt_delete(& vol->cat, (byte const   *)(record));
  }
#line 1368
  if (tmp___13 == -1) {
#line 1369
    goto fail;
  }
  {
#line 1373
  r_makecatkey(& key, dstid, (char const   *)(dstname));
#line 1374
  r_packcatrec((CatKeyRec const   *)(& key), (CatDataRec const   *)(& src), record,
               & reclen);
#line 1376
  tmp___14 = bt_insert(& vol->cat, (byte const   *)(record), reclen);
  }
#line 1376
  if (tmp___14 == -1) {
#line 1377
    goto fail;
  }
#line 1381
  if (isdir) {
    {
#line 1383
    tmp___15 = v_getthread(vol, src.u.dir.dirDirID, & dst, & n, 3);
    }
#line 1383
    if (tmp___15 <= 0) {
#line 1384
      goto fail;
    }
    {
#line 1386
    dst.u.dthd.thdParID = dstid;
#line 1387
    strcpy((char */* __restrict  */)(dst.u.dthd.thdCName), (char const   */* __restrict  */)(dstname));
#line 1389
    tmp___16 = v_putcatrec((CatDataRec const   *)(& dst), & n);
    }
#line 1389
    if (tmp___16 == -1) {
#line 1390
      goto fail;
    }
  } else {
    {
#line 1394
    found = v_getthread(vol, src.u.fil.filFlNum, & dst, & n, 4);
    }
#line 1395
    if (found == -1) {
#line 1396
      goto fail;
    }
#line 1398
    if (found) {
      {
#line 1400
      dst.u.fthd.fthdParID = dstid;
#line 1401
      strcpy((char */* __restrict  */)(dst.u.fthd.fthdCName), (char const   */* __restrict  */)(dstname));
#line 1403
      tmp___17 = v_putcatrec((CatDataRec const   *)(& dst), & n);
      }
#line 1403
      if (tmp___17 == -1) {
#line 1404
        goto fail;
      }
    }
  }
#line 1410
  if (moving) {
    {
#line 1412
    tmp___18 = v_adjvalence(vol, srcid, isdir, -1);
    }
#line 1412
    if (tmp___18 == -1) {
#line 1414
      goto fail;
    } else {
      {
#line 1412
      tmp___19 = v_adjvalence(vol, dstid, isdir, 1);
      }
#line 1412
      if (tmp___19 == -1) {
#line 1414
        goto fail;
      }
    }
  }
  done: 
#line 1418
  return (0);
  fail: 
#line 1421
  return (-1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_zero(char const   *path , unsigned int maxparts , unsigned long *blocks ) 
{ 
  hfsvol vol ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Partition map ;
  int found ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1434
  v_init(& vol, 256);
  }
#line 1436
  if (maxparts < 1U) {
    {
#line 1437
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1437
      hfs_error = "must allow at least 1 partition";
#line 1437
      tmp = __errno_location();
#line 1437
      *tmp = 22;
      }
#line 1437
      goto fail;
#line 1437
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1439
  tmp___0 = v_open(& vol, path, 1);
  }
#line 1439
  if (tmp___0 == -1) {
#line 1441
    goto fail;
  } else {
    {
#line 1439
    tmp___1 = v_geometry(& vol, 0);
    }
#line 1439
    if (tmp___1 == -1) {
#line 1441
      goto fail;
    }
  }
  {
#line 1443
  tmp___2 = m_zeroddr(& vol);
  }
#line 1443
  if (tmp___2 == -1) {
#line 1445
    goto fail;
  } else {
    {
#line 1443
    tmp___3 = m_zeropm(& vol, 1U + maxparts);
    }
#line 1443
    if (tmp___3 == -1) {
#line 1445
      goto fail;
    }
  }
#line 1447
  if (blocks) {
    {
#line 1452
    found = m_findpmentry(& vol, "Apple_Free", & map, (unsigned long *)0);
    }
#line 1453
    if (found == -1) {
#line 1454
      goto fail;
    }
#line 1456
    if (! found) {
      {
#line 1457
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1457
        hfs_error = "unable to determine free partition space";
#line 1457
        tmp___4 = __errno_location();
#line 1457
        *tmp___4 = 5;
        }
#line 1457
        goto fail;
#line 1457
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1459
    *blocks = (unsigned long )map.pmPartBlkCnt;
  }
  {
#line 1462
  tmp___5 = v_close(& vol);
  }
#line 1462
  if (tmp___5 == -1) {
#line 1463
    goto fail;
  }
#line 1465
  return (0);
  fail: 
  {
#line 1468
  v_close(& vol);
  }
#line 1469
  return (-1);
}
}
#line 1476 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_mkpart(char const   *path , unsigned long len ) 
{ 
  hfsvol vol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1480
  v_init(& vol, 256);
#line 1482
  tmp = v_open(& vol, path, 1);
  }
#line 1482
  if (tmp == -1) {
#line 1483
    goto fail;
  }
  {
#line 1485
  tmp___0 = m_mkpart(& vol, "MacOS", "Apple_HFS", len);
  }
#line 1485
  if (tmp___0 == -1) {
#line 1486
    goto fail;
  }
  {
#line 1488
  tmp___1 = v_close(& vol);
  }
#line 1488
  if (tmp___1 == -1) {
#line 1489
    goto fail;
  }
#line 1491
  return (0);
  fail: 
  {
#line 1494
  v_close(& vol);
  }
#line 1495
  return (-1);
}
}
#line 1502 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_nparts(char const   *path ) 
{ 
  hfsvol vol ;
  int nparts ;
  int found ;
  Partition map ;
  unsigned long bnum ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1507
  bnum = 0UL;
#line 1509
  v_init(& vol, 256);
#line 1511
  tmp = v_open(& vol, path, 0);
  }
#line 1511
  if (tmp == -1) {
#line 1512
    goto fail;
  }
#line 1514
  nparts = 0;
  {
#line 1515
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1517
    found = m_findpmentry(& vol, "Apple_HFS", & map, & bnum);
    }
#line 1518
    if (found == -1) {
#line 1519
      goto fail;
    }
#line 1521
    if (! found) {
#line 1522
      goto while_break;
    }
#line 1524
    nparts ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1527
  tmp___0 = v_close(& vol);
  }
#line 1527
  if (tmp___0 == -1) {
#line 1528
    goto fail;
  }
#line 1530
  return (nparts);
  fail: 
  {
#line 1533
  v_close(& vol);
  }
#line 1534
  return (-1);
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
static int compare(unsigned int const   *n1 , unsigned int const   *n2 ) 
{ 


  {
#line 1544
  return ((int )(*n1 - *n2));
}
}
#line 1551 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/hfs.c"
int hfs_format(char const   *path , int pnum , int mode , char const   *vname , unsigned int nbadblocks ,
               unsigned long const   *badblocks ) 
{ 
  hfsvol vol ;
  btree *ext ;
  btree *cat ;
  unsigned int i ;
  unsigned int *badalloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  unsigned long tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  unsigned long bnum ;
  unsigned int anum ;
  int *tmp___9 ;
  int *tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  void *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  hfsfile bbfile ;
  ExtDescriptor extent ;
  ExtDataRec *extrec ;
  ExtKeyRec key ;
  byte record[sizeof(ExtKeyRec ) + sizeof(ExtDataRec )] ;
  unsigned int reclen ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  block b ;
  unsigned long bnum___0 ;
  int tmp___21 ;

  {
  {
#line 1555
  ext = & vol.ext;
#line 1556
  cat = & vol.cat;
#line 1557
  badalloc = (unsigned int *)0;
#line 1559
  v_init(& vol, mode);
#line 1561
  tmp = validvname(vname);
  }
#line 1561
  if (! tmp) {
#line 1562
    goto fail;
  }
  {
#line 1564
  tmp___0 = v_open(& vol, path, 1);
  }
#line 1564
  if (tmp___0 == -1) {
#line 1566
    goto fail;
  } else {
    {
#line 1564
    tmp___1 = v_geometry(& vol, pnum);
    }
#line 1564
    if (tmp___1 == -1) {
#line 1566
      goto fail;
    }
  }
#line 1570
  vol.lpa = (unsigned int )(1UL + ((vol.vlen - 6UL) >> 16));
#line 1572
  if (vol.flags & 512) {
#line 1573
    vol.lpa = (vol.lpa + 3U) & 4294967292U;
  }
  {
#line 1575
  vol.vbmsz = (unsigned short )((vol.vlen / (unsigned long )vol.lpa + 4095UL) >> 12);
#line 1577
  vol.mdb.drSigWord = (Integer )16964;
#line 1578
  tmp___2 = time((time_t *)0);
#line 1578
  tmp___3 = d_mtime(tmp___2);
#line 1578
  vol.mdb.drCrDate = (LongInt )tmp___3;
#line 1579
  vol.mdb.drLsMod = vol.mdb.drCrDate;
#line 1580
  vol.mdb.drAtrb = (Integer )0;
#line 1581
  vol.mdb.drNmFls = (UInteger )0;
#line 1582
  vol.mdb.drVBMSt = (UInteger )3;
#line 1583
  vol.mdb.drAllocPtr = (UInteger )0;
#line 1585
  vol.mdb.drAlBlkSiz = (ULongInt )(vol.lpa << 9);
#line 1586
  vol.mdb.drClpSiz = vol.mdb.drAlBlkSiz << 2;
#line 1587
  vol.mdb.drAlBlSt = (UInteger )((int )vol.mdb.drVBMSt + (int )vol.vbmsz);
  }
#line 1589
  if (vol.flags & 512) {
#line 1590
    vol.mdb.drAlBlSt = (UInteger )((((vol.vstart & 3UL) + (unsigned long )vol.mdb.drAlBlSt) + 3UL) & 0xfffffffffffffffcUL);
  }
  {
#line 1592
  vol.mdb.drNmAlBlks = (UInteger )(((vol.vlen - 2UL) - (unsigned long )vol.mdb.drAlBlSt) / (unsigned long )vol.lpa);
#line 1594
  vol.mdb.drNxtCNID = (LongInt )2;
#line 1595
  vol.mdb.drFreeBks = vol.mdb.drNmAlBlks;
#line 1597
  strcpy((char */* __restrict  */)(vol.mdb.drVN), (char const   */* __restrict  */)vname);
#line 1599
  vol.mdb.drVolBkUp = (LongInt )0;
#line 1600
  vol.mdb.drVSeqNum = (Integer )0;
#line 1601
  vol.mdb.drWrCnt = (ULongInt )0;
#line 1603
  vol.mdb.drXTClpSiz = (ULongInt )((int )vol.mdb.drNmAlBlks / 128) * vol.mdb.drAlBlkSiz;
#line 1604
  vol.mdb.drCTClpSiz = vol.mdb.drXTClpSiz;
#line 1606
  vol.mdb.drNmRtDirs = (UInteger )0;
#line 1607
  vol.mdb.drFilCnt = (ULongInt )0;
#line 1608
  vol.mdb.drDirCnt = (ULongInt )-1;
#line 1610
  i = 0U;
  }
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! (i < 8U)) {
#line 1610
      goto while_break;
    }
#line 1611
    vol.mdb.drFndrInfo[i] = (LongInt )0;
#line 1610
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1613
  vol.mdb.drEmbedSigWord = (UInteger )0;
#line 1614
  vol.mdb.drEmbedExtent.xdrStABN = (UInteger )0;
#line 1615
  vol.mdb.drEmbedExtent.xdrNumABlks = (UInteger )0;
#line 1623
  vol.flags |= 48;
#line 1627
  tmp___4 = malloc(sizeof(block ) * (unsigned long )vol.vbmsz);
#line 1627
  vol.vbm = (block *)tmp___4;
  }
#line 1628
  if ((unsigned long )vol.vbm == (unsigned long )((block *)0)) {
    {
#line 1629
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1629
      hfs_error = (char const   *)0;
#line 1629
      tmp___5 = __errno_location();
#line 1629
      *tmp___5 = 12;
      }
#line 1629
      goto fail;
#line 1629
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1631
  memset((void *)vol.vbm, 0, (size_t )((int )vol.vbmsz << 9));
#line 1633
  vol.flags |= 64;
  }
#line 1637
  if (nbadblocks > 0U) {
#line 1639
    if ((unsigned long )(nbadblocks * 4U) > vol.vlen) {
      {
#line 1640
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1640
        hfs_error = "volume contains too many bad blocks";
#line 1640
        tmp___6 = __errno_location();
#line 1640
        *tmp___6 = 22;
        }
#line 1640
        goto fail;
#line 1640
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1642
    tmp___7 = malloc(sizeof(unsigned int ) * (unsigned long )nbadblocks);
#line 1642
    badalloc = (unsigned int *)tmp___7;
    }
#line 1643
    if ((unsigned long )badalloc == (unsigned long )((unsigned int *)0)) {
      {
#line 1644
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1644
        hfs_error = (char const   *)0;
#line 1644
        tmp___8 = __errno_location();
#line 1644
        *tmp___8 = 12;
        }
#line 1644
        goto fail;
#line 1644
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1646
    if ((int )vol.mdb.drNmAlBlks == 1594) {
#line 1647
      vol.mdb.drNmAlBlks = (UInteger )((int )vol.mdb.drNmAlBlks - 1);
#line 1647
      vol.mdb.drFreeBks = vol.mdb.drNmAlBlks;
    }
#line 1649
    i = 0U;
    {
#line 1649
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1649
      if (! (i < nbadblocks)) {
#line 1649
        goto while_break___3;
      }
#line 1654
      bnum = (unsigned long )*(badblocks + i);
#line 1656
      if (bnum < (unsigned long )vol.mdb.drAlBlSt) {
#line 1656
        goto _L;
      } else
#line 1656
      if (bnum == vol.vlen - 2UL) {
        _L: /* CIL Label */ 
        {
#line 1657
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 1657
          hfs_error = "can\'t spare critical bad block";
#line 1657
          tmp___9 = __errno_location();
#line 1657
          *tmp___9 = 22;
          }
#line 1657
          goto fail;
#line 1657
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 1658
      if (bnum >= vol.vlen) {
        {
#line 1659
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1659
          hfs_error = "bad block not in volume";
#line 1659
          tmp___10 = __errno_location();
#line 1659
          *tmp___10 = 22;
          }
#line 1659
          goto fail;
#line 1659
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 1661
      anum = (unsigned int )((bnum - (unsigned long )vol.mdb.drAlBlSt) / (unsigned long )vol.lpa);
#line 1663
      if (anum < (unsigned int )vol.mdb.drNmAlBlks) {
#line 1664
        *((byte *)vol.vbm + (anum >> 3)) = (byte )((int )*((byte *)vol.vbm + (anum >> 3)) | (128 >> (anum & 7U)));
      }
#line 1666
      *(badalloc + i) = anum;
#line 1649
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1669
    vol.mdb.drAtrb = (Integer )((int )vol.mdb.drAtrb | (1 << 9));
  }
  {
#line 1674
  n_init(& ext->hdrnd, ext, 1, 0);
#line 1676
  ext->hdrnd.nnum = 0UL;
#line 1677
  ext->hdrnd.nd.ndNRecs = (UInteger )3;
#line 1678
  ext->hdrnd.roff[1] = (UInteger )120;
#line 1679
  ext->hdrnd.roff[2] = (UInteger )248;
#line 1680
  ext->hdrnd.roff[3] = (UInteger )504;
#line 1682
  memset((void *)(ext->hdrnd.data + (int )ext->hdrnd.roff[1]), 0, (size_t )128);
#line 1684
  ext->hdr.bthDepth = (UInteger )0;
#line 1685
  ext->hdr.bthRoot = (ULongInt )0;
#line 1686
  ext->hdr.bthNRecs = (ULongInt )0;
#line 1687
  ext->hdr.bthFNode = (ULongInt )0;
#line 1688
  ext->hdr.bthLNode = (ULongInt )0;
#line 1689
  ext->hdr.bthNodeSize = (UInteger )512;
#line 1690
  ext->hdr.bthKeyLen = (UInteger )7;
#line 1691
  ext->hdr.bthNNodes = (ULongInt )0;
#line 1692
  ext->hdr.bthFree = (ULongInt )0;
#line 1693
  i = 0U;
  }
  {
#line 1693
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1693
    if (! (i < 76U)) {
#line 1693
      goto while_break___6;
    }
#line 1694
    ext->hdr.bthResv[i] = (SignedByte )0;
#line 1693
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1696
  tmp___11 = malloc(sizeof(byte ) * 256UL);
#line 1696
  ext->map = (byte *)tmp___11;
  }
#line 1697
  if ((unsigned long )ext->map == (unsigned long )((byte *)0)) {
    {
#line 1698
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 1698
      hfs_error = (char const   *)0;
#line 1698
      tmp___12 = __errno_location();
#line 1698
      *tmp___12 = 12;
      }
#line 1698
      goto fail;
#line 1698
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 1700
  memset((void *)ext->map, 0, (size_t )256);
#line 1701
  *(ext->map + 0) = (byte )((int )*(ext->map + 0) | 128);
#line 1703
  ext->mapsz = 256UL;
#line 1704
  ext->flags = 1;
#line 1708
  n_init(& cat->hdrnd, cat, 1, 0);
#line 1710
  cat->hdrnd.nnum = 0UL;
#line 1711
  cat->hdrnd.nd.ndNRecs = (UInteger )3;
#line 1712
  cat->hdrnd.roff[1] = (UInteger )120;
#line 1713
  cat->hdrnd.roff[2] = (UInteger )248;
#line 1714
  cat->hdrnd.roff[3] = (UInteger )504;
#line 1716
  memset((void *)(cat->hdrnd.data + (int )cat->hdrnd.roff[1]), 0, (size_t )128);
#line 1718
  cat->hdr.bthDepth = (UInteger )0;
#line 1719
  cat->hdr.bthRoot = (ULongInt )0;
#line 1720
  cat->hdr.bthNRecs = (ULongInt )0;
#line 1721
  cat->hdr.bthFNode = (ULongInt )0;
#line 1722
  cat->hdr.bthLNode = (ULongInt )0;
#line 1723
  cat->hdr.bthNodeSize = (UInteger )512;
#line 1724
  cat->hdr.bthKeyLen = (UInteger )37;
#line 1725
  cat->hdr.bthNNodes = (ULongInt )0;
#line 1726
  cat->hdr.bthFree = (ULongInt )0;
#line 1727
  i = 0U;
  }
  {
#line 1727
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1727
    if (! (i < 76U)) {
#line 1727
      goto while_break___8;
    }
#line 1728
    cat->hdr.bthResv[i] = (SignedByte )0;
#line 1727
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1730
  tmp___13 = malloc(sizeof(byte ) * 256UL);
#line 1730
  cat->map = (byte *)tmp___13;
  }
#line 1731
  if ((unsigned long )cat->map == (unsigned long )((byte *)0)) {
    {
#line 1732
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 1732
      hfs_error = (char const   *)0;
#line 1732
      tmp___14 = __errno_location();
#line 1732
      *tmp___14 = 12;
      }
#line 1732
      goto fail;
#line 1732
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 1734
  memset((void *)cat->map, 0, (size_t )256);
#line 1735
  *(cat->map + 0) = (byte )((int )*(cat->map + 0) | 128);
#line 1737
  cat->mapsz = 256UL;
#line 1738
  cat->flags = 1;
#line 1742
  tmp___15 = bt_space(ext, 1U);
  }
#line 1742
  if (tmp___15 == -1) {
#line 1744
    goto fail;
  } else {
    {
#line 1742
    tmp___16 = bt_space(cat, 1U);
    }
#line 1742
    if (tmp___16 == -1) {
#line 1744
      goto fail;
    }
  }
#line 1746
  (ext->hdr.bthFree) --;
#line 1747
  (cat->hdr.bthFree) --;
#line 1751
  if (nbadblocks > 0U) {
    {
#line 1760
    f_init(& bbfile, & vol, 5L, "bad blocks");
#line 1762
    qsort((void *)badalloc, (size_t )nbadblocks, sizeof(*badalloc), (int (*)(void const   * ,
                                                                             void const   * ))(& compare));
#line 1765
    i = 0U;
    }
    {
#line 1765
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1765
      if (! (i < nbadblocks)) {
#line 1765
        goto while_break___10;
      }
#line 1767
      if (i == 0U) {
#line 1767
        goto _L___0;
      } else
#line 1767
      if (*(badalloc + i) != (unsigned int )extent.xdrStABN) {
        _L___0: /* CIL Label */ 
#line 1769
        extent.xdrStABN = (UInteger )*(badalloc + i);
#line 1770
        extent.xdrNumABlks = (UInteger )1;
#line 1772
        if ((int )extent.xdrStABN < (int )vol.mdb.drNmAlBlks) {
          {
#line 1772
          tmp___17 = f_addextent(& bbfile, & extent);
          }
#line 1772
          if (tmp___17 == -1) {
#line 1774
            goto fail;
          }
        }
      }
#line 1765
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 1780
    f_getptrs(& bbfile, & extrec, (unsigned long **)0, (unsigned long **)0);
#line 1782
    r_makeextkey(& key, bbfile.fork, bbfile.cat.u.fil.filFlNum, 0U);
#line 1783
    r_packextrec((ExtKeyRec const   *)(& key), (ExtDataRec const   *)extrec, record,
                 & reclen);
#line 1785
    tmp___18 = bt_insert(& vol.ext, (byte const   *)(record), reclen);
    }
#line 1785
    if (tmp___18 == -1) {
#line 1786
      goto fail;
    }
  }
  {
#line 1789
  vol.flags |= 2;
#line 1793
  tmp___19 = v_mkdir(& vol, 1UL, vname);
  }
#line 1793
  if (tmp___19 == -1) {
#line 1794
    goto fail;
  }
  {
#line 1796
  vol.mdb.drNxtCNID = (LongInt )16;
#line 1800
  tmp___20 = m_zerobb(& vol);
  }
#line 1800
  if (tmp___20 == -1) {
#line 1801
    goto fail;
  }
#line 1805
  if (vol.flags & 1024) {
    {
#line 1810
    memset((void *)(& b), 0, sizeof(b));
#line 1814
    bnum___0 = 3UL;
    }
    {
#line 1814
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1814
      if (! (bnum___0 < (unsigned long )vol.mdb.drVBMSt)) {
#line 1814
        goto while_break___11;
      }
      {
#line 1815
      b_writelb(& vol, bnum___0, (block const   *)(& b));
#line 1814
      bnum___0 ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1819
    bnum___0 = (unsigned long )((int )vol.mdb.drVBMSt + (int )vol.vbmsz);
    {
#line 1819
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1819
      if (! (bnum___0 < (unsigned long )vol.mdb.drAlBlSt)) {
#line 1819
        goto while_break___12;
      }
      {
#line 1820
      b_writelb(& vol, bnum___0, (block const   *)(& b));
#line 1819
      bnum___0 ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1824
    bnum___0 = (unsigned long )((unsigned int )vol.mdb.drAlBlSt + (unsigned int )vol.mdb.drNmAlBlks * vol.lpa);
    {
#line 1824
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1824
      if (! (bnum___0 < vol.vlen - 2UL)) {
#line 1824
        goto while_break___13;
      }
      {
#line 1826
      b_writelb(& vol, bnum___0, (block const   *)(& b));
#line 1824
      bnum___0 ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 1830
    b_writelb(& vol, vol.vlen - 1UL, (block const   *)(& b));
    }
  }
  {
#line 1835
  tmp___21 = v_close(& vol);
  }
#line 1835
  if (tmp___21 == -1) {
#line 1836
    goto fail;
  }
#line 1838
  if (badalloc) {
    {
#line 1838
    free((void *)badalloc);
    }
  }
#line 1840
  return (0);
  fail: 
  {
#line 1843
  v_close(& vol);
  }
#line 1845
  if (badalloc) {
    {
#line 1845
    free((void *)badalloc);
    }
  }
#line 1847
  return (-1);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
void f_init(hfsfile *file___0 , hfsvol *vol , long cnid , char const   *name___1 ) 
{ 
  int i ;

  {
  {
#line 43
  file___0->vol = vol;
#line 44
  file___0->parid = 0UL;
#line 46
  strcpy((char */* __restrict  */)(file___0->name), (char const   */* __restrict  */)name___1);
#line 48
  file___0->cat.cdrType = (SignedByte )2;
#line 49
  file___0->cat.cdrResrv2 = (SignedByte )0;
#line 51
  file___0->cat.u.fil.filFlags = (SignedByte )0;
#line 52
  file___0->cat.u.fil.filTyp = (SignedByte )0;
#line 54
  file___0->cat.u.fil.filUsrWds.fdType = (OSType )0;
#line 55
  file___0->cat.u.fil.filUsrWds.fdCreator = (OSType )0;
#line 56
  file___0->cat.u.fil.filUsrWds.fdFlags = (Integer )0;
#line 57
  file___0->cat.u.fil.filUsrWds.fdLocation.v = (Integer )0;
#line 58
  file___0->cat.u.fil.filUsrWds.fdLocation.h = (Integer )0;
#line 59
  file___0->cat.u.fil.filUsrWds.fdFldr = (Integer )0;
#line 61
  file___0->cat.u.fil.filFlNum = (ULongInt )cnid;
#line 62
  file___0->cat.u.fil.filStBlk = (UInteger )0;
#line 63
  file___0->cat.u.fil.filLgLen = (ULongInt )0;
#line 64
  file___0->cat.u.fil.filPyLen = (ULongInt )0;
#line 65
  file___0->cat.u.fil.filRStBlk = (UInteger )0;
#line 66
  file___0->cat.u.fil.filRLgLen = (ULongInt )0;
#line 67
  file___0->cat.u.fil.filRPyLen = (ULongInt )0;
#line 68
  file___0->cat.u.fil.filCrDat = (LongInt )0;
#line 69
  file___0->cat.u.fil.filMdDat = (LongInt )0;
#line 70
  file___0->cat.u.fil.filBkDat = (LongInt )0;
#line 72
  file___0->cat.u.fil.filFndrInfo.fdIconID = (Integer )0;
#line 73
  i = 0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < 4)) {
#line 73
      goto while_break;
    }
#line 74
    file___0->cat.u.fil.filFndrInfo.fdUnused[i] = (Integer )0;
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  file___0->cat.u.fil.filFndrInfo.fdComment = (Integer )0;
#line 76
  file___0->cat.u.fil.filFndrInfo.fdPutAway = (LongInt )0;
#line 78
  file___0->cat.u.fil.filClpSize = (UInteger )0;
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (i < 3)) {
#line 80
      goto while_break___0;
    }
#line 82
    file___0->cat.u.fil.filExtRec[i].xdrStABN = (UInteger )0;
#line 83
    file___0->cat.u.fil.filExtRec[i].xdrNumABlks = (UInteger )0;
#line 85
    file___0->cat.u.fil.filRExtRec[i].xdrStABN = (UInteger )0;
#line 86
    file___0->cat.u.fil.filRExtRec[i].xdrNumABlks = (UInteger )0;
#line 80
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 89
  file___0->cat.u.fil.filResrv = (LongInt )0;
#line 91
  f_selectfork(file___0, 0);
#line 93
  file___0->flags = 0;
#line 95
  file___0->prev = (struct _hfsfile_ *)0;
#line 96
  file___0->next = (struct _hfsfile_ *)0;
  }
#line 97
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
void f_selectfork(hfsfile *file___0 , int fork ) 
{ 
  ExtDataRec *tmp ;

  {
#line 105
  file___0->fork = fork;
#line 107
  if (fork == 0) {
#line 107
    tmp = & file___0->cat.u.fil.filExtRec;
  } else {
#line 107
    tmp = & file___0->cat.u.fil.filRExtRec;
  }
  {
#line 107
  memcpy((void */* __restrict  */)(& file___0->ext), (void const   */* __restrict  */)tmp,
         sizeof(ExtDataRec ));
#line 111
  file___0->fabn = 0U;
#line 112
  file___0->pos = 0UL;
  }
#line 113
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
void f_getptrs(hfsfile *file___0 , ExtDataRec **extrec , unsigned long **lglen , unsigned long **pylen ) 
{ 


  {
#line 122
  if (file___0->fork == 0) {
#line 124
    if (extrec) {
#line 125
      *extrec = & file___0->cat.u.fil.filExtRec;
    }
#line 126
    if (lglen) {
#line 127
      *lglen = & file___0->cat.u.fil.filLgLen;
    }
#line 128
    if (pylen) {
#line 129
      *pylen = & file___0->cat.u.fil.filPyLen;
    }
  } else {
#line 133
    if (extrec) {
#line 134
      *extrec = & file___0->cat.u.fil.filRExtRec;
    }
#line 135
    if (lglen) {
#line 136
      *lglen = & file___0->cat.u.fil.filRLgLen;
    }
#line 137
    if (pylen) {
#line 138
      *pylen = & file___0->cat.u.fil.filRPyLen;
    }
  }
#line 140
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
int f_doblock(hfsfile *file___0 , unsigned long num , block *bp , int (*func)(hfsvol * ,
                                                                              unsigned int  ,
                                                                              unsigned int  ,
                                                                              block * ) ) 
{ 
  unsigned int abnum ;
  unsigned int blnum ;
  unsigned int fabn ;
  int i ;
  ExtDataRec *extrec ;
  unsigned int tmp ;
  unsigned int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 154
  abnum = (unsigned int )(num / (unsigned long )(file___0->vol)->lpa);
#line 155
  blnum = (unsigned int )(num % (unsigned long )(file___0->vol)->lpa);
#line 159
  fabn = file___0->fabn;
#line 161
  if (abnum < fabn) {
    {
#line 165
    f_getptrs(file___0, & extrec, (unsigned long **)0, (unsigned long **)0);
#line 167
    tmp = 0U;
#line 167
    file___0->fabn = tmp;
#line 167
    fabn = tmp;
#line 168
    memcpy((void */* __restrict  */)(& file___0->ext), (void const   */* __restrict  */)extrec,
           sizeof(ExtDataRec ));
    }
  } else {
#line 171
    abnum -= fabn;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    i = 0;
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if (! (i < 3)) {
#line 177
        goto while_break___0;
      }
#line 179
      n = (unsigned int )file___0->ext[i].xdrNumABlks;
#line 181
      if (abnum < n) {
        {
#line 182
        tmp___0 = (*func)(file___0->vol, (unsigned int )file___0->ext[i].xdrStABN + abnum,
                          blnum, bp);
        }
#line 182
        return (tmp___0);
      }
#line 184
      fabn += n;
#line 185
      abnum -= n;
#line 177
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 188
    tmp___1 = v_extsearch(file___0, fabn, & file___0->ext, (node *)0);
    }
#line 188
    if (tmp___1 <= 0) {
#line 189
      goto fail;
    }
#line 191
    file___0->fabn = fabn;
  }
  while_break: /* CIL Label */ ;
  }
  fail: 
#line 195
  return (-1);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
int f_addextent(hfsfile *file___0 , ExtDescriptor *blocks ) 
{ 
  hfsvol *vol ;
  ExtDataRec *extrec ;
  unsigned long *pylen ;
  unsigned int start ;
  unsigned int end ;
  node n ;
  int i ;
  unsigned int num ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  ExtKeyRec key ;
  byte record[sizeof(ExtKeyRec ) + sizeof(ExtDataRec )] ;
  unsigned int reclen ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 204
  vol = file___0->vol;
#line 211
  f_getptrs(file___0, & extrec, (unsigned long **)0, & pylen);
#line 213
  start = file___0->fabn;
#line 214
  end = (unsigned int )(*pylen / vol->mdb.drAlBlkSiz);
#line 216
  n.nnum = 0UL;
#line 217
  i = -1;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (start < end)) {
#line 219
      goto while_break;
    }
#line 221
    i = 0;
    {
#line 221
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 221
      if (! (i < 3)) {
#line 221
        goto while_break___0;
      }
#line 225
      num = (unsigned int )file___0->ext[i].xdrNumABlks;
#line 226
      start += num;
#line 228
      if (start == end) {
#line 229
        goto while_break___0;
      } else
#line 230
      if (start > end) {
        {
#line 231
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 231
          hfs_error = "file extents exceed file physical length";
#line 231
          tmp = __errno_location();
#line 231
          *tmp = 5;
          }
#line 231
          goto fail;
#line 231
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 232
      if (num == 0U) {
        {
#line 233
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 233
          hfs_error = "empty file extent";
#line 233
          tmp___0 = __errno_location();
#line 233
          *tmp___0 = 5;
          }
#line 233
          goto fail;
#line 233
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 221
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 236
    if (start == end) {
#line 237
      goto while_break;
    }
    {
#line 239
    tmp___1 = v_extsearch(file___0, start, & file___0->ext, & n);
    }
#line 239
    if (tmp___1 <= 0) {
#line 240
      goto fail;
    }
#line 242
    file___0->fabn = start;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if (i >= 0) {
#line 245
    if ((int )file___0->ext[i].xdrStABN + (int )file___0->ext[i].xdrNumABlks == (int )blocks->xdrStABN) {
#line 247
      file___0->ext[i].xdrNumABlks = (UInteger )((int )file___0->ext[i].xdrNumABlks + (int )blocks->xdrNumABlks);
    } else {
#line 245
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 252
    i ++;
#line 252
    if (i < 3) {
#line 253
      file___0->ext[i] = *blocks;
    } else {
#line 262
      file___0->ext[0] = *blocks;
#line 264
      i = 1;
      {
#line 264
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 264
        if (! (i < 3)) {
#line 264
          goto while_break___3;
        }
#line 266
        file___0->ext[i].xdrStABN = (UInteger )0;
#line 267
        file___0->ext[i].xdrNumABlks = (UInteger )0;
#line 264
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 270
      file___0->fabn = start;
#line 272
      r_makeextkey(& key, file___0->fork, file___0->cat.u.fil.filFlNum, end);
#line 273
      r_packextrec((ExtKeyRec const   *)(& key), (ExtDataRec const   *)(& file___0->ext),
                   record, & reclen);
#line 275
      tmp___2 = bt_insert(& vol->ext, (byte const   *)(record), reclen);
      }
#line 275
      if (tmp___2 == -1) {
#line 276
        goto fail;
      }
#line 278
      i = -1;
    }
  }
#line 282
  if (i >= 0) {
#line 286
    if (file___0->fabn) {
#line 288
      if (n.nnum == 0UL) {
        {
#line 288
        tmp___3 = v_extsearch(file___0, file___0->fabn, (ExtDataRec *)0, & n);
        }
#line 288
        if (tmp___3 <= 0) {
#line 291
          goto fail;
        } else {
#line 288
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 288
        tmp___4 = v_putextrec((ExtDataRec const   *)(& file___0->ext), & n);
        }
#line 288
        if (tmp___4 == -1) {
#line 291
          goto fail;
        }
      }
    } else {
      {
#line 294
      memcpy((void */* __restrict  */)extrec, (void const   */* __restrict  */)(& file___0->ext),
             sizeof(ExtDataRec ));
      }
    }
  }
#line 297
  *pylen += (ULongInt )blocks->xdrNumABlks * vol->mdb.drAlBlkSiz;
#line 299
  file___0->flags |= 1;
#line 301
  return (0);
  fail: 
#line 304
  return (-1);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
long f_alloc(hfsfile *file___0 ) 
{ 
  hfsvol *vol ;
  unsigned long clumpsz ;
  ExtDescriptor blocks ;
  int tmp ;
  int tmp___0 ;

  {
#line 313
  vol = file___0->vol;
#line 317
  clumpsz = (unsigned long )file___0->cat.u.fil.filClpSize;
#line 318
  if (clumpsz == 0UL) {
#line 320
    if ((unsigned long )file___0 == (unsigned long )(& vol->ext.f)) {
#line 321
      clumpsz = vol->mdb.drXTClpSiz;
    } else
#line 322
    if ((unsigned long )file___0 == (unsigned long )(& vol->cat.f)) {
#line 323
      clumpsz = vol->mdb.drCTClpSiz;
    } else {
#line 325
      clumpsz = vol->mdb.drClpSiz;
    }
  }
  {
#line 328
  blocks.xdrNumABlks = (UInteger )(clumpsz / vol->mdb.drAlBlkSiz);
#line 330
  tmp = v_allocblocks(vol, & blocks);
  }
#line 330
  if (tmp == -1) {
#line 331
    goto fail;
  }
  {
#line 333
  tmp___0 = f_addextent(file___0, & blocks);
  }
#line 333
  if (tmp___0 == -1) {
    {
#line 335
    v_freeblocks(vol, (ExtDescriptor const   *)(& blocks));
    }
#line 336
    goto fail;
  }
#line 339
  return ((long )blocks.xdrNumABlks);
  fail: 
#line 342
  return (-1L);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
int f_trunc(hfsfile *file___0 ) 
{ 
  hfsvol *vol ;
  ExtDataRec *extrec ;
  unsigned long *lglen ;
  unsigned long *pylen ;
  unsigned long alblksz ;
  unsigned long newpylen ;
  unsigned int dlen ;
  unsigned int start ;
  unsigned int end ;
  node n ;
  int i ;
  int *tmp ;
  unsigned int tmp___0 ;
  unsigned int num ;
  int *tmp___1 ;
  int tmp___2 ;
  ExtDescriptor blocks ;
  int tmp___3 ;
  unsigned int num___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 351
  vol = file___0->vol;
#line 358
  if (vol->flags & 4) {
#line 359
    goto done;
  }
  {
#line 361
  f_getptrs(file___0, & extrec, & lglen, & pylen);
#line 363
  alblksz = vol->mdb.drAlBlkSiz;
#line 364
  newpylen = (*lglen / alblksz + (unsigned long )(*lglen % alblksz != 0UL)) * alblksz;
  }
#line 366
  if (newpylen > *pylen) {
    {
#line 367
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 367
      hfs_error = "file size exceeds physical length";
#line 367
      tmp = __errno_location();
#line 367
      *tmp = 5;
      }
#line 367
      goto fail;
#line 367
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 368
  if (newpylen == *pylen) {
#line 369
    goto done;
  }
#line 371
  dlen = (unsigned int )((*pylen - newpylen) / alblksz);
#line 373
  start = file___0->fabn;
#line 374
  end = (unsigned int )(newpylen / alblksz);
#line 376
  if (start >= end) {
    {
#line 378
    tmp___0 = 0U;
#line 378
    file___0->fabn = tmp___0;
#line 378
    start = tmp___0;
#line 379
    memcpy((void */* __restrict  */)(& file___0->ext), (void const   */* __restrict  */)extrec,
           sizeof(ExtDataRec ));
    }
  }
#line 382
  n.nnum = 0UL;
#line 383
  i = -1;
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 385
    if (! (start < end)) {
#line 385
      goto while_break___0;
    }
#line 387
    i = 0;
    {
#line 387
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 387
      if (! (i < 3)) {
#line 387
        goto while_break___1;
      }
#line 391
      num = (unsigned int )file___0->ext[i].xdrNumABlks;
#line 392
      start += num;
#line 394
      if (start >= end) {
#line 395
        goto while_break___1;
      } else
#line 396
      if (num == 0U) {
        {
#line 397
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 397
          hfs_error = "empty file extent";
#line 397
          tmp___1 = __errno_location();
#line 397
          *tmp___1 = 5;
          }
#line 397
          goto fail;
#line 397
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 387
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 400
    if (start >= end) {
#line 401
      goto while_break___0;
    }
    {
#line 403
    tmp___2 = v_extsearch(file___0, start, & file___0->ext, & n);
    }
#line 403
    if (tmp___2 <= 0) {
#line 404
      goto fail;
    }
#line 406
    file___0->fabn = start;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 409
  if (start > end) {
    {
#line 413
    file___0->ext[i].xdrNumABlks = (UInteger )((unsigned int )file___0->ext[i].xdrNumABlks - (start - end));
#line 414
    dlen -= start - end;
#line 416
    blocks.xdrStABN = (UInteger )((int )file___0->ext[i].xdrStABN + (int )file___0->ext[i].xdrNumABlks);
#line 417
    blocks.xdrNumABlks = (UInteger )(start - end);
#line 419
    tmp___3 = v_freeblocks(vol, (ExtDescriptor const   *)(& blocks));
    }
#line 419
    if (tmp___3 == -1) {
#line 420
      goto fail;
    }
  }
#line 423
  *pylen = newpylen;
#line 425
  file___0->flags |= 1;
  {
#line 427
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 429
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 429
      if (dlen) {
#line 429
        i ++;
#line 429
        if (! (i < 3)) {
#line 429
          goto while_break___4;
        }
      } else {
#line 429
        goto while_break___4;
      }
#line 433
      num___0 = (unsigned int )file___0->ext[i].xdrNumABlks;
#line 434
      start += num___0;
#line 436
      if (num___0 == 0U) {
        {
#line 437
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 437
          hfs_error = "empty file extent";
#line 437
          tmp___4 = __errno_location();
#line 437
          *tmp___4 = 5;
          }
#line 437
          goto fail;
#line 437
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else
#line 438
      if (num___0 > dlen) {
        {
#line 439
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 439
          hfs_error = "file extents exceed physical size";
#line 439
          tmp___5 = __errno_location();
#line 439
          *tmp___5 = 5;
          }
#line 439
          goto fail;
#line 439
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 441
      dlen -= num___0;
#line 443
      tmp___6 = v_freeblocks(vol, (ExtDescriptor const   *)(& file___0->ext[i]));
      }
#line 443
      if (tmp___6 == -1) {
#line 444
        goto fail;
      }
#line 446
      file___0->ext[i].xdrStABN = (UInteger )0;
#line 447
      file___0->ext[i].xdrNumABlks = (UInteger )0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 450
    if (file___0->fabn) {
#line 452
      if (n.nnum == 0UL) {
        {
#line 452
        tmp___7 = v_extsearch(file___0, file___0->fabn, (ExtDataRec *)0, & n);
        }
#line 452
        if (tmp___7 <= 0) {
#line 454
          goto fail;
        }
      }
#line 456
      if (file___0->ext[0].xdrNumABlks) {
        {
#line 458
        tmp___8 = v_putextrec((ExtDataRec const   *)(& file___0->ext), & n);
        }
#line 458
        if (tmp___8 == -1) {
#line 459
          goto fail;
        }
      } else {
        {
#line 463
        tmp___9 = bt_delete(& vol->ext, (byte const   *)(n.data + (int )n.roff[n.rnum]));
        }
#line 463
        if (tmp___9 == -1) {
#line 464
          goto fail;
        }
#line 466
        n.nnum = 0UL;
      }
    } else {
      {
#line 470
      memcpy((void */* __restrict  */)extrec, (void const   */* __restrict  */)(& file___0->ext),
             sizeof(ExtDataRec ));
      }
    }
#line 472
    if (dlen) {
      {
#line 474
      tmp___10 = v_extsearch(file___0, start, & file___0->ext, & n);
      }
#line 474
      if (tmp___10 <= 0) {
#line 475
        goto fail;
      }
#line 477
      file___0->fabn = start;
#line 478
      i = -1;
    }
#line 427
    if (! dlen) {
#line 427
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 484
  return (0);
  fail: 
#line 487
  return (-1);
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/file.c"
int f_flush(hfsfile *file___0 ) 
{ 
  hfsvol *vol ;
  node n ;
  int tmp ;
  int tmp___0 ;

  {
#line 496
  vol = file___0->vol;
#line 498
  if (vol->flags & 4) {
#line 499
    goto done;
  }
#line 501
  if (file___0->flags & 1) {
    {
#line 505
    file___0->cat.u.fil.filStBlk = file___0->cat.u.fil.filExtRec[0].xdrStABN;
#line 506
    file___0->cat.u.fil.filRStBlk = file___0->cat.u.fil.filRExtRec[0].xdrStABN;
#line 508
    tmp = v_catsearch(vol, file___0->parid, (char const   *)(file___0->name), (CatDataRec *)0,
                      (char *)0, & n);
    }
#line 508
    if (tmp <= 0) {
#line 510
      goto fail;
    } else {
      {
#line 508
      tmp___0 = v_putcatrec((CatDataRec const   *)(& file___0->cat), & n);
      }
#line 508
      if (tmp___0 == -1) {
#line 510
        goto fail;
      }
    }
#line 512
    file___0->flags &= -2;
  }
  done: 
#line 516
  return (0);
  fail: 
#line 519
  return (-1);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/version.h"
char const   hfsutils_rcsid[52] ;
#line 24
char const   hfsutils_version[23] ;
#line 25
char const   hfsutils_copyright[38] ;
#line 26
char const   hfsutils_author[29] ;
#line 28
char const   hfsutils_license[662] ;
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/version.c"
char const   hfsutils_rcsid[52]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/version.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'1', 
        (char const   )'1',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'8',      (char const   )'/',      (char const   )'1', 
        (char const   )'1',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'0',      (char const   )'8',      (char const   )':',      (char const   )'3', 
        (char const   )'3',      (char const   )' ',      (char const   )'r',      (char const   )'o', 
        (char const   )'b',      (char const   )' ',      (char const   )'E',      (char const   )'x', 
        (char const   )'p',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/version.c"
char const   hfsutils_version[23]  = 
#line 27
  {      (char const   )'h',      (char const   )'f',      (char const   )'s',      (char const   )'u', 
        (char const   )'t',      (char const   )'i',      (char const   )'l',      (char const   )'s', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'3',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'6',      (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/version.c"
char const   hfsutils_copyright[38]  = 
#line 28
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'C', 
        (char const   )')',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'6',      (char const   )'-',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'8',      (char const   )' ', 
        (char const   )'R',      (char const   )'o',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'s',      (char const   )'l',      (char const   )'i', 
        (char const   )'e',      (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/version.c"
char const   hfsutils_author[29]  = 
#line 29
  {      (char const   )'R',      (char const   )'o',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'s',      (char const   )'l',      (char const   )'i', 
        (char const   )'e',      (char const   )' ',      (char const   )'<',      (char const   )'r', 
        (char const   )'o',      (char const   )'b',      (char const   )'@',      (char const   )'m', 
        (char const   )'a',      (char const   )'r',      (char const   )'s',      (char const   )'.', 
        (char const   )'o',      (char const   )'r',      (char const   )'g',      (char const   )'>', 
        (char const   )'\000'};
#line 31 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/version.c"
char const   hfsutils_license[662]  = 
#line 31
  {      (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )' ',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'f',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )';',      (char const   )' ',      (char const   )'y', 
        (char const   )'o',      (char const   )'u',      (char const   )' ',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'b', 
        (char const   )'u',      (char const   )'t',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'/',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'y', 
        (char const   )' ',      (char const   )'i',      (char const   )'t',      (char const   )'\n', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'m',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'G', 
        (char const   )'N',      (char const   )'U',      (char const   )' ',      (char const   )'G', 
        (char const   )'e',      (char const   )'n',      (char const   )'e',      (char const   )'r', 
        (char const   )'a',      (char const   )'l',      (char const   )' ',      (char const   )'P', 
        (char const   )'u',      (char const   )'b',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )' ',      (char const   )'L',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'s', 
        (char const   )' ',      (char const   )'p',      (char const   )'u',      (char const   )'b', 
        (char const   )'l',      (char const   )'i',      (char const   )'s',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'b', 
        (char const   )'y',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )'\n',      (char const   )'F',      (char const   )'r', 
        (char const   )'e',      (char const   )'e',      (char const   )' ',      (char const   )'S', 
        (char const   )'o',      (char const   )'f',      (char const   )'t',      (char const   )'w', 
        (char const   )'a',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'F',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )';',      (char const   )' ', 
        (char const   )'e',      (char const   )'i',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'2', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'L',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )',', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'(',      (char const   )'a',      (char const   )'t',      (char const   )' ', 
        (char const   )'y',      (char const   )'o',      (char const   )'u',      (char const   )'r', 
        (char const   )'\n',      (char const   )'o',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )')', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'y', 
        (char const   )' ',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'.',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'T',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'o',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'m',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'b', 
        (char const   )'u',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'h',      (char const   )'o',      (char const   )'p',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'a', 
        (char const   )'t',      (char const   )' ',      (char const   )'i',      (char const   )'t', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'l', 
        (char const   )'l',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'e', 
        (char const   )'f',      (char const   )'u',      (char const   )'l',      (char const   )',', 
        (char const   )' ',      (char const   )'b',      (char const   )'u',      (char const   )'t', 
        (char const   )'\n',      (char const   )'W',      (char const   )'I',      (char const   )'T', 
        (char const   )'H',      (char const   )'O',      (char const   )'U',      (char const   )'T', 
        (char const   )' ',      (char const   )'A',      (char const   )'N',      (char const   )'Y', 
        (char const   )' ',      (char const   )'W',      (char const   )'A',      (char const   )'R', 
        (char const   )'R',      (char const   )'A',      (char const   )'N',      (char const   )'T', 
        (char const   )'Y',      (char const   )';',      (char const   )' ',      (char const   )'w', 
        (char const   )'i',      (char const   )'t',      (char const   )'h',      (char const   )'o', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'e', 
        (char const   )'v',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'m',      (char const   )'p',      (char const   )'l', 
        (char const   )'i',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'w',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'n',      (char const   )'t',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )'\n', 
        (char const   )'M',      (char const   )'E',      (char const   )'R',      (char const   )'C', 
        (char const   )'H',      (char const   )'A',      (char const   )'N',      (char const   )'T', 
        (char const   )'A',      (char const   )'B',      (char const   )'I',      (char const   )'L', 
        (char const   )'I',      (char const   )'T',      (char const   )'Y',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'F', 
        (char const   )'I',      (char const   )'T',      (char const   )'N',      (char const   )'E', 
        (char const   )'S',      (char const   )'S',      (char const   )' ',      (char const   )'F', 
        (char const   )'O',      (char const   )'R',      (char const   )' ',      (char const   )'A', 
        (char const   )' ',      (char const   )'P',      (char const   )'A',      (char const   )'R', 
        (char const   )'T',      (char const   )'I',      (char const   )'C',      (char const   )'U', 
        (char const   )'L',      (char const   )'A',      (char const   )'R',      (char const   )' ', 
        (char const   )'P',      (char const   )'U',      (char const   )'R',      (char const   )'P', 
        (char const   )'O',      (char const   )'S',      (char const   )'E',      (char const   )'.', 
        (char const   )' ',      (char const   )' ',      (char const   )'S',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'G',      (char const   )'N', 
        (char const   )'U',      (char const   )'\n',      (char const   )'G',      (char const   )'e', 
        (char const   )'n',      (char const   )'e',      (char const   )'r',      (char const   )'a', 
        (char const   )'l',      (char const   )' ',      (char const   )'P',      (char const   )'u', 
        (char const   )'b',      (char const   )'l',      (char const   )'i',      (char const   )'c', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )'t',      (char const   )'a',      (char const   )'i',      (char const   )'l', 
        (char const   )'s',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'Y',      (char const   )'o',      (char const   )'u',      (char const   )' ', 
        (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'u', 
        (char const   )'l',      (char const   )'d',      (char const   )' ',      (char const   )'h', 
        (char const   )'a',      (char const   )'v',      (char const   )'e',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'a',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'G', 
        (char const   )'N',      (char const   )'U',      (char const   )' ',      (char const   )'G', 
        (char const   )'e',      (char const   )'n',      (char const   )'e',      (char const   )'r', 
        (char const   )'a',      (char const   )'l',      (char const   )' ',      (char const   )'P', 
        (char const   )'u',      (char const   )'b',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )' ',      (char const   )'L',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'l', 
        (char const   )'o',      (char const   )'n',      (char const   )'g',      (char const   )'\n', 
        (char const   )'w',      (char const   )'i',      (char const   )'t',      (char const   )'h', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'o',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'m',      (char const   )';',      (char const   )' ',      (char const   )'i', 
        (char const   )'f',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )',',      (char const   )' ',      (char const   )'w', 
        (char const   )'r',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )',',      (char const   )'\n', 
        (char const   )'6',      (char const   )'7',      (char const   )'5',      (char const   )' ', 
        (char const   )'M',      (char const   )'a',      (char const   )'s',      (char const   )'s', 
        (char const   )' ',      (char const   )'A',      (char const   )'v',      (char const   )'e', 
        (char const   )',',      (char const   )' ',      (char const   )'C',      (char const   )'a', 
        (char const   )'m',      (char const   )'b',      (char const   )'r',      (char const   )'i', 
        (char const   )'d',      (char const   )'g',      (char const   )'e',      (char const   )',', 
        (char const   )' ',      (char const   )'M',      (char const   )'A',      (char const   )' ', 
        (char const   )'0',      (char const   )'2',      (char const   )'1',      (char const   )'3', 
        (char const   )'9',      (char const   )',',      (char const   )' ',      (char const   )'U', 
        (char const   )'S',      (char const   )'A',      (char const   )'.',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'\000'};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.h"
int hcwd_mounted(char const   *vname , long vcrdate , char const   *path , int partno ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.h"
void hfsutil_pinfo(hfsvolent *ent ) ;
#line 39
char *hfsutil_abspath(char const   *path ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.h"
void suid_enable(void) ;
#line 24
void suid_disable(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hmount.h"
int hmount_main(int argc , char **argv ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hmount.c"
int hmount_main(int argc , char **argv ) 
{ 
  char *path ;
  hfsvol *vol ;
  hfsvolent ent ;
  int nparts ;
  int partno ;
  int result ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 41
  path = (char *)0;
#line 44
  result = 0;
#line 46
  if (argc < 2) {
    {
#line 48
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s source-path [partition-no]\n",
            argv0);
    }
#line 49
    goto fail;
  } else
#line 46
  if (argc > 3) {
    {
#line 48
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s source-path [partition-no]\n",
            argv0);
    }
#line 49
    goto fail;
  }
  {
#line 52
  path = hfsutil_abspath((char const   *)*(argv + 1));
  }
#line 53
  if ((unsigned long )path == (unsigned long )((char *)0)) {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
            argv0);
    }
#line 56
    goto fail;
  }
  {
#line 59
  suid_enable();
#line 60
  nparts = hfs_nparts((char const   *)path);
#line 61
  suid_disable();
  }
#line 63
  if (nparts >= 0) {
#line 64
    if (nparts == 1) {
#line 64
      tmp = "";
    } else {
#line 64
      tmp = "s";
    }
    {
#line 64
    printf((char const   */* __restrict  */)"%s: contains %d HFS partition%s\n", path,
           nparts, tmp);
    }
  }
#line 67
  if (argc == 3) {
    {
#line 68
    partno = atoi((char const   *)*(argv + 2));
    }
  } else
#line 71
  if (nparts > 1) {
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: must specify partition number\n",
            argv0);
    }
#line 74
    goto fail;
  } else
#line 76
  if (nparts == -1) {
#line 77
    partno = 0;
  } else {
#line 79
    partno = 1;
  }
  {
#line 82
  suid_enable();
#line 83
  vol = hfs_mount((char const   *)path, partno, 2);
#line 84
  suid_disable();
  }
#line 86
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
    {
#line 88
    hfsutil_perror((char const   *)path);
    }
#line 89
    goto fail;
  }
  {
#line 92
  hfs_vstat(vol, & ent);
#line 93
  hfsutil_pinfo(& ent);
#line 95
  tmp___0 = hcwd_mounted((char const   *)(ent.name), ent.crdate, (char const   *)path,
                         partno);
  }
#line 95
  if (tmp___0 == -1) {
    {
#line 97
    perror("Failed to record mount");
#line 98
    result = 1;
    }
  }
  {
#line 101
  hfsutil_unmount(vol, & result);
#line 103
  free((void *)path);
  }
#line 105
  return (result);
  fail: 
#line 108
  if (path) {
    {
#line 109
    free((void *)path);
    }
  }
#line 111
  return (1);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hpwd.h"
int hpwd_main(int argc , char **argv ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hpwd.c"
int hpwd_main(int argc , char **argv ) 
{ 
  mountent *ent ;
  int tmp ;

  {
#line 41
  if (argc != 1) {
    {
#line 43
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s\n",
            argv0);
    }
#line 44
    return (1);
  }
  {
#line 47
  ent = hcwd_getvol(-1);
  }
#line 48
  if ((unsigned long )ent == (unsigned long )((mountent *)0)) {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No volume is current; use `hmount\' or `hvol\'\n",
            argv0);
    }
#line 52
    return (1);
  }
  {
#line 55
  tmp = strcmp(ent->cwd, ":");
  }
#line 55
  if (tmp == 0) {
    {
#line 56
    printf((char const   */* __restrict  */)"%s:\n", ent->vname);
    }
  } else {
    {
#line 58
    printf((char const   */* __restrict  */)"%s%s:\n", ent->vname, ent->cwd);
    }
  }
#line 60
  return (0);
}
}
#line 1016 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.h"
int hcwd_init(void) ;
#line 31
int hcwd_finish(void) ;
#line 34
int hcwd_umounted(int vol ) ;
#line 36
int hcwd_setvol(int vol ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
static FILE *statef  =    (FILE *)0;
#line 42 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
static mountent *mounts  =    (mountent *)0;
#line 43 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
static int mtabsz  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
static int nmounts  =    0;
#line 44 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
static int curvol___0  =    -1;
#line 44 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
static int dirty  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
static int addent(mountent *ent ) 
{ 
  mountent *newmem ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 53
  if (nmounts >= mtabsz) {
#line 57
    mtabsz += 8;
#line 58
    if (mounts) {
      {
#line 58
      tmp = realloc((void *)mounts, (unsigned long )mtabsz * sizeof(mountent ));
#line 58
      newmem = (mountent *)tmp;
      }
    } else {
      {
#line 58
      tmp___0 = malloc((unsigned long )mtabsz * sizeof(mountent ));
#line 58
      newmem = (mountent *)tmp___0;
      }
    }
#line 60
    if ((unsigned long )newmem == (unsigned long )((mountent *)0)) {
#line 61
      return (-1);
    }
#line 63
    mounts = newmem;
  }
#line 66
  tmp___1 = nmounts;
#line 66
  nmounts ++;
#line 66
  *(mounts + tmp___1) = *ent;
#line 68
  dirty = 1;
#line 70
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
int hcwd_init(void) 
{ 
  char const   *home ;
  char const   *start ;
  char buf[512] ;
  char *path ;
  char *ptr ;
  mountent entry ;
  int newcur ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 82
  newcur = -1;
#line 84
  tmp = getenv("HOME");
#line 84
  home = (char const   *)tmp;
  }
#line 85
  if ((unsigned long )home == (unsigned long )((char const   *)0)) {
#line 86
    home = "";
  }
  {
#line 88
  tmp___0 = strlen(home);
#line 88
  tmp___1 = malloc((tmp___0 + 1UL) + sizeof(".hcwd"));
#line 88
  path = (char *)tmp___1;
  }
#line 89
  if ((unsigned long )path == (unsigned long )((char *)0)) {
#line 90
    return (-1);
  }
  {
#line 92
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)home);
#line 93
  strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/.hcwd");
#line 95
  statef = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r+");
  }
#line 96
  if ((unsigned long )statef == (unsigned long )((FILE *)0)) {
    {
#line 96
    tmp___2 = __errno_location();
    }
#line 96
    if (*tmp___2 == 2) {
      {
#line 97
      statef = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w+");
      }
    }
  }
  {
#line 99
  free((void *)path);
  }
#line 101
  if ((unsigned long )statef == (unsigned long )((FILE *)0)) {
#line 102
    return (-1);
  }
  {
#line 104
  tmp___3 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)statef);
  }
#line 104
  if (tmp___3) {
    {
#line 105
    newcur = atoi((char const   *)(buf));
    }
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    tmp___9 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)statef);
    }
#line 107
    if (! tmp___9) {
#line 107
      goto while_break;
    }
#line 109
    ptr = buf;
#line 109
    start = (char const   *)ptr;
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (*ptr) {
#line 111
        if ((int )*ptr != 10) {
#line 111
          if (! ((int )*ptr != 9)) {
#line 111
            goto while_break___0;
          }
        } else {
#line 111
          goto while_break___0;
        }
      } else {
#line 111
        goto while_break___0;
      }
#line 112
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    entry.vname[0] = (char)0;
#line 115
    if ((int )*ptr == 9) {
      {
#line 117
      tmp___4 = ptr;
#line 117
      ptr ++;
#line 117
      *tmp___4 = (char)0;
#line 118
      strcpy((char */* __restrict  */)(entry.vname), (char const   */* __restrict  */)start);
#line 119
      start = (char const   *)ptr;
      }
    }
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (*ptr) {
#line 122
        if ((int )*ptr != 10) {
#line 122
          if (! ((int )*ptr != 9)) {
#line 122
            goto while_break___1;
          }
        } else {
#line 122
          goto while_break___1;
        }
      } else {
#line 122
        goto while_break___1;
      }
#line 123
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 125
    if ((int )*ptr == 9) {
      {
#line 127
      tmp___5 = ptr;
#line 127
      ptr ++;
#line 127
      *tmp___5 = (char)0;
#line 128
      entry.vcrdate = strtol((char const   */* __restrict  */)start, (char **/* __restrict  */)0,
                             0);
#line 129
      start = (char const   *)ptr;
      }
    }
    {
#line 132
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 132
      if (*ptr) {
#line 132
        if ((int )*ptr != 10) {
#line 132
          if (! ((int )*ptr != 9)) {
#line 132
            goto while_break___2;
          }
        } else {
#line 132
          goto while_break___2;
        }
      } else {
#line 132
        goto while_break___2;
      }
#line 133
      ptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 135
    if ((int )*ptr == 9) {
      {
#line 137
      tmp___6 = ptr;
#line 137
      ptr ++;
#line 137
      *tmp___6 = (char)0;
#line 138
      entry.path = strdup(start);
      }
#line 139
      if ((unsigned long )entry.path == (unsigned long )((char *)0)) {
#line 140
        return (-1);
      }
#line 142
      start = (char const   *)ptr;
    }
    {
#line 145
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 145
      if (*ptr) {
#line 145
        if ((int )*ptr != 10) {
#line 145
          if (! ((int )*ptr != 9)) {
#line 145
            goto while_break___3;
          }
        } else {
#line 145
          goto while_break___3;
        }
      } else {
#line 145
        goto while_break___3;
      }
#line 146
      ptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 148
    if ((int )*ptr == 9) {
      {
#line 150
      tmp___7 = ptr;
#line 150
      ptr ++;
#line 150
      *tmp___7 = (char)0;
#line 151
      entry.partno = atoi(start);
#line 152
      start = (char const   *)ptr;
      }
    }
    {
#line 155
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 155
      if (*ptr) {
#line 155
        if ((int )*ptr != 10) {
#line 155
          if (! ((int )*ptr != 9)) {
#line 155
            goto while_break___4;
          }
        } else {
#line 155
          goto while_break___4;
        }
      } else {
#line 155
        goto while_break___4;
      }
#line 156
      ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 158
    if ((int )*ptr == 10) {
#line 159
      *ptr = (char)0;
    } else
#line 158
    if ((int )*ptr == 9) {
#line 159
      *ptr = (char)0;
    }
#line 161
    if (*start) {
      {
#line 163
      entry.cwd = strdup(start);
      }
#line 164
      if ((unsigned long )entry.cwd == (unsigned long )((char *)0)) {
#line 165
        return (-1);
      }
      {
#line 167
      tmp___8 = addent(& entry);
      }
#line 167
      if (tmp___8 == -1) {
#line 168
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  if (newcur >= 0) {
#line 172
    if (newcur < nmounts) {
#line 172
      curvol___0 = newcur;
    } else {
#line 172
      curvol___0 = -1;
    }
  } else {
#line 172
    curvol___0 = -1;
  }
#line 174
  return (0);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
int hcwd_finish(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  mountent *ent ;
  int tmp___1 ;

  {
#line 183
  if (statef) {
#line 183
    if (mounts) {
#line 183
      if (dirty) {
        {
#line 187
        rewind(statef);
#line 188
        tmp = fileno(statef);
#line 188
        tmp___0 = ftruncate(tmp, (__off_t )0);
        }
#line 188
        if (tmp___0 == -1) {
#line 189
          return (-1);
        }
        {
#line 191
        fprintf((FILE */* __restrict  */)statef, (char const   */* __restrict  */)"%d\n",
                curvol___0);
#line 193
        i = 0;
        }
        {
#line 193
        while (1) {
          while_continue: /* CIL Label */ ;
#line 193
          if (! (i < nmounts)) {
#line 193
            goto while_break;
          }
          {
#line 194
          fprintf((FILE */* __restrict  */)statef, (char const   */* __restrict  */)"%s\t%ld\t%s\t%d\t%s\n",
                  (mounts + i)->vname, (mounts + i)->vcrdate, (mounts + i)->path,
                  (mounts + i)->partno, (mounts + i)->cwd);
#line 193
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 201
        dirty = 0;
      }
    }
  }
#line 204
  if (mounts) {
#line 208
    ent = mounts;
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (! ((unsigned long )ent < (unsigned long )(mounts + nmounts))) {
#line 208
        goto while_break___0;
      }
#line 210
      if (ent->path) {
        {
#line 211
        free((void *)ent->path);
        }
      }
#line 212
      if (ent->cwd) {
        {
#line 213
        free((void *)ent->cwd);
        }
      }
#line 208
      ent ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 216
    free((void *)mounts);
    }
  }
#line 219
  if (statef) {
    {
#line 219
    tmp___1 = fclose(statef);
    }
#line 219
    if (tmp___1 == -1) {
#line 220
      return (-1);
    }
  }
#line 222
  return (0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
int hcwd_mounted(char const   *vname , long vcrdate , char const   *path , int partno ) 
{ 
  mountent *entry ;
  mountent new ;
  int tmp ;
  int tmp___0 ;

  {
#line 233
  entry = mounts;
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((unsigned long )entry < (unsigned long )(mounts + nmounts))) {
#line 233
      goto while_break;
    }
    {
#line 235
    tmp = strcmp((char const   *)entry->path, path);
    }
#line 235
    if (tmp == 0) {
#line 235
      if (entry->partno == partno) {
#line 240
        if (entry->cwd) {
          {
#line 241
          free((void *)entry->cwd);
          }
        }
        {
#line 243
        strcpy((char */* __restrict  */)(entry->vname), (char const   */* __restrict  */)vname);
#line 244
        entry->vcrdate = vcrdate;
#line 245
        entry->cwd = strdup(":");
        }
#line 246
        if ((unsigned long )entry->cwd == (unsigned long )((char *)0)) {
#line 247
          return (-1);
        }
#line 249
        curvol___0 = (int )(entry - mounts);
#line 250
        dirty = 1;
#line 252
        return (0);
      }
    }
#line 233
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  strcpy((char */* __restrict  */)(new.vname), (char const   */* __restrict  */)vname);
#line 257
  new.vcrdate = vcrdate;
#line 258
  new.path = strdup(path);
#line 259
  new.partno = partno;
#line 260
  new.cwd = strdup(":");
  }
#line 262
  if ((unsigned long )new.path == (unsigned long )((char *)0)) {
#line 264
    return (-1);
  } else
#line 262
  if ((unsigned long )new.cwd == (unsigned long )((char *)0)) {
#line 264
    return (-1);
  }
  {
#line 266
  tmp___0 = addent(& new);
  }
#line 266
  if (tmp___0 == -1) {
#line 267
    return (-1);
  }
#line 269
  curvol___0 = nmounts - 1;
#line 271
  return (0);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
int hcwd_umounted(int vol ) 
{ 
  mountent *entry ;
  int i ;

  {
#line 283
  if (vol < 0) {
#line 284
    vol = curvol___0;
  }
#line 286
  if (vol < 0) {
#line 287
    return (-1);
  } else
#line 286
  if (vol >= nmounts) {
#line 287
    return (-1);
  }
#line 289
  entry = mounts + vol;
#line 291
  if (entry->path) {
    {
#line 292
    free((void *)entry->path);
    }
  }
#line 293
  if (entry->cwd) {
    {
#line 294
    free((void *)entry->cwd);
    }
  }
#line 296
  i = vol + 1;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < nmounts)) {
#line 296
      goto while_break;
    }
#line 297
    *(mounts + (i - 1)) = *(mounts + i);
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  nmounts --;
#line 301
  if (curvol___0 > vol) {
#line 302
    curvol___0 --;
  } else
#line 303
  if (curvol___0 == vol) {
#line 304
    curvol___0 = -1;
  }
#line 306
  return (0);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
mountent *hcwd_getvol(int vol ) 
{ 


  {
#line 315
  if (vol < 0) {
#line 316
    vol = curvol___0;
  }
#line 318
  if (vol < 0) {
#line 319
    return ((mountent *)0);
  } else
#line 318
  if (vol >= nmounts) {
#line 319
    return ((mountent *)0);
  }
#line 321
  return (mounts + vol);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
int hcwd_setvol(int vol ) 
{ 


  {
#line 330
  if (vol < 0) {
#line 331
    return (-1);
  } else
#line 330
  if (vol >= nmounts) {
#line 331
    return (-1);
  }
#line 333
  if (curvol___0 != vol) {
#line 335
    curvol___0 = vol;
#line 336
    dirty = 1;
  }
#line 339
  return (0);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcwd.c"
int hcwd_setcwd(mountent *ent , char const   *newcwd ) 
{ 
  char const   *path ;
  char *cwd ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 351
  path = newcwd;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (*path) {
#line 352
      if (! ((int const   )*path != 58)) {
#line 352
        goto while_break;
      }
    } else {
#line 352
      goto while_break;
    }
#line 353
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 355
  memcpy((void */* __restrict  */)(ent->vname), (void const   */* __restrict  */)newcwd,
         (size_t )(path - newcwd));
#line 356
  ent->vname[path - newcwd] = (char)0;
  }
#line 358
  if ((int const   )*path == 0) {
    {
#line 358
    tmp = strdup(":");
#line 358
    cwd = tmp;
    }
  } else {
    {
#line 358
    tmp___0 = strdup(path);
#line 358
    cwd = tmp___0;
    }
  }
#line 359
  if ((unsigned long )cwd == (unsigned long )((char *)0)) {
#line 360
    return (-1);
  }
#line 362
  if (ent->cwd) {
    {
#line 363
    free((void *)ent->cwd);
    }
  }
#line 365
  ent->cwd = cwd;
#line 366
  dirty = 1;
#line 368
  return (0);
}
}
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 722
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setregid)(__gid_t __rgid ,
                                                                               __gid_t __egid ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.h"
void suid_init(void) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.c"
static uid_t uid  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.c"
static uid_t euid  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.c"
static gid_t gid  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.c"
static gid_t egid  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.c"
void suid_init(void) 
{ 


  {
  {
#line 55
  uid = getuid();
#line 56
  gid = getgid();
#line 58
  euid = geteuid();
#line 59
  egid = getegid();
#line 61
  suid_disable();
  }
#line 62
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.c"
void suid_enable(void) 
{ 


  {
  {
#line 72
  setreuid((__uid_t )-1, euid);
#line 73
  setregid((__gid_t )-1, egid);
  }
#line 81
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/suid.c"
void suid_disable(void) 
{ 


  {
  {
#line 91
  setreuid((__uid_t )-1, uid);
#line 92
  setregid((__gid_t )-1, gid);
  }
#line 100
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/crc.h"
unsigned short crc_macb(unsigned char const   *ptr , int count , unsigned short crc___0 ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/crc.c"
static unsigned short const   magic[256]  = 
#line 28 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/crc.c"
  {      (unsigned short const   )0,      (unsigned short const   )4129,      (unsigned short const   )8258,      (unsigned short const   )12387, 
        (unsigned short const   )16516,      (unsigned short const   )20645,      (unsigned short const   )24774,      (unsigned short const   )28903, 
        (unsigned short const   )33032,      (unsigned short const   )37161,      (unsigned short const   )41290,      (unsigned short const   )45419, 
        (unsigned short const   )49548,      (unsigned short const   )53677,      (unsigned short const   )57806,      (unsigned short const   )61935, 
        (unsigned short const   )4657,      (unsigned short const   )528,      (unsigned short const   )12915,      (unsigned short const   )8786, 
        (unsigned short const   )21173,      (unsigned short const   )17044,      (unsigned short const   )29431,      (unsigned short const   )25302, 
        (unsigned short const   )37689,      (unsigned short const   )33560,      (unsigned short const   )45947,      (unsigned short const   )41818, 
        (unsigned short const   )54205,      (unsigned short const   )50076,      (unsigned short const   )62463,      (unsigned short const   )58334, 
        (unsigned short const   )9314,      (unsigned short const   )13379,      (unsigned short const   )1056,      (unsigned short const   )5121, 
        (unsigned short const   )25830,      (unsigned short const   )29895,      (unsigned short const   )17572,      (unsigned short const   )21637, 
        (unsigned short const   )42346,      (unsigned short const   )46411,      (unsigned short const   )34088,      (unsigned short const   )38153, 
        (unsigned short const   )58862,      (unsigned short const   )62927,      (unsigned short const   )50604,      (unsigned short const   )54669, 
        (unsigned short const   )13907,      (unsigned short const   )9842,      (unsigned short const   )5649,      (unsigned short const   )1584, 
        (unsigned short const   )30423,      (unsigned short const   )26358,      (unsigned short const   )22165,      (unsigned short const   )18100, 
        (unsigned short const   )46939,      (unsigned short const   )42874,      (unsigned short const   )38681,      (unsigned short const   )34616, 
        (unsigned short const   )63455,      (unsigned short const   )59390,      (unsigned short const   )55197,      (unsigned short const   )51132, 
        (unsigned short const   )18628,      (unsigned short const   )22757,      (unsigned short const   )26758,      (unsigned short const   )30887, 
        (unsigned short const   )2112,      (unsigned short const   )6241,      (unsigned short const   )10242,      (unsigned short const   )14371, 
        (unsigned short const   )51660,      (unsigned short const   )55789,      (unsigned short const   )59790,      (unsigned short const   )63919, 
        (unsigned short const   )35144,      (unsigned short const   )39273,      (unsigned short const   )43274,      (unsigned short const   )47403, 
        (unsigned short const   )23285,      (unsigned short const   )19156,      (unsigned short const   )31415,      (unsigned short const   )27286, 
        (unsigned short const   )6769,      (unsigned short const   )2640,      (unsigned short const   )14899,      (unsigned short const   )10770, 
        (unsigned short const   )56317,      (unsigned short const   )52188,      (unsigned short const   )64447,      (unsigned short const   )60318, 
        (unsigned short const   )39801,      (unsigned short const   )35672,      (unsigned short const   )47931,      (unsigned short const   )43802, 
        (unsigned short const   )27814,      (unsigned short const   )31879,      (unsigned short const   )19684,      (unsigned short const   )23749, 
        (unsigned short const   )11298,      (unsigned short const   )15363,      (unsigned short const   )3168,      (unsigned short const   )7233, 
        (unsigned short const   )60846,      (unsigned short const   )64911,      (unsigned short const   )52716,      (unsigned short const   )56781, 
        (unsigned short const   )44330,      (unsigned short const   )48395,      (unsigned short const   )36200,      (unsigned short const   )40265, 
        (unsigned short const   )32407,      (unsigned short const   )28342,      (unsigned short const   )24277,      (unsigned short const   )20212, 
        (unsigned short const   )15891,      (unsigned short const   )11826,      (unsigned short const   )7761,      (unsigned short const   )3696, 
        (unsigned short const   )65439,      (unsigned short const   )61374,      (unsigned short const   )57309,      (unsigned short const   )53244, 
        (unsigned short const   )48923,      (unsigned short const   )44858,      (unsigned short const   )40793,      (unsigned short const   )36728, 
        (unsigned short const   )37256,      (unsigned short const   )33193,      (unsigned short const   )45514,      (unsigned short const   )41451, 
        (unsigned short const   )53516,      (unsigned short const   )49453,      (unsigned short const   )61774,      (unsigned short const   )57711, 
        (unsigned short const   )4224,      (unsigned short const   )161,      (unsigned short const   )12482,      (unsigned short const   )8419, 
        (unsigned short const   )20484,      (unsigned short const   )16421,      (unsigned short const   )28742,      (unsigned short const   )24679, 
        (unsigned short const   )33721,      (unsigned short const   )37784,      (unsigned short const   )41979,      (unsigned short const   )46042, 
        (unsigned short const   )49981,      (unsigned short const   )54044,      (unsigned short const   )58239,      (unsigned short const   )62302, 
        (unsigned short const   )689,      (unsigned short const   )4752,      (unsigned short const   )8947,      (unsigned short const   )13010, 
        (unsigned short const   )16949,      (unsigned short const   )21012,      (unsigned short const   )25207,      (unsigned short const   )29270, 
        (unsigned short const   )46570,      (unsigned short const   )42443,      (unsigned short const   )38312,      (unsigned short const   )34185, 
        (unsigned short const   )62830,      (unsigned short const   )58703,      (unsigned short const   )54572,      (unsigned short const   )50445, 
        (unsigned short const   )13538,      (unsigned short const   )9411,      (unsigned short const   )5280,      (unsigned short const   )1153, 
        (unsigned short const   )29798,      (unsigned short const   )25671,      (unsigned short const   )21540,      (unsigned short const   )17413, 
        (unsigned short const   )42971,      (unsigned short const   )47098,      (unsigned short const   )34713,      (unsigned short const   )38840, 
        (unsigned short const   )59231,      (unsigned short const   )63358,      (unsigned short const   )50973,      (unsigned short const   )55100, 
        (unsigned short const   )9939,      (unsigned short const   )14066,      (unsigned short const   )1681,      (unsigned short const   )5808, 
        (unsigned short const   )26199,      (unsigned short const   )30326,      (unsigned short const   )17941,      (unsigned short const   )22068, 
        (unsigned short const   )55628,      (unsigned short const   )51565,      (unsigned short const   )63758,      (unsigned short const   )59695, 
        (unsigned short const   )39368,      (unsigned short const   )35305,      (unsigned short const   )47498,      (unsigned short const   )43435, 
        (unsigned short const   )22596,      (unsigned short const   )18533,      (unsigned short const   )30726,      (unsigned short const   )26663, 
        (unsigned short const   )6336,      (unsigned short const   )2273,      (unsigned short const   )14466,      (unsigned short const   )10403, 
        (unsigned short const   )52093,      (unsigned short const   )56156,      (unsigned short const   )60223,      (unsigned short const   )64286, 
        (unsigned short const   )35833,      (unsigned short const   )39896,      (unsigned short const   )43963,      (unsigned short const   )48026, 
        (unsigned short const   )19061,      (unsigned short const   )23124,      (unsigned short const   )27191,      (unsigned short const   )31254, 
        (unsigned short const   )2801,      (unsigned short const   )6864,      (unsigned short const   )10931,      (unsigned short const   )14994, 
        (unsigned short const   )64814,      (unsigned short const   )60687,      (unsigned short const   )56684,      (unsigned short const   )52557, 
        (unsigned short const   )48554,      (unsigned short const   )44427,      (unsigned short const   )40424,      (unsigned short const   )36297, 
        (unsigned short const   )31782,      (unsigned short const   )27655,      (unsigned short const   )23652,      (unsigned short const   )19525, 
        (unsigned short const   )15522,      (unsigned short const   )11395,      (unsigned short const   )7392,      (unsigned short const   )3265, 
        (unsigned short const   )61215,      (unsigned short const   )65342,      (unsigned short const   )53085,      (unsigned short const   )57212, 
        (unsigned short const   )44955,      (unsigned short const   )49082,      (unsigned short const   )36825,      (unsigned short const   )40952, 
        (unsigned short const   )28183,      (unsigned short const   )32310,      (unsigned short const   )20053,      (unsigned short const   )24180, 
        (unsigned short const   )11923,      (unsigned short const   )16050,      (unsigned short const   )3793,      (unsigned short const   )7920};
#line 75 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/crc.c"
unsigned short crc_binh(unsigned char const   *ptr , int count , unsigned short crc___0 ) 
{ 
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    tmp___0 = count;
#line 78
    count --;
#line 78
    if (! tmp___0) {
#line 78
      goto while_break;
    }
#line 79
    tmp = ptr;
#line 79
    ptr ++;
#line 79
    crc___0 = (unsigned short )((((int )crc___0 << 8) | (int )*tmp) ^ (int )magic[(int )crc___0 >> 8]);
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return (crc___0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/crc.c"
unsigned short crc_macb(unsigned char const   *ptr , int count , unsigned short crc___0 ) 
{ 
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    tmp___0 = count;
#line 91
    count --;
#line 91
    if (! tmp___0) {
#line 91
      goto while_break;
    }
#line 93
    tmp = ptr;
#line 93
    ptr ++;
#line 93
    crc___0 = (unsigned short )((int )crc___0 ^ (int )((int const   )*tmp << 8));
#line 94
    crc___0 = (unsigned short )(((int )crc___0 << 8) ^ (int )magic[(int )crc___0 >> 8]);
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (crc___0);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/version.h"
char const   libhfs_rcsid[52] ;
#line 24
char const   libhfs_version[21] ;
#line 25
char const   libhfs_copyright[38] ;
#line 26
char const   libhfs_author[29] ;
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/version.c"
char const   libhfs_rcsid[52]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/version.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'.',      (char const   )'c',      (char const   )',',      (char const   )'v', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'1', 
        (char const   )'1',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'8',      (char const   )'/',      (char const   )'1', 
        (char const   )'1',      (char const   )'/',      (char const   )'0',      (char const   )'2', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'0',      (char const   )'9',      (char const   )':',      (char const   )'0', 
        (char const   )'9',      (char const   )' ',      (char const   )'r',      (char const   )'o', 
        (char const   )'b',      (char const   )' ',      (char const   )'E',      (char const   )'x', 
        (char const   )'p',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 27 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/version.c"
char const   libhfs_version[21]  = 
#line 27
  {      (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'h', 
        (char const   )'f',      (char const   )'s',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'3', 
        (char const   )'.',      (char const   )'2',      (char const   )'.',      (char const   )'6', 
        (char const   )'\000'};
#line 28 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/version.c"
char const   libhfs_copyright[38]  = 
#line 28
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'C', 
        (char const   )')',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'6',      (char const   )'-',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'8',      (char const   )' ', 
        (char const   )'R',      (char const   )'o',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'s',      (char const   )'l',      (char const   )'i', 
        (char const   )'e',      (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/version.c"
char const   libhfs_author[29]  = 
#line 29
  {      (char const   )'R',      (char const   )'o',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'L', 
        (char const   )'e',      (char const   )'s',      (char const   )'l',      (char const   )'i', 
        (char const   )'e',      (char const   )' ',      (char const   )'<',      (char const   )'r', 
        (char const   )'o',      (char const   )'b',      (char const   )'@',      (char const   )'m', 
        (char const   )'a',      (char const   )'r',      (char const   )'s',      (char const   )'.', 
        (char const   )'o',      (char const   )'r',      (char const   )'g',      (char const   )'>', 
        (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.h"
int dl_init(dlist *list ) ;
#line 30
void dl_free(dlist *list ) ;
#line 31
char **dl_array(dlist *list ) ;
#line 32
int dl_size(dlist *list ) ;
#line 33
int dl_append(dlist *list , char const   *str ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.c"
int dl_init(dlist *list ) 
{ 
  void *tmp ;

  {
  {
#line 37
  list->memsz = (size_t )100;
#line 38
  tmp = malloc(list->memsz);
#line 38
  list->mem = (char *)tmp;
  }
#line 39
  if ((unsigned long )list->mem == (unsigned long )((char *)0)) {
#line 40
    return (-1);
  }
#line 42
  list->eltend = (char **)list->mem;
#line 43
  list->strs = list->mem + list->memsz;
#line 45
  return (0);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.c"
void dl_free(dlist *list ) 
{ 


  {
  {
#line 54
  free((void *)list->mem);
  }
#line 55
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.c"
char **dl_array(dlist *list ) 
{ 


  {
#line 63
  return ((char **)list->mem);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.c"
int dl_size(dlist *list ) 
{ 


  {
#line 72
  return ((int )(list->eltend - (char **)list->mem));
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dlist.c"
int dl_append(dlist *list , char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  dlist newlist ;
  size_t strsz ;
  char **elt ;
  void *tmp___0 ;
  char **tmp___1 ;
  char **tmp___2 ;

  {
  {
#line 83
  tmp = strlen(str);
#line 83
  len = tmp + 1UL;
  }
#line 87
  if (sizeof(char *) + len > (size_t )(list->strs - (char *)list->eltend)) {
    {
#line 93
    strsz = (size_t )((list->mem + list->memsz) - list->strs);
#line 95
    newlist.memsz = (list->memsz * 2UL + sizeof(char *)) + len;
#line 96
    tmp___0 = malloc(newlist.memsz);
#line 96
    newlist.mem = (char *)tmp___0;
    }
#line 97
    if ((unsigned long )newlist.mem == (unsigned long )((char *)0)) {
#line 98
      return (-1);
    }
    {
#line 100
    newlist.eltend = (char **)newlist.mem;
#line 101
    newlist.strs = (newlist.mem + newlist.memsz) - strsz;
#line 103
    memcpy((void */* __restrict  */)newlist.strs, (void const   */* __restrict  */)list->strs,
           strsz);
#line 105
    elt = (char **)list->mem;
    }
    {
#line 105
    while (1) {
      while_continue: /* CIL Label */ ;
#line 105
      if (! ((unsigned long )elt < (unsigned long )list->eltend)) {
#line 105
        goto while_break;
      }
#line 106
      tmp___1 = newlist.eltend;
#line 106
      (newlist.eltend) ++;
#line 106
      *tmp___1 = newlist.strs + (*elt - list->strs);
#line 105
      elt ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 108
    free((void *)list->mem);
#line 110
    *list = newlist;
    }
  }
  {
#line 113
  list->strs -= len;
#line 114
  strcpy((char */* __restrict  */)list->strs, (char const   */* __restrict  */)str);
#line 116
  tmp___2 = list->eltend;
#line 116
  (list->eltend) ++;
#line 116
  *tmp___2 = list->strs;
  }
#line 118
  return (0);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.h"
UCS2 *cs_unicode(char *mstr , int *lenptr ) ;
#line 26
char *cs_latin1(char *mstr , int *lenptr ) ;
#line 27
char *cs_macroman(char *lstr , int *lenptr ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
static UCS2 const   macroman[256]  = 
#line 31 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
  {      (UCS2 const   )0,      (UCS2 const   )1,      (UCS2 const   )2,      (UCS2 const   )3, 
        (UCS2 const   )4,      (UCS2 const   )5,      (UCS2 const   )6,      (UCS2 const   )7, 
        (UCS2 const   )8,      (UCS2 const   )9,      (UCS2 const   )10,      (UCS2 const   )11, 
        (UCS2 const   )12,      (UCS2 const   )13,      (UCS2 const   )14,      (UCS2 const   )15, 
        (UCS2 const   )16,      (UCS2 const   )17,      (UCS2 const   )18,      (UCS2 const   )19, 
        (UCS2 const   )20,      (UCS2 const   )21,      (UCS2 const   )22,      (UCS2 const   )23, 
        (UCS2 const   )24,      (UCS2 const   )25,      (UCS2 const   )26,      (UCS2 const   )27, 
        (UCS2 const   )28,      (UCS2 const   )29,      (UCS2 const   )30,      (UCS2 const   )31, 
        (UCS2 const   )32,      (UCS2 const   )33,      (UCS2 const   )34,      (UCS2 const   )35, 
        (UCS2 const   )36,      (UCS2 const   )37,      (UCS2 const   )38,      (UCS2 const   )39, 
        (UCS2 const   )40,      (UCS2 const   )41,      (UCS2 const   )42,      (UCS2 const   )43, 
        (UCS2 const   )44,      (UCS2 const   )45,      (UCS2 const   )46,      (UCS2 const   )47, 
        (UCS2 const   )48,      (UCS2 const   )49,      (UCS2 const   )50,      (UCS2 const   )51, 
        (UCS2 const   )52,      (UCS2 const   )53,      (UCS2 const   )54,      (UCS2 const   )55, 
        (UCS2 const   )56,      (UCS2 const   )57,      (UCS2 const   )58,      (UCS2 const   )59, 
        (UCS2 const   )60,      (UCS2 const   )61,      (UCS2 const   )62,      (UCS2 const   )63, 
        (UCS2 const   )64,      (UCS2 const   )65,      (UCS2 const   )66,      (UCS2 const   )67, 
        (UCS2 const   )68,      (UCS2 const   )69,      (UCS2 const   )70,      (UCS2 const   )71, 
        (UCS2 const   )72,      (UCS2 const   )73,      (UCS2 const   )74,      (UCS2 const   )75, 
        (UCS2 const   )76,      (UCS2 const   )77,      (UCS2 const   )78,      (UCS2 const   )79, 
        (UCS2 const   )80,      (UCS2 const   )81,      (UCS2 const   )82,      (UCS2 const   )83, 
        (UCS2 const   )84,      (UCS2 const   )85,      (UCS2 const   )86,      (UCS2 const   )87, 
        (UCS2 const   )88,      (UCS2 const   )89,      (UCS2 const   )90,      (UCS2 const   )91, 
        (UCS2 const   )92,      (UCS2 const   )93,      (UCS2 const   )94,      (UCS2 const   )95, 
        (UCS2 const   )96,      (UCS2 const   )97,      (UCS2 const   )98,      (UCS2 const   )99, 
        (UCS2 const   )100,      (UCS2 const   )101,      (UCS2 const   )102,      (UCS2 const   )103, 
        (UCS2 const   )104,      (UCS2 const   )105,      (UCS2 const   )106,      (UCS2 const   )107, 
        (UCS2 const   )108,      (UCS2 const   )109,      (UCS2 const   )110,      (UCS2 const   )111, 
        (UCS2 const   )112,      (UCS2 const   )113,      (UCS2 const   )114,      (UCS2 const   )115, 
        (UCS2 const   )116,      (UCS2 const   )117,      (UCS2 const   )118,      (UCS2 const   )119, 
        (UCS2 const   )120,      (UCS2 const   )121,      (UCS2 const   )122,      (UCS2 const   )123, 
        (UCS2 const   )124,      (UCS2 const   )125,      (UCS2 const   )126,      (UCS2 const   )127, 
        (UCS2 const   )196,      (UCS2 const   )197,      (UCS2 const   )199,      (UCS2 const   )201, 
        (UCS2 const   )209,      (UCS2 const   )214,      (UCS2 const   )220,      (UCS2 const   )225, 
        (UCS2 const   )224,      (UCS2 const   )226,      (UCS2 const   )228,      (UCS2 const   )227, 
        (UCS2 const   )229,      (UCS2 const   )231,      (UCS2 const   )233,      (UCS2 const   )232, 
        (UCS2 const   )234,      (UCS2 const   )235,      (UCS2 const   )237,      (UCS2 const   )236, 
        (UCS2 const   )238,      (UCS2 const   )239,      (UCS2 const   )241,      (UCS2 const   )243, 
        (UCS2 const   )242,      (UCS2 const   )244,      (UCS2 const   )246,      (UCS2 const   )245, 
        (UCS2 const   )250,      (UCS2 const   )249,      (UCS2 const   )251,      (UCS2 const   )252, 
        (UCS2 const   )8224,      (UCS2 const   )176,      (UCS2 const   )162,      (UCS2 const   )163, 
        (UCS2 const   )167,      (UCS2 const   )8226,      (UCS2 const   )182,      (UCS2 const   )223, 
        (UCS2 const   )174,      (UCS2 const   )169,      (UCS2 const   )8482,      (UCS2 const   )180, 
        (UCS2 const   )168,      (UCS2 const   )8800,      (UCS2 const   )198,      (UCS2 const   )216, 
        (UCS2 const   )8734,      (UCS2 const   )177,      (UCS2 const   )8804,      (UCS2 const   )8805, 
        (UCS2 const   )165,      (UCS2 const   )181,      (UCS2 const   )8706,      (UCS2 const   )8721, 
        (UCS2 const   )8719,      (UCS2 const   )960,      (UCS2 const   )8747,      (UCS2 const   )170, 
        (UCS2 const   )186,      (UCS2 const   )8486,      (UCS2 const   )230,      (UCS2 const   )248, 
        (UCS2 const   )191,      (UCS2 const   )161,      (UCS2 const   )172,      (UCS2 const   )8730, 
        (UCS2 const   )402,      (UCS2 const   )8776,      (UCS2 const   )8710,      (UCS2 const   )171, 
        (UCS2 const   )187,      (UCS2 const   )8230,      (UCS2 const   )160,      (UCS2 const   )192, 
        (UCS2 const   )195,      (UCS2 const   )213,      (UCS2 const   )338,      (UCS2 const   )339, 
        (UCS2 const   )8211,      (UCS2 const   )8212,      (UCS2 const   )8220,      (UCS2 const   )8221, 
        (UCS2 const   )8216,      (UCS2 const   )8217,      (UCS2 const   )247,      (UCS2 const   )9674, 
        (UCS2 const   )255,      (UCS2 const   )376,      (UCS2 const   )8260,      (UCS2 const   )164, 
        (UCS2 const   )8249,      (UCS2 const   )8250,      (UCS2 const   )64257,      (UCS2 const   )64258, 
        (UCS2 const   )8225,      (UCS2 const   )183,      (UCS2 const   )8218,      (UCS2 const   )8222, 
        (UCS2 const   )8240,      (UCS2 const   )194,      (UCS2 const   )202,      (UCS2 const   )193, 
        (UCS2 const   )203,      (UCS2 const   )200,      (UCS2 const   )205,      (UCS2 const   )206, 
        (UCS2 const   )207,      (UCS2 const   )204,      (UCS2 const   )211,      (UCS2 const   )212, 
        (UCS2 const   )63743,      (UCS2 const   )210,      (UCS2 const   )218,      (UCS2 const   )219, 
        (UCS2 const   )217,      (UCS2 const   )305,      (UCS2 const   )710,      (UCS2 const   )732, 
        (UCS2 const   )175,      (UCS2 const   )728,      (UCS2 const   )729,      (UCS2 const   )730, 
        (UCS2 const   )184,      (UCS2 const   )733,      (UCS2 const   )731,      (UCS2 const   )711};
#line 74 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
static char const   *macroman_subst[128]  = 
#line 74
  {      (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "+",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "*",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "[tm]",      (char const   *)0, 
        (char const   *)0,      "!=",      (char const   *)0,      (char const   *)0, 
        "[inf]",      (char const   *)0,      "<=",      ">=", 
        (char const   *)0,      (char const   *)0,      "[partial]",      "[Sum]", 
        "[Prod]",      "[pi]",      "[Integral]",      (char const   *)0, 
        (char const   *)0,      "[ohm]",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "[Sqrt]", 
        "[f]",      "~=",      "[delta]",      (char const   *)0, 
        (char const   *)0,      "...",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "OE",      "oe", 
        "-",      "--",      "``",      "\'\'", 
        "`",      "\'",      (char const   *)0,      "#", 
        (char const   *)0,      "Y",      "/",      (char const   *)0, 
        "<",      ">",      "fi",      "fl", 
        "++",      (char const   *)0,      ",",      ",,", 
        "o/oo",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "[Apple]",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "i",      "^",      "~", 
        (char const   *)0,      "-",      "\267",      "\260", 
        (char const   *)0,      "\"",      "-",      "^"};
#line 98 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
static unsigned char latin1[256]  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
static char const   *latin1_subst[128]  = 
#line 101
  {      "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "|",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "-",      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      "[^2]",      "[^3]", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "[^1]",      (char const   *)0,      (char const   *)0, 
        "[1/4]",      "[1/2]",      "[3/4]",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "D",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      "x", 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "Y",      "P",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "d",      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      "y",      "p",      (char const   *)0};
#line 130 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
UCS2 *cs_unicode(char *mstr , int *lenptr ) 
{ 
  int len ;
  int i ;
  UCS2 *unicode ;
  UCS2 *ptr ;
  size_t tmp ;
  void *tmp___0 ;
  UCS2 *tmp___1 ;
  char *tmp___2 ;

  {
#line 135
  if (lenptr) {
#line 135
    len = *lenptr;
  } else {
    {
#line 135
    tmp = strlen((char const   *)mstr);
#line 135
    len = (int )tmp;
    }
  }
  {
#line 137
  tmp___0 = malloc((unsigned long )(len + 1) * sizeof(UCS2 ));
#line 137
  unicode = (UCS2 *)tmp___0;
  }
#line 138
  if ((unsigned long )unicode == (unsigned long )((UCS2 *)0)) {
#line 139
    return ((UCS2 *)0);
  }
#line 141
  ptr = unicode;
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < len)) {
#line 142
      goto while_break;
    }
#line 143
    tmp___1 = ptr;
#line 143
    ptr ++;
#line 143
    tmp___2 = mstr;
#line 143
    mstr ++;
#line 143
    *tmp___1 = (UCS2 )macroman[*((unsigned char *)tmp___2)];
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  *ptr = (UCS2 )0;
#line 147
  return (unicode);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
char *cs_latin1(char *mstr , int *lenptr ) 
{ 
  int ilen ;
  int olen ;
  int i ;
  char *latin1___0 ;
  char *ptr ;
  char const   *subst ;
  unsigned char ch ;
  UCS2 unicode ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 162
  if (lenptr) {
#line 162
    ilen = *lenptr;
  } else {
    {
#line 162
    tmp = strlen((char const   *)mstr);
#line 162
    ilen = (int )tmp;
    }
  }
#line 164
  olen = 0;
#line 165
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < ilen)) {
#line 165
      goto while_break;
    }
#line 167
    ch = *((unsigned char *)mstr + i);
#line 168
    unicode = (UCS2 )macroman[ch];
#line 170
    if ((int )unicode & 65280) {
      {
#line 171
      tmp___0 = strlen(macroman_subst[(int )ch & 127]);
#line 171
      olen = (int )((size_t )olen + tmp___0);
      }
    } else {
#line 173
      olen ++;
    }
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  tmp___1 = malloc((size_t )(olen + 1));
#line 176
  latin1___0 = (char *)tmp___1;
  }
#line 177
  if ((unsigned long )latin1___0 == (unsigned long )((char *)0)) {
#line 178
    return ((char *)0);
  }
#line 180
  ptr = latin1___0;
#line 181
  i = 0;
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! (i < ilen)) {
#line 181
      goto while_break___0;
    }
#line 183
    tmp___2 = mstr;
#line 183
    mstr ++;
#line 183
    ch = *((unsigned char *)tmp___2);
#line 184
    unicode = (UCS2 )macroman[ch];
#line 186
    if ((int )unicode & 65280) {
      {
#line 190
      subst = macroman_subst[(int )ch & 127];
#line 192
      strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)subst);
#line 193
      tmp___3 = strlen(subst);
#line 193
      ptr += tmp___3;
      }
    } else {
#line 196
      tmp___4 = ptr;
#line 196
      ptr ++;
#line 196
      *tmp___4 = (char )unicode;
    }
#line 181
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  *ptr = (char)0;
#line 201
  if (lenptr) {
#line 202
    *lenptr = olen;
  }
#line 204
  return (latin1___0);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
static void mktable(void) 
{ 
  int i ;
  UCS2 unicode ;

  {
#line 216
  i = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i <= 255)) {
#line 216
      goto while_break;
    }
#line 217
    latin1[i] = (unsigned char)255;
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  i = 0;
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if (! (i <= 255)) {
#line 219
      goto while_break___0;
    }
#line 221
    unicode = (UCS2 )macroman[i];
#line 223
    if (! ((int )unicode & 65280)) {
#line 224
      latin1[unicode] = (unsigned char )i;
    }
#line 219
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/charset.c"
char *cs_macroman(char *lstr , int *lenptr ) 
{ 
  int ilen ;
  int olen ;
  int i ;
  char *macroman___0 ;
  char *ptr ;
  char const   *subst ;
  unsigned char ch ;
  unsigned char msr ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 239
  if ((int )latin1[128] != 255) {
    {
#line 240
    mktable();
    }
  }
#line 242
  if (lenptr) {
#line 242
    ilen = *lenptr;
  } else {
    {
#line 242
    tmp = strlen((char const   *)lstr);
#line 242
    ilen = (int )tmp;
    }
  }
#line 244
  olen = 0;
#line 245
  i = 0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (i < ilen)) {
#line 245
      goto while_break;
    }
#line 247
    ch = *((unsigned char *)lstr + i);
#line 248
    msr = latin1[ch];
#line 250
    if ((int )msr == 255) {
      {
#line 251
      tmp___0 = strlen(latin1_subst[(int )ch & 127]);
#line 251
      olen = (int )((size_t )olen + tmp___0);
      }
    } else {
#line 253
      olen ++;
    }
#line 245
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  tmp___1 = malloc((size_t )(olen + 1));
#line 256
  macroman___0 = (char *)tmp___1;
  }
#line 257
  if ((unsigned long )macroman___0 == (unsigned long )((char *)0)) {
#line 258
    return ((char *)0);
  }
#line 260
  ptr = macroman___0;
#line 261
  i = 0;
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 261
    if (! (i < ilen)) {
#line 261
      goto while_break___0;
    }
#line 263
    tmp___2 = lstr;
#line 263
    lstr ++;
#line 263
    ch = *((unsigned char *)tmp___2);
#line 264
    msr = latin1[ch];
#line 266
    if ((int )msr == 255) {
      {
#line 270
      subst = latin1_subst[(int )ch & 127];
#line 272
      strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)subst);
#line 273
      tmp___3 = strlen(subst);
#line 273
      ptr += tmp___3;
      }
    } else {
#line 276
      tmp___4 = ptr;
#line 276
      ptr ++;
#line 276
      *tmp___4 = (char )msr;
    }
#line 261
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 279
  *ptr = (char)0;
#line 281
  if (lenptr) {
#line 282
    *lenptr = olen;
  }
#line 284
  return (macroman___0);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hrename.h"
int hrename_main(int argc , char **argv ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hrename.c"
static int do_rename(hfsvol *vol , int argc , char **argv , char const   *dest ) 
{ 
  hfsdirent ent ;
  int i ;
  int result ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 43
  result = 0;
#line 45
  if (argc > 1) {
    {
#line 45
    tmp___0 = hfs_stat(vol, dest, & ent);
    }
#line 45
    if (tmp___0 == -1) {
      {
#line 48
      hfs_error = (char const   *)0;
#line 48
      tmp = __errno_location();
#line 48
      *tmp = 20;
#line 49
      hfsutil_perrorp(dest);
      }
#line 51
      return (1);
    } else
#line 45
    if (! (ent.flags & 1)) {
      {
#line 48
      hfs_error = (char const   *)0;
#line 48
      tmp = __errno_location();
#line 48
      *tmp = 20;
#line 49
      hfsutil_perrorp(dest);
      }
#line 51
      return (1);
    }
  }
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < argc)) {
#line 54
      goto while_break;
    }
    {
#line 56
    tmp___1 = hfs_rename(vol, (char const   *)*(argv + i), dest);
    }
#line 56
    if (tmp___1 == -1) {
      {
#line 58
      hfsutil_perrorp((char const   *)*(argv + i));
#line 59
      result = 1;
      }
    }
#line 54
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (result);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hrename.c"
int hrename_main(int argc , char **argv ) 
{ 
  mountent *ment ;
  hfsvol *vol ;
  int fargc ;
  char **fargv ;
  int result ;
  char *path ;
  int tmp ;

  {
#line 76
  result = 0;
#line 78
  if (argc < 3) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s hfs-src-path [...] hfs-target-path\n",
            argv0);
    }
#line 81
    return (1);
  }
  {
#line 84
  ment = hcwd_getvol(-1);
#line 84
  vol = hfsutil_remount(ment, 2);
  }
#line 85
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 86
    return (1);
  }
  {
#line 88
  fargv = hfsutil_glob(vol, argc - 2, argv + 1, & fargc, & result);
  }
#line 90
  if (result == 0) {
    {
#line 91
    result = do_rename(vol, fargc, fargv, (char const   *)*(argv + (argc - 1)));
    }
  }
#line 93
  if (result == 0) {
    {
#line 97
    path = hfsutil_getcwd(vol);
    }
#line 98
    if ((unsigned long )path == (unsigned long )((char *)0)) {
      {
#line 100
      hfsutil_perror("Can\'t get current HFS directory path");
#line 101
      result = 1;
      }
    } else {
      {
#line 103
      tmp = hcwd_setcwd(ment, (char const   *)path);
      }
#line 103
      if (tmp == -1) {
        {
#line 105
        perror("Can\'t set current HFS directory");
#line 106
        result = 1;
        }
      }
    }
#line 109
    if (path) {
      {
#line 110
      free((void *)path);
      }
    }
  }
  {
#line 113
  hfsutil_unmount(vol, & result);
  }
#line 115
  if (fargv) {
    {
#line 116
    free((void *)fargv);
    }
  }
#line 118
  return (result);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hrmdir.h"
int hrmdir_main(int argc , char **argv ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hrmdir.c"
int hrmdir_main(int argc , char **argv ) 
{ 
  hfsvol *vol ;
  char **fargv ;
  int fargc ;
  int i ;
  int result ;
  mountent *tmp ;
  int tmp___0 ;

  {
#line 42
  result = 0;
#line 44
  if (argc < 2) {
    {
#line 46
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s hfs-path [...]\n",
            argv0);
    }
#line 47
    return (1);
  }
  {
#line 50
  tmp = hcwd_getvol(-1);
#line 50
  vol = hfsutil_remount(tmp, 2);
  }
#line 51
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 52
    return (1);
  }
  {
#line 54
  fargv = hfsutil_glob(vol, argc - 1, argv + 1, & fargc, & result);
  }
#line 56
  if (result == 0) {
#line 58
    i = 0;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! (i < fargc)) {
#line 58
        goto while_break;
      }
      {
#line 60
      tmp___0 = hfs_rmdir(vol, (char const   *)*(fargv + i));
      }
#line 60
      if (tmp___0 == -1) {
        {
#line 62
        hfsutil_perrorp((char const   *)*(fargv + i));
#line 63
        result = 1;
        }
      }
#line 58
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 68
  hfsutil_unmount(vol, & result);
  }
#line 70
  if (fargv) {
    {
#line 71
    free((void *)fargv);
    }
  }
#line 73
  return (result);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.h"
void d_putsl(unsigned char *ptr , long data ) ;
#line 38
void d_fetchsb(unsigned char const   **ptr , signed char *dest ) ;
#line 40
void d_fetchsw(unsigned char const   **ptr , short *dest ) ;
#line 41
void d_fetchuw(unsigned char const   **ptr , unsigned short *dest ) ;
#line 42
void d_fetchsl(unsigned char const   **ptr , long *dest ) ;
#line 43
void d_fetchul(unsigned char const   **ptr , unsigned long *dest ) ;
#line 45
void d_storesb(unsigned char **ptr , signed char data ) ;
#line 47
void d_storesw(unsigned char **ptr , short data ) ;
#line 48
void d_storeuw(unsigned char **ptr , unsigned short data ) ;
#line 49
void d_storesl(unsigned char **ptr , long data ) ;
#line 50
void d_storeul(unsigned char **ptr , unsigned long data ) ;
#line 52
void d_fetchstr(unsigned char const   **ptr , char *dest , unsigned int size ) ;
#line 53
void d_storestr(unsigned char **ptr , char const   *src , unsigned int size ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_packcatkey(CatKeyRec const   *key , byte *pkey , unsigned int *len ) 
{ 
  byte const   *start ;

  {
  {
#line 38
  start = (byte const   *)pkey;
#line 40
  d_storesb(& pkey, (signed char )key->ckrKeyLen);
#line 41
  d_storesb(& pkey, (signed char )key->ckrResrv1);
#line 42
  d_storeul(& pkey, (unsigned long )key->ckrParID);
#line 44
  d_storestr(& pkey, (char const   *)(key->ckrCName), (unsigned int )sizeof(key->ckrCName));
  }
#line 46
  if (len) {
#line 47
    *len = (unsigned int )((size_t )(((1 + (int )*start) + 1) & -2));
  }
#line 48
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_unpackcatkey(byte const   *pkey , CatKeyRec *key ) 
{ 


  {
  {
#line 56
  d_fetchsb(& pkey, & key->ckrKeyLen);
#line 57
  d_fetchsb(& pkey, & key->ckrResrv1);
#line 58
  d_fetchul(& pkey, & key->ckrParID);
#line 60
  d_fetchstr(& pkey, key->ckrCName, (unsigned int )sizeof(key->ckrCName));
  }
#line 61
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_packextkey(ExtKeyRec const   *key , byte *pkey , unsigned int *len ) 
{ 
  byte const   *start ;

  {
  {
#line 69
  start = (byte const   *)pkey;
#line 71
  d_storesb(& pkey, (signed char )key->xkrKeyLen);
#line 72
  d_storesb(& pkey, (signed char )key->xkrFkType);
#line 73
  d_storeul(& pkey, (unsigned long )key->xkrFNum);
#line 74
  d_storeuw(& pkey, (unsigned short )key->xkrFABN);
  }
#line 76
  if (len) {
#line 77
    *len = (unsigned int )((size_t )(((1 + (int )*start) + 1) & -2));
  }
#line 78
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_unpackextkey(byte const   *pkey , ExtKeyRec *key ) 
{ 


  {
  {
#line 86
  d_fetchsb(& pkey, & key->xkrKeyLen);
#line 87
  d_fetchsb(& pkey, & key->xkrFkType);
#line 88
  d_fetchul(& pkey, & key->xkrFNum);
#line 89
  d_fetchuw(& pkey, & key->xkrFABN);
  }
#line 90
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
int r_comparecatkeys(CatKeyRec const   *key1 , CatKeyRec const   *key2 ) 
{ 
  int diff ;
  int tmp ;

  {
#line 100
  diff = (int )(key1->ckrParID - key2->ckrParID);
#line 101
  if (diff) {
#line 102
    return (diff);
  }
  {
#line 104
  tmp = d_relstring((char const   *)(key1->ckrCName), (char const   *)(key2->ckrCName));
  }
#line 104
  return (tmp);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
int r_compareextkeys(ExtKeyRec const   *key1 , ExtKeyRec const   *key2 ) 
{ 
  int diff ;

  {
#line 115
  diff = (int )(key1->xkrFNum - key2->xkrFNum);
#line 116
  if (diff) {
#line 117
    return (diff);
  }
#line 119
  diff = (int )((unsigned char )key1->xkrFkType) - (int )((unsigned char )key2->xkrFkType);
#line 121
  if (diff) {
#line 122
    return (diff);
  }
#line 124
  return ((int )((int const   )key1->xkrFABN - (int const   )key2->xkrFABN));
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_packcatdata(CatDataRec const   *data , byte *pdata , unsigned int *len ) 
{ 
  byte const   *start ;
  int i ;

  {
  {
#line 133
  start = (byte const   *)pdata;
#line 136
  d_storesb(& pdata, (signed char )data->cdrType);
#line 137
  d_storesb(& pdata, (signed char )data->cdrResrv2);
  }
  {
#line 141
  if ((int const   )data->cdrType == 1) {
#line 141
    goto case_1;
  }
#line 170
  if ((int const   )data->cdrType == 2) {
#line 170
    goto case_2;
  }
#line 219
  if ((int const   )data->cdrType == 3) {
#line 219
    goto case_3;
  }
#line 230
  if ((int const   )data->cdrType == 4) {
#line 230
    goto case_4;
  }
#line 241
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 142
  d_storesw(& pdata, (short )data->u.dir.dirFlags);
#line 143
  d_storeuw(& pdata, (unsigned short )data->u.dir.dirVal);
#line 144
  d_storeul(& pdata, (unsigned long )data->u.dir.dirDirID);
#line 145
  d_storesl(& pdata, (long )data->u.dir.dirCrDat);
#line 146
  d_storesl(& pdata, (long )data->u.dir.dirMdDat);
#line 147
  d_storesl(& pdata, (long )data->u.dir.dirBkDat);
#line 149
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frRect.top);
#line 150
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frRect.left);
#line 151
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frRect.bottom);
#line 152
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frRect.right);
#line 153
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frFlags);
#line 154
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frLocation.v);
#line 155
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frLocation.h);
#line 156
  d_storesw(& pdata, (short )data->u.dir.dirUsrInfo.frView);
#line 158
  d_storesw(& pdata, (short )data->u.dir.dirFndrInfo.frScroll.v);
#line 159
  d_storesw(& pdata, (short )data->u.dir.dirFndrInfo.frScroll.h);
#line 160
  d_storesl(& pdata, (long )data->u.dir.dirFndrInfo.frOpenChain);
#line 161
  d_storesw(& pdata, (short )data->u.dir.dirFndrInfo.frUnused);
#line 162
  d_storesw(& pdata, (short )data->u.dir.dirFndrInfo.frComment);
#line 163
  d_storesl(& pdata, (long )data->u.dir.dirFndrInfo.frPutAway);
#line 165
  i = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < 4)) {
#line 165
      goto while_break;
    }
    {
#line 166
    d_storesl(& pdata, data->u.dir.dirResrv[i]);
#line 165
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 171
  d_storesb(& pdata, (signed char )data->u.fil.filFlags);
#line 172
  d_storesb(& pdata, (signed char )data->u.fil.filTyp);
#line 174
  d_storesl(& pdata, (long )data->u.fil.filUsrWds.fdType);
#line 175
  d_storesl(& pdata, (long )data->u.fil.filUsrWds.fdCreator);
#line 176
  d_storesw(& pdata, (short )data->u.fil.filUsrWds.fdFlags);
#line 177
  d_storesw(& pdata, (short )data->u.fil.filUsrWds.fdLocation.v);
#line 178
  d_storesw(& pdata, (short )data->u.fil.filUsrWds.fdLocation.h);
#line 179
  d_storesw(& pdata, (short )data->u.fil.filUsrWds.fdFldr);
#line 181
  d_storeul(& pdata, (unsigned long )data->u.fil.filFlNum);
#line 183
  d_storeuw(& pdata, (unsigned short )data->u.fil.filStBlk);
#line 184
  d_storeul(& pdata, (unsigned long )data->u.fil.filLgLen);
#line 185
  d_storeul(& pdata, (unsigned long )data->u.fil.filPyLen);
#line 187
  d_storeuw(& pdata, (unsigned short )data->u.fil.filRStBlk);
#line 188
  d_storeul(& pdata, (unsigned long )data->u.fil.filRLgLen);
#line 189
  d_storeul(& pdata, (unsigned long )data->u.fil.filRPyLen);
#line 191
  d_storesl(& pdata, (long )data->u.fil.filCrDat);
#line 192
  d_storesl(& pdata, (long )data->u.fil.filMdDat);
#line 193
  d_storesl(& pdata, (long )data->u.fil.filBkDat);
#line 195
  d_storesw(& pdata, (short )data->u.fil.filFndrInfo.fdIconID);
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 196
    if (! (i < 4)) {
#line 196
      goto while_break___0;
    }
    {
#line 197
    d_storesw(& pdata, data->u.fil.filFndrInfo.fdUnused[i]);
#line 196
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 198
  d_storesw(& pdata, (short )data->u.fil.filFndrInfo.fdComment);
#line 199
  d_storesl(& pdata, (long )data->u.fil.filFndrInfo.fdPutAway);
#line 201
  d_storeuw(& pdata, (unsigned short )data->u.fil.filClpSize);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 203
    if (! (i < 3)) {
#line 203
      goto while_break___1;
    }
    {
#line 205
    d_storeuw(& pdata, (unsigned short )data->u.fil.filExtRec[i].xdrStABN);
#line 206
    d_storeuw(& pdata, (unsigned short )data->u.fil.filExtRec[i].xdrNumABlks);
#line 203
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 209
    if (! (i < 3)) {
#line 209
      goto while_break___2;
    }
    {
#line 211
    d_storeuw(& pdata, (unsigned short )data->u.fil.filRExtRec[i].xdrStABN);
#line 212
    d_storeuw(& pdata, (unsigned short )data->u.fil.filRExtRec[i].xdrNumABlks);
#line 209
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 215
  d_storesl(& pdata, (long )data->u.fil.filResrv);
  }
#line 217
  goto switch_break;
  case_3: /* CIL Label */ 
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 220
    if (! (i < 2)) {
#line 220
      goto while_break___3;
    }
    {
#line 221
    d_storesl(& pdata, data->u.dthd.thdResrv[i]);
#line 220
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 223
  d_storeul(& pdata, (unsigned long )data->u.dthd.thdParID);
#line 225
  d_storestr(& pdata, (char const   *)(data->u.dthd.thdCName), (unsigned int )sizeof(data->u.dthd.thdCName));
  }
#line 228
  goto switch_break;
  case_4: /* CIL Label */ 
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 231
    if (! (i < 2)) {
#line 231
      goto while_break___4;
    }
    {
#line 232
    d_storesl(& pdata, data->u.fthd.fthdResrv[i]);
#line 231
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 234
  d_storeul(& pdata, (unsigned long )data->u.fthd.fthdParID);
#line 236
  d_storestr(& pdata, (char const   *)(data->u.fthd.fthdCName), (unsigned int )sizeof(data->u.fthd.fthdCName));
  }
#line 239
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 245
  if (len) {
#line 246
    *len = (unsigned int )((long )*len + (pdata - (byte *)start));
  }
#line 247
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_unpackcatdata(byte const   *pdata , CatDataRec *data ) 
{ 
  int i ;

  {
  {
#line 257
  d_fetchsb(& pdata, & data->cdrType);
#line 258
  d_fetchsb(& pdata, & data->cdrResrv2);
  }
  {
#line 262
  if ((int )data->cdrType == 1) {
#line 262
    goto case_1;
  }
#line 291
  if ((int )data->cdrType == 2) {
#line 291
    goto case_2;
  }
#line 340
  if ((int )data->cdrType == 3) {
#line 340
    goto case_3;
  }
#line 351
  if ((int )data->cdrType == 4) {
#line 351
    goto case_4;
  }
#line 362
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 263
  d_fetchsw(& pdata, & data->u.dir.dirFlags);
#line 264
  d_fetchuw(& pdata, & data->u.dir.dirVal);
#line 265
  d_fetchul(& pdata, & data->u.dir.dirDirID);
#line 266
  d_fetchsl(& pdata, & data->u.dir.dirCrDat);
#line 267
  d_fetchsl(& pdata, & data->u.dir.dirMdDat);
#line 268
  d_fetchsl(& pdata, & data->u.dir.dirBkDat);
#line 270
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frRect.top);
#line 271
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frRect.left);
#line 272
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frRect.bottom);
#line 273
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frRect.right);
#line 274
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frFlags);
#line 275
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frLocation.v);
#line 276
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frLocation.h);
#line 277
  d_fetchsw(& pdata, & data->u.dir.dirUsrInfo.frView);
#line 279
  d_fetchsw(& pdata, & data->u.dir.dirFndrInfo.frScroll.v);
#line 280
  d_fetchsw(& pdata, & data->u.dir.dirFndrInfo.frScroll.h);
#line 281
  d_fetchsl(& pdata, & data->u.dir.dirFndrInfo.frOpenChain);
#line 282
  d_fetchsw(& pdata, & data->u.dir.dirFndrInfo.frUnused);
#line 283
  d_fetchsw(& pdata, & data->u.dir.dirFndrInfo.frComment);
#line 284
  d_fetchsl(& pdata, & data->u.dir.dirFndrInfo.frPutAway);
#line 286
  i = 0;
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (i < 4)) {
#line 286
      goto while_break;
    }
    {
#line 287
    d_fetchsl(& pdata, & data->u.dir.dirResrv[i]);
#line 286
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 292
  d_fetchsb(& pdata, & data->u.fil.filFlags);
#line 293
  d_fetchsb(& pdata, & data->u.fil.filTyp);
#line 295
  d_fetchsl(& pdata, & data->u.fil.filUsrWds.fdType);
#line 296
  d_fetchsl(& pdata, & data->u.fil.filUsrWds.fdCreator);
#line 297
  d_fetchsw(& pdata, & data->u.fil.filUsrWds.fdFlags);
#line 298
  d_fetchsw(& pdata, & data->u.fil.filUsrWds.fdLocation.v);
#line 299
  d_fetchsw(& pdata, & data->u.fil.filUsrWds.fdLocation.h);
#line 300
  d_fetchsw(& pdata, & data->u.fil.filUsrWds.fdFldr);
#line 302
  d_fetchul(& pdata, & data->u.fil.filFlNum);
#line 304
  d_fetchuw(& pdata, & data->u.fil.filStBlk);
#line 305
  d_fetchul(& pdata, & data->u.fil.filLgLen);
#line 306
  d_fetchul(& pdata, & data->u.fil.filPyLen);
#line 308
  d_fetchuw(& pdata, & data->u.fil.filRStBlk);
#line 309
  d_fetchul(& pdata, & data->u.fil.filRLgLen);
#line 310
  d_fetchul(& pdata, & data->u.fil.filRPyLen);
#line 312
  d_fetchsl(& pdata, & data->u.fil.filCrDat);
#line 313
  d_fetchsl(& pdata, & data->u.fil.filMdDat);
#line 314
  d_fetchsl(& pdata, & data->u.fil.filBkDat);
#line 316
  d_fetchsw(& pdata, & data->u.fil.filFndrInfo.fdIconID);
#line 317
  i = 0;
  }
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (i < 4)) {
#line 317
      goto while_break___0;
    }
    {
#line 318
    d_fetchsw(& pdata, & data->u.fil.filFndrInfo.fdUnused[i]);
#line 317
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 319
  d_fetchsw(& pdata, & data->u.fil.filFndrInfo.fdComment);
#line 320
  d_fetchsl(& pdata, & data->u.fil.filFndrInfo.fdPutAway);
#line 322
  d_fetchuw(& pdata, & data->u.fil.filClpSize);
#line 324
  i = 0;
  }
  {
#line 324
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 324
    if (! (i < 3)) {
#line 324
      goto while_break___1;
    }
    {
#line 326
    d_fetchuw(& pdata, & data->u.fil.filExtRec[i].xdrStABN);
#line 327
    d_fetchuw(& pdata, & data->u.fil.filExtRec[i].xdrNumABlks);
#line 324
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  i = 0;
  {
#line 330
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 330
    if (! (i < 3)) {
#line 330
      goto while_break___2;
    }
    {
#line 332
    d_fetchuw(& pdata, & data->u.fil.filRExtRec[i].xdrStABN);
#line 333
    d_fetchuw(& pdata, & data->u.fil.filRExtRec[i].xdrNumABlks);
#line 330
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 336
  d_fetchsl(& pdata, & data->u.fil.filResrv);
  }
#line 338
  goto switch_break;
  case_3: /* CIL Label */ 
#line 341
  i = 0;
  {
#line 341
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 341
    if (! (i < 2)) {
#line 341
      goto while_break___3;
    }
    {
#line 342
    d_fetchsl(& pdata, & data->u.dthd.thdResrv[i]);
#line 341
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 344
  d_fetchul(& pdata, & data->u.dthd.thdParID);
#line 346
  d_fetchstr(& pdata, data->u.dthd.thdCName, (unsigned int )sizeof(data->u.dthd.thdCName));
  }
#line 349
  goto switch_break;
  case_4: /* CIL Label */ 
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 352
    if (! (i < 2)) {
#line 352
      goto while_break___4;
    }
    {
#line 353
    d_fetchsl(& pdata, & data->u.fthd.fthdResrv[i]);
#line 352
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 355
  d_fetchul(& pdata, & data->u.fthd.fthdParID);
#line 357
  d_fetchstr(& pdata, data->u.fthd.fthdCName, (unsigned int )sizeof(data->u.fthd.fthdCName));
  }
#line 360
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 365
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_packextdata(ExtDataRec const   *data , byte *pdata , unsigned int *len ) 
{ 
  byte const   *start ;
  int i ;

  {
#line 373
  start = (byte const   *)pdata;
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < 3)) {
#line 376
      goto while_break;
    }
    {
#line 378
    d_storeuw(& pdata, (unsigned short )(*data)[i].xdrStABN);
#line 379
    d_storeuw(& pdata, (unsigned short )(*data)[i].xdrNumABlks);
#line 376
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  if (len) {
#line 383
    *len = (unsigned int )((long )*len + (pdata - (byte *)start));
  }
#line 384
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_unpackextdata(byte const   *pdata , ExtDataRec *data ) 
{ 
  int i ;

  {
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < 3)) {
#line 394
      goto while_break;
    }
    {
#line 396
    d_fetchuw(& pdata, & (*data)[i].xdrStABN);
#line 397
    d_fetchuw(& pdata, & (*data)[i].xdrNumABlks);
#line 394
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_makecatkey(CatKeyRec *key , unsigned long parid , char const   *name___1 ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 409
  tmp = strlen(name___1);
#line 409
  len = (int )(tmp + 1UL);
#line 411
  key->ckrKeyLen = (SignedByte )((5 + len) + (len & 1));
#line 412
  key->ckrResrv1 = (SignedByte )0;
#line 413
  key->ckrParID = parid;
#line 415
  strcpy((char */* __restrict  */)(key->ckrCName), (char const   */* __restrict  */)name___1);
  }
#line 416
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_makeextkey(ExtKeyRec *key , int fork , unsigned long fnum , unsigned int fabn ) 
{ 


  {
#line 425
  key->xkrKeyLen = (SignedByte )7;
#line 426
  key->xkrFkType = (SignedByte )fork;
#line 427
  key->xkrFNum = fnum;
#line 428
  key->xkrFABN = (UInteger )fabn;
#line 429
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_packcatrec(CatKeyRec const   *key , CatDataRec const   *data , byte *precord ,
                  unsigned int *len ) 
{ 


  {
  {
#line 438
  r_packcatkey(key, precord, len);
#line 439
  r_packcatdata(data, precord + (size_t )(((1 + (int )*((byte const   *)precord)) + 1) & -2),
                len);
  }
#line 440
  return;
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_packextrec(ExtKeyRec const   *key , ExtDataRec const   *data , byte *precord ,
                  unsigned int *len ) 
{ 


  {
  {
#line 449
  r_packextkey(key, precord, len);
#line 450
  r_packextdata(data, precord + (size_t )(((1 + (int )*((byte const   *)precord)) + 1) & -2),
                len);
  }
#line 451
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_packdirent(CatDataRec *data , hfsdirent const   *ent ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  {
#line 461
  if ((int )data->cdrType == 1) {
#line 461
    goto case_1;
  }
#line 477
  if ((int )data->cdrType == 2) {
#line 477
    goto case_2;
  }
#line 459
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 462
  tmp = d_mtime((time_t )ent->crdate);
#line 462
  data->u.dir.dirCrDat = (LongInt )tmp;
#line 463
  tmp___0 = d_mtime((time_t )ent->mddate);
#line 463
  data->u.dir.dirMdDat = (LongInt )tmp___0;
#line 464
  tmp___1 = d_mtime((time_t )ent->bkdate);
#line 464
  data->u.dir.dirBkDat = (LongInt )tmp___1;
#line 466
  data->u.dir.dirUsrInfo.frFlags = (Integer )ent->fdflags;
#line 467
  data->u.dir.dirUsrInfo.frLocation.v = (Integer )ent->fdlocation.v;
#line 468
  data->u.dir.dirUsrInfo.frLocation.h = (Integer )ent->fdlocation.h;
#line 470
  data->u.dir.dirUsrInfo.frRect.top = (Integer )ent->u.dir.rect.top;
#line 471
  data->u.dir.dirUsrInfo.frRect.left = (Integer )ent->u.dir.rect.left;
#line 472
  data->u.dir.dirUsrInfo.frRect.bottom = (Integer )ent->u.dir.rect.bottom;
#line 473
  data->u.dir.dirUsrInfo.frRect.right = (Integer )ent->u.dir.rect.right;
  }
#line 475
  goto switch_break;
  case_2: /* CIL Label */ 
#line 478
  if (ent->flags & 2) {
#line 479
    data->u.fil.filFlags = (SignedByte )((int )data->u.fil.filFlags | 1);
  } else {
#line 481
    data->u.fil.filFlags = (SignedByte )((int )data->u.fil.filFlags & -2);
  }
  {
#line 483
  tmp___2 = d_mtime((time_t )ent->crdate);
#line 483
  data->u.fil.filCrDat = (LongInt )tmp___2;
#line 484
  tmp___3 = d_mtime((time_t )ent->mddate);
#line 484
  data->u.fil.filMdDat = (LongInt )tmp___3;
#line 485
  tmp___4 = d_mtime((time_t )ent->bkdate);
#line 485
  data->u.fil.filBkDat = (LongInt )tmp___4;
#line 487
  data->u.fil.filUsrWds.fdFlags = (Integer )ent->fdflags;
#line 488
  data->u.fil.filUsrWds.fdLocation.v = (Integer )ent->fdlocation.v;
#line 489
  data->u.fil.filUsrWds.fdLocation.h = (Integer )ent->fdlocation.h;
#line 491
  data->u.fil.filUsrWds.fdType = d_getsl((unsigned char const   *)(ent->u.file.type));
#line 493
  data->u.fil.filUsrWds.fdCreator = d_getsl((unsigned char const   *)(ent->u.file.creator));
  }
#line 496
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 498
  return;
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/record.c"
void r_unpackdirent(unsigned long parid , char const   *name___1 , CatDataRec const   *data ,
                    hfsdirent *ent ) 
{ 
  char tmp ;

  {
  {
#line 507
  strcpy((char */* __restrict  */)(ent->name), (char const   */* __restrict  */)name___1);
#line 508
  ent->parid = parid;
  }
  {
#line 512
  if ((int const   )data->cdrType == 1) {
#line 512
    goto case_1;
  }
#line 533
  if ((int const   )data->cdrType == 2) {
#line 533
    goto case_2;
  }
#line 510
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 513
  ent->flags = 1;
#line 514
  ent->cnid = (unsigned long )data->u.dir.dirDirID;
#line 516
  ent->crdate = d_ltime((unsigned long )data->u.dir.dirCrDat);
#line 517
  ent->mddate = d_ltime((unsigned long )data->u.dir.dirMdDat);
#line 518
  ent->bkdate = d_ltime((unsigned long )data->u.dir.dirBkDat);
#line 520
  ent->fdflags = (short )data->u.dir.dirUsrInfo.frFlags;
#line 521
  ent->fdlocation.v = (short )data->u.dir.dirUsrInfo.frLocation.v;
#line 522
  ent->fdlocation.h = (short )data->u.dir.dirUsrInfo.frLocation.h;
#line 524
  ent->u.dir.valence = (unsigned short )data->u.dir.dirVal;
#line 526
  ent->u.dir.rect.top = (short )data->u.dir.dirUsrInfo.frRect.top;
#line 527
  ent->u.dir.rect.left = (short )data->u.dir.dirUsrInfo.frRect.left;
#line 528
  ent->u.dir.rect.bottom = (short )data->u.dir.dirUsrInfo.frRect.bottom;
#line 529
  ent->u.dir.rect.right = (short )data->u.dir.dirUsrInfo.frRect.right;
  }
#line 531
  goto switch_break;
  case_2: /* CIL Label */ 
#line 534
  if ((int const   )data->u.fil.filFlags & 1) {
#line 534
    ent->flags = 2;
  } else {
#line 534
    ent->flags = 0;
  }
  {
#line 535
  ent->cnid = (unsigned long )data->u.fil.filFlNum;
#line 537
  ent->crdate = d_ltime((unsigned long )data->u.fil.filCrDat);
#line 538
  ent->mddate = d_ltime((unsigned long )data->u.fil.filMdDat);
#line 539
  ent->bkdate = d_ltime((unsigned long )data->u.fil.filBkDat);
#line 541
  ent->fdflags = (short )data->u.fil.filUsrWds.fdFlags;
#line 542
  ent->fdlocation.v = (short )data->u.fil.filUsrWds.fdLocation.v;
#line 543
  ent->fdlocation.h = (short )data->u.fil.filUsrWds.fdLocation.h;
#line 545
  ent->u.file.dsize = (unsigned long )data->u.fil.filLgLen;
#line 546
  ent->u.file.rsize = (unsigned long )data->u.fil.filRLgLen;
#line 548
  d_putsl((unsigned char *)(ent->u.file.type), (long )data->u.fil.filUsrWds.fdType);
#line 550
  d_putsl((unsigned char *)(ent->u.file.creator), (long )data->u.fil.filUsrWds.fdCreator);
#line 553
  tmp = (char)0;
#line 553
  ent->u.file.creator[4] = tmp;
#line 553
  ent->u.file.type[4] = tmp;
  }
#line 555
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 26 "libhfs/data.h"
short d_getsw(unsigned char const   *ptr ) ;
#line 27
unsigned short d_getuw(unsigned char const   *ptr ) ;
#line 29
unsigned long d_getul(unsigned char const   *ptr ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.h"
char const   *cpi_error ;
#line 26
int cpi_macb(char const   *srcname , hfsvol *vol , char const   *dstname ) ;
#line 27
int cpi_binh(char const   *srcname , hfsvol *vol , char const   *dstname ) ;
#line 28
int cpi_text(char const   *srcname , hfsvol *vol , char const   *dstname ) ;
#line 29
int cpi_raw(char const   *srcname , hfsvol *vol , char const   *dstname ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
char const   *cpi_error  =    "no error";
#line 67 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int fork_macb(int ifile , hfsfile *ofile , unsigned long size ) 
{ 
  char buf[2048] ;
  unsigned long chunk ;
  unsigned long bytes ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! size) {
#line 73
      goto while_break;
    }
#line 75
    if (size < sizeof(buf)) {
#line 75
      chunk = (size + 127UL) & 0xffffffffffffff80UL;
    } else {
#line 75
      chunk = sizeof(buf);
    }
    {
#line 78
    tmp = read(ifile, (void *)(buf), chunk);
#line 78
    bytes = (unsigned long )tmp;
    }
#line 79
    if (bytes == 0xffffffffffffffffUL) {
      {
#line 81
      cpi_error = "error reading data";
#line 81
      tmp___0 = __errno_location();
#line 81
      tmp___1 = __errno_location();
#line 81
      *tmp___0 = *tmp___1;
      }
#line 82
      return (-1);
    } else
#line 84
    if (bytes != chunk) {
      {
#line 86
      cpi_error = "read incomplete chunk";
#line 86
      tmp___2 = __errno_location();
#line 86
      *tmp___2 = 5;
      }
#line 87
      return (-1);
    }
#line 90
    if (size > bytes) {
#line 90
      chunk = bytes;
    } else {
#line 90
      chunk = size;
    }
    {
#line 92
    bytes = hfs_write(ofile, (void const   *)(buf), chunk);
    }
#line 93
    if (bytes == 0xffffffffffffffffUL) {
      {
#line 95
      cpi_error = hfs_error;
#line 95
      tmp___3 = __errno_location();
#line 95
      tmp___4 = __errno_location();
#line 95
      *tmp___3 = *tmp___4;
      }
#line 96
      return (-1);
    } else
#line 98
    if (bytes != chunk) {
      {
#line 100
      cpi_error = "wrote incomplete chunk";
#line 100
      tmp___5 = __errno_location();
#line 100
      *tmp___5 = 5;
      }
#line 101
      return (-1);
    }
#line 104
    size -= chunk;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (0);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int do_macb(int ifile , hfsfile *ofile , unsigned long dsize , unsigned long rsize ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 118
  tmp___1 = hfs_setfork(ofile, 0);
  }
#line 118
  if (tmp___1 == -1) {
    {
#line 120
    cpi_error = hfs_error;
#line 120
    tmp = __errno_location();
#line 120
    tmp___0 = __errno_location();
#line 120
    *tmp = *tmp___0;
    }
#line 121
    return (-1);
  }
  {
#line 124
  tmp___2 = fork_macb(ifile, ofile, dsize);
  }
#line 124
  if (tmp___2 == -1) {
#line 125
    return (-1);
  }
  {
#line 127
  tmp___5 = hfs_setfork(ofile, 1);
  }
#line 127
  if (tmp___5 == -1) {
    {
#line 129
    cpi_error = hfs_error;
#line 129
    tmp___3 = __errno_location();
#line 129
    tmp___4 = __errno_location();
#line 129
    *tmp___3 = *tmp___4;
    }
#line 130
    return (-1);
  }
  {
#line 133
  tmp___6 = fork_macb(ifile, ofile, rsize);
  }
#line 133
  if (tmp___6 == -1) {
#line 134
    return (-1);
  }
#line 136
  return (0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int fork_binh(hfsfile *ofile , unsigned long size ) 
{ 
  char buf[2048] ;
  long chunk ;
  long bytes ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  unsigned long tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! size) {
#line 149
      goto while_break;
    }
#line 151
    if (size > sizeof(buf)) {
#line 151
      chunk = (long )sizeof(buf);
    } else {
#line 151
      chunk = (long )size;
    }
    {
#line 153
    tmp = bh_read((void *)(buf), (int )chunk);
#line 153
    bytes = (long )tmp;
    }
#line 154
    if (bytes == -1L) {
      {
#line 156
      cpi_error = bh_error;
#line 156
      tmp___0 = __errno_location();
#line 156
      tmp___1 = __errno_location();
#line 156
      *tmp___0 = *tmp___1;
      }
#line 157
      return (-1);
    } else
#line 159
    if (bytes != chunk) {
      {
#line 161
      cpi_error = "read incomplete chunk";
#line 161
      tmp___2 = __errno_location();
#line 161
      *tmp___2 = 5;
      }
#line 162
      return (-1);
    }
    {
#line 165
    tmp___3 = hfs_write(ofile, (void const   *)(buf), (unsigned long )chunk);
#line 165
    bytes = (long )tmp___3;
    }
#line 166
    if (bytes == -1L) {
      {
#line 168
      cpi_error = hfs_error;
#line 168
      tmp___4 = __errno_location();
#line 168
      tmp___5 = __errno_location();
#line 168
      *tmp___4 = *tmp___5;
      }
#line 169
      return (-1);
    } else
#line 171
    if (bytes != chunk) {
      {
#line 173
      cpi_error = "wrote incomplete chunk";
#line 173
      tmp___6 = __errno_location();
#line 173
      *tmp___6 = 5;
      }
#line 174
      return (-1);
    }
#line 177
    size -= (unsigned long )chunk;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  tmp___9 = bh_readcrc();
  }
#line 180
  if (tmp___9 == -1) {
    {
#line 182
    cpi_error = bh_error;
#line 182
    tmp___7 = __errno_location();
#line 182
    tmp___8 = __errno_location();
#line 182
    *tmp___7 = *tmp___8;
    }
#line 183
    return (-1);
  }
#line 186
  return (0);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int do_binh(hfsfile *ofile , unsigned long dsize , unsigned long rsize ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 196
  tmp___1 = hfs_setfork(ofile, 0);
  }
#line 196
  if (tmp___1 == -1) {
    {
#line 198
    cpi_error = hfs_error;
#line 198
    tmp = __errno_location();
#line 198
    tmp___0 = __errno_location();
#line 198
    *tmp = *tmp___0;
    }
#line 199
    return (-1);
  }
  {
#line 202
  tmp___2 = fork_binh(ofile, dsize);
  }
#line 202
  if (tmp___2 == -1) {
#line 203
    return (-1);
  }
  {
#line 205
  tmp___5 = hfs_setfork(ofile, 1);
  }
#line 205
  if (tmp___5 == -1) {
    {
#line 207
    cpi_error = hfs_error;
#line 207
    tmp___3 = __errno_location();
#line 207
    tmp___4 = __errno_location();
#line 207
    *tmp___3 = *tmp___4;
    }
#line 208
    return (-1);
  }
  {
#line 211
  tmp___6 = fork_binh(ofile, rsize);
  }
#line 211
  if (tmp___6 == -1) {
#line 212
    return (-1);
  }
#line 214
  return (0);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int do_text(int ifile , hfsfile *ofile ) 
{ 
  char buf[2048] ;
  char *ptr ;
  long chunk ;
  long bytes ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  unsigned long tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    chunk = read(ifile, (void *)(buf), sizeof(buf));
    }
#line 231
    if (chunk == -1L) {
      {
#line 233
      cpi_error = "error reading source file";
#line 233
      tmp = __errno_location();
#line 233
      tmp___0 = __errno_location();
#line 233
      *tmp = *tmp___0;
      }
#line 234
      return (-1);
    } else
#line 236
    if (chunk == 0L) {
#line 237
      goto while_break;
    }
#line 239
    ptr = buf;
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 239
      if (! ((unsigned long )ptr < (unsigned long )(buf + chunk))) {
#line 239
        goto while_break___0;
      }
#line 241
      if ((int )*ptr == 10) {
#line 242
        *ptr = (char )'\r';
      }
#line 239
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 245
    len = (int )chunk;
#line 246
    ptr = cs_macroman(buf, & len);
    }
#line 247
    if ((unsigned long )ptr == (unsigned long )((char *)0)) {
      {
#line 249
      cpi_error = (char const   *)0;
#line 249
      tmp___1 = __errno_location();
#line 249
      *tmp___1 = 12;
      }
#line 250
      return (-1);
    }
    {
#line 253
    tmp___2 = hfs_write(ofile, (void const   *)ptr, (unsigned long )len);
#line 253
    bytes = (long )tmp___2;
#line 254
    free((void *)ptr);
    }
#line 256
    if (bytes == -1L) {
      {
#line 258
      cpi_error = hfs_error;
#line 258
      tmp___3 = __errno_location();
#line 258
      tmp___4 = __errno_location();
#line 258
      *tmp___3 = *tmp___4;
      }
#line 259
      return (-1);
    } else
#line 261
    if (bytes != (long )len) {
      {
#line 263
      cpi_error = "wrote incomplete chunk";
#line 263
      tmp___5 = __errno_location();
#line 263
      *tmp___5 = 5;
      }
#line 264
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int do_raw(int ifile , hfsfile *ofile ) 
{ 
  char buf[2048] ;
  long chunk ;
  long bytes ;
  int *tmp ;
  int *tmp___0 ;
  unsigned long tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 283
    chunk = read(ifile, (void *)(buf), sizeof(buf));
    }
#line 284
    if (chunk == -1L) {
      {
#line 286
      cpi_error = "error reading source file";
#line 286
      tmp = __errno_location();
#line 286
      tmp___0 = __errno_location();
#line 286
      *tmp = *tmp___0;
      }
#line 287
      return (-1);
    } else
#line 289
    if (chunk == 0L) {
#line 290
      goto while_break;
    }
    {
#line 292
    tmp___1 = hfs_write(ofile, (void const   *)(buf), (unsigned long )chunk);
#line 292
    bytes = (long )tmp___1;
    }
#line 293
    if (bytes == -1L) {
      {
#line 295
      cpi_error = hfs_error;
#line 295
      tmp___2 = __errno_location();
#line 295
      tmp___3 = __errno_location();
#line 295
      *tmp___2 = *tmp___3;
      }
#line 296
      return (-1);
    } else
#line 298
    if (bytes != chunk) {
      {
#line 300
      cpi_error = "wrote incomplete chunk";
#line 300
      tmp___4 = __errno_location();
#line 300
      *tmp___4 = 5;
      }
#line 301
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (0);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static char name[32]  ;
#line 314 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int opensrc(char const   *srcname , char const   **dsthint , char const   *ext ,
                   int binary ) 
{ 
  int fd ;
  int len ;
  char const   *cptr ;
  char *ptr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 323
  tmp = strcmp(srcname, "-");
  }
#line 323
  if (tmp == 0) {
    {
#line 325
    fd = dup(0);
#line 326
    srcname = "";
    }
  } else {
    {
#line 329
    fd = open(srcname, 0);
    }
  }
#line 331
  if (fd == -1) {
    {
#line 333
    cpi_error = "error opening source file";
#line 333
    tmp___0 = __errno_location();
#line 333
    tmp___1 = __errno_location();
#line 333
    *tmp___0 = *tmp___1;
    }
#line 334
    return (-1);
  }
  {
#line 337
  tmp___2 = strrchr(srcname, '/');
#line 337
  cptr = (char const   *)tmp___2;
  }
#line 338
  if ((unsigned long )cptr == (unsigned long )((char const   *)0)) {
#line 339
    cptr = srcname;
  } else {
#line 341
    cptr ++;
  }
#line 343
  if ((unsigned long )ext == (unsigned long )((char const   *)0)) {
    {
#line 344
    tmp___3 = strlen(cptr);
#line 344
    len = (int )tmp___3;
    }
  } else {
    {
#line 347
    tmp___4 = strstr(cptr, ext);
#line 347
    ext = (char const   *)tmp___4;
    }
#line 348
    if ((unsigned long )ext == (unsigned long )((char const   *)0)) {
      {
#line 349
      tmp___5 = strlen(cptr);
#line 349
      len = (int )tmp___5;
      }
    } else {
#line 351
      len = (int )(ext - cptr);
    }
  }
#line 354
  if (len > 31) {
#line 355
    len = 31;
  }
  {
#line 357
  memcpy((void */* __restrict  */)(name), (void const   */* __restrict  */)cptr, (size_t )len);
#line 358
  name[len] = (char)0;
#line 360
  ptr = name;
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! *ptr) {
#line 360
      goto while_break;
    }
    {
#line 364
    if ((int )*ptr == 58) {
#line 364
      goto case_58;
    }
#line 368
    if ((int )*ptr == 95) {
#line 368
      goto case_95;
    }
#line 362
    goto switch_break;
    case_58: /* CIL Label */ 
#line 365
    *ptr = (char )'-';
#line 366
    goto switch_break;
    case_95: /* CIL Label */ 
#line 369
    *ptr = (char )' ';
#line 370
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 360
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  *dsthint = (char const   *)(name);
#line 376
  return (fd);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static hfsfile *opendst(hfsvol *vol , char const   *dstname , char const   *hint ,
                        char const   *type , char const   *creator ) 
{ 
  hfsdirent ent ;
  hfsfile *file___0 ;
  unsigned long cwd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 391
  tmp___2 = hfs_stat(vol, dstname, & ent);
  }
#line 391
  if (tmp___2 != -1) {
#line 391
    if (ent.flags & 1) {
      {
#line 394
      cwd = hfs_getcwd(vol);
#line 396
      tmp___1 = hfs_setcwd(vol, ent.cnid);
      }
#line 396
      if (tmp___1 == -1) {
        {
#line 398
        cpi_error = hfs_error;
#line 398
        tmp = __errno_location();
#line 398
        tmp___0 = __errno_location();
#line 398
        *tmp = *tmp___0;
        }
#line 399
        return ((hfsfile *)0);
      }
#line 402
      dstname = hint;
    }
  }
  {
#line 405
  hfs_delete(vol, dstname);
#line 407
  file___0 = hfs_create(vol, dstname, type, creator);
  }
#line 408
  if ((unsigned long )file___0 == (unsigned long )((hfsfile *)0)) {
    {
#line 410
    cpi_error = hfs_error;
#line 410
    tmp___3 = __errno_location();
#line 410
    tmp___4 = __errno_location();
#line 410
    *tmp___3 = *tmp___4;
    }
#line 412
    if ((unsigned long )dstname == (unsigned long )hint) {
      {
#line 413
      hfs_setcwd(vol, cwd);
      }
    }
#line 415
    return ((hfsfile *)0);
  }
#line 418
  if ((unsigned long )dstname == (unsigned long )hint) {
    {
#line 420
    tmp___7 = hfs_setcwd(vol, cwd);
    }
#line 420
    if (tmp___7 == -1) {
      {
#line 422
      cpi_error = hfs_error;
#line 422
      tmp___5 = __errno_location();
#line 422
      tmp___6 = __errno_location();
#line 422
      *tmp___5 = *tmp___6;
#line 424
      hfs_close(file___0);
      }
#line 425
      return ((hfsfile *)0);
    }
  }
#line 429
  return (file___0);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static void closefiles(int ifile , hfsfile *ofile , int *result ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 439
  if (ofile) {
    {
#line 439
    tmp___1 = hfs_close(ofile);
    }
#line 439
    if (tmp___1 == -1) {
#line 439
      if (*result == 0) {
        {
#line 441
        cpi_error = hfs_error;
#line 441
        tmp = __errno_location();
#line 441
        tmp___0 = __errno_location();
#line 441
        *tmp = *tmp___0;
#line 442
        *result = -1;
        }
      }
    }
  }
  {
#line 445
  tmp___4 = close(ifile);
  }
#line 445
  if (tmp___4 == -1) {
#line 445
    if (*result == 0) {
      {
#line 447
      cpi_error = "error closing source file";
#line 447
      tmp___2 = __errno_location();
#line 447
      tmp___3 = __errno_location();
#line 447
      *tmp___2 = *tmp___3;
#line 448
      *result = -1;
      }
    }
  }
#line 450
  return;
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
int cpi_macb(char const   *srcname , hfsvol *vol , char const   *dstname ) 
{ 
  int ifile ;
  int result ;
  hfsfile *ofile ;
  hfsdirent ent ;
  char const   *dsthint ;
  char type[5] ;
  char creator[5] ;
  unsigned char buf[128] ;
  unsigned short crc___0 ;
  unsigned long dsize ;
  unsigned long rsize ;
  int *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  unsigned short tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;

  {
  {
#line 460
  result = 0;
#line 469
  ifile = opensrc(srcname, & dsthint, ".bin", 1);
  }
#line 470
  if (ifile == -1) {
#line 471
    return (-1);
  }
  {
#line 473
  tmp___1 = read(ifile, (void *)(buf), (size_t )128);
  }
#line 473
  if (tmp___1 < 128L) {
    {
#line 475
    cpi_error = "error reading MacBinary file header";
#line 475
    tmp = __errno_location();
#line 475
    tmp___0 = __errno_location();
#line 475
    *tmp = *tmp___0;
#line 477
    close(ifile);
    }
#line 478
    return (-1);
  }
#line 481
  if ((int )buf[0] != 0) {
    {
#line 483
    cpi_error = "invalid MacBinary file header";
#line 483
    tmp___2 = __errno_location();
#line 483
    *tmp___2 = 22;
#line 485
    close(ifile);
    }
#line 486
    return (-1);
  } else
#line 481
  if ((int )buf[74] != 0) {
    {
#line 483
    cpi_error = "invalid MacBinary file header";
#line 483
    tmp___2 = __errno_location();
#line 483
    *tmp___2 = 22;
#line 485
    close(ifile);
    }
#line 486
    return (-1);
  }
  {
#line 489
  crc___0 = d_getuw((unsigned char const   *)(& buf[124]));
#line 491
  tmp___4 = crc_macb((unsigned char const   *)(buf), 124, (unsigned short)0);
  }
#line 491
  if ((int )tmp___4 != (int )crc___0) {
    {
#line 495
    cpi_error = "unknown, unsupported, or corrupt MacBinary file";
#line 495
    tmp___3 = __errno_location();
#line 495
    *tmp___3 = 22;
#line 497
    close(ifile);
    }
#line 498
    return (-1);
  }
#line 501
  if ((int )buf[123] > 129) {
    {
#line 503
    cpi_error = "unsupported MacBinary file version";
#line 503
    tmp___5 = __errno_location();
#line 503
    *tmp___5 = 22;
#line 505
    close(ifile);
    }
#line 506
    return (-1);
  }
#line 509
  if ((int )buf[1] < 1) {
    {
#line 512
    cpi_error = "invalid MacBinary file header (bad file name)";
#line 512
    tmp___6 = __errno_location();
#line 512
    *tmp___6 = 22;
#line 514
    close(ifile);
    }
#line 515
    return (-1);
  } else
#line 509
  if ((int )buf[1] > 63) {
    {
#line 512
    cpi_error = "invalid MacBinary file header (bad file name)";
#line 512
    tmp___6 = __errno_location();
#line 512
    *tmp___6 = 22;
#line 514
    close(ifile);
    }
#line 515
    return (-1);
  } else
#line 509
  if ((int )buf[2 + (int )buf[1]] != 0) {
    {
#line 512
    cpi_error = "invalid MacBinary file header (bad file name)";
#line 512
    tmp___6 = __errno_location();
#line 512
    *tmp___6 = 22;
#line 514
    close(ifile);
    }
#line 515
    return (-1);
  }
  {
#line 518
  dsize = d_getul((unsigned char const   *)(& buf[83]));
#line 519
  rsize = d_getul((unsigned char const   *)(& buf[87]));
  }
#line 521
  if (dsize > 2147483647UL) {
    {
#line 523
    cpi_error = "invalid MacBinary file header (bad file length)";
#line 523
    tmp___7 = __errno_location();
#line 523
    *tmp___7 = 22;
#line 525
    close(ifile);
    }
#line 526
    return (-1);
  } else
#line 521
  if (rsize > 2147483647UL) {
    {
#line 523
    cpi_error = "invalid MacBinary file header (bad file length)";
#line 523
    tmp___7 = __errno_location();
#line 523
    *tmp___7 = 22;
#line 525
    close(ifile);
    }
#line 526
    return (-1);
  }
  {
#line 529
  dsthint = (char const   *)((char *)(& buf[2]));
#line 531
  memcpy((void */* __restrict  */)(type), (void const   */* __restrict  */)(& buf[65]),
         (size_t )4);
#line 532
  memcpy((void */* __restrict  */)(creator), (void const   */* __restrict  */)(& buf[69]),
         (size_t )4);
#line 533
  creator[4] = (char)0;
#line 533
  type[4] = creator[4];
#line 535
  ofile = opendst(vol, dstname, dsthint, (char const   *)(type), (char const   *)(creator));
  }
#line 536
  if ((unsigned long )ofile == (unsigned long )((hfsfile *)0)) {
    {
#line 538
    close(ifile);
    }
#line 539
    return (-1);
  }
  {
#line 542
  result = do_macb(ifile, ofile, dsize, rsize);
  }
#line 544
  if (result == 0) {
    {
#line 544
    tmp___10 = hfs_fstat(ofile, & ent);
    }
#line 544
    if (tmp___10 == -1) {
      {
#line 546
      cpi_error = hfs_error;
#line 546
      tmp___8 = __errno_location();
#line 546
      tmp___9 = __errno_location();
#line 546
      *tmp___8 = *tmp___9;
#line 547
      result = -1;
      }
    }
  }
  {
#line 550
  ent.fdflags = (short )((((int )buf[73] << 8) | (int )buf[101]) & ~ ((1 | (1 << 8)) | (1 << 9)));
#line 553
  tmp___11 = d_getul((unsigned char const   *)(& buf[91]));
#line 553
  ent.crdate = d_ltime(tmp___11);
#line 554
  tmp___12 = d_getul((unsigned char const   *)(& buf[95]));
#line 554
  ent.mddate = d_ltime(tmp___12);
  }
#line 556
  if (result == 0) {
    {
#line 556
    tmp___15 = hfs_fsetattr(ofile, (hfsdirent const   *)(& ent));
    }
#line 556
    if (tmp___15 == -1) {
      {
#line 558
      cpi_error = hfs_error;
#line 558
      tmp___13 = __errno_location();
#line 558
      tmp___14 = __errno_location();
#line 558
      *tmp___13 = *tmp___14;
#line 559
      result = -1;
      }
    }
  }
  {
#line 562
  closefiles(ifile, ofile, & result);
  }
#line 564
  return (result);
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
static int binhx(char *fname , char *type , char *creator , short *fdflags , unsigned long *dsize ,
                 unsigned long *rsize ) 
{ 
  int len ;
  unsigned char byte ;
  unsigned char word[2] ;
  unsigned char lword[4] ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;

  {
  {
#line 578
  tmp___1 = bh_read((void *)(& byte), 1);
  }
#line 578
  if (tmp___1 < 1) {
    {
#line 580
    cpi_error = bh_error;
#line 580
    tmp = __errno_location();
#line 580
    tmp___0 = __errno_location();
#line 580
    *tmp = *tmp___0;
    }
#line 581
    return (-1);
  }
#line 584
  len = (int )byte;
#line 586
  if (len < 1) {
    {
#line 588
    cpi_error = "invalid BinHex file header (bad file name)";
#line 588
    tmp___2 = __errno_location();
#line 588
    *tmp___2 = 22;
    }
#line 589
    return (-1);
  } else
#line 586
  if (len > 31) {
    {
#line 588
    cpi_error = "invalid BinHex file header (bad file name)";
#line 588
    tmp___2 = __errno_location();
#line 588
    *tmp___2 = 22;
    }
#line 589
    return (-1);
  }
  {
#line 592
  tmp___5 = bh_read((void *)fname, len + 1);
  }
#line 592
  if (tmp___5 < len + 1) {
    {
#line 594
    cpi_error = bh_error;
#line 594
    tmp___3 = __errno_location();
#line 594
    tmp___4 = __errno_location();
#line 594
    *tmp___3 = *tmp___4;
    }
#line 595
    return (-1);
  }
#line 598
  if ((int )*(fname + len) != 0) {
    {
#line 600
    cpi_error = "invalid BinHex file header (bad file name)";
#line 600
    tmp___6 = __errno_location();
#line 600
    *tmp___6 = 22;
    }
#line 601
    return (-1);
  }
  {
#line 604
  tmp___9 = bh_read((void *)type, 4);
  }
#line 604
  if (tmp___9 < 4) {
    {
#line 608
    cpi_error = bh_error;
#line 608
    tmp___7 = __errno_location();
#line 608
    tmp___8 = __errno_location();
#line 608
    *tmp___7 = *tmp___8;
    }
#line 609
    return (-1);
  } else {
    {
#line 604
    tmp___10 = bh_read((void *)creator, 4);
    }
#line 604
    if (tmp___10 < 4) {
      {
#line 608
      cpi_error = bh_error;
#line 608
      tmp___7 = __errno_location();
#line 608
      tmp___8 = __errno_location();
#line 608
      *tmp___7 = *tmp___8;
      }
#line 609
      return (-1);
    } else {
      {
#line 604
      tmp___11 = bh_read((void *)(word), 2);
      }
#line 604
      if (tmp___11 < 2) {
        {
#line 608
        cpi_error = bh_error;
#line 608
        tmp___7 = __errno_location();
#line 608
        tmp___8 = __errno_location();
#line 608
        *tmp___7 = *tmp___8;
        }
#line 609
        return (-1);
      }
    }
  }
  {
#line 611
  *fdflags = d_getsw((unsigned char const   *)(word));
#line 613
  tmp___14 = bh_read((void *)(lword), 4);
  }
#line 613
  if (tmp___14 < 4) {
    {
#line 615
    cpi_error = bh_error;
#line 615
    tmp___12 = __errno_location();
#line 615
    tmp___13 = __errno_location();
#line 615
    *tmp___12 = *tmp___13;
    }
#line 616
    return (-1);
  }
  {
#line 618
  *dsize = d_getul((unsigned char const   *)(lword));
#line 620
  tmp___17 = bh_read((void *)(lword), 4);
  }
#line 620
  if (tmp___17 < 4) {
    {
#line 622
    cpi_error = bh_error;
#line 622
    tmp___15 = __errno_location();
#line 622
    tmp___16 = __errno_location();
#line 622
    *tmp___15 = *tmp___16;
    }
#line 623
    return (-1);
  }
  {
#line 625
  *rsize = d_getul((unsigned char const   *)(lword));
  }
#line 627
  if (*dsize > 2147483647UL) {
    {
#line 629
    cpi_error = "invalid BinHex file header (bad file length)";
#line 629
    tmp___18 = __errno_location();
#line 629
    *tmp___18 = 22;
    }
#line 630
    return (-1);
  } else
#line 627
  if (*rsize > 2147483647UL) {
    {
#line 629
    cpi_error = "invalid BinHex file header (bad file length)";
#line 629
    tmp___18 = __errno_location();
#line 629
    *tmp___18 = 22;
    }
#line 630
    return (-1);
  }
  {
#line 633
  tmp___21 = bh_readcrc();
  }
#line 633
  if (tmp___21 == -1) {
    {
#line 635
    cpi_error = bh_error;
#line 635
    tmp___19 = __errno_location();
#line 635
    tmp___20 = __errno_location();
#line 635
    *tmp___19 = *tmp___20;
    }
#line 636
    return (-1);
  }
#line 639
  return (0);
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
int cpi_binh(char const   *srcname , hfsvol *vol , char const   *dstname ) 
{ 
  int ifile ;
  int result ;
  hfsfile *ofile ;
  hfsdirent ent ;
  char const   *dsthint ;
  char fname[32] ;
  char type[5] ;
  char creator[5] ;
  short fdflags ;
  unsigned long dsize ;
  unsigned long rsize ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 656
  ifile = opensrc(srcname, & dsthint, ".hqx", 0);
  }
#line 657
  if (ifile == -1) {
#line 658
    return (-1);
  }
  {
#line 660
  tmp___1 = bh_open(ifile);
  }
#line 660
  if (tmp___1 == -1) {
    {
#line 662
    cpi_error = bh_error;
#line 662
    tmp = __errno_location();
#line 662
    tmp___0 = __errno_location();
#line 662
    *tmp = *tmp___0;
#line 664
    close(ifile);
    }
#line 665
    return (-1);
  }
  {
#line 668
  tmp___2 = binhx(fname, type, creator, & fdflags, & dsize, & rsize);
  }
#line 668
  if (tmp___2 == -1) {
    {
#line 670
    bh_close();
#line 671
    close(ifile);
    }
#line 672
    return (-1);
  }
  {
#line 675
  dsthint = (char const   *)(fname);
#line 677
  ofile = opendst(vol, dstname, dsthint, (char const   *)(type), (char const   *)(creator));
  }
#line 678
  if ((unsigned long )ofile == (unsigned long )((hfsfile *)0)) {
    {
#line 680
    bh_close();
#line 681
    close(ifile);
    }
#line 682
    return (-1);
  }
  {
#line 685
  result = do_binh(ofile, dsize, rsize);
#line 687
  tmp___5 = bh_close();
  }
#line 687
  if (tmp___5 == -1) {
#line 687
    if (result == 0) {
      {
#line 689
      cpi_error = bh_error;
#line 689
      tmp___3 = __errno_location();
#line 689
      tmp___4 = __errno_location();
#line 689
      *tmp___3 = *tmp___4;
#line 690
      result = -1;
      }
    }
  }
#line 693
  if (result == 0) {
    {
#line 693
    tmp___8 = hfs_fstat(ofile, & ent);
    }
#line 693
    if (tmp___8 == -1) {
      {
#line 695
      cpi_error = hfs_error;
#line 695
      tmp___6 = __errno_location();
#line 695
      tmp___7 = __errno_location();
#line 695
      *tmp___6 = *tmp___7;
#line 696
      result = -1;
      }
    }
  }
#line 699
  ent.fdflags = (short )((int )fdflags & ~ ((1 | (1 << 8)) | (1 << 14)));
#line 702
  if (result == 0) {
    {
#line 702
    tmp___11 = hfs_fsetattr(ofile, (hfsdirent const   *)(& ent));
    }
#line 702
    if (tmp___11 == -1) {
      {
#line 704
      cpi_error = hfs_error;
#line 704
      tmp___9 = __errno_location();
#line 704
      tmp___10 = __errno_location();
#line 704
      *tmp___9 = *tmp___10;
#line 705
      result = -1;
      }
    }
  }
  {
#line 708
  closefiles(ifile, ofile, & result);
  }
#line 710
  return (result);
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
int cpi_text(char const   *srcname , hfsvol *vol , char const   *dstname ) 
{ 
  int ifile ;
  int result ;
  hfsfile *ofile ;
  char const   *dsthint ;

  {
  {
#line 719
  result = 0;
#line 723
  ifile = opensrc(srcname, & dsthint, ".txt", 0);
  }
#line 724
  if (ifile == -1) {
#line 725
    return (-1);
  }
  {
#line 727
  ofile = opendst(vol, dstname, dsthint, "TEXT", "UNIX");
  }
#line 728
  if ((unsigned long )ofile == (unsigned long )((hfsfile *)0)) {
    {
#line 730
    close(ifile);
    }
#line 731
    return (-1);
  }
  {
#line 734
  result = do_text(ifile, ofile);
#line 736
  closefiles(ifile, ofile, & result);
  }
#line 738
  return (result);
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyin.c"
int cpi_raw(char const   *srcname , hfsvol *vol , char const   *dstname ) 
{ 
  int ifile ;
  int result ;
  hfsfile *ofile ;
  char const   *dsthint ;

  {
  {
#line 747
  result = 0;
#line 751
  ifile = opensrc(srcname, & dsthint, (char const   *)0, 1);
  }
#line 752
  if (ifile == -1) {
#line 753
    return (-1);
  }
  {
#line 755
  ofile = opendst(vol, dstname, dsthint, "????", "UNIX");
  }
#line 756
  if ((unsigned long )ofile == (unsigned long )((hfsfile *)0)) {
    {
#line 758
    close(ifile);
    }
#line 759
    return (-1);
  }
  {
#line 762
  result = do_raw(ifile, ofile);
#line 764
  closefiles(ifile, ofile, & result);
  }
#line 766
  return (result);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.h"
int n_new(node *np ) ;
#line 25
int n_free(node *np ) ;
#line 27
int n_search(node *np , byte const   *pkey ) ;
#line 29
void n_index(node const   *np , byte *record , unsigned int *reclen ) ;
#line 31
void n_insertx(node *np , byte const   *record , unsigned int reclen ) ;
#line 32
int n_insert(node *np , byte *record , unsigned int *reclen ) ;
#line 34
int n_delete(node *np , byte *record , int *flag ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.h"
void d_putul(unsigned char *ptr , unsigned long data ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
void n_init(node *np , btree *bt , int type , int height ) 
{ 


  {
  {
#line 52
  np->bt = bt;
#line 53
  np->nnum = 0xffffffffffffffffUL;
#line 55
  np->nd.ndFLink = (ULongInt )0;
#line 56
  np->nd.ndBLink = (ULongInt )0;
#line 57
  np->nd.ndType = (SignedByte )type;
#line 58
  np->nd.ndNHeight = (SignedByte )height;
#line 59
  np->nd.ndNRecs = (UInteger )0;
#line 60
  np->nd.ndResv2 = (Integer )0;
#line 62
  np->rnum = -1;
#line 63
  np->roff[0] = (UInteger )14;
#line 65
  memset((void *)(& np->data), 0, sizeof(np->data));
  }
#line 66
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
int n_new(node *np ) 
{ 
  btree *bt ;
  unsigned long num ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 74
  bt = np->bt;
#line 77
  if (bt->hdr.bthFree == 0UL) {
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 78
      hfs_error = "b*-tree full";
#line 78
      tmp = __errno_location();
#line 78
      *tmp = 5;
      }
#line 78
      goto fail;
#line 78
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 80
  num = 0UL;
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 81
    if (num < bt->hdr.bthNNodes) {
#line 81
      if (! ((int const   )*((byte const   *)bt->map + (num >> 3)) & (int const   )(128 >> (num & 7UL)))) {
#line 81
        goto while_break___0;
      }
    } else {
#line 81
      goto while_break___0;
    }
#line 82
    num ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 84
  if (num == bt->hdr.bthNNodes) {
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 85
      hfs_error = "free b*-tree node not found";
#line 85
      tmp___0 = __errno_location();
#line 85
      *tmp___0 = 5;
      }
#line 85
      goto fail;
#line 85
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 87
  np->nnum = num;
#line 89
  *(bt->map + (num >> 3)) = (byte )((int )*(bt->map + (num >> 3)) | (128 >> (num & 7UL)));
#line 90
  (bt->hdr.bthFree) --;
#line 92
  bt->flags |= 1;
#line 94
  return (0);
  fail: 
#line 97
  return (-1);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
int n_free(node *np ) 
{ 
  btree *bt ;
  node sib ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 106
  bt = np->bt;
#line 109
  if (bt->hdr.bthFNode == np->nnum) {
#line 110
    bt->hdr.bthFNode = np->nd.ndFLink;
  }
#line 112
  if (bt->hdr.bthLNode == np->nnum) {
#line 113
    bt->hdr.bthLNode = np->nd.ndBLink;
  }
#line 115
  if (np->nd.ndFLink > 0UL) {
    {
#line 117
    tmp = bt_getnode(& sib, bt, np->nd.ndFLink);
    }
#line 117
    if (tmp == -1) {
#line 118
      goto fail;
    }
    {
#line 120
    sib.nd.ndBLink = np->nd.ndBLink;
#line 122
    tmp___0 = bt_putnode(& sib);
    }
#line 122
    if (tmp___0 == -1) {
#line 123
      goto fail;
    }
  }
#line 126
  if (np->nd.ndBLink > 0UL) {
    {
#line 128
    tmp___1 = bt_getnode(& sib, bt, np->nd.ndBLink);
    }
#line 128
    if (tmp___1 == -1) {
#line 129
      goto fail;
    }
    {
#line 131
    sib.nd.ndFLink = np->nd.ndFLink;
#line 133
    tmp___2 = bt_putnode(& sib);
    }
#line 133
    if (tmp___2 == -1) {
#line 134
      goto fail;
    }
  }
#line 137
  *(bt->map + (np->nnum >> 3)) = (byte )((int )*(bt->map + (np->nnum >> 3)) & ~ (128 >> (np->nnum & 7UL)));
#line 138
  (bt->hdr.bthFree) ++;
#line 140
  bt->flags |= 1;
#line 142
  return (0);
  fail: 
#line 145
  return (-1);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
static void compact(node *np ) 
{ 
  byte *ptr ;
  int offset ;
  int nrecs ;
  int i ;
  byte const   *rec ;
  int reclen ;
  int tmp ;
  byte *tmp___0 ;
  byte const   *tmp___1 ;
  int tmp___2 ;

  {
#line 158
  offset = 14;
#line 159
  ptr = np->data + offset;
#line 160
  nrecs = 0;
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < (int )np->nd.ndNRecs)) {
#line 162
      goto while_break;
    }
#line 167
    rec = (byte const   *)(np->data + (int )np->roff[i]);
#line 168
    reclen = (int )np->roff[i + 1] - (int )np->roff[i];
#line 170
    if ((int const   )*rec > 0) {
#line 172
      tmp = nrecs;
#line 172
      nrecs ++;
#line 172
      np->roff[tmp] = (UInteger )offset;
#line 173
      offset += reclen;
#line 175
      if ((unsigned long )ptr == (unsigned long )rec) {
#line 176
        ptr += reclen;
      } else {
        {
#line 179
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 179
          tmp___2 = reclen;
#line 179
          reclen --;
#line 179
          if (! tmp___2) {
#line 179
            goto while_break___0;
          }
#line 180
          tmp___0 = ptr;
#line 180
          ptr ++;
#line 180
          tmp___1 = rec;
#line 180
          rec ++;
#line 180
          *tmp___0 = (byte )*tmp___1;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  np->roff[nrecs] = (UInteger )offset;
#line 186
  np->nd.ndNRecs = (UInteger )nrecs;
#line 187
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
int n_search(node *np , byte const   *pkey ) 
{ 
  btree const   *bt ;
  byte key1[sizeof(CatKeyRec )] ;
  byte key2[sizeof(CatKeyRec )] ;
  int i ;
  int comp ;
  byte const   *rec ;
  int tmp ;

  {
  {
#line 195
  bt = (btree const   *)np->bt;
#line 197
  comp = -1;
#line 199
  (*(bt->keyunpack))(pkey, (void *)(key2));
#line 201
  i = (int )np->nd.ndNRecs;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    tmp = i;
#line 201
    i --;
#line 201
    if (! tmp) {
#line 201
      goto while_break;
    }
#line 205
    rec = (byte const   *)(np->data + (int )np->roff[i]);
#line 207
    if ((int const   )*rec == 0) {
#line 208
      goto __Cont;
    }
    {
#line 210
    (*(bt->keyunpack))(rec, (void *)(key1));
#line 211
    comp = (*(bt->keycompare))((void const   *)(key1), (void const   *)(key2));
    }
#line 213
    if (comp <= 0) {
#line 214
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  np->rnum = i;
#line 219
  return (comp == 0);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
void n_index(node const   *np , byte *record , unsigned int *reclen ) 
{ 
  byte const   *key ;

  {
#line 228
  key = (byte const   *)(np->data + (int )np->roff[0]);
#line 230
  if ((unsigned long )np->bt == (unsigned long )(& ((np->bt)->f.vol)->cat)) {
    {
#line 234
    *record = (byte )37;
#line 235
    memset((void *)(record + 1), 0, (size_t )37);
#line 236
    memcpy((void */* __restrict  */)(record + 1), (void const   */* __restrict  */)(key + 1),
           (size_t )*key);
    }
  } else {
    {
#line 239
    memcpy((void */* __restrict  */)record, (void const   */* __restrict  */)key,
           (size_t )(((1 + (int )*key) + 1) & -2));
    }
  }
  {
#line 241
  d_putul(record + (size_t )(((1 + (int )*((byte const   *)record)) + 1) & -2), (unsigned long )np->nnum);
  }
#line 243
  if (reclen) {
#line 244
    *reclen = (unsigned int )((size_t )(((1 + (int )*((byte const   *)record)) + 1) & -2) + 4UL);
  }
#line 245
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
static int split(node *left , byte *record , unsigned int *reclen ) 
{ 
  btree *bt ;
  node n ;
  node *right ;
  node *side ;
  int mark ;
  int i ;
  int tmp ;
  node *np ;
  byte *rec ;
  int tmp___0 ;
  int tmp___1 ;
  node sib ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 254
  bt = left->bt;
#line 255
  right = & n;
#line 255
  side = (node *)0;
#line 260
  *right = *left;
#line 262
  tmp = n_new(right);
  }
#line 262
  if (tmp == -1) {
#line 263
    goto fail;
  }
#line 265
  left->nd.ndFLink = right->nnum;
#line 266
  right->nd.ndBLink = left->nnum;
#line 270
  mark = (int )(((((size_t )((int )left->roff[left->nd.ndNRecs] - (int )left->roff[0]) + (size_t )(2 * (int )left->nd.ndNRecs)) + (size_t )*reclen) + 2UL) >> 1);
#line 272
  if (left->rnum == -1) {
#line 274
    side = left;
#line 275
    mark = (int )((unsigned int )mark - (*reclen + 2U));
  }
#line 278
  i = 0;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < (int )left->nd.ndNRecs)) {
#line 278
      goto while_break;
    }
#line 283
    if (mark > 0) {
#line 283
      np = right;
    } else {
#line 283
      np = left;
    }
#line 284
    rec = np->data + (int )np->roff[i];
#line 286
    mark -= ((int )np->roff[i + 1] - (int )np->roff[i]) + 2;
#line 288
    *rec = (byte )0;
#line 290
    if (left->rnum == i) {
#line 292
      if (mark > 0) {
#line 292
        side = left;
      } else {
#line 292
        side = right;
      }
#line 293
      mark = (int )((unsigned int )mark - (*reclen + 2U));
    }
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  compact(left);
#line 298
  compact(right);
#line 304
  n_search(side, (byte const   *)record);
#line 305
  n_insertx(side, (byte const   *)record, *reclen);
#line 307
  tmp___0 = bt_putnode(left);
  }
#line 307
  if (tmp___0 == -1) {
#line 309
    goto fail;
  } else {
    {
#line 307
    tmp___1 = bt_putnode(right);
    }
#line 307
    if (tmp___1 == -1) {
#line 309
      goto fail;
    }
  }
  {
#line 313
  n_index((node const   *)right, record, reclen);
  }
#line 317
  if (bt->hdr.bthLNode == left->nnum) {
#line 319
    bt->hdr.bthLNode = right->nnum;
#line 320
    bt->flags |= 1;
  }
#line 323
  if (right->nd.ndFLink > 0UL) {
    {
#line 327
    tmp___2 = bt_getnode(& sib, right->bt, right->nd.ndFLink);
    }
#line 327
    if (tmp___2 == -1) {
#line 328
      goto fail;
    }
    {
#line 330
    sib.nd.ndBLink = right->nnum;
#line 332
    tmp___3 = bt_putnode(& sib);
    }
#line 332
    if (tmp___3 == -1) {
#line 333
      goto fail;
    }
  }
#line 336
  return (0);
  fail: 
#line 339
  return (-1);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
void n_insertx(node *np , byte const   *record , unsigned int reclen ) 
{ 
  int rnum ;
  int i ;
  byte *ptr ;

  {
#line 351
  rnum = np->rnum + 1;
#line 355
  ptr = (np->data + (int )np->roff[np->nd.ndNRecs]) + reclen;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! ((unsigned long )ptr > (unsigned long )((np->data + (int )np->roff[rnum]) + reclen))) {
#line 355
      goto while_break;
    }
#line 357
    *(ptr - 1) = *((ptr - 1) - reclen);
#line 355
    ptr --;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  np->nd.ndNRecs = (UInteger )((int )np->nd.ndNRecs + 1);
#line 361
  i = (int )np->nd.ndNRecs;
  {
#line 361
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 361
    if (! (i > rnum)) {
#line 361
      goto while_break___0;
    }
#line 362
    np->roff[i] = (UInteger )((unsigned int )np->roff[i - 1] + reclen);
#line 361
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 366
  memcpy((void */* __restrict  */)(np->data + (int )np->roff[rnum]), (void const   */* __restrict  */)record,
         (size_t )reclen);
  }
#line 367
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
int n_insert(node *np , byte *record , unsigned int *reclen ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 377
  if ((int )np->nd.ndNRecs >= 35) {
    {
#line 379
    tmp = split(np, record, reclen);
    }
#line 379
    return (tmp);
  } else
#line 377
  if ((size_t )(*reclen + 2U) > (size_t )((512 - (int )np->roff[np->nd.ndNRecs]) - 2 * ((int )np->nd.ndNRecs + 1))) {
    {
#line 379
    tmp = split(np, record, reclen);
    }
#line 379
    return (tmp);
  }
  {
#line 381
  n_insertx(np, (byte const   *)record, *reclen);
#line 382
  *reclen = 0U;
#line 384
  tmp___0 = bt_putnode(np);
  }
#line 384
  return (tmp___0);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
static int join(node *left , node *right , byte *record , int *flag ) 
{ 
  int i ;
  int offset ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 398
  memcpy((void */* __restrict  */)(left->data + (int )left->roff[left->nd.ndNRecs]),
         (void const   */* __restrict  */)(right->data + (int )right->roff[0]), (size_t )((int )right->roff[right->nd.ndNRecs] - (int )right->roff[0]));
#line 401
  offset = (int )left->roff[left->nd.ndNRecs] - (int )right->roff[0];
#line 403
  i = 1;
  }
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i <= (int )right->nd.ndNRecs)) {
#line 403
      goto while_break;
    }
#line 404
    left->nd.ndNRecs = (UInteger )((int )left->nd.ndNRecs + 1);
#line 404
    left->roff[left->nd.ndNRecs] = (UInteger )(offset + (int )right->roff[i]);
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 406
  tmp = bt_putnode(left);
  }
#line 406
  if (tmp == -1) {
#line 407
    goto fail;
  }
  {
#line 411
  tmp___0 = n_free(right);
  }
#line 411
  if (tmp___0 == -1) {
#line 412
    goto fail;
  }
#line 414
  *record = (byte )0;
#line 415
  *flag = 1;
#line 417
  return (0);
  fail: 
#line 420
  return (-1);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/node.c"
int n_delete(node *np , byte *record , int *flag ) 
{ 
  byte *rec ;
  int tmp ;
  node left ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 431
  rec = np->data + (int )np->roff[np->rnum];
#line 433
  *rec = (byte )0;
#line 434
  compact(np);
  }
#line 436
  if ((int )np->nd.ndNRecs == 0) {
    {
#line 438
    tmp = n_free(np);
    }
#line 438
    if (tmp == -1) {
#line 439
      goto fail;
    }
#line 441
    *record = (byte )0;
#line 442
    *flag = 1;
#line 444
    return (0);
  }
#line 449
  if (np->nd.ndBLink > 0UL) {
    {
#line 453
    tmp___0 = bt_getnode(& left, np->bt, np->nd.ndBLink);
    }
#line 453
    if (tmp___0 == -1) {
#line 454
      goto fail;
    }
#line 456
    if ((int )np->nd.ndNRecs + (int )left.nd.ndNRecs <= 35) {
#line 456
      if ((size_t )((int )np->roff[np->nd.ndNRecs] - (int )np->roff[0]) + (size_t )(2 * (int )np->nd.ndNRecs) <= (size_t )((512 - (int )left.roff[left.nd.ndNRecs]) - 2 * ((int )left.nd.ndNRecs + 1))) {
        {
#line 458
        tmp___1 = join(& left, np, record, flag);
        }
#line 458
        return (tmp___1);
      }
    }
  }
#line 461
  if (np->rnum == 0) {
    {
#line 465
    n_index((node const   *)np, record, (unsigned int *)0);
#line 466
    *flag = 1;
    }
  }
  {
#line 469
  tmp___2 = bt_putnode(np);
  }
#line 469
  return (tmp___2);
  fail: 
#line 472
  return (-1);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.h"
darray *darr_new(size_t elemsz ) ;
#line 25
void darr_free(darray *array ) ;
#line 26
unsigned int darr_size(darray *array ) ;
#line 27
void *darr_array(darray *array ) ;
#line 28
void *darr_append(darray *array , void *elem ) ;
#line 29
void darr_shrink(darray *array , unsigned int nelts ) ;
#line 30
void darr_sort(darray *array , int (*compare___1)(void const   * , void const   * ) ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
darray *darr_new(size_t elemsz ) 
{ 
  darray *array ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 46
  tmp = malloc(sizeof(darray ));
#line 46
  array = (darray *)tmp;
  }
#line 47
  if ((unsigned long )array == (unsigned long )((darray *)0)) {
#line 48
    return ((darray *)0);
  }
  {
#line 50
  array->memsz = 8UL * elemsz;
#line 51
  tmp___0 = malloc(array->memsz);
#line 51
  array->mem = (char *)tmp___0;
  }
#line 52
  if ((unsigned long )array->mem == (unsigned long )((char *)0)) {
    {
#line 54
    free((void *)array);
    }
#line 55
    return ((darray *)0);
  }
#line 58
  array->eltend = array->mem;
#line 59
  array->elemsz = elemsz;
#line 61
  return (array);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
void darr_free(darray *array ) 
{ 


  {
  {
#line 70
  free((void *)array->mem);
#line 71
  free((void *)array);
  }
#line 72
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
unsigned int darr_size(darray *array ) 
{ 


  {
#line 80
  return ((unsigned int )((size_t )(array->eltend - array->mem) / array->elemsz));
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
void *darr_array(darray *array ) 
{ 


  {
#line 89
  return ((void *)array->mem);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
void *darr_append(darray *array , void *elem ) 
{ 
  char *eltend ;
  size_t elemsz ;
  char *newmem ;
  size_t newsz ;
  void *tmp ;

  {
#line 98
  eltend = array->eltend;
#line 99
  elemsz = array->elemsz;
#line 101
  if ((size_t )(eltend - array->mem) == array->memsz) {
    {
#line 106
    newsz = array->memsz * 2UL;
#line 107
    tmp = realloc((void *)array->mem, newsz);
#line 107
    newmem = (char *)tmp;
    }
#line 108
    if ((unsigned long )newmem == (unsigned long )((char *)0)) {
#line 109
      return ((void *)0);
    }
#line 111
    eltend = newmem + array->memsz;
#line 113
    array->mem = newmem;
#line 114
    array->memsz = newsz;
  }
  {
#line 117
  memcpy((void */* __restrict  */)eltend, (void const   */* __restrict  */)elem, elemsz);
#line 118
  array->eltend = eltend + elemsz;
  }
#line 120
  return ((void *)eltend);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
void darr_shrink(darray *array , unsigned int nelts ) 
{ 


  {
#line 129
  if ((size_t )nelts < (size_t )(array->eltend - array->mem) / array->elemsz) {
#line 130
    array->eltend = array->mem + (size_t )nelts * array->elemsz;
  }
#line 131
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/darray.c"
void darr_sort(darray *array , int (*compare___1)(void const   * , void const   * ) ) 
{ 


  {
  {
#line 139
  qsort((void *)array->mem, (size_t )(array->eltend - array->mem) / array->elemsz,
        array->elemsz, compare___1);
  }
#line 141
  return;
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.h"
int hfsutil_samepath(char const   *path1 , char const   *path2 ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hvol.h"
int hvol_main(int argc , char **argv ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hvol.c"
static int showvol(mountent *ment ) 
{ 
  hfsvol *vol ;
  hfsvolent vent ;
  int result ;

  {
  {
#line 43
  result = 0;
#line 45
  printf((char const   */* __restrict  */)"Current volume is mounted from");
  }
#line 46
  if (ment->partno > 0) {
    {
#line 47
    printf((char const   */* __restrict  */)" partition %d of", ment->partno);
    }
  }
  {
#line 48
  printf((char const   */* __restrict  */)":\n  %s\n", ment->path);
#line 50
  vol = hfsutil_remount(ment, 2);
  }
#line 51
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 52
    return (1);
  }
  {
#line 54
  printf((char const   */* __restrict  */)"\n");
#line 56
  hfs_vstat(vol, & vent);
#line 57
  hfsutil_pinfo(& vent);
#line 58
  hfsutil_unmount(vol, & result);
  }
#line 60
  return (result);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hvol.c"
int hvol_main(int argc , char **argv ) 
{ 
  int vnum ;
  mountent *ment ;
  int output ;
  int header ;
  mountent *ent ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 72
  if (argc > 2) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [volume-name-or-path]\n",
            argv0);
    }
#line 75
    return (1);
  }
#line 78
  if (argc == 1) {
    {
#line 80
    output = 0;
#line 80
    header = 0;
#line 82
    ment = hcwd_getvol(-1);
    }
#line 83
    if (ment) {
      {
#line 85
      showvol(ment);
#line 86
      output = 1;
      }
    }
#line 89
    vnum = 0;
    {
#line 89
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 93
      ent = hcwd_getvol(vnum);
      }
#line 94
      if ((unsigned long )ent == (unsigned long )((mountent *)0)) {
#line 95
        goto while_break;
      }
#line 97
      if ((unsigned long )ent == (unsigned long )ment) {
#line 98
        goto __Cont;
      }
#line 100
      if (header == 0) {
#line 102
        if (ment) {
#line 102
          tmp = "\nOther known";
        } else {
#line 102
          tmp = "Known";
        }
        {
#line 102
        printf((char const   */* __restrict  */)"%s volumes:\n", tmp);
#line 103
        header = 1;
        }
      }
#line 106
      if (ent->partno <= 0) {
        {
#line 107
        printf((char const   */* __restrict  */)"  %-35s     \"%s\"\n", ent->path,
               ent->vname);
        }
      } else {
        {
#line 109
        printf((char const   */* __restrict  */)"  %-35s %2d  \"%s\"\n", ent->path,
               ent->partno, ent->vname);
        }
      }
#line 112
      output = 1;
      __Cont: /* CIL Label */ 
#line 89
      vnum ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 115
    if (output == 0) {
      {
#line 116
      printf((char const   */* __restrict  */)"No known volumes; use `hmount\' to introduce new volumes\n");
      }
    }
#line 118
    return (0);
  }
  {
#line 121
  vnum = 0;
#line 121
  ment = hcwd_getvol(vnum);
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! ment) {
#line 121
      goto while_break___0;
    }
    {
#line 123
    tmp___1 = hfsutil_samepath((char const   *)*(argv + 1), (char const   *)ment->path);
    }
#line 123
    if (tmp___1) {
      {
#line 126
      hcwd_setvol(vnum);
#line 127
      tmp___0 = showvol(ment);
      }
#line 127
      return (tmp___0);
    } else {
      {
#line 123
      tmp___2 = strcasecmp((char const   *)*(argv + 1), (char const   *)(ment->vname));
      }
#line 123
      if (tmp___2 == 0) {
        {
#line 126
        hcwd_setvol(vnum);
#line 127
        tmp___0 = showvol(ment);
        }
#line 127
        return (tmp___0);
      }
    }
    {
#line 121
    vnum ++;
#line 121
    ment = hcwd_getvol(vnum);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown volume \"%s\"\n",
          argv0, *(argv + 1));
  }
#line 133
  return (1);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.h"
int l_getddr(hfsvol *vol , Block0 *ddr ) ;
#line 35
int l_putddr(hfsvol *vol , Block0 const   *ddr ) ;
#line 37
int l_getpmentry(hfsvol *vol , Partition *map , unsigned long bnum ) ;
#line 38
int l_putpmentry(hfsvol *vol , Partition const   *map , unsigned long bnum ) ;
#line 40
int l_getbb(hfsvol *vol , BootBlkHdr *bb , byte *bootcode ) ;
#line 41
int l_putbb(hfsvol *vol , BootBlkHdr const   *bb , byte const   *bootcode ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.h"
int b_readpb(hfsvol *vol , unsigned long bnum , block *bp , unsigned int blen ) ;
#line 27
int b_writepb(hfsvol *vol , unsigned long bnum , block const   *bp , unsigned int blen ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_getddr(hfsvol *vol , Block0 *ddr ) 
{ 
  block b ;
  byte const   *ptr ;
  int i ;
  int tmp ;

  {
  {
#line 43
  ptr = (byte const   *)(b);
#line 46
  tmp = b_readpb(vol, 0UL, & b, 1U);
  }
#line 46
  if (tmp == -1) {
#line 47
    goto fail;
  }
  {
#line 49
  d_fetchsw(& ptr, & ddr->sbSig);
#line 50
  d_fetchsw(& ptr, & ddr->sbBlkSize);
#line 51
  d_fetchsl(& ptr, & ddr->sbBlkCount);
#line 52
  d_fetchsw(& ptr, & ddr->sbDevType);
#line 53
  d_fetchsw(& ptr, & ddr->sbDevId);
#line 54
  d_fetchsl(& ptr, & ddr->sbData);
#line 55
  d_fetchsw(& ptr, & ddr->sbDrvrCount);
#line 56
  d_fetchsl(& ptr, & ddr->ddBlock);
#line 57
  d_fetchsw(& ptr, & ddr->ddSize);
#line 58
  d_fetchsw(& ptr, & ddr->ddType);
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < 243)) {
#line 60
      goto while_break;
    }
    {
#line 61
    d_fetchsw(& ptr, & ddr->ddPad[i]);
#line 60
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return (0);
  fail: 
#line 68
  return (-1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_putddr(hfsvol *vol , Block0 const   *ddr ) 
{ 
  block b ;
  byte *ptr ;
  int i ;
  int tmp ;

  {
  {
#line 78
  ptr = b;
#line 81
  d_storesw(& ptr, (short )ddr->sbSig);
#line 82
  d_storesw(& ptr, (short )ddr->sbBlkSize);
#line 83
  d_storesl(& ptr, (long )ddr->sbBlkCount);
#line 84
  d_storesw(& ptr, (short )ddr->sbDevType);
#line 85
  d_storesw(& ptr, (short )ddr->sbDevId);
#line 86
  d_storesl(& ptr, (long )ddr->sbData);
#line 87
  d_storesw(& ptr, (short )ddr->sbDrvrCount);
#line 88
  d_storesl(& ptr, (long )ddr->ddBlock);
#line 89
  d_storesw(& ptr, (short )ddr->ddSize);
#line 90
  d_storesw(& ptr, (short )ddr->ddType);
#line 92
  i = 0;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i < 243)) {
#line 92
      goto while_break;
    }
    {
#line 93
    d_storesw(& ptr, ddr->ddPad[i]);
#line 92
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  tmp = b_writepb(vol, 0UL, (block const   *)(& b), 1U);
  }
#line 97
  if (tmp == -1) {
#line 98
    goto fail;
  }
#line 100
  return (0);
  fail: 
#line 103
  return (-1);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_getpmentry(hfsvol *vol , Partition *map , unsigned long bnum ) 
{ 
  block b ;
  byte const   *ptr ;
  int i ;
  int tmp ;

  {
  {
#line 113
  ptr = (byte const   *)(b);
#line 116
  tmp = b_readpb(vol, bnum, & b, 1U);
  }
#line 116
  if (tmp == -1) {
#line 117
    goto fail;
  }
  {
#line 119
  d_fetchsw(& ptr, & map->pmSig);
#line 120
  d_fetchsw(& ptr, & map->pmSigPad);
#line 121
  d_fetchsl(& ptr, & map->pmMapBlkCnt);
#line 122
  d_fetchsl(& ptr, & map->pmPyPartStart);
#line 123
  d_fetchsl(& ptr, & map->pmPartBlkCnt);
#line 125
  strncpy((char */* __restrict  */)((char *)(map->pmPartName)), (char const   */* __restrict  */)((char const   *)ptr),
          (size_t )32);
#line 126
  map->pmPartName[32] = (Char )0;
#line 127
  ptr += 32;
#line 129
  strncpy((char */* __restrict  */)((char *)(map->pmParType)), (char const   */* __restrict  */)((char const   *)ptr),
          (size_t )32);
#line 130
  map->pmParType[32] = (Char )0;
#line 131
  ptr += 32;
#line 133
  d_fetchsl(& ptr, & map->pmLgDataStart);
#line 134
  d_fetchsl(& ptr, & map->pmDataCnt);
#line 135
  d_fetchsl(& ptr, & map->pmPartStatus);
#line 136
  d_fetchsl(& ptr, & map->pmLgBootStart);
#line 137
  d_fetchsl(& ptr, & map->pmBootSize);
#line 138
  d_fetchsl(& ptr, & map->pmBootAddr);
#line 139
  d_fetchsl(& ptr, & map->pmBootAddr2);
#line 140
  d_fetchsl(& ptr, & map->pmBootEntry);
#line 141
  d_fetchsl(& ptr, & map->pmBootEntry2);
#line 142
  d_fetchsl(& ptr, & map->pmBootCksum);
#line 144
  strncpy((char */* __restrict  */)((char *)(map->pmProcessor)), (char const   */* __restrict  */)((char const   *)ptr),
          (size_t )16);
#line 145
  map->pmProcessor[16] = (Char )0;
#line 146
  ptr += 16;
#line 148
  i = 0;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < 188)) {
#line 148
      goto while_break;
    }
    {
#line 149
    d_fetchsw(& ptr, & map->pmPad[i]);
#line 148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (0);
  fail: 
#line 156
  return (-1);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_putpmentry(hfsvol *vol , Partition const   *map , unsigned long bnum ) 
{ 
  block b ;
  byte *ptr ;
  int i ;
  int tmp ;

  {
  {
#line 166
  ptr = b;
#line 169
  d_storesw(& ptr, (short )map->pmSig);
#line 170
  d_storesw(& ptr, (short )map->pmSigPad);
#line 171
  d_storesl(& ptr, (long )map->pmMapBlkCnt);
#line 172
  d_storesl(& ptr, (long )map->pmPyPartStart);
#line 173
  d_storesl(& ptr, (long )map->pmPartBlkCnt);
#line 175
  memset((void *)ptr, 0, (size_t )32);
#line 176
  strncpy((char */* __restrict  */)((char *)ptr), (char const   */* __restrict  */)((char const   *)(map->pmPartName)),
          (size_t )32);
#line 177
  ptr += 32;
#line 179
  memset((void *)ptr, 0, (size_t )32);
#line 180
  strncpy((char */* __restrict  */)((char *)ptr), (char const   */* __restrict  */)((char const   *)(map->pmParType)),
          (size_t )32);
#line 181
  ptr += 32;
#line 183
  d_storesl(& ptr, (long )map->pmLgDataStart);
#line 184
  d_storesl(& ptr, (long )map->pmDataCnt);
#line 185
  d_storesl(& ptr, (long )map->pmPartStatus);
#line 186
  d_storesl(& ptr, (long )map->pmLgBootStart);
#line 187
  d_storesl(& ptr, (long )map->pmBootSize);
#line 188
  d_storesl(& ptr, (long )map->pmBootAddr);
#line 189
  d_storesl(& ptr, (long )map->pmBootAddr2);
#line 190
  d_storesl(& ptr, (long )map->pmBootEntry);
#line 191
  d_storesl(& ptr, (long )map->pmBootEntry2);
#line 192
  d_storesl(& ptr, (long )map->pmBootCksum);
#line 194
  memset((void *)ptr, 0, (size_t )16);
#line 195
  strncpy((char */* __restrict  */)((char *)ptr), (char const   */* __restrict  */)((char const   *)(map->pmProcessor)),
          (size_t )16);
#line 196
  ptr += 16;
#line 198
  i = 0;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < 188)) {
#line 198
      goto while_break;
    }
    {
#line 199
    d_storesw(& ptr, map->pmPad[i]);
#line 198
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  tmp = b_writepb(vol, bnum, (block const   *)(& b), 1U);
  }
#line 203
  if (tmp == -1) {
#line 204
    goto fail;
  }
#line 206
  return (0);
  fail: 
#line 209
  return (-1);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_getbb(hfsvol *vol , BootBlkHdr *bb , byte *bootcode ) 
{ 
  block b ;
  byte const   *ptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 219
  ptr = (byte const   *)(b);
#line 221
  tmp = b_readlb(vol, 0UL, & b);
  }
#line 221
  if (tmp == -1) {
#line 222
    goto fail;
  }
  {
#line 224
  d_fetchsw(& ptr, & bb->bbID);
#line 225
  d_fetchsl(& ptr, & bb->bbEntry);
#line 226
  d_fetchsw(& ptr, & bb->bbVersion);
#line 227
  d_fetchsw(& ptr, & bb->bbPageFlags);
#line 229
  d_fetchstr(& ptr, bb->bbSysName, (unsigned int )sizeof(bb->bbSysName));
#line 230
  d_fetchstr(& ptr, bb->bbShellName, (unsigned int )sizeof(bb->bbShellName));
#line 231
  d_fetchstr(& ptr, bb->bbDbg1Name, (unsigned int )sizeof(bb->bbDbg1Name));
#line 232
  d_fetchstr(& ptr, bb->bbDbg2Name, (unsigned int )sizeof(bb->bbDbg2Name));
#line 233
  d_fetchstr(& ptr, bb->bbScreenName, (unsigned int )sizeof(bb->bbScreenName));
#line 234
  d_fetchstr(& ptr, bb->bbHelloName, (unsigned int )sizeof(bb->bbHelloName));
#line 235
  d_fetchstr(& ptr, bb->bbScrapName, (unsigned int )sizeof(bb->bbScrapName));
#line 237
  d_fetchsw(& ptr, & bb->bbCntFCBs);
#line 238
  d_fetchsw(& ptr, & bb->bbCntEvts);
#line 239
  d_fetchsl(& ptr, & bb->bb128KSHeap);
#line 240
  d_fetchsl(& ptr, & bb->bb256KSHeap);
#line 241
  d_fetchsl(& ptr, & bb->bbSysHeapSize);
#line 242
  d_fetchsw(& ptr, & bb->filler);
#line 243
  d_fetchsl(& ptr, & bb->bbSysHeapExtra);
#line 244
  d_fetchsl(& ptr, & bb->bbSysHeapFract);
  }
#line 248
  if (bootcode) {
    {
#line 250
    memcpy((void */* __restrict  */)bootcode, (void const   */* __restrict  */)ptr,
           (size_t )364);
#line 252
    tmp___0 = b_readlb(vol, 1UL, & b);
    }
#line 252
    if (tmp___0 == -1) {
#line 253
      goto fail;
    }
    {
#line 255
    memcpy((void */* __restrict  */)(bootcode + 364), (void const   */* __restrict  */)(b),
           (size_t )512);
    }
  }
#line 258
  return (0);
  fail: 
#line 261
  return (-1);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_putbb(hfsvol *vol , BootBlkHdr const   *bb , byte const   *bootcode ) 
{ 
  block b ;
  byte *ptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 271
  ptr = b;
#line 273
  d_storesw(& ptr, (short )bb->bbID);
#line 274
  d_storesl(& ptr, (long )bb->bbEntry);
#line 275
  d_storesw(& ptr, (short )bb->bbVersion);
#line 276
  d_storesw(& ptr, (short )bb->bbPageFlags);
#line 278
  d_storestr(& ptr, (char const   *)(bb->bbSysName), (unsigned int )sizeof(bb->bbSysName));
#line 279
  d_storestr(& ptr, (char const   *)(bb->bbShellName), (unsigned int )sizeof(bb->bbShellName));
#line 280
  d_storestr(& ptr, (char const   *)(bb->bbDbg1Name), (unsigned int )sizeof(bb->bbDbg1Name));
#line 281
  d_storestr(& ptr, (char const   *)(bb->bbDbg2Name), (unsigned int )sizeof(bb->bbDbg2Name));
#line 282
  d_storestr(& ptr, (char const   *)(bb->bbScreenName), (unsigned int )sizeof(bb->bbScreenName));
#line 283
  d_storestr(& ptr, (char const   *)(bb->bbHelloName), (unsigned int )sizeof(bb->bbHelloName));
#line 284
  d_storestr(& ptr, (char const   *)(bb->bbScrapName), (unsigned int )sizeof(bb->bbScrapName));
#line 286
  d_storesw(& ptr, (short )bb->bbCntFCBs);
#line 287
  d_storesw(& ptr, (short )bb->bbCntEvts);
#line 288
  d_storesl(& ptr, (long )bb->bb128KSHeap);
#line 289
  d_storesl(& ptr, (long )bb->bb256KSHeap);
#line 290
  d_storesl(& ptr, (long )bb->bbSysHeapSize);
#line 291
  d_storesw(& ptr, (short )bb->filler);
#line 292
  d_storesl(& ptr, (long )bb->bbSysHeapExtra);
#line 293
  d_storesl(& ptr, (long )bb->bbSysHeapFract);
  }
#line 297
  if (bootcode) {
    {
#line 298
    memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)bootcode,
           (size_t )364);
    }
  } else {
    {
#line 300
    memset((void *)ptr, 0, (size_t )364);
    }
  }
  {
#line 302
  tmp = b_writelb(vol, 0UL, (block const   *)(& b));
  }
#line 302
  if (tmp == -1) {
#line 303
    goto fail;
  }
#line 305
  if (bootcode) {
    {
#line 306
    memcpy((void */* __restrict  */)(& b), (void const   */* __restrict  */)(bootcode + 364),
           (size_t )512);
    }
  } else {
    {
#line 308
    memset((void *)(& b), 0, (size_t )512);
    }
  }
  {
#line 310
  tmp___0 = b_writelb(vol, 1UL, (block const   *)(& b));
  }
#line 310
  if (tmp___0 == -1) {
#line 311
    goto fail;
  }
#line 313
  return (0);
  fail: 
#line 316
  return (-1);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_getmdb(hfsvol *vol , MDB *mdb , int backup ) 
{ 
  block b ;
  byte const   *ptr ;
  int i ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 326
  ptr = (byte const   *)(b);
#line 329
  if (backup) {
#line 329
    tmp = vol->vlen - 2UL;
  } else {
#line 329
    tmp = 2UL;
  }
  {
#line 329
  tmp___0 = b_readlb(vol, tmp, & b);
  }
#line 329
  if (tmp___0 == -1) {
#line 330
    goto fail;
  }
  {
#line 332
  d_fetchsw(& ptr, & mdb->drSigWord);
#line 333
  d_fetchsl(& ptr, & mdb->drCrDate);
#line 334
  d_fetchsl(& ptr, & mdb->drLsMod);
#line 335
  d_fetchsw(& ptr, & mdb->drAtrb);
#line 336
  d_fetchuw(& ptr, & mdb->drNmFls);
#line 337
  d_fetchuw(& ptr, & mdb->drVBMSt);
#line 338
  d_fetchuw(& ptr, & mdb->drAllocPtr);
#line 339
  d_fetchuw(& ptr, & mdb->drNmAlBlks);
#line 340
  d_fetchul(& ptr, & mdb->drAlBlkSiz);
#line 341
  d_fetchul(& ptr, & mdb->drClpSiz);
#line 342
  d_fetchuw(& ptr, & mdb->drAlBlSt);
#line 343
  d_fetchsl(& ptr, & mdb->drNxtCNID);
#line 344
  d_fetchuw(& ptr, & mdb->drFreeBks);
#line 346
  d_fetchstr(& ptr, mdb->drVN, (unsigned int )sizeof(mdb->drVN));
#line 350
  d_fetchsl(& ptr, & mdb->drVolBkUp);
#line 351
  d_fetchsw(& ptr, & mdb->drVSeqNum);
#line 352
  d_fetchul(& ptr, & mdb->drWrCnt);
#line 353
  d_fetchul(& ptr, & mdb->drXTClpSiz);
#line 354
  d_fetchul(& ptr, & mdb->drCTClpSiz);
#line 355
  d_fetchuw(& ptr, & mdb->drNmRtDirs);
#line 356
  d_fetchul(& ptr, & mdb->drFilCnt);
#line 357
  d_fetchul(& ptr, & mdb->drDirCnt);
#line 359
  i = 0;
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < 8)) {
#line 359
      goto while_break;
    }
    {
#line 360
    d_fetchsl(& ptr, & mdb->drFndrInfo[i]);
#line 359
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  d_fetchuw(& ptr, & mdb->drEmbedSigWord);
#line 365
  d_fetchuw(& ptr, & mdb->drEmbedExtent.xdrStABN);
#line 366
  d_fetchuw(& ptr, & mdb->drEmbedExtent.xdrNumABlks);
#line 368
  d_fetchul(& ptr, & mdb->drXTFlSize);
#line 370
  i = 0;
  }
  {
#line 370
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 370
    if (! (i < 3)) {
#line 370
      goto while_break___0;
    }
    {
#line 372
    d_fetchuw(& ptr, & mdb->drXTExtRec[i].xdrStABN);
#line 373
    d_fetchuw(& ptr, & mdb->drXTExtRec[i].xdrNumABlks);
#line 370
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 378
  d_fetchul(& ptr, & mdb->drCTFlSize);
#line 380
  i = 0;
  }
  {
#line 380
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 380
    if (! (i < 3)) {
#line 380
      goto while_break___1;
    }
    {
#line 382
    d_fetchuw(& ptr, & mdb->drCTExtRec[i].xdrStABN);
#line 383
    d_fetchuw(& ptr, & mdb->drCTExtRec[i].xdrNumABlks);
#line 380
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 388
  return (0);
  fail: 
#line 391
  return (-1);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/low.c"
int l_putmdb(hfsvol *vol , MDB const   *mdb , int backup ) 
{ 
  block b ;
  byte *ptr ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 401
  ptr = b;
#line 404
  d_storesw(& ptr, (short )mdb->drSigWord);
#line 405
  d_storesl(& ptr, (long )mdb->drCrDate);
#line 406
  d_storesl(& ptr, (long )mdb->drLsMod);
#line 407
  d_storesw(& ptr, (short )mdb->drAtrb);
#line 408
  d_storeuw(& ptr, (unsigned short )mdb->drNmFls);
#line 409
  d_storeuw(& ptr, (unsigned short )mdb->drVBMSt);
#line 410
  d_storeuw(& ptr, (unsigned short )mdb->drAllocPtr);
#line 411
  d_storeuw(& ptr, (unsigned short )mdb->drNmAlBlks);
#line 412
  d_storeul(& ptr, (unsigned long )mdb->drAlBlkSiz);
#line 413
  d_storeul(& ptr, (unsigned long )mdb->drClpSiz);
#line 414
  d_storeuw(& ptr, (unsigned short )mdb->drAlBlSt);
#line 415
  d_storesl(& ptr, (long )mdb->drNxtCNID);
#line 416
  d_storeuw(& ptr, (unsigned short )mdb->drFreeBks);
#line 418
  d_storestr(& ptr, (char const   *)(mdb->drVN), (unsigned int )sizeof(mdb->drVN));
#line 422
  d_storesl(& ptr, (long )mdb->drVolBkUp);
#line 423
  d_storesw(& ptr, (short )mdb->drVSeqNum);
#line 424
  d_storeul(& ptr, (unsigned long )mdb->drWrCnt);
#line 425
  d_storeul(& ptr, (unsigned long )mdb->drXTClpSiz);
#line 426
  d_storeul(& ptr, (unsigned long )mdb->drCTClpSiz);
#line 427
  d_storeuw(& ptr, (unsigned short )mdb->drNmRtDirs);
#line 428
  d_storeul(& ptr, (unsigned long )mdb->drFilCnt);
#line 429
  d_storeul(& ptr, (unsigned long )mdb->drDirCnt);
#line 431
  i = 0;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < 8)) {
#line 431
      goto while_break;
    }
    {
#line 432
    d_storesl(& ptr, mdb->drFndrInfo[i]);
#line 431
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 436
  d_storeuw(& ptr, (unsigned short )mdb->drEmbedSigWord);
#line 437
  d_storeuw(& ptr, (unsigned short )mdb->drEmbedExtent.xdrStABN);
#line 438
  d_storeuw(& ptr, (unsigned short )mdb->drEmbedExtent.xdrNumABlks);
#line 440
  d_storeul(& ptr, (unsigned long )mdb->drXTFlSize);
#line 442
  i = 0;
  }
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 442
    if (! (i < 3)) {
#line 442
      goto while_break___0;
    }
    {
#line 444
    d_storeuw(& ptr, (unsigned short )mdb->drXTExtRec[i].xdrStABN);
#line 445
    d_storeuw(& ptr, (unsigned short )mdb->drXTExtRec[i].xdrNumABlks);
#line 442
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 450
  d_storeul(& ptr, (unsigned long )mdb->drCTFlSize);
#line 452
  i = 0;
  }
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 452
    if (! (i < 3)) {
#line 452
      goto while_break___1;
    }
    {
#line 454
    d_storeuw(& ptr, (unsigned short )mdb->drCTExtRec[i].xdrStABN);
#line 455
    d_storeuw(& ptr, (unsigned short )mdb->drCTExtRec[i].xdrNumABlks);
#line 452
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 460
  memset((void *)ptr, 0, (size_t )(512L - (ptr - b)));
#line 462
  tmp = b_writelb(vol, 2UL, (block const   *)(& b));
  }
#line 462
  if (tmp == -1) {
#line 464
    goto fail;
  } else
#line 462
  if (backup) {
    {
#line 462
    tmp___0 = b_writelb(vol, vol->vlen - 2UL, (block const   *)(& b));
    }
#line 462
    if (tmp___0 == -1) {
#line 464
      goto fail;
    }
  }
#line 466
  return (0);
  fail: 
#line 469
  return (-1);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.h"
char const   *argv0  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.h"
char const   *bargv0  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/glob.h"
char **hfs_glob(hfsvol *vol , int argc , char **argv , int *nelts ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.h"
int hcopy_main(int argc , char **argv ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hdel.h"
int hdel_main(int argc , char **argv ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hformat.h"
int hformat_main(int argc , char **argv ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.h"
int hls_main(int argc , char **argv ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hmkdir.h"
int hmkdir_main(int argc , char **argv ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/humount.h"
int humount_main(int argc , char **argv ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int len ;
  char const   *dot ;
  struct __anonstruct_list_37 list[15] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int result ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 72
  list[0].name = "hattrib";
#line 72
  list[0].func = & hattrib_main;
#line 72
  list[1].name = "hcd";
#line 72
  list[1].func = & hcd_main;
#line 72
  list[2].name = "hcopy";
#line 72
  list[2].func = & hcopy_main;
#line 72
  list[3].name = "hdel";
#line 72
  list[3].func = & hdel_main;
#line 72
  list[4].name = "hdir";
#line 72
  list[4].func = & hls_main;
#line 72
  list[5].name = "hformat";
#line 72
  list[5].func = & hformat_main;
#line 72
  list[6].name = "hls";
#line 72
  list[6].func = & hls_main;
#line 72
  list[7].name = "hmkdir";
#line 72
  list[7].func = & hmkdir_main;
#line 72
  list[8].name = "hmount";
#line 72
  list[8].func = & hmount_main;
#line 72
  list[9].name = "hpwd";
#line 72
  list[9].func = & hpwd_main;
#line 72
  list[10].name = "hrename";
#line 72
  list[10].func = & hrename_main;
#line 72
  list[11].name = "hrmdir";
#line 72
  list[11].func = & hrmdir_main;
#line 72
  list[12].name = "humount";
#line 72
  list[12].func = & humount_main;
#line 72
  list[13].name = "hvol";
#line 72
  list[13].func = & hvol_main;
#line 72
  list[14].name = (char const   *)0;
#line 72
  list[14].func = (int (*)(int  , char ** ))0;
#line 93
  suid_init();
  }
#line 95
  if (argc == 2) {
    {
#line 97
    tmp___0 = strcmp((char const   *)*(argv + 1), "--version");
    }
#line 97
    if (tmp___0 == 0) {
      {
#line 99
      printf((char const   */* __restrict  */)"%s - %s\n", hfsutils_version, hfsutils_copyright);
#line 100
      printf((char const   */* __restrict  */)"`%s --license\' for licensing information.\n",
             *(argv + 0));
      }
#line 101
      return (0);
    } else {
      {
#line 103
      tmp = strcmp((char const   *)*(argv + 1), "--license");
      }
#line 103
      if (tmp == 0) {
        {
#line 105
        printf((char const   */* __restrict  */)"\n%s", hfsutils_license);
        }
#line 106
        return (0);
      }
    }
  }
  {
#line 110
  argv0 = (char const   *)*(argv + 0);
#line 112
  tmp___1 = strrchr(argv0, '/');
#line 112
  bargv0 = (char const   *)tmp___1;
  }
#line 113
  if ((unsigned long )bargv0 == (unsigned long )((char const   *)0)) {
#line 114
    bargv0 = argv0;
  } else {
#line 116
    bargv0 ++;
  }
  {
#line 118
  tmp___2 = strchr(bargv0, '.');
#line 118
  dot = (char const   *)tmp___2;
  }
#line 119
  if (dot) {
#line 119
    len = (int )(dot - bargv0);
  } else {
    {
#line 119
    tmp___3 = strlen(bargv0);
#line 119
    len = (int )tmp___3;
    }
  }
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! list[i].name) {
#line 121
      goto while_break;
    }
    {
#line 123
    tmp___6 = strncmp(bargv0, list[i].name, (size_t )len);
    }
#line 123
    if (tmp___6 == 0) {
      {
#line 127
      bargv0 = list[i].name;
#line 129
      tmp___4 = hcwd_init();
      }
#line 129
      if (tmp___4 == -1) {
        {
#line 131
        perror("Failed to initialize HFS working directories");
        }
#line 132
        return (1);
      }
      {
#line 135
      result = (*(list[i].func))(argc, argv);
#line 137
      tmp___5 = hcwd_finish();
      }
#line 137
      if (tmp___5 == -1) {
        {
#line 139
        perror("Failed to save working directory state");
        }
#line 140
        return (1);
      }
#line 143
      return (result);
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown operation `%s\'\n",
          argv0, bargv0);
  }
#line 148
  return (1);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
void hfsutil_perror(char const   *msg ) 
{ 
  char const   *str ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 157
  tmp = __errno_location();
#line 157
  tmp___0 = strerror(*tmp);
#line 157
  str = (char const   *)tmp___0;
  }
#line 159
  if ((unsigned long )hfs_error == (unsigned long )((char const   *)0)) {
    {
#line 160
    tmp___1 = tolower((int )*str);
#line 160
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %c%s\n",
            argv0, msg, tmp___1, str + 1);
    }
  } else {
    {
#line 162
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s (%s)\n",
            argv0, msg, hfs_error, str);
    }
  }
#line 163
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
void hfsutil_perrorp(char const   *path ) 
{ 
  char const   *str ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 171
  tmp = __errno_location();
#line 171
  tmp___0 = strerror(*tmp);
#line 171
  str = (char const   *)tmp___0;
  }
#line 173
  if ((unsigned long )hfs_error == (unsigned long )((char const   *)0)) {
    {
#line 174
    tmp___1 = tolower((int )*str);
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: \"%s\": %c%s\n",
            argv0, path, tmp___1, str + 1);
    }
  } else {
    {
#line 176
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: \"%s\": %s (%s)\n",
            argv0, path, hfs_error, str);
    }
  }
#line 177
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
hfsvol *hfsutil_remount(mountent *ment , int flags ) 
{ 
  hfsvol *vol ;
  hfsvolent vent ;
  int tmp ;
  int tmp___0 ;

  {
#line 188
  if ((unsigned long )ment == (unsigned long )((mountent *)0)) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No volume is current; use `hmount\' or `hvol\'\n",
            argv0);
    }
#line 192
    return ((hfsvol *)0);
  }
  {
#line 195
  suid_enable();
#line 196
  vol = hfs_mount((char const   *)ment->path, ment->partno, flags);
#line 197
  suid_disable();
  }
#line 199
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
    {
#line 201
    hfsutil_perror((char const   *)ment->path);
    }
#line 202
    return ((hfsvol *)0);
  }
  {
#line 205
  hfs_vstat(vol, & vent);
#line 207
  tmp = strcmp((char const   *)(vent.name), (char const   *)(ment->vname));
  }
#line 207
  if (tmp != 0) {
    {
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Expected volume \"%s\" not found\n",
            argv0, ment->vname);
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Replace media on %s or use `hmount\'\n",
            argv0, ment->path);
#line 214
    hfs_umount(vol);
    }
#line 215
    return ((hfsvol *)0);
  }
  {
#line 218
  tmp___0 = hfs_chdir(vol, (char const   *)ment->cwd);
  }
#line 218
  if (tmp___0 == -1) {
    {
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Current HFS directory \"%s%s:\" no longer exists\n",
            argv0, ment->vname, ment->cwd);
    }
  }
#line 224
  return (vol);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
void hfsutil_unmount(hfsvol *vol , int *result ) 
{ 
  int tmp ;

  {
  {
#line 233
  tmp = hfs_umount(vol);
  }
#line 233
  if (tmp == -1) {
#line 233
    if (*result == 0) {
      {
#line 235
      hfsutil_perror("Error closing HFS volume");
#line 236
      *result = 1;
      }
    }
  }
#line 238
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
void hfsutil_pinfo(hfsvolent *ent ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 246
  if (ent->flags & 2) {
#line 246
    tmp = " (locked)";
  } else {
#line 246
    tmp = "";
  }
  {
#line 246
  printf((char const   */* __restrict  */)"Volume name is \"%s\"%s\n", ent->name,
         tmp);
#line 248
  tmp___0 = ctime((time_t const   *)(& ent->crdate));
#line 248
  printf((char const   */* __restrict  */)"Volume was created on %s", tmp___0);
#line 249
  tmp___1 = ctime((time_t const   *)(& ent->mddate));
#line 249
  printf((char const   */* __restrict  */)"Volume was last modified on %s", tmp___1);
#line 250
  printf((char const   */* __restrict  */)"Volume has %lu bytes free\n", ent->freebytes);
  }
#line 251
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
char **hfsutil_glob(hfsvol *vol , int argc , char **argv , int *nelts , int *result ) 
{ 
  char **fargv ;

  {
  {
#line 262
  fargv = hfs_glob(vol, argc, argv, nelts);
  }
#line 263
  if ((unsigned long )fargv == (unsigned long )((char **)0)) {
#line 263
    if (*result == 0) {
      {
#line 265
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: globbing error\n",
              argv0);
#line 266
      *result = 1;
      }
    }
  }
#line 269
  return (fargv);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
char *hfsutil_getcwd(hfsvol *vol ) 
{ 
  char *path ;
  char name___1[33] ;
  long cwd ;
  int pathlen ;
  void *tmp ;
  unsigned long tmp___0 ;
  char *new ;
  int namelen ;
  int i ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 282
  tmp = malloc((size_t )1);
#line 282
  path = (char *)tmp;
#line 283
  *(path + 0) = (char)0;
#line 284
  pathlen = 0;
#line 285
  tmp___0 = hfs_getcwd(vol);
#line 285
  cwd = (long )tmp___0;
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (cwd != 1L)) {
#line 287
      goto while_break;
    }
    {
#line 292
    tmp___1 = hfs_dirinfo(vol, (unsigned long *)(& cwd), name___1);
    }
#line 292
    if (tmp___1 == -1) {
#line 293
      return ((char *)0);
    }
#line 295
    if (pathlen) {
      {
#line 296
      strcat((char */* __restrict  */)(name___1), (char const   */* __restrict  */)":");
      }
    }
    {
#line 298
    tmp___2 = strlen((char const   *)(name___1));
#line 298
    namelen = (int )tmp___2;
#line 300
    tmp___3 = realloc((void *)path, (size_t )((namelen + pathlen) + 1));
#line 300
    new = (char *)tmp___3;
    }
#line 301
    if ((unsigned long )new == (unsigned long )((char *)0)) {
      {
#line 303
      free((void *)path);
#line 304
      hfs_error = (char const   *)0;
#line 304
      tmp___4 = __errno_location();
#line 304
      *tmp___4 = 12;
      }
#line 305
      return ((char *)0);
    }
#line 308
    if (pathlen == 0) {
#line 309
      *(new + 0) = (char)0;
    }
#line 311
    path = new;
#line 315
    i = pathlen + 1;
#line 316
    new = (path + namelen) + pathlen;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      tmp___5 = i;
#line 316
      i --;
#line 316
      if (! tmp___5) {
#line 316
        goto while_break___0;
      }
#line 317
      *new = *(new - namelen);
#line 316
      new --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 319
    memcpy((void */* __restrict  */)path, (void const   */* __restrict  */)(name___1),
           (size_t )namelen);
#line 321
    pathlen += namelen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return (path);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
int hfsutil_samepath(char const   *path1 , char const   *path2 ) 
{ 
  struct stat sbuf1 ;
  struct stat sbuf2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 335
  tmp = stat((char const   */* __restrict  */)path1, (struct stat */* __restrict  */)(& sbuf1));
  }
#line 335
  if (tmp == 0) {
    {
#line 335
    tmp___0 = stat((char const   */* __restrict  */)path2, (struct stat */* __restrict  */)(& sbuf2));
    }
#line 335
    if (tmp___0 == 0) {
#line 335
      if (sbuf1.st_dev == sbuf2.st_dev) {
#line 335
        if (sbuf1.st_ino == sbuf2.st_ino) {
#line 335
          tmp___1 = 1;
        } else {
#line 335
          tmp___1 = 0;
        }
      } else {
#line 335
        tmp___1 = 0;
      }
    } else {
#line 335
      tmp___1 = 0;
    }
  } else {
#line 335
    tmp___1 = 0;
  }
#line 335
  return (tmp___1);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hfsutil.c"
char *hfsutil_abspath(char const   *path ) 
{ 
  char *cwd ;
  char *buf ;
  size_t len ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;

  {
#line 351
  if ((int const   )*(path + 0) == 47) {
    {
#line 352
    tmp = strdup(path);
    }
#line 352
    return (tmp);
  }
  {
#line 354
  cwd = getenv("PWD");
  }
#line 355
  if (cwd) {
    {
#line 355
    tmp___10 = hfsutil_samepath((char const   *)cwd, ".");
    }
#line 355
    if (tmp___10) {
      {
#line 357
      tmp___0 = strlen((char const   *)cwd);
#line 357
      tmp___1 = strlen(path);
#line 357
      tmp___2 = malloc(((tmp___0 + 1UL) + tmp___1) + 1UL);
#line 357
      buf = (char *)tmp___2;
      }
#line 358
      if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 359
        return ((char *)0);
      }
      {
#line 361
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)cwd);
      }
    } else {
#line 355
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 365
    len = (size_t )32;
#line 366
    tmp___3 = malloc(len);
#line 366
    cwd = (char *)tmp___3;
    }
#line 367
    if ((unsigned long )cwd == (unsigned long )((char *)0)) {
#line 368
      return ((char *)0);
    }
    {
#line 370
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 370
      tmp___6 = getcwd(cwd, len);
      }
#line 370
      if (! ((unsigned long )tmp___6 == (unsigned long )((char *)0))) {
#line 370
        goto while_break;
      }
      {
#line 372
      tmp___4 = __errno_location();
      }
#line 372
      if (*tmp___4 != 34) {
        {
#line 374
        free((void *)cwd);
        }
#line 375
        return ((char *)0);
      }
      {
#line 378
      len <<= 1;
#line 379
      tmp___5 = realloc((void *)cwd, len);
#line 379
      buf = (char *)tmp___5;
      }
#line 380
      if ((unsigned long )buf == (unsigned long )((char *)0)) {
        {
#line 382
        free((void *)cwd);
        }
#line 383
        return ((char *)0);
      }
#line 386
      cwd = buf;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 389
    tmp___7 = strlen((char const   *)cwd);
#line 389
    tmp___8 = strlen(path);
#line 389
    tmp___9 = realloc((void *)cwd, ((tmp___7 + 1UL) + tmp___8) + 1UL);
#line 389
    buf = (char *)tmp___9;
    }
#line 390
    if ((unsigned long )buf == (unsigned long )((char *)0)) {
      {
#line 392
      free((void *)cwd);
      }
#line 393
      return ((char *)0);
    }
  }
  {
#line 397
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"/");
#line 398
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)path);
  }
#line 400
  return (buf);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.h"
void dstr_init(dstring *string ) ;
#line 30
int dstr_append(dstring *string , char const   *str , size_t len ) ;
#line 31
char *dstr_string(dstring *string ) ;
#line 32
int dstr_length(dstring *string ) ;
#line 33
void dstr_shrink(dstring *string , size_t len ) ;
#line 34
void dstr_free(dstring *string ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.c"
void dstr_init(dstring *string ) 
{ 


  {
#line 37
  string->str = string->sbuf;
#line 38
  string->len = (size_t )0;
#line 39
  string->space = sizeof(string->sbuf);
#line 40
  string->sbuf[0] = (char)0;
#line 41
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.c"
int dstr_append(dstring *string , char const   *str , size_t len ) 
{ 
  size_t newlen ;
  char *new ;
  void *tmp ;

  {
#line 51
  if (len == 0xffffffffffffffffUL) {
    {
#line 52
    len = strlen(str);
    }
  }
#line 54
  newlen = string->len + len;
#line 58
  if (newlen >= string->space) {
    {
#line 62
    newlen *= 2UL;
#line 64
    tmp = malloc(newlen);
#line 64
    new = (char *)tmp;
    }
#line 65
    if ((unsigned long )new == (unsigned long )((char *)0)) {
#line 66
      return (-1);
    }
    {
#line 68
    string->space = newlen;
#line 70
    memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)string->str,
           string->len);
    }
#line 72
    if ((unsigned long )string->str != (unsigned long )(string->sbuf)) {
      {
#line 73
      free((void *)string->str);
      }
    }
#line 75
    string->str = new;
  }
  {
#line 80
  memcpy((void */* __restrict  */)(string->str + string->len), (void const   */* __restrict  */)str,
         len);
#line 82
  string->len += len;
#line 83
  *(string->str + string->len) = (char)0;
  }
#line 85
  return (0);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.c"
char *dstr_string(dstring *string ) 
{ 


  {
#line 94
  return (string->str);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.c"
int dstr_length(dstring *string ) 
{ 


  {
#line 103
  return ((int )string->len);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.c"
void dstr_shrink(dstring *string , size_t len ) 
{ 


  {
#line 112
  if (len < string->len) {
#line 113
    string->len = len;
  }
#line 114
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/dstring.c"
void dstr_free(dstring *string ) 
{ 


  {
#line 122
  if ((unsigned long )string->str != (unsigned long )(string->sbuf)) {
    {
#line 123
    free((void *)string->str);
    }
  }
#line 124
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_getnode(node *np , btree *bt , unsigned long nnum ) 
{ 
  block *bp ;
  byte const   *ptr ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 43
  bp = & np->data;
#line 47
  np->bt = bt;
#line 48
  np->nnum = nnum;
#line 57
  if (nnum > 0UL) {
#line 57
    if (nnum >= bt->hdr.bthNNodes) {
      {
#line 58
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 58
        hfs_error = "read nonexistent b*-tree node";
#line 58
        tmp = __errno_location();
#line 58
        *tmp = 5;
        }
#line 58
        goto fail;
#line 58
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 57
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 59
  if (bt->map) {
#line 59
    if (! ((int const   )*((byte const   *)bt->map + (nnum >> 3)) & (int const   )(128 >> (nnum & 7UL)))) {
      {
#line 60
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 60
        hfs_error = "read unallocated b*-tree node";
#line 60
        tmp___0 = __errno_location();
#line 60
        *tmp___0 = 5;
        }
#line 60
        goto fail;
#line 60
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 62
  tmp___1 = f_doblock(& bt->f, nnum, bp, & b_readab);
  }
#line 62
  if (tmp___1 == -1) {
#line 63
    goto fail;
  }
  {
#line 65
  ptr = (byte const   *)(*bp);
#line 67
  d_fetchul(& ptr, & np->nd.ndFLink);
#line 68
  d_fetchul(& ptr, & np->nd.ndBLink);
#line 69
  d_fetchsb(& ptr, & np->nd.ndType);
#line 70
  d_fetchsb(& ptr, & np->nd.ndNHeight);
#line 71
  d_fetchuw(& ptr, & np->nd.ndNRecs);
#line 72
  d_fetchsw(& ptr, & np->nd.ndResv2);
  }
#line 74
  if ((int )np->nd.ndNRecs > 35) {
    {
#line 75
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 75
      hfs_error = "too many b*-tree node records";
#line 75
      tmp___2 = __errno_location();
#line 75
      *tmp___2 = 5;
      }
#line 75
      goto fail;
#line 75
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 77
  i = (int )np->nd.ndNRecs + 1;
#line 79
  ptr = (byte const   *)((*bp + 512) - 2 * i);
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 81
    tmp___3 = i;
#line 81
    i --;
#line 81
    if (! tmp___3) {
#line 81
      goto while_break___2;
    }
    {
#line 82
    d_fetchuw(& ptr, & np->roff[i]);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 84
  return (0);
  fail: 
#line 87
  return (-1);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_putnode(node *np ) 
{ 
  btree *bt ;
  block *bp ;
  byte *ptr ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 96
  bt = np->bt;
#line 97
  bp = & np->data;
#line 108
  if (np->nnum > 0UL) {
#line 108
    if (np->nnum >= bt->hdr.bthNNodes) {
      {
#line 109
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 109
        hfs_error = "write nonexistent b*-tree node";
#line 109
        tmp = __errno_location();
#line 109
        *tmp = 5;
        }
#line 109
        goto fail;
#line 109
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 108
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 110
  if (bt->map) {
#line 110
    if (! ((int const   )*((byte const   *)bt->map + (np->nnum >> 3)) & (int const   )(128 >> (np->nnum & 7UL)))) {
      {
#line 111
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 111
        hfs_error = "write unallocated b*-tree node";
#line 111
        tmp___0 = __errno_location();
#line 111
        *tmp___0 = 5;
        }
#line 111
        goto fail;
#line 111
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 113
  ptr = *bp;
#line 115
  d_storeul(& ptr, np->nd.ndFLink);
#line 116
  d_storeul(& ptr, np->nd.ndBLink);
#line 117
  d_storesb(& ptr, np->nd.ndType);
#line 118
  d_storesb(& ptr, np->nd.ndNHeight);
#line 119
  d_storeuw(& ptr, np->nd.ndNRecs);
#line 120
  d_storesw(& ptr, np->nd.ndResv2);
  }
#line 122
  if ((int )np->nd.ndNRecs > 35) {
    {
#line 123
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 123
      hfs_error = "too many b*-tree node records";
#line 123
      tmp___1 = __errno_location();
#line 123
      *tmp___1 = 5;
      }
#line 123
      goto fail;
#line 123
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 125
  i = (int )np->nd.ndNRecs + 1;
#line 127
  ptr = (*bp + 512) - 2 * i;
  {
#line 129
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 129
    tmp___2 = i;
#line 129
    i --;
#line 129
    if (! tmp___2) {
#line 129
      goto while_break___2;
    }
    {
#line 130
    d_storeuw(& ptr, np->roff[i]);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 132
  tmp___3 = f_doblock(& bt->f, np->nnum, bp, (int (*)(hfsvol * , unsigned int  , unsigned int  ,
                                                      block * ))(& b_writeab));
  }
#line 132
  return (tmp___3);
  fail: 
#line 135
  return (-1);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_readhdr(btree *bt ) 
{ 
  byte const   *ptr ;
  byte *map ;
  int i ;
  unsigned long nnum ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  node n ;
  byte *newmap ;
  int tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 145
  map = (byte *)0;
#line 149
  tmp = bt_getnode(& bt->hdrnd, bt, 0UL);
  }
#line 149
  if (tmp == -1) {
#line 150
    goto fail;
  }
#line 152
  if ((int )bt->hdrnd.nd.ndType != 1) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )bt->hdrnd.nd.ndNRecs != 3) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )bt->hdrnd.roff[0] != 14) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )bt->hdrnd.roff[1] != 120) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )bt->hdrnd.roff[2] != 248) {
#line 152
    goto _L;
  } else
#line 152
  if ((int )bt->hdrnd.roff[3] != 504) {
    _L: /* CIL Label */ 
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 158
      hfs_error = "malformed b*-tree header node";
#line 158
      tmp___0 = __errno_location();
#line 158
      *tmp___0 = 5;
      }
#line 158
      goto fail;
#line 158
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 162
  ptr = (byte const   *)(bt->hdrnd.data + (int )bt->hdrnd.roff[0]);
#line 164
  d_fetchuw(& ptr, & bt->hdr.bthDepth);
#line 165
  d_fetchul(& ptr, & bt->hdr.bthRoot);
#line 166
  d_fetchul(& ptr, & bt->hdr.bthNRecs);
#line 167
  d_fetchul(& ptr, & bt->hdr.bthFNode);
#line 168
  d_fetchul(& ptr, & bt->hdr.bthLNode);
#line 169
  d_fetchuw(& ptr, & bt->hdr.bthNodeSize);
#line 170
  d_fetchuw(& ptr, & bt->hdr.bthKeyLen);
#line 171
  d_fetchul(& ptr, & bt->hdr.bthNNodes);
#line 172
  d_fetchul(& ptr, & bt->hdr.bthFree);
#line 174
  i = 0;
  }
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 174
    if (! (i < 76)) {
#line 174
      goto while_break___0;
    }
    {
#line 175
    d_fetchsb(& ptr, & bt->hdr.bthResv[i]);
#line 174
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 177
  if ((int )bt->hdr.bthNodeSize != 512) {
    {
#line 178
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 178
      hfs_error = "unsupported b*-tree node size";
#line 178
      tmp___1 = __errno_location();
#line 178
      *tmp___1 = 22;
      }
#line 178
      goto fail;
#line 178
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 183
  tmp___2 = malloc(sizeof(byte ) * 256UL);
#line 183
  map = (byte *)tmp___2;
  }
#line 184
  if ((unsigned long )map == (unsigned long )((byte *)0)) {
    {
#line 185
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 185
      hfs_error = (char const   *)0;
#line 185
      tmp___3 = __errno_location();
#line 185
      *tmp___3 = 12;
      }
#line 185
      goto fail;
#line 185
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 187
  memcpy((void */* __restrict  */)map, (void const   */* __restrict  */)(bt->hdrnd.data + (int )bt->hdrnd.roff[2]),
         (size_t )256);
#line 188
  bt->mapsz = 256UL;
#line 192
  nnum = bt->hdrnd.nd.ndFLink;
  }
  {
#line 194
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 194
    if (! nnum) {
#line 194
      goto while_break___3;
    }
    {
#line 199
    tmp___4 = bt_getnode(& n, bt, nnum);
    }
#line 199
    if (tmp___4 == -1) {
#line 200
      goto fail;
    }
#line 202
    if ((int )n.nd.ndType != 2) {
#line 202
      goto _L___0;
    } else
#line 202
    if ((int )n.nd.ndNRecs != 1) {
#line 202
      goto _L___0;
    } else
#line 202
    if ((int )n.roff[0] != 14) {
#line 202
      goto _L___0;
    } else
#line 202
    if ((int )n.roff[1] != 506) {
      _L___0: /* CIL Label */ 
      {
#line 206
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 206
        hfs_error = "malformed b*-tree map node";
#line 206
        tmp___5 = __errno_location();
#line 206
        *tmp___5 = 5;
        }
#line 206
        goto fail;
#line 206
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 208
    if (map) {
      {
#line 208
      tmp___6 = realloc((void *)map, sizeof(byte ) * (bt->mapsz + 492UL));
#line 208
      tmp___8 = tmp___6;
      }
    } else {
      {
#line 208
      tmp___7 = malloc(sizeof(byte ) * (bt->mapsz + 492UL));
#line 208
      tmp___8 = tmp___7;
      }
    }
#line 208
    newmap = (byte *)tmp___8;
#line 209
    if ((unsigned long )newmap == (unsigned long )((byte *)0)) {
      {
#line 210
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 210
        hfs_error = (char const   *)0;
#line 210
        tmp___9 = __errno_location();
#line 210
        *tmp___9 = 12;
        }
#line 210
        goto fail;
#line 210
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 212
    map = newmap;
#line 214
    memcpy((void */* __restrict  */)(map + bt->mapsz), (void const   */* __restrict  */)(n.data + (int )n.roff[0]),
           (size_t )492);
#line 215
    bt->mapsz += 492UL;
#line 217
    nnum = n.nd.ndFLink;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 220
  bt->map = map;
#line 222
  return (0);
  fail: 
#line 225
  if (map) {
    {
#line 225
    free((void *)map);
    }
  }
#line 226
  return (-1);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_writehdr(btree *bt ) 
{ 
  byte *ptr ;
  byte *map ;
  unsigned long mapsz ;
  unsigned long nnum ;
  int i ;
  int tmp ;
  node n ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 244
  ptr = bt->hdrnd.data + (int )bt->hdrnd.roff[0];
#line 246
  d_storeuw(& ptr, bt->hdr.bthDepth);
#line 247
  d_storeul(& ptr, bt->hdr.bthRoot);
#line 248
  d_storeul(& ptr, bt->hdr.bthNRecs);
#line 249
  d_storeul(& ptr, bt->hdr.bthFNode);
#line 250
  d_storeul(& ptr, bt->hdr.bthLNode);
#line 251
  d_storeuw(& ptr, bt->hdr.bthNodeSize);
#line 252
  d_storeuw(& ptr, bt->hdr.bthKeyLen);
#line 253
  d_storeul(& ptr, bt->hdr.bthNNodes);
#line 254
  d_storeul(& ptr, bt->hdr.bthFree);
#line 256
  i = 0;
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i < 76)) {
#line 256
      goto while_break;
    }
    {
#line 257
    d_storesb(& ptr, bt->hdr.bthResv[i]);
#line 256
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  memcpy((void */* __restrict  */)(bt->hdrnd.data + (int )bt->hdrnd.roff[2]), (void const   */* __restrict  */)bt->map,
         (size_t )256);
#line 261
  tmp = bt_putnode(& bt->hdrnd);
  }
#line 261
  if (tmp == -1) {
#line 262
    goto fail;
  }
#line 264
  map = bt->map + 256;
#line 265
  mapsz = bt->mapsz - 256UL;
#line 267
  nnum = bt->hdrnd.nd.ndFLink;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! mapsz) {
#line 269
      goto while_break___0;
    }
#line 273
    if (nnum == 0UL) {
      {
#line 274
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 274
        hfs_error = "truncated b*-tree map";
#line 274
        tmp___0 = __errno_location();
#line 274
        *tmp___0 = 5;
        }
#line 274
        goto fail;
#line 274
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 276
    tmp___1 = bt_getnode(& n, bt, nnum);
    }
#line 276
    if (tmp___1 == -1) {
#line 277
      goto fail;
    }
#line 279
    if ((int )n.nd.ndType != 2) {
#line 279
      goto _L;
    } else
#line 279
    if ((int )n.nd.ndNRecs != 1) {
#line 279
      goto _L;
    } else
#line 279
    if ((int )n.roff[0] != 14) {
#line 279
      goto _L;
    } else
#line 279
    if ((int )n.roff[1] != 506) {
      _L: /* CIL Label */ 
      {
#line 283
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 283
        hfs_error = "malformed b*-tree map node";
#line 283
        tmp___2 = __errno_location();
#line 283
        *tmp___2 = 5;
        }
#line 283
        goto fail;
#line 283
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 285
    memcpy((void */* __restrict  */)(n.data + (int )n.roff[0]), (void const   */* __restrict  */)map,
           (size_t )492);
#line 287
    tmp___3 = bt_putnode(& n);
    }
#line 287
    if (tmp___3 == -1) {
#line 288
      goto fail;
    }
#line 290
    map += 492;
#line 291
    mapsz -= 492UL;
#line 293
    nnum = n.nd.ndFLink;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 296
  bt->flags &= -2;
#line 298
  return (0);
  fail: 
#line 301
  return (-1);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_space(btree *bt , unsigned int nrecs ) 
{ 
  unsigned int nnodes ;
  long space ;
  int tmp ;
  byte *newmap ;
  node mapnd ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  node n ;
  unsigned long nnum ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 315
  nnodes = nrecs * (unsigned int )((int )bt->hdr.bthDepth + 1);
#line 317
  if ((ULongInt )nnodes <= bt->hdr.bthFree) {
#line 318
    goto done;
  }
#line 322
  if ((unsigned long )bt != (unsigned long )(& (bt->f.vol)->ext)) {
    {
#line 324
    tmp = bt_space(& (bt->f.vol)->ext, 1U);
    }
#line 324
    if (tmp == -1) {
#line 325
      goto fail;
    }
  }
  {
#line 328
  space = f_alloc(& bt->f);
  }
#line 329
  if (space == -1L) {
#line 330
    goto fail;
  }
#line 332
  nnodes = (unsigned int )((ULongInt )space * ((bt->f.vol)->mdb.drAlBlkSiz / (ULongInt )bt->hdr.bthNodeSize));
#line 334
  bt->hdr.bthNNodes += (ULongInt )nnodes;
#line 335
  bt->hdr.bthFree += (ULongInt )nnodes;
#line 337
  bt->flags |= 1;
#line 339
  (bt->f.vol)->flags |= 32;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (bt->hdr.bthNNodes > bt->mapsz * 8UL)) {
#line 341
      goto while_break;
    }
#line 348
    if (bt->map) {
      {
#line 348
      tmp___0 = realloc((void *)bt->map, sizeof(byte ) * (bt->mapsz + 492UL));
#line 348
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 348
      tmp___1 = malloc(sizeof(byte ) * (bt->mapsz + 492UL));
#line 348
      tmp___2 = tmp___1;
      }
    }
#line 348
    newmap = (byte *)tmp___2;
#line 349
    if ((unsigned long )newmap == (unsigned long )((byte *)0)) {
      {
#line 350
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 350
        hfs_error = (char const   *)0;
#line 350
        tmp___3 = __errno_location();
#line 350
        *tmp___3 = 12;
        }
#line 350
        goto fail;
#line 350
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 352
    memset((void *)(newmap + bt->mapsz), 0, (size_t )492);
#line 354
    bt->map = newmap;
#line 355
    bt->mapsz += 492UL;
#line 357
    n_init(& mapnd, bt, 2, 0);
#line 358
    tmp___4 = n_new(& mapnd);
    }
#line 358
    if (tmp___4 == -1) {
#line 359
      goto fail;
    }
#line 361
    mapnd.nd.ndNRecs = (UInteger )1;
#line 362
    mapnd.roff[1] = (UInteger )506;
#line 366
    if (bt->hdrnd.nd.ndFLink == 0UL) {
#line 368
      bt->hdrnd.nd.ndFLink = mapnd.nnum;
#line 369
      mapnd.nd.ndBLink = (ULongInt )0;
    } else {
#line 376
      nnum = bt->hdrnd.nd.ndFLink;
      {
#line 378
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 380
        tmp___5 = bt_getnode(& n, bt, nnum);
        }
#line 380
        if (tmp___5 == -1) {
#line 381
          goto fail;
        }
#line 383
        if (n.nd.ndFLink == 0UL) {
#line 384
          goto while_break___1;
        }
#line 386
        nnum = n.nd.ndFLink;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 389
      n.nd.ndFLink = mapnd.nnum;
#line 390
      mapnd.nd.ndBLink = n.nnum;
#line 392
      tmp___6 = bt_putnode(& n);
      }
#line 392
      if (tmp___6 == -1) {
#line 393
        goto fail;
      }
    }
    {
#line 396
    tmp___7 = bt_putnode(& mapnd);
    }
#line 396
    if (tmp___7 == -1) {
#line 397
      goto fail;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 401
  return (0);
  fail: 
#line 404
  return (-1);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
static int insertx(node *np , byte *record , int *reclen ) 
{ 
  node child ;
  byte *rec ;
  int result ;
  int *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 416
  result = 0;
#line 418
  tmp___0 = n_search(np, (byte const   *)record);
  }
#line 418
  if (tmp___0) {
    {
#line 419
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 419
      hfs_error = "b*-tree record already exists";
#line 419
      tmp = __errno_location();
#line 419
      *tmp = 5;
      }
#line 419
      goto fail;
#line 419
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 423
  if ((int )np->nd.ndType == 0) {
#line 423
    goto case_0;
  }
#line 448
  if ((int )np->nd.ndType == -1) {
#line 448
    goto case_neg_1;
  }
#line 452
  goto switch_default;
  case_0: /* CIL Label */ 
#line 424
  if (np->rnum == -1) {
#line 425
    rec = np->data + (int )np->roff[0];
  } else {
#line 427
    rec = np->data + (int )np->roff[np->rnum];
  }
  {
#line 429
  tmp___1 = d_getul((unsigned char const   *)(rec + (size_t )(((1 + (int )*((byte const   *)rec)) + 1) & -2)));
#line 429
  tmp___2 = bt_getnode(& child, np->bt, tmp___1);
  }
#line 429
  if (tmp___2 == -1) {
#line 431
    goto fail;
  } else {
    {
#line 429
    tmp___3 = insertx(& child, record, reclen);
    }
#line 429
    if (tmp___3 == -1) {
#line 431
      goto fail;
    }
  }
#line 433
  if (np->rnum == -1) {
    {
#line 435
    n_index((node const   *)(& child), rec, (unsigned int *)0);
    }
#line 436
    if (*reclen == 0) {
      {
#line 438
      result = bt_putnode(np);
      }
#line 439
      goto done;
    }
  }
#line 443
  if (*reclen) {
    {
#line 444
    result = n_insert(np, record, (unsigned int *)reclen);
    }
  }
#line 446
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 449
  result = n_insert(np, record, (unsigned int *)reclen);
  }
#line 450
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 453
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 453
    hfs_error = "unexpected b*-tree node";
#line 453
    tmp___4 = __errno_location();
#line 453
    *tmp___4 = 5;
    }
#line 453
    goto fail;
#line 453
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  done: 
#line 457
  return (result);
  fail: 
#line 460
  return (-1);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_insert(btree *bt , byte const   *record , unsigned int reclen ) 
{ 
  node root ;
  byte newrec[sizeof(CatKeyRec ) + sizeof(CatDataRec )] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  byte oroot[sizeof(CatKeyRec ) + sizeof(CatDataRec )] ;
  unsigned int orootlen ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 472
  if (bt->hdr.bthRoot == 0UL) {
    {
#line 476
    n_init(& root, bt, -1, 1);
#line 477
    tmp = n_new(& root);
    }
#line 477
    if (tmp == -1) {
#line 479
      goto fail;
    } else {
      {
#line 477
      tmp___0 = bt_putnode(& root);
      }
#line 477
      if (tmp___0 == -1) {
#line 479
        goto fail;
      }
    }
#line 481
    bt->hdr.bthDepth = (UInteger )1;
#line 482
    bt->hdr.bthRoot = root.nnum;
#line 483
    bt->hdr.bthFNode = root.nnum;
#line 484
    bt->hdr.bthLNode = root.nnum;
#line 486
    bt->flags |= 1;
  } else {
    {
#line 488
    tmp___1 = bt_getnode(& root, bt, bt->hdr.bthRoot);
    }
#line 488
    if (tmp___1 == -1) {
#line 489
      goto fail;
    }
  }
  {
#line 491
  memcpy((void */* __restrict  */)(newrec), (void const   */* __restrict  */)record,
         (size_t )reclen);
#line 493
  tmp___2 = insertx(& root, newrec, (int *)(& reclen));
  }
#line 493
  if (tmp___2 == -1) {
#line 494
    goto fail;
  }
#line 496
  if (reclen) {
    {
#line 503
    n_index((node const   *)(& root), oroot, & orootlen);
#line 505
    n_init(& root, bt, 0, (int )root.nd.ndNHeight + 1);
#line 506
    tmp___3 = n_new(& root);
    }
#line 506
    if (tmp___3 == -1) {
#line 507
      goto fail;
    }
    {
#line 509
    bt->hdr.bthDepth = (UInteger )((int )bt->hdr.bthDepth + 1);
#line 510
    bt->hdr.bthRoot = root.nnum;
#line 512
    bt->flags |= 1;
#line 516
    n_search(& root, (byte const   *)(oroot));
#line 517
    n_insertx(& root, (byte const   *)(oroot), orootlen);
#line 519
    n_search(& root, (byte const   *)(newrec));
#line 520
    n_insertx(& root, (byte const   *)(newrec), reclen);
#line 522
    tmp___4 = bt_putnode(& root);
    }
#line 522
    if (tmp___4 == -1) {
#line 523
      goto fail;
    }
  }
#line 526
  (bt->hdr.bthNRecs) ++;
#line 527
  bt->flags |= 1;
#line 529
  return (0);
  fail: 
#line 532
  return (-1);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
static int deletex(node *np , byte const   *key , byte *record , int *flag ) 
{ 
  node child ;
  byte *rec ;
  int found ;
  int result ;
  int *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 544
  result = 0;
#line 546
  found = n_search(np, key);
  }
  {
#line 550
  if ((int )np->nd.ndType == 0) {
#line 550
    goto case_0;
  }
#line 583
  if ((int )np->nd.ndType == -1) {
#line 583
    goto case_neg_1;
  }
#line 590
  goto switch_default;
  case_0: /* CIL Label */ 
#line 551
  if (np->rnum == -1) {
    {
#line 552
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 552
      hfs_error = "b*-tree record not found";
#line 552
      tmp = __errno_location();
#line 552
      *tmp = 5;
      }
#line 552
      goto fail;
#line 552
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 554
  rec = np->data + (int )np->roff[np->rnum];
#line 556
  tmp___0 = d_getul((unsigned char const   *)(rec + (size_t )(((1 + (int )*((byte const   *)rec)) + 1) & -2)));
#line 556
  tmp___1 = bt_getnode(& child, np->bt, tmp___0);
  }
#line 556
  if (tmp___1 == -1) {
#line 558
    goto fail;
  } else {
    {
#line 556
    tmp___2 = deletex(& child, key, rec, flag);
    }
#line 556
    if (tmp___2 == -1) {
#line 558
      goto fail;
    }
  }
#line 560
  if (*flag) {
#line 562
    *flag = 0;
#line 564
    if ((int const   )*((byte const   *)rec) == 0) {
      {
#line 566
      result = n_delete(np, record, flag);
      }
#line 567
      goto switch_break;
    }
#line 570
    if (np->rnum == 0) {
      {
#line 574
      n_index((node const   *)np, record, (unsigned int *)0);
#line 575
      *flag = 1;
      }
    }
    {
#line 578
    result = bt_putnode(np);
    }
  }
#line 581
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 584
  if (found == 0) {
    {
#line 585
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 585
      hfs_error = "b*-tree record not found";
#line 585
      tmp___3 = __errno_location();
#line 585
      *tmp___3 = 5;
      }
#line 585
      goto fail;
#line 585
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 587
  result = n_delete(np, record, flag);
  }
#line 588
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 591
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 591
    hfs_error = "unexpected b*-tree node";
#line 591
    tmp___4 = __errno_location();
#line 591
    *tmp___4 = 5;
    }
#line 591
    goto fail;
#line 591
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 594
  return (result);
  fail: 
#line 597
  return (-1);
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_delete(btree *bt , byte const   *key ) 
{ 
  node root ;
  byte record[sizeof(CatKeyRec ) + sizeof(CatDataRec )] ;
  int flag ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  byte const   *rec ;
  int tmp___2 ;

  {
#line 608
  flag = 0;
#line 610
  if (bt->hdr.bthRoot == 0UL) {
    {
#line 611
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 611
      hfs_error = "empty b*-tree";
#line 611
      tmp = __errno_location();
#line 611
      *tmp = 5;
      }
#line 611
      goto fail;
#line 611
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 613
  tmp___0 = bt_getnode(& root, bt, bt->hdr.bthRoot);
  }
#line 613
  if (tmp___0 == -1) {
#line 615
    goto fail;
  } else {
    {
#line 613
    tmp___1 = deletex(& root, key, record, & flag);
    }
#line 613
    if (tmp___1 == -1) {
#line 615
      goto fail;
    }
  }
#line 617
  if ((int )bt->hdr.bthDepth > 1) {
#line 617
    if ((int )root.nd.ndNRecs == 1) {
      {
#line 623
      rec = (byte const   *)(root.data + (int )root.roff[0]);
#line 625
      bt->hdr.bthDepth = (UInteger )((int )bt->hdr.bthDepth - 1);
#line 626
      bt->hdr.bthRoot = d_getul(rec + (size_t )(((1 + (int )*rec) + 1) & -2));
#line 628
      tmp___2 = n_free(& root);
      }
#line 628
      if (tmp___2 == -1) {
#line 629
        goto fail;
      }
    } else {
#line 617
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 631
  if ((int )bt->hdr.bthDepth == 1) {
#line 631
    if ((int )root.nd.ndNRecs == 0) {
#line 635
      bt->hdr.bthDepth = (UInteger )0;
#line 636
      bt->hdr.bthRoot = (ULongInt )0;
    }
  }
#line 639
  (bt->hdr.bthNRecs) --;
#line 640
  bt->flags |= 1;
#line 642
  return (0);
  fail: 
#line 645
  return (-1);
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/btree.c"
int bt_search(btree *bt , byte const   *key , node *np ) 
{ 
  int found ;
  unsigned long nnum ;
  int *tmp ;
  byte const   *rec ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 654
  found = 0;
#line 657
  nnum = bt->hdr.bthRoot;
#line 659
  if (nnum == 0UL) {
    {
#line 660
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 660
      hfs_error = (char const   *)0;
#line 660
      tmp = __errno_location();
#line 660
      *tmp = 2;
      }
#line 660
      goto done;
#line 660
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 662
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 666
    tmp___0 = bt_getnode(np, bt, nnum);
    }
#line 666
    if (tmp___0 == -1) {
#line 668
      found = -1;
#line 669
      goto done;
    }
    {
#line 672
    found = n_search(np, key);
    }
    {
#line 676
    if ((int )np->nd.ndType == 0) {
#line 676
      goto case_0;
    }
#line 685
    if ((int )np->nd.ndType == -1) {
#line 685
      goto case_neg_1;
    }
#line 691
    goto switch_default;
    case_0: /* CIL Label */ 
#line 677
    if (np->rnum == -1) {
      {
#line 678
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 678
        hfs_error = (char const   *)0;
#line 678
        tmp___1 = __errno_location();
#line 678
        *tmp___1 = 2;
        }
#line 678
        goto done;
#line 678
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 680
    rec = (byte const   *)(np->data + (int )np->roff[np->rnum]);
#line 681
    nnum = d_getul(rec + (size_t )(((1 + (int )*rec) + 1) & -2));
    }
#line 683
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 686
    if (! found) {
      {
#line 687
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 687
        hfs_error = (char const   *)0;
#line 687
        tmp___2 = __errno_location();
#line 687
        *tmp___2 = 2;
        }
#line 687
        goto done;
#line 687
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 689
    goto done;
    switch_default: /* CIL Label */ 
#line 692
    found = -1;
    {
#line 693
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 693
      hfs_error = "unexpected b*-tree node";
#line 693
      tmp___3 = __errno_location();
#line 693
      *tmp___3 = 5;
      }
#line 693
      goto done;
#line 693
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
#line 699
  return (found);
}
}
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int usage___0(void) 
{ 


  {
  {
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [options] [hfs-path ...]\n",
          argv0);
  }
#line 104
  return (1);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void dpfree(queueent *ent ) 
{ 


  {
  {
#line 114
  free((void *)ent->path);
  }
#line 115
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static darray *qnew(void) 
{ 
  darray *tmp ;

  {
  {
#line 124
  tmp = darr_new(sizeof(queueent ));
  }
#line 124
  return (tmp);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void qfree(darray *array ) 
{ 
  int i ;
  int sz ;
  queueent *ents ;
  unsigned int tmp ;
  void *tmp___0 ;

  {
  {
#line 137
  tmp = darr_size(array);
#line 137
  sz = (int )tmp;
#line 138
  tmp___0 = darr_array(array);
#line 138
  ents = (queueent *)tmp___0;
#line 140
  i = 0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < sz)) {
#line 140
      goto while_break;
    }
#line 141
    if ((ents + i)->free) {
      {
#line 142
      (*((ents + i)->free))(ents + i);
      }
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  darr_free(array);
  }
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int reverse  ;
#line 154 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int compare_names(queueent const   *ent1 , queueent const   *ent2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 157
  if (ent2->path) {
#line 157
    tmp = ent2->path;
  } else {
#line 157
    tmp = ent2->dirent.name;
  }
#line 157
  if (ent1->path) {
#line 157
    tmp___0 = ent1->path;
  } else {
#line 157
    tmp___0 = ent1->dirent.name;
  }
  {
#line 157
  tmp___1 = strcasecmp((char const   *)tmp___0, (char const   *)tmp);
  }
#line 157
  return (reverse * tmp___1);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int compare_mtimes(queueent const   *ent1 , queueent const   *ent2 ) 
{ 


  {
#line 167
  return ((int )((time_t const   )reverse * (ent2->dirent.mddate - ent1->dirent.mddate)));
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int compare_ctimes(queueent const   *ent1 , queueent const   *ent2 ) 
{ 


  {
#line 177
  return ((int )((time_t const   )reverse * (ent2->dirent.crdate - ent1->dirent.crdate)));
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int compare_sizes(queueent const   *ent1 , queueent const   *ent2 ) 
{ 


  {
#line 187
  return ((int )((unsigned long const   )reverse * ((ent2->dirent.u.file.dsize + ent2->dirent.u.file.rsize) - (ent1->dirent.u.file.dsize + ent1->dirent.u.file.rsize))));
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void sortfiles(darray *files , int flags , int options ) 
{ 
  int (*compare___1)(queueent const   * , queueent const   * ) ;

  {
  {
#line 203
  if ((options & 48) == 0) {
#line 203
    goto case_0;
  }
#line 207
  if ((options & 48) == 16) {
#line 207
    goto case_16;
  }
#line 223
  if ((options & 48) == 32) {
#line 223
    goto case_32;
  }
#line 227
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 204
  compare___1 = & compare_names;
#line 205
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 210
  if ((options & 8) == 0) {
#line 210
    goto case_0___0;
  }
#line 214
  if ((options & 8) == 8) {
#line 214
    goto case_8;
  }
#line 218
  goto switch_default;
  case_0___0: /* CIL Label */ 
#line 211
  compare___1 = & compare_mtimes;
#line 212
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 215
  compare___1 = & compare_ctimes;
#line 216
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 219
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 221
  goto switch_break;
  case_32: /* CIL Label */ 
#line 224
  compare___1 = & compare_sizes;
#line 225
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 228
  return;
  switch_break: /* CIL Label */ ;
  }
#line 231
  if (flags & 64) {
#line 231
    reverse = -1;
  } else {
#line 231
    reverse = 1;
  }
  {
#line 233
  darr_sort(files, (int (*)(void const   * , void const   * ))compare___1);
  }
#line 234
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int outpath(dstring *str , queueent *ent , int flags ) 
{ 
  char const   *path ;
  int tmp ;
  char const   *ptr ;
  char const   *add ;
  char buf[5] ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char c ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 245
  if (ent->path) {
#line 245
    path = (char const   *)ent->path;
  } else {
#line 245
    path = (char const   *)(ent->dirent.name);
  }
  {
#line 247
  dstr_shrink(str, (size_t )0);
  }
#line 249
  if (flags & 4) {
    {
#line 249
    tmp = dstr_append(str, "\"", (size_t )1);
    }
#line 249
    if (tmp == -1) {
#line 251
      return (-1);
    }
  }
#line 253
  if (flags & 14) {
#line 257
    ptr = path;
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 257
      if (! *ptr) {
#line 257
        goto while_break;
      }
#line 262
      if (flags & 2) {
        {
#line 266
        if ((int const   )*ptr == 92) {
#line 266
          goto case_92;
        }
#line 270
        if ((int const   )*ptr == 10) {
#line 270
          goto case_10;
        }
#line 274
        if ((int const   )*ptr == 8) {
#line 274
          goto case_8;
        }
#line 278
        if ((int const   )*ptr == 13) {
#line 278
          goto case_13;
        }
#line 282
        if ((int const   )*ptr == 9) {
#line 282
          goto case_9;
        }
#line 286
        if ((int const   )*ptr == 12) {
#line 286
          goto case_12;
        }
#line 290
        if ((int const   )*ptr == 32) {
#line 290
          goto case_32;
        }
#line 294
        if ((int const   )*ptr == 34) {
#line 294
          goto case_34;
        }
#line 298
        goto switch_default;
        case_92: /* CIL Label */ 
#line 267
        add = "\\\\";
#line 268
        goto switch_break;
        case_10: /* CIL Label */ 
#line 271
        add = "\\n";
#line 272
        goto switch_break;
        case_8: /* CIL Label */ 
#line 275
        add = "\\b";
#line 276
        goto switch_break;
        case_13: /* CIL Label */ 
#line 279
        add = "\\r";
#line 280
        goto switch_break;
        case_9: /* CIL Label */ 
#line 283
        add = "\\t";
#line 284
        goto switch_break;
        case_12: /* CIL Label */ 
#line 287
        add = "\\f";
#line 288
        goto switch_break;
        case_32: /* CIL Label */ 
#line 291
        add = "\\ ";
#line 292
        goto switch_break;
        case_34: /* CIL Label */ 
#line 295
        add = "\\\"";
#line 296
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 299
        tmp___0 = __ctype_b_loc();
        }
#line 299
        if ((int const   )*(*tmp___0 + (int )*ptr) & 32768) {
          {
#line 301
          sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%c",
                  (int const   )*ptr);
#line 302
          add = (char const   *)(buf);
          }
        } else {
          {
#line 306
          sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\\%03o",
                  (int )((unsigned char )*ptr));
#line 307
          add = (char const   *)(buf);
          }
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 313
        tmp___1 = __ctype_b_loc();
        }
#line 313
        if ((int const   )*(*tmp___1 + (int )*ptr) & 16384) {
          {
#line 315
          sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%c",
                  (int const   )*ptr);
#line 316
          add = (char const   *)(buf);
          }
        } else
#line 313
        if (! (flags & 8)) {
          {
#line 315
          sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%c",
                  (int const   )*ptr);
#line 316
          add = (char const   *)(buf);
          }
        } else {
          {
#line 320
          sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"?");
#line 321
          add = (char const   *)(buf);
          }
        }
      }
      {
#line 325
      tmp___2 = dstr_append(str, add, (size_t )-1);
      }
#line 325
      if (tmp___2 == -1) {
#line 326
        return (-1);
      }
#line 257
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 331
    tmp___3 = dstr_append(str, path, (size_t )-1);
    }
#line 331
    if (tmp___3 == -1) {
#line 332
      return (-1);
    }
  }
#line 335
  if (flags & 4) {
    {
#line 335
    tmp___4 = dstr_append(str, "\"", (size_t )1);
    }
#line 335
    if (tmp___4 == -1) {
#line 337
      return (-1);
    }
  }
#line 339
  if (flags & 256) {
#line 341
    c = (char)0;
#line 343
    if (ent->dirent.flags & 1) {
#line 344
      c = (char )':';
    } else {
      {
#line 345
      tmp___5 = strcmp((char const   *)(ent->dirent.u.file.type), "APPL");
      }
#line 345
      if (tmp___5 == 0) {
#line 346
        c = (char )'*';
      }
    }
#line 348
    if (c) {
      {
#line 348
      tmp___6 = dstr_append(str, (char const   *)(& c), (size_t )1);
      }
#line 348
      if (tmp___6 == -1) {
#line 349
        return (-1);
      }
    }
  }
#line 352
  return (0);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int misclen(int flags ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 362
  if (flags & 32) {
#line 362
    tmp = 8;
  } else {
#line 362
    tmp = 0;
  }
#line 362
  if (flags & 128) {
#line 362
    tmp___0 = 5;
  } else {
#line 362
    tmp___0 = 0;
  }
#line 362
  return (tmp + tmp___0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void showmisc(hfsdirent *ent , int flags ) 
{ 
  unsigned long size ;

  {
#line 375
  size = ent->u.file.rsize + ent->u.file.dsize;
#line 377
  if (flags & 32) {
    {
#line 378
    printf((char const   */* __restrict  */)"%7lu ", ent->cnid);
    }
  }
#line 379
  if (flags & 128) {
    {
#line 380
    printf((char const   */* __restrict  */)"%4lu ", size / 1024UL + (unsigned long )(size % 1024UL != 0UL));
    }
  }
#line 381
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void show_long(int sz , queueent *ents , char **strs , int flags , int options ,
                      int width ) 
{ 
  int i ;
  time_t now ;
  hfsdirent *ent ;
  time_t when ;
  char timebuf[26] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 394
  now = time((time_t *)0);
#line 396
  i = 0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (i < sz)) {
#line 396
      goto while_break;
    }
#line 402
    ent = & (ents + i)->dirent;
    {
#line 406
    if ((options & 8) == 0) {
#line 406
      goto case_0;
    }
#line 410
    if ((options & 8) == 8) {
#line 410
      goto case_8;
    }
#line 414
    goto switch_default;
    case_0: /* CIL Label */ 
#line 407
    when = ent->mddate;
#line 408
    goto switch_break;
    case_8: /* CIL Label */ 
#line 411
    when = ent->crdate;
#line 412
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 415
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 418
    tmp = ctime((time_t const   *)(& when));
#line 418
    strcpy((char */* __restrict  */)(timebuf), (char const   */* __restrict  */)tmp);
    }
#line 420
    if (now > when + 15552000L) {
      {
#line 422
      strcpy((char */* __restrict  */)(timebuf + 11), (char const   */* __restrict  */)(timebuf + 19));
      }
    } else
#line 420
    if (now < when - 3600L) {
      {
#line 422
      strcpy((char */* __restrict  */)(timebuf + 11), (char const   */* __restrict  */)(timebuf + 19));
      }
    }
    {
#line 424
    timebuf[16] = (char)0;
#line 426
    showmisc(ent, flags);
    }
#line 428
    if (ent->flags & 1) {
#line 429
      if ((int )ent->u.dir.valence == 1) {
#line 429
        tmp___0 = ' ';
      } else {
#line 429
        tmp___0 = 's';
      }
#line 429
      if ((int )ent->fdflags & (1 << 14)) {
#line 429
        tmp___1 = 'i';
      } else {
#line 429
        tmp___1 = ' ';
      }
      {
#line 429
      printf((char const   */* __restrict  */)"d%c %9u item%c               %s %s\n",
             tmp___1, (int )ent->u.dir.valence, tmp___0, timebuf + 4, *(strs + i));
      }
    } else {
#line 434
      if ((int )ent->fdflags & (1 << 14)) {
#line 434
        tmp___2 = 'i';
      } else {
#line 434
        tmp___2 = ' ';
      }
#line 434
      if (ent->flags & 2) {
#line 434
        tmp___3 = 'F';
      } else {
#line 434
        tmp___3 = 'f';
      }
      {
#line 434
      printf((char const   */* __restrict  */)"%c%c %4s/%4s %9lu %9lu %s %s\n", tmp___3,
             tmp___2, ent->u.file.type, ent->u.file.creator, ent->u.file.rsize, ent->u.file.dsize,
             timebuf + 4, *(strs + i));
      }
    }
#line 396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void show_one(int sz , queueent *ents , char **strs , int flags , int options ,
                     int width ) 
{ 
  int i ;

  {
#line 453
  i = 0;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (i < sz)) {
#line 453
      goto while_break;
    }
    {
#line 455
    showmisc(& (ents + i)->dirent, flags);
#line 456
    printf((char const   */* __restrict  */)"%s\n", *(strs + i));
#line 453
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void show_many(int sz , queueent *ents , char **strs , int flags , int options ,
                      int width ) 
{ 
  int i ;
  int len ;
  int misc ;
  int maxlen ;
  int rows ;
  int cols ;
  int row ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 468
  maxlen = 0;
#line 470
  misc = misclen(flags);
#line 472
  i = 0;
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (i < sz)) {
#line 472
      goto while_break;
    }
    {
#line 474
    tmp = strlen((char const   *)*(strs + i));
#line 474
    len = (int )(tmp + (size_t )misc);
    }
#line 475
    if (len > maxlen) {
#line 476
      maxlen = len;
    }
#line 472
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  maxlen += 2;
#line 481
  cols = width / maxlen;
#line 482
  if (cols == 0) {
#line 483
    cols = 1;
  }
#line 485
  rows = sz / cols + (sz % cols != 0);
#line 487
  row = 0;
  {
#line 487
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 487
    if (! (row < rows)) {
#line 487
      goto while_break___0;
    }
#line 489
    i = row;
    {
#line 491
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 493
      showmisc(& (ents + i)->dirent, flags);
#line 494
      printf((char const   */* __restrict  */)"%s", *(strs + i));
#line 496
      i += rows;
      }
#line 497
      if (i >= sz) {
#line 498
        goto while_break___1;
      }
      {
#line 500
      tmp___0 = strlen((char const   *)*(strs + (i - rows)));
#line 500
      len = (int )(tmp___0 + (size_t )misc);
      }
      {
#line 500
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 500
        if (! (len < maxlen)) {
#line 500
          goto while_break___2;
        }
        {
#line 502
        putchar(' ');
#line 500
        len ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 505
    putchar('\n');
#line 487
    row ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 507
  return;
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void show_horiz(int sz , queueent *ents , char **strs , int flags , int options ,
                       int width ) 
{ 
  int i ;
  int len ;
  int misc ;
  int maxlen ;
  int cols ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 517
  maxlen = 0;
#line 519
  misc = misclen(flags);
#line 521
  i = 0;
  }
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    if (! (i < sz)) {
#line 521
      goto while_break;
    }
    {
#line 523
    tmp = strlen((char const   *)*(strs + i));
#line 523
    len = (int )(tmp + (size_t )misc);
    }
#line 524
    if (len > maxlen) {
#line 525
      maxlen = len;
    }
#line 521
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  maxlen += 2;
#line 530
  cols = width / maxlen;
#line 531
  if (cols == 0) {
#line 532
    cols = 1;
  }
#line 534
  i = 0;
  {
#line 534
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 534
    if (! (i < sz)) {
#line 534
      goto while_break___0;
    }
#line 536
    if (i) {
#line 538
      if (i % cols == 0) {
        {
#line 539
        putchar('\n');
        }
      } else {
        {
#line 542
        tmp___0 = strlen((char const   *)*(strs + (i - 1)));
#line 542
        len = (int )(tmp___0 + (size_t )misc);
        }
        {
#line 542
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 542
          if (! (len < maxlen)) {
#line 542
            goto while_break___1;
          }
          {
#line 544
          putchar(' ');
#line 542
          len ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    {
#line 548
    showmisc(& (ents + i)->dirent, flags);
#line 549
    printf((char const   */* __restrict  */)"%s", *(strs + i));
#line 534
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 552
  if (i) {
    {
#line 553
    putchar('\n');
    }
  }
#line 554
  return;
}
}
#line 560 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static void show_commas(int sz , queueent *ents , char **strs , int flags , int options ,
                        int width ) 
{ 
  int i ;
  int pos ;
  hfsdirent *ent ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 564
  pos = 0;
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < sz)) {
#line 566
      goto while_break;
    }
    {
#line 571
    ent = & (ents + i)->dirent;
#line 572
    tmp = strlen((char const   *)*(strs + i));
#line 572
    tmp___0 = misclen(flags);
    }
#line 572
    if (i < sz - 1) {
#line 572
      tmp___1 = 2;
    } else {
#line 572
      tmp___1 = 0;
    }
#line 572
    len = (int )((tmp + (size_t )tmp___0) + (size_t )tmp___1);
#line 574
    if (pos) {
#line 574
      if (pos + len >= width) {
        {
#line 576
        putchar('\n');
#line 577
        pos = 0;
        }
      }
    }
    {
#line 580
    showmisc(ent, flags);
#line 581
    printf((char const   */* __restrict  */)"%s", *(strs + i));
    }
#line 583
    if (i < sz - 1) {
      {
#line 585
      putchar(',');
#line 586
      putchar(' ');
      }
    }
#line 589
    pos += len;
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  if (pos) {
    {
#line 593
    putchar('\n');
    }
  }
#line 594
  return;
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int showfiles(darray *files , int flags , int options , int width ) 
{ 
  dlist list ;
  int i ;
  int sz ;
  int result ;
  queueent *ents ;
  dstring str ;
  char **strs ;
  void (*show)(int  , queueent * , char ** , int  , int  , int  ) ;
  int tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 604
  result = 0;
#line 610
  tmp = dl_init(& list);
  }
#line 610
  if (tmp == -1) {
    {
#line 612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
            argv0);
    }
#line 613
    return (-1);
  }
  {
#line 616
  tmp___0 = darr_size(files);
#line 616
  sz = (int )tmp___0;
#line 617
  tmp___1 = darr_array(files);
#line 617
  ents = (queueent *)tmp___1;
#line 619
  dstr_init(& str);
#line 621
  i = 0;
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if (! (i < sz)) {
#line 621
      goto while_break;
    }
    {
#line 623
    tmp___2 = outpath(& str, ents + i, flags);
    }
#line 623
    if (tmp___2 == -1) {
#line 626
      result = -1;
#line 627
      goto while_break;
    } else {
      {
#line 623
      tmp___3 = dstr_string(& str);
#line 623
      tmp___4 = dl_append(& list, (char const   *)tmp___3);
      }
#line 623
      if (tmp___4 == -1) {
#line 626
        result = -1;
#line 627
        goto while_break;
      }
    }
#line 621
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 631
  dstr_free(& str);
#line 633
  strs = dl_array(& list);
  }
  {
#line 637
  if ((options & 7) == 0) {
#line 637
    goto case_0;
  }
#line 641
  if ((options & 7) == 1) {
#line 641
    goto case_1;
  }
#line 645
  if ((options & 7) == 2) {
#line 645
    goto case_2;
  }
#line 649
  if ((options & 7) == 3) {
#line 649
    goto case_3;
  }
#line 653
  if ((options & 7) == 4) {
#line 653
    goto case_4;
  }
#line 657
  goto switch_default;
  case_0: /* CIL Label */ 
#line 638
  show = & show_long;
#line 639
  goto switch_break;
  case_1: /* CIL Label */ 
#line 642
  show = & show_one;
#line 643
  goto switch_break;
  case_2: /* CIL Label */ 
#line 646
  show = & show_many;
#line 647
  goto switch_break;
  case_3: /* CIL Label */ 
#line 650
  show = & show_horiz;
#line 651
  goto switch_break;
  case_4: /* CIL Label */ 
#line 654
  show = & show_commas;
#line 655
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 658
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 661
  (*show)(sz, ents, strs, flags, options, width);
#line 663
  dl_free(& list);
  }
#line 665
  return (result);
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int process(hfsvol *vol , darray *dirs , darray *files , int flags , int options ,
                   int width ) 
{ 
  int i ;
  int dsz ;
  int fsz ;
  queueent *ents ;
  int result ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char const   *path ;
  hfsdir *dir ;
  queueent ent ;
  void *tmp___3 ;
  dstring str ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  unsigned int tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;

  {
  {
#line 678
  result = 0;
#line 680
  tmp = darr_size(dirs);
#line 680
  dsz = (int )tmp;
#line 681
  tmp___0 = darr_size(files);
#line 681
  fsz = (int )tmp___0;
  }
#line 683
  if (fsz) {
    {
#line 685
    sortfiles(files, flags, options);
#line 686
    tmp___1 = showfiles(files, flags, options, width);
    }
#line 686
    if (tmp___1 == -1) {
#line 687
      result = -1;
    }
#line 689
    flags |= 3072;
  } else
#line 691
  if (dsz > 1) {
#line 692
    flags |= 1024;
  }
  {
#line 694
  tmp___2 = darr_array(dirs);
#line 694
  ents = (queueent *)tmp___2;
#line 696
  i = 0;
  }
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    if (! (i < dsz)) {
#line 696
      goto while_break;
    }
    {
#line 702
    darr_shrink(files, 0U);
    }
#line 704
    if ((ents + i)->path) {
#line 704
      path = (char const   *)(ents + i)->path;
    } else {
#line 704
      path = (char const   *)((ents + i)->dirent.name);
    }
    {
#line 705
    dir = hfs_opendir(vol, path);
    }
#line 706
    if ((unsigned long )dir == (unsigned long )((hfsdir *)0)) {
      {
#line 708
      hfsutil_perrorp(path);
#line 709
      result = -1;
      }
#line 710
      goto __Cont;
    }
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 713
      tmp___14 = hfs_readdir(dir, & ent.dirent);
      }
#line 713
      if (! (tmp___14 != -1)) {
#line 713
        goto while_break___0;
      }
#line 715
      if ((int )ent.dirent.fdflags & (1 << 14)) {
#line 715
        if (! (flags & 1)) {
#line 717
          goto while_continue___0;
        }
      }
      {
#line 719
      ent.path = (char *)0;
#line 720
      ent.free = (void (*)(struct _queueent_ * ))0;
#line 722
      tmp___3 = darr_append(files, (void *)(& ent));
      }
#line 722
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
        {
#line 724
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
                argv0);
#line 725
        result = -1;
        }
#line 726
        goto while_break___0;
      }
#line 729
      if (ent.dirent.flags & 1) {
#line 729
        if (flags & 512) {
          {
#line 733
          dstr_init(& str);
#line 735
          tmp___4 = strchr(path, ':');
          }
#line 735
          if ((unsigned long )tmp___4 == (unsigned long )((char *)0)) {
            {
#line 735
            tmp___5 = dstr_append(& str, ":", (size_t )1);
            }
#line 735
            if (tmp___5 == -1) {
#line 737
              result = -1;
            }
          }
          {
#line 739
          tmp___6 = dstr_append(& str, path, (size_t )-1);
          }
#line 739
          if (tmp___6 == -1) {
#line 740
            result = -1;
          }
          {
#line 742
          tmp___7 = strlen(path);
          }
#line 742
          if ((int const   )*(path + (tmp___7 - 1UL)) != 58) {
            {
#line 742
            tmp___8 = dstr_append(& str, ":", (size_t )1);
            }
#line 742
            if (tmp___8 == -1) {
#line 744
              result = -1;
            }
          }
          {
#line 746
          tmp___9 = dstr_append(& str, (char const   *)(ent.dirent.name), (size_t )-1);
          }
#line 746
          if (tmp___9 == -1) {
#line 747
            result = -1;
          }
          {
#line 749
          tmp___10 = dstr_string(& str);
#line 749
          ent.path = strdup((char const   *)tmp___10);
          }
#line 750
          if (ent.path) {
#line 751
            ent.free = & dpfree;
          } else {
#line 753
            result = -1;
          }
          {
#line 755
          dstr_free(& str);
#line 757
          tmp___11 = darr_append(dirs, (void *)(& ent));
          }
#line 757
          if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
#line 759
            result = -1;
#line 760
            if (ent.path) {
              {
#line 761
              free((void *)ent.path);
              }
            }
          }
#line 764
          if (result) {
            {
#line 766
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
                    argv0);
            }
#line 767
            goto while_break___0;
          }
          {
#line 770
          tmp___12 = darr_size(dirs);
#line 770
          dsz = (int )tmp___12;
#line 771
          tmp___13 = darr_array(dirs);
#line 771
          ents = (queueent *)tmp___13;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 775
    hfs_closedir(dir);
    }
#line 777
    if (result) {
#line 778
      goto while_break;
    }
#line 780
    if (flags & 2048) {
      {
#line 781
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 782
    if (flags & 1024) {
      {
#line 783
      tmp___17 = strlen(path);
      }
#line 783
      if ((int const   )*(path + (tmp___17 - 1UL)) == 58) {
#line 783
        tmp___16 = "\n";
      } else {
#line 783
        tmp___16 = ":\n";
      }
      {
#line 783
      printf((char const   */* __restrict  */)"%s%s", path, tmp___16);
      }
    }
    {
#line 786
    sortfiles(files, flags, options);
#line 787
    tmp___18 = showfiles(files, flags, options, width);
    }
#line 787
    if (tmp___18 == -1) {
#line 788
      result = -1;
    }
#line 790
    flags |= 3072;
    __Cont: /* CIL Label */ 
#line 696
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  return (result);
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
static int queuepath(hfsvol *vol , char *path , darray *dirs , darray *files , int flags ) 
{ 
  queueent ent ;
  darray *array ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 806
  tmp___2 = hfs_stat(vol, (char const   *)path, & ent.dirent);
  }
#line 806
  if (tmp___2 == -1) {
    {
#line 808
    hfsutil_perrorp((char const   *)path);
#line 809
    tmp___1 = __errno_location();
    }
#line 809
    if (*tmp___1 == 2) {
#line 809
      tmp___0 = 0;
    } else {
#line 809
      tmp___0 = -1;
    }
#line 809
    return (tmp___0);
  }
#line 812
  ent.path = path;
#line 813
  ent.free = (void (*)(struct _queueent_ * ))0;
#line 815
  if (ent.dirent.flags & 1) {
#line 815
    if (! (flags & 16)) {
#line 815
      array = dirs;
    } else {
#line 815
      array = files;
    }
  } else {
#line 815
    array = files;
  }
  {
#line 818
  tmp___3 = darr_append(array, (void *)(& ent));
  }
#line 818
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 820
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
            argv0);
    }
#line 821
    return (-1);
  }
#line 824
  return (0);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hls.c"
int hls_main(int argc , char **argv ) 
{ 
  hfsvol *vol ;
  int fargc ;
  int i ;
  char **fargv ;
  int result ;
  int flags ;
  int options ;
  int width ;
  char *ptr ;
  darray *dirs ;
  darray *files ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct winsize ws ;
  int tmp___2 ;
  int opt ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  mountent *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 835
  fargv = (char **)0;
#line 836
  result = 0;
#line 841
  options = 0;
#line 843
  tmp = isatty(1);
  }
#line 843
  if (tmp) {
#line 845
    options |= 2;
#line 846
    flags = 8;
  } else {
#line 850
    options |= 1;
#line 851
    flags = 0;
  }
  {
#line 854
  tmp___0 = strcmp(bargv0, "hdir");
  }
#line 854
  if (tmp___0 == 0) {
#line 855
    options &= -8;
  }
  {
#line 857
  ptr = getenv("COLUMNS");
  }
#line 858
  if (ptr) {
    {
#line 858
    tmp___1 = atoi((char const   *)ptr);
#line 858
    width = tmp___1;
    }
  } else {
#line 858
    width = 80;
  }
  {
#line 864
  tmp___2 = ioctl(1, 21523UL, & ws);
  }
#line 864
  if (tmp___2 != -1) {
#line 864
    if ((int )ws.ws_col != 0) {
#line 866
      width = (int )ws.ws_col;
    }
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 874
    opt = getopt(argc, (char * const  *)argv, "1abcdfilmqrstxw:CFNQRSU");
    }
#line 875
    if (opt == -1) {
#line 876
      goto while_break;
    }
    {
#line 880
    if (opt == 63) {
#line 880
      goto case_63;
    }
#line 883
    if (opt == 49) {
#line 883
      goto case_49;
    }
#line 887
    if (opt == 97) {
#line 887
      goto case_97;
    }
#line 891
    if (opt == 98) {
#line 891
      goto case_98;
    }
#line 896
    if (opt == 99) {
#line 896
      goto case_99;
    }
#line 900
    if (opt == 100) {
#line 900
      goto case_100;
    }
#line 904
    if (opt == 102) {
#line 904
      goto case_102;
    }
#line 913
    if (opt == 105) {
#line 913
      goto case_105;
    }
#line 917
    if (opt == 108) {
#line 917
      goto case_108;
    }
#line 921
    if (opt == 109) {
#line 921
      goto case_109;
    }
#line 925
    if (opt == 113) {
#line 925
      goto case_113;
    }
#line 930
    if (opt == 114) {
#line 930
      goto case_114;
    }
#line 934
    if (opt == 115) {
#line 934
      goto case_115;
    }
#line 938
    if (opt == 116) {
#line 938
      goto case_116;
    }
#line 942
    if (opt == 120) {
#line 942
      goto case_120;
    }
#line 946
    if (opt == 119) {
#line 946
      goto case_119;
    }
#line 950
    if (opt == 67) {
#line 950
      goto case_67;
    }
#line 954
    if (opt == 70) {
#line 954
      goto case_70;
    }
#line 958
    if (opt == 78) {
#line 958
      goto case_78;
    }
#line 962
    if (opt == 81) {
#line 962
      goto case_81;
    }
#line 967
    if (opt == 82) {
#line 967
      goto case_82;
    }
#line 971
    if (opt == 83) {
#line 971
      goto case_83;
    }
#line 975
    if (opt == 85) {
#line 975
      goto case_85;
    }
#line 878
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 881
    tmp___3 = usage___0();
    }
#line 881
    return (tmp___3);
    case_49: /* CIL Label */ 
#line 884
    options = (options & -8) | 1;
#line 885
    goto switch_break;
    case_97: /* CIL Label */ 
#line 888
    flags |= 1;
#line 889
    goto switch_break;
    case_98: /* CIL Label */ 
#line 892
    flags |= 2;
#line 893
    flags &= -9;
#line 894
    goto switch_break;
    case_99: /* CIL Label */ 
#line 897
    options = ((options & -57) | 8) | 16;
#line 898
    goto switch_break;
    case_100: /* CIL Label */ 
#line 901
    flags |= 16;
#line 902
    goto switch_break;
    case_102: /* CIL Label */ 
#line 905
    flags |= 1;
#line 906
    flags &= -129;
#line 907
    options &= -49;
#line 908
    if ((options & 7) == 0) {
      {
#line 909
      tmp___6 = isatty(1);
      }
#line 909
      if (tmp___6) {
#line 909
        tmp___5 = 2;
      } else {
#line 909
        tmp___5 = 1;
      }
#line 909
      options = (options & -8) | tmp___5;
    }
#line 911
    goto switch_break;
    case_105: /* CIL Label */ 
#line 914
    flags |= 32;
#line 915
    goto switch_break;
    case_108: /* CIL Label */ 
#line 918
    options &= -8;
#line 919
    goto switch_break;
    case_109: /* CIL Label */ 
#line 922
    options = (options & -8) | 4;
#line 923
    goto switch_break;
    case_113: /* CIL Label */ 
#line 926
    flags |= 8;
#line 927
    flags &= -3;
#line 928
    goto switch_break;
    case_114: /* CIL Label */ 
#line 931
    flags |= 64;
#line 932
    goto switch_break;
    case_115: /* CIL Label */ 
#line 935
    flags |= 128;
#line 936
    goto switch_break;
    case_116: /* CIL Label */ 
#line 939
    options = (options & -49) | 16;
#line 940
    goto switch_break;
    case_120: /* CIL Label */ 
#line 943
    options = (options & -8) | 3;
#line 944
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 947
    width = atoi((char const   *)optarg);
    }
#line 948
    goto switch_break;
    case_67: /* CIL Label */ 
#line 951
    options = (options & -8) | 2;
#line 952
    goto switch_break;
    case_70: /* CIL Label */ 
#line 955
    flags |= 256;
#line 956
    goto switch_break;
    case_78: /* CIL Label */ 
#line 959
    flags &= -11;
#line 960
    goto switch_break;
    case_81: /* CIL Label */ 
#line 963
    flags |= 6;
#line 964
    flags &= -9;
#line 965
    goto switch_break;
    case_82: /* CIL Label */ 
#line 968
    flags |= 512;
#line 969
    goto switch_break;
    case_83: /* CIL Label */ 
#line 972
    options = (options & -49) | 32;
#line 973
    goto switch_break;
    case_85: /* CIL Label */ 
#line 976
    options &= -49;
#line 977
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  tmp___7 = hcwd_getvol(-1);
#line 981
  vol = hfsutil_remount(tmp___7, 0);
  }
#line 982
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 983
    return (1);
  }
  {
#line 985
  fargv = hfsutil_glob(vol, argc - optind, argv + optind, & fargc, & result);
#line 987
  dirs = qnew();
#line 988
  files = qnew();
  }
#line 989
  if (result == 0) {
#line 989
    if ((unsigned long )dirs == (unsigned long )((darray *)0)) {
      {
#line 991
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
              argv0);
#line 992
      result = 1;
      }
    } else
#line 989
    if ((unsigned long )files == (unsigned long )((darray *)0)) {
      {
#line 991
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
              argv0);
#line 992
      result = 1;
      }
    }
  }
#line 995
  if (result == 0) {
#line 997
    if (fargc == 0) {
      {
#line 999
      tmp___8 = queuepath(vol, (char *)":", dirs, files, flags);
      }
#line 999
      if (tmp___8 == -1) {
#line 1000
        result = 1;
      }
    } else {
#line 1004
      i = 0;
      {
#line 1004
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1004
        if (! (i < fargc)) {
#line 1004
          goto while_break___0;
        }
        {
#line 1006
        tmp___9 = queuepath(vol, *(fargv + i), dirs, files, flags);
        }
#line 1006
        if (tmp___9 == -1) {
#line 1008
          result = 1;
#line 1009
          goto while_break___0;
        }
#line 1004
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1015
  if (result == 0) {
    {
#line 1015
    tmp___10 = process(vol, dirs, files, flags, options, width);
    }
#line 1015
    if (tmp___10 == -1) {
#line 1016
      result = 1;
    }
  }
#line 1018
  if (files) {
    {
#line 1019
    qfree(files);
    }
  }
#line 1020
  if (dirs) {
    {
#line 1021
    qfree(dirs);
    }
  }
  {
#line 1023
  hfsutil_unmount(vol, & result);
  }
#line 1025
  if (fargv) {
    {
#line 1026
    free((void *)fargv);
    }
  }
#line 1028
  return (result);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hformat.c"
static void usage___1(void) 
{ 


  {
  {
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-f] [-l label] path [partition-no]\n",
          argv0);
  }
#line 53
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hformat.c"
static hfsvol *do_format(char const   *path , int partno , int mode , char const   *vname ) 
{ 
  hfsvol *vol ;
  int tmp ;

  {
  {
#line 62
  vol = (hfsvol *)0;
#line 64
  suid_enable();
#line 66
  tmp = hfs_format(path, partno, mode, vname, 0U, (unsigned long const   *)0);
  }
#line 66
  if (tmp != -1) {
    {
#line 67
    vol = hfs_mount(path, partno, 2);
    }
  }
  {
#line 69
  suid_disable();
  }
#line 71
  return (vol);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hformat.c"
int hformat_main(int argc , char **argv ) 
{ 
  char const   *vname ;
  char *path ;
  hfsvol *vol ;
  hfsvolent ent ;
  int nparts ;
  int partno ;
  int options ;
  int result ;
  int opt ;
  int tmp ;

  {
#line 81
  path = (char *)0;
#line 84
  options = 0;
#line 84
  result = 0;
#line 86
  vname = "Untitled";
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    opt = getopt(argc, (char * const  *)argv, "fl:");
    }
#line 93
    if (opt == -1) {
#line 94
      goto while_break;
    }
    {
#line 98
    if (opt == 63) {
#line 98
      goto case_63;
    }
#line 102
    if (opt == 102) {
#line 102
      goto case_102;
    }
#line 106
    if (opt == 108) {
#line 106
      goto case_108;
    }
#line 96
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 99
    usage___1();
    }
#line 100
    goto fail;
    case_102: /* CIL Label */ 
#line 103
    options |= 1;
#line 104
    goto switch_break;
    case_108: /* CIL Label */ 
#line 107
    vname = (char const   *)optarg;
#line 108
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  if (argc - optind < 1) {
    {
#line 114
    usage___1();
    }
#line 115
    goto fail;
  } else
#line 112
  if (argc - optind > 2) {
    {
#line 114
    usage___1();
    }
#line 115
    goto fail;
  }
  {
#line 118
  path = hfsutil_abspath((char const   *)*(argv + optind));
  }
#line 119
  if ((unsigned long )path == (unsigned long )((char *)0)) {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not enough memory\n",
            argv0);
    }
#line 122
    goto fail;
  }
  {
#line 125
  suid_enable();
#line 126
  nparts = hfs_nparts((char const   *)path);
#line 127
  suid_disable();
  }
#line 129
  if (argc - optind == 2) {
    {
#line 131
    partno = atoi((char const   *)*(argv + (optind + 1)));
    }
#line 133
    if (nparts != -1) {
#line 133
      if (partno == 0) {
#line 135
        if (options & 1) {
          {
#line 137
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: erasing partition information\n",
                  argv0);
          }
        } else {
          {
#line 142
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: medium is partitioned; select partition > 0 or use -f\n",
                  argv0);
          }
#line 144
          goto fail;
        }
      }
    }
  } else
#line 150
  if (nparts > 1) {
    {
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: must specify partition number (%d available)\n",
            argv0, nparts);
    }
#line 155
    goto fail;
  } else
#line 157
  if (nparts == -1) {
#line 158
    partno = 0;
  } else {
#line 160
    partno = 1;
  }
  {
#line 163
  vol = do_format((char const   *)path, partno, 0, vname);
  }
#line 164
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
    {
#line 166
    hfsutil_perror((char const   *)path);
    }
#line 167
    goto fail;
  }
  {
#line 170
  hfs_vstat(vol, & ent);
#line 171
  hfsutil_pinfo(& ent);
#line 173
  tmp = hcwd_mounted((char const   *)(ent.name), ent.crdate, (char const   *)path,
                     partno);
  }
#line 173
  if (tmp == -1) {
    {
#line 175
    perror("Failed to record mount");
#line 176
    result = 1;
    }
  }
  {
#line 179
  hfsutil_unmount(vol, & result);
#line 181
  free((void *)path);
  }
#line 183
  return (result);
  fail: 
#line 186
  if (path) {
    {
#line 187
    free((void *)path);
    }
  }
#line 189
  return (1);
}
}
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.h"
unsigned char const   hfs_charorder[256] ;
#line 24
signed char d_getsb(unsigned char const   *ptr ) ;
#line 25
unsigned char d_getub(unsigned char const   *ptr ) ;
#line 31
void d_putsb(unsigned char *ptr , signed char data ) ;
#line 32
void d_putub(unsigned char *ptr , unsigned char data ) ;
#line 33
void d_putsw(unsigned char *ptr , short data ) ;
#line 34
void d_putuw(unsigned char *ptr , unsigned short data ) ;
#line 39
void d_fetchub(unsigned char const   **ptr , unsigned char *dest ) ;
#line 46
void d_storeub(unsigned char **ptr , unsigned char data ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
static time_t tzdiff  =    (time_t )-1;
#line 40 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
unsigned char const   hfs_charorder[256]  = 
#line 40
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )47,      (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50, 
        (unsigned char const   )51,      (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54, 
        (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58, 
        (unsigned char const   )59,      (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62, 
        (unsigned char const   )63,      (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66, 
        (unsigned char const   )67,      (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70, 
        (unsigned char const   )71,      (unsigned char const   )72,      (unsigned char const   )88,      (unsigned char const   )90, 
        (unsigned char const   )94,      (unsigned char const   )96,      (unsigned char const   )103,      (unsigned char const   )105, 
        (unsigned char const   )107,      (unsigned char const   )109,      (unsigned char const   )115,      (unsigned char const   )117, 
        (unsigned char const   )119,      (unsigned char const   )121,      (unsigned char const   )123,      (unsigned char const   )127, 
        (unsigned char const   )141,      (unsigned char const   )143,      (unsigned char const   )145,      (unsigned char const   )147, 
        (unsigned char const   )150,      (unsigned char const   )152,      (unsigned char const   )159,      (unsigned char const   )161, 
        (unsigned char const   )163,      (unsigned char const   )165,      (unsigned char const   )168,      (unsigned char const   )170, 
        (unsigned char const   )171,      (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174, 
        (unsigned char const   )84,      (unsigned char const   )72,      (unsigned char const   )88,      (unsigned char const   )90, 
        (unsigned char const   )94,      (unsigned char const   )96,      (unsigned char const   )103,      (unsigned char const   )105, 
        (unsigned char const   )107,      (unsigned char const   )109,      (unsigned char const   )115,      (unsigned char const   )117, 
        (unsigned char const   )119,      (unsigned char const   )121,      (unsigned char const   )123,      (unsigned char const   )127, 
        (unsigned char const   )141,      (unsigned char const   )143,      (unsigned char const   )145,      (unsigned char const   )147, 
        (unsigned char const   )150,      (unsigned char const   )152,      (unsigned char const   )159,      (unsigned char const   )161, 
        (unsigned char const   )163,      (unsigned char const   )165,      (unsigned char const   )168,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )76,      (unsigned char const   )80,      (unsigned char const   )92,      (unsigned char const   )98, 
        (unsigned char const   )125,      (unsigned char const   )129,      (unsigned char const   )154,      (unsigned char const   )85, 
        (unsigned char const   )74,      (unsigned char const   )86,      (unsigned char const   )76,      (unsigned char const   )78, 
        (unsigned char const   )80,      (unsigned char const   )92,      (unsigned char const   )98,      (unsigned char const   )100, 
        (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )111,      (unsigned char const   )112, 
        (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )125,      (unsigned char const   )137, 
        (unsigned char const   )138,      (unsigned char const   )139,      (unsigned char const   )129,      (unsigned char const   )131, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )154, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )149, 
        (unsigned char const   )187,      (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190, 
        (unsigned char const   )191,      (unsigned char const   )192,      (unsigned char const   )82,      (unsigned char const   )133, 
        (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195,      (unsigned char const   )196, 
        (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199,      (unsigned char const   )200, 
        (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203,      (unsigned char const   )87, 
        (unsigned char const   )140,      (unsigned char const   )204,      (unsigned char const   )82,      (unsigned char const   )133, 
        (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207,      (unsigned char const   )208, 
        (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211,      (unsigned char const   )38, 
        (unsigned char const   )39,      (unsigned char const   )212,      (unsigned char const   )32,      (unsigned char const   )74, 
        (unsigned char const   )78,      (unsigned char const   )131,      (unsigned char const   )135,      (unsigned char const   )135, 
        (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )36,      (unsigned char const   )37, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )215,      (unsigned char const   )216, 
        (unsigned char const   )167,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 87 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
signed char d_getsb(unsigned char const   *ptr ) 
{ 


  {
#line 89
  return ((signed char )*(ptr + 0));
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
unsigned char d_getub(unsigned char const   *ptr ) 
{ 


  {
#line 98
  return ((unsigned char )*(ptr + 0));
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
short d_getsw(unsigned char const   *ptr ) 
{ 


  {
#line 107
  return ((short )(((int )((short )*(ptr + 0)) << 8) | (int )((unsigned short )*(ptr + 1))));
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
unsigned short d_getuw(unsigned char const   *ptr ) 
{ 


  {
#line 118
  return ((unsigned short )(((int )((unsigned short )*(ptr + 0)) << 8) | (int )((unsigned short )*(ptr + 1))));
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
long d_getsl(unsigned char const   *ptr ) 
{ 


  {
#line 129
  return ((long )((((unsigned long )((long )*(ptr + 0) << 24) | ((unsigned long )*(ptr + 1) << 16)) | ((unsigned long )*(ptr + 2) << 8)) | (unsigned long )*(ptr + 3)));
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
unsigned long d_getul(unsigned char const   *ptr ) 
{ 


  {
#line 142
  return (((((unsigned long )*(ptr + 0) << 24) | ((unsigned long )*(ptr + 1) << 16)) | ((unsigned long )*(ptr + 2) << 8)) | (unsigned long )*(ptr + 3));
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_putsb(unsigned char *ptr , signed char data ) 
{ 


  {
#line 156
  *ptr = (unsigned char )data;
#line 157
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_putub(unsigned char *ptr , unsigned char data ) 
{ 


  {
#line 166
  *ptr = data;
#line 167
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_putsw(unsigned char *ptr , short data ) 
{ 
  unsigned char *tmp ;

  {
#line 176
  tmp = ptr;
#line 176
  ptr ++;
#line 176
  *tmp = (unsigned char )(((int )((unsigned short )data) & 65280) >> 8);
#line 177
  *ptr = (unsigned char )((int )((unsigned short )data) & 255);
#line 178
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_putuw(unsigned char *ptr , unsigned short data ) 
{ 
  unsigned char *tmp ;

  {
#line 187
  tmp = ptr;
#line 187
  ptr ++;
#line 187
  *tmp = (unsigned char )(((int )data & 65280) >> 8);
#line 188
  *ptr = (unsigned char )((int )data & 255);
#line 189
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_putsl(unsigned char *ptr , long data ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 198
  tmp = ptr;
#line 198
  ptr ++;
#line 198
  *tmp = (unsigned char )(((unsigned long )data & 4278190080UL) >> 24);
#line 199
  tmp___0 = ptr;
#line 199
  ptr ++;
#line 199
  *tmp___0 = (unsigned char )(((unsigned long )data & 16711680UL) >> 16);
#line 200
  tmp___1 = ptr;
#line 200
  ptr ++;
#line 200
  *tmp___1 = (unsigned char )(((unsigned long )data & 65280UL) >> 8);
#line 201
  *ptr = (unsigned char )((unsigned long )data & 255UL);
#line 202
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_putul(unsigned char *ptr , unsigned long data ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 211
  tmp = ptr;
#line 211
  ptr ++;
#line 211
  *tmp = (unsigned char )((data & 4278190080UL) >> 24);
#line 212
  tmp___0 = ptr;
#line 212
  ptr ++;
#line 212
  *tmp___0 = (unsigned char )((data & 16711680UL) >> 16);
#line 213
  tmp___1 = ptr;
#line 213
  ptr ++;
#line 213
  *tmp___1 = (unsigned char )((data & 65280UL) >> 8);
#line 214
  *ptr = (unsigned char )(data & 255UL);
#line 215
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_fetchsb(unsigned char const   **ptr , signed char *dest ) 
{ 
  unsigned char const   *tmp ;

  {
#line 224
  tmp = *ptr;
#line 224
  (*ptr) ++;
#line 224
  *dest = (signed char )*tmp;
#line 225
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_fetchub(unsigned char const   **ptr , unsigned char *dest ) 
{ 
  unsigned char const   *tmp ;

  {
#line 234
  tmp = *ptr;
#line 234
  (*ptr) ++;
#line 234
  *dest = (unsigned char )*tmp;
#line 235
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_fetchsw(unsigned char const   **ptr , short *dest ) 
{ 


  {
#line 244
  *dest = (short )(((int )((short )*(*ptr + 0)) << 8) | (int )((unsigned short )*(*ptr + 1)));
#line 247
  *ptr += 2;
#line 248
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_fetchuw(unsigned char const   **ptr , unsigned short *dest ) 
{ 


  {
#line 257
  *dest = (unsigned short )(((int )((unsigned short )*(*ptr + 0)) << 8) | (int )((unsigned short )*(*ptr + 1)));
#line 260
  *ptr += 2;
#line 261
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_fetchsl(unsigned char const   **ptr , long *dest ) 
{ 


  {
#line 270
  *dest = (long )((((unsigned long )((long )*(*ptr + 0) << 24) | ((unsigned long )*(*ptr + 1) << 16)) | ((unsigned long )*(*ptr + 2) << 8)) | (unsigned long )*(*ptr + 3));
#line 275
  *ptr += 4;
#line 276
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_fetchul(unsigned char const   **ptr , unsigned long *dest ) 
{ 


  {
#line 285
  *dest = ((((unsigned long )*(*ptr + 0) << 24) | ((unsigned long )*(*ptr + 1) << 16)) | ((unsigned long )*(*ptr + 2) << 8)) | (unsigned long )*(*ptr + 3);
#line 290
  *ptr += 4;
#line 291
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_storesb(unsigned char **ptr , signed char data ) 
{ 
  unsigned char *tmp ;

  {
#line 300
  tmp = *ptr;
#line 300
  (*ptr) ++;
#line 300
  *tmp = (unsigned char )data;
#line 301
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_storeub(unsigned char **ptr , unsigned char data ) 
{ 
  unsigned char *tmp ;

  {
#line 310
  tmp = *ptr;
#line 310
  (*ptr) ++;
#line 310
  *tmp = data;
#line 311
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_storesw(unsigned char **ptr , short data ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 320
  tmp = *ptr;
#line 320
  (*ptr) ++;
#line 320
  *tmp = (unsigned char )(((int )((unsigned short )data) & 65280) >> 8);
#line 321
  tmp___0 = *ptr;
#line 321
  (*ptr) ++;
#line 321
  *tmp___0 = (unsigned char )((int )((unsigned short )data) & 255);
#line 322
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_storeuw(unsigned char **ptr , unsigned short data ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 331
  tmp = *ptr;
#line 331
  (*ptr) ++;
#line 331
  *tmp = (unsigned char )(((int )data & 65280) >> 8);
#line 332
  tmp___0 = *ptr;
#line 332
  (*ptr) ++;
#line 332
  *tmp___0 = (unsigned char )((int )data & 255);
#line 333
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_storesl(unsigned char **ptr , long data ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 342
  tmp = *ptr;
#line 342
  (*ptr) ++;
#line 342
  *tmp = (unsigned char )(((unsigned long )data & 4278190080UL) >> 24);
#line 343
  tmp___0 = *ptr;
#line 343
  (*ptr) ++;
#line 343
  *tmp___0 = (unsigned char )(((unsigned long )data & 16711680UL) >> 16);
#line 344
  tmp___1 = *ptr;
#line 344
  (*ptr) ++;
#line 344
  *tmp___1 = (unsigned char )(((unsigned long )data & 65280UL) >> 8);
#line 345
  tmp___2 = *ptr;
#line 345
  (*ptr) ++;
#line 345
  *tmp___2 = (unsigned char )((unsigned long )data & 255UL);
#line 346
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_storeul(unsigned char **ptr , unsigned long data ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 355
  tmp = *ptr;
#line 355
  (*ptr) ++;
#line 355
  *tmp = (unsigned char )((data & 4278190080UL) >> 24);
#line 356
  tmp___0 = *ptr;
#line 356
  (*ptr) ++;
#line 356
  *tmp___0 = (unsigned char )((data & 16711680UL) >> 16);
#line 357
  tmp___1 = *ptr;
#line 357
  (*ptr) ++;
#line 357
  *tmp___1 = (unsigned char )((data & 65280UL) >> 8);
#line 358
  tmp___2 = *ptr;
#line 358
  (*ptr) ++;
#line 358
  *tmp___2 = (unsigned char )(data & 255UL);
#line 359
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_fetchstr(unsigned char const   **ptr , char *dest , unsigned int size ) 
{ 
  unsigned int len ;
  unsigned char tmp ;

  {
  {
#line 369
  tmp = d_getub(*ptr);
#line 369
  len = (unsigned int )tmp;
  }
#line 371
  if (len > 0U) {
#line 371
    if (len < size) {
      {
#line 372
      memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)(*ptr + 1),
             (size_t )len);
      }
    } else {
#line 374
      len = 0U;
    }
  } else {
#line 374
    len = 0U;
  }
#line 376
  *(dest + len) = (char)0;
#line 378
  *ptr += size;
#line 379
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
void d_storestr(unsigned char **ptr , char const   *src , unsigned int size ) 
{ 
  unsigned int len ;
  size_t tmp ;

  {
  {
#line 389
  tmp = strlen(src);
#line 389
  len = (unsigned int )tmp;
#line 390
  size --;
  }
#line 390
  if (len > size) {
#line 391
    len = 0U;
  }
  {
#line 393
  d_storeub(ptr, (unsigned char )len);
#line 395
  memcpy((void */* __restrict  */)*ptr, (void const   */* __restrict  */)src, (size_t )len);
#line 396
  memset((void *)(*ptr + len), 0, (size_t )(size - len));
#line 398
  *ptr += size;
  }
#line 399
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
int d_relstring(char const   *str1 , char const   *str2 ) 
{ 
  register int diff ;

  {
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (*str1) {
#line 409
      if (! *str2) {
#line 409
        goto while_break;
      }
    } else {
#line 409
      goto while_break;
    }
#line 411
    diff = (int )((int const   )hfs_charorder[(unsigned char )*str1] - (int const   )hfs_charorder[(unsigned char )*str2]);
#line 414
    if (diff) {
#line 415
      return (diff);
    }
#line 417
    str1 ++;
#line 417
    str2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  if (! *str1) {
#line 420
    if (*str2) {
#line 421
      return (-1);
    } else {
#line 420
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 422
  if (*str1) {
#line 422
    if (! *str2) {
#line 423
      return (1);
    }
  }
#line 425
  return (0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
static void calctzdiff(void) 
{ 
  time_t t ;
  int isdst ;
  struct tm tm ;
  struct tm  const  *tmp ;
  struct tm *tmp___0 ;
  struct tm *tmp___1 ;
  time_t tmp___2 ;

  {
  {
#line 442
  time(& t);
#line 443
  tmp___0 = localtime((time_t const   *)(& t));
#line 443
  isdst = tmp___0->tm_isdst;
#line 445
  tmp___1 = gmtime((time_t const   *)(& t));
#line 445
  tmp = (struct tm  const  *)tmp___1;
  }
#line 446
  if (tmp) {
    {
#line 448
    tm = (struct tm )*tmp;
#line 449
    tm.tm_isdst = isdst;
#line 451
    tmp___2 = mktime(& tm);
#line 451
    tzdiff = t - tmp___2;
    }
  } else {
#line 454
    tzdiff = (time_t )0;
  }
#line 461
  return;
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
time_t d_ltime(unsigned long mtime ) 
{ 


  {
#line 469
  if (tzdiff == -1L) {
    {
#line 470
    calctzdiff();
    }
  }
#line 472
  return ((time_t )(mtime - 2082844800UL) - tzdiff);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/data.c"
unsigned long d_mtime(time_t ltime ) 
{ 


  {
#line 481
  if (tzdiff == -1L) {
    {
#line 482
    calctzdiff();
    }
  }
#line 484
  return ((unsigned long )(ltime + tzdiff) + 2082844800UL);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/medium.c"
int m_zeroddr(hfsvol *vol ) 
{ 
  Block0 ddr ;
  int i ;
  int tmp ;

  {
#line 48
  ddr.sbSig = (Integer )17746;
#line 49
  ddr.sbBlkSize = (Integer )512;
#line 50
  ddr.sbBlkCount = (LongInt )vol->vlen;
#line 52
  ddr.sbDevType = (Integer )0;
#line 53
  ddr.sbDevId = (Integer )0;
#line 54
  ddr.sbData = (LongInt )0;
#line 56
  ddr.sbDrvrCount = (Integer )0;
#line 58
  ddr.ddBlock = (LongInt )0;
#line 59
  ddr.ddSize = (Integer )0;
#line 60
  ddr.ddType = (Integer )0;
#line 62
  i = 0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i < 243)) {
#line 62
      goto while_break;
    }
#line 63
    ddr.ddPad[i] = (Integer )0;
#line 62
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  tmp = l_putddr(vol, (Block0 const   *)(& ddr));
  }
#line 65
  return (tmp);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/medium.c"
int m_zeropm(hfsvol *vol , unsigned int maxparts ) 
{ 
  Partition map ;
  unsigned int i ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  block b ;
  int tmp___2 ;

  {
#line 81
  if (maxparts < 2U) {
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 82
      hfs_error = "must allow at least 2 partitions";
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 22;
      }
#line 82
      goto fail;
#line 82
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 86
  map.pmSig = (Integer )20557;
#line 87
  map.pmSigPad = (Integer )0;
#line 88
  map.pmMapBlkCnt = (LongInt )2;
#line 90
  map.pmPyPartStart = (LongInt )1;
#line 91
  map.pmPartBlkCnt = (LongInt )maxparts;
#line 93
  strcpy((char */* __restrict  */)((char *)(map.pmPartName)), (char const   */* __restrict  */)"Apple");
#line 94
  strcpy((char */* __restrict  */)((char *)(map.pmParType)), (char const   */* __restrict  */)"Apple_partition_map");
#line 96
  map.pmLgDataStart = (LongInt )0;
#line 97
  map.pmDataCnt = map.pmPartBlkCnt;
#line 99
  map.pmPartStatus = (LongInt )0;
#line 101
  map.pmLgBootStart = (LongInt )0;
#line 102
  map.pmBootSize = (LongInt )0;
#line 103
  map.pmBootAddr = (LongInt )0;
#line 104
  map.pmBootAddr2 = (LongInt )0;
#line 105
  map.pmBootEntry = (LongInt )0;
#line 106
  map.pmBootEntry2 = (LongInt )0;
#line 107
  map.pmBootCksum = (LongInt )0;
#line 109
  strcpy((char */* __restrict  */)((char *)(map.pmProcessor)), (char const   */* __restrict  */)"");
#line 111
  i = 0U;
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i < 188U)) {
#line 111
      goto while_break___0;
    }
#line 112
    map.pmPad[i] = (Integer )0;
#line 111
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 114
  tmp___0 = l_putpmentry(vol, (Partition const   *)(& map), 1UL);
  }
#line 114
  if (tmp___0 == -1) {
#line 115
    goto fail;
  }
  {
#line 119
  map.pmPyPartStart = (LongInt )(1U + maxparts);
#line 120
  map.pmPartBlkCnt = (LongInt )((vol->vlen - 1UL) - (unsigned long )maxparts);
#line 122
  strcpy((char */* __restrict  */)((char *)(map.pmPartName)), (char const   */* __restrict  */)"Extra");
#line 123
  strcpy((char */* __restrict  */)((char *)(map.pmParType)), (char const   */* __restrict  */)"Apple_Free");
#line 125
  map.pmDataCnt = map.pmPartBlkCnt;
#line 127
  tmp___1 = l_putpmentry(vol, (Partition const   *)(& map), 2UL);
  }
#line 127
  if (tmp___1 == -1) {
#line 128
    goto fail;
  }
#line 132
  if (maxparts > 2U) {
    {
#line 136
    memset((void *)(& b), 0, sizeof(b));
#line 138
    i = 3U;
    }
    {
#line 138
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 138
      if (! (i <= maxparts)) {
#line 138
        goto while_break___1;
      }
      {
#line 140
      tmp___2 = b_writepb(vol, (unsigned long )i, (block const   *)(& b), 1U);
      }
#line 140
      if (tmp___2 == -1) {
#line 141
        goto fail;
      }
#line 138
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 145
  return (0);
  fail: 
#line 148
  return (-1);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/medium.c"
int m_findpmentry(hfsvol *vol , char const   *type , Partition *map , unsigned long *start ) 
{ 
  unsigned long bnum ;
  int found ;
  int *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 159
  found = 0;
#line 161
  if (start) {
#line 161
    if (*start > 0UL) {
#line 163
      bnum = *start;
#line 165
      tmp___0 = bnum;
#line 165
      bnum ++;
#line 165
      if (tmp___0 >= (unsigned long )map->pmMapBlkCnt) {
        {
#line 166
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 166
          hfs_error = "partition not found";
#line 166
          tmp = __errno_location();
#line 166
          *tmp = 22;
          }
#line 166
          goto fail;
#line 166
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    } else {
#line 169
      bnum = 1UL;
    }
  } else {
#line 169
    bnum = 1UL;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 173
    tmp___1 = l_getpmentry(vol, map, bnum);
    }
#line 173
    if (tmp___1 == -1) {
#line 175
      found = -1;
#line 176
      goto fail;
    }
#line 179
    if ((int )map->pmSig != 20557) {
#line 181
      found = -1;
#line 183
      if ((int )map->pmSig == 21587) {
        {
#line 184
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 184
          hfs_error = "old partition map format not supported";
#line 184
          tmp___2 = __errno_location();
#line 184
          *tmp___2 = 22;
          }
#line 184
          goto fail;
#line 184
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 186
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 186
          hfs_error = "invalid partition map";
#line 186
          tmp___3 = __errno_location();
#line 186
          *tmp___3 = 22;
          }
#line 186
          goto fail;
#line 186
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 189
    tmp___4 = strcmp((char const   *)((char *)(map->pmParType)), type);
    }
#line 189
    if (tmp___4 == 0) {
#line 191
      found = 1;
#line 192
      goto done;
    }
#line 195
    tmp___6 = bnum;
#line 195
    bnum ++;
#line 195
    if (tmp___6 >= (unsigned long )map->pmMapBlkCnt) {
      {
#line 196
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 196
        hfs_error = "partition not found";
#line 196
        tmp___5 = __errno_location();
#line 196
        *tmp___5 = 22;
        }
#line 196
        goto fail;
#line 196
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
#line 200
  if (start) {
#line 201
    *start = bnum;
  }
  fail: 
#line 204
  return (found);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/medium.c"
int m_mkpart(hfsvol *vol , char const   *name___1 , char const   *type , unsigned long len ) 
{ 
  Partition map ;
  unsigned int nparts ;
  unsigned int maxparts ;
  unsigned long bnum ;
  unsigned long start ;
  unsigned long remain ;
  int found ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 219
  tmp___0 = strlen(name___1);
  }
#line 219
  if (tmp___0 > 32UL) {
#line 219
    goto _L;
  } else {
    {
#line 219
    tmp___1 = strlen(type);
    }
#line 219
    if (tmp___1 > 32UL) {
      _L: /* CIL Label */ 
      {
#line 221
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 221
        hfs_error = "partition name/type can each be at most 32 chars";
#line 221
        tmp = __errno_location();
#line 221
        *tmp = 22;
        }
#line 221
        goto fail;
#line 221
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 223
  if (len == 0UL) {
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 224
      hfs_error = "partition length must be > 0";
#line 224
      tmp___2 = __errno_location();
#line 224
      *tmp___2 = 22;
      }
#line 224
      goto fail;
#line 224
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 226
  found = m_findpmentry(vol, "Apple_partition_map", & map, (unsigned long *)0);
  }
#line 227
  if (found == -1) {
#line 228
    goto fail;
  }
#line 230
  if (! found) {
    {
#line 231
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 231
      hfs_error = "cannot find partition map\'s partition";
#line 231
      tmp___3 = __errno_location();
#line 231
      *tmp___3 = 5;
      }
#line 231
      goto fail;
#line 231
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 233
  nparts = (unsigned int )map.pmMapBlkCnt;
#line 234
  maxparts = (unsigned int )map.pmPartBlkCnt;
#line 236
  bnum = 0UL;
  {
#line 237
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 239
    found = m_findpmentry(vol, "Apple_Free", & map, & bnum);
    }
#line 240
    if (found == -1) {
#line 241
      goto fail;
    }
#line 243
    if (! found) {
      {
#line 244
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 244
        hfs_error = "no available partitions";
#line 244
        tmp___4 = __errno_location();
#line 244
        *tmp___4 = 28;
        }
#line 244
        goto fail;
#line 244
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 237
    if (! (len > (unsigned long )map.pmPartBlkCnt)) {
#line 237
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 248
  start = (unsigned long )map.pmPyPartStart + len;
#line 249
  remain = (unsigned long )map.pmPartBlkCnt - len;
#line 251
  if (remain) {
#line 251
    if (nparts >= maxparts) {
      {
#line 252
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 252
        hfs_error = "must allocate all blocks in free space";
#line 252
        tmp___5 = __errno_location();
#line 252
        *tmp___5 = 22;
        }
#line 252
        goto fail;
#line 252
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  {
#line 254
  map.pmPartBlkCnt = (LongInt )len;
#line 256
  strcpy((char */* __restrict  */)((char *)(map.pmPartName)), (char const   */* __restrict  */)name___1);
#line 257
  strcpy((char */* __restrict  */)((char *)(map.pmParType)), (char const   */* __restrict  */)type);
#line 259
  map.pmLgDataStart = (LongInt )0;
#line 260
  map.pmDataCnt = (LongInt )len;
#line 262
  map.pmPartStatus = (LongInt )0;
#line 264
  tmp___6 = l_putpmentry(vol, (Partition const   *)(& map), bnum);
  }
#line 264
  if (tmp___6 == -1) {
#line 265
    goto fail;
  }
#line 267
  if (remain) {
    {
#line 269
    map.pmPyPartStart = (LongInt )start;
#line 270
    map.pmPartBlkCnt = (LongInt )remain;
#line 272
    strcpy((char */* __restrict  */)((char *)(map.pmPartName)), (char const   */* __restrict  */)"Extra");
#line 273
    strcpy((char */* __restrict  */)((char *)(map.pmParType)), (char const   */* __restrict  */)"Apple_Free");
#line 275
    map.pmDataCnt = (LongInt )remain;
#line 277
    nparts ++;
#line 277
    tmp___7 = l_putpmentry(vol, (Partition const   *)(& map), (unsigned long )nparts);
    }
#line 277
    if (tmp___7 == -1) {
#line 278
      goto fail;
    }
#line 280
    bnum = 1UL;
    {
#line 280
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 280
      if (! (bnum <= (unsigned long )nparts)) {
#line 280
        goto while_break___5;
      }
      {
#line 282
      tmp___8 = l_getpmentry(vol, & map, bnum);
      }
#line 282
      if (tmp___8 == -1) {
#line 283
        goto fail;
      }
      {
#line 285
      map.pmMapBlkCnt = (LongInt )nparts;
#line 287
      tmp___9 = l_putpmentry(vol, (Partition const   *)(& map), bnum);
      }
#line 287
      if (tmp___9 == -1) {
#line 288
        goto fail;
      }
#line 280
      bnum ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 292
  return (0);
  fail: 
#line 295
  return (-1);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/medium.c"
int m_zerobb(hfsvol *vol ) 
{ 
  block b ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 308
  memset((void *)(& b), 0, sizeof(b));
#line 310
  tmp = b_writelb(vol, 0UL, (block const   *)(& b));
  }
#line 310
  if (tmp == -1) {
#line 312
    goto fail;
  } else {
    {
#line 310
    tmp___0 = b_writelb(vol, 1UL, (block const   *)(& b));
    }
#line 310
    if (tmp___0 == -1) {
#line 312
      goto fail;
    }
  }
#line 314
  return (0);
  fail: 
#line 317
  return (-1);
}
}
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.h"
unsigned long os_seek(void **priv , unsigned long offset ) ;
#line 28
unsigned long os_read(void **priv , void *buf , unsigned long len ) ;
#line 29
unsigned long os_write(void **priv , void const   *buf , unsigned long len ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.c"
int os_open(void **priv , char const   *path , int mode ) 
{ 
  int fd ;
  struct flock lock ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 61
  if (mode == 0) {
#line 61
    goto case_0;
  }
#line 66
  goto switch_default;
  case_0: /* CIL Label */ 
#line 62
  mode = 0;
#line 63
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 67
  mode = 2;
#line 68
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 71
  fd = open(path, mode);
  }
#line 72
  if (fd == -1) {
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 73
      hfs_error = "error opening medium";
#line 73
      tmp = __errno_location();
#line 73
      tmp___0 = __errno_location();
#line 73
      *tmp = *tmp___0;
      }
#line 73
      goto fail;
#line 73
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 77
  if (mode == 0) {
#line 77
    lock.l_type = (short)0;
  } else {
#line 77
    lock.l_type = (short)1;
  }
  {
#line 78
  lock.l_start = (__off_t )0;
#line 79
  lock.l_whence = (short)0;
#line 80
  lock.l_len = (__off_t )0;
#line 82
  tmp___2 = fcntl(fd, 6, & lock);
  }
#line 82
  if (tmp___2 == -1) {
    {
#line 82
    tmp___3 = __errno_location();
    }
#line 82
    if (*tmp___3 == 13) {
#line 82
      goto _L;
    } else {
      {
#line 82
      tmp___4 = __errno_location();
      }
#line 82
      if (*tmp___4 == 11) {
        _L: /* CIL Label */ 
        {
#line 84
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 84
          hfs_error = "unable to obtain lock for medium";
#line 84
          tmp___1 = __errno_location();
#line 84
          *tmp___1 = 11;
          }
#line 84
          goto fail;
#line 84
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 86
  *priv = (void *)fd;
#line 88
  return (0);
  fail: 
#line 91
  if (fd != -1) {
    {
#line 92
    close(fd);
    }
  }
#line 94
  return (-1);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.c"
int os_close(void **priv ) 
{ 
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 103
  fd = (int )*priv;
#line 105
  *priv = (void *)-1;
#line 107
  tmp___1 = close(fd);
  }
#line 107
  if (tmp___1 == -1) {
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 108
      hfs_error = "error closing medium";
#line 108
      tmp = __errno_location();
#line 108
      tmp___0 = __errno_location();
#line 108
      *tmp = *tmp___0;
      }
#line 108
      goto fail;
#line 108
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 110
  return (0);
  fail: 
#line 113
  return (-1);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.c"
int os_same(void **priv , char const   *path ) 
{ 
  int fd ;
  struct stat fdev ;
  struct stat dev ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 122
  fd = (int )*priv;
#line 125
  tmp___1 = fstat(fd, & fdev);
  }
#line 125
  if (tmp___1 == -1) {
#line 125
    goto _L;
  } else {
    {
#line 125
    tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& dev));
    }
#line 125
    if (tmp___2 == -1) {
      _L: /* CIL Label */ 
      {
#line 127
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 127
        hfs_error = "can\'t get path information";
#line 127
        tmp = __errno_location();
#line 127
        tmp___0 = __errno_location();
#line 127
        *tmp = *tmp___0;
        }
#line 127
        goto fail;
#line 127
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 129
  if (fdev.st_dev == dev.st_dev) {
#line 129
    if (fdev.st_ino == dev.st_ino) {
#line 129
      tmp___3 = 1;
    } else {
#line 129
      tmp___3 = 0;
    }
  } else {
#line 129
    tmp___3 = 0;
  }
#line 129
  return (tmp___3);
  fail: 
#line 133
  return (-1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.c"
unsigned long os_seek(void **priv , unsigned long offset ) 
{ 
  int fd ;
  off_t result ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 142
  fd = (int )*priv;
#line 147
  if (offset == 0xffffffffffffffffUL) {
    {
#line 148
    result = lseek(fd, (__off_t )0, 2);
    }
  } else {
    {
#line 150
    result = lseek(fd, (__off_t )(offset << 9), 0);
    }
  }
#line 152
  if (result == -1L) {
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 153
      hfs_error = "error seeking medium";
#line 153
      tmp = __errno_location();
#line 153
      tmp___0 = __errno_location();
#line 153
      *tmp = *tmp___0;
      }
#line 153
      goto fail;
#line 153
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 155
  return ((unsigned long )result >> 9);
  fail: 
#line 158
  return (0xffffffffffffffffUL);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.c"
unsigned long os_read(void **priv , void *buf , unsigned long len ) 
{ 
  int fd ;
  ssize_t result ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 167
  fd = (int )*priv;
#line 170
  result = read(fd, buf, len << 9);
  }
#line 172
  if (result == -1L) {
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 173
      hfs_error = "error reading from medium";
#line 173
      tmp = __errno_location();
#line 173
      tmp___0 = __errno_location();
#line 173
      *tmp = *tmp___0;
      }
#line 173
      goto fail;
#line 173
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 175
  return ((unsigned long )result >> 9);
  fail: 
#line 178
  return (0xffffffffffffffffUL);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/os.c"
unsigned long os_write(void **priv , void const   *buf , unsigned long len ) 
{ 
  int fd ;
  ssize_t result ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 187
  fd = (int )*priv;
#line 190
  result = write(fd, buf, len << 9);
  }
#line 192
  if (result == -1L) {
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 193
      hfs_error = "error writing to medium";
#line 193
      tmp = __errno_location();
#line 193
      tmp___0 = __errno_location();
#line 193
      *tmp = *tmp___0;
      }
#line 193
      goto fail;
#line 193
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 195
  return ((unsigned long )result >> 9);
  fail: 
#line 198
  return (0xffffffffffffffffUL);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.h"
char const   *cpo_error ;
#line 26
int cpo_macb(hfsvol *vol , char const   *srcname , char const   *dstname ) ;
#line 27
int cpo_binh(hfsvol *vol , char const   *srcname , char const   *dstname ) ;
#line 28
int cpo_text(hfsvol *vol , char const   *srcname , char const   *dstname ) ;
#line 29
int cpo_raw(hfsvol *vol , char const   *srcname , char const   *dstname ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.c"
static cpifunc automode_unix(char const   *path ) 
{ 
  int i ;
  struct __anonstruct_exts_36 exts[9] ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 53
  exts[0].ext = ".bin";
#line 53
  exts[0].func = & cpi_macb;
#line 53
  exts[1].ext = ".hqx";
#line 53
  exts[1].func = & cpi_binh;
#line 53
  exts[2].ext = ".txt";
#line 53
  exts[2].func = & cpi_text;
#line 53
  exts[3].ext = ".c";
#line 53
  exts[3].func = & cpi_text;
#line 53
  exts[4].ext = ".h";
#line 53
  exts[4].func = & cpi_text;
#line 53
  exts[5].ext = ".html";
#line 53
  exts[5].func = & cpi_text;
#line 53
  exts[6].ext = ".htm";
#line 53
  exts[6].func = & cpi_text;
#line 53
  exts[7].ext = ".rtf";
#line 53
  exts[7].func = & cpi_text;
#line 53
  exts[8].ext = (char const   *)0;
#line 53
  exts[8].func = (int (*)(char const   * , hfsvol * , char const   * ))0;
#line 70
  tmp = strlen(path);
#line 70
  path += tmp;
#line 72
  i = 0;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! exts[i].ext) {
#line 72
      goto while_break;
    }
    {
#line 74
    tmp___0 = strlen(exts[i].ext);
#line 74
    tmp___1 = strcasecmp(path - tmp___0, exts[i].ext);
    }
#line 74
    if (tmp___1 == 0) {
#line 75
      return (exts[i].func);
    }
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (& cpi_raw);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.c"
static int do_copyin(hfsvol *vol , int argc , char **argv , char const   *dest , int mode ) 
{ 
  hfsdirent ent ;
  struct stat sbuf ;
  int (*copyfile)(char const   * , hfsvol * , char const   * ) ;
  int i ;
  int result ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 91
  result = 0;
#line 93
  if (argc > 1) {
    {
#line 93
    tmp___0 = hfs_stat(vol, dest, & ent);
    }
#line 93
    if (tmp___0 == -1) {
      {
#line 96
      hfs_error = (char const   *)0;
#line 96
      tmp = __errno_location();
#line 96
      *tmp = 20;
#line 97
      hfsutil_perrorp(dest);
      }
#line 99
      return (1);
    } else
#line 93
    if (! (ent.flags & 1)) {
      {
#line 96
      hfs_error = (char const   *)0;
#line 96
      tmp = __errno_location();
#line 96
      *tmp = 20;
#line 97
      hfsutil_perrorp(dest);
      }
#line 99
      return (1);
    }
  }
  {
#line 104
  if (mode == 109) {
#line 104
    goto case_109;
  }
#line 108
  if (mode == 98) {
#line 108
    goto case_98;
  }
#line 112
  if (mode == 116) {
#line 112
    goto case_116;
  }
#line 116
  if (mode == 114) {
#line 116
    goto case_114;
  }
#line 102
  goto switch_break;
  case_109: /* CIL Label */ 
#line 105
  copyfile = & cpi_macb;
#line 106
  goto switch_break;
  case_98: /* CIL Label */ 
#line 109
  copyfile = & cpi_binh;
#line 110
  goto switch_break;
  case_116: /* CIL Label */ 
#line 113
  copyfile = & cpi_text;
#line 114
  goto switch_break;
  case_114: /* CIL Label */ 
#line 117
  copyfile = & cpi_raw;
#line 118
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < argc)) {
#line 121
      goto while_break;
    }
    {
#line 123
    tmp___5 = stat((char const   */* __restrict  */)*(argv + i), (struct stat */* __restrict  */)(& sbuf));
    }
#line 123
    if (tmp___5 != -1) {
#line 123
      if ((sbuf.st_mode & 61440U) == 16384U) {
        {
#line 126
        hfs_error = (char const   *)0;
#line 126
        tmp___1 = __errno_location();
#line 126
        *tmp___1 = 21;
#line 127
        hfsutil_perrorp((char const   *)*(argv + i));
#line 129
        result = 1;
        }
      } else {
#line 123
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 133
      if (mode == 97) {
        {
#line 134
        copyfile = automode_unix((char const   *)*(argv + i));
        }
      }
      {
#line 136
      tmp___4 = (*copyfile)((char const   *)*(argv + i), vol, dest);
      }
#line 136
      if (tmp___4 == -1) {
        {
#line 138
        hfs_error = cpi_error;
#line 138
        tmp___2 = __errno_location();
#line 138
        tmp___3 = __errno_location();
#line 138
        *tmp___2 = *tmp___3;
#line 139
        hfsutil_perrorp((char const   *)*(argv + i));
#line 141
        result = 1;
        }
      }
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (result);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.c"
static cpofunc automode_hfs(hfsvol *vol , char const   *path ) 
{ 
  hfsdirent ent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 158
  tmp___1 = hfs_stat(vol, path, & ent);
  }
#line 158
  if (tmp___1 != -1) {
    {
#line 160
    tmp = strcmp((char const   *)(ent.u.file.type), "TEXT");
    }
#line 160
    if (tmp == 0) {
#line 162
      return (& cpo_text);
    } else {
      {
#line 160
      tmp___0 = strcmp((char const   *)(ent.u.file.type), "ttro");
      }
#line 160
      if (tmp___0 == 0) {
#line 162
        return (& cpo_text);
      } else
#line 163
      if (ent.u.file.rsize == 0UL) {
#line 164
        return (& cpo_raw);
      }
    }
  }
#line 167
  return (& cpo_macb);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.c"
static int do_copyout(hfsvol *vol , int argc , char **argv , char const   *dest ,
                      int mode ) 
{ 
  struct stat sbuf ;
  hfsdirent ent ;
  int (*copyfile)(hfsvol * , char const   * , char const   * ) ;
  int i ;
  int result ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 180
  result = 0;
#line 182
  if (argc > 1) {
    {
#line 182
    tmp___0 = stat((char const   */* __restrict  */)dest, (struct stat */* __restrict  */)(& sbuf));
    }
#line 182
    if (tmp___0 == -1) {
      {
#line 185
      hfs_error = (char const   *)0;
#line 185
      tmp = __errno_location();
#line 185
      *tmp = 20;
#line 186
      hfsutil_perrorp(dest);
      }
#line 188
      return (1);
    } else
#line 182
    if (! ((sbuf.st_mode & 61440U) == 16384U)) {
      {
#line 185
      hfs_error = (char const   *)0;
#line 185
      tmp = __errno_location();
#line 185
      *tmp = 20;
#line 186
      hfsutil_perrorp(dest);
      }
#line 188
      return (1);
    }
  }
  {
#line 193
  if (mode == 109) {
#line 193
    goto case_109;
  }
#line 197
  if (mode == 98) {
#line 197
    goto case_98;
  }
#line 201
  if (mode == 116) {
#line 201
    goto case_116;
  }
#line 205
  if (mode == 114) {
#line 205
    goto case_114;
  }
#line 191
  goto switch_break;
  case_109: /* CIL Label */ 
#line 194
  copyfile = & cpo_macb;
#line 195
  goto switch_break;
  case_98: /* CIL Label */ 
#line 198
  copyfile = & cpo_binh;
#line 199
  goto switch_break;
  case_116: /* CIL Label */ 
#line 202
  copyfile = & cpo_text;
#line 203
  goto switch_break;
  case_114: /* CIL Label */ 
#line 206
  copyfile = & cpo_raw;
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 210
  i = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < argc)) {
#line 210
      goto while_break;
    }
    {
#line 212
    tmp___5 = hfs_stat(vol, (char const   *)*(argv + i), & ent);
    }
#line 212
    if (tmp___5 != -1) {
#line 212
      if (ent.flags & 1) {
        {
#line 215
        hfs_error = (char const   *)0;
#line 215
        tmp___1 = __errno_location();
#line 215
        *tmp___1 = 21;
#line 216
        hfsutil_perrorp((char const   *)*(argv + i));
#line 218
        result = 1;
        }
      } else {
#line 212
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 222
      if (mode == 97) {
        {
#line 223
        copyfile = automode_hfs(vol, (char const   *)*(argv + i));
        }
      }
      {
#line 225
      tmp___4 = (*copyfile)(vol, (char const   *)*(argv + i), dest);
      }
#line 225
      if (tmp___4 == -1) {
        {
#line 227
        hfs_error = cpo_error;
#line 227
        tmp___2 = __errno_location();
#line 227
        tmp___3 = __errno_location();
#line 227
        *tmp___2 = *tmp___3;
#line 228
        hfsutil_perrorp((char const   *)*(argv + i));
#line 230
        result = 1;
        }
      }
    }
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (result);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.c"
static int usage___2(void) 
{ 


  {
  {
#line 245
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-m|-b|-t|-r|-a] source-path [...] target-path\n",
          argv0);
  }
#line 248
  return (1);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hcopy.c"
int hcopy_main(int argc , char **argv ) 
{ 
  int nargs ;
  int mode ;
  int result ;
  char const   *target ;
  int fargc ;
  char **fargv ;
  hfsvol *vol ;
  int (*copy)(hfsvol * , int  , char ** , char const   * , int  ) ;
  int opt ;
  int tmp ;
  int tmp___0 ;
  mountent *tmp___1 ;
  mountent *tmp___2 ;
  char *tmp___3 ;

  {
#line 257
  mode = 'a';
#line 257
  result = 0;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    opt = getopt(argc, (char * const  *)argv, "mbtra");
    }
#line 269
    if (opt == -1) {
#line 270
      goto while_break;
    }
    {
#line 274
    if (opt == 63) {
#line 274
      goto case_63;
    }
#line 277
    goto switch_default;
    case_63: /* CIL Label */ 
    {
#line 275
    tmp = usage___2();
    }
#line 275
    return (tmp);
    switch_default: /* CIL Label */ 
#line 278
    mode = opt;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  nargs = argc - optind;
#line 284
  if (nargs < 2) {
    {
#line 285
    tmp___0 = usage___2();
    }
#line 285
    return (tmp___0);
  }
  {
#line 287
  target = (char const   *)*(argv + (argc - 1));
#line 289
  tmp___3 = strchr(target, ':');
  }
#line 289
  if (tmp___3) {
#line 289
    if ((int const   )*(target + 0) != 46) {
#line 289
      if ((int const   )*(target + 0) != 47) {
        {
#line 291
        tmp___1 = hcwd_getvol(-1);
#line 291
        vol = hfsutil_remount(tmp___1, 2);
        }
#line 292
        if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 293
          return (1);
        }
#line 295
        copy = & do_copyin;
#line 296
        fargc = nargs - 1;
#line 297
        fargv = argv + optind;
      } else {
#line 289
        goto _L___0;
      }
    } else {
#line 289
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 301
    tmp___2 = hcwd_getvol(-1);
#line 301
    vol = hfsutil_remount(tmp___2, 0);
    }
#line 302
    if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 303
      return (1);
    }
    {
#line 305
    copy = & do_copyout;
#line 306
    fargv = hfsutil_glob(vol, nargs - 1, argv + optind, & fargc, & result);
    }
  }
#line 309
  if (result == 0) {
    {
#line 310
    result = (*copy)(vol, fargc, fargv, target, mode);
    }
  }
  {
#line 312
  hfsutil_unmount(vol, & result);
  }
#line 314
  if (fargv) {
#line 314
    if ((unsigned long )fargv != (unsigned long )(argv + optind)) {
      {
#line 315
      free((void *)fargv);
      }
    }
  }
#line 317
  return (result);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hdel.c"
int hdel_main(int argc , char **argv ) 
{ 
  hfsvol *vol ;
  int fargc ;
  char **fargv ;
  int i ;
  int result ;
  mountent *tmp ;
  int tmp___0 ;

  {
#line 43
  result = 0;
#line 45
  if (argc < 2) {
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s hfs-path [...]\n",
            argv0);
    }
#line 48
    return (1);
  }
  {
#line 51
  tmp = hcwd_getvol(-1);
#line 51
  vol = hfsutil_remount(tmp, 2);
  }
#line 52
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 53
    return (1);
  }
  {
#line 55
  fargv = hfsutil_glob(vol, argc - 1, argv + 1, & fargc, & result);
  }
#line 57
  if (result == 0) {
#line 59
    i = 0;
    {
#line 59
    while (1) {
      while_continue: /* CIL Label */ ;
#line 59
      if (! (i < fargc)) {
#line 59
        goto while_break;
      }
      {
#line 61
      tmp___0 = hfs_delete(vol, (char const   *)*(fargv + i));
      }
#line 61
      if (tmp___0 == -1) {
        {
#line 63
        hfsutil_perrorp((char const   *)*(fargv + i));
#line 64
        result = 1;
        }
      }
#line 59
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 69
  hfsutil_unmount(vol, & result);
  }
#line 71
  if (fargv) {
    {
#line 72
    free((void *)fargv);
    }
  }
#line 74
  return (result);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/humount.c"
int humount_main(int argc , char **argv ) 
{ 
  int vnum ;
  mountent *ent ;
  int tmp ;
  mountent *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 43
  if (argc > 2) {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [volume-name-or-path]\n",
            argv0);
    }
#line 46
    return (1);
  }
#line 49
  if (argc == 1) {
    {
#line 51
    tmp = hcwd_umounted(-1);
    }
#line 51
    if (tmp == -1) {
      {
#line 51
      tmp___0 = hcwd_getvol(-1);
      }
#line 51
      if ((unsigned long )tmp___0 == (unsigned long )((mountent *)0)) {
        {
#line 54
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No volume is current\n",
                argv0);
        }
#line 55
        return (1);
      }
    }
#line 58
    return (0);
  }
  {
#line 61
  vnum = 0;
#line 61
  ent = hcwd_getvol(vnum);
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! ent) {
#line 61
      goto while_break;
    }
    {
#line 63
    tmp___1 = hfsutil_samepath((char const   *)*(argv + 1), (char const   *)ent->path);
    }
#line 63
    if (tmp___1) {
      {
#line 66
      hcwd_umounted(vnum);
      }
#line 67
      return (0);
    } else {
      {
#line 63
      tmp___2 = strcasecmp((char const   *)*(argv + 1), (char const   *)(ent->vname));
      }
#line 63
      if (tmp___2 == 0) {
        {
#line 66
        hcwd_umounted(vnum);
        }
#line 67
        return (0);
      }
    }
    {
#line 61
    vnum ++;
#line 61
    ent = hcwd_getvol(vnum);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown volume \"%s\"\n",
          argv0, *(argv + 1));
  }
#line 73
  return (1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
char const   *cpo_error  =    "no error";
#line 62 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int fork_macb___0(hfsfile *ifile , int ofile , unsigned long size ) 
{ 
  char buf[2048] ;
  long chunk ;
  long bytes ;
  unsigned long total ;
  unsigned long tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 67
  total = 0UL;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    tmp = hfs_read(ifile, (void *)(buf), sizeof(buf));
#line 71
    chunk = (long )tmp;
    }
#line 72
    if (chunk == -1L) {
      {
#line 74
      cpo_error = hfs_error;
#line 74
      tmp___0 = __errno_location();
#line 74
      tmp___1 = __errno_location();
#line 74
      *tmp___0 = *tmp___1;
      }
#line 75
      return (-1);
    } else
#line 77
    if (chunk == 0L) {
#line 78
      goto while_break;
    }
    {
#line 80
    bytes = write(ofile, (void const   *)(buf), (size_t )chunk);
    }
#line 81
    if (bytes == -1L) {
      {
#line 83
      cpo_error = "error writing data";
#line 83
      tmp___2 = __errno_location();
#line 83
      tmp___3 = __errno_location();
#line 83
      *tmp___2 = *tmp___3;
      }
#line 84
      return (-1);
    } else
#line 86
    if (bytes != chunk) {
      {
#line 88
      cpo_error = "wrote incomplete chunk";
#line 88
      tmp___4 = __errno_location();
#line 88
      *tmp___4 = 5;
      }
#line 89
      return (-1);
    }
#line 92
    total += (unsigned long )bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if (total != size) {
    {
#line 97
    cpo_error = "inconsistent fork length";
#line 97
    tmp___5 = __errno_location();
#line 97
    *tmp___5 = 5;
    }
#line 98
    return (-1);
  }
#line 101
  chunk = (long )(total % 128UL);
#line 102
  if (chunk) {
    {
#line 104
    memset((void *)(buf), 0, (size_t )128);
#line 105
    bytes = write(ofile, (void const   *)(buf), (size_t )(128L - chunk));
    }
#line 106
    if (bytes == -1L) {
      {
#line 108
      cpo_error = "error writing data";
#line 108
      tmp___6 = __errno_location();
#line 108
      tmp___7 = __errno_location();
#line 108
      *tmp___6 = *tmp___7;
      }
#line 109
      return (-1);
    } else
#line 111
    if (bytes != 128L - chunk) {
      {
#line 113
      cpo_error = "wrong incomplete chunk";
#line 113
      tmp___8 = __errno_location();
#line 113
      *tmp___8 = 5;
      }
#line 114
      return (-1);
    }
  }
#line 118
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int do_macb___0(hfsfile *ifile , int ofile ) 
{ 
  hfsdirent ent ;
  unsigned char buf[128] ;
  long bytes ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned short tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 132
  tmp___1 = hfs_fstat(ifile, & ent);
  }
#line 132
  if (tmp___1 == -1) {
    {
#line 134
    cpo_error = hfs_error;
#line 134
    tmp = __errno_location();
#line 134
    tmp___0 = __errno_location();
#line 134
    *tmp = *tmp___0;
    }
#line 135
    return (-1);
  }
  {
#line 138
  memset((void *)(buf), 0, (size_t )128);
#line 140
  tmp___2 = strlen((char const   *)(ent.name));
#line 140
  buf[1] = (unsigned char )tmp___2;
#line 141
  strcpy((char */* __restrict  */)((char *)(& buf[2])), (char const   */* __restrict  */)(ent.name));
#line 143
  memcpy((void */* __restrict  */)(& buf[65]), (void const   */* __restrict  */)(ent.u.file.type),
         (size_t )4);
#line 144
  memcpy((void */* __restrict  */)(& buf[69]), (void const   */* __restrict  */)(ent.u.file.creator),
         (size_t )4);
#line 146
  buf[73] = (unsigned char )((int )ent.fdflags >> 8);
#line 148
  d_putul(& buf[83], ent.u.file.dsize);
#line 149
  d_putul(& buf[87], ent.u.file.rsize);
#line 151
  tmp___3 = d_mtime(ent.crdate);
#line 151
  d_putul(& buf[91], tmp___3);
#line 152
  tmp___4 = d_mtime(ent.mddate);
#line 152
  d_putul(& buf[95], tmp___4);
#line 154
  buf[101] = (unsigned char )((int )ent.fdflags & 255);
#line 155
  buf[123] = (unsigned char)129;
#line 155
  buf[122] = buf[123];
#line 157
  tmp___5 = crc_macb((unsigned char const   *)(buf), 124, (unsigned short)0);
#line 157
  d_putuw(& buf[124], tmp___5);
#line 159
  bytes = write(ofile, (void const   *)(buf), (size_t )128);
  }
#line 160
  if (bytes == -1L) {
    {
#line 162
    cpo_error = "error writing data";
#line 162
    tmp___6 = __errno_location();
#line 162
    tmp___7 = __errno_location();
#line 162
    *tmp___6 = *tmp___7;
    }
#line 163
    return (-1);
  } else
#line 165
  if (bytes != 128L) {
    {
#line 167
    cpo_error = "wrote incomplete chunk";
#line 167
    tmp___8 = __errno_location();
#line 167
    *tmp___8 = 5;
    }
#line 168
    return (-1);
  }
  {
#line 171
  tmp___11 = hfs_setfork(ifile, 0);
  }
#line 171
  if (tmp___11 == -1) {
    {
#line 173
    cpo_error = hfs_error;
#line 173
    tmp___9 = __errno_location();
#line 173
    tmp___10 = __errno_location();
#line 173
    *tmp___9 = *tmp___10;
    }
#line 174
    return (-1);
  }
  {
#line 177
  tmp___12 = fork_macb___0(ifile, ofile, ent.u.file.dsize);
  }
#line 177
  if (tmp___12 == -1) {
#line 178
    return (-1);
  }
  {
#line 180
  tmp___15 = hfs_setfork(ifile, 1);
  }
#line 180
  if (tmp___15 == -1) {
    {
#line 182
    cpo_error = hfs_error;
#line 182
    tmp___13 = __errno_location();
#line 182
    tmp___14 = __errno_location();
#line 182
    *tmp___13 = *tmp___14;
    }
#line 183
    return (-1);
  }
  {
#line 186
  tmp___16 = fork_macb___0(ifile, ofile, ent.u.file.rsize);
  }
#line 186
  if (tmp___16 == -1) {
#line 187
    return (-1);
  }
#line 189
  return (0);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int fork_binh___0(hfsfile *ifile , unsigned long size ) 
{ 
  char buf[2048] ;
  long bytes ;
  unsigned long total ;
  unsigned long tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 201
  total = 0UL;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    tmp = hfs_read(ifile, (void *)(buf), sizeof(buf));
#line 205
    bytes = (long )tmp;
    }
#line 206
    if (bytes == -1L) {
      {
#line 208
      cpo_error = hfs_error;
#line 208
      tmp___0 = __errno_location();
#line 208
      tmp___1 = __errno_location();
#line 208
      *tmp___0 = *tmp___1;
      }
#line 209
      return (-1);
    } else
#line 211
    if (bytes == 0L) {
#line 212
      goto while_break;
    }
    {
#line 214
    tmp___4 = bh_insert((void const   *)(buf), (int )bytes);
    }
#line 214
    if (tmp___4 == -1) {
      {
#line 216
      cpo_error = bh_error;
#line 216
      tmp___2 = __errno_location();
#line 216
      tmp___3 = __errno_location();
#line 216
      *tmp___2 = *tmp___3;
      }
#line 217
      return (-1);
    }
#line 220
    total += (unsigned long )bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (total != size) {
    {
#line 225
    cpo_error = "inconsistent fork length";
#line 225
    tmp___5 = __errno_location();
#line 225
    *tmp___5 = 5;
    }
#line 226
    return (-1);
  }
  {
#line 229
  tmp___8 = bh_insertcrc();
  }
#line 229
  if (tmp___8 == -1) {
    {
#line 231
    cpo_error = bh_error;
#line 231
    tmp___6 = __errno_location();
#line 231
    tmp___7 = __errno_location();
#line 231
    *tmp___6 = *tmp___7;
    }
#line 232
    return (-1);
  }
#line 235
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int binhx___0(hfsfile *ifile ) 
{ 
  hfsdirent ent ;
  unsigned char byte ;
  unsigned char word[2] ;
  unsigned char lword[4] ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 248
  tmp___1 = hfs_fstat(ifile, & ent);
  }
#line 248
  if (tmp___1 == -1) {
    {
#line 250
    cpo_error = hfs_error;
#line 250
    tmp = __errno_location();
#line 250
    tmp___0 = __errno_location();
#line 250
    *tmp = *tmp___0;
    }
#line 251
    return (-1);
  }
  {
#line 254
  tmp___2 = strlen((char const   *)(ent.name));
#line 254
  byte = (unsigned char )tmp___2;
#line 255
  tmp___5 = bh_insert((void const   *)(& byte), 1);
  }
#line 255
  if (tmp___5 == -1) {
    {
#line 260
    cpo_error = bh_error;
#line 260
    tmp___3 = __errno_location();
#line 260
    tmp___4 = __errno_location();
#line 260
    *tmp___3 = *tmp___4;
    }
#line 261
    return (-1);
  } else {
    {
#line 255
    tmp___6 = bh_insert((void const   *)(ent.name), (int )byte + 1);
    }
#line 255
    if (tmp___6 == -1) {
      {
#line 260
      cpo_error = bh_error;
#line 260
      tmp___3 = __errno_location();
#line 260
      tmp___4 = __errno_location();
#line 260
      *tmp___3 = *tmp___4;
      }
#line 261
      return (-1);
    } else {
      {
#line 255
      tmp___7 = bh_insert((void const   *)(ent.u.file.type), 4);
      }
#line 255
      if (tmp___7 == -1) {
        {
#line 260
        cpo_error = bh_error;
#line 260
        tmp___3 = __errno_location();
#line 260
        tmp___4 = __errno_location();
#line 260
        *tmp___3 = *tmp___4;
        }
#line 261
        return (-1);
      } else {
        {
#line 255
        tmp___8 = bh_insert((void const   *)(ent.u.file.creator), 4);
        }
#line 255
        if (tmp___8 == -1) {
          {
#line 260
          cpo_error = bh_error;
#line 260
          tmp___3 = __errno_location();
#line 260
          tmp___4 = __errno_location();
#line 260
          *tmp___3 = *tmp___4;
          }
#line 261
          return (-1);
        }
      }
    }
  }
  {
#line 264
  d_putsw(word, ent.fdflags);
#line 265
  tmp___11 = bh_insert((void const   *)(word), 2);
  }
#line 265
  if (tmp___11 == -1) {
    {
#line 267
    cpo_error = bh_error;
#line 267
    tmp___9 = __errno_location();
#line 267
    tmp___10 = __errno_location();
#line 267
    *tmp___9 = *tmp___10;
    }
#line 268
    return (-1);
  }
  {
#line 271
  d_putul(lword, ent.u.file.dsize);
#line 272
  tmp___14 = bh_insert((void const   *)(lword), 4);
  }
#line 272
  if (tmp___14 == -1) {
    {
#line 274
    cpo_error = bh_error;
#line 274
    tmp___12 = __errno_location();
#line 274
    tmp___13 = __errno_location();
#line 274
    *tmp___12 = *tmp___13;
    }
#line 275
    return (-1);
  }
  {
#line 278
  d_putul(lword, ent.u.file.rsize);
#line 279
  tmp___17 = bh_insert((void const   *)(lword), 4);
  }
#line 279
  if (tmp___17 == -1) {
    {
#line 282
    cpo_error = bh_error;
#line 282
    tmp___15 = __errno_location();
#line 282
    tmp___16 = __errno_location();
#line 282
    *tmp___15 = *tmp___16;
    }
#line 283
    return (-1);
  } else {
    {
#line 279
    tmp___18 = bh_insertcrc();
    }
#line 279
    if (tmp___18 == -1) {
      {
#line 282
      cpo_error = bh_error;
#line 282
      tmp___15 = __errno_location();
#line 282
      tmp___16 = __errno_location();
#line 282
      *tmp___15 = *tmp___16;
      }
#line 283
      return (-1);
    }
  }
  {
#line 286
  tmp___21 = hfs_setfork(ifile, 0);
  }
#line 286
  if (tmp___21 == -1) {
    {
#line 288
    cpo_error = hfs_error;
#line 288
    tmp___19 = __errno_location();
#line 288
    tmp___20 = __errno_location();
#line 288
    *tmp___19 = *tmp___20;
    }
#line 289
    return (-1);
  }
  {
#line 292
  tmp___22 = fork_binh___0(ifile, ent.u.file.dsize);
  }
#line 292
  if (tmp___22 == -1) {
#line 293
    return (-1);
  }
  {
#line 295
  tmp___25 = hfs_setfork(ifile, 1);
  }
#line 295
  if (tmp___25 == -1) {
    {
#line 297
    cpo_error = hfs_error;
#line 297
    tmp___23 = __errno_location();
#line 297
    tmp___24 = __errno_location();
#line 297
    *tmp___23 = *tmp___24;
    }
#line 298
    return (-1);
  }
  {
#line 301
  tmp___26 = fork_binh___0(ifile, ent.u.file.rsize);
  }
#line 301
  if (tmp___26 == -1) {
#line 302
    return (-1);
  }
#line 304
  return (0);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int do_binh___0(hfsfile *ifile , int ofile ) 
{ 
  int result ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 316
  tmp___1 = bh_start(ofile);
  }
#line 316
  if (tmp___1 == -1) {
    {
#line 318
    cpo_error = bh_error;
#line 318
    tmp = __errno_location();
#line 318
    tmp___0 = __errno_location();
#line 318
    *tmp = *tmp___0;
    }
#line 319
    return (-1);
  }
  {
#line 322
  result = binhx___0(ifile);
#line 324
  tmp___4 = bh_end();
  }
#line 324
  if (tmp___4 == -1) {
#line 324
    if (result == 0) {
      {
#line 326
      cpo_error = bh_error;
#line 326
      tmp___2 = __errno_location();
#line 326
      tmp___3 = __errno_location();
#line 326
      *tmp___2 = *tmp___3;
#line 327
      result = -1;
      }
    }
  }
#line 330
  return (result);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int do_text___0(hfsfile *ifile , int ofile ) 
{ 
  char buf[2048] ;
  char *ptr ;
  long chunk ;
  long bytes ;
  int len ;
  unsigned long tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 346
    tmp = hfs_read(ifile, (void *)(buf), sizeof(buf));
#line 346
    chunk = (long )tmp;
    }
#line 347
    if (chunk == -1L) {
      {
#line 349
      cpo_error = hfs_error;
#line 349
      tmp___0 = __errno_location();
#line 349
      tmp___1 = __errno_location();
#line 349
      *tmp___0 = *tmp___1;
      }
#line 350
      return (-1);
    } else
#line 352
    if (chunk == 0L) {
#line 353
      goto while_break;
    }
#line 355
    ptr = buf;
    {
#line 355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if (! ((unsigned long )ptr < (unsigned long )(buf + chunk))) {
#line 355
        goto while_break___0;
      }
#line 357
      if ((int )*ptr == 13) {
#line 358
        *ptr = (char )'\n';
      }
#line 355
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 361
    len = (int )chunk;
#line 362
    ptr = cs_latin1(buf, & len);
    }
#line 363
    if ((unsigned long )ptr == (unsigned long )((char *)0)) {
      {
#line 365
      cpo_error = (char const   *)0;
#line 365
      tmp___2 = __errno_location();
#line 365
      *tmp___2 = 12;
      }
#line 366
      return (-1);
    }
    {
#line 369
    bytes = write(ofile, (void const   *)ptr, (size_t )len);
#line 370
    free((void *)ptr);
    }
#line 372
    if (bytes == -1L) {
      {
#line 374
      cpo_error = "error writing data";
#line 374
      tmp___3 = __errno_location();
#line 374
      tmp___4 = __errno_location();
#line 374
      *tmp___3 = *tmp___4;
      }
#line 375
      return (-1);
    } else
#line 377
    if (bytes != (long )len) {
      {
#line 379
      cpo_error = "wrote incomplete chunk";
#line 379
      tmp___5 = __errno_location();
#line 379
      *tmp___5 = 5;
      }
#line 380
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return (0);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int do_raw___0(hfsfile *ifile , int ofile ) 
{ 
  char buf[2048] ;
  long chunk ;
  long bytes ;
  unsigned long tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    tmp = hfs_read(ifile, (void *)(buf), sizeof(buf));
#line 399
    chunk = (long )tmp;
    }
#line 400
    if (chunk == -1L) {
      {
#line 402
      cpo_error = hfs_error;
#line 402
      tmp___0 = __errno_location();
#line 402
      tmp___1 = __errno_location();
#line 402
      *tmp___0 = *tmp___1;
      }
#line 403
      return (-1);
    } else
#line 405
    if (chunk == 0L) {
#line 406
      goto while_break;
    }
    {
#line 408
    bytes = write(ofile, (void const   *)(buf), (size_t )chunk);
    }
#line 409
    if (bytes == -1L) {
      {
#line 411
      cpo_error = "error writing data";
#line 411
      tmp___2 = __errno_location();
#line 411
      tmp___3 = __errno_location();
#line 411
      *tmp___2 = *tmp___3;
      }
#line 412
      return (-1);
    } else
#line 414
    if (bytes != chunk) {
      {
#line 416
      cpo_error = "wrote incomplete chunk";
#line 416
      tmp___4 = __errno_location();
#line 416
      *tmp___4 = 5;
      }
#line 417
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  return (0);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static char name___0[36]  ;
#line 430 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static hfsfile *opensrc___0(hfsvol *vol , char const   *srcname , char const   **dsthint ,
                            char const   *ext ) 
{ 
  hfsfile *file___0 ;
  hfsdirent ent ;
  char *ptr ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 439
  file___0 = hfs_open(vol, srcname);
  }
#line 440
  if ((unsigned long )file___0 == (unsigned long )((hfsfile *)0)) {
    {
#line 442
    cpo_error = hfs_error;
#line 442
    tmp = __errno_location();
#line 442
    tmp___0 = __errno_location();
#line 442
    *tmp = *tmp___0;
    }
#line 443
    return ((hfsfile *)0);
  }
  {
#line 446
  tmp___3 = hfs_fstat(file___0, & ent);
  }
#line 446
  if (tmp___3 == -1) {
    {
#line 448
    cpo_error = hfs_error;
#line 448
    tmp___1 = __errno_location();
#line 448
    tmp___2 = __errno_location();
#line 448
    *tmp___1 = *tmp___2;
#line 450
    hfs_close(file___0);
    }
#line 451
    return ((hfsfile *)0);
  }
  {
#line 454
  strcpy((char */* __restrict  */)(name___0), (char const   */* __restrict  */)(ent.name));
#line 456
  ptr = name___0;
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! *ptr) {
#line 456
      goto while_break;
    }
    {
#line 460
    if ((int )*ptr == 47) {
#line 460
      goto case_47;
    }
#line 464
    if ((int )*ptr == 32) {
#line 464
      goto case_32;
    }
#line 458
    goto switch_break;
    case_47: /* CIL Label */ 
#line 461
    *ptr = (char )'-';
#line 462
    goto switch_break;
    case_32: /* CIL Label */ 
#line 465
    *ptr = (char )'_';
#line 466
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 456
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  if (ext) {
    {
#line 471
    strcat((char */* __restrict  */)(name___0), (char const   */* __restrict  */)ext);
    }
  }
#line 473
  *dsthint = (char const   *)(name___0);
#line 475
  return (file___0);
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int opendst___0(char const   *dstname , char const   *hint ) 
{ 
  int fd ;
  struct stat sbuf ;
  char *path ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 487
  tmp___4 = strcmp(dstname, "-");
  }
#line 487
  if (tmp___4 == 0) {
    {
#line 488
    fd = dup(1);
    }
  } else {
    {
#line 492
    path = (char *)0;
#line 494
    tmp___3 = stat((char const   */* __restrict  */)dstname, (struct stat */* __restrict  */)(& sbuf));
    }
#line 494
    if (tmp___3 != -1) {
#line 494
      if ((sbuf.st_mode & 61440U) == 16384U) {
        {
#line 497
        tmp = strlen(dstname);
#line 497
        tmp___0 = strlen(hint);
#line 497
        tmp___1 = malloc(((tmp + 1UL) + tmp___0) + 1UL);
#line 497
        path = (char *)tmp___1;
        }
#line 498
        if ((unsigned long )path == (unsigned long )((char *)0)) {
          {
#line 500
          cpo_error = (char const   *)0;
#line 500
          tmp___2 = __errno_location();
#line 500
          *tmp___2 = 12;
          }
#line 501
          return (-1);
        }
        {
#line 504
        strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)dstname);
#line 505
        strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
#line 506
        strcat((char */* __restrict  */)path, (char const   */* __restrict  */)hint);
#line 508
        dstname = (char const   *)path;
        }
      }
    }
    {
#line 511
    fd = open(dstname, 577, 438);
    }
#line 513
    if (path) {
      {
#line 514
      free((void *)path);
      }
    }
  }
#line 517
  if (fd == -1) {
    {
#line 519
    cpo_error = "error opening destination file";
#line 519
    tmp___5 = __errno_location();
#line 519
    tmp___6 = __errno_location();
#line 519
    *tmp___5 = *tmp___6;
    }
#line 520
    return (-1);
  }
#line 523
  return (fd);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static int openfiles(hfsvol *vol , char const   *srcname , char const   *dstname ,
                     char const   *ext , hfsfile **ifile , int *ofile ) 
{ 
  char const   *dsthint ;

  {
  {
#line 536
  *ifile = opensrc___0(vol, srcname, & dsthint, ext);
  }
#line 537
  if ((unsigned long )*ifile == (unsigned long )((hfsfile *)0)) {
#line 538
    return (-1);
  }
  {
#line 540
  *ofile = opendst___0(dstname, dsthint);
  }
#line 541
  if (*ofile == -1) {
    {
#line 543
    hfs_close(*ifile);
    }
#line 544
    return (-1);
  }
#line 547
  return (0);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
static void closefiles___0(hfsfile *ifile , int ofile , int *result ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 557
  tmp___1 = close(ofile);
  }
#line 557
  if (tmp___1 == -1) {
#line 557
    if (*result == 0) {
      {
#line 559
      cpo_error = "error closing destination file";
#line 559
      tmp = __errno_location();
#line 559
      tmp___0 = __errno_location();
#line 559
      *tmp = *tmp___0;
#line 560
      *result = -1;
      }
    }
  }
  {
#line 563
  tmp___4 = hfs_close(ifile);
  }
#line 563
  if (tmp___4 == -1) {
#line 563
    if (*result == 0) {
      {
#line 565
      cpo_error = hfs_error;
#line 565
      tmp___2 = __errno_location();
#line 565
      tmp___3 = __errno_location();
#line 565
      *tmp___2 = *tmp___3;
#line 566
      *result = -1;
      }
    }
  }
#line 568
  return;
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
int cpo_macb(hfsvol *vol , char const   *srcname , char const   *dstname ) 
{ 
  hfsfile *ifile ;
  int ofile ;
  int result ;
  int tmp ;

  {
  {
#line 579
  result = 0;
#line 581
  tmp = openfiles(vol, srcname, dstname, ".bin", & ifile, & ofile);
  }
#line 581
  if (tmp == -1) {
#line 582
    return (-1);
  }
  {
#line 584
  result = do_macb___0(ifile, ofile);
#line 586
  closefiles___0(ifile, ofile, & result);
  }
#line 588
  return (result);
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
int cpo_binh(hfsvol *vol , char const   *srcname , char const   *dstname ) 
{ 
  hfsfile *ifile ;
  int ofile ;
  int result ;
  int tmp ;

  {
  {
#line 600
  tmp = openfiles(vol, srcname, dstname, ".hqx", & ifile, & ofile);
  }
#line 600
  if (tmp == -1) {
#line 601
    return (-1);
  }
  {
#line 603
  result = do_binh___0(ifile, ofile);
#line 605
  closefiles___0(ifile, ofile, & result);
  }
#line 607
  return (result);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
int cpo_text(hfsvol *vol , char const   *srcname , char const   *dstname ) 
{ 
  char const   *ext ;
  hfsfile *ifile ;
  int ofile ;
  int result ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 616
  ext = (char const   *)0;
#line 618
  result = 0;
#line 620
  tmp = strchr(srcname, '.');
  }
#line 620
  if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 621
    ext = ".txt";
  }
  {
#line 623
  tmp___0 = openfiles(vol, srcname, dstname, ext, & ifile, & ofile);
  }
#line 623
  if (tmp___0 == -1) {
#line 624
    return (-1);
  }
  {
#line 626
  result = do_text___0(ifile, ofile);
#line 628
  closefiles___0(ifile, ofile, & result);
  }
#line 630
  return (result);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/copyout.c"
int cpo_raw(hfsvol *vol , char const   *srcname , char const   *dstname ) 
{ 
  hfsfile *ifile ;
  int ofile ;
  int result ;
  int tmp ;

  {
  {
#line 640
  result = 0;
#line 642
  tmp = openfiles(vol, srcname, dstname, (char const   *)0, & ifile, & ofile);
  }
#line 642
  if (tmp == -1) {
#line 643
    return (-1);
  }
  {
#line 645
  result = do_raw___0(ifile, ofile);
#line 647
  closefiles___0(ifile, ofile, & result);
  }
#line 649
  return (result);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/hmkdir.c"
int hmkdir_main(int argc , char **argv ) 
{ 
  hfsvol *vol ;
  char **fargv ;
  int fargc ;
  int i ;
  int result ;
  mountent *tmp ;
  int tmp___0 ;

  {
#line 42
  result = 0;
#line 44
  if (argc < 2) {
    {
#line 46
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s hfs-path [...]\n",
            argv0);
    }
#line 47
    return (1);
  }
  {
#line 50
  tmp = hcwd_getvol(-1);
#line 50
  vol = hfsutil_remount(tmp, 2);
  }
#line 51
  if ((unsigned long )vol == (unsigned long )((hfsvol *)0)) {
#line 52
    return (1);
  }
  {
#line 54
  fargv = hfsutil_glob(vol, argc - 1, argv + 1, & fargc, & result);
  }
#line 56
  if (result == 0) {
#line 58
    i = 0;
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! (i < fargc)) {
#line 58
        goto while_break;
      }
      {
#line 60
      tmp___0 = hfs_mkdir(vol, (char const   *)*(fargv + i));
      }
#line 60
      if (tmp___0 == -1) {
        {
#line 62
        hfsutil_perrorp((char const   *)*(fargv + i));
#line 63
        result = 1;
        }
      }
#line 58
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 68
  hfsutil_unmount(vol, & result);
  }
#line 70
  if (fargv) {
    {
#line 71
    free((void *)fargv);
    }
  }
#line 73
  return (result);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_init(hfsvol *vol ) 
{ 
  bcache *cache ;
  int i ;
  void *tmp ;
  int *tmp___0 ;
  bucket *b ;

  {
  {
#line 49
  tmp = malloc(sizeof(bcache ));
#line 49
  cache = (bcache *)tmp;
  }
#line 50
  if ((unsigned long )cache == (unsigned long )((bcache *)0)) {
    {
#line 51
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 51
      hfs_error = (char const   *)0;
#line 51
      tmp___0 = __errno_location();
#line 51
      *tmp___0 = 12;
      }
#line 51
      goto fail;
#line 51
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 53
  vol->cache = cache;
#line 55
  cache->vol = vol;
#line 56
  cache->tail = & cache->chain[127];
#line 58
  cache->hits = 0U;
#line 59
  cache->misses = 0U;
#line 61
  i = 0;
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 61
    if (! (i < 128)) {
#line 61
      goto while_break___0;
    }
#line 63
    b = & cache->chain[i];
#line 65
    b->flags = 0;
#line 66
    b->count = 0U;
#line 68
    b->bnum = 0UL;
#line 69
    b->data = & cache->pool[i];
#line 71
    b->cnext = b + 1;
#line 72
    b->cprev = b - 1;
#line 74
    b->hnext = (struct _bucket_ *)0;
#line 75
    b->hprev = (struct _bucket_ **)0;
#line 61
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 78
  cache->chain[0].cprev = cache->tail;
#line 79
  (cache->tail)->cnext = & cache->chain[0];
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 81
    if (! (i < 32)) {
#line 81
      goto while_break___1;
    }
#line 82
    cache->hash[i] = (bucket *)0;
#line 81
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 84
  return (0);
  fail: 
#line 87
  return (-1);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static int fillchain(hfsvol *vol , bucket **bptr , unsigned int *count ) 
{ 
  bucket *blist[16] ;
  bucket **start ;
  unsigned long bnum ;
  unsigned int len ;
  unsigned int i ;
  unsigned int tmp ;
  int tmp___0 ;
  block buffer[16] ;
  int tmp___1 ;

  {
#line 163
  start = bptr;
#line 167
  len = 0U;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (len < 16U) {
#line 167
      if (! ((unsigned int )(bptr - start) < *count)) {
#line 167
        goto while_break;
      }
    } else {
#line 167
      goto while_break;
    }
#line 170
    if ((*bptr)->flags & 1) {
#line 171
      goto __Cont;
    }
#line 173
    if (len > 0U) {
#line 173
      if ((*bptr)->bnum != bnum) {
#line 174
        goto while_break;
      }
    }
#line 176
    tmp = len;
#line 176
    len ++;
#line 176
    blist[tmp] = *bptr;
#line 177
    bnum = (*bptr)->bnum + 1UL;
    __Cont: /* CIL Label */ 
#line 167
    bptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  *count = (unsigned int )(bptr - start);
#line 182
  if (len == 0U) {
#line 183
    goto done;
  } else
#line 184
  if (len == 1U) {
    {
#line 186
    tmp___0 = b_readpb(vol, vol->vstart + (blist[0])->bnum, (blist[0])->data, 1U);
    }
#line 186
    if (tmp___0 == -1) {
#line 188
      goto fail;
    }
  } else {
    {
#line 194
    tmp___1 = b_readpb(vol, vol->vstart + (blist[0])->bnum, buffer, len);
    }
#line 194
    if (tmp___1 == -1) {
#line 195
      goto fail;
    }
#line 197
    i = 0U;
    {
#line 197
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 197
      if (! (i < len)) {
#line 197
        goto while_break___0;
      }
      {
#line 198
      memcpy((void */* __restrict  */)(blist[i])->data, (void const   */* __restrict  */)(buffer[i]),
             (size_t )512);
#line 197
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 201
  i = 0U;
  {
#line 201
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 201
    if (! (i < len)) {
#line 201
      goto while_break___1;
    }
#line 203
    (blist[i])->flags |= 1;
#line 204
    (blist[i])->flags &= -3;
#line 201
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
#line 208
  return (0);
  fail: 
#line 211
  return (-1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static int flushchain(hfsvol *vol , bucket **bptr , unsigned int *count ) 
{ 
  bucket *blist[16] ;
  bucket **start ;
  unsigned long bnum ;
  unsigned int len ;
  unsigned int i ;
  unsigned int tmp ;
  int tmp___0 ;
  block buffer[16] ;
  int tmp___1 ;

  {
#line 221
  start = bptr;
#line 225
  len = 0U;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (len < 16U) {
#line 225
      if (! ((unsigned int )(bptr - start) < *count)) {
#line 225
        goto while_break;
      }
    } else {
#line 225
      goto while_break;
    }
#line 228
    if (! ((*bptr)->flags & 1)) {
#line 229
      goto __Cont;
    } else
#line 228
    if (! ((*bptr)->flags & 2)) {
#line 229
      goto __Cont;
    }
#line 231
    if (len > 0U) {
#line 231
      if ((*bptr)->bnum != bnum) {
#line 232
        goto while_break;
      }
    }
#line 234
    tmp = len;
#line 234
    len ++;
#line 234
    blist[tmp] = *bptr;
#line 235
    bnum = (*bptr)->bnum + 1UL;
    __Cont: /* CIL Label */ 
#line 225
    bptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  *count = (unsigned int )(bptr - start);
#line 240
  if (len == 0U) {
#line 241
    goto done;
  } else
#line 242
  if (len == 1U) {
    {
#line 244
    tmp___0 = b_writepb(vol, vol->vstart + (blist[0])->bnum, (block const   *)(blist[0])->data,
                        1U);
    }
#line 244
    if (tmp___0 == -1) {
#line 246
      goto fail;
    }
  } else {
#line 252
    i = 0U;
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (! (i < len)) {
#line 252
        goto while_break___0;
      }
      {
#line 253
      memcpy((void */* __restrict  */)(buffer[i]), (void const   */* __restrict  */)(blist[i])->data,
             (size_t )512);
#line 252
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 255
    tmp___1 = b_writepb(vol, vol->vstart + (blist[0])->bnum, (block const   *)(buffer),
                        len);
    }
#line 255
    if (tmp___1 == -1) {
#line 256
      goto fail;
    }
  }
#line 259
  i = 0U;
  {
#line 259
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 259
    if (! (i < len)) {
#line 259
      goto while_break___1;
    }
#line 260
    (blist[i])->flags &= -3;
#line 259
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
#line 263
  return (0);
  fail: 
#line 266
  return (-1);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static int compare___0(bucket const   **b1 , bucket const   **b2 ) 
{ 
  long diff ;

  {
#line 278
  diff = (long )((*b1)->bnum - (*b2)->bnum);
#line 280
  if (diff < 0L) {
#line 281
    return (-1);
  } else
#line 282
  if (diff > 0L) {
#line 283
    return (1);
  } else {
#line 285
    return (0);
  }
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static int dobuckets(hfsvol *vol , bucket **chain , unsigned int len , int (*func)(hfsvol * ,
                                                                                   bucket ** ,
                                                                                   unsigned int * ) ) 
{ 
  unsigned int count ;
  unsigned int i ;
  int result ;
  int tmp ;

  {
  {
#line 297
  result = 0;
#line 299
  qsort((void *)chain, (size_t )len, sizeof(*chain), (int (*)(void const   * , void const   * ))(& compare___0));
#line 302
  i = 0U;
  }
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! (i < len)) {
#line 302
      goto while_break;
    }
    {
#line 304
    count = len - i;
#line 305
    tmp = (*func)(vol, chain + i, & count);
    }
#line 305
    if (tmp == -1) {
#line 306
      result = -1;
    }
#line 302
    i += count;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  return (result);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_flush(hfsvol *vol ) 
{ 
  bcache *cache ;
  bucket *chain[128] ;
  int i ;
  int tmp ;

  {
#line 321
  cache = vol->cache;
#line 325
  if ((unsigned long )cache == (unsigned long )((bcache *)0)) {
#line 326
    goto done;
  } else
#line 325
  if (vol->flags & 4) {
#line 326
    goto done;
  }
#line 328
  i = 0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < 128)) {
#line 328
      goto while_break;
    }
#line 329
    chain[i] = & cache->chain[i];
#line 328
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 331
  tmp = dobuckets(vol, chain, 128U, & flushchain);
  }
#line 331
  if (tmp == -1) {
#line 332
    goto fail;
  }
  done: 
#line 340
  return (0);
  fail: 
#line 343
  return (-1);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_finish(hfsvol *vol ) 
{ 
  int result ;

  {
#line 352
  result = 0;
#line 354
  if ((unsigned long )vol->cache == (unsigned long )((bcache *)0)) {
#line 355
    goto done;
  }
  {
#line 361
  result = b_flush(vol);
  }
#line 363
  if (vol->cache) {
    {
#line 363
    free((void *)vol->cache);
    }
  }
#line 364
  vol->cache = (bcache *)0;
  done: 
#line 367
  return (result);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static bucket *findbucket(bcache *cache , unsigned long bnum , bucket ***hslot ) 
{ 
  bucket *b ;

  {
#line 379
  *hslot = & cache->hash[bnum & 31UL];
#line 381
  b = *(*hslot);
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! b) {
#line 381
      goto while_break;
    }
#line 383
    if (b->flags & 1) {
#line 383
      if (b->bnum == bnum) {
#line 384
        goto while_break;
      }
    }
#line 381
    b = b->hnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  return (b);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static int reuse(bcache *cache , bucket *b , unsigned long bnum ) 
{ 
  bucket *chain[16] ;
  bucket *bptr ;
  int i ;
  int tmp ;

  {
#line 407
  if (b->flags & 1) {
#line 407
    if (b->flags & 2) {
#line 411
      bptr = b;
#line 411
      i = 0;
      {
#line 411
      while (1) {
        while_continue: /* CIL Label */ ;
#line 411
        if (! (i < 16)) {
#line 411
          goto while_break;
        }
#line 413
        chain[i] = bptr;
#line 414
        bptr = bptr->cprev;
#line 411
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 417
      tmp = dobuckets(cache->vol, chain, 16U, & flushchain);
      }
#line 417
      if (tmp == -1) {
#line 418
        goto fail;
      }
    }
  }
#line 421
  b->flags &= -2;
#line 422
  b->count = 1U;
#line 423
  b->bnum = bnum;
#line 425
  return (0);
  fail: 
#line 428
  return (-1);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static void cplace(bcache *cache , bucket *b ) 
{ 
  bucket *p ;

  {
#line 440
  p = (cache->tail)->cnext;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (p->count > 1U)) {
#line 440
      goto while_break;
    }
#line 441
    (p->count) --;
#line 440
    p = p->cnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  (b->cnext)->cprev = b->cprev;
#line 444
  (b->cprev)->cnext = b->cnext;
#line 446
  if ((unsigned long )cache->tail == (unsigned long )b) {
#line 447
    cache->tail = b->cprev;
  }
#line 449
  b->cprev = p->cprev;
#line 450
  b->cnext = p;
#line 452
  (p->cprev)->cnext = b;
#line 453
  p->cprev = b;
#line 454
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static void hplace(bucket **hslot , bucket *b ) 
{ 


  {
#line 463
  if ((unsigned long )*hslot != (unsigned long )b) {
#line 465
    if (b->hprev) {
#line 466
      *(b->hprev) = b->hnext;
    }
#line 467
    if (b->hnext) {
#line 468
      (b->hnext)->hprev = b->hprev;
    }
#line 470
    b->hprev = hslot;
#line 471
    b->hnext = *hslot;
#line 473
    if (*hslot) {
#line 474
      (*hslot)->hprev = & b->hnext;
    }
#line 476
    *hslot = b;
  }
#line 478
  return;
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
static bucket *getbucket(bcache *cache , unsigned long bnum , int fill ) 
{ 
  bucket **hslot ;
  bucket *b ;
  bucket *p ;
  bucket *bptr ;
  bucket *chain[16] ;
  bucket **slots[16] ;
  int tmp ;
  unsigned int len ;
  unsigned int tmp___0 ;
  bucket *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 490
  b = findbucket(cache, bnum, & hslot);
  }
#line 492
  if (b) {
#line 496
    (cache->hits) ++;
#line 498
    (b->count) ++;
#line 498
    if (b->count > (b->cprev)->count) {
#line 498
      if ((unsigned long )b != (unsigned long )(cache->tail)->cnext) {
#line 501
        p = b->cprev;
#line 503
        (p->cprev)->cnext = b;
#line 504
        (b->cnext)->cprev = p;
#line 506
        p->cnext = b->cnext;
#line 507
        b->cprev = p->cprev;
#line 509
        p->cprev = b;
#line 510
        b->cnext = p;
#line 512
        if ((unsigned long )cache->tail == (unsigned long )b) {
#line 513
          cache->tail = p;
        }
      }
    }
  } else {
    {
#line 520
    (cache->misses) ++;
#line 522
    b = cache->tail;
#line 524
    tmp = reuse(cache, b, bnum);
    }
#line 524
    if (tmp == -1) {
#line 525
      goto fail;
    }
#line 527
    if (fill) {
#line 529
      len = 0U;
#line 531
      chain[len] = b;
#line 532
      tmp___0 = len;
#line 532
      len ++;
#line 532
      slots[tmp___0] = hslot;
#line 534
      bptr = b->cprev;
      {
#line 534
      while (1) {
        while_continue: /* CIL Label */ ;
#line 534
        if (len < (unsigned int )(16 >> 1)) {
#line 534
          bnum ++;
#line 534
          if (! (bnum < (cache->vol)->vlen)) {
#line 534
            goto while_break;
          }
        } else {
#line 534
          goto while_break;
        }
        {
#line 538
        tmp___1 = findbucket(cache, bnum, & hslot);
        }
#line 538
        if (tmp___1) {
#line 539
          goto while_break;
        }
        {
#line 541
        tmp___2 = reuse(cache, bptr, bnum);
        }
#line 541
        if (tmp___2 == -1) {
#line 542
          goto fail;
        }
#line 544
        chain[len] = bptr;
#line 545
        tmp___3 = len;
#line 545
        len ++;
#line 545
        slots[tmp___3] = hslot;
#line 534
        bptr = bptr->cprev;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 548
      tmp___4 = dobuckets(cache->vol, chain, len, & fillchain);
      }
#line 548
      if (tmp___4 == -1) {
#line 549
        goto fail;
      }
      {
#line 551
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 551
        len --;
#line 551
        if (! len) {
#line 551
          goto while_break___0;
        }
        {
#line 553
        cplace(cache, chain[len]);
#line 554
        hplace(slots[len], chain[len]);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 557
      hslot = slots[0];
    }
    {
#line 562
    cplace(cache, b);
    }
  }
  {
#line 567
  hplace(hslot, b);
  }
#line 569
  return (b);
  fail: 
#line 572
  return ((bucket *)0);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_readpb(hfsvol *vol , unsigned long bnum , block *bp , unsigned int blen ) 
{ 
  unsigned long nblocks ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 592
  nblocks = os_seek(& vol->priv, bnum);
  }
#line 593
  if (nblocks == 0xffffffffffffffffUL) {
#line 594
    goto fail;
  }
#line 596
  if (nblocks != bnum) {
    {
#line 597
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 597
      hfs_error = "block seek failed for read";
#line 597
      tmp = __errno_location();
#line 597
      *tmp = 5;
      }
#line 597
      goto fail;
#line 597
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 599
  nblocks = os_read(& vol->priv, (void *)bp, (unsigned long )blen);
  }
#line 600
  if (nblocks == 0xffffffffffffffffUL) {
#line 601
    goto fail;
  }
#line 603
  if (nblocks != (unsigned long )blen) {
    {
#line 604
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 604
      hfs_error = "incomplete block read";
#line 604
      tmp___0 = __errno_location();
#line 604
      *tmp___0 = 5;
      }
#line 604
      goto fail;
#line 604
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 606
  return (0);
  fail: 
#line 609
  return (-1);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_writepb(hfsvol *vol , unsigned long bnum , block const   *bp , unsigned int blen ) 
{ 
  unsigned long nblocks ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 630
  nblocks = os_seek(& vol->priv, bnum);
  }
#line 631
  if (nblocks == 0xffffffffffffffffUL) {
#line 632
    goto fail;
  }
#line 634
  if (nblocks != bnum) {
    {
#line 635
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 635
      hfs_error = "block seek failed for write";
#line 635
      tmp = __errno_location();
#line 635
      *tmp = 5;
      }
#line 635
      goto fail;
#line 635
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 637
  nblocks = os_write(& vol->priv, (void const   *)bp, (unsigned long )blen);
  }
#line 638
  if (nblocks == 0xffffffffffffffffUL) {
#line 639
    goto fail;
  }
#line 641
  if (nblocks != (unsigned long )blen) {
    {
#line 642
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 642
      hfs_error = "incomplete block write";
#line 642
      tmp___0 = __errno_location();
#line 642
      *tmp___0 = 5;
      }
#line 642
      goto fail;
#line 642
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 644
  return (0);
  fail: 
#line 647
  return (-1);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_readlb(hfsvol *vol , unsigned long bnum , block *bp ) 
{ 
  int *tmp ;
  bucket *b ;
  int tmp___0 ;

  {
#line 656
  if (vol->vlen > 0UL) {
#line 656
    if (bnum >= vol->vlen) {
      {
#line 657
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 657
        hfs_error = "read nonexistent logical block";
#line 657
        tmp = __errno_location();
#line 657
        *tmp = 5;
        }
#line 657
        goto fail;
#line 657
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 659
  if (vol->cache) {
    {
#line 663
    b = getbucket(vol->cache, bnum, 1);
    }
#line 664
    if ((unsigned long )b == (unsigned long )((bucket *)0)) {
#line 665
      goto fail;
    }
    {
#line 667
    memcpy((void */* __restrict  */)bp, (void const   */* __restrict  */)b->data,
           (size_t )512);
    }
  } else {
    {
#line 671
    tmp___0 = b_readpb(vol, vol->vstart + bnum, bp, 1U);
    }
#line 671
    if (tmp___0 == -1) {
#line 672
      goto fail;
    }
  }
#line 675
  return (0);
  fail: 
#line 678
  return (-1);
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_writelb(hfsvol *vol , unsigned long bnum , block const   *bp ) 
{ 
  int *tmp ;
  bucket *b ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 687
  if (vol->vlen > 0UL) {
#line 687
    if (bnum >= vol->vlen) {
      {
#line 688
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 688
        hfs_error = "write nonexistent logical block";
#line 688
        tmp = __errno_location();
#line 688
        *tmp = 5;
        }
#line 688
        goto fail;
#line 688
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 690
  if (vol->cache) {
    {
#line 694
    b = getbucket(vol->cache, bnum, 0);
    }
#line 695
    if ((unsigned long )b == (unsigned long )((bucket *)0)) {
#line 696
      goto fail;
    }
#line 698
    if (! (b->flags & 1)) {
      {
#line 701
      memcpy((void */* __restrict  */)b->data, (void const   */* __restrict  */)bp,
             (size_t )512);
#line 702
      b->flags |= 3;
      }
    } else {
      {
#line 698
      tmp___0 = memcmp((void const   *)b->data, (void const   *)bp, (size_t )512);
      }
#line 698
      if (tmp___0 != 0) {
        {
#line 701
        memcpy((void */* __restrict  */)b->data, (void const   */* __restrict  */)bp,
               (size_t )512);
#line 702
        b->flags |= 3;
        }
      }
    }
  } else {
    {
#line 707
    tmp___1 = b_writepb(vol, vol->vstart + bnum, bp, 1U);
    }
#line 707
    if (tmp___1 == -1) {
#line 708
      goto fail;
    }
  }
#line 711
  return (0);
  fail: 
#line 714
  return (-1);
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_readab(hfsvol *vol , unsigned int anum , unsigned int index___0 , block *bp ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 725
  if (anum >= (unsigned int )vol->mdb.drNmAlBlks) {
    {
#line 726
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 726
      hfs_error = "read nonexistent allocation block";
#line 726
      tmp = __errno_location();
#line 726
      *tmp = 5;
      }
#line 726
      goto fail;
#line 726
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 727
  if (vol->vbm) {
#line 727
    if (! ((int const   )*((byte const   *)vol->vbm + (anum >> 3)) & (int const   )(128 >> (anum & 7U)))) {
      {
#line 728
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 728
        hfs_error = "read unallocated block";
#line 728
        tmp___0 = __errno_location();
#line 728
        *tmp___0 = 5;
        }
#line 728
        goto fail;
#line 728
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 730
  tmp___1 = b_readlb(vol, (unsigned long )(((unsigned int )vol->mdb.drAlBlSt + anum * vol->lpa) + index___0),
                     bp);
  }
#line 730
  return (tmp___1);
  fail: 
#line 733
  return (-1);
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
int b_writeab(hfsvol *vol , unsigned int anum , unsigned int index___0 , block const   *bp ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 745
  if (anum >= (unsigned int )vol->mdb.drNmAlBlks) {
    {
#line 746
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 746
      hfs_error = "write nonexistent allocation block";
#line 746
      tmp = __errno_location();
#line 746
      *tmp = 5;
      }
#line 746
      goto fail;
#line 746
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 747
  if (vol->vbm) {
#line 747
    if (! ((int const   )*((byte const   *)vol->vbm + (anum >> 3)) & (int const   )(128 >> (anum & 7U)))) {
      {
#line 748
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 748
        hfs_error = "write unallocated block";
#line 748
        tmp___0 = __errno_location();
#line 748
        *tmp___0 = 5;
        }
#line 748
        goto fail;
#line 748
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 750
  tmp___1 = v_dirty(vol);
  }
#line 750
  if (tmp___1 == -1) {
#line 751
    goto fail;
  }
  {
#line 753
  tmp___2 = b_writelb(vol, (unsigned long )(((unsigned int )vol->mdb.drAlBlSt + anum * vol->lpa) + index___0),
                      bp);
  }
#line 753
  return (tmp___2);
  fail: 
#line 756
  return (-1);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/libhfs/block.c"
unsigned long b_size(hfsvol *vol ) 
{ 
  unsigned long low ;
  unsigned long high ;
  unsigned long mid ;
  block b ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 768
  high = os_seek(& vol->priv, 0xffffffffffffffffUL);
  }
#line 770
  if (high != 0xffffffffffffffffUL) {
#line 770
    if (high > 0UL) {
#line 771
      return (high);
    }
  }
  {
#line 775
  tmp___0 = b_readpb(vol, 0UL, & b, 1U);
  }
#line 775
  if (tmp___0 == -1) {
    {
#line 776
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 776
      hfs_error = "size of medium indeterminable or empty";
#line 776
      tmp = __errno_location();
#line 776
      *tmp = 5;
      }
#line 776
      goto fail;
#line 776
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 778
  low = 0UL;
#line 778
  high = 2880UL;
  {
#line 778
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 778
    if (high > 0UL) {
      {
#line 778
      tmp___1 = b_readpb(vol, high - 1UL, & b, 1U);
      }
#line 778
      if (! (tmp___1 != -1)) {
#line 778
        goto while_break___0;
      }
    } else {
#line 778
      goto while_break___0;
    }
#line 781
    low = high - 1UL;
#line 778
    high <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 783
  if (high == 0UL) {
    {
#line 784
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 784
      hfs_error = "size of medium indeterminable or too large";
#line 784
      tmp___2 = __errno_location();
#line 784
      *tmp___2 = 5;
      }
#line 784
      goto fail;
#line 784
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 788
  if (low == 2879UL) {
    {
#line 788
    tmp___3 = b_readpb(vol, 2880UL, & b, 1U);
    }
#line 788
    if (tmp___3 == -1) {
#line 789
      return (2880UL);
    }
  }
  {
#line 793
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 793
    if (! (low < high - 1UL)) {
#line 793
      goto while_break___2;
    }
    {
#line 795
    mid = (low + high) >> 1;
#line 797
    tmp___4 = b_readpb(vol, mid, & b, 1U);
    }
#line 797
    if (tmp___4 == -1) {
#line 798
      high = mid;
    } else {
#line 800
      low = mid;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 803
  return (low + 1UL);
  fail: 
#line 806
  return (0UL);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/glob.c"
static int strmatch(char const   *str , char const   *pat ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  unsigned char p0 ;
  unsigned char p1 ;
  unsigned char s ;

  {
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if ((int const   )*str == 0) {
#line 43
      if ((int const   )*pat != 0) {
#line 43
        if ((int const   )*pat != 42) {
#line 44
          return (0);
        }
      }
    }
    {
#line 48
    if ((int const   )*pat == 0) {
#line 48
      goto case_0;
    }
#line 51
    if ((int const   )*pat == 42) {
#line 51
      goto case_42;
    }
#line 64
    if ((int const   )*pat == 63) {
#line 64
      goto case_63;
    }
#line 67
    if ((int const   )*pat == 91) {
#line 67
      goto case_91;
    }
#line 117
    if ((int const   )*pat == 92) {
#line 117
      goto case_92;
    }
#line 123
    goto switch_default;
    case_0: /* CIL Label */ 
#line 49
    return ((int const   )*str == 0);
    case_42: /* CIL Label */ 
#line 52
    pat ++;
#line 52
    if ((int const   )*pat == 0) {
#line 53
      return (1);
    }
    {
#line 55
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 57
      tmp = strmatch(str, pat);
      }
#line 57
      if (tmp) {
#line 58
        return (1);
      }
#line 60
      tmp___0 = str;
#line 60
      str ++;
#line 60
      if ((int const   )*tmp___0 == 0) {
#line 61
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_63: /* CIL Label */ 
#line 65
    goto switch_break;
    case_91: /* CIL Label */ 
#line 69
    pat ++;
    {
#line 71
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 75
      p0 = (unsigned char )*pat;
#line 77
      if ((int )p0 == 93) {
#line 78
        return (0);
      } else
#line 77
      if ((int )p0 == 0) {
#line 78
        return (0);
      }
#line 80
      s = (unsigned char )*str;
#line 82
      if ((int const   )hfs_charorder[p0] == (int const   )hfs_charorder[s]) {
#line 83
        goto while_break___1;
      }
#line 85
      if ((int const   )*(pat + 1) == 45) {
#line 87
        p1 = (unsigned char )*(pat + 2);
#line 89
        if ((int )p1 == 0) {
#line 90
          return (0);
        }
#line 92
        if ((int const   )hfs_charorder[p0] <= (int const   )hfs_charorder[s]) {
#line 92
          if ((int const   )hfs_charorder[p1] >= (int const   )hfs_charorder[s]) {
#line 96
            goto while_break___1;
          } else {
#line 92
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 92
        if ((int const   )hfs_charorder[p0] >= (int const   )hfs_charorder[s]) {
#line 92
          if ((int const   )hfs_charorder[p1] <= (int const   )hfs_charorder[s]) {
#line 96
            goto while_break___1;
          }
        }
#line 98
        pat += 2;
      }
#line 101
      pat ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 104
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 104
      if (! ((int const   )*pat != 93)) {
#line 104
        goto while_break___2;
      }
#line 106
      if ((int const   )*pat == 0) {
#line 108
        pat --;
#line 109
        goto while_break___2;
      }
#line 112
      pat ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 115
    goto switch_break;
    case_92: /* CIL Label */ 
#line 118
    pat ++;
#line 118
    if ((int const   )*pat == 0) {
#line 119
      return (0);
    }
    switch_default: /* CIL Label */ 
#line 124
    if ((int const   )hfs_charorder[(unsigned char )*pat] != (int const   )hfs_charorder[(unsigned char )*str]) {
#line 126
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
#line 129
    pat ++;
#line 129
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/glob.c"
static int doglob(hfsvol *vol , dlist *list , char const   *dir , char const   *rem ) 
{ 
  dstring new ;
  int special ;
  int len ;
  int result ;
  char const   *obrace ;
  char const   *cbrace ;
  char const   *ptr ;
  char const   *elt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  hfsdirent ent ;
  hfsdir *d ;
  dstring pat ;
  int found ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *ptr___0 ;
  char *rem___0 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 141
  result = 0;
#line 144
  dstr_init(& new);
#line 146
  special = 0;
#line 147
  cbrace = (char const   *)0;
#line 147
  obrace = cbrace;
#line 149
  ptr = rem;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (*ptr) {
#line 149
      if (! obrace) {
#line 149
        if (! ((int const   )*ptr != 58)) {
#line 149
          goto while_break;
        }
      }
    } else {
#line 149
      goto while_break;
    }
    {
#line 153
    if ((int const   )*ptr == 123) {
#line 153
      goto case_123;
    }
#line 158
    if ((int const   )*ptr == 125) {
#line 158
      goto case_125;
    }
#line 163
    if ((int const   )*ptr == 92) {
#line 163
      goto case_92;
    }
#line 169
    if ((int const   )*ptr == 63) {
#line 169
      goto case_63;
    }
#line 169
    if ((int const   )*ptr == 91) {
#line 169
      goto case_63;
    }
#line 169
    if ((int const   )*ptr == 42) {
#line 169
      goto case_63;
    }
#line 151
    goto switch_break;
    case_123: /* CIL Label */ 
#line 154
    if ((unsigned long )obrace == (unsigned long )((char const   *)0)) {
#line 155
      obrace = ptr;
    }
#line 156
    goto switch_break;
    case_125: /* CIL Label */ 
#line 159
    if (obrace) {
#line 159
      if ((unsigned long )cbrace == (unsigned long )((char const   *)0)) {
#line 160
        cbrace = ptr;
      }
    }
#line 161
    goto switch_break;
    case_92: /* CIL Label */ 
#line 164
    ptr ++;
#line 164
    if ((int const   )*ptr == 0) {
#line 165
      ptr --;
    }
    case_63: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_42: /* CIL Label */ 
#line 170
    special = 1;
#line 171
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 149
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (obrace) {
#line 179
    if ((unsigned long )cbrace == (unsigned long )((char const   *)0)) {
      {
#line 182
      dstr_free(& new);
      }
#line 183
      return (-1);
    } else {
      {
#line 179
      tmp = dstr_append(& new, rem, (size_t )(obrace - rem));
      }
#line 179
      if (tmp == -1) {
        {
#line 182
        dstr_free(& new);
        }
#line 183
        return (-1);
      }
    }
    {
#line 185
    len = dstr_length(& new);
#line 187
    ptr = obrace;
    }
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      if (! ((int const   )*ptr != 125)) {
#line 187
        goto while_break___0;
      }
#line 189
      elt = ptr + 1;
#line 191
      ptr = elt;
      {
#line 192
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 192
        if ((int const   )*ptr != 125) {
#line 192
          if (! ((int const   )*ptr != 44)) {
#line 192
            goto while_break___1;
          }
        } else {
#line 192
          goto while_break___1;
        }
#line 193
        ptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 195
      tmp___0 = dstr_append(& new, elt, (size_t )(ptr - elt));
      }
#line 195
      if (tmp___0 == -1) {
        {
#line 199
        dstr_free(& new);
        }
#line 200
        return (-1);
      } else {
        {
#line 195
        tmp___1 = dstr_append(& new, cbrace + 1, (size_t )-1);
        }
#line 195
        if (tmp___1 == -1) {
          {
#line 199
          dstr_free(& new);
          }
#line 200
          return (-1);
        } else {
          {
#line 195
          tmp___2 = dstr_string(& new);
#line 195
          tmp___3 = doglob(vol, list, dir, (char const   *)tmp___2);
          }
#line 195
          if (tmp___3 == -1) {
            {
#line 199
            dstr_free(& new);
            }
#line 200
            return (-1);
          }
        }
      }
      {
#line 203
      dstr_shrink(& new, (size_t )len);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 206
    dstr_free(& new);
    }
#line 207
    return (0);
  }
  {
#line 210
  tmp___4 = dstr_append(& new, dir, (size_t )-1);
  }
#line 210
  if (tmp___4 == -1) {
    {
#line 212
    dstr_free(& new);
    }
#line 213
    return (-1);
  }
  {
#line 215
  len = dstr_length(& new);
  }
#line 217
  if (special) {
    {
#line 222
    found = 0;
#line 224
    dstr_init(& pat);
#line 225
    tmp___5 = dstr_append(& pat, rem, (size_t )(ptr - rem));
    }
#line 225
    if (tmp___5 == -1) {
      {
#line 227
      dstr_free(& pat);
#line 228
      dstr_free(& new);
      }
#line 229
      return (-1);
    }
#line 232
    if ((int const   )*dir == 0) {
      {
#line 232
      tmp___6 = strchr(rem, ':');
      }
#line 232
      if ((unsigned long )tmp___6 == (unsigned long )((char *)0)) {
        {
#line 233
        d = hfs_opendir(vol, ":");
        }
      } else {
        {
#line 235
        d = hfs_opendir(vol, dir);
        }
      }
    } else {
      {
#line 235
      d = hfs_opendir(vol, dir);
      }
    }
#line 237
    if ((unsigned long )d == (unsigned long )((hfsdir *)0)) {
      {
#line 239
      dstr_free(& pat);
#line 240
      dstr_free(& new);
      }
#line 241
      return (-1);
    }
    {
#line 244
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 244
      tmp___13 = hfs_readdir(d, & ent);
      }
#line 244
      if (! (tmp___13 != -1)) {
#line 244
        goto while_break___2;
      }
#line 246
      if ((int )ent.fdflags & (1 << 14)) {
#line 247
        goto while_continue___2;
      }
      {
#line 249
      tmp___11 = dstr_string(& pat);
#line 249
      tmp___12 = strmatch((char const   *)(ent.name), (char const   *)tmp___11);
      }
#line 249
      if (tmp___12) {
        {
#line 251
        dstr_shrink(& new, (size_t )len);
#line 252
        tmp___7 = dstr_append(& new, (char const   *)(ent.name), (size_t )-1);
        }
#line 252
        if (tmp___7 == -1) {
#line 254
          result = -1;
#line 255
          goto while_break___2;
        }
#line 258
        if ((int const   )*ptr == 0) {
          {
#line 260
          found = 1;
#line 261
          tmp___8 = dstr_string(& new);
#line 261
          result = dl_append(list, (char const   *)tmp___8);
          }
#line 263
          if (result == -1) {
#line 264
            goto while_break___2;
          }
        } else
#line 266
        if (ent.flags & 1) {
          {
#line 268
          tmp___10 = dstr_append(& new, ":", (size_t )1);
          }
#line 268
          if (tmp___10 == -1) {
#line 269
            result = -1;
          } else {
            {
#line 272
            found = 1;
#line 273
            tmp___9 = dstr_string(& new);
#line 273
            result = doglob(vol, list, (char const   *)tmp___9, ptr + 1);
            }
          }
#line 276
          if (result == -1) {
#line 277
            goto while_break___2;
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 282
    hfs_closedir(d);
    }
#line 284
    if (result == 0) {
#line 284
      if (! found) {
        {
#line 286
        dstr_shrink(& new, (size_t )len);
#line 287
        tmp___16 = dstr_append(& new, rem, (size_t )-1);
        }
#line 287
        if (tmp___16 == -1) {
#line 288
          result = -1;
        } else {
          {
#line 293
          tmp___14 = dstr_string(& new);
#line 293
          rem___0 = tmp___14 + len;
#line 293
          ptr___0 = rem___0;
          }
          {
#line 293
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 293
            if (! *rem___0) {
#line 293
              goto while_break___3;
            }
#line 296
            if ((int )*rem___0 == 92) {
#line 297
              rem___0 ++;
            }
#line 299
            *ptr___0 = *rem___0;
#line 293
            rem___0 ++;
#line 293
            ptr___0 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 301
          *ptr___0 = (char)0;
#line 303
          tmp___15 = dstr_string(& new);
#line 303
          result = dl_append(list, (char const   *)tmp___15);
          }
        }
      }
    }
    {
#line 307
    dstr_free(& pat);
#line 308
    dstr_free(& new);
    }
#line 310
    return (result);
  }
  {
#line 313
  tmp___20 = dstr_append(& new, rem, (size_t )(ptr - rem));
  }
#line 313
  if (tmp___20 == -1) {
#line 314
    result = -1;
  } else {
#line 317
    if (*ptr) {
      {
#line 319
      tmp___18 = dstr_append(& new, ":", (size_t )1);
      }
#line 319
      if (tmp___18 == -1) {
#line 320
        result = -1;
      } else {
        {
#line 322
        tmp___17 = dstr_string(& new);
#line 322
        result = doglob(vol, list, (char const   *)tmp___17, ptr + 1);
        }
      }
      {
#line 324
      dstr_free(& new);
      }
#line 325
      return (result);
    }
    {
#line 328
    tmp___19 = dstr_string(& new);
#line 328
    result = dl_append(list, (char const   *)tmp___19);
    }
  }
  {
#line 331
  dstr_free(& new);
  }
#line 332
  return (result);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/hfsutils-3.2.6/glob.c"
char **hfs_glob(hfsvol *vol , int argc , char **argv , int *nelts ) 
{ 
  dlist list ;
  int i ;
  int tmp ;
  int tmp___0 ;
  char **tmp___1 ;

  {
  {
#line 344
  tmp = dl_init(& list);
  }
#line 344
  if (tmp == -1) {
#line 345
    return ((char **)0);
  }
#line 347
  i = 0;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i < argc)) {
#line 347
      goto while_break;
    }
    {
#line 349
    tmp___0 = doglob(vol, & list, "", (char const   *)*(argv + i));
    }
#line 349
    if (tmp___0 == -1) {
      {
#line 351
      dl_free(& list);
      }
#line 352
      return ((char **)0);
    }
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  *nelts = dl_size(& list);
#line 358
  tmp___1 = dl_array(& list);
  }
#line 358
  return (tmp___1);
}
}
