/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 90 "include/linux/i2c-dev.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34] ;
};
#line 147 "include/linux/i2c-dev.h"
struct i2c_smbus_ioctl_data {
   char read_write ;
   __u8 command ;
   int size ;
   union i2c_smbus_data *data ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 27 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.h"
struct i2c_adap {
   int nr ;
   char *name ;
   char const   *funcs ;
   char const   *algo ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
enum adt {
    adt_dummy = 0,
    adt_isa = 1,
    adt_i2c = 2,
    adt_smbus = 3,
    adt_unknown = 4
} ;
#line 45 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
struct adap_type {
   char const   *funcs ;
   char const   *algo ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdetect.c"
struct func {
   long value ;
   char const   *name ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 161 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_access(int file , char read_write , __u8 command ,
                                       int size , union i2c_smbus_data *data ) 
{ 
  struct i2c_smbus_ioctl_data args ;
  int tmp ;

  {
  {
#line 166
  args.read_write = read_write;
#line 167
  args.command = command;
#line 168
  args.size = size;
#line 169
  args.data = data;
#line 170
  tmp = ioctl(file, 1824UL, & args);
  }
#line 170
  return (tmp);
}
}
#line 179 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_read_byte(int file ) 
{ 
  union i2c_smbus_data data ;
  __s32 tmp ;

  {
  {
#line 182
  tmp = i2c_smbus_access(file, (char)1, (__u8 )0, 1, & data);
  }
#line 182
  if (tmp) {
#line 183
    return (-1);
  } else {
#line 185
    return (255 & (int )data.byte);
  }
}
}
#line 188 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_write_byte(int file , __u8 value ) 
{ 
  __s32 tmp ;

  {
  {
#line 190
  tmp = i2c_smbus_access(file, (char)0, value, 1, (union i2c_smbus_data *)((void *)0));
  }
#line 190
  return (tmp);
}
}
#line 194 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_read_byte_data(int file , __u8 command ) 
{ 
  union i2c_smbus_data data ;
  __s32 tmp ;

  {
  {
#line 197
  tmp = i2c_smbus_access(file, (char)1, command, 2, & data);
  }
#line 197
  if (tmp) {
#line 199
    return (-1);
  } else {
#line 201
    return (255 & (int )data.byte);
  }
}
}
#line 204 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_write_byte_data(int file , __u8 command , __u8 value ) 
{ 
  union i2c_smbus_data data ;
  __s32 tmp ;

  {
  {
#line 208
  data.byte = value;
#line 209
  tmp = i2c_smbus_access(file, (char)0, command, 2, & data);
  }
#line 209
  return (tmp);
}
}
#line 213 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_read_word_data(int file , __u8 command ) 
{ 
  union i2c_smbus_data data ;
  __s32 tmp ;

  {
  {
#line 216
  tmp = i2c_smbus_access(file, (char)1, command, 3, & data);
  }
#line 216
  if (tmp) {
#line 218
    return (-1);
  } else {
#line 220
    return (65535 & (int )data.word);
  }
}
}
#line 223 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_write_word_data(int file , __u8 command , __u16 value ) 
{ 
  union i2c_smbus_data data ;
  __s32 tmp ;

  {
  {
#line 227
  data.word = value;
#line 228
  tmp = i2c_smbus_access(file, (char)0, command, 3, & data);
  }
#line 228
  return (tmp);
}
}
#line 260 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_write_block_data(int file , __u8 command , __u8 length ,
                                                 __u8 const   *values ) 
{ 
  union i2c_smbus_data data ;
  int i ;
  __s32 tmp ;

  {
#line 265
  if ((int )length > 32) {
#line 266
    length = (__u8 )32;
  }
#line 267
  i = 1;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (i <= (int )length)) {
#line 267
      goto while_break;
    }
#line 268
    data.block[i] = (__u8 )*(values + (i - 1));
#line 267
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  data.block[0] = length;
#line 270
  tmp = i2c_smbus_access(file, (char)0, command, 5, & data);
  }
#line 270
  return (tmp);
}
}
#line 298 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_write_i2c_block_data(int file , __u8 command , __u8 length ,
                                                     __u8 const   *values ) 
{ 
  union i2c_smbus_data data ;
  int i ;
  __s32 tmp ;

  {
#line 304
  if ((int )length > 32) {
#line 305
    length = (__u8 )32;
  }
#line 306
  i = 1;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i <= (int )length)) {
#line 306
      goto while_break;
    }
#line 307
    data.block[i] = (__u8 )*(values + (i - 1));
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  data.block[0] = length;
#line 309
  tmp = i2c_smbus_access(file, (char)0, command, 6, & data);
  }
#line 309
  return (tmp);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.h"
int lookup_i2c_bus(char const   *i2cbus_arg ) ;
#line 38
int parse_i2c_address(char const   *address_arg ) ;
#line 39
int open_i2c_dev(int i2cbus , char *filename , size_t size , int quiet ) ;
#line 40
int set_slave_addr(int file , int address , int force ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/util.h"
int user_ack(int def ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cset.c"
static  __attribute__((__noreturn__)) void help(void) ;
#line 35
static  __attribute__((__noreturn__)) void help(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cset.c"
static void help(void) 
{ 


  {
  {
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: i2cset [-f] [-y] [-m MASK] I2CBUS CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]\n  I2CBUS is an integer or an I2C bus name\n  ADDRESS is an integer (0x03 - 0x77)\n  MODE is one of:\n    c (byte, no value)\n    b (byte data, default)\n    w (word data)\n    i (I2C block data)\n    s (SMBus block data)\n    Append p for SMBus PEC\n");
#line 48
  exit(1);
  }
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cset.c"
static int check_funcs(int file , int size , int pec ) 
{ 
  unsigned long funcs ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 56
  tmp___1 = ioctl(file, 1797UL, & funcs);
  }
#line 56
  if (tmp___1 < 0) {
    {
#line 57
    tmp = __errno_location();
#line 57
    tmp___0 = strerror(*tmp);
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not get the adapter functionality matrix: %s\n",
            tmp___0);
    }
#line 59
    return (-1);
  }
  {
#line 63
  if (size == 1) {
#line 63
    goto case_1;
  }
#line 70
  if (size == 2) {
#line 70
    goto case_2;
  }
#line 77
  if (size == 3) {
#line 77
    goto case_3;
  }
#line 84
  if (size == 5) {
#line 84
    goto case_5;
  }
#line 90
  if (size == 8) {
#line 90
    goto case_8;
  }
#line 62
  goto switch_break;
  case_1: /* CIL Label */ 
#line 64
  if (! (funcs & 262144UL)) {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus send byte");
    }
#line 66
    return (-1);
  }
#line 68
  goto switch_break;
  case_2: /* CIL Label */ 
#line 71
  if (! (funcs & 1048576UL)) {
    {
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus write byte");
    }
#line 73
    return (-1);
  }
#line 75
  goto switch_break;
  case_3: /* CIL Label */ 
#line 78
  if (! (funcs & 4194304UL)) {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus write word");
    }
#line 80
    return (-1);
  }
#line 82
  goto switch_break;
  case_5: /* CIL Label */ 
#line 85
  if (! (funcs & 33554432UL)) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus block write");
    }
#line 87
    return (-1);
  }
#line 89
  goto switch_break;
  case_8: /* CIL Label */ 
#line 91
  if (! (funcs & 134217728UL)) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "I2C block write");
    }
#line 93
    return (-1);
  }
#line 95
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 98
  if (pec) {
#line 98
    if (! (funcs & 9UL)) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Adapter does not seem to support PEC\n");
      }
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cset.c"
static int confirm(char const   *filename , int address , int size , int daddress ,
                   int value , int vmask , unsigned char const   *block , int len ,
                   int pec ) 
{ 
  int dont ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 111
  dont = 0;
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING! This program can confuse your I2C bus, cause data loss and worse!\n");
  }
#line 116
  if (address >= 80) {
#line 116
    if (address <= 87) {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DANGEROUS! Writing to a serial EEPROM on a memory DIMM\nmay render your memory USELESS and make your system UNBOOTABLE!\n");
#line 121
      dont ++;
      }
    }
  }
  {
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I will write to device file %s, chip address 0x%02x, data address\n0x%02x, ",
          filename, address, daddress);
  }
#line 126
  if (size == 1) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no data.\n");
    }
  } else
#line 128
  if (size == 5) {
#line 128
    goto _L;
  } else
#line 128
  if (size == 8) {
    _L: /* CIL Label */ 
    {
#line 132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data");
#line 133
    i = 0;
    }
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 133
      if (! (i < len)) {
#line 133
        goto while_break;
      }
      {
#line 134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" 0x%02x",
              (int const   )*(block + i));
#line 133
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 135
    if (size == 5) {
#line 135
      tmp = "smbus block";
    } else {
#line 135
      tmp = "i2c block";
    }
    {
#line 135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", mode %s.\n",
            tmp);
    }
  } else {
#line 138
    if (size == 2) {
#line 138
      tmp___0 = "byte";
    } else {
#line 138
      tmp___0 = "word";
    }
#line 138
    if (vmask) {
#line 138
      tmp___1 = " (masked)";
    } else {
#line 138
      tmp___1 = "";
    }
    {
#line 138
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data 0x%02x%s, mode %s.\n",
            value, tmp___1, tmp___0);
    }
  }
#line 141
  if (pec) {
    {
#line 142
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PEC checking enabled.\n");
    }
  }
#line 144
  if (dont) {
#line 144
    tmp___2 = "y/N";
  } else {
#line 144
    tmp___2 = "Y/n";
  }
  {
#line 144
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Continue? [%s] ",
          tmp___2);
#line 145
  fflush(stderr);
#line 146
  tmp___3 = user_ack(! dont);
  }
#line 146
  if (! tmp___3) {
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborting on user request.\n");
    }
#line 148
    return (0);
  }
#line 151
  return (1);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cset.c"
int main(int argc , char **argv ) 
{ 
  char *end ;
  char const   *maskp ;
  int res ;
  int i2cbus ;
  int address ;
  int size ;
  int file ;
  int value ;
  int daddress ;
  int vmask ;
  char filename[20] ;
  int pec ;
  int flags ;
  int force ;
  int yes ;
  int version ;
  int readback ;
  unsigned char block[32] ;
  int len ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int oldvalue ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 157
  maskp = (char const   *)((void *)0);
#line 159
  vmask = 0;
#line 161
  pec = 0;
#line 162
  flags = 0;
#line 163
  force = 0;
#line 163
  yes = 0;
#line 163
  version = 0;
#line 163
  readback = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (1 + flags < argc) {
#line 168
      if (! ((int )*(*(argv + (1 + flags)) + 0) == 45)) {
#line 168
        goto while_break;
      }
    } else {
#line 168
      goto while_break;
    }
    {
#line 170
    if ((int )*(*(argv + (1 + flags)) + 1) == 86) {
#line 170
      goto case_86;
    }
#line 171
    if ((int )*(*(argv + (1 + flags)) + 1) == 102) {
#line 171
      goto case_102;
    }
#line 172
    if ((int )*(*(argv + (1 + flags)) + 1) == 121) {
#line 172
      goto case_121;
    }
#line 173
    if ((int )*(*(argv + (1 + flags)) + 1) == 109) {
#line 173
      goto case_109;
    }
#line 178
    if ((int )*(*(argv + (1 + flags)) + 1) == 114) {
#line 178
      goto case_114;
    }
#line 179
    goto switch_default;
    case_86: /* CIL Label */ 
#line 170
    version = 1;
#line 170
    goto switch_break;
    case_102: /* CIL Label */ 
#line 171
    force = 1;
#line 171
    goto switch_break;
    case_121: /* CIL Label */ 
#line 172
    yes = 1;
#line 172
    goto switch_break;
    case_109: /* CIL Label */ 
#line 174
    if (2 + flags < argc) {
#line 175
      maskp = (char const   *)*(argv + (2 + flags));
    }
#line 176
    flags ++;
#line 177
    goto switch_break;
    case_114: /* CIL Label */ 
#line 178
    readback = 1;
#line 178
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unsupported option \"%s\"!\n",
            *(argv + (1 + flags)));
#line 182
    help();
#line 183
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 185
    flags ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (version) {
    {
#line 189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"i2cset version %s\n",
            "3.1.0");
#line 190
    exit(0);
    }
  }
#line 193
  if (argc < flags + 4) {
    {
#line 194
    help();
    }
  }
  {
#line 196
  i2cbus = lookup_i2c_bus((char const   *)*(argv + (flags + 1)));
  }
#line 197
  if (i2cbus < 0) {
    {
#line 198
    help();
    }
  }
  {
#line 200
  address = parse_i2c_address((char const   *)*(argv + (flags + 2)));
  }
#line 201
  if (address < 0) {
    {
#line 202
    help();
    }
  }
  {
#line 204
  tmp = strtol((char const   */* __restrict  */)*(argv + (flags + 3)), (char **/* __restrict  */)(& end),
               0);
#line 204
  daddress = (int )tmp;
  }
#line 205
  if (*end) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data address invalid!\n");
#line 207
    help();
    }
  } else
#line 205
  if (daddress < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data address invalid!\n");
#line 207
    help();
    }
  } else
#line 205
  if (daddress > 255) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data address invalid!\n");
#line 207
    help();
    }
  }
#line 211
  if (argc == flags + 4) {
#line 213
    size = 1;
  } else
#line 214
  if (argc == flags + 5) {
    {
#line 216
    tmp___0 = strcmp((char const   *)*(argv + (flags + 4)), "c");
    }
#line 216
    if (tmp___0) {
      {
#line 216
      tmp___1 = strcmp((char const   *)*(argv + (flags + 4)), "cp");
      }
#line 216
      if (tmp___1) {
#line 221
        size = 2;
      } else {
#line 218
        size = 1;
#line 219
        pec = (int )*(*(argv + (flags + 4)) + 1) == 112;
      }
    } else {
#line 218
      size = 1;
#line 219
      pec = (int )*(*(argv + (flags + 4)) + 1) == 112;
    }
  } else {
    {
#line 225
    tmp___2 = strlen((char const   *)*(argv + (argc - 1)));
    }
#line 225
    if (tmp___2 > 2UL) {
      {
#line 227
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid mode \'%s\'!\n",
              *(argv + (argc - 1)));
#line 228
      help();
      }
    } else {
      {
#line 225
      tmp___3 = strlen((char const   *)*(argv + (argc - 1)));
      }
#line 225
      if (tmp___3 == 2UL) {
#line 225
        if ((int )*(*(argv + (argc - 1)) + 1) != 112) {
          {
#line 227
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid mode \'%s\'!\n",
                  *(argv + (argc - 1)));
#line 228
          help();
          }
        }
      }
    }
    {
#line 231
    if ((int )*(*(argv + (argc - 1)) + 0) == 98) {
#line 231
      goto case_98;
    }
#line 232
    if ((int )*(*(argv + (argc - 1)) + 0) == 119) {
#line 232
      goto case_119;
    }
#line 233
    if ((int )*(*(argv + (argc - 1)) + 0) == 115) {
#line 233
      goto case_115;
    }
#line 234
    if ((int )*(*(argv + (argc - 1)) + 0) == 105) {
#line 234
      goto case_105;
    }
#line 235
    goto switch_default___0;
    case_98: /* CIL Label */ 
#line 231
    size = 2;
#line 231
    goto switch_break___0;
    case_119: /* CIL Label */ 
#line 232
    size = 3;
#line 232
    goto switch_break___0;
    case_115: /* CIL Label */ 
#line 233
    size = 5;
#line 233
    goto switch_break___0;
    case_105: /* CIL Label */ 
#line 234
    size = 8;
#line 234
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid mode \'%s\'!\n",
            *(argv + (argc - 1)));
#line 237
    help();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 239
    pec = (int )*(*(argv + (argc - 1)) + 1) == 112;
#line 240
    if (size == 5) {
#line 240
      goto _L;
    } else
#line 240
    if (size == 8) {
      _L: /* CIL Label */ 
#line 241
      if (pec) {
#line 241
        if (size == 8) {
          {
#line 242
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: PEC not supported for I2C block writes!\n");
#line 243
          help();
          }
        }
      }
#line 245
      if (maskp) {
        {
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Mask not supported for block writes!\n");
#line 247
        help();
        }
      }
#line 249
      if (argc > ((int )sizeof(block) + flags) + 5) {
        {
#line 250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Too many arguments!\n");
#line 251
        help();
        }
      }
    } else
#line 253
    if (argc != flags + 6) {
      {
#line 254
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Too many arguments!\n");
#line 255
      help();
      }
    }
  }
#line 259
  len = 0;
  {
#line 264
  if (size == 3) {
#line 264
    goto case_3;
  }
#line 264
  if (size == 2) {
#line 264
    goto case_3;
  }
#line 277
  if (size == 8) {
#line 277
    goto case_8;
  }
#line 277
  if (size == 5) {
#line 277
    goto case_8;
  }
#line 292
  goto switch_default___1;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 265
  tmp___4 = strtol((char const   */* __restrict  */)*(argv + (flags + 4)), (char **/* __restrict  */)(& end),
                   0);
#line 265
  value = (int )tmp___4;
  }
#line 266
  if (*end) {
    {
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value invalid!\n");
#line 268
    help();
    }
  } else
#line 266
  if (value < 0) {
    {
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value invalid!\n");
#line 268
    help();
    }
  }
#line 270
  if (size == 2) {
#line 270
    if (value > 255) {
      {
#line 272
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value out of range!\n");
#line 273
      help();
      }
    } else {
#line 270
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 270
  if (size == 3) {
#line 270
    if (value > 65535) {
      {
#line 272
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value out of range!\n");
#line 273
      help();
      }
    }
  }
#line 275
  goto switch_break___1;
  case_8: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 278
  len = 0;
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 278
    if (! ((len + flags) + 5 < argc)) {
#line 278
      goto while_break___0;
    }
    {
#line 279
    tmp___5 = strtol((char const   */* __restrict  */)*(argv + ((flags + len) + 4)),
                     (char **/* __restrict  */)(& end), 0);
#line 279
    value = (int )tmp___5;
    }
#line 280
    if (*end) {
      {
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value invalid!\n");
#line 282
      help();
      }
    } else
#line 280
    if (value < 0) {
      {
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value invalid!\n");
#line 282
      help();
      }
    }
#line 284
    if (value > 255) {
      {
#line 285
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value out of range!\n");
#line 286
      help();
      }
    }
#line 288
    block[len] = (unsigned char )value;
#line 278
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 290
  value = -1;
#line 291
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 293
  value = -1;
#line 294
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 297
  if (maskp) {
    {
#line 298
    tmp___6 = strtol((char const   */* __restrict  */)maskp, (char **/* __restrict  */)(& end),
                     0);
#line 298
    vmask = (int )tmp___6;
    }
#line 299
    if (*end) {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value mask invalid!\n");
#line 301
      help();
      }
    } else
#line 299
    if (vmask == 0) {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value mask invalid!\n");
#line 301
      help();
      }
    }
#line 303
    if (size == 1) {
#line 303
      goto _L___2;
    } else
#line 303
    if (size == 2) {
      _L___2: /* CIL Label */ 
#line 303
      if (vmask > 255) {
        {
#line 305
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value mask out of range!\n");
#line 306
        help();
        }
      } else {
#line 303
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 303
    if (vmask > 65535) {
      {
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Data value mask out of range!\n");
#line 306
      help();
      }
    }
  }
  {
#line 310
  file = open_i2c_dev(i2cbus, filename, sizeof(filename), 0);
  }
#line 311
  if (file < 0) {
    {
#line 314
    exit(1);
    }
  } else {
    {
#line 311
    tmp___7 = check_funcs(file, size, pec);
    }
#line 311
    if (tmp___7) {
      {
#line 314
      exit(1);
      }
    } else {
      {
#line 311
      tmp___8 = set_slave_addr(file, address, force);
      }
#line 311
      if (tmp___8) {
        {
#line 314
        exit(1);
        }
      }
    }
  }
#line 316
  if (! yes) {
    {
#line 316
    tmp___9 = confirm((char const   *)(filename), address, size, daddress, value,
                      vmask, (unsigned char const   *)(block), len, pec);
    }
#line 316
    if (! tmp___9) {
      {
#line 318
      exit(0);
      }
    }
  }
#line 320
  if (vmask) {
    {
#line 324
    if (size == 1) {
#line 324
      goto case_1;
    }
#line 327
    if (size == 3) {
#line 327
      goto case_3___0;
    }
#line 330
    goto switch_default___2;
    case_1: /* CIL Label */ 
    {
#line 325
    oldvalue = i2c_smbus_read_byte(file);
    }
#line 326
    goto switch_break___2;
    case_3___0: /* CIL Label */ 
    {
#line 328
    oldvalue = i2c_smbus_read_word_data(file, (__u8 )daddress);
    }
#line 329
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
    {
#line 331
    oldvalue = i2c_smbus_read_byte_data(file, (__u8 )daddress);
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 334
    if (oldvalue < 0) {
      {
#line 335
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Failed to read old value\n");
#line 336
      exit(1);
      }
    }
#line 339
    value = (value & vmask) | (oldvalue & ~ vmask);
#line 341
    if (! yes) {
#line 342
      if (size == 3) {
#line 342
        tmp___10 = 4;
      } else {
#line 342
        tmp___10 = 2;
      }
#line 342
      if (size == 3) {
#line 342
        tmp___11 = 4;
      } else {
#line 342
        tmp___11 = 2;
      }
#line 342
      if (size == 3) {
#line 342
        tmp___12 = 4;
      } else {
#line 342
        tmp___12 = 2;
      }
      {
#line 342
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Old value 0x%0*x, write mask 0x%0*x: Will write 0x%0*x to register 0x%02x\n",
              tmp___12, oldvalue, tmp___11, vmask, tmp___10, value, daddress);
#line 350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Continue? [Y/n] ");
#line 351
      fflush(stderr);
#line 352
      tmp___13 = user_ack(1);
      }
#line 352
      if (! tmp___13) {
        {
#line 353
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborting on user request.\n");
#line 354
        exit(0);
        }
      }
    }
  }
#line 359
  if (pec) {
    {
#line 359
    tmp___16 = ioctl(file, 1800UL, 1);
    }
#line 359
    if (tmp___16 < 0) {
      {
#line 360
      tmp___14 = __errno_location();
#line 360
      tmp___15 = strerror(*tmp___14);
#line 360
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not set PEC: %s\n",
              tmp___15);
#line 362
      close(file);
#line 363
      exit(1);
      }
    }
  }
  {
#line 367
  if (size == 1) {
#line 367
    goto case_1___0;
  }
#line 370
  if (size == 3) {
#line 370
    goto case_3___1;
  }
#line 373
  if (size == 5) {
#line 373
    goto case_5___0;
  }
#line 376
  if (size == 8) {
#line 376
    goto case_8___0;
  }
#line 379
  goto switch_default___3;
  case_1___0: /* CIL Label */ 
  {
#line 368
  res = i2c_smbus_write_byte(file, (__u8 )daddress);
  }
#line 369
  goto switch_break___3;
  case_3___1: /* CIL Label */ 
  {
#line 371
  res = i2c_smbus_write_word_data(file, (__u8 )daddress, (__u16 )value);
  }
#line 372
  goto switch_break___3;
  case_5___0: /* CIL Label */ 
  {
#line 374
  res = i2c_smbus_write_block_data(file, (__u8 )daddress, (__u8 )len, (__u8 const   *)(block));
  }
#line 375
  goto switch_break___3;
  case_8___0: /* CIL Label */ 
  {
#line 377
  res = i2c_smbus_write_i2c_block_data(file, (__u8 )daddress, (__u8 )len, (__u8 const   *)(block));
  }
#line 378
  goto switch_break___3;
  switch_default___3: /* CIL Label */ 
  {
#line 380
  res = i2c_smbus_write_byte_data(file, (__u8 )daddress, (__u8 )value);
  }
#line 381
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 383
  if (res < 0) {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Write failed\n");
#line 385
    close(file);
#line 386
    exit(1);
    }
  }
#line 389
  if (pec) {
    {
#line 390
    tmp___19 = ioctl(file, 1800UL, 0);
    }
#line 390
    if (tmp___19 < 0) {
      {
#line 391
      tmp___17 = __errno_location();
#line 391
      tmp___18 = strerror(*tmp___17);
#line 391
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not clear PEC: %s\n",
              tmp___18);
#line 393
      close(file);
#line 394
      exit(1);
      }
    }
  }
#line 398
  if (! readback) {
    {
#line 399
    close(file);
#line 400
    exit(0);
    }
  }
  {
#line 404
  if (size == 1) {
#line 404
    goto case_1___1;
  }
#line 408
  if (size == 3) {
#line 408
    goto case_3___2;
  }
#line 411
  goto switch_default___4;
  case_1___1: /* CIL Label */ 
  {
#line 405
  res = i2c_smbus_read_byte(file);
#line 406
  value = daddress;
  }
#line 407
  goto switch_break___4;
  case_3___2: /* CIL Label */ 
  {
#line 409
  res = i2c_smbus_read_word_data(file, (__u8 )daddress);
  }
#line 410
  goto switch_break___4;
  switch_default___4: /* CIL Label */ 
  {
#line 412
  res = i2c_smbus_read_byte_data(file, (__u8 )daddress);
  }
  switch_break___4: /* CIL Label */ ;
  }
  {
#line 414
  close(file);
  }
#line 416
  if (res < 0) {
    {
#line 417
    printf((char const   */* __restrict  */)"Warning - readback failed\n");
    }
  } else
#line 419
  if (res != value) {
#line 420
    if (size == 3) {
#line 420
      tmp___20 = 4;
    } else {
#line 420
      tmp___20 = 2;
    }
#line 420
    if (size == 3) {
#line 420
      tmp___21 = 4;
    } else {
#line 420
      tmp___21 = 2;
    }
    {
#line 420
    printf((char const   */* __restrict  */)"Warning - data mismatch - wrote 0x%0*x, read back 0x%0*x\n",
           tmp___21, value, tmp___20, res);
    }
  } else {
#line 425
    if (size == 3) {
#line 425
      tmp___22 = 4;
    } else {
#line 425
      tmp___22 = 2;
    }
    {
#line 425
    printf((char const   */* __restrict  */)"Value 0x%0*x written, readback matched\n",
           tmp___22, value);
    }
  }
  {
#line 429
  exit(0);
  }
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/util.c"
int user_ack(int def ) 
{ 
  char s[2] ;
  int ret ;
  char *tmp ;
  int c ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = fgets((char */* __restrict  */)(s), 2, (FILE */* __restrict  */)stdin);
  }
#line 30
  if (! tmp) {
#line 31
    return (0);
  }
  {
#line 35
  if ((int )s[0] == 89) {
#line 35
    goto case_89;
  }
#line 35
  if ((int )s[0] == 121) {
#line 35
    goto case_89;
  }
#line 39
  if ((int )s[0] == 78) {
#line 39
    goto case_78;
  }
#line 39
  if ((int )s[0] == 110) {
#line 39
    goto case_78;
  }
#line 42
  goto switch_default;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 36
  ret = 1;
#line 37
  goto switch_break;
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
#line 40
  ret = 0;
#line 41
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 43
  ret = def;
  switch_break: /* CIL Label */ ;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! ((int )s[0] != 10)) {
#line 47
      goto while_break;
    }
    {
#line 48
    tmp___0 = fgetc(stdin);
#line 48
    c = tmp___0;
    }
#line 49
    if (c == -1) {
#line 50
      ret = 0;
#line 51
      goto while_break;
    }
#line 53
    s[0] = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (ret);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.h"
struct i2c_adap *gather_i2c_busses(void) ;
#line 35
void free_adapters(struct i2c_adap *adapters ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct adap_type adap_types[5]  = {      {"dummy", "Dummy bus"}, 
        {"isa", "ISA bus"}, 
        {"i2c", "I2C adapter"}, 
        {"smbus", "SMBus adapter"}, 
        {"unknown", "N/A"}};
#line 63 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static enum adt i2c_get_funcs(int i2cbus ) 
{ 
  unsigned long funcs ;
  int file ;
  char filename[20] ;
  enum adt ret ;
  int tmp ;

  {
  {
#line 70
  file = open_i2c_dev(i2cbus, filename, sizeof(filename), 1);
  }
#line 71
  if (file < 0) {
#line 72
    return ((enum adt )4);
  }
  {
#line 74
  tmp = ioctl(file, 1797UL, & funcs);
  }
#line 74
  if (tmp < 0) {
#line 75
    ret = (enum adt )4;
  } else
#line 76
  if (funcs & 1UL) {
#line 77
    ret = (enum adt )2;
  } else
#line 78
  if (funcs & 8257536UL) {
#line 81
    ret = (enum adt )3;
  } else {
#line 83
    ret = (enum adt )0;
  }
  {
#line 85
  close(file);
  }
#line 86
  return (ret);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int rtrim(char *s ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 95
  tmp = strlen((char const   *)s);
#line 95
  i = (int )(tmp - 1UL);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (i >= 0) {
#line 95
      if (! ((int )*(s + i) == 32)) {
#line 95
        if (! ((int )*(s + i) == 10)) {
#line 95
          goto while_break;
        }
      }
    } else {
#line 95
      goto while_break;
    }
#line 96
    *(s + i) = (char )'\000';
#line 95
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (i + 2);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
void free_adapters(struct i2c_adap *adapters ) 
{ 
  int i ;

  {
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (adapters + i)->name) {
#line 104
      goto while_break;
    }
    {
#line 105
    free((void *)(adapters + i)->name);
#line 104
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  free((void *)adapters);
  }
#line 107
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct i2c_adap *more_adapters(struct i2c_adap *adapters , int n ) 
{ 
  struct i2c_adap *new_adapters ;
  void *tmp ;

  {
  {
#line 119
  tmp = realloc((void *)adapters, (unsigned long )(n + 8) * sizeof(struct i2c_adap ));
#line 119
  new_adapters = (struct i2c_adap *)tmp;
  }
#line 120
  if (! new_adapters) {
    {
#line 121
    free_adapters(adapters);
    }
#line 122
    return ((struct i2c_adap *)((void *)0));
  }
  {
#line 124
  memset((void *)(new_adapters + n), 0, 8UL * sizeof(struct i2c_adap ));
  }
#line 126
  return (new_adapters);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
struct i2c_adap *gather_i2c_busses(void) 
{ 
  char s[120] ;
  struct dirent *de ;
  struct dirent *dde ;
  DIR *dir ;
  DIR *ddir ;
  FILE *f ;
  char fstype[255] ;
  char sysfs[255] ;
  char n[255] ;
  int foundsysfs ;
  int count ;
  struct i2c_adap *adapters ;
  void *tmp ;
  char *algo ;
  char *name ;
  char *type ;
  char *all ;
  int len_algo ;
  int len_name ;
  int len_type ;
  int i2cbus ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int i2cbus___0 ;
  enum adt type___0 ;
  char *px ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 136
  foundsysfs = 0;
#line 137
  count = 0;
#line 140
  tmp = calloc((size_t )8, sizeof(struct i2c_adap ));
#line 140
  adapters = (struct i2c_adap *)tmp;
  }
#line 141
  if (! adapters) {
#line 142
    return ((struct i2c_adap *)((void *)0));
  }
  {
#line 145
  f = fopen((char const   */* __restrict  */)"/proc/bus/i2c", (char const   */* __restrict  */)"r");
  }
#line 145
  if (f) {
    {
#line 146
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 146
      tmp___6 = fgets((char */* __restrict  */)(s), 120, (FILE */* __restrict  */)f);
      }
#line 146
      if (! tmp___6) {
#line 146
        goto while_break;
      }
      {
#line 151
      algo = strrchr((char const   *)(s), '\t');
#line 152
      tmp___0 = algo;
#line 152
      algo ++;
#line 152
      *tmp___0 = (char )'\000';
#line 153
      len_algo = rtrim(algo);
#line 155
      name = strrchr((char const   *)(s), '\t');
#line 156
      tmp___1 = name;
#line 156
      name ++;
#line 156
      *tmp___1 = (char )'\000';
#line 157
      len_name = rtrim(name);
#line 159
      type = strrchr((char const   *)(s), '\t');
#line 160
      tmp___2 = type;
#line 160
      type ++;
#line 160
      *tmp___2 = (char )'\000';
#line 161
      len_type = rtrim(type);
#line 163
      sscanf((char const   */* __restrict  */)(s), (char const   */* __restrict  */)"i2c-%d",
             & i2cbus);
      }
#line 165
      if ((count + 1) % 8 == 0) {
        {
#line 167
        adapters = more_adapters(adapters, count + 1);
        }
#line 168
        if (! adapters) {
#line 169
          return ((struct i2c_adap *)((void *)0));
        }
      }
      {
#line 172
      tmp___3 = malloc((size_t )((len_name + len_type) + len_algo));
#line 172
      all = (char *)tmp___3;
      }
#line 173
      if ((unsigned long )all == (unsigned long )((void *)0)) {
        {
#line 174
        free_adapters(adapters);
        }
#line 175
        return ((struct i2c_adap *)((void *)0));
      }
      {
#line 177
      (adapters + count)->nr = i2cbus;
#line 178
      (adapters + count)->name = strcpy((char */* __restrict  */)all, (char const   */* __restrict  */)name);
#line 179
      tmp___4 = strcpy((char */* __restrict  */)(all + len_name), (char const   */* __restrict  */)type);
#line 179
      (adapters + count)->funcs = (char const   *)tmp___4;
#line 180
      tmp___5 = strcpy((char */* __restrict  */)((all + len_name) + len_type), (char const   */* __restrict  */)algo);
#line 180
      (adapters + count)->algo = (char const   *)tmp___5;
#line 182
      count ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 184
    fclose(f);
    }
#line 185
    goto done;
  }
  {
#line 190
  f = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 190
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 191
    goto done;
  }
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 193
    tmp___8 = fgets((char */* __restrict  */)(n), 255, (FILE */* __restrict  */)f);
    }
#line 193
    if (! tmp___8) {
#line 193
      goto while_break___0;
    }
    {
#line 194
    sscanf((char const   */* __restrict  */)(n), (char const   */* __restrict  */)"%*[^ ] %[^ ] %[^ ] %*s\n",
           sysfs, fstype);
#line 195
    tmp___7 = strcasecmp((char const   *)(fstype), "sysfs");
    }
#line 195
    if (tmp___7 == 0) {
#line 196
      foundsysfs ++;
#line 197
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 200
  fclose(f);
  }
#line 201
  if (! foundsysfs) {
#line 202
    goto done;
  }
  {
#line 208
  strcat((char */* __restrict  */)(sysfs), (char const   */* __restrict  */)"/class/i2c-dev");
#line 209
  dir = opendir((char const   *)(sysfs));
  }
#line 209
  if (! dir) {
#line 210
    goto done;
  }
  {
#line 212
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 212
    de = readdir(dir);
    }
#line 212
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 212
      goto while_break___1;
    }
    {
#line 213
    tmp___9 = strcmp((char const   *)(de->d_name), ".");
    }
#line 213
    if (! tmp___9) {
#line 214
      goto while_continue___1;
    }
    {
#line 215
    tmp___10 = strcmp((char const   *)(de->d_name), "..");
    }
#line 215
    if (! tmp___10) {
#line 216
      goto while_continue___1;
    }
    {
#line 220
    sprintf((char */* __restrict  */)(n), (char const   */* __restrict  */)"%s/%s/name",
            sysfs, de->d_name);
#line 221
    f = fopen((char const   */* __restrict  */)(n), (char const   */* __restrict  */)"r");
    }
#line 223
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 224
      sprintf((char */* __restrict  */)(n), (char const   */* __restrict  */)"%s/%s/device/name",
              sysfs, de->d_name);
#line 225
      f = fopen((char const   */* __restrict  */)(n), (char const   */* __restrict  */)"r");
      }
    }
#line 230
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 231
      sprintf((char */* __restrict  */)(n), (char const   */* __restrict  */)"%s/%s/device",
              sysfs, de->d_name);
#line 232
      ddir = opendir((char const   *)(n));
      }
#line 232
      if (! ddir) {
#line 233
        goto while_continue___1;
      }
      {
#line 234
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 234
        dde = readdir(ddir);
        }
#line 234
        if (! ((unsigned long )dde != (unsigned long )((void *)0))) {
#line 234
          goto while_break___2;
        }
        {
#line 235
        tmp___11 = strcmp((char const   *)(dde->d_name), ".");
        }
#line 235
        if (! tmp___11) {
#line 236
          goto while_continue___2;
        }
        {
#line 237
        tmp___12 = strcmp((char const   *)(dde->d_name), "..");
        }
#line 237
        if (! tmp___12) {
#line 238
          goto while_continue___2;
        }
        {
#line 239
        tmp___13 = strncmp((char const   *)(dde->d_name), "i2c-", (size_t )4);
        }
#line 239
        if (! tmp___13) {
          {
#line 240
          sprintf((char */* __restrict  */)(n), (char const   */* __restrict  */)"%s/%s/device/%s/name",
                  sysfs, de->d_name, dde->d_name);
#line 242
          f = fopen((char const   */* __restrict  */)(n), (char const   */* __restrict  */)"r");
          }
#line 242
          if (f) {
#line 243
            goto found;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    found: 
#line 249
    if ((unsigned long )f != (unsigned long )((void *)0)) {
      {
#line 254
      px = fgets((char */* __restrict  */)(s), 120, (FILE */* __restrict  */)f);
#line 255
      fclose(f);
      }
#line 256
      if (! px) {
        {
#line 257
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: read error\n",
                n);
        }
#line 258
        goto while_continue___1;
      }
      {
#line 260
      px = strchr((char const   *)(s), '\n');
      }
#line 260
      if ((unsigned long )px != (unsigned long )((void *)0)) {
#line 261
        *px = (char)0;
      }
      {
#line 262
      tmp___14 = sscanf((char const   */* __restrict  */)(de->d_name), (char const   */* __restrict  */)"i2c-%d",
                        & i2cbus___0);
      }
#line 262
      if (! tmp___14) {
#line 263
        goto while_continue___1;
      }
      {
#line 264
      tmp___15 = strncmp((char const   *)(s), "ISA ", (size_t )4);
      }
#line 264
      if (tmp___15) {
        {
#line 268
        type___0 = i2c_get_funcs(i2cbus___0);
        }
      } else {
#line 265
        type___0 = (enum adt )1;
      }
#line 271
      if ((count + 1) % 8 == 0) {
        {
#line 273
        adapters = more_adapters(adapters, count + 1);
        }
#line 274
        if (! adapters) {
#line 275
          return ((struct i2c_adap *)((void *)0));
        }
      }
      {
#line 278
      (adapters + count)->nr = i2cbus___0;
#line 279
      (adapters + count)->name = strdup((char const   *)(s));
      }
#line 280
      if ((unsigned long )(adapters + count)->name == (unsigned long )((void *)0)) {
        {
#line 281
        free_adapters(adapters);
        }
#line 282
        return ((struct i2c_adap *)((void *)0));
      }
#line 284
      (adapters + count)->funcs = adap_types[type___0].funcs;
#line 285
      (adapters + count)->algo = adap_types[type___0].algo;
#line 286
      count ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 289
  closedir(dir);
  }
  done: 
#line 292
  return (adapters);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int lookup_i2c_bus_by_name(char const   *bus_name ) 
{ 
  struct i2c_adap *adapters ;
  int i ;
  int i2cbus ;
  int tmp ;

  {
  {
#line 298
  i2cbus = -1;
#line 300
  adapters = gather_i2c_busses();
  }
#line 301
  if ((unsigned long )adapters == (unsigned long )((void *)0)) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory!\n");
    }
#line 303
    return (-3);
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (adapters + i)->name) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = strcmp((char const   *)(adapters + i)->name, bus_name);
    }
#line 309
    if (tmp == 0) {
#line 310
      if (i2cbus >= 0) {
        {
#line 311
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name is not unique!\n");
#line 313
        i2cbus = -4;
        }
#line 314
        goto done;
      }
#line 316
      i2cbus = (adapters + i)->nr;
    }
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if (i2cbus == -1) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name doesn\'t match any bus present!\n");
    }
  }
  done: 
  {
#line 325
  free_adapters(adapters);
  }
#line 326
  return (i2cbus);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
int lookup_i2c_bus(char const   *i2cbus_arg ) 
{ 
  unsigned long i2cbus ;
  char *end ;
  int tmp ;

  {
  {
#line 338
  i2cbus = strtoul((char const   */* __restrict  */)i2cbus_arg, (char **/* __restrict  */)(& end),
                   0);
  }
#line 339
  if (*end) {
    {
#line 341
    tmp = lookup_i2c_bus_by_name(i2cbus_arg);
    }
#line 341
    return (tmp);
  } else
#line 339
  if (! *i2cbus_arg) {
    {
#line 341
    tmp = lookup_i2c_bus_by_name(i2cbus_arg);
    }
#line 341
    return (tmp);
  }
#line 343
  if (i2cbus > 1048575UL) {
    {
#line 344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus out of range!\n");
    }
#line 345
    return (-2);
  }
#line 348
  return ((int )i2cbus);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
int parse_i2c_address(char const   *address_arg ) 
{ 
  long address ;
  char *end ;

  {
  {
#line 360
  address = strtol((char const   */* __restrict  */)address_arg, (char **/* __restrict  */)(& end),
                   0);
  }
#line 361
  if (*end) {
    {
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Chip address is not a number!\n");
    }
#line 363
    return (-1);
  } else
#line 361
  if (! *address_arg) {
    {
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Chip address is not a number!\n");
    }
#line 363
    return (-1);
  }
#line 365
  if (address < 3L) {
    {
#line 366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Chip address out of range (0x03-0x77)!\n");
    }
#line 368
    return (-2);
  } else
#line 365
  if (address > 119L) {
    {
#line 366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Chip address out of range (0x03-0x77)!\n");
    }
#line 368
    return (-2);
  }
#line 371
  return ((int )address);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
int open_i2c_dev(int i2cbus , char *filename , size_t size , int quiet ) 
{ 
  int file ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 378
  snprintf((char */* __restrict  */)filename, size, (char const   */* __restrict  */)"/dev/i2c/%d",
           i2cbus);
#line 379
  *(filename + (size - 1UL)) = (char )'\000';
#line 380
  file = open((char const   *)filename, 2);
  }
#line 382
  if (file < 0) {
    {
#line 382
    tmp = __errno_location();
    }
#line 382
    if (*tmp == 2) {
      {
#line 383
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"/dev/i2c-%d",
              i2cbus);
#line 384
      file = open((char const   *)filename, 2);
      }
    } else {
      {
#line 382
      tmp___0 = __errno_location();
      }
#line 382
      if (*tmp___0 == 20) {
        {
#line 383
        sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"/dev/i2c-%d",
                i2cbus);
#line 384
        file = open((char const   *)filename, 2);
        }
      }
    }
  }
#line 387
  if (file < 0) {
#line 387
    if (! quiet) {
      {
#line 388
      tmp___5 = __errno_location();
      }
#line 388
      if (*tmp___5 == 2) {
        {
#line 389
        tmp___1 = strerror(2);
#line 389
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not open file `/dev/i2c-%d\' or `/dev/i2c/%d\': %s\n",
                i2cbus, i2cbus, tmp___1);
        }
      } else {
        {
#line 393
        tmp___2 = __errno_location();
#line 393
        tmp___3 = strerror(*tmp___2);
#line 393
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not open file `%s\': %s\n",
                filename, tmp___3);
#line 395
        tmp___4 = __errno_location();
        }
#line 395
        if (*tmp___4 == 13) {
          {
#line 396
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Run as root?\n");
          }
        }
      }
    }
  }
#line 400
  return (file);
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
int set_slave_addr(int file , int address , int force ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 407
  if (force) {
#line 407
    tmp___2 = 1798;
  } else {
#line 407
    tmp___2 = 1795;
  }
  {
#line 407
  tmp___3 = ioctl(file, (unsigned long )tmp___2, address);
  }
#line 407
  if (tmp___3 < 0) {
    {
#line 408
    tmp = __errno_location();
#line 408
    tmp___0 = strerror(*tmp);
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not set address to 0x%02x: %s\n",
            address, tmp___0);
#line 411
    tmp___1 = __errno_location();
    }
#line 411
    return (- *tmp___1);
  }
#line 414
  return (0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 245 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_read_block_data(int file , __u8 command , __u8 *values ) 
{ 
  union i2c_smbus_data data ;
  int i ;
  __s32 tmp ;

  {
  {
#line 250
  tmp = i2c_smbus_access(file, (char)1, command, 5, & data);
  }
#line 250
  if (tmp) {
#line 252
    return (-1);
  } else {
#line 254
    i = 1;
    {
#line 254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 254
      if (! (i <= (int )data.block[0])) {
#line 254
        goto while_break;
      }
#line 255
      *(values + (i - 1)) = data.block[i];
#line 254
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 256
    return ((__s32 )data.block[0]);
  }
}
}
#line 278 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_read_i2c_block_data(int file , __u8 command , __u8 length ,
                                                    __u8 *values ) 
{ 
  union i2c_smbus_data data ;
  int i ;
  int tmp ;
  __s32 tmp___0 ;

  {
#line 284
  if ((int )length > 32) {
#line 285
    length = (__u8 )32;
  }
#line 286
  data.block[0] = length;
#line 287
  if ((int )length == 32) {
#line 287
    tmp = 6;
  } else {
#line 287
    tmp = 8;
  }
  {
#line 287
  tmp___0 = i2c_smbus_access(file, (char)1, command, tmp, & data);
  }
#line 287
  if (tmp___0) {
#line 290
    return (-1);
  } else {
#line 292
    i = 1;
    {
#line 292
    while (1) {
      while_continue: /* CIL Label */ ;
#line 292
      if (! (i <= (int )data.block[0])) {
#line 292
        goto while_break;
      }
#line 293
      *(values + (i - 1)) = data.block[i];
#line 292
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 294
    return ((__s32 )data.block[0]);
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdump.c"
static void help___0(void) 
{ 


  {
  {
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: i2cdump [-f] [-y] [-r first-last] I2CBUS ADDRESS [MODE [BANK [BANKREG]]]\n  I2CBUS is an integer or an I2C bus name\n  ADDRESS is an integer (0x03 - 0x77)\n  MODE is one of:\n    b (byte, default)\n    w (word)\n    W (word on even register addresses)\n    s (SMBus block)\n    i (I2C block)\n    c (consecutive byte)\n    Append p for SMBus PEC\n");
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdump.c"
static int check_funcs___0(int file , int size , int pec ) 
{ 
  unsigned long funcs ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 54
  tmp___1 = ioctl(file, 1797UL, & funcs);
  }
#line 54
  if (tmp___1 < 0) {
    {
#line 55
    tmp = __errno_location();
#line 55
    tmp___0 = strerror(*tmp);
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not get the adapter functionality matrix: %s\n",
            tmp___0);
    }
#line 57
    return (-1);
  }
  {
#line 61
  if (size == 1) {
#line 61
    goto case_1;
  }
#line 72
  if (size == 2) {
#line 72
    goto case_2;
  }
#line 79
  if (size == 3) {
#line 79
    goto case_3;
  }
#line 86
  if (size == 5) {
#line 86
    goto case_5;
  }
#line 93
  if (size == 8) {
#line 93
    goto case_8;
  }
#line 60
  goto switch_break;
  case_1: /* CIL Label */ 
#line 62
  if (! (funcs & 131072UL)) {
    {
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus receive byte");
    }
#line 64
    return (-1);
  }
#line 66
  if (! (funcs & 262144UL)) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus send byte");
    }
#line 68
    return (-1);
  }
#line 70
  goto switch_break;
  case_2: /* CIL Label */ 
#line 73
  if (! (funcs & 524288UL)) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus read byte");
    }
#line 75
    return (-1);
  }
#line 77
  goto switch_break;
  case_3: /* CIL Label */ 
#line 80
  if (! (funcs & 2097152UL)) {
    {
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus read word");
    }
#line 82
    return (-1);
  }
#line 84
  goto switch_break;
  case_5: /* CIL Label */ 
#line 87
  if (! (funcs & 16777216UL)) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus block read");
    }
#line 89
    return (-1);
  }
#line 91
  goto switch_break;
  case_8: /* CIL Label */ 
#line 94
  if (! (funcs & 67108864UL)) {
    {
#line 95
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "I2C block read");
    }
#line 96
    return (-1);
  }
#line 98
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 101
  if (pec) {
#line 101
    if (! (funcs & 9UL)) {
      {
#line 103
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Adapter does not seem to support PEC\n");
      }
    }
  }
#line 107
  return (0);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct adap_type adap_types___0[5]  = {      {"dummy", "Dummy bus"}, 
        {"isa", "ISA bus"}, 
        {"i2c", "I2C adapter"}, 
        {"smbus", "SMBus adapter"}, 
        {"unknown", "N/A"}};
#line 63 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static enum adt i2c_get_funcs___0(int i2cbus ) 
{ 
  unsigned long funcs ;
  int file ;
  char filename[20] ;
  enum adt ret ;
  int tmp ;

  {
  {
#line 70
  file = open_i2c_dev(i2cbus, filename, sizeof(filename), 1);
  }
#line 71
  if (file < 0) {
#line 72
    return ((enum adt )4);
  }
  {
#line 74
  tmp = ioctl(file, 1797UL, & funcs);
  }
#line 74
  if (tmp < 0) {
#line 75
    ret = (enum adt )4;
  } else
#line 76
  if (funcs & 1UL) {
#line 77
    ret = (enum adt )2;
  } else
#line 78
  if (funcs & 8257536UL) {
#line 81
    ret = (enum adt )3;
  } else {
#line 83
    ret = (enum adt )0;
  }
  {
#line 85
  close(file);
  }
#line 86
  return (ret);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int rtrim___0(char *s ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 95
  tmp = strlen((char const   *)s);
#line 95
  i = (int )(tmp - 1UL);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (i >= 0) {
#line 95
      if (! ((int )*(s + i) == 32)) {
#line 95
        if (! ((int )*(s + i) == 10)) {
#line 95
          goto while_break;
        }
      }
    } else {
#line 95
      goto while_break;
    }
#line 96
    *(s + i) = (char )'\000';
#line 95
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (i + 2);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct i2c_adap *more_adapters___0(struct i2c_adap *adapters , int n ) 
{ 
  struct i2c_adap *new_adapters ;
  void *tmp ;

  {
  {
#line 119
  tmp = realloc((void *)adapters, (unsigned long )(n + 8) * sizeof(struct i2c_adap ));
#line 119
  new_adapters = (struct i2c_adap *)tmp;
  }
#line 120
  if (! new_adapters) {
    {
#line 121
    free_adapters(adapters);
    }
#line 122
    return ((struct i2c_adap *)((void *)0));
  }
  {
#line 124
  memset((void *)(new_adapters + n), 0, 8UL * sizeof(struct i2c_adap ));
  }
#line 126
  return (new_adapters);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int lookup_i2c_bus_by_name___0(char const   *bus_name ) 
{ 
  struct i2c_adap *adapters ;
  int i ;
  int i2cbus ;
  int tmp ;

  {
  {
#line 298
  i2cbus = -1;
#line 300
  adapters = gather_i2c_busses();
  }
#line 301
  if ((unsigned long )adapters == (unsigned long )((void *)0)) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory!\n");
    }
#line 303
    return (-3);
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (adapters + i)->name) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = strcmp((char const   *)(adapters + i)->name, bus_name);
    }
#line 309
    if (tmp == 0) {
#line 310
      if (i2cbus >= 0) {
        {
#line 311
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name is not unique!\n");
#line 313
        i2cbus = -4;
        }
#line 314
        goto done;
      }
#line 316
      i2cbus = (adapters + i)->nr;
    }
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if (i2cbus == -1) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name doesn\'t match any bus present!\n");
    }
  }
  done: 
  {
#line 325
  free_adapters(adapters);
  }
#line 326
  return (i2cbus);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cget.c"
static  __attribute__((__noreturn__)) void help___1(void) ;
#line 38
static  __attribute__((__noreturn__)) void help___1(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cget.c"
static void help___1(void) 
{ 


  {
  {
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: i2cget [-f] [-y] I2CBUS CHIP-ADDRESS [DATA-ADDRESS [MODE]]\n  I2CBUS is an integer or an I2C bus name\n  ADDRESS is an integer (0x03 - 0x77)\n  MODE is one of:\n    b (read byte data, default)\n    w (read word data)\n    c (write byte/read byte)\n    Append p for SMBus PEC\n");
#line 49
  exit(1);
  }
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cget.c"
static int check_funcs___1(int file , int size , int daddress , int pec ) 
{ 
  unsigned long funcs ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 57
  tmp___1 = ioctl(file, 1797UL, & funcs);
  }
#line 57
  if (tmp___1 < 0) {
    {
#line 58
    tmp = __errno_location();
#line 58
    tmp___0 = strerror(*tmp);
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not get the adapter functionality matrix: %s\n",
            tmp___0);
    }
#line 60
    return (-1);
  }
  {
#line 64
  if (size == 1) {
#line 64
    goto case_1;
  }
#line 76
  if (size == 2) {
#line 76
    goto case_2;
  }
#line 83
  if (size == 3) {
#line 83
    goto case_3;
  }
#line 63
  goto switch_break;
  case_1: /* CIL Label */ 
#line 65
  if (! (funcs & 131072UL)) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus receive byte");
    }
#line 67
    return (-1);
  }
#line 69
  if (daddress >= 0) {
#line 69
    if (! (funcs & 262144UL)) {
      {
#line 71
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
              "SMBus send byte");
      }
#line 72
      return (-1);
    }
  }
#line 74
  goto switch_break;
  case_2: /* CIL Label */ 
#line 77
  if (! (funcs & 524288UL)) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus read byte");
    }
#line 79
    return (-1);
  }
#line 81
  goto switch_break;
  case_3: /* CIL Label */ 
#line 84
  if (! (funcs & 2097152UL)) {
    {
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Adapter does not have %s capability\n",
            "SMBus read word");
    }
#line 86
    return (-1);
  }
#line 88
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 91
  if (pec) {
#line 91
    if (! (funcs & 9UL)) {
      {
#line 93
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Adapter does not seem to support PEC\n");
      }
    }
  }
#line 97
  return (0);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cget.c"
static int confirm___0(char const   *filename , int address , int size , int daddress ,
                       int pec ) 
{ 
  int dont ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 103
  dont = 0;
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING! This program can confuse your I2C bus, cause data loss and worse!\n");
  }
#line 109
  if (address >= 80) {
#line 109
    if (address <= 87) {
#line 109
      if (pec) {
        {
#line 110
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"STOP! EEPROMs are I2C devices, not SMBus devices. Using PEC\non I2C devices may result in unexpected results, such as\ntrashing the contents of EEPROMs. We can\'t let you do that, sorry.\n");
        }
#line 115
        return (0);
      }
    }
  }
#line 118
  if (size == 1) {
#line 118
    if (daddress >= 0) {
#line 118
      if (pec) {
        {
#line 119
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING! All I2C chips and some SMBus chips will interpret a write\nbyte command with PEC as awrite byte data command, effectively writing a\nvalue into a register!\n");
#line 123
        dont ++;
        }
      }
    }
  }
  {
#line 126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I will read from device file %s, chip address 0x%02x, ",
          filename, address);
  }
#line 128
  if (daddress < 0) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"current data\naddress");
    }
  } else {
    {
#line 131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data address\n0x%02x",
            daddress);
    }
  }
#line 132
  if (size == 1) {
#line 132
    if (daddress < 0) {
#line 132
      tmp = "read byte";
    } else {
#line 132
      tmp = "write byte/read byte";
    }
#line 132
    tmp___1 = tmp;
  } else {
#line 132
    if (size == 2) {
#line 132
      tmp___0 = "read byte data";
    } else {
#line 132
      tmp___0 = "read word data";
    }
#line 132
    tmp___1 = tmp___0;
  }
  {
#line 132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", using %s.\n",
          tmp___1);
  }
#line 137
  if (pec) {
    {
#line 138
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PEC checking enabled.\n");
    }
  }
#line 140
  if (dont) {
#line 140
    tmp___2 = "y/N";
  } else {
#line 140
    tmp___2 = "Y/n";
  }
  {
#line 140
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Continue? [%s] ",
          tmp___2);
#line 141
  fflush(stderr);
#line 142
  tmp___3 = user_ack(! dont);
  }
#line 142
  if (! tmp___3) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborting on user request.\n");
    }
#line 144
    return (0);
  }
#line 147
  return (1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct adap_type adap_types___1[5]  = {      {"dummy", "Dummy bus"}, 
        {"isa", "ISA bus"}, 
        {"i2c", "I2C adapter"}, 
        {"smbus", "SMBus adapter"}, 
        {"unknown", "N/A"}};
#line 63 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static enum adt i2c_get_funcs___1(int i2cbus ) 
{ 
  unsigned long funcs ;
  int file ;
  char filename[20] ;
  enum adt ret ;
  int tmp ;

  {
  {
#line 70
  file = open_i2c_dev(i2cbus, filename, sizeof(filename), 1);
  }
#line 71
  if (file < 0) {
#line 72
    return ((enum adt )4);
  }
  {
#line 74
  tmp = ioctl(file, 1797UL, & funcs);
  }
#line 74
  if (tmp < 0) {
#line 75
    ret = (enum adt )4;
  } else
#line 76
  if (funcs & 1UL) {
#line 77
    ret = (enum adt )2;
  } else
#line 78
  if (funcs & 8257536UL) {
#line 81
    ret = (enum adt )3;
  } else {
#line 83
    ret = (enum adt )0;
  }
  {
#line 85
  close(file);
  }
#line 86
  return (ret);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int rtrim___1(char *s ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 95
  tmp = strlen((char const   *)s);
#line 95
  i = (int )(tmp - 1UL);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (i >= 0) {
#line 95
      if (! ((int )*(s + i) == 32)) {
#line 95
        if (! ((int )*(s + i) == 10)) {
#line 95
          goto while_break;
        }
      }
    } else {
#line 95
      goto while_break;
    }
#line 96
    *(s + i) = (char )'\000';
#line 95
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (i + 2);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct i2c_adap *more_adapters___1(struct i2c_adap *adapters , int n ) 
{ 
  struct i2c_adap *new_adapters ;
  void *tmp ;

  {
  {
#line 119
  tmp = realloc((void *)adapters, (unsigned long )(n + 8) * sizeof(struct i2c_adap ));
#line 119
  new_adapters = (struct i2c_adap *)tmp;
  }
#line 120
  if (! new_adapters) {
    {
#line 121
    free_adapters(adapters);
    }
#line 122
    return ((struct i2c_adap *)((void *)0));
  }
  {
#line 124
  memset((void *)(new_adapters + n), 0, 8UL * sizeof(struct i2c_adap ));
  }
#line 126
  return (new_adapters);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int lookup_i2c_bus_by_name___1(char const   *bus_name ) 
{ 
  struct i2c_adap *adapters ;
  int i ;
  int i2cbus ;
  int tmp ;

  {
  {
#line 298
  i2cbus = -1;
#line 300
  adapters = gather_i2c_busses();
  }
#line 301
  if ((unsigned long )adapters == (unsigned long )((void *)0)) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory!\n");
    }
#line 303
    return (-3);
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (adapters + i)->name) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = strcmp((char const   *)(adapters + i)->name, bus_name);
    }
#line 309
    if (tmp == 0) {
#line 310
      if (i2cbus >= 0) {
        {
#line 311
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name is not unique!\n");
#line 313
        i2cbus = -4;
        }
#line 314
        goto done;
      }
#line 316
      i2cbus = (adapters + i)->nr;
    }
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if (i2cbus == -1) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name doesn\'t match any bus present!\n");
    }
  }
  done: 
  {
#line 325
  free_adapters(adapters);
  }
#line 326
  return (i2cbus);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct adap_type adap_types___2[5]  = {      {"dummy", "Dummy bus"}, 
        {"isa", "ISA bus"}, 
        {"i2c", "I2C adapter"}, 
        {"smbus", "SMBus adapter"}, 
        {"unknown", "N/A"}};
#line 63 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static enum adt i2c_get_funcs___2(int i2cbus ) 
{ 
  unsigned long funcs ;
  int file ;
  char filename[20] ;
  enum adt ret ;
  int tmp ;

  {
  {
#line 70
  file = open_i2c_dev(i2cbus, filename, sizeof(filename), 1);
  }
#line 71
  if (file < 0) {
#line 72
    return ((enum adt )4);
  }
  {
#line 74
  tmp = ioctl(file, 1797UL, & funcs);
  }
#line 74
  if (tmp < 0) {
#line 75
    ret = (enum adt )4;
  } else
#line 76
  if (funcs & 1UL) {
#line 77
    ret = (enum adt )2;
  } else
#line 78
  if (funcs & 8257536UL) {
#line 81
    ret = (enum adt )3;
  } else {
#line 83
    ret = (enum adt )0;
  }
  {
#line 85
  close(file);
  }
#line 86
  return (ret);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int rtrim___2(char *s ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 95
  tmp = strlen((char const   *)s);
#line 95
  i = (int )(tmp - 1UL);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (i >= 0) {
#line 95
      if (! ((int )*(s + i) == 32)) {
#line 95
        if (! ((int )*(s + i) == 10)) {
#line 95
          goto while_break;
        }
      }
    } else {
#line 95
      goto while_break;
    }
#line 96
    *(s + i) = (char )'\000';
#line 95
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (i + 2);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static struct i2c_adap *more_adapters___2(struct i2c_adap *adapters , int n ) 
{ 
  struct i2c_adap *new_adapters ;
  void *tmp ;

  {
  {
#line 119
  tmp = realloc((void *)adapters, (unsigned long )(n + 8) * sizeof(struct i2c_adap ));
#line 119
  new_adapters = (struct i2c_adap *)tmp;
  }
#line 120
  if (! new_adapters) {
    {
#line 121
    free_adapters(adapters);
    }
#line 122
    return ((struct i2c_adap *)((void *)0));
  }
  {
#line 124
  memset((void *)(new_adapters + n), 0, 8UL * sizeof(struct i2c_adap ));
  }
#line 126
  return (new_adapters);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cbusses.c"
static int lookup_i2c_bus_by_name___2(char const   *bus_name ) 
{ 
  struct i2c_adap *adapters ;
  int i ;
  int i2cbus ;
  int tmp ;

  {
  {
#line 298
  i2cbus = -1;
#line 300
  adapters = gather_i2c_busses();
  }
#line 301
  if ((unsigned long )adapters == (unsigned long )((void *)0)) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory!\n");
    }
#line 303
    return (-3);
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (adapters + i)->name) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = strcmp((char const   *)(adapters + i)->name, bus_name);
    }
#line 309
    if (tmp == 0) {
#line 310
      if (i2cbus >= 0) {
        {
#line 311
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name is not unique!\n");
#line 313
        i2cbus = -4;
        }
#line 314
        goto done;
      }
#line 316
      i2cbus = (adapters + i)->nr;
    }
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if (i2cbus == -1) {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: I2C bus name doesn\'t match any bus present!\n");
    }
  }
  done: 
  {
#line 325
  free_adapters(adapters);
  }
#line 326
  return (i2cbus);
}
}
#line 174 "include/linux/i2c-dev.h"
__inline static __s32 i2c_smbus_write_quick(int file , __u8 value ) 
{ 
  __s32 tmp ;

  {
  {
#line 176
  tmp = i2c_smbus_access(file, (char )value, (__u8 )0, 0, (union i2c_smbus_data *)((void *)0));
  }
#line 176
  return (tmp);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdetect.c"
static void help___2(void) 
{ 


  {
  {
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]\n       i2cdetect -F I2CBUS\n       i2cdetect -l\n  I2CBUS is an integer or an I2C bus name\n  If provided, FIRST and LAST limit the probing range.\n");
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdetect.c"
static int scan_i2c_bus(int file , int mode , int first , int last ) 
{ 
  int i ;
  int j ;
  int res ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 52
  printf((char const   */* __restrict  */)"     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n");
#line 54
  i = 0;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < 128)) {
#line 54
      goto while_break;
    }
    {
#line 55
    printf((char const   */* __restrict  */)"%02x: ", i);
#line 56
    j = 0;
    }
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 56
      if (! (j < 16)) {
#line 56
        goto while_break___0;
      }
      {
#line 57
      fflush(stdout);
      }
#line 60
      if (i + j < first) {
        {
#line 61
        printf((char const   */* __restrict  */)"   ");
        }
#line 62
        goto __Cont;
      } else
#line 60
      if (i + j > last) {
        {
#line 61
        printf((char const   */* __restrict  */)"   ");
        }
#line 62
        goto __Cont;
      }
      {
#line 66
      tmp___2 = ioctl(file, 1795UL, i + j);
      }
#line 66
      if (tmp___2 < 0) {
        {
#line 67
        tmp___1 = __errno_location();
        }
#line 67
        if (*tmp___1 == 16) {
          {
#line 68
          printf((char const   */* __restrict  */)"UU ");
          }
#line 69
          goto __Cont;
        } else {
          {
#line 71
          tmp = __errno_location();
#line 71
          tmp___0 = strerror(*tmp);
#line 71
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not set address to 0x%02x: %s\n",
                  i + j, tmp___0);
          }
#line 74
          return (-1);
        }
      }
      {
#line 80
      if (mode == 1) {
#line 80
        goto case_1;
      }
#line 86
      if (mode == 2) {
#line 86
        goto case_2;
      }
#line 91
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 83
      res = i2c_smbus_write_quick(file, (__u8 )0);
      }
#line 85
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 89
      res = i2c_smbus_read_byte(file);
      }
#line 90
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 92
      if (i + j >= 48) {
#line 92
        if (i + j <= 55) {
          {
#line 94
          res = i2c_smbus_read_byte(file);
          }
        } else {
#line 92
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 92
      if (i + j >= 80) {
#line 92
        if (i + j <= 95) {
          {
#line 94
          res = i2c_smbus_read_byte(file);
          }
        } else {
          {
#line 96
          res = i2c_smbus_write_quick(file, (__u8 )0);
          }
        }
      } else {
        {
#line 96
        res = i2c_smbus_write_quick(file, (__u8 )0);
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 100
      if (res < 0) {
        {
#line 101
        printf((char const   */* __restrict  */)"-- ");
        }
      } else {
        {
#line 103
        printf((char const   */* __restrict  */)"%02x ", i + j);
        }
      }
      __Cont: /* CIL Label */ 
#line 56
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 105
    printf((char const   */* __restrict  */)"\n");
#line 54
    i += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (0);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdetect.c"
static struct func  const  all_func[16]  = 
#line 117
  {      {1L, "I2C"}, 
        {65536L, "SMBus Quick Command"}, 
        {262144L, "SMBus Send Byte"}, 
        {131072L, "SMBus Receive Byte"}, 
        {1048576L, "SMBus Write Byte"}, 
        {524288L, "SMBus Read Byte"}, 
        {4194304L, "SMBus Write Word"}, 
        {2097152L, "SMBus Read Word"}, 
        {8388608L, "SMBus Process Call"}, 
        {33554432L, "SMBus Block Write"}, 
        {16777216L, "SMBus Block Read"}, 
        {32768L, "SMBus Block Process Call"}, 
        {8L, "SMBus PEC"}, 
        {134217728L, "I2C Block Write"}, 
        {67108864L, "I2C Block Read"}, 
        {0L, ""}};
#line 151 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdetect.c"
static void print_functionality(unsigned long funcs ) 
{ 
  int i ;
  char const   *tmp ;

  {
#line 155
  i = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! all_func[i].value) {
#line 155
      goto while_break;
    }
#line 156
    if (funcs & (unsigned long )all_func[i].value) {
#line 156
      tmp = "yes";
    } else {
#line 156
      tmp = "no";
    }
    {
#line 156
    printf((char const   */* __restrict  */)"%-32s %s\n", all_func[i].name, tmp);
#line 155
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/i2c-tools-3.1.0/tools/i2cdetect.c"
static void print_i2c_busses(void) 
{ 
  struct i2c_adap *adapters ;
  int count ;

  {
  {
#line 170
  adapters = gather_i2c_busses();
  }
#line 171
  if ((unsigned long )adapters == (unsigned long )((void *)0)) {
    {
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory!\n");
    }
#line 173
    return;
  }
#line 176
  count = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (adapters + count)->name) {
#line 176
      goto while_break;
    }
    {
#line 177
    printf((char const   */* __restrict  */)"i2c-%d\t%-10s\t%-32s\t%s\n", (adapters + count)->nr,
           (adapters + count)->funcs, (adapters + count)->name, (adapters + count)->algo);
#line 176
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  free_adapters(adapters);
  }
#line 183
  return;
}
}
