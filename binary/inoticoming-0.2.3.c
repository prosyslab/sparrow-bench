/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_31 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_31 regmatch_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
struct inotify_event {
   int wd ;
   uint32_t mask ;
   uint32_t cookie ;
   uint32_t len ;
   char name[] ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
struct argument {
   char *argument ;
   size_t len ;
   size_t substitute ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
struct lookfor {
   struct lookfor *next ;
   char *regexp ;
   char *prefix ;
   char *suffix ;
   size_t prefixlen ;
   size_t suffixlen ;
   char *dir ;
   char *action ;
   struct argument *arguments ;
   size_t num_arguments ;
   _Bool logstderr ;
   _Bool logstdout ;
   regex_t reg ;
};
#line 257 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 262 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 260 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 255 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 255 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/closeallfds.h"
void closeallopenfds(int const   *exceptions___0 , size_t count ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/closeallfds.c"
void closeallopenfds(int const   *exceptions___0 , size_t count ) 
{ 
  long maxopen ;
  int maxfd ;
  int fd ;
  size_t i ;

  {
#line 25
  maxfd = -1;
#line 26
  i = (size_t )0;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! (i < count)) {
#line 26
      goto while_break;
    }
#line 27
    if (*(exceptions___0 + i) > (int const   )maxfd) {
#line 28
      maxfd = (int )*(exceptions___0 + i);
    }
#line 26
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  fd = 0;
  {
#line 30
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 30
    if (! (fd < maxfd)) {
#line 30
      goto while_break___0;
    }
#line 31
    i = (size_t )0;
    {
#line 31
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 31
      if (! (i < count)) {
#line 31
        goto while_break___1;
      }
#line 32
      if (*(exceptions___0 + i) == (int const   )fd) {
#line 33
        goto while_break___1;
      }
#line 31
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 35
    if (i == count) {
      {
#line 36
      close(fd);
      }
    }
#line 30
    fd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 45
  maxopen = sysconf(4);
  }
#line 46
  if (maxopen > 2147483647L) {
#line 47
    maxopen = 2147483647L;
  }
#line 48
  if (maxopen < 0L) {
#line 49
    maxopen = 1024L;
  }
#line 50
  fd = maxfd + 1;
  {
#line 50
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 50
    if (! ((long )fd <= maxopen)) {
#line 50
      goto while_break___2;
    }
    {
#line 51
    close(fd);
#line 50
    fd ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 53
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 347
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 223
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 84 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_init)(void) ;
#line 91
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_add_watch)(int __fd ,
                                                                                        char const   *__name ,
                                                                                        uint32_t __mask ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static char const   *program  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static _Bool foreground  =    (_Bool)0;
#line 50 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static _Bool amdaemon  =    (_Bool)0;
#line 51 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static FILE *logfile  =    (FILE *)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static _Bool volatile   termsignaled  =    (_Bool volatile   )0;
#line 53 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static char *pidfilename  =    (char *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void termsignal(int i  __attribute__((__unused__)) ) 
{ 


  {
#line 56
  termsignaled = (_Bool volatile   )1;
#line 57
  return;
}
}
#line 58
static void ( /* format attribute */  dolog)(char const   *format  , ...) ;
#line 59
static void ( /* format attribute */  logerror)(char const   *format  , ...) ;
#line 60
static  __attribute__((__noreturn__)) void ( /* format attribute */  logerror_die)(char const   *format 
                                                                                   , ...) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void ( /* format attribute */  dolog)(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 64
  __builtin_va_start(ap, format);
  }
#line 65
  if (amdaemon) {
#line 66
    if ((unsigned long )logfile != (unsigned long )((void *)0)) {
      {
#line 67
      vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)format,
               ap);
      }
    } else {
      {
#line 69
      vsyslog(6, format, ap);
      }
    }
  } else {
    {
#line 71
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
             ap);
    }
  }
  {
#line 73
  __builtin_va_end(ap);
  }
#line 74
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void ( /* format attribute */  logerror)(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 78
  __builtin_va_start(ap, format);
  }
#line 79
  if (amdaemon) {
#line 80
    if ((unsigned long )logfile != (unsigned long )((void *)0)) {
      {
#line 81
      vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)format,
               ap);
      }
    } else {
      {
#line 83
      vsyslog(3, format, ap);
      }
    }
  } else {
    {
#line 85
    fputs((char const   */* __restrict  */)program, (FILE */* __restrict  */)stderr);
#line 86
    fputc(':', stderr);
#line 87
    fputc(' ', stderr);
#line 88
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             ap);
    }
  }
  {
#line 90
  __builtin_va_end(ap);
  }
#line 91
  return;
}
}
#line 92
static  __attribute__((__noreturn__)) void ( /* format attribute */  logerror_die)(char const   *format 
                                                                                   , ...) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void ( /* format attribute */  logerror_die)(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 95
  __builtin_va_start(ap, format);
  }
#line 96
  if (amdaemon) {
#line 97
    if ((unsigned long )logfile != (unsigned long )((void *)0)) {
      {
#line 98
      vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)format,
               ap);
      }
    } else {
      {
#line 100
      vsyslog(3, format, ap);
      }
    }
  } else {
    {
#line 102
    fputs((char const   */* __restrict  */)program, (FILE */* __restrict  */)stderr);
#line 103
    fputc(':', stderr);
#line 104
    fputc(' ', stderr);
#line 105
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             ap);
    }
  }
  {
#line 107
  exit(1);
  }
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static _Bool waitforevent(int notifd , int const   timeout ) 
{ 
  struct pollfd pollinfo ;
  int e ;
  int r ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 114
  pollinfo.fd = notifd;
#line 115
  pollinfo.events = (short)1;
#line 116
  pollinfo.revents = (short)0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    tmp = __errno_location();
#line 118
    *tmp = 0;
#line 119
    r = poll(& pollinfo, (nfds_t )1, (int )timeout);
#line 120
    tmp___0 = __errno_location();
#line 120
    e = *tmp___0;
    }
#line 117
    if (r < 0) {
#line 117
      if (e == 4) {
#line 117
        if (! (! termsignaled)) {
#line 117
          goto while_break;
        }
      } else {
#line 117
        goto while_break;
      }
    } else {
#line 117
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (termsignaled) {
#line 123
    return ((_Bool)0);
  }
#line 124
  if (r < 0) {
    {
#line 125
    tmp___1 = strerror(e);
#line 125
    logerror("Error polling inotify descriptor: %s(%d)\n", tmp___1, e);
#line 127
    exit(1);
    }
  }
#line 129
  if (r == 0) {
#line 130
    if (((int )pollinfo.revents & 1) == 0) {
#line 131
      return ((_Bool)0);
    }
  }
#line 133
  if (((int )pollinfo.revents & 56) != 0) {
    {
#line 134
    logerror("Where did my inotify descriptor go?\n");
#line 135
    exit(1);
    }
  }
#line 137
  return ((_Bool )(((int )pollinfo.revents & 3) != 0));
}
}
#line 142
static struct inotify_event *getevent(int notifd , _Bool *mayread ) ;
#line 142 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void *buffer  =    (void *)0;
#line 143 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static size_t bufcount  =    (size_t )0;
#line 144 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static size_t already  =    (size_t )0;
#line 141 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static struct inotify_event *getevent(int notifd , _Bool *mayread ) 
{ 
  struct inotify_event *event ;
  ssize_t bytesread ;
  size_t size ;
  _Bool doread ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 148
  doread = *mayread;
#line 150
  if (already >= sizeof(struct inotify_event )) {
#line 151
    size = sizeof(struct inotify_event ) + (unsigned long )((struct inotify_event *)buffer)->len;
#line 153
    if (already >= size) {
#line 154
      doread = (_Bool)0;
    }
  }
#line 156
  if (doread) {
#line 157
    if (bufcount <= already + 1024UL) {
      {
#line 158
      buffer = realloc(buffer, already + 20480UL);
      }
#line 159
      if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 160
        return ((struct inotify_event *)((void *)0));
      } else {
#line 162
        bufcount = already + 20480UL;
      }
    }
#line 164
    if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
      {
#line 164
      __assert_fail("buffer != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c",
                    164U, "getevent");
      }
    }
#line 165
    if (! (bufcount > already)) {
      {
#line 165
      __assert_fail("bufcount > already", "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c",
                    165U, "getevent");
      }
    }
    {
#line 167
    bytesread = read(notifd, buffer + already, bufcount - already);
#line 168
    *mayread = (_Bool)0;
    }
#line 169
    if (bytesread < 0L) {
      {
#line 170
      tmp = __errno_location();
#line 170
      e = *tmp;
#line 171
      tmp___0 = strerror(e);
#line 171
      logerror("Error reading from inotify descriptor: %s(%d)\n", tmp___0, e);
#line 174
      exit(1);
      }
    }
#line 176
    if (! ((size_t )bytesread <= bufcount - already)) {
      {
#line 176
      __assert_fail("(size_t)bytesread <= bufcount - already", "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c",
                    176U, "getevent");
      }
    }
#line 177
    already += (size_t )bytesread;
  }
#line 179
  if (already < sizeof(struct inotify_event )) {
#line 180
    return ((struct inotify_event *)((void *)0));
  }
#line 181
  size = sizeof(struct inotify_event ) + (unsigned long )((struct inotify_event *)buffer)->len;
#line 183
  if (already < size) {
#line 184
    return ((struct inotify_event *)((void *)0));
  }
  {
#line 185
  tmp___1 = malloc(size);
#line 185
  event = (struct inotify_event *)tmp___1;
  }
#line 186
  if ((unsigned long )event == (unsigned long )((void *)0)) {
    {
#line 187
    logerror("Out of memory! (allocating %lu bytes)\n", size);
#line 189
    already -= size;
#line 190
    memmove(buffer, (void const   *)(buffer + size), already);
    }
#line 191
    return ((struct inotify_event *)((void *)0));
  }
  {
#line 193
  memcpy((void */* __restrict  */)event, (void const   */* __restrict  */)buffer,
         size);
#line 194
  already -= size;
#line 195
  memmove(buffer, (void const   *)(buffer + size), already);
  }
#line 196
  return (event);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static struct lookfor *lookfor  =    (struct lookfor *)((void *)0);
#line 216 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static char *fill_str(char const   *value , size_t len , size_t subst , char const   *filename ) 
{ 
  size_t fnl ;
  size_t tmp ;
  char *r ;
  void *tmp___0 ;

  {
  {
#line 217
  tmp = strlen(filename);
#line 217
  fnl = tmp;
#line 220
  tmp___0 = malloc((len + fnl) + 1UL);
#line 220
  r = (char *)tmp___0;
  }
#line 221
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 222
    return (r);
  }
  {
#line 223
  memcpy((void */* __restrict  */)r, (void const   */* __restrict  */)value, subst);
#line 224
  memcpy((void */* __restrict  */)(r + subst), (void const   */* __restrict  */)filename,
         fnl);
#line 225
  memcpy((void */* __restrict  */)((r + subst) + fnl), (void const   */* __restrict  */)(value + subst),
         (1UL + len) - subst);
  }
#line 226
  return (r);
}
}
#line 233
static void doaction(struct lookfor  const  *l , char const   *filename ) ;
#line 233 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static int const   exceptions[3]  = {      (int const   )0,      (int const   )1,      (int const   )2};
#line 229 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void doaction(struct lookfor  const  *l , char const   *filename ) 
{ 
  char **args ;
  pid_t child ;
  size_t i ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  int status ;
  pid_t w ;
  int *tmp___1 ;
  union __anonunion_58 __constr_expr_0 ;
  union __anonunion_59 __constr_expr_1 ;
  union __anonunion_60 __constr_expr_2 ;
  union __anonunion_61 __constr_expr_3 ;
  union __anonunion_62 __constr_expr_4 ;
  void *tmp___2 ;
  struct argument *a ;
  int e___0 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int e___1 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int e___2 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 239
  dolog("Will call action %s for: %s\n", l->action, filename);
#line 241
  child = fork();
  }
#line 242
  if (child == -1) {
    {
#line 243
    tmp = __errno_location();
#line 243
    e = *tmp;
#line 244
    tmp___0 = strerror(e);
#line 244
    logerror("Error forking: %s(%d)\n", tmp___0, e);
    }
#line 246
    return;
  }
#line 248
  if (child > 0) {
    {
#line 251
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 252
      w = waitpid(child, & status, 0);
      }
#line 251
      if (w == -1) {
        {
#line 251
        tmp___1 = __errno_location();
        }
#line 251
        if (*tmp___1 == 4) {
#line 251
          if (! (! termsignaled)) {
#line 251
            goto while_break;
          }
        } else {
#line 251
          goto while_break;
        }
      } else {
#line 251
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 254
    if (w == child) {
#line 255
      __constr_expr_3.__in = status;
#line 255
      if ((__constr_expr_3.__i & 127) == 0) {
#line 255
        __constr_expr_4.__in = status;
#line 255
        if ((__constr_expr_4.__i & 65280) >> 8 != 0) {
          {
#line 257
          __constr_expr_0.__in = status;
#line 257
          logerror("Action \'%s\' returned exitcode %d\n", l->action, (__constr_expr_0.__i & 65280) >> 8);
          }
        } else {
#line 255
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 260
        __constr_expr_2.__in = status;
#line 260
        if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
          {
#line 262
          __constr_expr_1.__in = status;
#line 262
          logerror("Action \'%s\' died by signal %d\n", l->action, __constr_expr_1.__i & 127);
          }
        }
      }
    }
#line 267
    return;
  }
  {
#line 270
  tmp___2 = calloc((size_t )(l->num_arguments + 2UL), sizeof(char *));
#line 270
  args = (char **)tmp___2;
  }
#line 271
  if ((unsigned long )args == (unsigned long )((void *)0)) {
    {
#line 272
    logerror_die("Out of memory in child!\n");
    }
  }
#line 273
  *(args + 0) = (char *)l->action;
#line 274
  i = (size_t )0;
  {
#line 274
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 274
    if (! (i < (size_t )l->num_arguments)) {
#line 274
      goto while_break___0;
    }
#line 275
    a = l->arguments + i;
#line 276
    if (a->substitute != 0xffffffffffffffffUL) {
      {
#line 277
      *(args + (i + 1UL)) = fill_str((char const   *)a->argument, a->len, a->substitute,
                                     filename);
      }
#line 279
      if ((unsigned long )*(args + (i + 1UL)) == (unsigned long )((void *)0)) {
        {
#line 280
        logerror_die("Out of memory in child!\n");
        }
      }
    } else {
#line 282
      *(args + (i + 1UL)) = a->argument;
    }
#line 274
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 284
  *(args + (l->num_arguments + 1UL)) = (char *)((void *)0);
#line 285
  if ((unsigned long )l->dir != (unsigned long )((void *)0)) {
    {
#line 285
    tmp___5 = chdir((char const   *)l->dir);
    }
#line 285
    if (tmp___5 != 0) {
      {
#line 286
      tmp___3 = __errno_location();
#line 286
      e___0 = *tmp___3;
#line 287
      tmp___4 = strerror(e___0);
#line 287
      logerror_die("Could not change to directory \'%s\' in child: %s(%d)\n", l->dir,
                   tmp___4, e___0);
      }
    }
  }
#line 290
  if ((unsigned long )logfile != (unsigned long )((void *)0)) {
#line 291
    if (l->logstdout) {
      {
#line 291
      tmp___8 = fileno(logfile);
#line 291
      tmp___9 = dup2(tmp___8, 1);
      }
#line 291
      if (tmp___9 == -1) {
        {
#line 292
        tmp___6 = __errno_location();
#line 292
        e___1 = *tmp___6;
#line 293
        tmp___7 = strerror(e___1);
#line 293
        logerror_die("Could not redirect stdout to logfile: %s(%d)\n", tmp___7, e___1);
        }
      }
    }
#line 296
    if (l->logstderr) {
      {
#line 296
      tmp___12 = fileno(logfile);
#line 296
      tmp___13 = dup2(tmp___12, 2);
      }
#line 296
      if (tmp___13 == -1) {
        {
#line 297
        tmp___10 = __errno_location();
#line 297
        e___2 = *tmp___10;
#line 298
        tmp___11 = strerror(e___2);
#line 298
        logerror_die("Could not redirect stderr to logfile: %s(%d)\n", tmp___11, e___2);
        }
      }
    }
    {
#line 301
    fclose(logfile);
    }
  }
  {
#line 303
  closeallopenfds(exceptions, (size_t )3);
#line 304
  execvp((char const   *)*(args + 0), (char * const  *)args);
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static _Bool shouldprocess(struct lookfor  const  *l , char const   *filename ) 
{ 
  size_t len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 308
  tmp = strlen(filename);
#line 308
  len = tmp;
  }
#line 311
  if ((unsigned long )l->prefix != (unsigned long )((void *)0)) {
#line 311
    if (len < (size_t )l->prefixlen) {
#line 313
      return ((_Bool)0);
    } else {
      {
#line 311
      tmp___0 = memcmp((void const   *)filename, (void const   *)l->prefix, (size_t )l->prefixlen);
      }
#line 311
      if (tmp___0 != 0) {
#line 313
        return ((_Bool)0);
      }
    }
  }
#line 314
  if ((unsigned long )l->suffix != (unsigned long )((void *)0)) {
#line 314
    if (len < (size_t )l->suffixlen) {
#line 317
      return ((_Bool)0);
    } else {
      {
#line 314
      tmp___1 = memcmp((void const   *)((filename + len) - l->suffixlen), (void const   *)l->suffix,
                       (size_t )l->suffixlen);
      }
#line 314
      if (tmp___1 != 0) {
#line 317
        return ((_Bool)0);
      }
    }
  }
#line 319
  if ((unsigned long )l->regexp != (unsigned long )((void *)0)) {
    {
#line 320
    tmp___2 = regexec((regex_t const   */* __restrict  */)(& l->reg), (char const   */* __restrict  */)filename,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 320
    if (tmp___2 != 0) {
#line 321
      return ((_Bool)0);
    }
  }
#line 323
  return ((_Bool)1);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void processevent(struct inotify_event  const  *event ) 
{ 
  struct lookfor  const  *l ;
  _Bool tmp ;

  {
#line 330
  if ((event->mask & 9216U) != 0U) {
    {
#line 331
    logerror_die("Watched directory vanished!\n");
    }
  }
#line 333
  if ((event->mask & 16384U) != 0U) {
    {
#line 334
    logerror("Warning: overflow happened! Events might have been missed.\n");
    }
  }
#line 349
  if (! ((event->mask & 136U) != 0U)) {
#line 350
    return;
  }
#line 352
  l = (struct lookfor  const  *)lookfor;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 352
      goto while_break;
    }
    {
#line 353
    tmp = shouldprocess(l, (char const   *)(event->name));
    }
#line 353
    if (tmp) {
      {
#line 354
      doaction(l, (char const   *)(event->name));
      }
    }
#line 352
    l = (struct lookfor  const  *)l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void process_directory(DIR *dir ) 
{ 
  struct lookfor  const  *l ;
  struct dirent *ent ;
  _Bool tmp ;

  {
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 362
    ent = readdir(dir);
    }
#line 362
    if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 362
      goto while_break;
    }
#line 363
    if ((int )ent->d_type != 8) {
#line 364
      goto while_continue;
    }
#line 365
    l = (struct lookfor  const  *)lookfor;
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 365
        goto while_break___0;
      }
      {
#line 366
      tmp = shouldprocess(l, (char const   *)(ent->d_name));
      }
#line 366
      if (tmp) {
        {
#line 367
        doaction(l, (char const   *)(ent->d_name));
        }
      }
#line 365
      l = (struct lookfor  const  *)l->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
__inline static char *xstrdup(char const   *s ) 
{ 
  char *v ;

  {
  {
#line 374
  v = strdup(s);
  }
#line 375
  if ((unsigned long )v == (unsigned long )((void *)0)) {
    {
#line 376
    logerror_die("Out of memory!\n");
    }
  }
#line 377
  return (v);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void parse_regexp(struct lookfor *l , char const   *regexp ) 
{ 
  int r ;
  size_t s ;
  char *msg ;
  void *tmp ;

  {
#line 382
  if ((unsigned long )l->regexp != (unsigned long )((void *)0)) {
    {
#line 383
    logerror_die("Multiple regular expressions for the same action!\n");
    }
  }
  {
#line 385
  l->regexp = xstrdup(regexp);
#line 386
  r = regcomp((regex_t */* __restrict  */)(& l->reg), (char const   */* __restrict  */)l->regexp,
              1 | (((1 << 1) << 1) << 1));
  }
#line 387
  if (r != 0) {
    {
#line 390
    s = regerror(r, (regex_t const   */* __restrict  */)(& l->reg), (char */* __restrict  */)((void *)0),
                 (size_t )0);
#line 391
    tmp = malloc(s);
#line 391
    msg = (char *)tmp;
    }
#line 392
    if ((unsigned long )msg == (unsigned long )((void *)0)) {
      {
#line 393
      logerror_die("Out of memory!\n");
      }
    }
    {
#line 394
    regerror(r, (regex_t const   */* __restrict  */)(& l->reg), (char */* __restrict  */)msg,
             s);
#line 395
    logerror_die("Error parsing regular expression \'%s\': %s\n", l->regexp, msg);
    }
  }
#line 398
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void parse_argument(struct argument *a , char const   *v ) 
{ 
  size_t len ;
  char const   *p ;
  char *q ;
  _Bool hadsubst ;
  _Bool hadescaped ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 404
  hadsubst = (_Bool)0;
#line 404
  hadescaped = (_Bool)0;
#line 406
  len = (size_t )0;
#line 406
  p = v;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! ((int const   )*p != 0)) {
#line 407
      goto while_break;
    }
#line 408
    if ((int const   )*(p + 0) == 123) {
#line 408
      if ((int const   )*(p + 1) == 123) {
#line 408
        if ((int const   )*(p + 2) == 125) {
#line 408
          if ((int const   )*(p + 3) == 125) {
#line 409
            hadescaped = (_Bool)1;
#line 410
            len += 2UL;
#line 411
            p += 4;
          } else {
#line 408
            goto _L___1;
          }
        } else {
#line 408
          goto _L___1;
        }
      } else {
#line 408
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 412
    if ((int const   )*(p + 0) == 123) {
#line 412
      if ((int const   )*(p + 1) == 125) {
#line 413
        if (hadsubst) {
          {
#line 414
          logerror_die("Only one {} per argument is supported!\n");
          }
        }
#line 416
        hadsubst = (_Bool)1;
#line 417
        p += 2;
      } else {
#line 419
        len ++;
#line 420
        p ++;
      }
    } else {
#line 419
      len ++;
#line 420
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  a->len = len;
#line 425
  a->substitute = (size_t )-1;
#line 426
  tmp = malloc(len + 1UL);
#line 426
  a->argument = (char *)tmp;
  }
#line 427
  if ((unsigned long )a->argument == (unsigned long )((void *)0)) {
    {
#line 428
    logerror_die("Out of memory!\n");
    }
  }
#line 429
  if (! hadsubst) {
#line 429
    if (! hadescaped) {
      {
#line 430
      memcpy((void */* __restrict  */)a->argument, (void const   */* __restrict  */)v,
             len + 1UL);
      }
    } else {
#line 429
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
#line 432
    p = v;
#line 432
    q = a->argument;
    {
#line 433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 433
      if (! ((int const   )*p != 0)) {
#line 433
        goto while_break___0;
      }
#line 434
      if ((int const   )*(p + 0) == 123) {
#line 434
        if ((int const   )*(p + 1) == 123) {
#line 434
          if ((int const   )*(p + 2) == 125) {
#line 434
            if ((int const   )*(p + 3) == 125) {
#line 436
              if (! ((unsigned long )q < (unsigned long )((a->argument + len) + 1))) {
                {
#line 436
                __assert_fail("q < a->argument + len + 1", "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c",
                              436U, "parse_argument");
                }
              }
#line 437
              tmp___0 = q;
#line 437
              q ++;
#line 437
              *tmp___0 = (char )'{';
#line 438
              tmp___1 = q;
#line 438
              q ++;
#line 438
              *tmp___1 = (char )'}';
#line 439
              p += 4;
            } else {
#line 434
              goto _L___5;
            }
          } else {
#line 434
            goto _L___5;
          }
        } else {
#line 434
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 440
      if ((int const   )*(p + 0) == 123) {
#line 440
        if ((int const   )*(p + 1) == 125) {
#line 441
          p += 2;
#line 442
          a->substitute = (size_t )(q - a->argument);
        } else {
#line 440
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 444
        if (! ((unsigned long )q < (unsigned long )(a->argument + len))) {
          {
#line 444
          __assert_fail("q < a->argument + len", "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c",
                        444U, "parse_argument");
          }
        }
#line 445
        tmp___2 = q;
#line 445
        q ++;
#line 445
        tmp___3 = p;
#line 445
        p ++;
#line 445
        *tmp___2 = (char )*tmp___3;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    if (! ((unsigned long )q == (unsigned long )(a->argument + len))) {
      {
#line 448
      __assert_fail("q == a->argument + len", "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c",
                    448U, "parse_argument");
      }
    }
#line 449
    *q = (char )'\000';
  }
#line 451
  return;
}
}
#line 455
static void parseaction(int argc , char * const  *argv , _Bool havelogfile ) ;
#line 455 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static struct option  const  long_options[7]  = {      {"stdout-to-log", 0, (int *)((void *)0), 1}, 
        {"stderr-to-log", 0, (int *)((void *)0), 2}, 
        {"regexp", 1, (int *)((void *)0), 'r'}, 
        {"prefix", 1, (int *)((void *)0), 'p'}, 
        {"suffix", 1, (int *)((void *)0), 's'}, 
        {"chdir", 1, (int *)((void *)0), 'c'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 453 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void parseaction(int argc , char * const  *argv , _Bool havelogfile ) 
{ 
  int i ;
  int j ;
  int opt ;
  struct lookfor *l ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 464
  tmp = calloc((size_t )1, sizeof(struct lookfor ));
#line 464
  l = (struct lookfor *)tmp;
  }
#line 466
  if ((unsigned long )l == (unsigned long )((void *)0)) {
    {
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Out of memory.\n",
            program);
#line 468
    exit(1);
    }
  }
#line 470
  l->next = lookfor;
#line 471
  lookfor = l;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 472
    opt = getopt_long(argc, argv, "+p:s:r:c:", long_options, (int *)((void *)0));
    }
#line 472
    if (! (opt >= 0)) {
#line 472
      goto while_break;
    }
    {
#line 475
    if (opt == 1) {
#line 475
      goto case_1;
    }
#line 481
    if (opt == 2) {
#line 481
      goto case_2;
    }
#line 487
    if (opt == 114) {
#line 487
      goto case_114;
    }
#line 490
    if (opt == 112) {
#line 490
      goto case_112;
    }
#line 497
    if (opt == 115) {
#line 497
      goto case_115;
    }
#line 504
    if (opt == 99) {
#line 504
      goto case_99;
    }
#line 510
    if (opt == 63) {
#line 510
      goto case_63;
    }
#line 474
    goto switch_break;
    case_1: /* CIL Label */ 
#line 476
    if (! havelogfile) {
      {
#line 477
      logerror_die("Action\'s --stderr-to-log needs global --logfile option!\n");
      }
    }
#line 479
    l->logstdout = (_Bool)1;
#line 480
    goto switch_break;
    case_2: /* CIL Label */ 
#line 482
    if (! havelogfile) {
      {
#line 483
      logerror_die("Action\'s --stderr-to-log needs global --logfile option!\n");
      }
    }
#line 485
    l->logstderr = (_Bool)1;
#line 486
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 488
    parse_regexp(lookfor, (char const   *)optarg);
    }
#line 489
    goto switch_break;
    case_112: /* CIL Label */ 
#line 491
    if ((unsigned long )lookfor->prefix != (unsigned long )((void *)0)) {
      {
#line 492
      logerror_die("Multiple --prefix options!\n");
      }
    }
    {
#line 494
    lookfor->prefix = xstrdup((char const   *)optarg);
#line 495
    lookfor->prefixlen = strlen((char const   *)lookfor->prefix);
    }
#line 496
    goto switch_break;
    case_115: /* CIL Label */ 
#line 498
    if ((unsigned long )lookfor->suffix != (unsigned long )((void *)0)) {
      {
#line 499
      logerror_die("Multiple --suffix options!\n");
      }
    }
    {
#line 501
    lookfor->suffix = xstrdup((char const   *)optarg);
#line 502
    lookfor->suffixlen = strlen((char const   *)lookfor->suffix);
    }
#line 503
    goto switch_break;
    case_99: /* CIL Label */ 
#line 505
    if ((unsigned long )lookfor->dir != (unsigned long )((void *)0)) {
      {
#line 506
      logerror_die("Multiple --chdir options!\n");
      }
    }
    {
#line 508
    lookfor->dir = xstrdup((char const   *)optarg);
    }
#line 509
    goto switch_break;
    case_63: /* CIL Label */ 
#line 511
    if (optopt == 0) {
      {
#line 512
      logerror_die("Unknown/ambiguous action option \'%s\'!\n", *(argv + (optind - 1)));
      }
    } else
#line 514
    if (optopt == 112) {
      {
#line 515
      logerror_die("Action option \'%s\' needs an argument!\n", *(argv + (optind - 1)));
      }
    } else
#line 514
    if (optopt == 108) {
      {
#line 515
      logerror_die("Action option \'%s\' needs an argument!\n", *(argv + (optind - 1)));
      }
    } else {
      {
#line 518
      logerror_die("Unknown action option \'%c\'!\n", (int )((char )optopt));
      }
    }
#line 520
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  if (optind >= argc) {
    {
#line 524
    logerror_die("Unexpected end of command line (action expected)!\n");
    }
  }
  {
#line 526
  l->action = xstrdup((char const   *)*(argv + optind));
#line 527
  optind ++;
  }
#line 528
  if ((unsigned long )l->action == (unsigned long )((void *)0)) {
    {
#line 529
    logerror_die("Out of memory!\n");
    }
  }
#line 530
  i = optind;
  {
#line 531
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 531
    if (i < argc) {
      {
#line 531
      tmp___0 = strcmp((char const   *)*(argv + i), ";");
      }
#line 531
      if (! (tmp___0 != 0)) {
#line 531
        goto while_break___0;
      }
    } else {
#line 531
      goto while_break___0;
    }
#line 532
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 533
  if (i >= argc) {
    {
#line 534
    logerror_die("Missing \';\' at end of action!\n(Don\'t forget to escape it (\\;) if you use a shell)\n");
    }
  }
  {
#line 537
  l->num_arguments = (size_t )(i - optind);
#line 538
  tmp___1 = calloc(l->num_arguments, sizeof(struct argument ));
#line 538
  l->arguments = (struct argument *)tmp___1;
  }
#line 539
  if ((unsigned long )l->arguments == (unsigned long )((void *)0)) {
    {
#line 540
    logerror_die("Out of memory!\n");
    }
  }
#line 541
  j = optind;
  {
#line 541
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 541
    if (! (j < i)) {
#line 541
      goto while_break___1;
    }
    {
#line 542
    parse_argument(l->arguments + (j - optind), (char const   *)*(argv + j));
#line 541
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 544
  optind = i + 1;
#line 545
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static void syntax(FILE *file , int exitcode ) 
{ 


  {
  {
#line 549
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Syntax: %s [<options>*] <directory to watch> <actions>\nwhere option can be:\n\t--logfile <file>\n\t--pid-file <file>\n\t--foreground\n\t--initialsearch\nand each action is [<action-options>*] command [<arguments>] ;\nwith possible action-options:\n\t--prefix <string>\tonly processes filenames starting with string.\n\t--suffix <string>\tonly processes filenames ending with string.\n\t--regexp <regular expression>\t... matching the regular expression given.\n\t--chdir <directory>\tchange directory before calling action.\n\t--stdout-to-log\t\tsend output to the logfile\n\t--stderr-to-log\t\tsend error output to the logfile\nIn the arguments {} is replaced by the filename found.\nNote the ; at the end of every action. (In a shell, use \\; to get ;)\n",
          program);
#line 567
  exit(exitcode);
  }
}
}
#line 580
int main(int argc , char * const  *argv ) ;
#line 580 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
static struct option  const  global_long_options[7]  = {      {"version", 0, (int *)((void *)0), 1}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"logfile", 1, (int *)((void *)0), 'l'}, 
        {"foreground", 0, (int *)((void *)0), 'F'}, 
        {"initialsearch", 0, (int *)((void *)0), 'i'}, 
        {"pid-file", 1, (int *)((void *)0), 'p'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 570 "/home/june/repo/benchmarks/collector/temp/inoticoming-0.2.3/inoticoming.c"
int main(int argc , char * const  *argv ) 
{ 
  int notifd ;
  int dirwatchid ;
  char const   *directory ;
  char *logfilename ;
  int timeout ;
  int e ;
  int opt ;
  struct inotify_event *event ;
  FILE *pidfile ;
  DIR *dir ;
  _Bool initialsearch ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  __pid_t tmp___12 ;
  int exceptions___0[6] ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  _Bool doread ;
  _Bool tmp___18 ;

  {
#line 574
  logfilename = (char *)((void *)0);
#line 579
  initialsearch = (_Bool)0;
#line 590
  program = (char const   *)*(argv + 0);
#line 591
  if (argc < 2) {
    {
#line 592
    logerror("Not enough arguments.\n");
#line 593
    syntax(stderr, 1);
    }
  }
#line 595
  opterr = 0;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 596
    opt = getopt_long(argc, argv, "+h?p:l:Ffi", global_long_options, (int *)((void *)0));
    }
#line 596
    if (! (opt >= 0)) {
#line 596
      goto while_break;
    }
    {
#line 599
    if (opt == 1) {
#line 599
      goto case_1;
    }
#line 603
    if (opt == 104) {
#line 603
      goto case_104;
    }
#line 606
    if (opt == 108) {
#line 606
      goto case_108;
    }
#line 612
    if (opt == 112) {
#line 612
      goto case_112;
    }
#line 619
    if (opt == 70) {
#line 619
      goto case_70;
    }
#line 619
    if (opt == 102) {
#line 619
      goto case_70;
    }
#line 622
    if (opt == 105) {
#line 622
      goto case_105;
    }
#line 625
    if (opt == 63) {
#line 625
      goto case_63;
    }
#line 598
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 600
    puts("inoticoming 0.2.3");
#line 601
    exit(0);
    }
#line 602
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 604
    syntax(stdout, 0);
    }
#line 605
    goto switch_break;
    case_108: /* CIL Label */ 
#line 607
    if ((unsigned long )logfile != (unsigned long )((void *)0)) {
      {
#line 608
      logerror_die("Multiple --logfile options are not supported.\n");
      }
    }
    {
#line 610
    logfilename = xstrdup((char const   *)optarg);
    }
#line 611
    goto switch_break;
    case_112: /* CIL Label */ 
#line 613
    if ((unsigned long )pidfilename != (unsigned long )((void *)0)) {
      {
#line 614
      logerror_die("Multiple --pid-file options are not supported.\n");
      }
    }
    {
#line 616
    pidfilename = xstrdup((char const   *)optarg);
    }
#line 617
    goto switch_break;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 620
    foreground = (_Bool)1;
#line 621
    goto switch_break;
    case_105: /* CIL Label */ 
#line 623
    initialsearch = (_Bool)1;
#line 624
    goto switch_break;
    case_63: /* CIL Label */ 
#line 626
    if (optopt == 0) {
      {
#line 627
      logerror_die("Unknown/ambiguous global option \'%s\'!\n", *(argv + (optind - 1)));
      }
    } else
#line 629
    if (optopt == 112) {
      {
#line 630
      logerror_die("Global option \'%s\' needs an argument!\n", *(argv + (optind - 1)));
      }
    } else
#line 629
    if (optopt == 108) {
      {
#line 630
      logerror_die("Global option \'%s\' needs an argument!\n", *(argv + (optind - 1)));
      }
    } else {
      {
#line 633
      logerror_die("Unknown global option \'%c\'!\n", (int )((char )optopt));
      }
    }
#line 635
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  if (optind >= argc) {
    {
#line 639
    logerror_die("Not enough arguments!\n");
    }
  }
#line 640
  directory = (char const   *)*(argv + optind);
#line 641
  optind ++;
  {
#line 642
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 642
    if (! (optind < argc)) {
#line 642
      goto while_break___0;
    }
    {
#line 643
    parseaction(argc, argv, (_Bool )((unsigned long )logfilename != (unsigned long )((void *)0)));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 644
  if ((unsigned long )lookfor == (unsigned long )((void *)0)) {
    {
#line 645
    logerror_die("Nothing to do specified!\n");
    }
  }
  {
#line 647
  notifd = inotify_init();
  }
#line 648
  if (notifd < 0) {
    {
#line 649
    tmp = __errno_location();
#line 649
    e = *tmp;
#line 650
    tmp___0 = strerror(e);
#line 650
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Could not initialize inotify: %s(%d)\n",
            program, tmp___0, e);
    }
#line 652
    return (1);
  }
  {
#line 655
  dirwatchid = inotify_add_watch(notifd, directory, (uint32_t )16778376);
  }
#line 657
  if (dirwatchid < 0) {
    {
#line 658
    tmp___1 = __errno_location();
#line 658
    e = *tmp___1;
#line 659
    tmp___2 = strerror(e);
#line 659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error adding watch for %s: %s(%d)\n",
            program, directory, tmp___2, e);
#line 661
    close(notifd);
    }
#line 662
    return (1);
  }
#line 665
  if (initialsearch) {
    {
#line 666
    dir = opendir(directory);
    }
#line 667
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
      {
#line 668
      tmp___3 = __errno_location();
#line 668
      e = *tmp___3;
#line 669
      tmp___4 = strerror(e);
#line 669
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error opening directory %s: %s(%d)\n",
              program, directory, tmp___4, e);
#line 672
      close(notifd);
      }
#line 673
      return (1);
    }
  } else {
#line 676
    dir = (DIR *)((void *)0);
  }
#line 678
  if ((unsigned long )pidfilename != (unsigned long )((void *)0)) {
    {
#line 679
    pidfile = fopen((char const   */* __restrict  */)pidfilename, (char const   */* __restrict  */)"w");
    }
#line 680
    if ((unsigned long )pidfile == (unsigned long )((void *)0)) {
      {
#line 681
      tmp___5 = __errno_location();
#line 681
      e = *tmp___5;
#line 682
      tmp___6 = strerror(e);
#line 682
      logerror_die("Could not create/open pidfile \'%s\': %s(%d)\n", pidfilename,
                   tmp___6, e);
      }
    }
  } else {
#line 687
    pidfile = (FILE *)((void *)0);
  }
#line 688
  if (! foreground) {
#line 689
    if ((unsigned long )logfilename != (unsigned long )((void *)0)) {
      {
#line 690
      logfile = fopen((char const   */* __restrict  */)logfilename, (char const   */* __restrict  */)"a");
      }
#line 691
      if ((unsigned long )logfile == (unsigned long )((void *)0)) {
        {
#line 692
        tmp___7 = __errno_location();
#line 692
        e = *tmp___7;
#line 693
        tmp___8 = strerror(e);
#line 693
        logerror_die("Error opening logfile \'%s\': %s(%d)\n", logfilename, tmp___8,
                     e);
        }
      }
      {
#line 697
      free((void *)logfilename);
#line 697
      logfilename = (char *)((void *)0);
#line 698
      setlinebuf(logfile);
      }
    } else {
      {
#line 700
      openlog("queueprocessor", 1, 3 << 3);
      }
    }
    {
#line 701
    tmp___11 = daemon(0, 0);
    }
#line 701
    if (tmp___11 < 0) {
      {
#line 702
      tmp___9 = __errno_location();
#line 702
      e = *tmp___9;
#line 703
      tmp___10 = strerror(e);
#line 703
      logerror_die("Failed to daemonize: %s(%d)\n", tmp___10, e);
      }
    }
#line 706
    amdaemon = (_Bool)1;
  } else {
    {
#line 708
    setlinebuf(stdout);
#line 709
    setlinebuf(stderr);
    }
  }
#line 711
  if ((unsigned long )pidfile != (unsigned long )((void *)0)) {
    {
#line 712
    tmp___12 = getpid();
#line 712
    fprintf((FILE */* __restrict  */)pidfile, (char const   */* __restrict  */)"%llu",
            (unsigned long long )tmp___12);
#line 713
    fclose(pidfile);
    }
  }
#line 716
  if ((unsigned long )logfile == (unsigned long )((void *)0)) {
#line 716
    tmp___14 = -1;
  } else {
    {
#line 716
    tmp___13 = fileno(logfile);
#line 716
    tmp___14 = tmp___13;
    }
  }
#line 716
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 716
    tmp___16 = -1;
  } else {
    {
#line 716
    tmp___15 = dirfd(dir);
#line 716
    tmp___16 = tmp___15;
    }
  }
  {
#line 716
  exceptions___0[0] = 0;
#line 716
  exceptions___0[1] = 1;
#line 716
  exceptions___0[2] = 2;
#line 716
  exceptions___0[3] = notifd;
#line 716
  exceptions___0[4] = tmp___14;
#line 716
  exceptions___0[5] = tmp___16;
#line 719
  closeallopenfds((int const   *)(exceptions___0), (size_t )6);
#line 720
  tmp___17 = __errno_location();
#line 720
  *tmp___17 = 0;
#line 722
  signal(15, & termsignal);
#line 723
  signal(6, & termsignal);
  }
#line 725
  if ((unsigned long )dir != (unsigned long )((void *)0)) {
    {
#line 726
    process_directory(dir);
#line 727
    closedir(dir);
    }
  }
#line 730
  timeout = -1;
  {
#line 731
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 731
    if (! (! termsignaled)) {
#line 731
      goto while_break___1;
    }
    {
#line 732
    tmp___18 = waitforevent(notifd, (int const   )timeout);
    }
#line 732
    if (tmp___18) {
#line 733
      doread = (_Bool)1;
#line 734
      if (termsignaled) {
#line 735
        goto while_break___1;
      }
      {
#line 736
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 736
        event = getevent(notifd, & doread);
        }
#line 736
        if (! ((unsigned long )event != (unsigned long )((void *)0))) {
#line 736
          goto while_break___2;
        }
        {
#line 737
        processevent((struct inotify_event  const  *)event);
#line 738
        free((void *)event);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 741
      timeout = -1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 744
  close(notifd);
  }
#line 745
  return (0);
}
}
