/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 43 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef int SRes;
#line 55 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef unsigned char Byte;
#line 64 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef unsigned int UInt32;
#line 83 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef unsigned long long UInt64;
#line 92 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef size_t SizeT;
#line 95 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef int Bool;
#line 137 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_ISeqInStream_3 {
   SRes (*Read)(void *p , void *buf , size_t *size ) ;
};
#line 137 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_ISeqInStream_3 ISeqInStream;
#line 149 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_ISeqOutStream_4 {
   size_t (*Write)(void *p , void const   *buf , size_t size ) ;
};
#line 149 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_ISeqOutStream_4 ISeqOutStream;
#line 220 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_ICompressProgress_11 {
   SRes (*Progress)(void *p , UInt64 inSize , UInt64 outSize ) ;
};
#line 220 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_ICompressProgress_11 ICompressProgress;
#line 227 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_ISzAlloc_12 {
   void *(*Alloc)(void *p , size_t size ) ;
   void (*Free)(void *p , void *address ) ;
};
#line 227 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_ISzAlloc_12 ISzAlloc;
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.h"
struct _CLzmaEncProps {
   int level ;
   UInt32 dictSize ;
   int lc ;
   int lp ;
   int pb ;
   int algo ;
   int fb ;
   int btMode ;
   int numHashBytes ;
   UInt32 mc ;
   unsigned int writeEndMark ;
   int numThreads ;
};
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.h"
typedef struct _CLzmaEncProps CLzmaEncProps;
#line 50 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.h"
typedef void *CLzmaEncHandle;
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.h"
struct __anonstruct_CLzma2EncProps_13 {
   CLzmaEncProps lzmaProps ;
   size_t blockSize ;
   int numBlockThreads ;
   int numTotalThreads ;
};
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.h"
typedef struct __anonstruct_CLzma2EncProps_13 CLzma2EncProps;
#line 36 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.h"
typedef void *CLzma2EncHandle;
#line 67 "../../../include_windows/windows.h"
typedef void *LPVOID;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_17 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_17 pthread_mutex_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_20 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_19 {
   struct __anonstruct___data_20 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_19 pthread_cond_t;
#line 19 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
struct _CThread {
   pthread_t _tid ;
   int _created ;
};
#line 19 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
typedef struct _CThread CThread;
#line 33 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
typedef unsigned int THREAD_FUNC_RET_TYPE;
#line 43 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
struct _CEvent {
   int _created ;
   int _manual_reset ;
   int _state ;
   pthread_mutex_t _mutex ;
   pthread_cond_t _cond ;
};
#line 43 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
typedef struct _CEvent CEvent;
#line 58 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
typedef CEvent CAutoResetEvent;
#line 97 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
struct __anonstruct_CCriticalSection_39 {
   pthread_mutex_t _mutex ;
};
#line 97 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
typedef struct __anonstruct_CCriticalSection_39 CCriticalSection;
#line 11 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
struct __anonstruct_CLoopThread_40 {
   CThread thread ;
   CAutoResetEvent startEvent ;
   CAutoResetEvent finishedEvent ;
   int stop ;
   THREAD_FUNC_RET_TYPE (*func)(void * ) ;
   LPVOID param ;
   THREAD_FUNC_RET_TYPE res ;
};
#line 11 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
typedef struct __anonstruct_CLoopThread_40 CLoopThread;
#line 36 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
struct __anonstruct_CMtProgress_41 {
   UInt64 totalInSize ;
   UInt64 totalOutSize ;
   ICompressProgress *progress ;
   SRes res ;
   CCriticalSection cs ;
   UInt64 inSizes[32] ;
   UInt64 outSizes[32] ;
};
#line 36 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
typedef struct __anonstruct_CMtProgress_41 CMtProgress;
#line 49
struct _CMtCoder;
#line 51 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
struct __anonstruct_CMtThread_42 {
   struct _CMtCoder *mtCoder ;
   Byte *outBuf ;
   size_t outBufSize ;
   Byte *inBuf ;
   size_t inBufSize ;
   unsigned int index ;
   CLoopThread thread ;
   Bool stopReading ;
   Bool stopWriting ;
   CAutoResetEvent canRead ;
   CAutoResetEvent canWrite ;
};
#line 51 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
typedef struct __anonstruct_CMtThread_42 CMtThread;
#line 67 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
struct __anonstruct_IMtCoderCallback_43 {
   SRes (*Code)(void *p , unsigned int index , Byte *dest , size_t *destSize , Byte const   *src ,
                size_t srcSize , int finished ) ;
};
#line 67 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
typedef struct __anonstruct_IMtCoderCallback_43 IMtCoderCallback;
#line 73 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
struct _CMtCoder {
   size_t blockSize ;
   size_t destBlockSize ;
   unsigned int numThreads ;
   ISeqInStream *inStream ;
   ISeqOutStream *outStream ;
   ICompressProgress *progress ;
   ISzAlloc *alloc ;
   IMtCoderCallback *mtCallback ;
   CCriticalSection cs ;
   SRes res ;
   CMtProgress mtProgress ;
   CMtThread threads[32] ;
};
#line 73 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
typedef struct _CMtCoder CMtCoder;
#line 38 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
struct __anonstruct_CLzma2EncInt_44 {
   CLzmaEncHandle enc ;
   UInt64 srcPos ;
   Byte props ;
   Bool needInitState ;
   Bool needInitProp ;
};
#line 38 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
typedef struct __anonstruct_CLzma2EncInt_44 CLzma2EncInt;
#line 243 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
struct __anonstruct_CLzma2Enc_45 {
   Byte propEncoded ;
   CLzma2EncProps props ;
   Byte *outBuf ;
   ISzAlloc *alloc ;
   ISzAlloc *allocBig ;
   CLzma2EncInt coders[32] ;
   CMtCoder mtCoder ;
};
#line 243 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
typedef struct __anonstruct_CLzma2Enc_45 CLzma2Enc;
#line 304 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
struct __anonstruct_CMtCallbackImp_46 {
   IMtCoderCallback funcTable ;
   CLzma2Enc *lzma2Enc ;
};
#line 304 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
typedef struct __anonstruct_CMtCallbackImp_46 CMtCallbackImp;
#line 48 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef int WRes;
#line 39 "../../../include_windows/windows.h"
typedef int BOOL;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_17 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_17 pthread_mutexattr_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_20 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_20 pthread_condattr_t;
#line 59 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
typedef CEvent CManualResetEvent;
#line 74 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
struct _CSemaphore {
   int _created ;
   UInt32 _count ;
   UInt32 _maxCount ;
   pthread_mutex_t _mutex ;
   pthread_cond_t _cond ;
};
#line 74 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
typedef struct _CSemaphore CSemaphore;
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.h"
struct __anonstruct_CSha256_13 {
   UInt32 state[8] ;
   UInt64 count ;
   Byte buffer[64] ;
};
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.h"
typedef struct __anonstruct_CSha256_13 CSha256;
#line 57 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef unsigned short UInt16;
#line 63 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef int Int32;
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.h"
typedef UInt32 CLzRef;
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.h"
struct _CMatchFinder {
   Byte *buffer ;
   UInt32 pos ;
   UInt32 posLimit ;
   UInt32 streamPos ;
   UInt32 lenLimit ;
   UInt32 cyclicBufferPos ;
   UInt32 cyclicBufferSize ;
   UInt32 matchMaxLen ;
   CLzRef *hash ;
   CLzRef *son ;
   UInt32 hashMask ;
   UInt32 cutValue ;
   Byte *bufferBase ;
   ISeqInStream *stream ;
   int streamEndWasReached ;
   UInt32 blockSize ;
   UInt32 keepSizeBefore ;
   UInt32 keepSizeAfter ;
   UInt32 numHashBytes ;
   int directInput ;
   size_t directInputRem ;
   int btMode ;
   int bigHash ;
   UInt32 historySize ;
   UInt32 fixedHashSize ;
   UInt32 hashSizeSum ;
   UInt32 numSons ;
   SRes result ;
   UInt32 crc[256] ;
};
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.h"
typedef struct _CMatchFinder CMatchFinder;
#line 93 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.h"
struct _IMatchFinder {
   void (*Init)(void *object ) ;
   Byte (*GetIndexByte)(void *object , Int32 index ) ;
   UInt32 (*GetNumAvailableBytes)(void *object ) ;
   Byte const   *(*GetPointerToCurrentPos)(void *object ) ;
   UInt32 (*GetMatches)(void *object , UInt32 *distances ) ;
   void (*Skip)(void *object , UInt32  ) ;
};
#line 93 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.h"
typedef struct _IMatchFinder IMatchFinder;
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.h"
struct _CMtSync {
   Bool wasCreated ;
   Bool needStart ;
   Bool exit ;
   Bool stopWriting ;
   CThread thread ;
   CAutoResetEvent canStart ;
   CAutoResetEvent wasStarted ;
   CAutoResetEvent wasStopped ;
   CSemaphore freeSemaphore ;
   CSemaphore filledSemaphore ;
   Bool csWasInitialized ;
   Bool csWasEntered ;
   CCriticalSection cs ;
   UInt32 numProcessedBlocks ;
};
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.h"
typedef struct _CMtSync CMtSync;
#line 49 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.h"
struct _CMatchFinderMt {
   Byte const   *pointerToCurPos ;
   UInt32 *btBuf ;
   UInt32 btBufPos ;
   UInt32 btBufPosLimit ;
   UInt32 lzPos ;
   UInt32 btNumAvailBytes ;
   UInt32 *hash ;
   UInt32 fixedHashSize ;
   UInt32 historySize ;
   UInt32 const   *crc ;
   UInt32 *(*MixMatchesFunc)(void *p , UInt32 matchMinPos , UInt32 *distances ) ;
   CMtSync btSync ;
   Byte btDummy[128] ;
   UInt32 *hashBuf ;
   UInt32 hashBufPos ;
   UInt32 hashBufPosLimit ;
   UInt32 hashNumAvail ;
   CLzRef *son ;
   UInt32 matchMaxLen ;
   UInt32 numHashBytes ;
   UInt32 pos ;
   Byte *buffer ;
   UInt32 cyclicBufferPos ;
   UInt32 cyclicBufferSize ;
   UInt32 cutValue ;
   CMtSync hashSync ;
   void (*GetHeadsFunc)(Byte const   *buffer , UInt32 pos , UInt32 *hash , UInt32 hashMask ,
                        UInt32 *heads , UInt32 numHeads , UInt32 const   *crc ) ;
   CMatchFinder *MatchFinder ;
};
#line 49 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.h"
typedef struct _CMatchFinderMt CMatchFinderMt;
#line 140 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef unsigned int CState;
#line 142 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
struct __anonstruct_COptimal_39 {
   UInt32 price ;
   CState state ;
   int prev1IsChar ;
   int prev2 ;
   UInt32 posPrev2 ;
   UInt32 backPrev2 ;
   UInt32 posPrev ;
   UInt32 backPrev ;
   UInt32 backs[4] ;
};
#line 142 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef struct __anonstruct_COptimal_39 COptimal;
#line 204 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
struct __anonstruct_CLenEnc_40 {
   UInt16 choice ;
   UInt16 choice2 ;
   UInt16 low[(1 << 4) << 3] ;
   UInt16 mid[(1 << 4) << 3] ;
   UInt16 high[1 << 8] ;
};
#line 204 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef struct __anonstruct_CLenEnc_40 CLenEnc;
#line 213 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
struct __anonstruct_CLenPriceEnc_41 {
   CLenEnc p ;
   UInt32 prices[1 << 4][((1 << 3) + (1 << 3)) + (1 << 8)] ;
   UInt32 tableSize ;
   UInt32 counters[1 << 4] ;
};
#line 213 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef struct __anonstruct_CLenPriceEnc_41 CLenPriceEnc;
#line 221 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
struct __anonstruct_CRangeEnc_42 {
   UInt32 range ;
   Byte cache ;
   UInt64 low ;
   UInt64 cacheSize ;
   Byte *buf ;
   Byte *bufLim ;
   Byte *bufBase ;
   ISeqOutStream *outStream ;
   UInt64 processed ;
   SRes res ;
};
#line 221 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef struct __anonstruct_CRangeEnc_42 CRangeEnc;
#line 235 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
struct __anonstruct_CSaveState_43 {
   UInt16 *litProbs ;
   UInt16 isMatch[12][1 << 4] ;
   UInt16 isRep[12] ;
   UInt16 isRepG0[12] ;
   UInt16 isRepG1[12] ;
   UInt16 isRepG2[12] ;
   UInt16 isRep0Long[12][1 << 4] ;
   UInt16 posSlotEncoder[4][1 << 6] ;
   UInt16 posEncoders[(1 << (14 >> 1)) - 14] ;
   UInt16 posAlignEncoder[1 << 4] ;
   CLenPriceEnc lenEnc ;
   CLenPriceEnc repLenEnc ;
   UInt32 reps[4] ;
   UInt32 state ;
};
#line 235 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef struct __anonstruct_CSaveState_43 CSaveState;
#line 257 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
struct __anonstruct_CLzmaEnc_44 {
   IMatchFinder matchFinder ;
   void *matchFinderObj ;
   Bool mtMode ;
   CMatchFinderMt matchFinderMt ;
   CMatchFinder matchFinderBase ;
   Byte pad[128] ;
   UInt32 optimumEndIndex ;
   UInt32 optimumCurrentIndex ;
   UInt32 longestMatchLength ;
   UInt32 numPairs ;
   UInt32 numAvail ;
   COptimal opt[1 << 12] ;
   Byte g_FastPos[1 << (9 + (int )sizeof(size_t ) / 2)] ;
   UInt32 ProbPrices[(1 << 11) >> 4] ;
   UInt32 matches[(((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1) * 2 + 2) + 1] ;
   UInt32 numFastBytes ;
   UInt32 additionalOffset ;
   UInt32 reps[4] ;
   UInt32 state ;
   UInt32 posSlotPrices[4][64] ;
   UInt32 distancesPrices[4][1 << (14 >> 1)] ;
   UInt32 alignPrices[1 << 4] ;
   UInt32 alignPriceCount ;
   UInt32 distTableSize ;
   unsigned int lc ;
   unsigned int lp ;
   unsigned int pb ;
   unsigned int lpMask ;
   unsigned int pbMask ;
   UInt16 *litProbs ;
   UInt16 isMatch[12][1 << 4] ;
   UInt16 isRep[12] ;
   UInt16 isRepG0[12] ;
   UInt16 isRepG1[12] ;
   UInt16 isRepG2[12] ;
   UInt16 isRep0Long[12][1 << 4] ;
   UInt16 posSlotEncoder[4][1 << 6] ;
   UInt16 posEncoders[(1 << (14 >> 1)) - 14] ;
   UInt16 posAlignEncoder[1 << 4] ;
   CLenPriceEnc lenEnc ;
   CLenPriceEnc repLenEnc ;
   unsigned int lclp ;
   Bool fastMode ;
   CRangeEnc rc ;
   Bool writeEndMark ;
   UInt64 nowPos64 ;
   UInt32 matchPriceCount ;
   Bool finished ;
   Bool multiThread ;
   SRes result ;
   UInt32 dictSize ;
   UInt32 matchFinderCycles ;
   int needInit ;
   CSaveState saveState ;
};
#line 257 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef struct __anonstruct_CLzmaEnc_44 CLzmaEnc;
#line 2085 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
struct __anonstruct_CSeqOutStreamBuf_45 {
   ISeqOutStream funcTable ;
   Byte *data ;
   SizeT rem ;
   Bool overflow ;
};
#line 2085 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
typedef struct __anonstruct_CSeqOutStreamBuf_45 CSeqOutStreamBuf;
#line 127 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_IByteIn_1 {
   Byte (*Read)(void *p ) ;
};
#line 127 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_IByteIn_1 IByteIn;
#line 132 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_IByteOut_2 {
   void (*Write)(void *p , Byte b ) ;
};
#line 132 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_IByteOut_2 IByteOut;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
#pragma pack(push,1)
#line 35 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
struct __anonstruct_CPpmd_See_15 {
   UInt16 Summ ;
   Byte Shift ;
   Byte Count ;
};
#line 35 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
typedef struct __anonstruct_CPpmd_See_15 CPpmd_See;
#line 45 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
struct __anonstruct_CPpmd_State_16 {
   Byte Symbol ;
   Byte Freq ;
   UInt16 SuccessorLow ;
   UInt16 SuccessorHigh ;
};
#line 45 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
typedef struct __anonstruct_CPpmd_State_16 CPpmd_State;
#line 53
#pragma pack(pop)
#line 55 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
typedef UInt32 CPpmd_State_Ref;
#line 63 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
typedef UInt32 CPpmd_Void_Ref;
#line 17 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
struct CPpmd8_Context_;
#line 19 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
typedef UInt32 CPpmd8_Context_Ref;
#line 27 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
struct CPpmd8_Context_ {
   Byte NumStats ;
   Byte Flags ;
   UInt16 SummFreq ;
   CPpmd_State_Ref Stats ;
   CPpmd8_Context_Ref Suffix ;
};
#line 27 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
typedef struct CPpmd8_Context_ CPpmd8_Context;
#line 51 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
union __anonunion_Stream_19 {
   IByteIn *In ;
   IByteOut *Out ;
};
#line 51 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
struct __anonstruct_CPpmd8_18 {
   CPpmd8_Context *MinContext ;
   CPpmd8_Context *MaxContext ;
   CPpmd_State *FoundState ;
   unsigned int OrderFall ;
   unsigned int InitEsc ;
   unsigned int PrevSuccess ;
   unsigned int MaxOrder ;
   Int32 RunLength ;
   Int32 InitRL ;
   UInt32 Size ;
   UInt32 GlueCount ;
   Byte *Base ;
   Byte *LoUnit ;
   Byte *HiUnit ;
   Byte *Text ;
   Byte *UnitsStart ;
   UInt32 AlignOffset ;
   unsigned int RestoreMethod ;
   UInt32 Range ;
   UInt32 Code ;
   UInt32 Low ;
   union __anonunion_Stream_19 Stream ;
   Byte Indx2Units[38] ;
   Byte Units2Indx[128] ;
   CPpmd_Void_Ref FreeList[38] ;
   UInt32 Stamps[38] ;
   Byte NS2BSIndx[256] ;
   Byte NS2Indx[260] ;
   CPpmd_See DummySee ;
   CPpmd_See See[24][32] ;
   UInt16 BinSumm[25][64] ;
};
#line 51 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
typedef struct __anonstruct_CPpmd8_18 CPpmd8;
#line 77 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CXzCheck_18 {
   int mode ;
   UInt32 crc ;
   UInt64 crc64 ;
   CSha256 sha ;
};
#line 77 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CXzCheck_18 CXzCheck;
#line 89 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef UInt16 CXzStreamFlags;
#line 99 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CXzBlockSizes_19 {
   UInt64 unpackSize ;
   UInt64 totalSize ;
};
#line 99 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CXzBlockSizes_19 CXzBlockSizes;
#line 105 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CXzStream_20 {
   CXzStreamFlags flags ;
   size_t numBlocks ;
   size_t numBlocksAllocated ;
   CXzBlockSizes *blocks ;
   UInt64 startOffset ;
};
#line 105 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CXzStream_20 CXzStream;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 82 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef long long Int64;
#line 156
enum __anonenum_ESzSeek_5 {
    SZ_SEEK_SET = 0,
    SZ_SEEK_CUR = 1,
    SZ_SEEK_END = 2
} ;
#line 156 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef enum __anonenum_ESzSeek_5 ESzSeek;
#line 169 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_ILookInStream_7 {
   SRes (*Look)(void *p , void const   **buf , size_t *size ) ;
   SRes (*Skip)(void *p , size_t offset ) ;
   SRes (*Read)(void *p , void *buf , size_t *size ) ;
   SRes (*Seek)(void *p , Int64 *pos , ESzSeek origin ) ;
};
#line 169 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_ILookInStream_7 ILookInStream;
#line 212 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_CSecToRead_10 {
   ISeqInStream s ;
   ILookInStream *realStream ;
};
#line 212 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_CSecToRead_10 CSecToRead;
#line 35 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CXzFilter_16 {
   UInt64 id ;
   UInt32 propsSize ;
   Byte props[20] ;
};
#line 35 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CXzFilter_16 CXzFilter;
#line 42 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CXzBlock_17 {
   UInt64 packSize ;
   UInt64 unpackSize ;
   Byte flags ;
   CXzFilter filters[4] ;
};
#line 42 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CXzBlock_17 CXzBlock;
#line 122 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CXzs_21 {
   size_t num ;
   size_t numAllocated ;
   CXzStream *streams ;
};
#line 122 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CXzs_21 CXzs;
#line 163 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_ISeekInStream_6 {
   SRes (*Read)(void *p , void *buf , size_t *size ) ;
   SRes (*Seek)(void *p , Int64 *pos , ESzSeek origin ) ;
};
#line 163 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_ISeekInStream_6 ISeekInStream;
#line 192 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_CLookToRead_8 {
   ILookInStream s ;
   ISeekInStream *realStream ;
   size_t pos ;
   size_t size ;
   Byte buf[1 << 14] ;
};
#line 192 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_CLookToRead_8 CLookToRead;
#line 204 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
struct __anonstruct_CSecToLook_9 {
   ISeqInStream s ;
   ILookInStream *realStream ;
};
#line 204 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
typedef struct __anonstruct_CSecToLook_9 CSecToLook;
#line 28 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
struct _CLzmaProps {
   unsigned int lc ;
   unsigned int lp ;
   unsigned int pb ;
   UInt32 dicSize ;
};
#line 28 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
typedef struct _CLzmaProps CLzmaProps;
#line 50 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
struct __anonstruct_CLzmaDec_35 {
   CLzmaProps prop ;
   UInt16 *probs ;
   Byte *dic ;
   Byte const   *buf ;
   UInt32 range ;
   UInt32 code ;
   SizeT dicPos ;
   SizeT dicBufSize ;
   UInt32 processedPos ;
   UInt32 checkDicSize ;
   unsigned int state ;
   UInt32 reps[4] ;
   unsigned int remainLen ;
   int needFlush ;
   int needInitState ;
   UInt32 numProbs ;
   unsigned int tempBufSize ;
   Byte tempBuf[20] ;
};
#line 50 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
typedef struct __anonstruct_CLzmaDec_35 CLzmaDec;
#line 79
enum __anonenum_ELzmaFinishMode_36 {
    LZMA_FINISH_ANY = 0,
    LZMA_FINISH_END = 1
} ;
#line 79 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
typedef enum __anonenum_ELzmaFinishMode_36 ELzmaFinishMode;
#line 100
enum __anonenum_ELzmaStatus_37 {
    LZMA_STATUS_NOT_SPECIFIED = 0,
    LZMA_STATUS_FINISHED_WITH_MARK = 1,
    LZMA_STATUS_NOT_FINISHED = 2,
    LZMA_STATUS_NEEDS_MORE_INPUT = 3,
    LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK = 4
} ;
#line 100 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
typedef enum __anonenum_ELzmaStatus_37 ELzmaStatus;
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.h"
struct __anonstruct_CLzma2Dec_38 {
   CLzmaDec decoder ;
   UInt32 packSize ;
   UInt32 unpackSize ;
   int state ;
   Byte control ;
   Bool needInitDic ;
   Bool needInitState ;
   Bool needInitProp ;
};
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.h"
typedef struct __anonstruct_CLzma2Dec_38 CLzma2Dec;
#line 136 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
enum __anonenum_ECoderStatus_46 {
    CODER_STATUS_NOT_SPECIFIED = 0,
    CODER_STATUS_FINISHED_WITH_MARK = 1,
    CODER_STATUS_NOT_FINISHED = 2,
    CODER_STATUS_NEEDS_MORE_INPUT = 3
} ;
#line 136 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef enum __anonenum_ECoderStatus_46 ECoderStatus;
#line 144
enum __anonenum_ECoderFinishMode_47 {
    CODER_FINISH_ANY = 0,
    CODER_FINISH_END = 1
} ;
#line 144 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef enum __anonenum_ECoderFinishMode_47 ECoderFinishMode;
#line 150 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct _IStateCoder {
   void *p ;
   void (*Free)(void *p , ISzAlloc *alloc ) ;
   SRes (*SetProps)(void *p , Byte const   *props , size_t propSize , ISzAlloc *alloc ) ;
   void (*Init)(void *p ) ;
   SRes (*Code)(void *p , Byte *dest , SizeT *destLen , Byte const   *src , SizeT *srcLen ,
                int srcWasFinished , ECoderFinishMode finishMode , int *wasFinished ) ;
};
#line 150 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct _IStateCoder IStateCoder;
#line 162 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CMixCoder_48 {
   ISzAlloc *alloc ;
   Byte *buf ;
   int numCoders ;
   int finished[3] ;
   size_t pos[3] ;
   size_t size[3] ;
   UInt64 ids[4] ;
   IStateCoder coders[4] ;
};
#line 162 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CMixCoder_48 CMixCoder;
#line 182
enum __anonenum_EXzState_49 {
    XZ_STATE_STREAM_HEADER = 0,
    XZ_STATE_STREAM_INDEX = 1,
    XZ_STATE_STREAM_INDEX_CRC = 2,
    XZ_STATE_STREAM_FOOTER = 3,
    XZ_STATE_STREAM_PADDING = 4,
    XZ_STATE_BLOCK_HEADER = 5,
    XZ_STATE_BLOCK = 6,
    XZ_STATE_BLOCK_FOOTER = 7
} ;
#line 182 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef enum __anonenum_EXzState_49 EXzState;
#line 194 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
struct __anonstruct_CXzUnpacker_50 {
   EXzState state ;
   UInt32 pos ;
   unsigned int alignPos ;
   unsigned int indexPreSize ;
   CXzStreamFlags streamFlags ;
   UInt32 blockHeaderSize ;
   UInt64 packSize ;
   UInt64 unpackSize ;
   UInt64 numBlocks ;
   UInt64 indexSize ;
   UInt64 indexPos ;
   UInt64 padSize ;
   UInt64 numStreams ;
   UInt32 crc ;
   CMixCoder decoder ;
   CXzBlock block ;
   CXzCheck check ;
   CSha256 sha ;
   Byte shaDigest[32] ;
   Byte buf[1024] ;
};
#line 194 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
typedef struct __anonstruct_CXzUnpacker_50 CXzUnpacker;
#line 50 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
struct __anonstruct_CBraState_51 {
   size_t bufPos ;
   size_t bufConv ;
   size_t bufTotal ;
   UInt32 methodId ;
   int encodeMode ;
   UInt32 delta ;
   UInt32 ip ;
   UInt32 x86State ;
   Byte deltaState[256] ;
   Byte buf[1 << 14] ;
};
#line 50 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
typedef struct __anonstruct_CBraState_51 CBraState;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
#pragma pack(push,1)
#line 53
#pragma pack(pop)
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
struct CPpmd7_Context_;
#line 24 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
typedef UInt32 CPpmd7_Context_Ref;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
struct CPpmd7_Context_ {
   UInt16 NumStats ;
   UInt16 SummFreq ;
   CPpmd_State_Ref Stats ;
   CPpmd7_Context_Ref Suffix ;
};
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
typedef struct CPpmd7_Context_ CPpmd7_Context;
#line 42 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
struct __anonstruct_CPpmd7_17 {
   CPpmd7_Context *MinContext ;
   CPpmd7_Context *MaxContext ;
   CPpmd_State *FoundState ;
   unsigned int OrderFall ;
   unsigned int InitEsc ;
   unsigned int PrevSuccess ;
   unsigned int MaxOrder ;
   unsigned int HiBitsFlag ;
   Int32 RunLength ;
   Int32 InitRL ;
   UInt32 Size ;
   UInt32 GlueCount ;
   Byte *Base ;
   Byte *LoUnit ;
   Byte *HiUnit ;
   Byte *Text ;
   Byte *UnitsStart ;
   UInt32 AlignOffset ;
   Byte Indx2Units[38] ;
   Byte Units2Indx[128] ;
   CPpmd_Void_Ref FreeList[38] ;
   Byte NS2Indx[256] ;
   Byte NS2BSIndx[256] ;
   Byte HB2Flag[256] ;
   CPpmd_See DummySee ;
   CPpmd_See See[25][16] ;
   UInt16 BinSumm[128][64] ;
};
#line 42 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
typedef struct __anonstruct_CPpmd7_17 CPpmd7;
#line 100 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
struct __anonstruct_IPpmd7_RangeDec_18 {
   UInt32 (*GetThreshold)(void *p , UInt32 total ) ;
   void (*Decode)(void *p , UInt32 start , UInt32 size ) ;
   UInt32 (*DecodeBit)(void *p , UInt32 size0 ) ;
};
#line 100 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
typedef struct __anonstruct_IPpmd7_RangeDec_18 IPpmd7_RangeDec;
#line 107 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
struct __anonstruct_CPpmd7z_RangeDec_19 {
   IPpmd7_RangeDec p ;
   UInt32 Range ;
   UInt32 Code ;
   IByteIn *Stream ;
};
#line 107 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
typedef struct __anonstruct_CPpmd7z_RangeDec_19 CPpmd7z_RangeDec;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef long ptrdiff_t;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
#pragma pack(push,1)
#line 53
#pragma pack(pop)
#line 124 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
struct __anonstruct_CPpmd7z_RangeEnc_20 {
   UInt64 Low ;
   UInt32 Range ;
   Byte Cache ;
   UInt64 CacheSize ;
   IByteOut *Stream ;
};
#line 124 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
typedef struct __anonstruct_CPpmd7z_RangeEnc_20 CPpmd7z_RangeEnc;
#line 47 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
enum __anonenum_ELzma2State_17 {
    LZMA2_STATE_CONTROL = 0,
    LZMA2_STATE_UNPACK0 = 1,
    LZMA2_STATE_UNPACK1 = 2,
    LZMA2_STATE_PACK0 = 3,
    LZMA2_STATE_PACK1 = 4,
    LZMA2_STATE_PROP = 5,
    LZMA2_STATE_DATA = 6,
    LZMA2_STATE_DATA_CONT = 7,
    LZMA2_STATE_FINISHED = 8,
    LZMA2_STATE_ERROR = 9
} ;
#line 47 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
typedef enum __anonenum_ELzma2State_17 ELzma2State;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
#pragma pack(push,1)
#line 53
#pragma pack(pop)
#line 71 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
typedef UInt32 CPpmd_Byte_Ref;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
typedef CPpmd8_Context *CTX_PTR;
#line 34
struct CPpmd8_Node_;
#line 36 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
typedef UInt32 CPpmd8_Node_Ref;
#line 44 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
struct CPpmd8_Node_ {
   UInt32 Stamp ;
   CPpmd8_Node_Ref Next ;
   UInt32 NU ;
};
#line 44 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
typedef struct CPpmd8_Node_ CPpmd8_Node;
#line 479 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
enum __anonenum_ELzmaDummy_16 {
    DUMMY_ERROR = 0,
    DUMMY_LIT = 1,
    DUMMY_MATCH = 2,
    DUMMY_REP = 3
} ;
#line 479 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
typedef enum __anonenum_ELzmaDummy_16 ELzmaDummy;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd.h"
#pragma pack(push,1)
#line 53
#pragma pack(pop)
#line 32
#pragma pack(push,1)
#line 53
#pragma pack(pop)
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
typedef CPpmd7_Context *CTX_PTR___0;
#line 34
struct CPpmd7_Node_;
#line 36 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
typedef UInt32 CPpmd7_Node_Ref;
#line 44 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
struct CPpmd7_Node_ {
   UInt16 Stamp ;
   UInt16 NU ;
   CPpmd7_Node_Ref Next ;
   CPpmd7_Node_Ref Prev ;
};
#line 44 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
typedef struct CPpmd7_Node_ CPpmd7_Node;
#line 154 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
struct __anonstruct_CSeqCheckInStream_48 {
   ISeqInStream p ;
   ISeqInStream *realStream ;
   UInt64 processed ;
   CXzCheck check ;
};
#line 154 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
typedef struct __anonstruct_CSeqCheckInStream_48 CSeqCheckInStream;
#line 184 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
struct __anonstruct_CSeqSizeOutStream_49 {
   ISeqOutStream p ;
   ISeqOutStream *realStream ;
   UInt64 processed ;
};
#line 184 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
typedef struct __anonstruct_CSeqSizeOutStream_49 CSeqSizeOutStream;
#line 346 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
struct __anonstruct_CLzma2WithFilters_50 {
   CLzma2EncHandle lzma2 ;
   ISzAlloc *alloc ;
   ISzAlloc *bigAlloc ;
};
#line 346 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
typedef struct __anonstruct_CLzma2WithFilters_50 CLzma2WithFilters;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 33 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.h"
void LzmaEncProps_Init(CLzmaEncProps *p ) ;
#line 34
void LzmaEncProps_Normalize(CLzmaEncProps *p ) ;
#line 35
UInt32 LzmaEncProps_GetDictSize(CLzmaEncProps const   *props2 ) ;
#line 52
CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc ) ;
#line 53
void LzmaEnc_Destroy(CLzmaEncHandle p , ISzAlloc *alloc , ISzAlloc *allocBig ) ;
#line 54
SRes LzmaEnc_SetProps(CLzmaEncHandle pp , CLzmaEncProps const   *props2 ) ;
#line 55
SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp , Byte *props , SizeT *size ) ;
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.h"
void Lzma2EncProps_Init(CLzma2EncProps *p ) ;
#line 22
void Lzma2EncProps_Normalize(CLzma2EncProps *p ) ;
#line 38
CLzma2EncHandle Lzma2Enc_Create(ISzAlloc *alloc , ISzAlloc *allocBig ) ;
#line 39
void Lzma2Enc_Destroy(CLzma2EncHandle pp ) ;
#line 40
SRes Lzma2Enc_SetProps(CLzma2EncHandle pp , CLzma2EncProps const   *props ) ;
#line 41
Byte Lzma2Enc_WriteProperties(CLzma2EncHandle pp ) ;
#line 42
SRes Lzma2Enc_Encode(CLzma2EncHandle pp , ISeqOutStream *outStream , ISeqInStream *inStream ,
                     ICompressProgress *progress ) ;
#line 47 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
SRes MtProgress_Set(CMtProgress *p , unsigned int index___0 , UInt64 inSize , UInt64 outSize ) ;
#line 92
void MtCoder_Construct(CMtCoder *p ) ;
#line 93
void MtCoder_Destruct(CMtCoder *p ) ;
#line 94
SRes MtCoder_Code(CMtCoder *p ) ;
#line 47 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
static SRes Lzma2EncInt_Init(CLzma2EncInt *p , CLzma2EncProps const   *props ) 
{ 
  Byte propsEncoded[5] ;
  SizeT propsSize ;
  int __result__ ;
  SRes tmp ;
  int __result_____0 ;
  SRes tmp___0 ;

  {
  {
#line 50
  propsSize = (SizeT )5;
#line 51
  tmp = LzmaEnc_SetProps(p->enc, & props->lzmaProps);
#line 51
  __result__ = tmp;
  }
#line 51
  if (__result__ != 0) {
#line 51
    return (__result__);
  }
  {
#line 52
  tmp___0 = LzmaEnc_WriteProperties(p->enc, propsEncoded, & propsSize);
#line 52
  __result_____0 = tmp___0;
  }
#line 52
  if (__result_____0 != 0) {
#line 52
    return (__result_____0);
  }
#line 53
  p->srcPos = (UInt64 )0;
#line 54
  p->props = propsEncoded[0];
#line 55
  p->needInitState = 1;
#line 56
  p->needInitProp = 1;
#line 57
  return (0);
}
}
#line 60
SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp , ISeqInStream *inStream , UInt32 keepWindowSize ,
                             ISzAlloc *alloc , ISzAlloc *allocBig ) ;
#line 62
SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp , Byte const   *src , SizeT srcLen , UInt32 keepWindowSize ,
                        ISzAlloc *alloc , ISzAlloc *allocBig ) ;
#line 64
SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp , Bool reInit , Byte *dest , size_t *destLen ,
                             UInt32 desiredPackSize , UInt32 *unpackSize ) ;
#line 66
Byte const   *LzmaEnc_GetCurBuf(CLzmaEncHandle pp ) ;
#line 67
void LzmaEnc_Finish(CLzmaEncHandle pp ) ;
#line 68
void LzmaEnc_SaveState(CLzmaEncHandle pp ) ;
#line 69
void LzmaEnc_RestoreState(CLzmaEncHandle pp ) ;
#line 72 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
static SRes Lzma2EncInt_EncodeSubblock(CLzma2EncInt *p , Byte *outBuf , size_t *packSizeRes ,
                                       ISeqOutStream *outStream ) 
{ 
  size_t packSizeLimit ;
  size_t packSize ;
  UInt32 unpackSize ;
  unsigned int lzHeaderSize ;
  int tmp ;
  Bool useCopyBlock ;
  SRes res ;
  int tmp___0 ;
  size_t destPos ;
  UInt32 u ;
  UInt32 tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  Byte const   *tmp___6 ;
  size_t tmp___7 ;
  size_t destPos___0 ;
  UInt32 u___0 ;
  UInt32 pm ;
  unsigned int mode ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;

  {
#line 75
  packSizeLimit = *packSizeRes;
#line 76
  packSize = packSizeLimit;
#line 77
  unpackSize = (UInt32 )(1 << 21);
#line 78
  if (p->needInitProp) {
#line 78
    tmp = 1;
  } else {
#line 78
    tmp = 0;
  }
#line 78
  lzHeaderSize = (unsigned int )(5 + tmp);
#line 82
  *packSizeRes = (size_t )0;
#line 83
  if (packSize < (size_t )lzHeaderSize) {
#line 84
    return (7);
  }
  {
#line 85
  packSize -= (size_t )lzHeaderSize;
#line 87
  LzmaEnc_SaveState(p->enc);
#line 88
  res = LzmaEnc_CodeOneMemBlock(p->enc, p->needInitState, outBuf + lzHeaderSize, & packSize,
                                (UInt32 )(1 << 16), & unpackSize);
  }
#line 93
  if (unpackSize == 0U) {
#line 94
    return (res);
  }
#line 96
  if (res == 0) {
#line 97
    if (packSize + 2UL >= (size_t )unpackSize) {
#line 97
      tmp___0 = 1;
    } else
#line 97
    if (packSize > (size_t )(1 << 16)) {
#line 97
      tmp___0 = 1;
    } else {
#line 97
      tmp___0 = 0;
    }
#line 97
    useCopyBlock = tmp___0;
  } else {
#line 100
    if (res != 7) {
#line 101
      return (res);
    }
#line 102
    res = 0;
#line 103
    useCopyBlock = 1;
  }
#line 106
  if (useCopyBlock) {
#line 108
    destPos = (size_t )0;
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;
#line 110
      if (! (unpackSize > 0U)) {
#line 110
        goto while_break;
      }
#line 112
      if (unpackSize < (UInt32 )(1 << 16)) {
#line 112
        tmp___1 = unpackSize;
      } else {
#line 112
        tmp___1 = (UInt32 )(1 << 16);
      }
#line 112
      u = tmp___1;
#line 113
      if (packSizeLimit - destPos < (size_t )(u + 3U)) {
#line 114
        return (7);
      }
#line 115
      tmp___2 = destPos;
#line 115
      destPos ++;
#line 115
      if (p->srcPos == 0ULL) {
#line 115
        tmp___3 = 1;
      } else {
#line 115
        tmp___3 = 2;
      }
      {
#line 115
      *(outBuf + tmp___2) = (Byte )tmp___3;
#line 116
      tmp___4 = destPos;
#line 116
      destPos ++;
#line 116
      *(outBuf + tmp___4) = (Byte )((u - 1U) >> 8);
#line 117
      tmp___5 = destPos;
#line 117
      destPos ++;
#line 117
      *(outBuf + tmp___5) = (Byte )(u - 1U);
#line 118
      tmp___6 = LzmaEnc_GetCurBuf(p->enc);
#line 118
      memcpy((void */* __restrict  */)(outBuf + destPos), (void const   */* __restrict  */)(tmp___6 - unpackSize),
             (size_t )u);
#line 119
      unpackSize -= u;
#line 120
      destPos += (size_t )u;
#line 121
      p->srcPos += (UInt64 )u;
      }
#line 122
      if (outStream) {
        {
#line 124
        *packSizeRes += destPos;
#line 125
        tmp___7 = (*(outStream->Write))((void *)outStream, (void const   *)outBuf,
                                        destPos);
        }
#line 125
        if (tmp___7 != destPos) {
#line 126
          return (9);
        }
#line 127
        destPos = (size_t )0;
      } else {
#line 130
        *packSizeRes = destPos;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 133
    LzmaEnc_RestoreState(p->enc);
    }
#line 134
    return (0);
  }
#line 137
  destPos___0 = (size_t )0;
#line 138
  u___0 = unpackSize - 1U;
#line 139
  pm = (UInt32 )(packSize - 1UL);
#line 140
  if (p->srcPos == 0ULL) {
#line 140
    tmp___10 = 3;
  } else {
#line 140
    if (p->needInitState) {
#line 140
      if (p->needInitProp) {
#line 140
        tmp___8 = 2;
      } else {
#line 140
        tmp___8 = 1;
      }
#line 140
      tmp___9 = tmp___8;
    } else {
#line 140
      tmp___9 = 0;
    }
#line 140
    tmp___10 = tmp___9;
  }
#line 140
  mode = (unsigned int )tmp___10;
#line 144
  tmp___11 = destPos___0;
#line 144
  destPos___0 ++;
#line 144
  *(outBuf + tmp___11) = (Byte )(((unsigned int )(1 << 7) | (mode << 5)) | ((u___0 >> 16) & 31U));
#line 145
  tmp___12 = destPos___0;
#line 145
  destPos___0 ++;
#line 145
  *(outBuf + tmp___12) = (Byte )(u___0 >> 8);
#line 146
  tmp___13 = destPos___0;
#line 146
  destPos___0 ++;
#line 146
  *(outBuf + tmp___13) = (Byte )u___0;
#line 147
  tmp___14 = destPos___0;
#line 147
  destPos___0 ++;
#line 147
  *(outBuf + tmp___14) = (Byte )(pm >> 8);
#line 148
  tmp___15 = destPos___0;
#line 148
  destPos___0 ++;
#line 148
  *(outBuf + tmp___15) = (Byte )pm;
#line 150
  if (p->needInitProp) {
#line 151
    tmp___16 = destPos___0;
#line 151
    destPos___0 ++;
#line 151
    *(outBuf + tmp___16) = p->props;
  }
#line 153
  p->needInitProp = 0;
#line 154
  p->needInitState = 0;
#line 155
  destPos___0 += packSize;
#line 156
  p->srcPos += (UInt64 )unpackSize;
#line 158
  if (outStream) {
    {
#line 159
    tmp___17 = (*(outStream->Write))((void *)outStream, (void const   *)outBuf, destPos___0);
    }
#line 159
    if (tmp___17 != destPos___0) {
#line 160
      return (9);
    }
  }
#line 161
  *packSizeRes = destPos___0;
#line 162
  return (0);
}
}
#line 168 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
void Lzma2EncProps_Init(CLzma2EncProps *p ) 
{ 


  {
  {
#line 170
  LzmaEncProps_Init(& p->lzmaProps);
#line 171
  p->numTotalThreads = -1;
#line 172
  p->numBlockThreads = -1;
#line 173
  p->blockSize = (size_t )0;
  }
#line 174
  return;
}
}
#line 176 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
void Lzma2EncProps_Normalize(CLzma2EncProps *p ) 
{ 
  int t1 ;
  int t1n ;
  int t2 ;
  int t3 ;
  CLzmaEncProps lzmaProps ;
  UInt32 dictSize ;
  UInt64 blockSize ;
  UInt32 kMinSize ;
  UInt32 kMaxSize ;

  {
  {
#line 180
  lzmaProps = p->lzmaProps;
#line 181
  LzmaEncProps_Normalize(& lzmaProps);
#line 182
  t1n = lzmaProps.numThreads;
#line 185
  t1 = p->lzmaProps.numThreads;
#line 186
  t2 = p->numBlockThreads;
#line 187
  t3 = p->numTotalThreads;
  }
#line 189
  if (t2 > 32) {
#line 190
    t2 = 32;
  }
#line 192
  if (t3 <= 0) {
#line 194
    if (t2 <= 0) {
#line 195
      t2 = 1;
    }
#line 196
    t3 = t1n * t2;
  } else
#line 198
  if (t2 <= 0) {
#line 200
    t2 = t3 / t1n;
#line 201
    if (t2 == 0) {
#line 203
      t1 = 1;
#line 204
      t2 = t3;
    }
#line 206
    if (t2 > 32) {
#line 207
      t2 = 32;
    }
  } else
#line 209
  if (t1 <= 0) {
#line 211
    t1 = t3 / t2;
#line 212
    if (t1 == 0) {
#line 213
      t1 = 1;
    }
  } else {
#line 216
    t3 = t1n * t2;
  }
  {
#line 218
  p->lzmaProps.numThreads = t1;
#line 219
  p->numBlockThreads = t2;
#line 220
  p->numTotalThreads = t3;
#line 221
  LzmaEncProps_Normalize(& p->lzmaProps);
  }
#line 223
  if (p->blockSize == 0UL) {
#line 225
    dictSize = p->lzmaProps.dictSize;
#line 226
    blockSize = (UInt64 )dictSize << 2;
#line 227
    kMinSize = 1U << 20;
#line 228
    kMaxSize = 1U << 28;
#line 229
    if (blockSize < (UInt64 )kMinSize) {
#line 229
      blockSize = (UInt64 )kMinSize;
    }
#line 230
    if (blockSize > (UInt64 )kMaxSize) {
#line 230
      blockSize = (UInt64 )kMaxSize;
    }
#line 231
    if (blockSize < (UInt64 )dictSize) {
#line 231
      blockSize = (UInt64 )dictSize;
    }
#line 232
    p->blockSize = (size_t )blockSize;
  }
#line 234
  return;
}
}
#line 236 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
static SRes Progress(ICompressProgress *p , UInt64 inSize , UInt64 outSize ) 
{ 
  int tmp___0 ;
  SRes tmp___1 ;

  {
#line 238
  if (p) {
    {
#line 238
    tmp___1 = (*(p->Progress))((void *)p, inSize, outSize);
    }
#line 238
    if (tmp___1 != 0) {
#line 238
      tmp___0 = 10;
    } else {
#line 238
      tmp___0 = 0;
    }
  } else {
#line 238
    tmp___0 = 0;
  }
#line 238
  return (tmp___0);
}
}
#line 264 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
static SRes Lzma2Enc_EncodeMt1(CLzma2EncInt *p , CLzma2Enc *mainEncoder , ISeqOutStream *outStream ,
                               ISeqInStream *inStream , ICompressProgress *progress ) 
{ 
  UInt64 packTotal ;
  SRes res ;
  void *tmp ;
  int __result__ ;
  SRes tmp___0 ;
  int __result_____0 ;
  SRes tmp___1 ;
  size_t packSize ;
  Byte b ;
  size_t tmp___2 ;

  {
#line 267
  packTotal = (UInt64 )0;
#line 268
  res = 0;
#line 270
  if ((unsigned long )mainEncoder->outBuf == (unsigned long )((Byte *)0)) {
    {
#line 272
    tmp = (*((mainEncoder->alloc)->Alloc))((void *)mainEncoder->alloc, (size_t )((1 << 16) + 16));
#line 272
    mainEncoder->outBuf = (Byte *)tmp;
    }
#line 273
    if ((unsigned long )mainEncoder->outBuf == (unsigned long )((Byte *)0)) {
#line 274
      return (2);
    }
  }
  {
#line 276
  tmp___0 = Lzma2EncInt_Init(p, (CLzma2EncProps const   *)(& mainEncoder->props));
#line 276
  __result__ = tmp___0;
  }
#line 276
  if (__result__ != 0) {
#line 276
    return (__result__);
  }
  {
#line 277
  tmp___1 = LzmaEnc_PrepareForLzma2(p->enc, inStream, (UInt32 )(1 << 21), mainEncoder->alloc,
                                    mainEncoder->allocBig);
#line 277
  __result_____0 = tmp___1;
  }
#line 277
  if (__result_____0 != 0) {
#line 277
    return (__result_____0);
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 281
    packSize = (size_t )((1 << 16) + 16);
#line 282
    res = Lzma2EncInt_EncodeSubblock(p, mainEncoder->outBuf, & packSize, outStream);
    }
#line 283
    if (res != 0) {
#line 284
      goto while_break;
    }
    {
#line 285
    packTotal += (UInt64 )packSize;
#line 286
    res = Progress(progress, p->srcPos, packTotal);
    }
#line 287
    if (res != 0) {
#line 288
      goto while_break;
    }
#line 289
    if (packSize == 0UL) {
#line 290
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  LzmaEnc_Finish(p->enc);
  }
#line 293
  if (res == 0) {
    {
#line 295
    b = (Byte )0;
#line 296
    tmp___2 = (*(outStream->Write))((void *)outStream, (void const   *)(& b), (size_t )1);
    }
#line 296
    if (tmp___2 != 1UL) {
#line 297
      return (9);
    }
  }
#line 299
  return (res);
}
}
#line 310 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
static SRes MtCallbackImp_Code(void *pp , unsigned int index___0 , Byte *dest , size_t *destSize ,
                               Byte const   *src , size_t srcSize , int finished ) 
{ 
  CMtCallbackImp *imp ;
  CLzma2Enc *mainEncoder ;
  CLzma2EncInt *p ;
  SRes res ;
  size_t destLim ;
  int __result__ ;
  SRes tmp ;
  int __result_____0 ;
  SRes tmp___0 ;
  size_t packSize ;
  SRes tmp___1 ;
  size_t tmp___2 ;

  {
#line 313
  imp = (CMtCallbackImp *)pp;
#line 314
  mainEncoder = imp->lzma2Enc;
#line 315
  p = & mainEncoder->coders[index___0];
#line 317
  res = 0;
#line 319
  destLim = *destSize;
#line 320
  *destSize = (size_t )0;
#line 322
  if (srcSize != 0UL) {
    {
#line 324
    tmp = Lzma2EncInt_Init(p, (CLzma2EncProps const   *)(& mainEncoder->props));
#line 324
    __result__ = tmp;
    }
#line 324
    if (__result__ != 0) {
#line 324
      return (__result__);
    }
    {
#line 326
    tmp___0 = LzmaEnc_MemPrepare(p->enc, src, srcSize, (UInt32 )(1 << 21), mainEncoder->alloc,
                                 mainEncoder->allocBig);
#line 326
    __result_____0 = tmp___0;
    }
#line 326
    if (__result_____0 != 0) {
#line 326
      return (__result_____0);
    }
    {
#line 329
    while (1) {
      while_continue: /* CIL Label */ ;
#line 329
      if (! (p->srcPos < (UInt64 )srcSize)) {
#line 329
        goto while_break;
      }
      {
#line 331
      packSize = destLim - *destSize;
#line 332
      res = Lzma2EncInt_EncodeSubblock(p, dest + *destSize, & packSize, (ISeqOutStream *)((void *)0));
      }
#line 333
      if (res != 0) {
#line 334
        goto while_break;
      }
#line 335
      *destSize += packSize;
#line 337
      if (packSize == 0UL) {
#line 339
        res = 11;
#line 340
        goto while_break;
      }
      {
#line 343
      tmp___1 = MtProgress_Set(& mainEncoder->mtCoder.mtProgress, index___0, p->srcPos,
                               (UInt64 )*destSize);
      }
#line 343
      if (tmp___1 != 0) {
#line 345
        res = 10;
#line 346
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 349
    LzmaEnc_Finish(p->enc);
    }
#line 350
    if (res != 0) {
#line 351
      return (res);
    }
  }
#line 353
  if (finished) {
#line 355
    if (*destSize == destLim) {
#line 356
      return (7);
    }
#line 357
    tmp___2 = *destSize;
#line 357
    (*destSize) ++;
#line 357
    *(dest + tmp___2) = (Byte )0;
  }
#line 360
  return (res);
}
}
#line 367 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
CLzma2EncHandle Lzma2Enc_Create(ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 
  CLzma2Enc *p ;
  void *tmp ;
  unsigned int i ;

  {
  {
#line 369
  tmp = (*(alloc->Alloc))((void *)alloc, sizeof(CLzma2Enc ));
#line 369
  p = (CLzma2Enc *)tmp;
  }
#line 370
  if ((unsigned long )p == (unsigned long )((CLzma2Enc *)0)) {
#line 371
    return ((void *)0);
  }
  {
#line 372
  Lzma2EncProps_Init(& p->props);
#line 373
  Lzma2EncProps_Normalize(& p->props);
#line 374
  p->outBuf = (Byte *)0;
#line 375
  p->alloc = alloc;
#line 376
  p->allocBig = allocBig;
#line 379
  i = 0U;
  }
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (i < 32U)) {
#line 379
      goto while_break;
    }
#line 380
    p->coders[i].enc = (CLzmaEncHandle )0;
#line 379
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  MtCoder_Construct(& p->mtCoder);
  }
#line 386
  return ((CLzma2EncHandle )p);
}
}
#line 389 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
void Lzma2Enc_Destroy(CLzma2EncHandle pp ) 
{ 
  CLzma2Enc *p ;
  unsigned int i ;
  CLzma2EncInt *t ;

  {
#line 391
  p = (CLzma2Enc *)pp;
#line 393
  i = 0U;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i < 32U)) {
#line 393
      goto while_break;
    }
#line 395
    t = & p->coders[i];
#line 396
    if (t->enc) {
      {
#line 398
      LzmaEnc_Destroy(t->enc, p->alloc, p->allocBig);
#line 399
      t->enc = (CLzmaEncHandle )0;
      }
    }
#line 393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  MtCoder_Destruct(& p->mtCoder);
#line 407
  (*((p->alloc)->Free))((void *)p->alloc, (void *)p->outBuf);
#line 408
  (*((p->alloc)->Free))((void *)p->alloc, pp);
  }
#line 409
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
SRes Lzma2Enc_SetProps(CLzma2EncHandle pp , CLzma2EncProps const   *props ) 
{ 
  CLzma2Enc *p ;
  CLzmaEncProps lzmaProps ;

  {
  {
#line 413
  p = (CLzma2Enc *)pp;
#line 414
  lzmaProps = props->lzmaProps;
#line 415
  LzmaEncProps_Normalize(& lzmaProps);
  }
#line 416
  if (lzmaProps.lc + lzmaProps.lp > 4) {
#line 417
    return (5);
  }
  {
#line 418
  p->props = (CLzma2EncProps )*props;
#line 419
  Lzma2EncProps_Normalize(& p->props);
  }
#line 420
  return (0);
}
}
#line 423 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
Byte Lzma2Enc_WriteProperties(CLzma2EncHandle pp ) 
{ 
  CLzma2Enc *p ;
  unsigned int i ;
  UInt32 dicSize ;
  UInt32 tmp ;

  {
  {
#line 425
  p = (CLzma2Enc *)pp;
#line 427
  tmp = LzmaEncProps_GetDictSize((CLzmaEncProps const   *)(& p->props.lzmaProps));
#line 427
  dicSize = tmp;
#line 428
  i = 0U;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < 40U)) {
#line 428
      goto while_break;
    }
#line 429
    if (dicSize <= (2U | (i & 1U)) << (i / 2U + 11U)) {
#line 430
      goto while_break;
    }
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return ((Byte )i);
}
}
#line 434 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Enc.c"
SRes Lzma2Enc_Encode(CLzma2EncHandle pp , ISeqOutStream *outStream , ISeqInStream *inStream ,
                     ICompressProgress *progress ) 
{ 
  CLzma2Enc *p ;
  int i ;
  CLzma2EncInt *t ;
  SRes tmp ;
  CMtCallbackImp mtCallback ;
  SRes tmp___0 ;

  {
#line 437
  p = (CLzma2Enc *)pp;
#line 440
  i = 0;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (i < p->props.numBlockThreads)) {
#line 440
      goto while_break;
    }
#line 442
    t = & p->coders[i];
#line 443
    if ((unsigned long )t->enc == (unsigned long )((void *)0)) {
      {
#line 445
      t->enc = LzmaEnc_Create(p->alloc);
      }
#line 446
      if ((unsigned long )t->enc == (unsigned long )((void *)0)) {
#line 447
        return (2);
      }
    }
#line 440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  if (p->props.numBlockThreads <= 1) {
    {
#line 454
    tmp = Lzma2Enc_EncodeMt1(& p->coders[0], p, outStream, inStream, progress);
    }
#line 454
    return (tmp);
  }
  {
#line 461
  mtCallback.funcTable.Code = & MtCallbackImp_Code;
#line 462
  mtCallback.lzma2Enc = p;
#line 464
  p->mtCoder.progress = progress;
#line 465
  p->mtCoder.inStream = inStream;
#line 466
  p->mtCoder.outStream = outStream;
#line 467
  p->mtCoder.alloc = p->alloc;
#line 468
  p->mtCoder.mtCallback = & mtCallback.funcTable;
#line 470
  p->mtCoder.blockSize = p->props.blockSize;
#line 471
  p->mtCoder.destBlockSize = (p->props.blockSize + (p->props.blockSize >> 10)) + 16UL;
#line 472
  p->mtCoder.numThreads = (unsigned int )p->props.numBlockThreads;
#line 474
  tmp___0 = MtCoder_Code(& p->mtCoder);
  }
#line 474
  return (tmp___0);
}
}
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 282
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th ) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 301
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
#line 310
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                                  int __detachstate ) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 984
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
#line 992
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 39 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.h"
WRes Thread_Create(CThread *thread , THREAD_FUNC_RET_TYPE (*startAddress)(void * ) ,
                   LPVOID parameter ) ;
#line 40
WRes Thread_Wait(CThread *thread ) ;
#line 41
WRes Thread_Close(CThread *thread ) ;
#line 64
WRes ManualResetEvent_Create(CManualResetEvent *p , int initialSignaled ) ;
#line 65
WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p ) ;
#line 66
WRes AutoResetEvent_Create(CAutoResetEvent *p , int initialSignaled ) ;
#line 67
WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p ) ;
#line 68
WRes Event_Set(CEvent *p ) ;
#line 69
WRes Event_Reset(CEvent *p ) ;
#line 70
WRes Event_Wait(CEvent *p ) ;
#line 71
WRes Event_Close(CEvent *p ) ;
#line 91
WRes Semaphore_Create(CSemaphore *p , UInt32 initiallyCount , UInt32 maxCount ) ;
#line 92
WRes Semaphore_ReleaseN(CSemaphore *p , UInt32 releaseCount ) ;
#line 94
WRes Semaphore_Wait(CSemaphore *p ) ;
#line 95
WRes Semaphore_Close(CSemaphore *p ) ;
#line 105
WRes CriticalSection_Init(CCriticalSection *lpCriticalSection ) ;
#line 188 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Thread_Create(CThread *thread , THREAD_FUNC_RET_TYPE (*startAddress)(void * ) ,
                   LPVOID parameter ) 
{ 
  pthread_attr_t attr ;
  int ret ;

  {
  {
#line 193
  thread->_created = 0;
#line 195
  ret = pthread_attr_init(& attr);
  }
#line 196
  if (ret) {
#line 196
    return (ret);
  }
  {
#line 198
  ret = pthread_attr_setdetachstate(& attr, 0);
  }
#line 199
  if (ret) {
#line 199
    return (ret);
  }
  {
#line 201
  ret = pthread_create((pthread_t */* __restrict  */)(& thread->_tid), (pthread_attr_t const   */* __restrict  */)(& attr),
                       (void *(*)(void * ))startAddress, (void */* __restrict  */)parameter);
#line 203
  pthread_attr_destroy(& attr);
  }
#line 205
  if (ret) {
#line 205
    return (ret);
  }
#line 207
  thread->_created = 1;
#line 209
  return (0);
}
}
#line 212 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Thread_Wait(CThread *thread ) 
{ 
  void *thread_return ;
  int ret ;

  {
#line 217
  if (thread->_created == 0) {
#line 218
    return (22);
  }
  {
#line 220
  ret = pthread_join(thread->_tid, & thread_return);
#line 221
  thread->_created = 0;
  }
#line 223
  return (ret);
}
}
#line 226 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Thread_Close(CThread *thread ) 
{ 


  {
#line 228
  if (! thread->_created) {
#line 228
    return (0);
  }
  {
#line 230
  pthread_detach(thread->_tid);
#line 231
  thread->_tid = (pthread_t )0;
#line 232
  thread->_created = 0;
  }
#line 233
  return (0);
}
}
#line 463 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Event_Create(CEvent *p , BOOL manualReset , int initialSignaled ) 
{ 


  {
  {
#line 465
  pthread_mutex_init(& p->_mutex, (pthread_mutexattr_t const   *)0);
#line 466
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& p->_cond), (pthread_condattr_t const   */* __restrict  */)0);
#line 467
  p->_manual_reset = manualReset;
  }
#line 468
  if (initialSignaled) {
#line 468
    p->_state = 1;
  } else {
#line 468
    p->_state = 0;
  }
#line 469
  p->_created = 1;
#line 470
  return (0);
}
}
#line 473 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Event_Set(CEvent *p ) 
{ 


  {
  {
#line 474
  pthread_mutex_lock(& p->_mutex);
#line 475
  p->_state = 1;
#line 476
  pthread_cond_broadcast(& p->_cond);
#line 477
  pthread_mutex_unlock(& p->_mutex);
  }
#line 478
  return (0);
}
}
#line 481 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Event_Reset(CEvent *p ) 
{ 


  {
  {
#line 482
  pthread_mutex_lock(& p->_mutex);
#line 483
  p->_state = 0;
#line 484
  pthread_mutex_unlock(& p->_mutex);
  }
#line 485
  return (0);
}
}
#line 488 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Event_Wait(CEvent *p ) 
{ 


  {
  {
#line 489
  pthread_mutex_lock(& p->_mutex);
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (p->_state == 0)) {
#line 490
      goto while_break;
    }
    {
#line 492
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& p->_cond), (pthread_mutex_t */* __restrict  */)(& p->_mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (p->_manual_reset == 0) {
#line 496
    p->_state = 0;
  }
  {
#line 498
  pthread_mutex_unlock(& p->_mutex);
  }
#line 499
  return (0);
}
}
#line 502 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Event_Close(CEvent *p ) 
{ 


  {
#line 503
  if (p->_created) {
    {
#line 505
    p->_created = 0;
#line 506
    pthread_mutex_destroy(& p->_mutex);
#line 507
    pthread_cond_destroy(& p->_cond);
    }
  }
#line 509
  return (0);
}
}
#line 512 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Semaphore_Create(CSemaphore *p , UInt32 initiallyCount , UInt32 maxCount ) 
{ 


  {
  {
#line 514
  pthread_mutex_init(& p->_mutex, (pthread_mutexattr_t const   *)0);
#line 515
  pthread_cond_init((pthread_cond_t */* __restrict  */)(& p->_cond), (pthread_condattr_t const   */* __restrict  */)0);
#line 516
  p->_count = initiallyCount;
#line 517
  p->_maxCount = maxCount;
#line 518
  p->_created = 1;
  }
#line 519
  return (0);
}
}
#line 522 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Semaphore_ReleaseN(CSemaphore *p , UInt32 releaseCount ) 
{ 
  UInt32 newCount ;

  {
#line 526
  if (releaseCount < 1U) {
#line 526
    return (22);
  }
  {
#line 528
  pthread_mutex_lock(& p->_mutex);
#line 530
  newCount = p->_count + releaseCount;
  }
#line 531
  if (newCount > p->_maxCount) {
    {
#line 533
    pthread_mutex_unlock(& p->_mutex);
    }
#line 534
    return (22);
  }
  {
#line 536
  p->_count = newCount;
#line 537
  pthread_cond_broadcast(& p->_cond);
#line 538
  pthread_mutex_unlock(& p->_mutex);
  }
#line 539
  return (0);
}
}
#line 542 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Semaphore_Wait(CSemaphore *p ) 
{ 


  {
  {
#line 543
  pthread_mutex_lock(& p->_mutex);
  }
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! (p->_count < 1U)) {
#line 544
      goto while_break;
    }
    {
#line 546
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& p->_cond), (pthread_mutex_t */* __restrict  */)(& p->_mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 548
  (p->_count) --;
#line 549
  pthread_mutex_unlock(& p->_mutex);
  }
#line 550
  return (0);
}
}
#line 553 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes Semaphore_Close(CSemaphore *p ) 
{ 


  {
#line 554
  if (p->_created) {
    {
#line 556
    p->_created = 0;
#line 557
    pthread_mutex_destroy(& p->_mutex);
#line 558
    pthread_cond_destroy(& p->_cond);
    }
  }
#line 560
  return (0);
}
}
#line 563 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes CriticalSection_Init(CCriticalSection *lpCriticalSection ) 
{ 
  int tmp ;

  {
  {
#line 565
  tmp = pthread_mutex_init(& lpCriticalSection->_mutex, (pthread_mutexattr_t const   *)0);
  }
#line 565
  return (tmp);
}
}
#line 572 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes ManualResetEvent_Create(CManualResetEvent *p , int initialSignaled ) 
{ 
  WRes tmp ;

  {
  {
#line 573
  tmp = Event_Create(p, 1, initialSignaled);
  }
#line 573
  return (tmp);
}
}
#line 575 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p ) 
{ 
  WRes tmp ;

  {
  {
#line 576
  tmp = ManualResetEvent_Create(p, 0);
  }
#line 576
  return (tmp);
}
}
#line 578 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes AutoResetEvent_Create(CAutoResetEvent *p , int initialSignaled ) 
{ 
  WRes tmp ;

  {
  {
#line 579
  tmp = Event_Create(p, 0, initialSignaled);
  }
#line 579
  return (tmp);
}
}
#line 580 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Threads.c"
WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p ) 
{ 
  WRes tmp ;

  {
  {
#line 581
  tmp = AutoResetEvent_Create(p, 0);
  }
#line 581
  return (tmp);
}
}
#line 20 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.h"
void Sha256_Init(CSha256 *p ) ;
#line 21
void Sha256_Update(CSha256 *p , Byte const   *data , size_t size ) ;
#line 22
void Sha256_Final(CSha256 *p , Byte *digest ) ;
#line 12 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.c"
void Sha256_Init(CSha256 *p ) 
{ 


  {
#line 14
  p->state[0] = (UInt32 )1779033703;
#line 15
  p->state[1] = 3144134277U;
#line 16
  p->state[2] = (UInt32 )1013904242;
#line 17
  p->state[3] = 2773480762U;
#line 18
  p->state[4] = (UInt32 )1359893119;
#line 19
  p->state[5] = 2600822924U;
#line 20
  p->state[6] = (UInt32 )528734635;
#line 21
  p->state[7] = (UInt32 )1541459225;
#line 22
  p->count = (UInt64 )0;
#line 23
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.c"
static UInt32 const   K[64]  = 
#line 74
  {      (UInt32 const   )1116352408,      (UInt32 const   )1899447441,      (UInt32 const   )3049323471U,      (UInt32 const   )3921009573U, 
        (UInt32 const   )961987163,      (UInt32 const   )1508970993,      (UInt32 const   )2453635748U,      (UInt32 const   )2870763221U, 
        (UInt32 const   )3624381080U,      (UInt32 const   )310598401,      (UInt32 const   )607225278,      (UInt32 const   )1426881987, 
        (UInt32 const   )1925078388,      (UInt32 const   )2162078206U,      (UInt32 const   )2614888103U,      (UInt32 const   )3248222580U, 
        (UInt32 const   )3835390401U,      (UInt32 const   )4022224774U,      (UInt32 const   )264347078,      (UInt32 const   )604807628, 
        (UInt32 const   )770255983,      (UInt32 const   )1249150122,      (UInt32 const   )1555081692,      (UInt32 const   )1996064986, 
        (UInt32 const   )2554220882U,      (UInt32 const   )2821834349U,      (UInt32 const   )2952996808U,      (UInt32 const   )3210313671U, 
        (UInt32 const   )3336571891U,      (UInt32 const   )3584528711U,      (UInt32 const   )113926993,      (UInt32 const   )338241895, 
        (UInt32 const   )666307205,      (UInt32 const   )773529912,      (UInt32 const   )1294757372,      (UInt32 const   )1396182291, 
        (UInt32 const   )1695183700,      (UInt32 const   )1986661051,      (UInt32 const   )2177026350U,      (UInt32 const   )2456956037U, 
        (UInt32 const   )2730485921U,      (UInt32 const   )2820302411U,      (UInt32 const   )3259730800U,      (UInt32 const   )3345764771U, 
        (UInt32 const   )3516065817U,      (UInt32 const   )3600352804U,      (UInt32 const   )4094571909U,      (UInt32 const   )275423344, 
        (UInt32 const   )430227734,      (UInt32 const   )506948616,      (UInt32 const   )659060556,      (UInt32 const   )883997877, 
        (UInt32 const   )958139571,      (UInt32 const   )1322822218,      (UInt32 const   )1537002063,      (UInt32 const   )1747873779, 
        (UInt32 const   )1955562222,      (UInt32 const   )2024104815,      (UInt32 const   )2227730452U,      (UInt32 const   )2361852424U, 
        (UInt32 const   )2428436474U,      (UInt32 const   )2756734187U,      (UInt32 const   )3204031479U,      (UInt32 const   )3329325298U};
#line 93 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.c"
static void Sha256_Transform(UInt32 *state , UInt32 const   *data ) 
{ 
  UInt32 W[16] ;
  unsigned int j ;
  UInt32 T___0[8] ;
  unsigned int i ;
  UInt32 tmp ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;

  {
#line 109
  j = 0U;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (j < 8U)) {
#line 109
      goto while_break;
    }
#line 110
    T___0[j] = *(state + j);
#line 109
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  j = 0U;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (j < 64U)) {
#line 113
      goto while_break___0;
    }
#line 119
    i = 0U;
    {
#line 119
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 119
      if (! (i < 16U)) {
#line 119
        goto while_break___1;
      }
#line 119
      if (j) {
#line 119
        tmp = W[i & 15U] + ((((((W[(i - 2U) & 15U] >> 17) | (W[(i - 2U) & 15U] << 15)) ^ ((W[(i - 2U) & 15U] >> 19) | (W[(i - 2U) & 15U] << 13))) ^ (W[(i - 2U) & 15U] >> 10)) + W[(i - 7U) & 15U]) + ((((W[(i - 15U) & 15U] >> 7) | (W[(i - 15U) & 15U] << 25)) ^ ((W[(i - 15U) & 15U] >> 18) | (W[(i - 15U) & 15U] << 14))) ^ (W[(i - 15U) & 15U] >> 3)));
#line 119
        W[i & 15U] = tmp;
#line 119
        tmp___1 = tmp;
      } else {
#line 119
        tmp___0 = (UInt32 )*(data + i);
#line 119
        W[i] = tmp___0;
#line 119
        tmp___1 = tmp___0;
      }
#line 119
      T___0[(7U - i) & 7U] += ((((((T___0[(4U - i) & 7U] >> 6) | (T___0[(4U - i) & 7U] << 26)) ^ ((T___0[(4U - i) & 7U] >> 11) | (T___0[(4U - i) & 7U] << 21))) ^ ((T___0[(4U - i) & 7U] >> 25) | (T___0[(4U - i) & 7U] << 7))) + (T___0[(6U - i) & 7U] ^ (T___0[(4U - i) & 7U] & (T___0[(5U - i) & 7U] ^ T___0[(6U - i) & 7U])))) + (unsigned int )K[i + j]) + tmp___1;
#line 119
      T___0[(3U - i) & 7U] += T___0[(7U - i) & 7U];
#line 119
      T___0[(7U - i) & 7U] += ((((T___0[(0U - i) & 7U] >> 2) | (T___0[(0U - i) & 7U] << 30)) ^ ((T___0[(0U - i) & 7U] >> 13) | (T___0[(0U - i) & 7U] << 19))) ^ ((T___0[(0U - i) & 7U] >> 22) | (T___0[(0U - i) & 7U] << 10))) + ((T___0[(0U - i) & 7U] & T___0[(1U - i) & 7U]) | (T___0[(2U - i) & 7U] & (T___0[(0U - i) & 7U] | T___0[(1U - i) & 7U])));
#line 119
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 113
    j += 16U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  j = 0U;
  {
#line 133
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 133
    if (! (j < 8U)) {
#line 133
      goto while_break___2;
    }
#line 134
    *(state + j) += T___0[j];
#line 133
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 140
  return;
}
}
#line 147 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.c"
static void Sha256_WriteByteBlock(CSha256 *p ) 
{ 
  UInt32 data32[16] ;
  unsigned int i ;

  {
#line 151
  i = 0U;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < 16U)) {
#line 151
      goto while_break;
    }
#line 152
    data32[i] = ((((UInt32 )p->buffer[i * 4U] << 24) + ((UInt32 )p->buffer[i * 4U + 1U] << 16)) + ((UInt32 )p->buffer[i * 4U + 2U] << 8)) + (UInt32 )p->buffer[i * 4U + 3U];
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  Sha256_Transform(p->state, (UInt32 const   *)(data32));
  }
#line 158
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.c"
void Sha256_Update(CSha256 *p , Byte const   *data , size_t size ) 
{ 
  UInt32 curBufferPos ;
  UInt32 tmp ;
  Byte const   *tmp___0 ;

  {
#line 162
  curBufferPos = (UInt32 )p->count & 63U;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (size > 0UL)) {
#line 163
      goto while_break;
    }
#line 165
    tmp = curBufferPos;
#line 165
    curBufferPos ++;
#line 165
    tmp___0 = data;
#line 165
    data ++;
#line 165
    p->buffer[tmp] = (Byte )*tmp___0;
#line 166
    (p->count) ++;
#line 167
    size --;
#line 168
    if (curBufferPos == 64U) {
      {
#line 170
      curBufferPos = (UInt32 )0;
#line 171
      Sha256_WriteByteBlock(p);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 176 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sha256.c"
void Sha256_Final(CSha256 *p , Byte *digest ) 
{ 
  UInt64 lenInBits ;
  UInt32 curBufferPos ;
  unsigned int i ;
  UInt32 tmp ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;
  Byte *tmp___2 ;
  Byte *tmp___3 ;
  Byte *tmp___4 ;
  Byte *tmp___5 ;

  {
#line 178
  lenInBits = p->count << 3;
#line 179
  curBufferPos = (UInt32 )p->count & 63U;
#line 181
  tmp = curBufferPos;
#line 181
  curBufferPos ++;
#line 181
  p->buffer[tmp] = (Byte )128;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (curBufferPos != 56U)) {
#line 182
      goto while_break;
    }
#line 184
    curBufferPos &= 63U;
#line 185
    if (curBufferPos == 0U) {
      {
#line 186
      Sha256_WriteByteBlock(p);
      }
    }
#line 187
    tmp___0 = curBufferPos;
#line 187
    curBufferPos ++;
#line 187
    p->buffer[tmp___0] = (Byte )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  i = 0U;
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 189
    if (! (i < 8U)) {
#line 189
      goto while_break___0;
    }
#line 191
    tmp___1 = curBufferPos;
#line 191
    curBufferPos ++;
#line 191
    p->buffer[tmp___1] = (Byte )(lenInBits >> 56);
#line 192
    lenInBits <<= 8;
#line 189
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 194
  Sha256_WriteByteBlock(p);
#line 196
  i = 0U;
  }
  {
#line 196
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 196
    if (! (i < 8U)) {
#line 196
      goto while_break___1;
    }
#line 198
    tmp___2 = digest;
#line 198
    digest ++;
#line 198
    *tmp___2 = (Byte )(p->state[i] >> 24);
#line 199
    tmp___3 = digest;
#line 199
    digest ++;
#line 199
    *tmp___3 = (Byte )(p->state[i] >> 16);
#line 200
    tmp___4 = digest;
#line 200
    digest ++;
#line 200
    *tmp___4 = (Byte )(p->state[i] >> 8);
#line 201
    tmp___5 = digest;
#line 201
    digest ++;
#line 201
    *tmp___5 = (Byte )p->state[i];
#line 196
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 203
  Sha256_Init(p);
  }
#line 204
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sort.h"
void HeapSort(UInt32 *p , UInt32 size ) ;
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Sort.c"
void HeapSort(UInt32 *p , UInt32 size ) 
{ 
  UInt32 i ;
  UInt32 temp ;
  UInt32 k ;
  UInt32 s ;
  UInt32 temp___0 ;
  UInt32 k___0 ;
  int tmp ;
  UInt32 tmp___0 ;
  UInt32 s___0 ;
  UInt32 temp___1 ;

  {
#line 17
  if (size <= 1U) {
#line 18
    return;
  }
#line 19
  p --;
#line 21
  i = size / 2U;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    temp = *(p + i);
#line 25
    k = i;
    {
#line 26
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 26
      s = k << 1;
#line 26
      if (s > size) {
#line 26
        goto while_break___0;
      }
#line 26
      if (s < size) {
#line 26
        if (*(p + (s + 1U)) > *(p + s)) {
#line 26
          s ++;
        }
      }
#line 26
      if (temp >= *(p + s)) {
#line 26
        goto while_break___0;
      }
#line 26
      *(p + k) = *(p + s);
#line 26
      k = s;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 26
    *(p + k) = temp;
#line 22
    i --;
#line 22
    if (! (i != 0U)) {
#line 22
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 40
    if (! (size > 3U)) {
#line 40
      goto while_break___1;
    }
#line 42
    temp___0 = *(p + size);
#line 43
    if (*(p + 3) > *(p + 2)) {
#line 43
      tmp = 3;
    } else {
#line 43
      tmp = 2;
    }
#line 43
    k___0 = (UInt32 )tmp;
#line 44
    tmp___0 = size;
#line 44
    size --;
#line 44
    *(p + tmp___0) = *(p + 1);
#line 45
    *(p + 1) = *(p + k___0);
    {
#line 46
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 46
      s___0 = k___0 << 1;
#line 46
      if (s___0 > size) {
#line 46
        goto while_break___2;
      }
#line 46
      if (s___0 < size) {
#line 46
        if (*(p + (s___0 + 1U)) > *(p + s___0)) {
#line 46
          s___0 ++;
        }
      }
#line 46
      if (temp___0 >= *(p + s___0)) {
#line 46
        goto while_break___2;
      }
#line 46
      *(p + k___0) = *(p + s___0);
#line 46
      k___0 = s___0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 46
    *(p + k___0) = temp___0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 49
  temp___1 = *(p + size);
#line 50
  *(p + size) = *(p + 1);
#line 51
  if (size > 2U) {
#line 51
    if (*(p + 2) < temp___1) {
#line 53
      *(p + 1) = *(p + 2);
#line 54
      *(p + 2) = temp___1;
    } else {
#line 57
      *(p + 1) = temp___1;
    }
  } else {
#line 57
    *(p + 1) = temp___1;
  }
#line 59
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.h"
SRes LzmaEnc_Encode(CLzmaEncHandle pp , ISeqOutStream *outStream , ISeqInStream *inStream ,
                    ICompressProgress *progress , ISzAlloc *alloc , ISzAlloc *allocBig ) ;
#line 58
SRes LzmaEnc_MemEncode(CLzmaEncHandle pp , Byte *dest , SizeT *destLen , Byte const   *src ,
                       SizeT srcLen , int writeEndMark , ICompressProgress *progress ,
                       ISzAlloc *alloc , ISzAlloc *allocBig ) ;
#line 72
SRes LzmaEncode(Byte *dest , SizeT *destLen , Byte const   *src , SizeT srcLen , CLzmaEncProps const   *props ,
                Byte *propsEncoded , SizeT *propsSize , int writeEndMark , ICompressProgress *progress ,
                ISzAlloc *alloc , ISzAlloc *allocBig ) ;
#line 63 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.h"
void MatchFinder_Construct(CMatchFinder *p ) ;
#line 69
int MatchFinder_Create(CMatchFinder *p , UInt32 historySize , UInt32 keepAddBufferBefore ,
                       UInt32 matchMaxLen , UInt32 keepAddBufferAfter , ISzAlloc *alloc ) ;
#line 72
void MatchFinder_Free(CMatchFinder *p , ISzAlloc *alloc ) ;
#line 103
void MatchFinder_CreateVTable(CMatchFinder *p , IMatchFinder *vTable ) ;
#line 94 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.h"
void MatchFinderMt_Construct(CMatchFinderMt *p ) ;
#line 95
void MatchFinderMt_Destruct(CMatchFinderMt *p , ISzAlloc *alloc ) ;
#line 96
SRes MatchFinderMt_Create(CMatchFinderMt *p , UInt32 historySize , UInt32 keepAddBufferBefore ,
                          UInt32 matchMaxLen , UInt32 keepAddBufferAfter , ISzAlloc *alloc ) ;
#line 98
void MatchFinderMt_CreateVTable(CMatchFinderMt *p , IMatchFinder *vTable ) ;
#line 99
void MatchFinderMt_ReleaseStream(CMatchFinderMt *p ) ;
#line 45 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEncProps_Init(CLzmaEncProps *p ) 
{ 
  UInt32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 47
  p->level = 5;
#line 48
  tmp = (UInt32 )0;
#line 48
  p->mc = tmp;
#line 48
  p->dictSize = tmp;
#line 49
  tmp___6 = -1;
#line 49
  p->numThreads = tmp___6;
#line 49
  tmp___5 = tmp___6;
#line 49
  p->numHashBytes = tmp___5;
#line 49
  tmp___4 = tmp___5;
#line 49
  p->btMode = tmp___4;
#line 49
  tmp___3 = tmp___4;
#line 49
  p->fb = tmp___3;
#line 49
  tmp___2 = tmp___3;
#line 49
  p->algo = tmp___2;
#line 49
  tmp___1 = tmp___2;
#line 49
  p->pb = tmp___1;
#line 49
  tmp___0 = tmp___1;
#line 49
  p->lp = tmp___0;
#line 49
  p->lc = tmp___0;
#line 50
  p->writeEndMark = 0U;
#line 51
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEncProps_Normalize(CLzmaEncProps *p ) 
{ 
  int level ;
  int tmp ;
  int tmp___0 ;

  {
#line 55
  level = p->level;
#line 56
  if (level < 0) {
#line 56
    level = 5;
  }
#line 57
  p->level = level;
#line 58
  if (p->dictSize == 0U) {
#line 58
    if (level <= 5) {
#line 58
      p->dictSize = (UInt32 )(1 << (level * 2 + 14));
    } else {
#line 58
      if (level == 6) {
#line 58
        tmp = 1 << 25;
      } else {
#line 58
        tmp = 1 << 26;
      }
#line 58
      p->dictSize = (UInt32 )tmp;
    }
  }
#line 59
  if (p->lc < 0) {
#line 59
    p->lc = 3;
  }
#line 60
  if (p->lp < 0) {
#line 60
    p->lp = 0;
  }
#line 61
  if (p->pb < 0) {
#line 61
    p->pb = 2;
  }
#line 62
  if (p->algo < 0) {
#line 62
    if (level < 5) {
#line 62
      p->algo = 0;
    } else {
#line 62
      p->algo = 1;
    }
  }
#line 63
  if (p->fb < 0) {
#line 63
    if (level < 7) {
#line 63
      p->fb = 32;
    } else {
#line 63
      p->fb = 64;
    }
  }
#line 64
  if (p->btMode < 0) {
#line 64
    if (p->algo == 0) {
#line 64
      p->btMode = 0;
    } else {
#line 64
      p->btMode = 1;
    }
  }
#line 65
  if (p->numHashBytes < 0) {
#line 65
    p->numHashBytes = 4;
  }
#line 66
  if (p->mc == 0U) {
#line 66
    if (p->btMode) {
#line 66
      tmp___0 = 0;
    } else {
#line 66
      tmp___0 = 1;
    }
#line 66
    p->mc = (UInt32 )((16 + (p->fb >> 1)) >> tmp___0);
  }
#line 67
  if (p->numThreads < 0) {
#line 68
    if (p->btMode) {
#line 68
      if (p->algo) {
#line 68
        p->numThreads = 2;
      } else {
#line 68
        p->numThreads = 1;
      }
    } else {
#line 68
      p->numThreads = 1;
    }
  }
#line 74
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
UInt32 LzmaEncProps_GetDictSize(CLzmaEncProps const   *props2 ) 
{ 
  CLzmaEncProps props ;

  {
  {
#line 78
  props = *props2;
#line 79
  LzmaEncProps_Normalize(& props);
  }
#line 80
  return (props.dictSize);
}
}
#line 107 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_FastPosInit(Byte *g_FastPos ) 
{ 
  int c ;
  int slotFast ;
  UInt32 k ;
  UInt32 j ;

  {
#line 109
  c = 2;
#line 110
  *(g_FastPos + 0) = (Byte )0;
#line 111
  *(g_FastPos + 1) = (Byte )1;
#line 113
  slotFast = 2;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (slotFast < (9 + (int )sizeof(size_t ) / 2) * 2)) {
#line 113
      goto while_break;
    }
#line 115
    k = (UInt32 )(1 << ((slotFast >> 1) - 1));
#line 117
    j = (UInt32 )0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (j < k)) {
#line 117
        goto while_break___0;
      }
#line 118
      *(g_FastPos + c) = (Byte )slotFast;
#line 117
      j ++;
#line 117
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 113
    slotFast ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 339 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_SaveState(CLzmaEncHandle pp ) 
{ 
  CLzmaEnc *p ;
  CSaveState *dest ;
  int i ;

  {
#line 341
  p = (CLzmaEnc *)pp;
#line 342
  dest = & p->saveState;
#line 344
  dest->lenEnc = p->lenEnc;
#line 345
  dest->repLenEnc = p->repLenEnc;
#line 346
  dest->state = p->state;
#line 348
  i = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (i < 12)) {
#line 348
      goto while_break;
    }
    {
#line 350
    memcpy((void */* __restrict  */)(dest->isMatch[i]), (void const   */* __restrict  */)(p->isMatch[i]),
           sizeof(p->isMatch[i]));
#line 351
    memcpy((void */* __restrict  */)(dest->isRep0Long[i]), (void const   */* __restrict  */)(p->isRep0Long[i]),
           sizeof(p->isRep0Long[i]));
#line 348
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  i = 0;
  {
#line 353
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 353
    if (! (i < 4)) {
#line 353
      goto while_break___0;
    }
    {
#line 354
    memcpy((void */* __restrict  */)(dest->posSlotEncoder[i]), (void const   */* __restrict  */)(p->posSlotEncoder[i]),
           sizeof(p->posSlotEncoder[i]));
#line 353
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 355
  memcpy((void */* __restrict  */)(dest->isRep), (void const   */* __restrict  */)(p->isRep),
         sizeof(p->isRep));
#line 356
  memcpy((void */* __restrict  */)(dest->isRepG0), (void const   */* __restrict  */)(p->isRepG0),
         sizeof(p->isRepG0));
#line 357
  memcpy((void */* __restrict  */)(dest->isRepG1), (void const   */* __restrict  */)(p->isRepG1),
         sizeof(p->isRepG1));
#line 358
  memcpy((void */* __restrict  */)(dest->isRepG2), (void const   */* __restrict  */)(p->isRepG2),
         sizeof(p->isRepG2));
#line 359
  memcpy((void */* __restrict  */)(dest->posEncoders), (void const   */* __restrict  */)(p->posEncoders),
         sizeof(p->posEncoders));
#line 360
  memcpy((void */* __restrict  */)(dest->posAlignEncoder), (void const   */* __restrict  */)(p->posAlignEncoder),
         sizeof(p->posAlignEncoder));
#line 361
  memcpy((void */* __restrict  */)(dest->reps), (void const   */* __restrict  */)(p->reps),
         sizeof(p->reps));
#line 362
  memcpy((void */* __restrict  */)dest->litProbs, (void const   */* __restrict  */)p->litProbs,
         (unsigned long )(768 << p->lclp) * sizeof(UInt16 ));
  }
#line 363
  return;
}
}
#line 365 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_RestoreState(CLzmaEncHandle pp ) 
{ 
  CLzmaEnc *dest ;
  CSaveState const   *p ;
  int i ;

  {
#line 367
  dest = (CLzmaEnc *)pp;
#line 368
  p = (CSaveState const   *)(& dest->saveState);
#line 370
  dest->lenEnc = (CLenPriceEnc )p->lenEnc;
#line 371
  dest->repLenEnc = (CLenPriceEnc )p->repLenEnc;
#line 372
  dest->state = (UInt32 )p->state;
#line 374
  i = 0;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < 12)) {
#line 374
      goto while_break;
    }
    {
#line 376
    memcpy((void */* __restrict  */)(dest->isMatch[i]), (void const   */* __restrict  */)(p->isMatch[i]),
           sizeof(p->isMatch[i]));
#line 377
    memcpy((void */* __restrict  */)(dest->isRep0Long[i]), (void const   */* __restrict  */)(p->isRep0Long[i]),
           sizeof(p->isRep0Long[i]));
#line 374
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  i = 0;
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 379
    if (! (i < 4)) {
#line 379
      goto while_break___0;
    }
    {
#line 380
    memcpy((void */* __restrict  */)(dest->posSlotEncoder[i]), (void const   */* __restrict  */)(p->posSlotEncoder[i]),
           sizeof(p->posSlotEncoder[i]));
#line 379
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 381
  memcpy((void */* __restrict  */)(dest->isRep), (void const   */* __restrict  */)(p->isRep),
         sizeof(p->isRep));
#line 382
  memcpy((void */* __restrict  */)(dest->isRepG0), (void const   */* __restrict  */)(p->isRepG0),
         sizeof(p->isRepG0));
#line 383
  memcpy((void */* __restrict  */)(dest->isRepG1), (void const   */* __restrict  */)(p->isRepG1),
         sizeof(p->isRepG1));
#line 384
  memcpy((void */* __restrict  */)(dest->isRepG2), (void const   */* __restrict  */)(p->isRepG2),
         sizeof(p->isRepG2));
#line 385
  memcpy((void */* __restrict  */)(dest->posEncoders), (void const   */* __restrict  */)(p->posEncoders),
         sizeof(p->posEncoders));
#line 386
  memcpy((void */* __restrict  */)(dest->posAlignEncoder), (void const   */* __restrict  */)(p->posAlignEncoder),
         sizeof(p->posAlignEncoder));
#line 387
  memcpy((void */* __restrict  */)(dest->reps), (void const   */* __restrict  */)(p->reps),
         sizeof(p->reps));
#line 388
  memcpy((void */* __restrict  */)dest->litProbs, (void const   */* __restrict  */)p->litProbs,
         (unsigned long )(768 << dest->lclp) * sizeof(UInt16 ));
  }
#line 389
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEnc_SetProps(CLzmaEncHandle pp , CLzmaEncProps const   *props2 ) 
{ 
  CLzmaEnc *p ;
  CLzmaEncProps props ;
  unsigned int fb ;
  UInt32 numHashBytes ;

  {
  {
#line 393
  p = (CLzmaEnc *)pp;
#line 394
  props = *props2;
#line 395
  LzmaEncProps_Normalize(& props);
  }
#line 397
  if (props.lc > 8) {
#line 399
    return (5);
  } else
#line 397
  if (props.lp > 4) {
#line 399
    return (5);
  } else
#line 397
  if (props.pb > 4) {
#line 399
    return (5);
  } else
#line 397
  if (props.dictSize > 1U << (((9 + (int )sizeof(size_t ) / 2) - 1) * 2 + 7)) {
#line 399
    return (5);
  } else
#line 397
  if (props.dictSize > 1U << 30) {
#line 399
    return (5);
  }
#line 400
  p->dictSize = props.dictSize;
#line 401
  p->matchFinderCycles = props.mc;
#line 403
  fb = (unsigned int )props.fb;
#line 404
  if (fb < 5U) {
#line 405
    fb = 5U;
  }
#line 406
  if (fb > (unsigned int )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1)) {
#line 407
    fb = (unsigned int )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1);
  }
#line 408
  p->numFastBytes = fb;
#line 410
  p->lc = (unsigned int )props.lc;
#line 411
  p->lp = (unsigned int )props.lp;
#line 412
  p->pb = (unsigned int )props.pb;
#line 413
  p->fastMode = props.algo == 0;
#line 414
  p->matchFinderBase.btMode = props.btMode;
#line 416
  numHashBytes = (UInt32 )4;
#line 417
  if (props.btMode) {
#line 419
    if (props.numHashBytes < 2) {
#line 420
      numHashBytes = (UInt32 )2;
    } else
#line 421
    if (props.numHashBytes < 4) {
#line 422
      numHashBytes = (UInt32 )props.numHashBytes;
    }
  }
#line 424
  p->matchFinderBase.numHashBytes = numHashBytes;
#line 427
  p->matchFinderBase.cutValue = props.mc;
#line 429
  p->writeEndMark = (Bool )props.writeEndMark;
#line 439
  p->multiThread = props.numThreads > 1;
#line 442
  return (0);
}
}
#line 445 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static int const   kLiteralNextStates[12]  = 
#line 445
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )4,      (int const   )5};
#line 446 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static int const   kMatchNextStates[12]  = 
#line 446
  {      (int const   )7,      (int const   )7,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )7,      (int const   )10, 
        (int const   )10,      (int const   )10,      (int const   )10,      (int const   )10};
#line 447 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static int const   kRepNextStates[12]  = 
#line 447
  {      (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11};
#line 448 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static int const   kShortRepNextStates[12]  = 
#line 448
  {      (int const   )9,      (int const   )9,      (int const   )9,      (int const   )9, 
        (int const   )9,      (int const   )9,      (int const   )9,      (int const   )11, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11};
#line 456 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_Construct(CRangeEnc *p ) 
{ 


  {
#line 458
  p->outStream = (ISeqOutStream *)0;
#line 459
  p->bufBase = (Byte *)0;
#line 460
  return;
}
}
#line 465 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static int RangeEnc_Alloc(CRangeEnc *p , ISzAlloc *alloc ) 
{ 
  void *tmp ;

  {
#line 467
  if ((unsigned long )p->bufBase == (unsigned long )((Byte *)0)) {
    {
#line 469
    tmp = (*(alloc->Alloc))((void *)alloc, (size_t )(1 << 16));
#line 469
    p->bufBase = (Byte *)tmp;
    }
#line 470
    if ((unsigned long )p->bufBase == (unsigned long )((Byte *)0)) {
#line 471
      return (0);
    }
#line 472
    p->bufLim = p->bufBase + (1 << 16);
  }
#line 474
  return (1);
}
}
#line 477 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_Free(CRangeEnc *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 479
  (*(alloc->Free))((void *)alloc, (void *)p->bufBase);
#line 480
  p->bufBase = (Byte *)0;
  }
#line 481
  return;
}
}
#line 483 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_Init(CRangeEnc *p ) 
{ 


  {
#line 486
  p->low = (UInt64 )0;
#line 487
  p->range = 4294967295U;
#line 488
  p->cacheSize = (UInt64 )1;
#line 489
  p->cache = (Byte )0;
#line 491
  p->buf = p->bufBase;
#line 493
  p->processed = (UInt64 )0;
#line 494
  p->res = 0;
#line 495
  return;
}
}
#line 497 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_FlushStream(CRangeEnc *p ) 
{ 
  size_t num ;
  size_t tmp ;

  {
#line 500
  if (p->res != 0) {
#line 501
    return;
  }
  {
#line 502
  num = (size_t )(p->buf - p->bufBase);
#line 503
  tmp = (*((p->outStream)->Write))((void *)p->outStream, (void const   *)p->bufBase,
                                   num);
  }
#line 503
  if (num != tmp) {
#line 504
    p->res = 9;
  }
#line 505
  p->processed += (UInt64 )num;
#line 506
  p->buf = p->bufBase;
#line 507
  return;
}
}
#line 509 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_ShiftLow(CRangeEnc *p ) 
{ 
  Byte temp ;
  Byte *buf ;
  Byte *tmp ;

  {
#line 511
  if ((UInt32 )p->low < 4278190080U) {
#line 511
    goto _L;
  } else
#line 511
  if ((int )(p->low >> 32) != 0) {
    _L: /* CIL Label */ 
#line 513
    temp = p->cache;
    {
#line 514
    while (1) {
      while_continue: /* CIL Label */ ;
#line 516
      buf = p->buf;
#line 517
      tmp = buf;
#line 517
      buf ++;
#line 517
      *tmp = (Byte )((int )temp + (int )((Byte )(p->low >> 32)));
#line 518
      p->buf = buf;
#line 519
      if ((unsigned long )buf == (unsigned long )p->bufLim) {
        {
#line 520
        RangeEnc_FlushStream(p);
        }
      }
#line 521
      temp = (Byte )255;
#line 514
      (p->cacheSize) --;
#line 514
      if (! (p->cacheSize != 0ULL)) {
#line 514
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 524
    p->cache = (Byte )((UInt32 )p->low >> 24);
  }
#line 526
  (p->cacheSize) ++;
#line 527
  p->low = (UInt64 )((UInt32 )p->low << 8);
#line 528
  return;
}
}
#line 530 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_FlushData(CRangeEnc *p ) 
{ 
  int i ;

  {
#line 533
  i = 0;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (i < 5)) {
#line 533
      goto while_break;
    }
    {
#line 534
    RangeEnc_ShiftLow(p);
#line 533
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  return;
}
}
#line 537 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_EncodeDirectBits(CRangeEnc *p , UInt32 value , int numBits ) 
{ 


  {
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    p->range >>= 1;
#line 542
    numBits --;
#line 542
    p->low += (UInt64 )(p->range & (0U - ((value >> numBits) & 1U)));
#line 543
    if (p->range < 1U << 24) {
      {
#line 545
      p->range <<= 8;
#line 546
      RangeEnc_ShiftLow(p);
      }
    }
#line 539
    if (! (numBits != 0)) {
#line 539
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RangeEnc_EncodeBit(CRangeEnc *p , UInt16 *prob , UInt32 symbol ) 
{ 
  UInt32 ttt ;
  UInt32 newBound ;

  {
#line 554
  ttt = (UInt32 )*prob;
#line 555
  newBound = (p->range >> 11) * ttt;
#line 556
  if (symbol == 0U) {
#line 558
    p->range = newBound;
#line 559
    ttt += ((UInt32 )(1 << 11) - ttt) >> 5;
  } else {
#line 563
    p->low += (UInt64 )newBound;
#line 564
    p->range -= newBound;
#line 565
    ttt -= ttt >> 5;
  }
#line 567
  *prob = (UInt16 )ttt;
#line 568
  if (p->range < 1U << 24) {
    {
#line 570
    p->range <<= 8;
#line 571
    RangeEnc_ShiftLow(p);
    }
  }
#line 573
  return;
}
}
#line 575 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LitEnc_Encode(CRangeEnc *p , UInt16 *probs , UInt32 symbol ) 
{ 


  {
#line 577
  symbol |= 256U;
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 580
    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1U);
#line 581
    symbol <<= 1;
    }
#line 578
    if (! (symbol < 65536U)) {
#line 578
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  return;
}
}
#line 586 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LitEnc_EncodeMatched(CRangeEnc *p , UInt16 *probs , UInt32 symbol , UInt32 matchByte ) 
{ 
  UInt32 offs ;

  {
#line 588
  offs = (UInt32 )256;
#line 589
  symbol |= 256U;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 592
    matchByte <<= 1;
#line 593
    RangeEnc_EncodeBit(p, probs + ((offs + (matchByte & offs)) + (symbol >> 8)), (symbol >> 7) & 1U);
#line 594
    symbol <<= 1;
#line 595
    offs &= ~ (matchByte ^ symbol);
    }
#line 590
    if (! (symbol < 65536U)) {
#line 590
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 598
  return;
}
}
#line 600 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_InitPriceTables(UInt32 *ProbPrices ) 
{ 
  UInt32 i ;
  int kCyclesBits ;
  UInt32 w ;
  UInt32 bitCount ;
  int j ;

  {
#line 603
  i = (UInt32 )((1 << 4) / 2);
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (i < (UInt32 )(1 << 11))) {
#line 603
      goto while_break;
    }
#line 605
    kCyclesBits = 4;
#line 606
    w = i;
#line 607
    bitCount = (UInt32 )0;
#line 609
    j = 0;
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 609
      if (! (j < kCyclesBits)) {
#line 609
        goto while_break___0;
      }
#line 611
      w *= w;
#line 612
      bitCount <<= 1;
      {
#line 613
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 613
        if (! (w >= 1U << 16)) {
#line 613
          goto while_break___1;
        }
#line 615
        w >>= 1;
#line 616
        bitCount ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 609
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 619
    *(ProbPrices + (i >> 4)) = (UInt32 )((11 << kCyclesBits) - 15) - bitCount;
#line 603
    i += (UInt32 )(1 << 4);
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 636 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 LitEnc_GetPrice(UInt16 const   *probs , UInt32 symbol , UInt32 *ProbPrices ) 
{ 
  UInt32 price ;

  {
#line 638
  price = (UInt32 )0;
#line 639
  symbol |= 256U;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    price += *(ProbPrices + (((int const   )*(probs + (symbol >> 8)) ^ (int const   )(- ((int )((symbol >> 7) & 1U)) & ((1 << 11) - 1))) >> 4));
#line 643
    symbol <<= 1;
#line 640
    if (! (symbol < 65536U)) {
#line 640
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  return (price);
}
}
#line 649 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 LitEnc_GetPriceMatched(UInt16 const   *probs , UInt32 symbol , UInt32 matchByte ,
                                     UInt32 *ProbPrices ) 
{ 
  UInt32 price ;
  UInt32 offs ;

  {
#line 651
  price = (UInt32 )0;
#line 652
  offs = (UInt32 )256;
#line 653
  symbol |= 256U;
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    matchByte <<= 1;
#line 657
    price += *(ProbPrices + (((int const   )*(probs + ((offs + (matchByte & offs)) + (symbol >> 8))) ^ (int const   )(- ((int )((symbol >> 7) & 1U)) & ((1 << 11) - 1))) >> 4));
#line 658
    symbol <<= 1;
#line 659
    offs &= ~ (matchByte ^ symbol);
#line 654
    if (! (symbol < 65536U)) {
#line 654
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return (price);
}
}
#line 666 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RcTree_Encode(CRangeEnc *rc , UInt16 *probs , int numBitLevels , UInt32 symbol ) 
{ 
  UInt32 m ;
  int i ;
  UInt32 bit ;

  {
#line 668
  m = (UInt32 )1;
#line 670
  i = numBitLevels;
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! (i != 0)) {
#line 670
      goto while_break;
    }
    {
#line 673
    i --;
#line 674
    bit = (symbol >> i) & 1U;
#line 675
    RangeEnc_EncodeBit(rc, probs + m, bit);
#line 676
    m = (m << 1) | bit;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  return;
}
}
#line 680 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void RcTree_ReverseEncode(CRangeEnc *rc , UInt16 *probs , int numBitLevels ,
                                 UInt32 symbol ) 
{ 
  UInt32 m ;
  int i ;
  UInt32 bit ;

  {
#line 682
  m = (UInt32 )1;
#line 684
  i = 0;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (i < numBitLevels)) {
#line 684
      goto while_break;
    }
    {
#line 686
    bit = symbol & 1U;
#line 687
    RangeEnc_EncodeBit(rc, probs + m, bit);
#line 688
    m = (m << 1) | bit;
#line 689
    symbol >>= 1;
#line 684
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 691
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 RcTree_GetPrice(UInt16 const   *probs , int numBitLevels , UInt32 symbol ,
                              UInt32 *ProbPrices ) 
{ 
  UInt32 price ;

  {
#line 695
  price = (UInt32 )0;
#line 696
  symbol |= (unsigned int )(1 << numBitLevels);
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    if (! (symbol != 1U)) {
#line 697
      goto while_break;
    }
#line 699
    price += *(ProbPrices + (((int const   )*(probs + (symbol >> 1)) ^ (int const   )(- ((int )(symbol & 1U)) & ((1 << 11) - 1))) >> 4));
#line 700
    symbol >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  return (price);
}
}
#line 705 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 RcTree_ReverseGetPrice(UInt16 const   *probs , int numBitLevels , UInt32 symbol ,
                                     UInt32 *ProbPrices ) 
{ 
  UInt32 price ;
  UInt32 m ;
  int i ;
  UInt32 bit ;

  {
#line 707
  price = (UInt32 )0;
#line 708
  m = (UInt32 )1;
#line 710
  i = numBitLevels;
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! (i != 0)) {
#line 710
      goto while_break;
    }
#line 712
    bit = symbol & 1U;
#line 713
    symbol >>= 1;
#line 714
    price += *(ProbPrices + (((int const   )*(probs + m) ^ (int const   )(- ((int )bit) & ((1 << 11) - 1))) >> 4));
#line 715
    m = (m << 1) | bit;
#line 710
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  return (price);
}
}
#line 721 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LenEnc_Init(CLenEnc *p ) 
{ 
  unsigned int i ;
  UInt16 tmp ;

  {
#line 724
  tmp = (UInt16 )((1 << 11) >> 1);
#line 724
  p->choice2 = tmp;
#line 724
  p->choice = tmp;
#line 725
  i = 0U;
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (i < (unsigned int )((1 << 4) << 3))) {
#line 725
      goto while_break;
    }
#line 726
    p->low[i] = (UInt16 )((1 << 11) >> 1);
#line 725
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  i = 0U;
  {
#line 727
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 727
    if (! (i < (unsigned int )((1 << 4) << 3))) {
#line 727
      goto while_break___0;
    }
#line 728
    p->mid[i] = (UInt16 )((1 << 11) >> 1);
#line 727
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 729
  i = 0U;
  {
#line 729
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 729
    if (! (i < (unsigned int )(1 << 8))) {
#line 729
      goto while_break___1;
    }
#line 730
    p->high[i] = (UInt16 )((1 << 11) >> 1);
#line 729
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 731
  return;
}
}
#line 733 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LenEnc_Encode(CLenEnc *p , CRangeEnc *rc , UInt32 symbol , UInt32 posState ) 
{ 


  {
#line 735
  if (symbol < (UInt32 )(1 << 3)) {
    {
#line 737
    RangeEnc_EncodeBit(rc, & p->choice, (UInt32 )0);
#line 738
    RcTree_Encode(rc, p->low + (posState << 3), 3, symbol);
    }
  } else {
    {
#line 742
    RangeEnc_EncodeBit(rc, & p->choice, (UInt32 )1);
    }
#line 743
    if (symbol < (UInt32 )((1 << 3) + (1 << 3))) {
      {
#line 745
      RangeEnc_EncodeBit(rc, & p->choice2, (UInt32 )0);
#line 746
      RcTree_Encode(rc, p->mid + (posState << 3), 3, symbol - (UInt32 )(1 << 3));
      }
    } else {
      {
#line 750
      RangeEnc_EncodeBit(rc, & p->choice2, (UInt32 )1);
#line 751
      RcTree_Encode(rc, p->high, 8, (symbol - (UInt32 )(1 << 3)) - (UInt32 )(1 << 3));
      }
    }
  }
#line 754
  return;
}
}
#line 756 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LenEnc_SetPrices(CLenEnc *p , UInt32 posState , UInt32 numSymbols , UInt32 *prices ,
                             UInt32 *ProbPrices ) 
{ 
  UInt32 a0 ;
  UInt32 a1 ;
  UInt32 b0 ;
  UInt32 b1 ;
  UInt32 i ;
  UInt32 tmp ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;

  {
#line 758
  a0 = *(ProbPrices + ((int )p->choice >> 4));
#line 759
  a1 = *(ProbPrices + (((int )p->choice ^ ((1 << 11) - 1)) >> 4));
#line 760
  b0 = a1 + *(ProbPrices + ((int )p->choice2 >> 4));
#line 761
  b1 = a1 + *(ProbPrices + (((int )p->choice2 ^ ((1 << 11) - 1)) >> 4));
#line 762
  i = (UInt32 )0;
#line 763
  i = (UInt32 )0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! (i < (UInt32 )(1 << 3))) {
#line 763
      goto while_break;
    }
#line 765
    if (i >= numSymbols) {
#line 766
      return;
    }
    {
#line 767
    tmp = RcTree_GetPrice((UInt16 const   *)(p->low + (posState << 3)), 3, i, ProbPrices);
#line 767
    *(prices + i) = a0 + tmp;
#line 763
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 769
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 769
    if (! (i < (UInt32 )((1 << 3) + (1 << 3)))) {
#line 769
      goto while_break___0;
    }
#line 771
    if (i >= numSymbols) {
#line 772
      return;
    }
    {
#line 773
    tmp___0 = RcTree_GetPrice((UInt16 const   *)(p->mid + (posState << 3)), 3, i - (UInt32 )(1 << 3),
                              ProbPrices);
#line 773
    *(prices + i) = b0 + tmp___0;
#line 769
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 775
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 775
    if (! (i < numSymbols)) {
#line 775
      goto while_break___1;
    }
    {
#line 776
    tmp___1 = RcTree_GetPrice((UInt16 const   *)(p->high), 8, (i - (UInt32 )(1 << 3)) - (UInt32 )(1 << 3),
                              ProbPrices);
#line 776
    *(prices + i) = b1 + tmp___1;
#line 775
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 777
  return;
}
}
#line 779 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LenPriceEnc_UpdateTable(CLenPriceEnc *p , UInt32 posState , UInt32 *ProbPrices ) 
{ 


  {
  {
#line 781
  LenEnc_SetPrices(& p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
#line 782
  p->counters[posState] = p->tableSize;
  }
#line 783
  return;
}
}
#line 785 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LenPriceEnc_UpdateTables(CLenPriceEnc *p , UInt32 numPosStates , UInt32 *ProbPrices ) 
{ 
  UInt32 posState ;

  {
#line 788
  posState = (UInt32 )0;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! (posState < numPosStates)) {
#line 788
      goto while_break;
    }
    {
#line 789
    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
#line 788
    posState ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return;
}
}
#line 792 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LenEnc_Encode2(CLenPriceEnc *p , CRangeEnc *rc , UInt32 symbol , UInt32 posState ,
                           Bool updatePrice , UInt32 *ProbPrices ) 
{ 


  {
  {
#line 794
  LenEnc_Encode(& p->p, rc, symbol, posState);
  }
#line 795
  if (updatePrice) {
#line 796
    (p->counters[posState]) --;
#line 796
    if (p->counters[posState] == 0U) {
      {
#line 797
      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
      }
    }
  }
#line 798
  return;
}
}
#line 803 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void MovePos(CLzmaEnc *p , UInt32 num ) 
{ 


  {
#line 809
  if (num != 0U) {
    {
#line 811
    p->additionalOffset += num;
#line 812
    (*(p->matchFinder.Skip))(p->matchFinderObj, num);
    }
  }
#line 814
  return;
}
}
#line 816 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 ReadMatchDistances(CLzmaEnc *p , UInt32 *numDistancePairsRes ) 
{ 
  UInt32 lenRes ;
  UInt32 numPairs ;
  Byte const   *pby ;
  Byte const   *tmp ;
  UInt32 distance ;
  UInt32 numAvail ;
  Byte const   *pby2 ;

  {
  {
#line 818
  lenRes = (UInt32 )0;
#line 819
  p->numAvail = (*(p->matchFinder.GetNumAvailableBytes))(p->matchFinderObj);
#line 820
  numPairs = (*(p->matchFinder.GetMatches))(p->matchFinderObj, p->matches);
  }
#line 830
  if (numPairs > 0U) {
#line 832
    lenRes = p->matches[numPairs - 2U];
#line 833
    if (lenRes == p->numFastBytes) {
      {
#line 835
      tmp = (*(p->matchFinder.GetPointerToCurrentPos))(p->matchFinderObj);
#line 835
      pby = tmp - 1;
#line 836
      distance = p->matches[numPairs - 1U] + 1U;
#line 837
      numAvail = p->numAvail;
      }
#line 838
      if (numAvail > (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1)) {
#line 839
        numAvail = (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1);
      }
#line 841
      pby2 = pby - distance;
      {
#line 842
      while (1) {
        while_continue: /* CIL Label */ ;
#line 842
        if (lenRes < numAvail) {
#line 842
          if (! ((int const   )*(pby + lenRes) == (int const   )*(pby2 + lenRes))) {
#line 842
            goto while_break;
          }
        } else {
#line 842
          goto while_break;
        }
#line 842
        lenRes ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 846
  (p->additionalOffset) ++;
#line 847
  *numDistancePairsRes = numPairs;
#line 848
  return (lenRes);
}
}
#line 856 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 GetRepLen1Price(CLzmaEnc *p , UInt32 state , UInt32 posState ) 
{ 


  {
#line 858
  return (p->ProbPrices[(int )p->isRepG0[state] >> 4] + p->ProbPrices[(int )p->isRep0Long[state][posState] >> 4]);
}
}
#line 863 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 GetPureRepPrice(CLzmaEnc *p , UInt32 repIndex , UInt32 state , UInt32 posState ) 
{ 
  UInt32 price ;

  {
#line 866
  if (repIndex == 0U) {
#line 868
    price = p->ProbPrices[(int )p->isRepG0[state] >> 4];
#line 869
    price += p->ProbPrices[((int )p->isRep0Long[state][posState] ^ ((1 << 11) - 1)) >> 4];
  } else {
#line 873
    price = p->ProbPrices[((int )p->isRepG0[state] ^ ((1 << 11) - 1)) >> 4];
#line 874
    if (repIndex == 1U) {
#line 875
      price += p->ProbPrices[(int )p->isRepG1[state] >> 4];
    } else {
#line 878
      price += p->ProbPrices[((int )p->isRepG1[state] ^ ((1 << 11) - 1)) >> 4];
#line 879
      price += p->ProbPrices[((int )p->isRepG2[state] ^ (- ((int )(repIndex - 2U)) & ((1 << 11) - 1))) >> 4];
    }
  }
#line 882
  return (price);
}
}
#line 885 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 GetRepPrice(CLzmaEnc *p , UInt32 repIndex , UInt32 len , UInt32 state ,
                          UInt32 posState ) 
{ 
  UInt32 tmp ;

  {
  {
#line 887
  tmp = GetPureRepPrice(p, repIndex, state, posState);
  }
#line 887
  return (p->repLenEnc.prices[posState][len - 2U] + tmp);
}
}
#line 891 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 Backward(CLzmaEnc *p , UInt32 *backRes , UInt32 cur ) 
{ 
  UInt32 posMem ;
  UInt32 backMem ;
  UInt32 posPrev ;
  UInt32 backCur ;

  {
#line 893
  posMem = p->opt[cur].posPrev;
#line 894
  backMem = p->opt[cur].backPrev;
#line 895
  p->optimumEndIndex = cur;
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (p->opt[cur].prev1IsChar) {
#line 900
      p->opt[posMem].backPrev = (UInt32 )-1;
#line 900
      p->opt[posMem].prev1IsChar = 0;
#line 901
      p->opt[posMem].posPrev = posMem - 1U;
#line 902
      if (p->opt[cur].prev2) {
#line 904
        p->opt[posMem - 1U].prev1IsChar = 0;
#line 905
        p->opt[posMem - 1U].posPrev = p->opt[cur].posPrev2;
#line 906
        p->opt[posMem - 1U].backPrev = p->opt[cur].backPrev2;
      }
    }
#line 910
    posPrev = posMem;
#line 911
    backCur = backMem;
#line 913
    backMem = p->opt[posPrev].backPrev;
#line 914
    posMem = p->opt[posPrev].posPrev;
#line 916
    p->opt[posPrev].backPrev = backCur;
#line 917
    p->opt[posPrev].posPrev = cur;
#line 918
    cur = posPrev;
#line 896
    if (! (cur != 0U)) {
#line 896
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 922
  *backRes = p->opt[0].backPrev;
#line 923
  p->optimumCurrentIndex = p->opt[0].posPrev;
#line 924
  return (p->optimumCurrentIndex);
}
}
#line 929 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 GetOptimum(CLzmaEnc *p , UInt32 position , UInt32 *backRes ) 
{ 
  UInt32 numAvail ;
  UInt32 mainLen ;
  UInt32 numPairs ;
  UInt32 repMaxIndex ;
  UInt32 i ;
  UInt32 posState ;
  UInt32 lenEnd ;
  UInt32 len ;
  UInt32 cur ;
  UInt32 matchPrice ;
  UInt32 repMatchPrice ;
  UInt32 normalMatchPrice ;
  UInt32 reps[4] ;
  UInt32 repLens[4] ;
  UInt32 *matches ;
  Byte const   *data ;
  Byte curByte ;
  Byte matchByte ;
  COptimal const   *opt ;
  UInt32 lenRes ;
  UInt32 tmp ;
  Byte const   *tmp___0 ;
  UInt32 lenTest ;
  Byte const   *data2 ;
  UInt32 lenRes___0 ;
  UInt16 const   *probs ;
  UInt32 tmp___1 ;
  UInt32 tmp___2 ;
  UInt32 tmp___3 ;
  UInt32 shortRepPrice ;
  UInt32 tmp___4 ;
  UInt32 tmp___5 ;
  UInt32 repLen ;
  UInt32 price ;
  UInt32 tmp___6 ;
  UInt32 curAndLenPrice ;
  COptimal *opt___0 ;
  UInt32 offs ;
  COptimal *opt___1 ;
  UInt32 distance ;
  UInt32 curAndLenPrice___0 ;
  UInt32 lenToPosState ;
  UInt32 tmp___7 ;
  UInt32 slot ;
  UInt32 i___0 ;
  UInt32 numAvailFull ;
  UInt32 newLen ;
  UInt32 numPairs___0 ;
  UInt32 posPrev ;
  UInt32 state ;
  UInt32 posState___0 ;
  UInt32 startLen ;
  UInt32 curPrice ;
  UInt32 curAnd1Price ;
  UInt32 matchPrice___0 ;
  UInt32 repMatchPrice___0 ;
  Bool nextIsChar ;
  Byte curByte___0 ;
  Byte matchByte___0 ;
  Byte const   *data___0 ;
  COptimal *curOpt ;
  COptimal *nextOpt ;
  UInt32 tmp___8 ;
  UInt32 tmp___9 ;
  UInt32 pos ;
  COptimal const   *prevOpt ;
  UInt32 i___1 ;
  UInt32 i___2 ;
  Byte const   *tmp___10 ;
  UInt16 const   *probs___0 ;
  UInt32 tmp___11 ;
  UInt32 tmp___12 ;
  UInt32 tmp___13 ;
  UInt32 shortRepPrice___0 ;
  UInt32 tmp___14 ;
  UInt32 temp ;
  UInt32 temp___0 ;
  UInt32 lenTest2 ;
  Byte const   *data2___0 ;
  UInt32 limit ;
  UInt32 state2 ;
  UInt32 posStateNext ;
  UInt32 nextRepMatchPrice ;
  UInt32 curAndLenPrice___1 ;
  COptimal *opt___2 ;
  UInt32 offset ;
  UInt32 tmp___15 ;
  UInt32 repIndex ;
  UInt32 lenTest___0 ;
  UInt32 lenTestTemp ;
  UInt32 price___0 ;
  Byte const   *data2___1 ;
  UInt32 tmp___16 ;
  UInt32 curAndLenPrice___2 ;
  COptimal *opt___3 ;
  UInt32 lenTest2___0 ;
  UInt32 limit___0 ;
  UInt32 nextRepMatchPrice___0 ;
  UInt32 state2___0 ;
  UInt32 posStateNext___0 ;
  UInt32 curAndLenCharPrice ;
  UInt32 tmp___17 ;
  UInt32 curAndLenPrice___3 ;
  COptimal *opt___4 ;
  UInt32 offset___0 ;
  UInt32 tmp___18 ;
  UInt32 normalMatchPrice___0 ;
  UInt32 offs___0 ;
  UInt32 curBack ;
  UInt32 posSlot ;
  UInt32 lenTest___1 ;
  UInt32 i___3 ;
  UInt32 curAndLenPrice___4 ;
  UInt32 lenToPosState___0 ;
  UInt32 tmp___19 ;
  COptimal *opt___5 ;
  Byte const   *data2___2 ;
  UInt32 lenTest2___1 ;
  UInt32 limit___1 ;
  UInt32 nextRepMatchPrice___1 ;
  UInt32 state2___1 ;
  UInt32 posStateNext___1 ;
  UInt32 curAndLenCharPrice___0 ;
  UInt32 tmp___20 ;
  UInt32 offset___1 ;
  UInt32 curAndLenPrice___5 ;
  COptimal *opt___6 ;
  UInt32 tmp___21 ;
  UInt32 i___4 ;

  {
#line 937
  if (p->optimumEndIndex != p->optimumCurrentIndex) {
#line 939
    opt = (COptimal const   *)(& p->opt[p->optimumCurrentIndex]);
#line 940
    lenRes = (UInt32 )(opt->posPrev - (UInt32 const   )p->optimumCurrentIndex);
#line 941
    *backRes = (UInt32 )opt->backPrev;
#line 942
    p->optimumCurrentIndex = (UInt32 )opt->posPrev;
#line 943
    return (lenRes);
  }
#line 945
  tmp = (UInt32 )0;
#line 945
  p->optimumEndIndex = tmp;
#line 945
  p->optimumCurrentIndex = tmp;
#line 947
  if (p->additionalOffset == 0U) {
    {
#line 948
    mainLen = ReadMatchDistances(p, & numPairs);
    }
  } else {
#line 951
    mainLen = p->longestMatchLength;
#line 952
    numPairs = p->numPairs;
  }
#line 955
  numAvail = p->numAvail;
#line 956
  if (numAvail < 2U) {
#line 958
    *backRes = (UInt32 )-1;
#line 959
    return ((UInt32 )1);
  }
#line 961
  if (numAvail > (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1)) {
#line 962
    numAvail = (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1);
  }
  {
#line 964
  tmp___0 = (*(p->matchFinder.GetPointerToCurrentPos))(p->matchFinderObj);
#line 964
  data = tmp___0 - 1;
#line 965
  repMaxIndex = (UInt32 )0;
#line 966
  i = (UInt32 )0;
  }
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 966
    if (! (i < 4U)) {
#line 966
      goto while_break;
    }
#line 970
    reps[i] = p->reps[i];
#line 971
    data2 = data - (reps[i] + 1U);
#line 972
    if ((int const   )*(data + 0) != (int const   )*(data2 + 0)) {
#line 974
      repLens[i] = (UInt32 )0;
#line 975
      goto __Cont;
    } else
#line 972
    if ((int const   )*(data + 1) != (int const   )*(data2 + 1)) {
#line 974
      repLens[i] = (UInt32 )0;
#line 975
      goto __Cont;
    }
#line 977
    lenTest = (UInt32 )2;
    {
#line 977
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 977
      if (lenTest < numAvail) {
#line 977
        if (! ((int const   )*(data + lenTest) == (int const   )*(data2 + lenTest))) {
#line 977
          goto while_break___0;
        }
      } else {
#line 977
        goto while_break___0;
      }
#line 977
      lenTest ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 978
    repLens[i] = lenTest;
#line 979
    if (lenTest > repLens[repMaxIndex]) {
#line 980
      repMaxIndex = i;
    }
    __Cont: /* CIL Label */ 
#line 966
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 982
  if (repLens[repMaxIndex] >= p->numFastBytes) {
    {
#line 985
    *backRes = repMaxIndex;
#line 986
    lenRes___0 = repLens[repMaxIndex];
#line 987
    MovePos(p, lenRes___0 - 1U);
    }
#line 988
    return (lenRes___0);
  }
#line 991
  matches = p->matches;
#line 992
  if (mainLen >= p->numFastBytes) {
    {
#line 994
    *backRes = *(matches + (numPairs - 1U)) + 4U;
#line 995
    MovePos(p, mainLen - 1U);
    }
#line 996
    return (mainLen);
  }
#line 998
  curByte = (Byte )*data;
#line 999
  matchByte = (Byte )*(data - (reps[0] + 1U));
#line 1001
  if (mainLen < 2U) {
#line 1001
    if ((int )curByte != (int )matchByte) {
#line 1001
      if (repLens[repMaxIndex] < 2U) {
#line 1003
        *backRes = (UInt32 )-1;
#line 1004
        return ((UInt32 )1);
      }
    }
  }
#line 1007
  p->opt[0].state = p->state;
#line 1009
  posState = position & p->pbMask;
#line 1012
  probs = (UInt16 const   *)(p->litProbs + (((position & p->lpMask) << p->lc) + (unsigned int )((int const   )*(data - 1) >> (8U - p->lc))) * 768U);
#line 1013
  if (! (p->state < 7U)) {
    {
#line 1013
    tmp___1 = LitEnc_GetPriceMatched(probs, (UInt32 )curByte, (UInt32 )matchByte,
                                     p->ProbPrices);
#line 1013
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 1013
    tmp___2 = LitEnc_GetPrice(probs, (UInt32 )curByte, p->ProbPrices);
#line 1013
    tmp___3 = tmp___2;
    }
  }
#line 1013
  p->opt[1].price = p->ProbPrices[(int )p->isMatch[p->state][posState] >> 4] + tmp___3;
#line 1019
  p->opt[1].backPrev = (UInt32 )-1;
#line 1019
  p->opt[1].prev1IsChar = 0;
#line 1021
  matchPrice = p->ProbPrices[((int )p->isMatch[p->state][posState] ^ ((1 << 11) - 1)) >> 4];
#line 1022
  repMatchPrice = matchPrice + p->ProbPrices[((int )p->isRep[p->state] ^ ((1 << 11) - 1)) >> 4];
#line 1024
  if ((int )matchByte == (int )curByte) {
    {
#line 1026
    tmp___4 = GetRepLen1Price(p, p->state, posState);
#line 1026
    shortRepPrice = repMatchPrice + tmp___4;
    }
#line 1027
    if (shortRepPrice < p->opt[1].price) {
#line 1029
      p->opt[1].price = shortRepPrice;
#line 1030
      p->opt[1].backPrev = (UInt32 )0;
#line 1030
      p->opt[1].prev1IsChar = 0;
    }
  }
#line 1033
  if (mainLen >= repLens[repMaxIndex]) {
#line 1033
    lenEnd = mainLen;
  } else {
#line 1033
    lenEnd = repLens[repMaxIndex];
  }
#line 1035
  if (lenEnd < 2U) {
#line 1037
    *backRes = p->opt[1].backPrev;
#line 1038
    return ((UInt32 )1);
  }
#line 1041
  p->opt[1].posPrev = (UInt32 )0;
#line 1042
  i = (UInt32 )0;
  {
#line 1042
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1042
    if (! (i < 4U)) {
#line 1042
      goto while_break___1;
    }
#line 1043
    p->opt[0].backs[i] = reps[i];
#line 1042
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1045
  len = lenEnd;
  {
#line 1046
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1047
    tmp___5 = len;
#line 1047
    len --;
#line 1047
    p->opt[tmp___5].price = (UInt32 )(1 << 30);
#line 1046
    if (! (len >= 2U)) {
#line 1046
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1050
  i = (UInt32 )0;
  {
#line 1050
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1050
    if (! (i < 4U)) {
#line 1050
      goto while_break___3;
    }
#line 1052
    repLen = repLens[i];
#line 1054
    if (repLen < 2U) {
#line 1055
      goto __Cont___0;
    }
    {
#line 1056
    tmp___6 = GetPureRepPrice(p, i, p->state, posState);
#line 1056
    price = repMatchPrice + tmp___6;
    }
    {
#line 1057
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1059
      curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2U];
#line 1060
      opt___0 = & p->opt[repLen];
#line 1061
      if (curAndLenPrice < opt___0->price) {
#line 1063
        opt___0->price = curAndLenPrice;
#line 1064
        opt___0->posPrev = (UInt32 )0;
#line 1065
        opt___0->backPrev = i;
#line 1066
        opt___0->prev1IsChar = 0;
      }
#line 1057
      repLen --;
#line 1057
      if (! (repLen >= 2U)) {
#line 1057
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 1050
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1072
  normalMatchPrice = matchPrice + p->ProbPrices[(int )p->isRep[p->state] >> 4];
#line 1074
  if (repLens[0] >= 2U) {
#line 1074
    len = repLens[0] + 1U;
  } else {
#line 1074
    len = (UInt32 )2;
  }
#line 1075
  if (len <= mainLen) {
#line 1077
    offs = (UInt32 )0;
    {
#line 1078
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1078
      if (! (len > *(matches + offs))) {
#line 1078
        goto while_break___5;
      }
#line 1079
      offs += 2U;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1080
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1083
      distance = *(matches + (offs + 1U));
#line 1085
      curAndLenPrice___0 = normalMatchPrice + p->lenEnc.prices[posState][len - 2U];
#line 1086
      if (len < 5U) {
#line 1086
        tmp___7 = len - 2U;
      } else {
#line 1086
        tmp___7 = (UInt32 )3;
      }
#line 1086
      lenToPosState = tmp___7;
#line 1087
      if (distance < (UInt32 )(1 << (14 >> 1))) {
#line 1088
        curAndLenPrice___0 += p->distancesPrices[lenToPosState][distance];
      } else {
#line 1092
        i___0 = 6U + ((unsigned int )((9 + (int )sizeof(size_t ) / 2) - 1) & (0U - ((((1U << ((9 + (int )sizeof(size_t ) / 2) + 6)) - 1U) - distance) >> 31)));
#line 1092
        slot = (UInt32 )p->g_FastPos[distance >> i___0] + i___0 * 2U;
#line 1093
        curAndLenPrice___0 += p->alignPrices[distance & (unsigned int )((1 << 4) - 1)] + p->posSlotPrices[lenToPosState][slot];
      }
#line 1095
      opt___1 = & p->opt[len];
#line 1096
      if (curAndLenPrice___0 < opt___1->price) {
#line 1098
        opt___1->price = curAndLenPrice___0;
#line 1099
        opt___1->posPrev = (UInt32 )0;
#line 1100
        opt___1->backPrev = distance + 4U;
#line 1101
        opt___1->prev1IsChar = 0;
      }
#line 1103
      if (len == *(matches + offs)) {
#line 1105
        offs += 2U;
#line 1106
        if (offs == numPairs) {
#line 1107
          goto while_break___6;
        }
      }
#line 1080
      len ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1112
  cur = (UInt32 )0;
  {
#line 1124
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1134
    cur ++;
#line 1135
    if (cur == lenEnd) {
      {
#line 1136
      tmp___8 = Backward(p, backRes, cur);
      }
#line 1136
      return (tmp___8);
    }
    {
#line 1138
    newLen = ReadMatchDistances(p, & numPairs___0);
    }
#line 1139
    if (newLen >= p->numFastBytes) {
      {
#line 1141
      p->numPairs = numPairs___0;
#line 1142
      p->longestMatchLength = newLen;
#line 1143
      tmp___9 = Backward(p, backRes, cur);
      }
#line 1143
      return (tmp___9);
    }
#line 1145
    position ++;
#line 1146
    curOpt = & p->opt[cur];
#line 1147
    posPrev = curOpt->posPrev;
#line 1148
    if (curOpt->prev1IsChar) {
#line 1150
      posPrev --;
#line 1151
      if (curOpt->prev2) {
#line 1153
        state = p->opt[curOpt->posPrev2].state;
#line 1154
        if (curOpt->backPrev2 < 4U) {
#line 1155
          state = (UInt32 )kRepNextStates[state];
        } else {
#line 1157
          state = (UInt32 )kMatchNextStates[state];
        }
      } else {
#line 1160
        state = p->opt[posPrev].state;
      }
#line 1161
      state = (UInt32 )kLiteralNextStates[state];
    } else {
#line 1164
      state = p->opt[posPrev].state;
    }
#line 1165
    if (posPrev == cur - 1U) {
#line 1167
      if (curOpt->backPrev == 0U) {
#line 1168
        state = (UInt32 )kShortRepNextStates[state];
      } else {
#line 1170
        state = (UInt32 )kLiteralNextStates[state];
      }
    } else {
#line 1176
      if (curOpt->prev1IsChar) {
#line 1176
        if (curOpt->prev2) {
#line 1178
          posPrev = curOpt->posPrev2;
#line 1179
          pos = curOpt->backPrev2;
#line 1180
          state = (UInt32 )kRepNextStates[state];
        } else {
#line 1176
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1184
        pos = curOpt->backPrev;
#line 1185
        if (pos < 4U) {
#line 1186
          state = (UInt32 )kRepNextStates[state];
        } else {
#line 1188
          state = (UInt32 )kMatchNextStates[state];
        }
      }
#line 1190
      prevOpt = (COptimal const   *)(& p->opt[posPrev]);
#line 1191
      if (pos < 4U) {
#line 1194
        reps[0] = prevOpt->backs[pos];
#line 1195
        i___1 = (UInt32 )1;
        {
#line 1195
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1195
          if (! (i___1 <= pos)) {
#line 1195
            goto while_break___8;
          }
#line 1196
          reps[i___1] = prevOpt->backs[i___1 - 1U];
#line 1195
          i___1 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 1197
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1197
          if (! (i___1 < 4U)) {
#line 1197
            goto while_break___9;
          }
#line 1198
          reps[i___1] = prevOpt->backs[i___1];
#line 1197
          i___1 ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      } else {
#line 1203
        reps[0] = pos - 4U;
#line 1204
        i___2 = (UInt32 )1;
        {
#line 1204
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1204
          if (! (i___2 < 4U)) {
#line 1204
            goto while_break___10;
          }
#line 1205
          reps[i___2] = prevOpt->backs[i___2 - 1U];
#line 1204
          i___2 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    {
#line 1208
    curOpt->state = state;
#line 1210
    curOpt->backs[0] = reps[0];
#line 1211
    curOpt->backs[1] = reps[1];
#line 1212
    curOpt->backs[2] = reps[2];
#line 1213
    curOpt->backs[3] = reps[3];
#line 1215
    curPrice = curOpt->price;
#line 1216
    nextIsChar = 0;
#line 1217
    tmp___10 = (*(p->matchFinder.GetPointerToCurrentPos))(p->matchFinderObj);
#line 1217
    data___0 = tmp___10 - 1;
#line 1218
    curByte___0 = (Byte )*data___0;
#line 1219
    matchByte___0 = (Byte )*(data___0 - (reps[0] + 1U));
#line 1221
    posState___0 = position & p->pbMask;
#line 1223
    curAnd1Price = curPrice + p->ProbPrices[(int )p->isMatch[state][posState___0] >> 4];
#line 1225
    probs___0 = (UInt16 const   *)(p->litProbs + (((position & p->lpMask) << p->lc) + (unsigned int )((int const   )*(data___0 - 1) >> (8U - p->lc))) * 768U);
    }
#line 1226
    if (! (state < 7U)) {
      {
#line 1226
      tmp___11 = LitEnc_GetPriceMatched(probs___0, (UInt32 )curByte___0, (UInt32 )matchByte___0,
                                        p->ProbPrices);
#line 1226
      tmp___13 = tmp___11;
      }
    } else {
      {
#line 1226
      tmp___12 = LitEnc_GetPrice(probs___0, (UInt32 )curByte___0, p->ProbPrices);
#line 1226
      tmp___13 = tmp___12;
      }
    }
#line 1226
    curAnd1Price += tmp___13;
#line 1232
    nextOpt = & p->opt[cur + 1U];
#line 1234
    if (curAnd1Price < nextOpt->price) {
#line 1236
      nextOpt->price = curAnd1Price;
#line 1237
      nextOpt->posPrev = cur;
#line 1238
      nextOpt->backPrev = (UInt32 )-1;
#line 1238
      nextOpt->prev1IsChar = 0;
#line 1239
      nextIsChar = 1;
    }
#line 1242
    matchPrice___0 = curPrice + p->ProbPrices[((int )p->isMatch[state][posState___0] ^ ((1 << 11) - 1)) >> 4];
#line 1243
    repMatchPrice___0 = matchPrice___0 + p->ProbPrices[((int )p->isRep[state] ^ ((1 << 11) - 1)) >> 4];
#line 1245
    if ((int )matchByte___0 == (int )curByte___0) {
#line 1245
      if (nextOpt->posPrev < cur) {
#line 1245
        if (! (nextOpt->backPrev == 0U)) {
#line 1245
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1247
        tmp___14 = GetRepLen1Price(p, state, posState___0);
#line 1247
        shortRepPrice___0 = repMatchPrice___0 + tmp___14;
        }
#line 1248
        if (shortRepPrice___0 <= nextOpt->price) {
#line 1250
          nextOpt->price = shortRepPrice___0;
#line 1251
          nextOpt->posPrev = cur;
#line 1252
          nextOpt->backPrev = (UInt32 )0;
#line 1252
          nextOpt->prev1IsChar = 0;
#line 1253
          nextIsChar = 1;
        }
      }
    }
#line 1256
    numAvailFull = p->numAvail;
#line 1258
    temp = (UInt32 )((1 << 12) - 1) - cur;
#line 1259
    if (temp < numAvailFull) {
#line 1260
      numAvailFull = temp;
    }
#line 1263
    if (numAvailFull < 2U) {
#line 1264
      goto __Cont___1;
    }
#line 1265
    if (numAvailFull <= p->numFastBytes) {
#line 1265
      numAvail = numAvailFull;
    } else {
#line 1265
      numAvail = p->numFastBytes;
    }
#line 1267
    if (! nextIsChar) {
#line 1267
      if ((int )matchByte___0 != (int )curByte___0) {
#line 1272
        data2___0 = data___0 - (reps[0] + 1U);
#line 1273
        limit = p->numFastBytes + 1U;
#line 1274
        if (limit > numAvailFull) {
#line 1275
          limit = numAvailFull;
        }
#line 1277
        temp___0 = (UInt32 )1;
        {
#line 1277
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1277
          if (temp___0 < limit) {
#line 1277
            if (! ((int const   )*(data___0 + temp___0) == (int const   )*(data2___0 + temp___0))) {
#line 1277
              goto while_break___11;
            }
          } else {
#line 1277
            goto while_break___11;
          }
#line 1277
          temp___0 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1278
        lenTest2 = temp___0 - 1U;
#line 1279
        if (lenTest2 >= 2U) {
#line 1281
          state2 = (UInt32 )kLiteralNextStates[state];
#line 1282
          posStateNext = (position + 1U) & p->pbMask;
#line 1283
          nextRepMatchPrice = (curAnd1Price + p->ProbPrices[((int )p->isMatch[state2][posStateNext] ^ ((1 << 11) - 1)) >> 4]) + p->ProbPrices[((int )p->isRep[state2] ^ ((1 << 11) - 1)) >> 4];
#line 1290
          offset = (cur + 1U) + lenTest2;
          {
#line 1291
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 1291
            if (! (lenEnd < offset)) {
#line 1291
              goto while_break___12;
            }
#line 1292
            lenEnd ++;
#line 1292
            p->opt[lenEnd].price = (UInt32 )(1 << 30);
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 1293
          tmp___15 = GetRepPrice(p, (UInt32 )0, lenTest2, state2, posStateNext);
#line 1293
          curAndLenPrice___1 = nextRepMatchPrice + tmp___15;
#line 1294
          opt___2 = & p->opt[offset];
          }
#line 1295
          if (curAndLenPrice___1 < opt___2->price) {
#line 1297
            opt___2->price = curAndLenPrice___1;
#line 1298
            opt___2->posPrev = cur + 1U;
#line 1299
            opt___2->backPrev = (UInt32 )0;
#line 1300
            opt___2->prev1IsChar = 1;
#line 1301
            opt___2->prev2 = 0;
          }
        }
      }
    }
#line 1307
    startLen = (UInt32 )2;
#line 1310
    repIndex = (UInt32 )0;
    {
#line 1310
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1310
      if (! (repIndex < 4U)) {
#line 1310
        goto while_break___13;
      }
#line 1315
      data2___1 = data___0 - (reps[repIndex] + 1U);
#line 1316
      if ((int const   )*(data___0 + 0) != (int const   )*(data2___1 + 0)) {
#line 1317
        goto __Cont___2;
      } else
#line 1316
      if ((int const   )*(data___0 + 1) != (int const   )*(data2___1 + 1)) {
#line 1317
        goto __Cont___2;
      }
#line 1318
      lenTest___0 = (UInt32 )2;
      {
#line 1318
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1318
        if (lenTest___0 < numAvail) {
#line 1318
          if (! ((int const   )*(data___0 + lenTest___0) == (int const   )*(data2___1 + lenTest___0))) {
#line 1318
            goto while_break___14;
          }
        } else {
#line 1318
          goto while_break___14;
        }
#line 1318
        lenTest___0 ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 1319
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1319
        if (! (lenEnd < cur + lenTest___0)) {
#line 1319
          goto while_break___15;
        }
#line 1320
        lenEnd ++;
#line 1320
        p->opt[lenEnd].price = (UInt32 )(1 << 30);
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 1321
      lenTestTemp = lenTest___0;
#line 1322
      tmp___16 = GetPureRepPrice(p, repIndex, state, posState___0);
#line 1322
      price___0 = repMatchPrice___0 + tmp___16;
      }
      {
#line 1323
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1325
        curAndLenPrice___2 = price___0 + p->repLenEnc.prices[posState___0][lenTest___0 - 2U];
#line 1326
        opt___3 = & p->opt[cur + lenTest___0];
#line 1327
        if (curAndLenPrice___2 < opt___3->price) {
#line 1329
          opt___3->price = curAndLenPrice___2;
#line 1330
          opt___3->posPrev = cur;
#line 1331
          opt___3->backPrev = repIndex;
#line 1332
          opt___3->prev1IsChar = 0;
        }
#line 1323
        lenTest___0 --;
#line 1323
        if (! (lenTest___0 >= 2U)) {
#line 1323
          goto while_break___16;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
#line 1336
      lenTest___0 = lenTestTemp;
#line 1338
      if (repIndex == 0U) {
#line 1339
        startLen = lenTest___0 + 1U;
      }
#line 1343
      lenTest2___0 = lenTest___0 + 1U;
#line 1344
      limit___0 = lenTest2___0 + p->numFastBytes;
#line 1346
      if (limit___0 > numAvailFull) {
#line 1347
        limit___0 = numAvailFull;
      }
      {
#line 1348
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 1348
        if (lenTest2___0 < limit___0) {
#line 1348
          if (! ((int const   )*(data___0 + lenTest2___0) == (int const   )*(data2___1 + lenTest2___0))) {
#line 1348
            goto while_break___17;
          }
        } else {
#line 1348
          goto while_break___17;
        }
#line 1348
        lenTest2___0 ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 1349
      lenTest2___0 -= lenTest___0 + 1U;
#line 1350
      if (lenTest2___0 >= 2U) {
        {
#line 1352
        state2___0 = (UInt32 )kRepNextStates[state];
#line 1353
        posStateNext___0 = (position + lenTest___0) & p->pbMask;
#line 1354
        tmp___17 = LitEnc_GetPriceMatched((UInt16 const   *)(p->litProbs + ((((position + lenTest___0) & p->lpMask) << p->lc) + (unsigned int )((int const   )*(data___0 + (lenTest___0 - 1U)) >> (8U - p->lc))) * 768U),
                                          (UInt32 )*(data___0 + lenTest___0), (UInt32 )*(data2___1 + lenTest___0),
                                          p->ProbPrices);
#line 1354
        curAndLenCharPrice = ((price___0 + p->repLenEnc.prices[posState___0][lenTest___0 - 2U]) + p->ProbPrices[(int )p->isMatch[state2___0][posStateNext___0] >> 4]) + tmp___17;
#line 1359
        state2___0 = (UInt32 )kLiteralNextStates[state2___0];
#line 1360
        posStateNext___0 = ((position + lenTest___0) + 1U) & p->pbMask;
#line 1361
        nextRepMatchPrice___0 = (curAndLenCharPrice + p->ProbPrices[((int )p->isMatch[state2___0][posStateNext___0] ^ ((1 << 11) - 1)) >> 4]) + p->ProbPrices[((int )p->isRep[state2___0] ^ ((1 << 11) - 1)) >> 4];
#line 1369
        offset___0 = ((cur + lenTest___0) + 1U) + lenTest2___0;
        }
        {
#line 1370
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 1370
          if (! (lenEnd < offset___0)) {
#line 1370
            goto while_break___18;
          }
#line 1371
          lenEnd ++;
#line 1371
          p->opt[lenEnd].price = (UInt32 )(1 << 30);
        }
        while_break___18: /* CIL Label */ ;
        }
        {
#line 1372
        tmp___18 = GetRepPrice(p, (UInt32 )0, lenTest2___0, state2___0, posStateNext___0);
#line 1372
        curAndLenPrice___3 = nextRepMatchPrice___0 + tmp___18;
#line 1373
        opt___4 = & p->opt[offset___0];
        }
#line 1374
        if (curAndLenPrice___3 < opt___4->price) {
#line 1376
          opt___4->price = curAndLenPrice___3;
#line 1377
          opt___4->posPrev = (cur + lenTest___0) + 1U;
#line 1378
          opt___4->backPrev = (UInt32 )0;
#line 1379
          opt___4->prev1IsChar = 1;
#line 1380
          opt___4->prev2 = 1;
#line 1381
          opt___4->posPrev2 = cur;
#line 1382
          opt___4->backPrev2 = repIndex;
        }
      }
      __Cont___2: /* CIL Label */ 
#line 1310
      repIndex ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1390
    if (newLen > numAvail) {
#line 1392
      newLen = numAvail;
#line 1393
      numPairs___0 = (UInt32 )0;
      {
#line 1393
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 1393
        if (! (newLen > *(matches + numPairs___0))) {
#line 1393
          goto while_break___19;
        }
#line 1393
        numPairs___0 += 2U;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 1394
      *(matches + numPairs___0) = newLen;
#line 1395
      numPairs___0 += 2U;
    }
#line 1397
    if (newLen >= startLen) {
#line 1399
      normalMatchPrice___0 = matchPrice___0 + p->ProbPrices[(int )p->isRep[state] >> 4];
      {
#line 1402
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 1402
        if (! (lenEnd < cur + newLen)) {
#line 1402
          goto while_break___20;
        }
#line 1403
        lenEnd ++;
#line 1403
        p->opt[lenEnd].price = (UInt32 )(1 << 30);
      }
      while_break___20: /* CIL Label */ ;
      }
#line 1405
      offs___0 = (UInt32 )0;
      {
#line 1406
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 1406
        if (! (startLen > *(matches + offs___0))) {
#line 1406
          goto while_break___21;
        }
#line 1407
        offs___0 += 2U;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 1408
      curBack = *(matches + (offs___0 + 1U));
#line 1409
      i___3 = 6U + ((unsigned int )((9 + (int )sizeof(size_t ) / 2) - 1) & (0U - ((((1U << ((9 + (int )sizeof(size_t ) / 2) + 6)) - 1U) - curBack) >> 31)));
#line 1409
      posSlot = (UInt32 )p->g_FastPos[curBack >> i___3] + i___3 * 2U;
#line 1410
      lenTest___1 = startLen;
      {
#line 1410
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 1412
        curAndLenPrice___4 = normalMatchPrice___0 + p->lenEnc.prices[posState___0][lenTest___1 - 2U];
#line 1413
        if (lenTest___1 < 5U) {
#line 1413
          tmp___19 = lenTest___1 - 2U;
        } else {
#line 1413
          tmp___19 = (UInt32 )3;
        }
#line 1413
        lenToPosState___0 = tmp___19;
#line 1415
        if (curBack < (UInt32 )(1 << (14 >> 1))) {
#line 1416
          curAndLenPrice___4 += p->distancesPrices[lenToPosState___0][curBack];
        } else {
#line 1418
          curAndLenPrice___4 += p->posSlotPrices[lenToPosState___0][posSlot] + p->alignPrices[curBack & (unsigned int )((1 << 4) - 1)];
        }
#line 1420
        opt___5 = & p->opt[cur + lenTest___1];
#line 1421
        if (curAndLenPrice___4 < opt___5->price) {
#line 1423
          opt___5->price = curAndLenPrice___4;
#line 1424
          opt___5->posPrev = cur;
#line 1425
          opt___5->backPrev = curBack + 4U;
#line 1426
          opt___5->prev1IsChar = 0;
        }
#line 1429
        if (lenTest___1 == *(matches + offs___0)) {
#line 1432
          data2___2 = data___0 - (curBack + 1U);
#line 1433
          lenTest2___1 = lenTest___1 + 1U;
#line 1434
          limit___1 = lenTest2___1 + p->numFastBytes;
#line 1436
          if (limit___1 > numAvailFull) {
#line 1437
            limit___1 = numAvailFull;
          }
          {
#line 1438
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 1438
            if (lenTest2___1 < limit___1) {
#line 1438
              if (! ((int const   )*(data___0 + lenTest2___1) == (int const   )*(data2___2 + lenTest2___1))) {
#line 1438
                goto while_break___23;
              }
            } else {
#line 1438
              goto while_break___23;
            }
#line 1438
            lenTest2___1 ++;
          }
          while_break___23: /* CIL Label */ ;
          }
#line 1439
          lenTest2___1 -= lenTest___1 + 1U;
#line 1440
          if (lenTest2___1 >= 2U) {
            {
#line 1442
            state2___1 = (UInt32 )kMatchNextStates[state];
#line 1443
            posStateNext___1 = (position + lenTest___1) & p->pbMask;
#line 1444
            tmp___20 = LitEnc_GetPriceMatched((UInt16 const   *)(p->litProbs + ((((position + lenTest___1) & p->lpMask) << p->lc) + (unsigned int )((int const   )*(data___0 + (lenTest___1 - 1U)) >> (8U - p->lc))) * 768U),
                                              (UInt32 )*(data___0 + lenTest___1),
                                              (UInt32 )*(data2___2 + lenTest___1),
                                              p->ProbPrices);
#line 1444
            curAndLenCharPrice___0 = (curAndLenPrice___4 + p->ProbPrices[(int )p->isMatch[state2___1][posStateNext___1] >> 4]) + tmp___20;
#line 1448
            state2___1 = (UInt32 )kLiteralNextStates[state2___1];
#line 1449
            posStateNext___1 = (posStateNext___1 + 1U) & p->pbMask;
#line 1450
            nextRepMatchPrice___1 = (curAndLenCharPrice___0 + p->ProbPrices[((int )p->isMatch[state2___1][posStateNext___1] ^ ((1 << 11) - 1)) >> 4]) + p->ProbPrices[((int )p->isRep[state2___1] ^ ((1 << 11) - 1)) >> 4];
#line 1456
            offset___1 = ((cur + lenTest___1) + 1U) + lenTest2___1;
            }
            {
#line 1459
            while (1) {
              while_continue___24: /* CIL Label */ ;
#line 1459
              if (! (lenEnd < offset___1)) {
#line 1459
                goto while_break___24;
              }
#line 1460
              lenEnd ++;
#line 1460
              p->opt[lenEnd].price = (UInt32 )(1 << 30);
            }
            while_break___24: /* CIL Label */ ;
            }
            {
#line 1461
            tmp___21 = GetRepPrice(p, (UInt32 )0, lenTest2___1, state2___1, posStateNext___1);
#line 1461
            curAndLenPrice___5 = nextRepMatchPrice___1 + tmp___21;
#line 1462
            opt___6 = & p->opt[offset___1];
            }
#line 1463
            if (curAndLenPrice___5 < opt___6->price) {
#line 1465
              opt___6->price = curAndLenPrice___5;
#line 1466
              opt___6->posPrev = (cur + lenTest___1) + 1U;
#line 1467
              opt___6->backPrev = (UInt32 )0;
#line 1468
              opt___6->prev1IsChar = 1;
#line 1469
              opt___6->prev2 = 1;
#line 1470
              opt___6->posPrev2 = cur;
#line 1471
              opt___6->backPrev2 = curBack + 4U;
            }
          }
#line 1475
          offs___0 += 2U;
#line 1476
          if (offs___0 == numPairs___0) {
#line 1477
            goto while_break___22;
          }
#line 1478
          curBack = *(matches + (offs___0 + 1U));
#line 1479
          if (curBack >= (UInt32 )(1 << (14 >> 1))) {
#line 1480
            i___4 = 6U + ((unsigned int )((9 + (int )sizeof(size_t ) / 2) - 1) & (0U - ((((1U << ((9 + (int )sizeof(size_t ) / 2) + 6)) - 1U) - curBack) >> 31)));
#line 1480
            posSlot = (UInt32 )p->g_FastPos[curBack >> i___4] + i___4 * 2U;
          }
        }
#line 1410
        lenTest___1 ++;
      }
      while_break___22: /* CIL Label */ ;
      }
    }
    __Cont___1: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
}
}
#line 1489 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static UInt32 GetOptimumFast(CLzmaEnc *p , UInt32 *backRes ) 
{ 
  UInt32 numAvail ;
  UInt32 mainLen ;
  UInt32 mainDist ;
  UInt32 numPairs ;
  UInt32 repIndex ;
  UInt32 repLen ;
  UInt32 i ;
  Byte const   *data ;
  UInt32 const   *matches ;
  Byte const   *tmp ;
  UInt32 len ;
  Byte const   *data2 ;
  UInt32 newDistance ;
  Byte const   *tmp___0 ;
  UInt32 len___0 ;
  UInt32 limit ;
  Byte const   *data2___0 ;

  {
#line 1495
  if (p->additionalOffset == 0U) {
    {
#line 1496
    mainLen = ReadMatchDistances(p, & numPairs);
    }
  } else {
#line 1499
    mainLen = p->longestMatchLength;
#line 1500
    numPairs = p->numPairs;
  }
#line 1503
  numAvail = p->numAvail;
#line 1504
  *backRes = (UInt32 )-1;
#line 1505
  if (numAvail < 2U) {
#line 1506
    return ((UInt32 )1);
  }
#line 1507
  if (numAvail > (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1)) {
#line 1508
    numAvail = (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1);
  }
  {
#line 1509
  tmp = (*(p->matchFinder.GetPointerToCurrentPos))(p->matchFinderObj);
#line 1509
  data = tmp - 1;
#line 1511
  repIndex = (UInt32 )0;
#line 1511
  repLen = repIndex;
#line 1512
  i = (UInt32 )0;
  }
  {
#line 1512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1512
    if (! (i < 4U)) {
#line 1512
      goto while_break;
    }
#line 1515
    data2 = data - (p->reps[i] + 1U);
#line 1516
    if ((int const   )*(data + 0) != (int const   )*(data2 + 0)) {
#line 1517
      goto __Cont;
    } else
#line 1516
    if ((int const   )*(data + 1) != (int const   )*(data2 + 1)) {
#line 1517
      goto __Cont;
    }
#line 1518
    len = (UInt32 )2;
    {
#line 1518
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1518
      if (len < numAvail) {
#line 1518
        if (! ((int const   )*(data + len) == (int const   )*(data2 + len))) {
#line 1518
          goto while_break___0;
        }
      } else {
#line 1518
        goto while_break___0;
      }
#line 1518
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1519
    if (len >= p->numFastBytes) {
      {
#line 1521
      *backRes = i;
#line 1522
      MovePos(p, len - 1U);
      }
#line 1523
      return (len);
    }
#line 1525
    if (len > repLen) {
#line 1527
      repIndex = i;
#line 1528
      repLen = len;
    }
    __Cont: /* CIL Label */ 
#line 1512
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1532
  matches = (UInt32 const   *)(p->matches);
#line 1533
  if (mainLen >= p->numFastBytes) {
    {
#line 1535
    *backRes = (UInt32 )(*(matches + (numPairs - 1U)) + 4U);
#line 1536
    MovePos(p, mainLen - 1U);
    }
#line 1537
    return (mainLen);
  }
#line 1540
  mainDist = (UInt32 )0;
#line 1541
  if (mainLen >= 2U) {
#line 1543
    mainDist = (UInt32 )*(matches + (numPairs - 1U));
    {
#line 1544
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1544
      if (numPairs > 2U) {
#line 1544
        if (! (mainLen == (UInt32 )(*(matches + (numPairs - 4U)) + 1U))) {
#line 1544
          goto while_break___1;
        }
      } else {
#line 1544
        goto while_break___1;
      }
#line 1546
      if (! (mainDist >> 7 > (UInt32 )*(matches + (numPairs - 3U)))) {
#line 1547
        goto while_break___1;
      }
#line 1548
      numPairs -= 2U;
#line 1549
      mainLen = (UInt32 )*(matches + (numPairs - 2U));
#line 1550
      mainDist = (UInt32 )*(matches + (numPairs - 1U));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1552
    if (mainLen == 2U) {
#line 1552
      if (mainDist >= 128U) {
#line 1553
        mainLen = (UInt32 )1;
      }
    }
  }
#line 1556
  if (repLen >= 2U) {
#line 1556
    if (repLen + 1U >= mainLen) {
      {
#line 1561
      *backRes = repIndex;
#line 1562
      MovePos(p, repLen - 1U);
      }
#line 1563
      return (repLen);
    } else
#line 1556
    if (repLen + 2U >= mainLen) {
#line 1556
      if (mainDist >= (UInt32 )(1 << 9)) {
        {
#line 1561
        *backRes = repIndex;
#line 1562
        MovePos(p, repLen - 1U);
        }
#line 1563
        return (repLen);
      } else {
#line 1556
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1556
    if (repLen + 3U >= mainLen) {
#line 1556
      if (mainDist >= (UInt32 )(1 << 15)) {
        {
#line 1561
        *backRes = repIndex;
#line 1562
        MovePos(p, repLen - 1U);
        }
#line 1563
        return (repLen);
      }
    }
  }
#line 1566
  if (mainLen < 2U) {
#line 1567
    return ((UInt32 )1);
  } else
#line 1566
  if (numAvail <= 2U) {
#line 1567
    return ((UInt32 )1);
  }
  {
#line 1569
  p->longestMatchLength = ReadMatchDistances(p, & p->numPairs);
  }
#line 1570
  if (p->longestMatchLength >= 2U) {
#line 1572
    newDistance = (UInt32 )*(matches + (p->numPairs - 1U));
#line 1573
    if (p->longestMatchLength >= mainLen) {
#line 1573
      if (newDistance < mainDist) {
#line 1577
        return ((UInt32 )1);
      } else {
#line 1573
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1573
    if (p->longestMatchLength == mainLen + 1U) {
#line 1573
      if (! (newDistance >> 7 > mainDist)) {
#line 1577
        return ((UInt32 )1);
      } else {
#line 1573
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1573
    if (p->longestMatchLength > mainLen + 1U) {
#line 1577
      return ((UInt32 )1);
    } else
#line 1573
    if (p->longestMatchLength + 1U >= mainLen) {
#line 1573
      if (mainLen >= 3U) {
#line 1573
        if (mainDist >> 7 > newDistance) {
#line 1577
          return ((UInt32 )1);
        }
      }
    }
  }
  {
#line 1580
  tmp___0 = (*(p->matchFinder.GetPointerToCurrentPos))(p->matchFinderObj);
#line 1580
  data = tmp___0 - 1;
#line 1581
  i = (UInt32 )0;
  }
  {
#line 1581
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1581
    if (! (i < 4U)) {
#line 1581
      goto while_break___2;
    }
#line 1584
    data2___0 = data - (p->reps[i] + 1U);
#line 1585
    if ((int const   )*(data + 0) != (int const   )*(data2___0 + 0)) {
#line 1586
      goto __Cont___0;
    } else
#line 1585
    if ((int const   )*(data + 1) != (int const   )*(data2___0 + 1)) {
#line 1586
      goto __Cont___0;
    }
#line 1587
    limit = mainLen - 1U;
#line 1588
    len___0 = (UInt32 )2;
    {
#line 1588
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1588
      if (len___0 < limit) {
#line 1588
        if (! ((int const   )*(data + len___0) == (int const   )*(data2___0 + len___0))) {
#line 1588
          goto while_break___3;
        }
      } else {
#line 1588
        goto while_break___3;
      }
#line 1588
      len___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1589
    if (len___0 >= limit) {
#line 1590
      return ((UInt32 )1);
    }
    __Cont___0: /* CIL Label */ 
#line 1581
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1592
  *backRes = mainDist + 4U;
#line 1593
  MovePos(p, mainLen - 2U);
  }
#line 1594
  return (mainLen);
}
}
#line 1597 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void WriteEndMarker(CLzmaEnc *p , UInt32 posState ) 
{ 
  UInt32 len ;
  UInt32 tmp ;

  {
  {
#line 1600
  RangeEnc_EncodeBit(& p->rc, & p->isMatch[p->state][posState], (UInt32 )1);
#line 1601
  RangeEnc_EncodeBit(& p->rc, & p->isRep[p->state], (UInt32 )0);
#line 1602
  p->state = (UInt32 )kMatchNextStates[p->state];
#line 1603
  len = (UInt32 )2;
#line 1604
  LenEnc_Encode2(& p->lenEnc, & p->rc, len - 2U, posState, ! p->fastMode, p->ProbPrices);
  }
#line 1605
  if (len < 5U) {
#line 1605
    tmp = len - 2U;
  } else {
#line 1605
    tmp = (UInt32 )3;
  }
  {
#line 1605
  RcTree_Encode(& p->rc, p->posSlotEncoder[tmp], 6, (UInt32 )((1 << 6) - 1));
#line 1606
  RangeEnc_EncodeDirectBits(& p->rc, ((1U << 30) - 1U) >> 4, 26);
#line 1607
  RcTree_ReverseEncode(& p->rc, p->posAlignEncoder, 4, (UInt32 )((1 << 4) - 1));
  }
#line 1608
  return;
}
}
#line 1610 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static SRes CheckErrors(CLzmaEnc *p ) 
{ 


  {
#line 1612
  if (p->result != 0) {
#line 1613
    return (p->result);
  }
#line 1614
  if (p->rc.res != 0) {
#line 1615
    p->result = 9;
  }
#line 1616
  if (p->matchFinderBase.result != 0) {
#line 1617
    p->result = 8;
  }
#line 1618
  if (p->result != 0) {
#line 1619
    p->finished = 1;
  }
#line 1620
  return (p->result);
}
}
#line 1623 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static SRes Flush(CLzmaEnc *p , UInt32 nowPos ) 
{ 
  SRes tmp ;

  {
#line 1626
  p->finished = 1;
#line 1627
  if (p->writeEndMark) {
    {
#line 1628
    WriteEndMarker(p, nowPos & p->pbMask);
    }
  }
  {
#line 1629
  RangeEnc_FlushData(& p->rc);
#line 1630
  RangeEnc_FlushStream(& p->rc);
#line 1631
  tmp = CheckErrors(p);
  }
#line 1631
  return (tmp);
}
}
#line 1634 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void FillAlignPrices(CLzmaEnc *p ) 
{ 
  UInt32 i ;

  {
#line 1637
  i = (UInt32 )0;
  {
#line 1637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1637
    if (! (i < (UInt32 )(1 << 4))) {
#line 1637
      goto while_break;
    }
    {
#line 1638
    p->alignPrices[i] = RcTree_ReverseGetPrice((UInt16 const   *)(p->posAlignEncoder),
                                               4, i, p->ProbPrices);
#line 1637
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1639
  p->alignPriceCount = (UInt32 )0;
#line 1640
  return;
}
}
#line 1642 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void FillDistancesPrices(CLzmaEnc *p ) 
{ 
  UInt32 tempPrices[1 << (14 >> 1)] ;
  UInt32 i ;
  UInt32 lenToPosState ;
  UInt32 posSlot ;
  UInt32 footerBits ;
  UInt32 base ;
  UInt32 posSlot___0 ;
  UInt16 const   *encoder ;
  UInt32 *posSlotPrices ;
  UInt32 *distancesPrices ;
  UInt32 i___0 ;

  {
#line 1646
  i = (UInt32 )4;
  {
#line 1646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1646
    if (! (i < (UInt32 )(1 << (14 >> 1)))) {
#line 1646
      goto while_break;
    }
    {
#line 1648
    posSlot = (UInt32 )p->g_FastPos[i];
#line 1649
    footerBits = (posSlot >> 1) - 1U;
#line 1650
    base = (2U | (posSlot & 1U)) << footerBits;
#line 1651
    tempPrices[i] = RcTree_ReverseGetPrice((UInt16 const   *)(((p->posEncoders + base) - posSlot) - 1),
                                           (int )footerBits, i - base, p->ProbPrices);
#line 1646
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1654
  lenToPosState = (UInt32 )0;
  {
#line 1654
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1654
    if (! (lenToPosState < 4U)) {
#line 1654
      goto while_break___0;
    }
#line 1657
    encoder = (UInt16 const   *)(p->posSlotEncoder[lenToPosState]);
#line 1658
    posSlotPrices = p->posSlotPrices[lenToPosState];
#line 1659
    posSlot___0 = (UInt32 )0;
    {
#line 1659
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1659
      if (! (posSlot___0 < p->distTableSize)) {
#line 1659
        goto while_break___1;
      }
      {
#line 1660
      *(posSlotPrices + posSlot___0) = RcTree_GetPrice(encoder, 6, posSlot___0, p->ProbPrices);
#line 1659
      posSlot___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1661
    posSlot___0 = (UInt32 )14;
    {
#line 1661
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1661
      if (! (posSlot___0 < p->distTableSize)) {
#line 1661
        goto while_break___2;
      }
#line 1662
      *(posSlotPrices + posSlot___0) += (((posSlot___0 >> 1) - 1U) - 4U) << 4;
#line 1661
      posSlot___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1665
    distancesPrices = p->distancesPrices[lenToPosState];
#line 1667
    i___0 = (UInt32 )0;
    {
#line 1667
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1667
      if (! (i___0 < 4U)) {
#line 1667
        goto while_break___3;
      }
#line 1668
      *(distancesPrices + i___0) = *(posSlotPrices + i___0);
#line 1667
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1669
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1669
      if (! (i___0 < (UInt32 )(1 << (14 >> 1)))) {
#line 1669
        goto while_break___4;
      }
#line 1670
      *(distancesPrices + i___0) = *(posSlotPrices + p->g_FastPos[i___0]) + tempPrices[i___0];
#line 1669
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1654
    lenToPosState ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1673
  p->matchPriceCount = (UInt32 )0;
#line 1674
  return;
}
}
#line 1676 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_Construct(CLzmaEnc *p ) 
{ 
  CLzmaEncProps props ;

  {
  {
#line 1678
  RangeEnc_Construct(& p->rc);
#line 1679
  MatchFinder_Construct(& p->matchFinderBase);
#line 1681
  MatchFinderMt_Construct(& p->matchFinderMt);
#line 1682
  p->matchFinderMt.MatchFinder = & p->matchFinderBase;
#line 1687
  LzmaEncProps_Init(& props);
#line 1688
  LzmaEnc_SetProps((CLzmaEncHandle )p, (CLzmaEncProps const   *)(& props));
#line 1692
  LzmaEnc_FastPosInit(p->g_FastPos);
#line 1695
  LzmaEnc_InitPriceTables(p->ProbPrices);
#line 1696
  p->litProbs = (UInt16 *)0;
#line 1697
  p->saveState.litProbs = (UInt16 *)0;
  }
#line 1698
  return;
}
}
#line 1700 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc ) 
{ 
  void *p ;

  {
  {
#line 1703
  p = (*(alloc->Alloc))((void *)alloc, sizeof(CLzmaEnc ));
  }
#line 1704
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 1705
    LzmaEnc_Construct((CLzmaEnc *)p);
    }
  }
#line 1706
  return (p);
}
}
#line 1709 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_FreeLits(CLzmaEnc *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 1711
  (*(alloc->Free))((void *)alloc, (void *)p->litProbs);
#line 1712
  (*(alloc->Free))((void *)alloc, (void *)p->saveState.litProbs);
#line 1713
  p->litProbs = (UInt16 *)0;
#line 1714
  p->saveState.litProbs = (UInt16 *)0;
  }
#line 1715
  return;
}
}
#line 1717 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_Destruct(CLzmaEnc *p , ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 


  {
  {
#line 1720
  MatchFinderMt_Destruct(& p->matchFinderMt, allocBig);
#line 1722
  MatchFinder_Free(& p->matchFinderBase, allocBig);
#line 1723
  LzmaEnc_FreeLits(p, alloc);
#line 1724
  RangeEnc_Free(& p->rc, alloc);
  }
#line 1725
  return;
}
}
#line 1727 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_Destroy(CLzmaEncHandle p , ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 


  {
  {
#line 1729
  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
#line 1730
  (*(alloc->Free))((void *)alloc, p);
  }
#line 1731
  return;
}
}
#line 1733 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p , Bool useLimits , UInt32 maxPackSize ,
                                 UInt32 maxUnpackSize ) 
{ 
  UInt32 nowPos32 ;
  UInt32 startPos32 ;
  int __result__ ;
  SRes tmp ;
  UInt32 numPairs ;
  Byte curByte ;
  SRes tmp___0 ;
  UInt32 tmp___1 ;
  UInt32 pos ;
  UInt32 len ;
  UInt32 posState ;
  Byte curByte___0 ;
  UInt16 *probs ;
  Byte const   *data ;
  Byte const   *tmp___2 ;
  int tmp___3 ;
  UInt32 distance ;
  UInt32 posSlot ;
  UInt32 i ;
  UInt32 tmp___4 ;
  UInt32 footerBits ;
  UInt32 base ;
  UInt32 posReduced ;
  UInt32 processed ;
  UInt32 tmp___5 ;
  SRes tmp___6 ;
  UInt32 tmp___7 ;
  SRes tmp___8 ;

  {
#line 1736
  if (p->needInit) {
    {
#line 1738
    (*(p->matchFinder.Init))(p->matchFinderObj);
#line 1739
    p->needInit = 0;
    }
  }
#line 1742
  if (p->finished) {
#line 1743
    return (p->result);
  }
  {
#line 1744
  tmp = CheckErrors(p);
#line 1744
  __result__ = tmp;
  }
#line 1744
  if (__result__ != 0) {
#line 1744
    return (__result__);
  }
#line 1746
  nowPos32 = (UInt32 )p->nowPos64;
#line 1747
  startPos32 = nowPos32;
#line 1749
  if (p->nowPos64 == 0ULL) {
    {
#line 1753
    tmp___1 = (*(p->matchFinder.GetNumAvailableBytes))(p->matchFinderObj);
    }
#line 1753
    if (tmp___1 == 0U) {
      {
#line 1754
      tmp___0 = Flush(p, nowPos32);
      }
#line 1754
      return (tmp___0);
    }
    {
#line 1755
    ReadMatchDistances(p, & numPairs);
#line 1756
    RangeEnc_EncodeBit(& p->rc, & p->isMatch[p->state][0], (UInt32 )0);
#line 1757
    p->state = (UInt32 )kLiteralNextStates[p->state];
#line 1758
    curByte = (*(p->matchFinder.GetIndexByte))(p->matchFinderObj, (Int32 )(0U - p->additionalOffset));
#line 1759
    LitEnc_Encode(& p->rc, p->litProbs, (UInt32 )curByte);
#line 1760
    (p->additionalOffset) --;
#line 1761
    nowPos32 ++;
    }
  }
  {
#line 1764
  tmp___7 = (*(p->matchFinder.GetNumAvailableBytes))(p->matchFinderObj);
  }
#line 1764
  if (tmp___7 != 0U) {
    {
#line 1765
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1769
      if (p->fastMode) {
        {
#line 1770
        len = GetOptimumFast(p, & pos);
        }
      } else {
        {
#line 1772
        len = GetOptimum(p, nowPos32, & pos);
        }
      }
#line 1778
      posState = nowPos32 & p->pbMask;
#line 1779
      if (len == 1U) {
#line 1779
        if (pos == 4294967295U) {
          {
#line 1785
          RangeEnc_EncodeBit(& p->rc, & p->isMatch[p->state][posState], (UInt32 )0);
#line 1786
          tmp___2 = (*(p->matchFinder.GetPointerToCurrentPos))(p->matchFinderObj);
#line 1786
          data = tmp___2 - p->additionalOffset;
#line 1787
          curByte___0 = (Byte )*data;
#line 1788
          probs = p->litProbs + (((nowPos32 & p->lpMask) << p->lc) + (unsigned int )((int const   )*(data - 1) >> (8U - p->lc))) * 768U;
          }
#line 1789
          if (p->state < 7U) {
            {
#line 1790
            LitEnc_Encode(& p->rc, probs, (UInt32 )curByte___0);
            }
          } else {
            {
#line 1792
            LitEnc_EncodeMatched(& p->rc, probs, (UInt32 )curByte___0, (UInt32 )*((data - p->reps[0]) - 1));
            }
          }
#line 1793
          p->state = (UInt32 )kLiteralNextStates[p->state];
        } else {
#line 1779
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1797
        RangeEnc_EncodeBit(& p->rc, & p->isMatch[p->state][posState], (UInt32 )1);
        }
#line 1798
        if (pos < 4U) {
          {
#line 1800
          RangeEnc_EncodeBit(& p->rc, & p->isRep[p->state], (UInt32 )1);
          }
#line 1801
          if (pos == 0U) {
            {
#line 1803
            RangeEnc_EncodeBit(& p->rc, & p->isRepG0[p->state], (UInt32 )0);
            }
#line 1804
            if (len == 1U) {
#line 1804
              tmp___3 = 0;
            } else {
#line 1804
              tmp___3 = 1;
            }
            {
#line 1804
            RangeEnc_EncodeBit(& p->rc, & p->isRep0Long[p->state][posState], (UInt32 )tmp___3);
            }
          } else {
            {
#line 1808
            distance = p->reps[pos];
#line 1809
            RangeEnc_EncodeBit(& p->rc, & p->isRepG0[p->state], (UInt32 )1);
            }
#line 1810
            if (pos == 1U) {
              {
#line 1811
              RangeEnc_EncodeBit(& p->rc, & p->isRepG1[p->state], (UInt32 )0);
              }
            } else {
              {
#line 1814
              RangeEnc_EncodeBit(& p->rc, & p->isRepG1[p->state], (UInt32 )1);
#line 1815
              RangeEnc_EncodeBit(& p->rc, & p->isRepG2[p->state], pos - 2U);
              }
#line 1816
              if (pos == 3U) {
#line 1817
                p->reps[3] = p->reps[2];
              }
#line 1818
              p->reps[2] = p->reps[1];
            }
#line 1820
            p->reps[1] = p->reps[0];
#line 1821
            p->reps[0] = distance;
          }
#line 1823
          if (len == 1U) {
#line 1824
            p->state = (UInt32 )kShortRepNextStates[p->state];
          } else {
            {
#line 1827
            LenEnc_Encode2(& p->repLenEnc, & p->rc, len - 2U, posState, ! p->fastMode,
                           p->ProbPrices);
#line 1828
            p->state = (UInt32 )kRepNextStates[p->state];
            }
          }
        } else {
          {
#line 1834
          RangeEnc_EncodeBit(& p->rc, & p->isRep[p->state], (UInt32 )0);
#line 1835
          p->state = (UInt32 )kMatchNextStates[p->state];
#line 1836
          LenEnc_Encode2(& p->lenEnc, & p->rc, len - 2U, posState, ! p->fastMode,
                         p->ProbPrices);
#line 1837
          pos -= 4U;
          }
#line 1838
          if (pos < (UInt32 )(1 << (14 >> 1))) {
#line 1838
            posSlot = (UInt32 )p->g_FastPos[pos];
          } else {
#line 1838
            i = 6U + ((unsigned int )((9 + (int )sizeof(size_t ) / 2) - 1) & (0U - ((((1U << ((9 + (int )sizeof(size_t ) / 2) + 6)) - 1U) - pos) >> 31)));
#line 1838
            posSlot = (UInt32 )p->g_FastPos[pos >> i] + i * 2U;
          }
#line 1839
          if (len < 5U) {
#line 1839
            tmp___4 = len - 2U;
          } else {
#line 1839
            tmp___4 = (UInt32 )3;
          }
          {
#line 1839
          RcTree_Encode(& p->rc, p->posSlotEncoder[tmp___4], 6, posSlot);
          }
#line 1841
          if (posSlot >= 4U) {
#line 1843
            footerBits = (posSlot >> 1) - 1U;
#line 1844
            base = (2U | (posSlot & 1U)) << footerBits;
#line 1845
            posReduced = pos - base;
#line 1847
            if (posSlot < 14U) {
              {
#line 1848
              RcTree_ReverseEncode(& p->rc, ((p->posEncoders + base) - posSlot) - 1,
                                   (int )footerBits, posReduced);
              }
            } else {
              {
#line 1851
              RangeEnc_EncodeDirectBits(& p->rc, posReduced >> 4, (int )(footerBits - 4U));
#line 1852
              RcTree_ReverseEncode(& p->rc, p->posAlignEncoder, 4, posReduced & (unsigned int )((1 << 4) - 1));
#line 1853
              (p->alignPriceCount) ++;
              }
            }
          }
#line 1856
          p->reps[3] = p->reps[2];
#line 1857
          p->reps[2] = p->reps[1];
#line 1858
          p->reps[1] = p->reps[0];
#line 1859
          p->reps[0] = pos;
#line 1860
          (p->matchPriceCount) ++;
        }
      }
#line 1863
      p->additionalOffset -= len;
#line 1864
      nowPos32 += len;
#line 1865
      if (p->additionalOffset == 0U) {
#line 1868
        if (! p->fastMode) {
#line 1870
          if (p->matchPriceCount >= (UInt32 )(1 << 7)) {
            {
#line 1871
            FillDistancesPrices(p);
            }
          }
#line 1872
          if (p->alignPriceCount >= (UInt32 )(1 << 4)) {
            {
#line 1873
            FillAlignPrices(p);
            }
          }
        }
        {
#line 1875
        tmp___5 = (*(p->matchFinder.GetNumAvailableBytes))(p->matchFinderObj);
        }
#line 1875
        if (tmp___5 == 0U) {
#line 1876
          goto while_break;
        }
#line 1877
        processed = nowPos32 - startPos32;
#line 1878
        if (useLimits) {
#line 1880
          if ((processed + (UInt32 )(1 << 12)) + 300U >= maxUnpackSize) {
#line 1882
            goto while_break;
          } else
#line 1880
          if (((p->rc.processed + (UInt64 )(p->rc.buf - p->rc.bufBase)) + p->rc.cacheSize) + (UInt64 )((1 << 12) * 2) >= (UInt64 )maxPackSize) {
#line 1882
            goto while_break;
          }
        } else
#line 1884
        if (processed >= (UInt32 )(1 << 15)) {
          {
#line 1886
          p->nowPos64 += (UInt64 )(nowPos32 - startPos32);
#line 1887
          tmp___6 = CheckErrors(p);
          }
#line 1887
          return (tmp___6);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1891
  p->nowPos64 += (UInt64 )(nowPos32 - startPos32);
#line 1892
  tmp___8 = Flush(p, nowPos32);
  }
#line 1892
  return (tmp___8);
}
}
#line 1897 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static SRes LzmaEnc_Alloc(CLzmaEnc *p , UInt32 keepWindowSize , ISzAlloc *alloc ,
                          ISzAlloc *allocBig ) 
{ 
  UInt32 beforeSize ;
  Bool btMode ;
  int tmp ;
  int tmp___0 ;
  unsigned int lclp ;
  void *tmp___1 ;
  void *tmp___2 ;
  int __result__ ;
  SRes tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1899
  beforeSize = (UInt32 )(1 << 12);
#line 1901
  tmp = RangeEnc_Alloc(& p->rc, alloc);
  }
#line 1901
  if (! tmp) {
#line 1902
    return (2);
  }
#line 1903
  btMode = p->matchFinderBase.btMode != 0;
#line 1905
  if (p->multiThread) {
#line 1905
    if (! p->fastMode) {
#line 1905
      if (btMode) {
#line 1905
        tmp___0 = 1;
      } else {
#line 1905
        tmp___0 = 0;
      }
    } else {
#line 1905
      tmp___0 = 0;
    }
  } else {
#line 1905
    tmp___0 = 0;
  }
#line 1905
  p->mtMode = tmp___0;
#line 1909
  lclp = p->lc + p->lp;
#line 1910
  if ((unsigned long )p->litProbs == (unsigned long )((UInt16 *)0)) {
#line 1910
    goto _L;
  } else
#line 1910
  if ((unsigned long )p->saveState.litProbs == (unsigned long )((UInt16 *)0)) {
#line 1910
    goto _L;
  } else
#line 1910
  if (p->lclp != lclp) {
    _L: /* CIL Label */ 
    {
#line 1912
    LzmaEnc_FreeLits(p, alloc);
#line 1913
    tmp___1 = (*(alloc->Alloc))((void *)alloc, (unsigned long )(768 << lclp) * sizeof(UInt16 ));
#line 1913
    p->litProbs = (UInt16 *)tmp___1;
#line 1914
    tmp___2 = (*(alloc->Alloc))((void *)alloc, (unsigned long )(768 << lclp) * sizeof(UInt16 ));
#line 1914
    p->saveState.litProbs = (UInt16 *)tmp___2;
    }
#line 1915
    if ((unsigned long )p->litProbs == (unsigned long )((UInt16 *)0)) {
      {
#line 1917
      LzmaEnc_FreeLits(p, alloc);
      }
#line 1918
      return (2);
    } else
#line 1915
    if ((unsigned long )p->saveState.litProbs == (unsigned long )((UInt16 *)0)) {
      {
#line 1917
      LzmaEnc_FreeLits(p, alloc);
      }
#line 1918
      return (2);
    }
#line 1920
    p->lclp = lclp;
  }
#line 1924
  p->matchFinderBase.bigHash = p->dictSize > 1U << 24;
#line 1926
  if (beforeSize + p->dictSize < keepWindowSize) {
#line 1927
    beforeSize = keepWindowSize - p->dictSize;
  }
#line 1930
  if (p->mtMode) {
    {
#line 1932
    tmp___3 = MatchFinderMt_Create(& p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes,
                                   (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1),
                                   allocBig);
#line 1932
    __result__ = tmp___3;
    }
#line 1932
    if (__result__ != 0) {
#line 1932
      return (__result__);
    }
    {
#line 1933
    p->matchFinderObj = (void *)(& p->matchFinderMt);
#line 1934
    MatchFinderMt_CreateVTable(& p->matchFinderMt, & p->matchFinder);
    }
  } else {
    {
#line 1939
    tmp___4 = MatchFinder_Create(& p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes,
                                 (UInt32 )((2 + (((1 << 3) + (1 << 3)) + (1 << 8))) - 1),
                                 allocBig);
    }
#line 1939
    if (! tmp___4) {
#line 1940
      return (2);
    }
    {
#line 1941
    p->matchFinderObj = (void *)(& p->matchFinderBase);
#line 1942
    MatchFinder_CreateVTable(& p->matchFinderBase, & p->matchFinder);
    }
  }
#line 1944
  return (0);
}
}
#line 1947 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_Init(CLzmaEnc *p ) 
{ 
  UInt32 i ;
  UInt32 j ;
  UInt32 num ;
  UInt16 *probs ;
  UInt32 j___0 ;

  {
#line 1950
  p->state = (UInt32 )0;
#line 1951
  i = (UInt32 )0;
  {
#line 1951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1951
    if (! (i < 4U)) {
#line 1951
      goto while_break;
    }
#line 1952
    p->reps[i] = (UInt32 )0;
#line 1951
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1954
  RangeEnc_Init(& p->rc);
#line 1957
  i = (UInt32 )0;
  }
  {
#line 1957
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1957
    if (! (i < 12U)) {
#line 1957
      goto while_break___0;
    }
#line 1960
    j = (UInt32 )0;
    {
#line 1960
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1960
      if (! (j < (UInt32 )(1 << 4))) {
#line 1960
        goto while_break___1;
      }
#line 1962
      p->isMatch[i][j] = (UInt16 )((1 << 11) >> 1);
#line 1963
      p->isRep0Long[i][j] = (UInt16 )((1 << 11) >> 1);
#line 1960
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1965
    p->isRep[i] = (UInt16 )((1 << 11) >> 1);
#line 1966
    p->isRepG0[i] = (UInt16 )((1 << 11) >> 1);
#line 1967
    p->isRepG1[i] = (UInt16 )((1 << 11) >> 1);
#line 1968
    p->isRepG2[i] = (UInt16 )((1 << 11) >> 1);
#line 1957
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1972
  num = (UInt32 )(768 << (p->lp + p->lc));
#line 1973
  i = (UInt32 )0;
  {
#line 1973
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1973
    if (! (i < num)) {
#line 1973
      goto while_break___2;
    }
#line 1974
    *(p->litProbs + i) = (UInt16 )((1 << 11) >> 1);
#line 1973
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1978
  i = (UInt32 )0;
  {
#line 1978
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1978
    if (! (i < 4U)) {
#line 1978
      goto while_break___3;
    }
#line 1980
    probs = p->posSlotEncoder[i];
#line 1982
    j___0 = (UInt32 )0;
    {
#line 1982
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1982
      if (! (j___0 < (UInt32 )(1 << 6))) {
#line 1982
        goto while_break___4;
      }
#line 1983
      *(probs + j___0) = (UInt16 )((1 << 11) >> 1);
#line 1982
      j___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1978
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1987
  i = (UInt32 )0;
  {
#line 1987
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1987
    if (! (i < (UInt32 )((1 << (14 >> 1)) - 14))) {
#line 1987
      goto while_break___5;
    }
#line 1988
    p->posEncoders[i] = (UInt16 )((1 << 11) >> 1);
#line 1987
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1991
  LenEnc_Init(& p->lenEnc.p);
#line 1992
  LenEnc_Init(& p->repLenEnc.p);
#line 1994
  i = (UInt32 )0;
  }
  {
#line 1994
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1994
    if (! (i < (UInt32 )(1 << 4))) {
#line 1994
      goto while_break___6;
    }
#line 1995
    p->posAlignEncoder[i] = (UInt16 )((1 << 11) >> 1);
#line 1994
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1997
  p->optimumEndIndex = (UInt32 )0;
#line 1998
  p->optimumCurrentIndex = (UInt32 )0;
#line 1999
  p->additionalOffset = (UInt32 )0;
#line 2001
  p->pbMask = (unsigned int )((1 << p->pb) - 1);
#line 2002
  p->lpMask = (unsigned int )((1 << p->lp) - 1);
#line 2003
  return;
}
}
#line 2005 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_InitPrices(CLzmaEnc *p ) 
{ 
  UInt32 tmp ;

  {
#line 2007
  if (! p->fastMode) {
    {
#line 2009
    FillDistancesPrices(p);
#line 2010
    FillAlignPrices(p);
    }
  }
  {
#line 2013
  tmp = (p->numFastBytes + 1U) - 2U;
#line 2013
  p->repLenEnc.tableSize = tmp;
#line 2013
  p->lenEnc.tableSize = tmp;
#line 2016
  LenPriceEnc_UpdateTables(& p->lenEnc, (UInt32 )(1 << p->pb), p->ProbPrices);
#line 2017
  LenPriceEnc_UpdateTables(& p->repLenEnc, (UInt32 )(1 << p->pb), p->ProbPrices);
  }
#line 2018
  return;
}
}
#line 2020 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p , UInt32 keepWindowSize , ISzAlloc *alloc ,
                                 ISzAlloc *allocBig ) 
{ 
  UInt32 i ;
  int __result__ ;
  SRes tmp ;

  {
#line 2023
  i = (UInt32 )0;
  {
#line 2023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2023
    if (! (i < (UInt32 )(((9 + (int )sizeof(size_t ) / 2) - 1) * 2 + 7))) {
#line 2023
      goto while_break;
    }
#line 2024
    if (p->dictSize <= 1U << i) {
#line 2025
      goto while_break;
    }
#line 2023
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2026
  p->distTableSize = i * 2U;
#line 2028
  p->finished = 0;
#line 2029
  p->result = 0;
#line 2030
  tmp = LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig);
#line 2030
  __result__ = tmp;
  }
#line 2030
  if (__result__ != 0) {
#line 2030
    return (__result__);
  }
  {
#line 2031
  LzmaEnc_Init(p);
#line 2032
  LzmaEnc_InitPrices(p);
#line 2033
  p->nowPos64 = (UInt64 )0;
  }
#line 2034
  return (0);
}
}
#line 2037 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static SRes LzmaEnc_Prepare(CLzmaEncHandle pp , ISeqOutStream *outStream , ISeqInStream *inStream ,
                            ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 
  CLzmaEnc *p ;
  SRes tmp ;

  {
  {
#line 2040
  p = (CLzmaEnc *)pp;
#line 2041
  p->matchFinderBase.stream = inStream;
#line 2042
  p->needInit = 1;
#line 2043
  p->rc.outStream = outStream;
#line 2044
  tmp = LzmaEnc_AllocAndInit(p, (UInt32 )0, alloc, allocBig);
  }
#line 2044
  return (tmp);
}
}
#line 2047 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp , ISeqInStream *inStream , UInt32 keepWindowSize ,
                             ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 
  CLzmaEnc *p ;
  SRes tmp ;

  {
  {
#line 2051
  p = (CLzmaEnc *)pp;
#line 2052
  p->matchFinderBase.stream = inStream;
#line 2053
  p->needInit = 1;
#line 2054
  tmp = LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
  }
#line 2054
  return (tmp);
}
}
#line 2057 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static void LzmaEnc_SetInputBuf(CLzmaEnc *p , Byte const   *src , SizeT srcLen ) 
{ 


  {
#line 2059
  p->matchFinderBase.directInput = 1;
#line 2060
  p->matchFinderBase.bufferBase = (Byte *)src;
#line 2061
  p->matchFinderBase.directInputRem = srcLen;
#line 2062
  return;
}
}
#line 2064 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp , Byte const   *src , SizeT srcLen , UInt32 keepWindowSize ,
                        ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 
  CLzmaEnc *p ;
  SRes tmp ;

  {
  {
#line 2067
  p = (CLzmaEnc *)pp;
#line 2068
  LzmaEnc_SetInputBuf(p, src, srcLen);
#line 2069
  p->needInit = 1;
#line 2071
  tmp = LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
  }
#line 2071
  return (tmp);
}
}
#line 2074 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
void LzmaEnc_Finish(CLzmaEncHandle pp ) 
{ 
  CLzmaEnc *p ;

  {
#line 2077
  p = (CLzmaEnc *)pp;
#line 2078
  if (p->mtMode) {
    {
#line 2079
    MatchFinderMt_ReleaseStream(& p->matchFinderMt);
    }
  }
#line 2083
  return;
}
}
#line 2093 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static size_t MyWrite(void *pp , void const   *data , size_t size ) 
{ 
  CSeqOutStreamBuf *p ;

  {
#line 2095
  p = (CSeqOutStreamBuf *)pp;
#line 2096
  if (p->rem < size) {
#line 2098
    size = p->rem;
#line 2099
    p->overflow = 1;
  }
  {
#line 2101
  memcpy((void */* __restrict  */)p->data, (void const   */* __restrict  */)data,
         size);
#line 2102
  p->rem -= size;
#line 2103
  p->data += size;
  }
#line 2104
  return (size);
}
}
#line 2108 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp ) 
{ 
  CLzmaEnc const   *p ;
  UInt32 tmp ;

  {
  {
#line 2110
  p = (CLzmaEnc const   *)((CLzmaEnc *)pp);
#line 2111
  tmp = (*(p->matchFinder.GetNumAvailableBytes))((void *)p->matchFinderObj);
  }
#line 2111
  return (tmp);
}
}
#line 2114 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
Byte const   *LzmaEnc_GetCurBuf(CLzmaEncHandle pp ) 
{ 
  CLzmaEnc const   *p ;
  Byte const   *tmp ;

  {
  {
#line 2116
  p = (CLzmaEnc const   *)((CLzmaEnc *)pp);
#line 2117
  tmp = (*(p->matchFinder.GetPointerToCurrentPos))((void *)p->matchFinderObj);
  }
#line 2117
  return (tmp - p->additionalOffset);
}
}
#line 2120 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp , Bool reInit , Byte *dest , size_t *destLen ,
                             UInt32 desiredPackSize , UInt32 *unpackSize ) 
{ 
  CLzmaEnc *p ;
  UInt64 nowPos64 ;
  SRes res ;
  CSeqOutStreamBuf outStream ;

  {
#line 2123
  p = (CLzmaEnc *)pp;
#line 2128
  outStream.funcTable.Write = & MyWrite;
#line 2129
  outStream.data = dest;
#line 2130
  outStream.rem = *destLen;
#line 2131
  outStream.overflow = 0;
#line 2133
  p->writeEndMark = 0;
#line 2134
  p->finished = 0;
#line 2135
  p->result = 0;
#line 2137
  if (reInit) {
    {
#line 2138
    LzmaEnc_Init(p);
    }
  }
  {
#line 2139
  LzmaEnc_InitPrices(p);
#line 2140
  nowPos64 = p->nowPos64;
#line 2141
  RangeEnc_Init(& p->rc);
#line 2142
  p->rc.outStream = & outStream.funcTable;
#line 2144
  res = LzmaEnc_CodeOneBlock(p, 1, desiredPackSize, *unpackSize);
#line 2146
  *unpackSize = (UInt32 )(p->nowPos64 - nowPos64);
#line 2147
  *destLen -= outStream.rem;
  }
#line 2148
  if (outStream.overflow) {
#line 2149
    return (7);
  }
#line 2151
  return (res);
}
}
#line 2154 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
static SRes LzmaEnc_Encode2(CLzmaEnc *p , ICompressProgress *progress ) 
{ 
  SRes res ;
  Byte allocaDummy[768] ;
  int i ;

  {
#line 2156
  res = 0;
#line 2160
  i = 0;
#line 2161
  i = 0;
  {
#line 2161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2161
    if (! (i < 16)) {
#line 2161
      goto while_break;
    }
#line 2162
    allocaDummy[i] = (Byte )i;
#line 2161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2165
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2167
    res = LzmaEnc_CodeOneBlock(p, 0, (UInt32 )0, (UInt32 )0);
    }
#line 2168
    if (res != 0) {
#line 2169
      goto while_break___0;
    } else
#line 2168
    if (p->finished != 0) {
#line 2169
      goto while_break___0;
    }
#line 2170
    if ((unsigned long )progress != (unsigned long )((ICompressProgress *)0)) {
      {
#line 2172
      res = (*(progress->Progress))((void *)progress, p->nowPos64, (p->rc.processed + (UInt64 )(p->rc.buf - p->rc.bufBase)) + p->rc.cacheSize);
      }
#line 2173
      if (res != 0) {
#line 2175
        res = 10;
#line 2176
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2180
  LzmaEnc_Finish((CLzmaEncHandle )p);
  }
#line 2181
  return (res);
}
}
#line 2184 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEnc_Encode(CLzmaEncHandle pp , ISeqOutStream *outStream , ISeqInStream *inStream ,
                    ICompressProgress *progress , ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 
  int __result__ ;
  SRes tmp ;
  SRes tmp___0 ;

  {
  {
#line 2187
  tmp = LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig);
#line 2187
  __result__ = tmp;
  }
#line 2187
  if (__result__ != 0) {
#line 2187
    return (__result__);
  }
  {
#line 2188
  tmp___0 = LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
  }
#line 2188
  return (tmp___0);
}
}
#line 2191 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp , Byte *props , SizeT *size ) 
{ 
  CLzmaEnc *p ;
  int i ;
  UInt32 dictSize ;

  {
#line 2193
  p = (CLzmaEnc *)pp;
#line 2195
  dictSize = p->dictSize;
#line 2196
  if (*size < 5UL) {
#line 2197
    return (5);
  }
#line 2198
  *size = (SizeT )5;
#line 2199
  *(props + 0) = (Byte )((p->pb * 5U + p->lp) * 9U + p->lc);
#line 2201
  i = 11;
  {
#line 2201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2201
    if (! (i <= 30)) {
#line 2201
      goto while_break;
    }
#line 2203
    if (dictSize <= 2U << i) {
#line 2205
      dictSize = (UInt32 )(2 << i);
#line 2206
      goto while_break;
    }
#line 2208
    if (dictSize <= 3U << i) {
#line 2210
      dictSize = (UInt32 )(3 << i);
#line 2211
      goto while_break;
    }
#line 2201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2215
  i = 0;
  {
#line 2215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2215
    if (! (i < 4)) {
#line 2215
      goto while_break___0;
    }
#line 2216
    *(props + (1 + i)) = (Byte )(dictSize >> 8 * i);
#line 2215
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2217
  return (0);
}
}
#line 2220 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEnc_MemEncode(CLzmaEncHandle pp , Byte *dest , SizeT *destLen , Byte const   *src ,
                       SizeT srcLen , int writeEndMark , ICompressProgress *progress ,
                       ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 
  SRes res ;
  CLzmaEnc *p ;
  CSeqOutStreamBuf outStream ;

  {
  {
#line 2224
  p = (CLzmaEnc *)pp;
#line 2228
  LzmaEnc_SetInputBuf(p, src, srcLen);
#line 2230
  outStream.funcTable.Write = & MyWrite;
#line 2231
  outStream.data = dest;
#line 2232
  outStream.rem = *destLen;
#line 2233
  outStream.overflow = 0;
#line 2235
  p->writeEndMark = writeEndMark;
#line 2237
  p->rc.outStream = & outStream.funcTable;
#line 2238
  res = LzmaEnc_MemPrepare(pp, src, srcLen, (UInt32 )0, alloc, allocBig);
  }
#line 2239
  if (res == 0) {
    {
#line 2240
    res = LzmaEnc_Encode2(p, progress);
    }
  }
#line 2242
  *destLen -= outStream.rem;
#line 2243
  if (outStream.overflow) {
#line 2244
    return (7);
  }
#line 2245
  return (res);
}
}
#line 2248 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaEnc.c"
SRes LzmaEncode(Byte *dest , SizeT *destLen , Byte const   *src , SizeT srcLen , CLzmaEncProps const   *props ,
                Byte *propsEncoded , SizeT *propsSize , int writeEndMark , ICompressProgress *progress ,
                ISzAlloc *alloc , ISzAlloc *allocBig ) 
{ 
  CLzmaEnc *p ;
  CLzmaEncHandle tmp ;
  SRes res ;

  {
  {
#line 2252
  tmp = LzmaEnc_Create(alloc);
#line 2252
  p = (CLzmaEnc *)tmp;
  }
#line 2254
  if ((unsigned long )p == (unsigned long )((CLzmaEnc *)0)) {
#line 2255
    return (2);
  }
  {
#line 2257
  res = LzmaEnc_SetProps((CLzmaEncHandle )p, props);
  }
#line 2258
  if (res == 0) {
    {
#line 2260
    res = LzmaEnc_WriteProperties((CLzmaEncHandle )p, propsEncoded, propsSize);
    }
#line 2261
    if (res == 0) {
      {
#line 2262
      res = LzmaEnc_MemEncode((CLzmaEncHandle )p, dest, destLen, src, srcLen, writeEndMark,
                              progress, alloc, allocBig);
      }
    }
  }
  {
#line 2266
  LzmaEnc_Destroy((CLzmaEncHandle )p, alloc, allocBig);
  }
#line 2267
  return (res);
}
}
#line 93 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
Byte const   PPMD8_kExpEscape[16] ;
#line 105
void Ppmd8_Update1(CPpmd8 *p ) ;
#line 106
void Ppmd8_Update1_0(CPpmd8 *p ) ;
#line 107
void Ppmd8_Update2(CPpmd8 *p ) ;
#line 108
void Ppmd8_UpdateBin(CPpmd8 *p ) ;
#line 115
CPpmd_See *Ppmd8_MakeEscFreq(CPpmd8 *p , unsigned int numMasked1 , UInt32 *escFreq ) ;
#line 120
Bool Ppmd8_RangeDec_Init(CPpmd8 *p ) ;
#line 122
int Ppmd8_DecodeSymbol(CPpmd8 *p ) ;
#line 12 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Dec.c"
Bool Ppmd8_RangeDec_Init(CPpmd8 *p ) 
{ 
  unsigned int i ;
  Byte tmp ;

  {
#line 15
  p->Low = (UInt32 )0;
#line 16
  p->Range = 4294967295U;
#line 17
  p->Code = (UInt32 )0;
#line 18
  i = 0U;
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (i < 4U)) {
#line 18
      goto while_break;
    }
    {
#line 19
    tmp = (*((p->Stream.In)->Read))((void *)p->Stream.In);
#line 19
    p->Code = (p->Code << 8) | (unsigned int )tmp;
#line 18
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return (p->Code < 4294967295U);
}
}
#line 23 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Dec.c"
static UInt32 RangeDec_GetThreshold(CPpmd8 *p , UInt32 total ) 
{ 
  UInt32 tmp ;

  {
#line 25
  tmp = p->Range / total;
#line 25
  p->Range = tmp;
#line 25
  return (p->Code / tmp);
}
}
#line 28 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Dec.c"
static void RangeDec_Decode(CPpmd8 *p , UInt32 start , UInt32 size ) 
{ 
  Byte tmp ;

  {
#line 30
  start *= p->Range;
#line 31
  p->Low += start;
#line 32
  p->Code -= start;
#line 33
  p->Range *= size;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((p->Low ^ (p->Low + p->Range)) < (unsigned int )(1 << 24))) {
#line 35
      if (p->Range < (UInt32 )(1 << 15)) {
#line 35
        p->Range = (0U - p->Low) & (unsigned int )((1 << 15) - 1);
      } else {
#line 35
        goto while_break;
      }
    }
    {
#line 38
    tmp = (*((p->Stream.In)->Read))((void *)p->Stream.In);
#line 38
    p->Code = (p->Code << 8) | (unsigned int )tmp;
#line 39
    p->Range <<= 8;
#line 40
    p->Low <<= 8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Dec.c"
int Ppmd8_DecodeSymbol(CPpmd8 *p ) 
{ 
  size_t charMask[256UL / sizeof(size_t )] ;
  CPpmd_State *s ;
  unsigned int i ;
  UInt32 count ;
  UInt32 hiCnt ;
  Byte symbol ;
  Byte symbol___0 ;
  unsigned int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  UInt16 *prob ;
  Byte symbol___1 ;
  CPpmd_State *tmp___6 ;
  UInt32 tmp___7 ;
  unsigned int i___1 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  CPpmd_State *ps[256] ;
  CPpmd_State *s___0 ;
  UInt32 freqSum ;
  UInt32 count___0 ;
  UInt32 hiCnt___0 ;
  CPpmd_See *see ;
  unsigned int i___2 ;
  unsigned int num ;
  unsigned int numMasked ;
  int k ;
  CPpmd_State *tmp___15 ;
  Byte symbol___2 ;
  CPpmd_State **pps ;
  Byte tmp___16 ;

  {
#line 49
  if ((int )(p->MinContext)->NumStats != 0) {
    {
#line 51
    s = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 54
    count = RangeDec_GetThreshold(p, (UInt32 )(p->MinContext)->SummFreq);
#line 54
    hiCnt = (UInt32 )s->Freq;
    }
#line 54
    if (count < hiCnt) {
      {
#line 57
      RangeDec_Decode(p, (UInt32 )0, (UInt32 )s->Freq);
#line 58
      p->FoundState = s;
#line 59
      symbol = s->Symbol;
#line 60
      Ppmd8_Update1_0(p);
      }
#line 61
      return ((int )symbol);
    }
#line 63
    p->PrevSuccess = 0U;
#line 64
    i = (unsigned int )(p->MinContext)->NumStats;
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
#line 67
      s ++;
#line 67
      hiCnt += (UInt32 )s->Freq;
#line 67
      if (hiCnt > count) {
        {
#line 70
        RangeDec_Decode(p, hiCnt - (UInt32 )s->Freq, (UInt32 )s->Freq);
#line 71
        p->FoundState = s;
#line 72
        symbol___0 = s->Symbol;
#line 73
        Ppmd8_Update1(p);
        }
#line 74
        return ((int )symbol___0);
      }
#line 65
      i --;
#line 65
      if (! i) {
#line 65
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 78
    if (count >= (UInt32 )(p->MinContext)->SummFreq) {
#line 79
      return (-2);
    }
    {
#line 80
    RangeDec_Decode(p, hiCnt, (UInt32 )(p->MinContext)->SummFreq - hiCnt);
#line 81
    i___0 = 0U;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! ((unsigned long )i___0 < 256UL / sizeof(charMask[0]))) {
#line 81
        goto while_break___0;
      }
#line 81
      tmp___5 = ~ ((size_t )0);
#line 81
      charMask[i___0] = tmp___5;
#line 81
      tmp___4 = tmp___5;
#line 81
      charMask[i___0 + 1U] = tmp___4;
#line 81
      tmp___3 = tmp___4;
#line 81
      charMask[i___0 + 2U] = tmp___3;
#line 81
      tmp___2 = tmp___3;
#line 81
      charMask[i___0 + 3U] = tmp___2;
#line 81
      tmp___1 = tmp___2;
#line 81
      charMask[i___0 + 4U] = tmp___1;
#line 81
      tmp___0 = tmp___1;
#line 81
      charMask[i___0 + 5U] = tmp___0;
#line 81
      tmp = tmp___0;
#line 81
      charMask[i___0 + 6U] = tmp;
#line 81
      charMask[i___0 + 7U] = tmp;
#line 81
      i___0 += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 82
    *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 83
    i = (unsigned int )(p->MinContext)->NumStats;
    {
#line 84
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 84
      s --;
#line 84
      *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 84
      i --;
#line 84
      if (! i) {
#line 84
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 88
    prob = & p->BinSumm[p->NS2Indx[(int )((CPpmd_State *)(& (p->MinContext)->SummFreq))->Freq - 1]][(((unsigned int )p->NS2BSIndx[((CPpmd8_Context *)((void *)(p->Base + (p->MinContext)->Suffix)))->NumStats] + p->PrevSuccess) + (unsigned int )(p->MinContext)->Flags) + (unsigned int )((p->RunLength >> 26) & 32)];
#line 89
    tmp___7 = p->Range >> 14;
#line 89
    p->Range = tmp___7;
#line 89
    if (p->Code / tmp___7 < (UInt32 )*prob) {
      {
#line 92
      RangeDec_Decode(p, (UInt32 )0, (UInt32 )*prob);
#line 93
      *prob = (UInt16 )(((int )*prob + (1 << 7)) - (((int )*prob + (1 << 5)) >> 7));
#line 94
      tmp___6 = (CPpmd_State *)(& (p->MinContext)->SummFreq);
#line 94
      p->FoundState = tmp___6;
#line 94
      symbol___1 = tmp___6->Symbol;
#line 95
      Ppmd8_UpdateBin(p);
      }
#line 96
      return ((int )symbol___1);
    }
    {
#line 98
    RangeDec_Decode(p, (UInt32 )*prob, (UInt32 )((1 << 14) - (int )*prob));
#line 99
    *prob = (UInt16 )((int )*prob - (((int )*prob + (1 << 5)) >> 7));
#line 100
    p->InitEsc = (unsigned int )PPMD8_kExpEscape[(int )*prob >> 10];
#line 101
    i___1 = 0U;
    }
    {
#line 101
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 101
      if (! ((unsigned long )i___1 < 256UL / sizeof(charMask[0]))) {
#line 101
        goto while_break___2;
      }
#line 101
      tmp___14 = ~ ((size_t )0);
#line 101
      charMask[i___1] = tmp___14;
#line 101
      tmp___13 = tmp___14;
#line 101
      charMask[i___1 + 1U] = tmp___13;
#line 101
      tmp___12 = tmp___13;
#line 101
      charMask[i___1 + 2U] = tmp___12;
#line 101
      tmp___11 = tmp___12;
#line 101
      charMask[i___1 + 3U] = tmp___11;
#line 101
      tmp___10 = tmp___11;
#line 101
      charMask[i___1 + 4U] = tmp___10;
#line 101
      tmp___9 = tmp___10;
#line 101
      charMask[i___1 + 5U] = tmp___9;
#line 101
      tmp___8 = tmp___9;
#line 101
      charMask[i___1 + 6U] = tmp___8;
#line 101
      charMask[i___1 + 7U] = tmp___8;
#line 101
      i___1 += 8U;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 102
    *((signed char *)(charMask) + ((CPpmd_State *)(& (p->MinContext)->SummFreq))->Symbol) = (signed char)0;
#line 103
    p->PrevSuccess = 0U;
  }
  {
#line 105
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 110
    numMasked = (unsigned int )(p->MinContext)->NumStats;
    {
#line 111
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 113
      (p->OrderFall) ++;
#line 114
      if (! (p->MinContext)->Suffix) {
#line 115
        return (-1);
      }
#line 116
      p->MinContext = (CPpmd8_Context *)((void *)(p->Base + (p->MinContext)->Suffix));
#line 111
      if (! ((unsigned int )(p->MinContext)->NumStats == numMasked)) {
#line 111
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 119
    hiCnt___0 = (UInt32 )0;
#line 120
    s___0 = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 121
    i___2 = 0U;
#line 122
    num = (unsigned int )(p->MinContext)->NumStats - numMasked;
    {
#line 123
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 125
      k = (int )*((signed char *)(charMask) + s___0->Symbol);
#line 126
      hiCnt___0 += (UInt32 )((int )s___0->Freq & k);
#line 127
      tmp___15 = s___0;
#line 127
      s___0 ++;
#line 127
      ps[i___2] = tmp___15;
#line 128
      i___2 -= (unsigned int )k;
#line 123
      if (! (i___2 != num)) {
#line 123
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 132
    see = Ppmd8_MakeEscFreq(p, numMasked, & freqSum);
#line 133
    freqSum += hiCnt___0;
#line 134
    count___0 = RangeDec_GetThreshold(p, freqSum);
    }
#line 136
    if (count___0 < hiCnt___0) {
#line 139
      pps = ps;
#line 140
      hiCnt___0 = (UInt32 )0;
      {
#line 140
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 140
        hiCnt___0 += (UInt32 )(*pps)->Freq;
#line 140
        if (! (hiCnt___0 <= count___0)) {
#line 140
          goto while_break___6;
        }
#line 140
        pps ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 141
      s___0 = *pps;
#line 142
      RangeDec_Decode(p, hiCnt___0 - (UInt32 )s___0->Freq, (UInt32 )s___0->Freq);
      }
#line 143
      if ((int )see->Shift < 7) {
#line 143
        see->Count = (Byte )((int )see->Count - 1);
#line 143
        if ((int )see->Count == 0) {
#line 143
          see->Summ = (UInt16 )((int )see->Summ << 1);
#line 143
          tmp___16 = see->Shift;
#line 143
          see->Shift = (Byte )((int )see->Shift + 1);
#line 143
          see->Count = (Byte )(3 << (int )tmp___16);
        }
      }
      {
#line 144
      p->FoundState = s___0;
#line 145
      symbol___2 = s___0->Symbol;
#line 146
      Ppmd8_Update2(p);
      }
#line 147
      return ((int )symbol___2);
    }
#line 149
    if (count___0 >= freqSum) {
#line 150
      return (-2);
    }
    {
#line 151
    RangeDec_Decode(p, hiCnt___0, freqSum - hiCnt___0);
#line 152
    see->Summ = (UInt16 )((UInt32 )see->Summ + freqSum);
    }
    {
#line 153
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 153
      i___2 --;
#line 153
      *((signed char *)(charMask) + (ps[i___2])->Symbol) = (signed char)0;
#line 153
      if (! (i___2 != 0U)) {
#line 153
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 20 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.h"
UInt32 CrcUpdate(UInt32 v , void const   *data , size_t size ) ;
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
unsigned int Xz_WriteVarInt(Byte *buf , UInt64 v ) ;
#line 62
Byte XZ_SIG[6] ;
#line 63
Byte XZ_FOOTER_SIG[2] ;
#line 85
void XzCheck_Init(CXzCheck *p , int mode ) ;
#line 86
void XzCheck_Update(CXzCheck *p , void const   *data , size_t size ) ;
#line 87
int XzCheck_Final(CXzCheck *p , Byte *digest ) ;
#line 94
unsigned int XzFlags_GetCheckSize(CXzStreamFlags f ) ;
#line 114
void Xz_Construct(CXzStream *p ) ;
#line 115
void Xz_Free(CXzStream *p , ISzAlloc *alloc ) ;
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzCrc64.h"
UInt64 Crc64Update(UInt64 v , void const   *data , size_t size ) ;
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
Byte XZ_SIG[6]  = {      (Byte )253,      (Byte )'7',      (Byte )'z',      (Byte )'X', 
        (Byte )'Z',      (Byte )0};
#line 10 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
Byte XZ_FOOTER_SIG[2]  = {      (Byte )'Y',      (Byte )'Z'};
#line 12 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
unsigned int Xz_WriteVarInt(Byte *buf , UInt64 v ) 
{ 
  unsigned int i ;
  unsigned int tmp ;

  {
#line 14
  i = 0U;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    tmp = i;
#line 17
    i ++;
#line 17
    *(buf + tmp) = (Byte )((v & 127ULL) | 128ULL);
#line 18
    v >>= 7;
#line 15
    if (! (v != 0ULL)) {
#line 15
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  *(buf + (i - 1U)) = (Byte )((int )*(buf + (i - 1U)) & 127);
#line 22
  return (i);
}
}
#line 25 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
void Xz_Construct(CXzStream *p ) 
{ 
  size_t tmp ;

  {
#line 27
  tmp = (size_t )0;
#line 27
  p->numBlocksAllocated = tmp;
#line 27
  p->numBlocks = tmp;
#line 28
  p->blocks = (CXzBlockSizes *)0;
#line 29
  p->flags = (CXzStreamFlags )0;
#line 30
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
void Xz_Free(CXzStream *p , ISzAlloc *alloc ) 
{ 
  size_t tmp ;

  {
  {
#line 34
  (*(alloc->Free))((void *)alloc, (void *)p->blocks);
#line 35
  tmp = (size_t )0;
#line 35
  p->numBlocksAllocated = tmp;
#line 35
  p->numBlocks = tmp;
#line 36
  p->blocks = (CXzBlockSizes *)0;
  }
#line 37
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
unsigned int XzFlags_GetCheckSize(CXzStreamFlags f ) 
{ 
  int t ;
  int tmp ;

  {
#line 41
  t = (int )f & 15;
#line 42
  if (t == 0) {
#line 42
    tmp = 0;
  } else {
#line 42
    tmp = 4 << (t - 1) / 3;
  }
#line 42
  return ((unsigned int )tmp);
}
}
#line 45 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
void XzCheck_Init(CXzCheck *p , int mode ) 
{ 


  {
#line 47
  p->mode = mode;
  {
#line 50
  if (mode == 1) {
#line 50
    goto case_1;
  }
#line 51
  if (mode == 4) {
#line 51
    goto case_4;
  }
#line 52
  if (mode == 10) {
#line 52
    goto case_10;
  }
#line 48
  goto switch_break;
  case_1: /* CIL Label */ 
#line 50
  p->crc = 4294967295U;
#line 50
  goto switch_break;
  case_4: /* CIL Label */ 
#line 51
  p->crc64 = 0xffffffffffffffffULL;
#line 51
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 52
  Sha256_Init(& p->sha);
  }
#line 52
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 54
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
void XzCheck_Update(CXzCheck *p , void const   *data , size_t size ) 
{ 


  {
  {
#line 60
  if (p->mode == 1) {
#line 60
    goto case_1;
  }
#line 61
  if (p->mode == 4) {
#line 61
    goto case_4;
  }
#line 62
  if (p->mode == 10) {
#line 62
    goto case_10;
  }
#line 58
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 60
  p->crc = CrcUpdate(p->crc, data, size);
  }
#line 60
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 61
  p->crc64 = Crc64Update(p->crc64, data, size);
  }
#line 61
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 62
  Sha256_Update(& p->sha, (Byte const   *)data, size);
  }
#line 62
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.c"
int XzCheck_Final(CXzCheck *p , Byte *digest ) 
{ 
  int i ;
  UInt64 v ;

  {
  {
#line 70
  if (p->mode == 1) {
#line 70
    goto case_1;
  }
#line 73
  if (p->mode == 4) {
#line 73
    goto case_4;
  }
#line 81
  if (p->mode == 10) {
#line 81
    goto case_10;
  }
#line 84
  goto switch_default;
  case_1: /* CIL Label */ 
#line 71
  *((UInt32 *)digest) = p->crc ^ 4294967295U;
#line 72
  goto switch_break;
  case_4: /* CIL Label */ 
#line 76
  v = p->crc64 ^ 0xffffffffffffffffULL;
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < 8)) {
#line 77
      goto while_break;
    }
#line 78
    *(digest + i) = (Byte )(v & 255ULL);
#line 77
    i ++;
#line 77
    v >>= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 82
  Sha256_Final(& p->sha, digest);
  }
#line 83
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 85
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 87
  return (1);
}
}
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Delta.h"
void Delta_Init(Byte *state ) ;
#line 16
void Delta_Encode(Byte *state , unsigned int delta , Byte *data , SizeT size ) ;
#line 17
void Delta_Decode(Byte *state , unsigned int delta , Byte *data , SizeT size ) ;
#line 6 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Delta.c"
void Delta_Init(Byte *state ) 
{ 
  unsigned int i ;

  {
#line 9
  i = 0U;
  {
#line 9
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9
    if (! (i < 256U)) {
#line 9
      goto while_break;
    }
#line 10
    *(state + i) = (Byte )0;
#line 9
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Delta.c"
static void MyMemCpy(Byte *dest , Byte const   *src , unsigned int size ) 
{ 
  unsigned int i ;

  {
#line 16
  i = 0U;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! (i < size)) {
#line 16
      goto while_break;
    }
#line 17
    *(dest + i) = (Byte )*(src + i);
#line 16
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  return;
}
}
#line 20 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Delta.c"
void Delta_Encode(Byte *state , unsigned int delta , Byte *data , SizeT size ) 
{ 
  Byte buf[256] ;
  unsigned int j ;
  SizeT i ;
  Byte b ;

  {
  {
#line 23
  j = 0U;
#line 24
  MyMemCpy(buf, (Byte const   *)state, delta);
#line 27
  i = (SizeT )0;
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! (i < size)) {
#line 27
      goto while_break;
    }
#line 29
    j = 0U;
    {
#line 29
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 29
      if (j < delta) {
#line 29
        if (! (i < size)) {
#line 29
          goto while_break___0;
        }
      } else {
#line 29
        goto while_break___0;
      }
#line 31
      b = *(data + i);
#line 32
      *(data + i) = (Byte )((int )b - (int )buf[j]);
#line 33
      buf[j] = b;
#line 29
      i ++;
#line 29
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  if (j == delta) {
#line 38
    j = 0U;
  }
  {
#line 39
  MyMemCpy(state, (Byte const   *)(buf + j), delta - j);
#line 40
  MyMemCpy((state + delta) - j, (Byte const   *)(buf), j);
  }
#line 41
  return;
}
}
#line 43 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Delta.c"
void Delta_Decode(Byte *state , unsigned int delta , Byte *data , SizeT size ) 
{ 
  Byte buf[256] ;
  unsigned int j ;
  SizeT i ;
  Byte tmp ;

  {
  {
#line 46
  j = 0U;
#line 47
  MyMemCpy(buf, (Byte const   *)state, delta);
#line 50
  i = (SizeT )0;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < size)) {
#line 50
      goto while_break;
    }
#line 52
    j = 0U;
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      if (j < delta) {
#line 52
        if (! (i < size)) {
#line 52
          goto while_break___0;
        }
      } else {
#line 52
        goto while_break___0;
      }
#line 54
      tmp = (Byte )((int )buf[j] + (int )*(data + i));
#line 54
      *(data + i) = tmp;
#line 54
      buf[j] = tmp;
#line 52
      i ++;
#line 52
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  if (j == delta) {
#line 59
    j = 0U;
  }
  {
#line 60
  MyMemCpy(state, (Byte const   *)(buf + j), delta - j);
#line 61
  MyMemCpy((state + delta) - j, (Byte const   *)(buf), j);
  }
#line 62
  return;
}
}
#line 14 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.h"
void AesGenTables(void) ;
#line 24
void Aes_SetKey_Enc(UInt32 *w , Byte const   *key , unsigned int keySize ) ;
#line 25
void Aes_SetKey_Dec(UInt32 *w , Byte const   *key , unsigned int keySize ) ;
#line 28
void AesCbc_Init(UInt32 *p , Byte const   *iv ) ;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.h"
void (*g_AesCbc_Encode)(UInt32 *ivAes , Byte *data , size_t numBlocks )  ;
#line 33 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.h"
void (*g_AesCbc_Decode)(UInt32 *ivAes , Byte *data , size_t numBlocks )  ;
#line 34 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.h"
void (*g_AesCtr_Code)(UInt32 *ivAes , Byte *data , size_t numBlocks )  ;
#line 7 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
static UInt32 T[1024]  ;
#line 8 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
static Byte Sbox[256]  = 
#line 8
  {      (Byte )99,      (Byte )124,      (Byte )119,      (Byte )123, 
        (Byte )242,      (Byte )107,      (Byte )111,      (Byte )197, 
        (Byte )48,      (Byte )1,      (Byte )103,      (Byte )43, 
        (Byte )254,      (Byte )215,      (Byte )171,      (Byte )118, 
        (Byte )202,      (Byte )130,      (Byte )201,      (Byte )125, 
        (Byte )250,      (Byte )89,      (Byte )71,      (Byte )240, 
        (Byte )173,      (Byte )212,      (Byte )162,      (Byte )175, 
        (Byte )156,      (Byte )164,      (Byte )114,      (Byte )192, 
        (Byte )183,      (Byte )253,      (Byte )147,      (Byte )38, 
        (Byte )54,      (Byte )63,      (Byte )247,      (Byte )204, 
        (Byte )52,      (Byte )165,      (Byte )229,      (Byte )241, 
        (Byte )113,      (Byte )216,      (Byte )49,      (Byte )21, 
        (Byte )4,      (Byte )199,      (Byte )35,      (Byte )195, 
        (Byte )24,      (Byte )150,      (Byte )5,      (Byte )154, 
        (Byte )7,      (Byte )18,      (Byte )128,      (Byte )226, 
        (Byte )235,      (Byte )39,      (Byte )178,      (Byte )117, 
        (Byte )9,      (Byte )131,      (Byte )44,      (Byte )26, 
        (Byte )27,      (Byte )110,      (Byte )90,      (Byte )160, 
        (Byte )82,      (Byte )59,      (Byte )214,      (Byte )179, 
        (Byte )41,      (Byte )227,      (Byte )47,      (Byte )132, 
        (Byte )83,      (Byte )209,      (Byte )0,      (Byte )237, 
        (Byte )32,      (Byte )252,      (Byte )177,      (Byte )91, 
        (Byte )106,      (Byte )203,      (Byte )190,      (Byte )57, 
        (Byte )74,      (Byte )76,      (Byte )88,      (Byte )207, 
        (Byte )208,      (Byte )239,      (Byte )170,      (Byte )251, 
        (Byte )67,      (Byte )77,      (Byte )51,      (Byte )133, 
        (Byte )69,      (Byte )249,      (Byte )2,      (Byte )127, 
        (Byte )80,      (Byte )60,      (Byte )159,      (Byte )168, 
        (Byte )81,      (Byte )163,      (Byte )64,      (Byte )143, 
        (Byte )146,      (Byte )157,      (Byte )56,      (Byte )245, 
        (Byte )188,      (Byte )182,      (Byte )218,      (Byte )33, 
        (Byte )16,      (Byte )255,      (Byte )243,      (Byte )210, 
        (Byte )205,      (Byte )12,      (Byte )19,      (Byte )236, 
        (Byte )95,      (Byte )151,      (Byte )68,      (Byte )23, 
        (Byte )196,      (Byte )167,      (Byte )126,      (Byte )61, 
        (Byte )100,      (Byte )93,      (Byte )25,      (Byte )115, 
        (Byte )96,      (Byte )129,      (Byte )79,      (Byte )220, 
        (Byte )34,      (Byte )42,      (Byte )144,      (Byte )136, 
        (Byte )70,      (Byte )238,      (Byte )184,      (Byte )20, 
        (Byte )222,      (Byte )94,      (Byte )11,      (Byte )219, 
        (Byte )224,      (Byte )50,      (Byte )58,      (Byte )10, 
        (Byte )73,      (Byte )6,      (Byte )36,      (Byte )92, 
        (Byte )194,      (Byte )211,      (Byte )172,      (Byte )98, 
        (Byte )145,      (Byte )149,      (Byte )228,      (Byte )121, 
        (Byte )231,      (Byte )200,      (Byte )55,      (Byte )109, 
        (Byte )141,      (Byte )213,      (Byte )78,      (Byte )169, 
        (Byte )108,      (Byte )86,      (Byte )244,      (Byte )234, 
        (Byte )101,      (Byte )122,      (Byte )174,      (Byte )8, 
        (Byte )186,      (Byte )120,      (Byte )37,      (Byte )46, 
        (Byte )28,      (Byte )166,      (Byte )180,      (Byte )198, 
        (Byte )232,      (Byte )221,      (Byte )116,      (Byte )31, 
        (Byte )75,      (Byte )189,      (Byte )139,      (Byte )138, 
        (Byte )112,      (Byte )62,      (Byte )181,      (Byte )102, 
        (Byte )72,      (Byte )3,      (Byte )246,      (Byte )14, 
        (Byte )97,      (Byte )53,      (Byte )87,      (Byte )185, 
        (Byte )134,      (Byte )193,      (Byte )29,      (Byte )158, 
        (Byte )225,      (Byte )248,      (Byte )152,      (Byte )17, 
        (Byte )105,      (Byte )217,      (Byte )142,      (Byte )148, 
        (Byte )155,      (Byte )30,      (Byte )135,      (Byte )233, 
        (Byte )206,      (Byte )85,      (Byte )40,      (Byte )223, 
        (Byte )140,      (Byte )161,      (Byte )137,      (Byte )13, 
        (Byte )191,      (Byte )230,      (Byte )66,      (Byte )104, 
        (Byte )65,      (Byte )153,      (Byte )45,      (Byte )15, 
        (Byte )176,      (Byte )84,      (Byte )187,      (Byte )22};
#line 26
void AesCbc_Encode(UInt32 *p , Byte *data , size_t numBlocks ) ;
#line 27
void AesCbc_Decode(UInt32 *p , Byte *data , size_t numBlocks ) ;
#line 28
void AesCtr_Code(UInt32 *p , Byte *data , size_t numBlocks ) ;
#line 38 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
static UInt32 D[1024]  ;
#line 39 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
static Byte InvS[256]  ;
#line 41 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
static Byte Rcon[11]  = 
#line 41
  {      (Byte )0,      (Byte )1,      (Byte )2,      (Byte )4, 
        (Byte )8,      (Byte )16,      (Byte )32,      (Byte )64, 
        (Byte )128,      (Byte )27,      (Byte )54};
#line 52 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
void AesGenTables(void) 
{ 
  unsigned int i ;
  UInt32 a1 ;
  UInt32 a2 ;
  int tmp ;
  UInt32 a3 ;
  UInt32 a1___0 ;
  UInt32 a2___0 ;
  int tmp___0 ;
  UInt32 a4 ;
  int tmp___1 ;
  UInt32 a8 ;
  int tmp___2 ;
  UInt32 a9 ;
  UInt32 aB ;
  UInt32 aD ;
  UInt32 aE ;

  {
#line 55
  i = 0U;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < 256U)) {
#line 55
      goto while_break;
    }
#line 56
    InvS[Sbox[i]] = (Byte )i;
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  i = 0U;
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (i < 256U)) {
#line 57
      goto while_break___0;
    }
#line 60
    a1 = (UInt32 )Sbox[i];
#line 61
    if ((a1 & 128U) != 0U) {
#line 61
      tmp = 27;
    } else {
#line 61
      tmp = 0;
    }
#line 61
    a2 = ((a1 << 1) ^ (unsigned int )tmp) & 255U;
#line 62
    a3 = a2 ^ a1;
#line 63
    T[i] = ((a2 | (a1 << 8)) | (a1 << 16)) | (a3 << 24);
#line 64
    T[256U + i] = ((a3 | (a2 << 8)) | (a1 << 16)) | (a1 << 24);
#line 65
    T[512U + i] = ((a1 | (a3 << 8)) | (a2 << 16)) | (a1 << 24);
#line 66
    T[768U + i] = ((a1 | (a1 << 8)) | (a3 << 16)) | (a2 << 24);
#line 69
    a1___0 = (UInt32 )InvS[i];
#line 70
    if ((a1___0 & 128U) != 0U) {
#line 70
      tmp___0 = 27;
    } else {
#line 70
      tmp___0 = 0;
    }
#line 70
    a2___0 = ((a1___0 << 1) ^ (unsigned int )tmp___0) & 255U;
#line 71
    if ((a2___0 & 128U) != 0U) {
#line 71
      tmp___1 = 27;
    } else {
#line 71
      tmp___1 = 0;
    }
#line 71
    a4 = ((a2___0 << 1) ^ (unsigned int )tmp___1) & 255U;
#line 72
    if ((a4 & 128U) != 0U) {
#line 72
      tmp___2 = 27;
    } else {
#line 72
      tmp___2 = 0;
    }
#line 72
    a8 = ((a4 << 1) ^ (unsigned int )tmp___2) & 255U;
#line 73
    a9 = a8 ^ a1___0;
#line 74
    aB = (a8 ^ a2___0) ^ a1___0;
#line 75
    aD = (a8 ^ a4) ^ a1___0;
#line 76
    aE = (a8 ^ a4) ^ a2___0;
#line 77
    D[i] = ((aE | (a9 << 8)) | (aD << 16)) | (aB << 24);
#line 78
    D[256U + i] = ((aB | (aE << 8)) | (a9 << 16)) | (aD << 24);
#line 79
    D[512U + i] = ((aD | (aB << 8)) | (aE << 16)) | (a9 << 24);
#line 80
    D[768U + i] = ((a9 | (aD << 8)) | (aB << 16)) | (aE << 24);
#line 57
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 83
  g_AesCbc_Encode = & AesCbc_Encode;
#line 84
  g_AesCbc_Decode = & AesCbc_Decode;
#line 85
  g_AesCtr_Code = & AesCtr_Code;
#line 96
  return;
}
}
#line 130 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
void Aes_SetKey_Enc(UInt32 *w , Byte const   *key , unsigned int keySize ) 
{ 
  unsigned int i ;
  unsigned int wSize ;
  UInt32 t ;
  unsigned int rem ;

  {
#line 133
  wSize = keySize + 28U;
#line 134
  keySize /= 4U;
#line 135
  *(w + 0) = keySize / 2U + 3U;
#line 136
  w += 4;
#line 138
  i = 0U;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (i < keySize)) {
#line 138
      goto while_break;
    }
#line 139
    *(w + i) = (UInt32 )*((UInt32 const   *)key);
#line 138
    i ++;
#line 138
    key += 4;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (i < wSize)) {
#line 141
      goto while_break___0;
    }
#line 143
    t = *(w + (i - 1U));
#line 144
    rem = i % keySize;
#line 145
    if (rem == 0U) {
#line 146
      t = (((UInt32 )((int )Sbox[(t >> 8) & 255U] ^ (int )Rcon[i / keySize]) | ((UInt32 )Sbox[(t >> 16) & 255U] << 8)) | ((UInt32 )Sbox[(t >> 24) & 255U] << 16)) | ((UInt32 )Sbox[t & 255U] << 24);
    } else
#line 147
    if (keySize > 6U) {
#line 147
      if (rem == 4U) {
#line 148
        t = (((UInt32 )Sbox[t & 255U] | ((UInt32 )Sbox[(t >> 8) & 255U] << 8)) | ((UInt32 )Sbox[(t >> 16) & 255U] << 16)) | ((UInt32 )Sbox[(t >> 24) & 255U] << 24);
      }
    }
#line 149
    *(w + i) = *(w + (i - keySize)) ^ t;
#line 141
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
void Aes_SetKey_Dec(UInt32 *w , Byte const   *key , unsigned int keySize ) 
{ 
  unsigned int i ;
  unsigned int num ;
  UInt32 r ;

  {
  {
#line 156
  Aes_SetKey_Enc(w, key, keySize);
#line 157
  num = keySize + 20U;
#line 158
  w += 8;
#line 159
  i = 0U;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i < num)) {
#line 159
      goto while_break;
    }
#line 161
    r = *(w + i);
#line 162
    *(w + i) = ((D[Sbox[r & 255U]] ^ D[256 + (int )Sbox[(r >> 8) & 255U]]) ^ D[512 + (int )Sbox[(r >> 16) & 255U]]) ^ D[768 + (int )Sbox[(r >> 24) & 255U]];
#line 159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
static void Aes_Encode(UInt32 const   *w , UInt32 *dest , UInt32 const   *src ) 
{ 
  UInt32 s[4] ;
  UInt32 m[4] ;
  UInt32 numRounds2 ;

  {
#line 178
  numRounds2 = (UInt32 )*(w + 0);
#line 179
  w += 4;
#line 180
  s[0] = (UInt32 )(*(src + 0) ^ *(w + 0));
#line 181
  s[1] = (UInt32 )(*(src + 1) ^ *(w + 1));
#line 182
  s[2] = (UInt32 )(*(src + 2) ^ *(w + 2));
#line 183
  s[3] = (UInt32 )(*(src + 3) ^ *(w + 3));
#line 184
  w += 4;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    m[2] = (((*((T + 0) + (s[2] & 255U)) ^ *((T + (1 << 8)) + ((s[3] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((s[0] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((s[1] >> 24) & 255U))) ^ (unsigned int )*(w + 2);
#line 187
    m[0] = (((*((T + 0) + (s[0] & 255U)) ^ *((T + (1 << 8)) + ((s[1] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((s[2] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((s[3] >> 24) & 255U))) ^ (unsigned int )*(w + 0);
#line 187
    m[3] = (((*((T + 0) + (s[3] & 255U)) ^ *((T + (1 << 8)) + ((s[0] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((s[1] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((s[2] >> 24) & 255U))) ^ (unsigned int )*(w + 3);
#line 187
    m[1] = (((*((T + 0) + (s[1] & 255U)) ^ *((T + (1 << 8)) + ((s[2] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((s[3] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((s[0] >> 24) & 255U))) ^ (unsigned int )*(w + 1);
#line 188
    numRounds2 --;
#line 188
    if (numRounds2 == 0U) {
#line 189
      goto while_break;
    }
#line 190
    s[2] = (((*((T + 0) + (m[2] & 255U)) ^ *((T + (1 << 8)) + ((m[3] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((m[0] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((m[1] >> 24) & 255U))) ^ (unsigned int )*(w + 6);
#line 190
    s[0] = (((*((T + 0) + (m[0] & 255U)) ^ *((T + (1 << 8)) + ((m[1] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((m[2] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((m[3] >> 24) & 255U))) ^ (unsigned int )*(w + 4);
#line 190
    s[3] = (((*((T + 0) + (m[3] & 255U)) ^ *((T + (1 << 8)) + ((m[0] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((m[1] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((m[2] >> 24) & 255U))) ^ (unsigned int )*(w + 7);
#line 190
    s[1] = (((*((T + 0) + (m[1] & 255U)) ^ *((T + (1 << 8)) + ((m[2] >> 8) & 255U))) ^ *((T + (2 << 8)) + ((m[3] >> 16) & 255U))) ^ *((T + (3 << 8)) + ((m[0] >> 24) & 255U))) ^ (unsigned int )*(w + 5);
#line 191
    w += 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  w += 4;
#line 194
  *(dest + 0) = ((((UInt32 )Sbox[m[0] & 255U] | ((UInt32 )Sbox[(m[1] >> 8) & 255U] << 8)) | ((UInt32 )Sbox[(m[2] >> 16) & 255U] << 16)) | ((UInt32 )Sbox[(m[3] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 0);
#line 194
  *(dest + 1) = ((((UInt32 )Sbox[m[1] & 255U] | ((UInt32 )Sbox[(m[2] >> 8) & 255U] << 8)) | ((UInt32 )Sbox[(m[3] >> 16) & 255U] << 16)) | ((UInt32 )Sbox[(m[0] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 1);
#line 194
  *(dest + 2) = ((((UInt32 )Sbox[m[2] & 255U] | ((UInt32 )Sbox[(m[3] >> 8) & 255U] << 8)) | ((UInt32 )Sbox[(m[0] >> 16) & 255U] << 16)) | ((UInt32 )Sbox[(m[1] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 2);
#line 194
  *(dest + 3) = ((((UInt32 )Sbox[m[3] & 255U] | ((UInt32 )Sbox[(m[0] >> 8) & 255U] << 8)) | ((UInt32 )Sbox[(m[1] >> 16) & 255U] << 16)) | ((UInt32 )Sbox[(m[2] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 3);
#line 195
  return;
}
}
#line 197 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
static void Aes_Decode(UInt32 const   *w , UInt32 *dest , UInt32 const   *src ) 
{ 
  UInt32 s[4] ;
  UInt32 m[4] ;
  UInt32 numRounds2 ;

  {
#line 201
  numRounds2 = (UInt32 )*(w + 0);
#line 202
  w += 4U + numRounds2 * 8U;
#line 203
  s[0] = (UInt32 )(*(src + 0) ^ *(w + 0));
#line 204
  s[1] = (UInt32 )(*(src + 1) ^ *(w + 1));
#line 205
  s[2] = (UInt32 )(*(src + 2) ^ *(w + 2));
#line 206
  s[3] = (UInt32 )(*(src + 3) ^ *(w + 3));
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    w -= 8;
#line 210
    m[0] = (((*((D + 0) + (s[0] & 255U)) ^ *((D + (1 << 8)) + ((s[3] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((s[2] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((s[1] >> 24) & 255U))) ^ (unsigned int )*(w + 4);
#line 210
    m[2] = (((*((D + 0) + (s[2] & 255U)) ^ *((D + (1 << 8)) + ((s[1] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((s[0] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((s[3] >> 24) & 255U))) ^ (unsigned int )*(w + 6);
#line 210
    m[3] = (((*((D + 0) + (s[3] & 255U)) ^ *((D + (1 << 8)) + ((s[2] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((s[1] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((s[0] >> 24) & 255U))) ^ (unsigned int )*(w + 7);
#line 210
    m[1] = (((*((D + 0) + (s[1] & 255U)) ^ *((D + (1 << 8)) + ((s[0] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((s[3] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((s[2] >> 24) & 255U))) ^ (unsigned int )*(w + 5);
#line 211
    numRounds2 --;
#line 211
    if (numRounds2 == 0U) {
#line 212
      goto while_break;
    }
#line 213
    s[0] = (((*((D + 0) + (m[0] & 255U)) ^ *((D + (1 << 8)) + ((m[3] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((m[2] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((m[1] >> 24) & 255U))) ^ (unsigned int )*(w + 0);
#line 213
    s[2] = (((*((D + 0) + (m[2] & 255U)) ^ *((D + (1 << 8)) + ((m[1] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((m[0] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((m[3] >> 24) & 255U))) ^ (unsigned int )*(w + 2);
#line 213
    s[3] = (((*((D + 0) + (m[3] & 255U)) ^ *((D + (1 << 8)) + ((m[2] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((m[1] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((m[0] >> 24) & 255U))) ^ (unsigned int )*(w + 3);
#line 213
    s[1] = (((*((D + 0) + (m[1] & 255U)) ^ *((D + (1 << 8)) + ((m[0] >> 8) & 255U))) ^ *((D + (2 << 8)) + ((m[3] >> 16) & 255U))) ^ *((D + (3 << 8)) + ((m[2] >> 24) & 255U))) ^ (unsigned int )*(w + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  *(dest + 0) = ((((UInt32 )InvS[m[0] & 255U] | ((UInt32 )InvS[(m[3] >> 8) & 255U] << 8)) | ((UInt32 )InvS[(m[2] >> 16) & 255U] << 16)) | ((UInt32 )InvS[(m[1] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 0);
#line 215
  *(dest + 1) = ((((UInt32 )InvS[m[1] & 255U] | ((UInt32 )InvS[(m[0] >> 8) & 255U] << 8)) | ((UInt32 )InvS[(m[3] >> 16) & 255U] << 16)) | ((UInt32 )InvS[(m[2] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 1);
#line 215
  *(dest + 2) = ((((UInt32 )InvS[m[2] & 255U] | ((UInt32 )InvS[(m[1] >> 8) & 255U] << 8)) | ((UInt32 )InvS[(m[0] >> 16) & 255U] << 16)) | ((UInt32 )InvS[(m[3] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 2);
#line 215
  *(dest + 3) = ((((UInt32 )InvS[m[3] & 255U] | ((UInt32 )InvS[(m[2] >> 8) & 255U] << 8)) | ((UInt32 )InvS[(m[1] >> 16) & 255U] << 16)) | ((UInt32 )InvS[(m[0] >> 24) & 255U] << 24)) ^ (unsigned int )*(w + 3);
#line 216
  return;
}
}
#line 218 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
void AesCbc_Init(UInt32 *p , Byte const   *iv ) 
{ 
  unsigned int i ;

  {
#line 221
  i = 0U;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < 4U)) {
#line 221
      goto while_break;
    }
#line 222
    *(p + i) = (UInt32 )*((UInt32 const   *)(iv + i * 4U));
#line 221
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 225 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
void AesCbc_Encode(UInt32 *p , Byte *data , size_t numBlocks ) 
{ 


  {
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (numBlocks != 0UL)) {
#line 227
      goto while_break;
    }
    {
#line 229
    *(p + 0) ^= (unsigned int )*((UInt32 const   *)data);
#line 230
    *(p + 1) ^= (unsigned int )*((UInt32 const   *)(data + 4));
#line 231
    *(p + 2) ^= (unsigned int )*((UInt32 const   *)(data + 8));
#line 232
    *(p + 3) ^= (unsigned int )*((UInt32 const   *)(data + 12));
#line 234
    Aes_Encode((UInt32 const   *)(p + 4), p, (UInt32 const   *)p);
#line 236
    *((UInt32 *)data) = *(p + 0);
#line 237
    *((UInt32 *)(data + 4)) = *(p + 1);
#line 238
    *((UInt32 *)(data + 8)) = *(p + 2);
#line 239
    *((UInt32 *)(data + 12)) = *(p + 3);
#line 227
    numBlocks --;
#line 227
    data += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
void AesCbc_Decode(UInt32 *p , Byte *data , size_t numBlocks ) 
{ 
  UInt32 in[4] ;
  UInt32 out[4] ;

  {
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (numBlocks != 0UL)) {
#line 246
      goto while_break;
    }
    {
#line 248
    in[0] = (UInt32 )*((UInt32 const   *)data);
#line 249
    in[1] = (UInt32 )*((UInt32 const   *)(data + 4));
#line 250
    in[2] = (UInt32 )*((UInt32 const   *)(data + 8));
#line 251
    in[3] = (UInt32 )*((UInt32 const   *)(data + 12));
#line 253
    Aes_Decode((UInt32 const   *)(p + 4), out, (UInt32 const   *)(in));
#line 255
    *((UInt32 *)data) = *(p + 0) ^ out[0];
#line 256
    *((UInt32 *)(data + 4)) = *(p + 1) ^ out[1];
#line 257
    *((UInt32 *)(data + 8)) = *(p + 2) ^ out[2];
#line 258
    *((UInt32 *)(data + 12)) = *(p + 3) ^ out[3];
#line 260
    *(p + 0) = in[0];
#line 261
    *(p + 1) = in[1];
#line 262
    *(p + 2) = in[2];
#line 263
    *(p + 3) = in[3];
#line 246
    numBlocks --;
#line 246
    data += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Aes.c"
void AesCtr_Code(UInt32 *p , Byte *data , size_t numBlocks ) 
{ 
  UInt32 temp[4] ;
  Byte buf[16] ;
  int i ;
  Byte *tmp ;

  {
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (numBlocks != 0UL)) {
#line 269
      goto while_break;
    }
#line 274
    (*(p + 0)) ++;
#line 274
    if (*(p + 0) == 0U) {
#line 275
      (*(p + 1)) ++;
    }
    {
#line 276
    Aes_Encode((UInt32 const   *)(p + 4), temp, (UInt32 const   *)p);
#line 277
    *((UInt32 *)(buf)) = temp[0];
#line 278
    *((UInt32 *)(buf + 4)) = temp[1];
#line 279
    *((UInt32 *)(buf + 8)) = temp[2];
#line 280
    *((UInt32 *)(buf + 12)) = temp[3];
#line 281
    i = 0;
    }
    {
#line 281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 281
      if (! (i < 16)) {
#line 281
        goto while_break___0;
      }
#line 282
      tmp = data;
#line 282
      data ++;
#line 282
      *tmp = (Byte )((int )*tmp ^ (int )buf[i]);
#line 281
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 269
    numBlocks --;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 623
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template )  __asm__("mkstemp64")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 612
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 978
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off64_t __offset )  __asm__("mmap64")  ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 87
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.h"
void *MyAlloc(size_t size ) ;
#line 14
void MyFree(void *address ) ;
#line 16
void SetLargePageSize(void) ;
#line 18
void *MidAlloc(size_t size ) ;
#line 19
void MidFree(void *address ) ;
#line 20
void *BigAlloc(size_t size ) ;
#line 21
void BigFree(void *address ) ;
#line 37 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
void *MyAlloc(size_t size ) 
{ 
  void *tmp ;

  {
#line 39
  if (size == 0UL) {
#line 40
    return ((void *)0);
  }
  {
#line 48
  tmp = malloc(size);
  }
#line 48
  return (tmp);
}
}
#line 52 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
void MyFree(void *address ) 
{ 


  {
  {
#line 58
  free(address);
  }
#line 59
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
static void *g_HugePageAddr[64]  = {      (void *)0};
#line 68 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
static size_t g_HugePageLen[64]  ;
#line 69 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
static char *g_HugetlbPath  ;
#line 82
static void *VirtualAlloc(size_t size , int memLargePages ) ;
#line 82 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
static pthread_mutex_t mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 74 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
static void *VirtualAlloc(size_t size , int memLargePages ) 
{ 
  int i ;
  void *address ;
  int fd ;
  int pathlen ;
  size_t tmp ;
  char *tempname ;
  unsigned long __lengthoftempname ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 77
  if (memLargePages) {
    {
#line 86
    address = (void *)0;
#line 88
    pthread_mutex_lock(& mutex);
#line 90
    i = 0;
    }
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
#line 90
      if (! (i < 64)) {
#line 90
        goto while_break;
      }
#line 92
      if ((unsigned long )g_HugePageAddr[i] == (unsigned long )((void *)0)) {
        {
#line 94
        tmp = strlen((char const   *)g_HugetlbPath);
#line 94
        pathlen = (int )tmp;
#line 95
        __lengthoftempname = (unsigned long )(pathlen + 12);
#line 95
        tmp___0 = __builtin_alloca(sizeof(*tempname) * __lengthoftempname);
#line 95
        tempname = (char *)tmp___0;
#line 97
        memcpy((void */* __restrict  */)tempname, (void const   */* __restrict  */)g_HugetlbPath,
               (size_t )pathlen);
#line 98
        memcpy((void */* __restrict  */)(tempname + pathlen), (void const   */* __restrict  */)"/7z-XXXXXX",
               (size_t )11);
#line 99
        fd = mkstemp(tempname);
#line 100
        unlink((char const   *)tempname);
        }
#line 101
        if (fd < 0) {
          {
#line 103
          tmp___1 = __errno_location();
#line 103
          tmp___2 = strerror(*tmp___1);
#line 103
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cant\'t open %s (%s)\n",
                  tempname, tmp___2);
          }
#line 104
          goto while_break;
        }
        {
#line 106
        address = mmap((void *)0, size, 3, 1, fd, (__off64_t )0);
#line 107
        close(fd);
        }
#line 108
        if ((unsigned long )address == (unsigned long )((void *)-1)) {
#line 110
          address = (void *)0;
#line 111
          goto while_break;
        }
#line 113
        g_HugePageLen[i] = size;
#line 114
        g_HugePageAddr[i] = address;
#line 116
        goto while_break;
      }
#line 90
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 120
    pthread_mutex_unlock(& mutex);
    }
#line 122
    return (address);
  }
  {
#line 126
  tmp___3 = malloc(size);
  }
#line 126
  return (tmp___3);
}
}
#line 129 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
static int VirtualFree(void *address ) 
{ 
  int i ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < 64)) {
#line 135
      goto while_break;
    }
#line 137
    if ((unsigned long )g_HugePageAddr[i] == (unsigned long )address) {
      {
#line 139
      munmap(address, g_HugePageLen[i]);
#line 140
      g_HugePageAddr[i] = (void *)0;
      }
#line 141
      return (1);
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  free(address);
  }
#line 147
  return (1);
}
}
#line 152 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
void *MidAlloc(size_t size ) 
{ 
  void *tmp ;

  {
#line 154
  if (size == 0UL) {
#line 155
    return ((void *)0);
  }
  {
#line 159
  tmp = VirtualAlloc(size, 0);
  }
#line 159
  return (tmp);
}
}
#line 162 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
void MidFree(void *address ) 
{ 


  {
#line 168
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 169
    return;
  }
  {
#line 170
  VirtualFree(address);
  }
#line 171
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
size_t g_LargePageSize  =    (size_t )0;
#line 187 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
static char dir_hugetlbfs[1024]  ;
#line 178 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
size_t largePageMinimum(void) 
{ 
  size_t size ;
  char const   *filename ;
  FILE *fp ;
  struct mntent *info ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 182
  g_HugetlbPath = getenv("HUGETLB_PATH");
  }
#line 184
  if ((unsigned long )g_HugetlbPath == (unsigned long )((void *)0)) {
    {
#line 188
    filename = "/etc/mtab";
#line 192
    dir_hugetlbfs[0] = (char)0;
#line 194
    fp = setmntent(filename, "r");
    }
#line 195
    if (fp) {
      {
#line 197
      info = getmntent(fp);
      }
      {
#line 198
      while (1) {
        while_continue: /* CIL Label */ ;
#line 198
        if (! info) {
#line 198
          goto while_break;
        }
        {
#line 206
        tmp = strcmp((char const   *)info->mnt_type, "hugetlbfs");
        }
#line 206
        if (tmp == 0) {
          {
#line 208
          strcpy((char */* __restrict  */)(dir_hugetlbfs), (char const   */* __restrict  */)info->mnt_dir);
          }
#line 209
          goto while_break;
        }
        {
#line 212
        info = getmntent(fp);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 214
      endmntent(fp);
      }
    }
#line 217
    if (dir_hugetlbfs[0]) {
#line 219
      g_HugetlbPath = dir_hugetlbfs;
    }
  }
#line 223
  if ((unsigned long )g_HugetlbPath == (unsigned long )((void *)0)) {
#line 224
    return ((size_t )0);
  } else {
    {
#line 223
    tmp___0 = pathconf((char const   *)g_HugetlbPath, 16);
#line 223
    size = (size_t )tmp___0;
#line 223
    tmp___1 = getpagesize();
    }
#line 223
    if (size <= (size_t )tmp___1) {
#line 224
      return ((size_t )0);
    }
  }
#line 225
  return (size);
}
}
#line 232 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
void SetLargePageSize(void) 
{ 
  size_t size ;

  {
  {
#line 242
  size = largePageMinimum();
  }
#line 243
  if (size == 0UL) {
#line 244
    return;
  } else
#line 243
  if ((size & (size - 1UL)) != 0UL) {
#line 244
    return;
  }
#line 245
  g_LargePageSize = size;
#line 248
  return;
}
}
#line 251 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
void *BigAlloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 253
  if (size == 0UL) {
#line 254
    return ((void *)0);
  }
#line 260
  if (g_LargePageSize != 0UL) {
#line 260
    if (g_LargePageSize <= (size_t )(1 << 30)) {
#line 260
      if (size >= (size_t )(1 << 18)) {
        {
#line 262
        tmp = VirtualAlloc(((size + g_LargePageSize) - 1UL) & ~ (g_LargePageSize - 1UL),
                           1);
#line 262
        res = tmp;
        }
#line 263
        if ((unsigned long )res != (unsigned long )((void *)0)) {
#line 264
          return (res);
        }
      }
    }
  }
  {
#line 267
  tmp___0 = VirtualAlloc(size, 0);
  }
#line 267
  return (tmp___0);
}
}
#line 270 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Alloc.c"
void BigFree(void *address ) 
{ 


  {
#line 277
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 278
    return;
  }
  {
#line 279
  VirtualFree(address);
  }
#line 280
  return;
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 145 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
SRes SeqInStream_Read(ISeqInStream *stream , void *buf , size_t size ) ;
#line 146
SRes SeqInStream_Read2(ISeqInStream *stream , void *buf , size_t size , SRes errorType ) ;
#line 147
SRes SeqInStream_ReadByte(ISeqInStream *stream , Byte *buf ) ;
#line 187
SRes LookInStream_Read2(ILookInStream *stream , void *buf , size_t size , SRes errorType ) ;
#line 218
void SecToRead_CreateVTable(CSecToRead *p ) ;
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.h"
UInt32 CrcCalc(void const   *data , size_t size ) ;
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
unsigned int Xz_ReadVarInt(Byte const   *p , size_t maxSize , UInt64 *value ) ;
#line 54
SRes XzBlock_Parse(CXzBlock *p , Byte const   *header ) ;
#line 55
SRes XzBlock_ReadHeader(CXzBlock *p , ISeqInStream *inStream , Bool *isIndex , UInt32 *headerSizeRes ) ;
#line 96
SRes Xz_ParseHeader(CXzStreamFlags *p , Byte const   *buf ) ;
#line 97
SRes Xz_ReadHeader(CXzStreamFlags *p , ISeqInStream *inStream ) ;
#line 119
UInt64 Xz_GetUnpackSize(CXzStream const   *p ) ;
#line 120
UInt64 Xz_GetPackSize(CXzStream const   *p ) ;
#line 129
void Xzs_Construct(CXzs *p ) ;
#line 130
void Xzs_Free(CXzs *p , ISzAlloc *alloc ) ;
#line 131
SRes Xzs_ReadBackward(CXzs *p , ILookInStream *stream , Int64 *startOffset , ICompressProgress *progress ,
                      ISzAlloc *alloc ) ;
#line 133
UInt64 Xzs_GetNumBlocks(CXzs const   *p ) ;
#line 134
UInt64 Xzs_GetUnpackSize(CXzs const   *p ) ;
#line 10 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
SRes Xz_ReadHeader(CXzStreamFlags *p , ISeqInStream *inStream ) 
{ 
  Byte sig[12] ;
  int __result__ ;
  SRes tmp ;
  int tmp___0 ;
  SRes tmp___1 ;

  {
  {
#line 13
  tmp = SeqInStream_Read2(inStream, (void *)(sig), (size_t )12, 17);
#line 13
  __result__ = tmp;
  }
#line 13
  if (__result__ != 0) {
#line 13
    return (__result__);
  }
  {
#line 14
  tmp___0 = memcmp((void const   *)(sig), (void const   *)(XZ_SIG), (size_t )6);
  }
#line 14
  if (tmp___0 != 0) {
#line 15
    return (17);
  }
  {
#line 16
  tmp___1 = Xz_ParseHeader(p, (Byte const   *)(sig));
  }
#line 16
  return (tmp___1);
}
}
#line 23 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
SRes XzBlock_ReadHeader(CXzBlock *p , ISeqInStream *inStream , Bool *isIndex , UInt32 *headerSizeRes ) 
{ 
  Byte header[1024] ;
  unsigned int headerSize ;
  int __result__ ;
  SRes tmp ;
  int __result_____0 ;
  SRes tmp___0 ;
  SRes tmp___1 ;

  {
  {
#line 27
  *headerSizeRes = (UInt32 )0;
#line 28
  tmp = SeqInStream_ReadByte(inStream, & header[0]);
#line 28
  __result__ = tmp;
  }
#line 28
  if (__result__ != 0) {
#line 28
    return (__result__);
  }
#line 29
  headerSize = ((unsigned int )header[0] << 2) + 4U;
#line 30
  if (headerSize == 0U) {
#line 32
    *headerSizeRes = (UInt32 )1;
#line 33
    *isIndex = 1;
#line 34
    return (0);
  }
  {
#line 37
  *isIndex = 0;
#line 38
  *headerSizeRes = headerSize;
#line 39
  tmp___0 = SeqInStream_Read(inStream, (void *)(header + 1), (size_t )(headerSize - 1U));
#line 39
  __result_____0 = tmp___0;
  }
#line 39
  if (__result_____0 != 0) {
#line 39
    return (__result_____0);
  }
  {
#line 40
  tmp___1 = XzBlock_Parse(p, (Byte const   *)(header));
  }
#line 40
  return (tmp___1);
}
}
#line 46 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
UInt64 Xz_GetUnpackSize(CXzStream const   *p ) 
{ 
  UInt64 size ;
  size_t i ;
  UInt64 newSize ;

  {
#line 48
  size = (UInt64 )0;
#line 50
  i = (size_t )0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < (size_t )p->numBlocks)) {
#line 50
      goto while_break;
    }
#line 51
    newSize = size + (p->blocks + i)->unpackSize;
#line 51
    if (newSize < size) {
#line 51
      return ((UInt64 )((Int64 )-1));
    }
#line 51
    size = newSize;
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (size);
}
}
#line 55 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
UInt64 Xz_GetPackSize(CXzStream const   *p ) 
{ 
  UInt64 size ;
  size_t i ;
  UInt64 newSize ;

  {
#line 57
  size = (UInt64 )0;
#line 59
  i = (size_t )0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < (size_t )p->numBlocks)) {
#line 59
      goto while_break;
    }
#line 60
    newSize = size + (((p->blocks + i)->totalSize + 3ULL) & 0xfffffffffffffffcULL);
#line 60
    if (newSize < size) {
#line 60
      return ((UInt64 )((Int64 )-1));
    }
#line 60
    size = newSize;
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (size);
}
}
#line 71 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
static SRes Xz_ReadIndex2(CXzStream *p , Byte const   *buf , size_t size , ISzAlloc *alloc ) 
{ 
  size_t i ;
  size_t numBlocks ;
  size_t crcStartPos ;
  size_t pos ;
  UInt32 crc ;
  UInt64 numBlocks64 ;
  unsigned int s ;
  unsigned int tmp ;
  void *tmp___0 ;
  CXzBlockSizes *block ;
  unsigned int s___0 ;
  unsigned int tmp___1 ;
  unsigned int s___1 ;
  unsigned int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 73
  pos = (size_t )1;
#line 76
  if (size < 5UL) {
#line 77
    return (16);
  } else
#line 76
  if ((int const   )*(buf + 0) != 0) {
#line 77
    return (16);
  }
  {
#line 79
  size -= 4UL;
#line 80
  crc = CrcCalc((void const   *)buf, size);
  }
#line 81
  if (crc != (UInt32 )*((UInt32 const   *)(buf + size))) {
#line 82
    return (16);
  }
  {
#line 86
  tmp = Xz_ReadVarInt(buf + pos, size - pos, & numBlocks64);
#line 86
  s = tmp;
  }
#line 86
  if (s == 0U) {
#line 86
    return (16);
  }
#line 86
  pos += (size_t )s;
#line 87
  numBlocks = (size_t )numBlocks64;
#line 88
  if ((UInt64 )numBlocks != numBlocks64) {
#line 89
    return (16);
  } else
#line 88
  if (numBlocks * 2UL > size) {
#line 89
    return (16);
  }
  {
#line 92
  crcStartPos = pos;
#line 93
  Xz_Free(p, alloc);
  }
#line 94
  if (numBlocks != 0UL) {
    {
#line 96
    p->numBlocks = numBlocks;
#line 97
    p->numBlocksAllocated = numBlocks;
#line 98
    tmp___0 = (*(alloc->Alloc))((void *)alloc, sizeof(CXzBlockSizes ) * numBlocks);
#line 98
    p->blocks = (CXzBlockSizes *)tmp___0;
    }
#line 99
    if ((unsigned long )p->blocks == (unsigned long )((CXzBlockSizes *)0)) {
#line 100
      return (2);
    }
#line 101
    i = (size_t )0;
    {
#line 101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 101
      if (! (i < numBlocks)) {
#line 101
        goto while_break;
      }
      {
#line 103
      block = p->blocks + i;
#line 104
      tmp___1 = Xz_ReadVarInt(buf + pos, size - pos, & block->totalSize);
#line 104
      s___0 = tmp___1;
      }
#line 104
      if (s___0 == 0U) {
#line 104
        return (16);
      }
      {
#line 104
      pos += (size_t )s___0;
#line 105
      tmp___2 = Xz_ReadVarInt(buf + pos, size - pos, & block->unpackSize);
#line 105
      s___1 = tmp___2;
      }
#line 105
      if (s___1 == 0U) {
#line 105
        return (16);
      }
#line 105
      pos += (size_t )s___1;
#line 106
      if (block->totalSize == 0ULL) {
#line 107
        return (16);
      }
#line 101
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if (! ((pos & 3UL) != 0UL)) {
#line 110
      goto while_break___0;
    }
#line 111
    tmp___3 = pos;
#line 111
    pos ++;
#line 111
    if ((int const   )*(buf + tmp___3) != 0) {
#line 112
      return (16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  if (pos == size) {
#line 113
    tmp___4 = 0;
  } else {
#line 113
    tmp___4 = 16;
  }
#line 113
  return (tmp___4);
}
}
#line 116 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
static SRes Xz_ReadIndex(CXzStream *p , ILookInStream *stream , UInt64 indexSize ,
                         ISzAlloc *alloc ) 
{ 
  SRes res ;
  size_t size ;
  Byte *buf ;
  void *tmp ;

  {
#line 121
  if (indexSize > (UInt64 )(1U << 31)) {
#line 122
    return (4);
  }
#line 123
  size = (size_t )indexSize;
#line 124
  if ((UInt64 )size != indexSize) {
#line 125
    return (4);
  }
  {
#line 126
  tmp = (*(alloc->Alloc))((void *)alloc, size);
#line 126
  buf = (Byte *)tmp;
  }
#line 127
  if ((unsigned long )buf == (unsigned long )((Byte *)0)) {
#line 128
    return (2);
  }
  {
#line 129
  res = LookInStream_Read2(stream, (void *)buf, size, 4);
  }
#line 130
  if (res == 0) {
    {
#line 131
    res = Xz_ReadIndex2(p, (Byte const   *)buf, size, alloc);
    }
  }
  {
#line 132
  (*(alloc->Free))((void *)alloc, (void *)buf);
  }
#line 133
  return (res);
}
}
#line 136 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
static SRes SeekFromCur(ILookInStream *inStream , Int64 *res ) 
{ 
  SRes tmp ;

  {
  {
#line 138
  tmp = (*(inStream->Seek))((void *)inStream, res, (ESzSeek )1);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
static SRes Xz_ReadBackward(CXzStream *p , ILookInStream *stream , Int64 *startOffset ,
                            ISzAlloc *alloc ) 
{ 
  UInt64 indexSize ;
  Byte buf[12] ;
  int __result__ ;
  SRes tmp ;
  int __result_____0 ;
  SRes tmp___0 ;
  Int64 i ;
  int j ;
  size_t processedSize ;
  Byte tempBuf[1 << 10] ;
  int __result_____1 ;
  SRes tmp___1 ;
  int __result_____2 ;
  SRes tmp___2 ;
  int __result_____3 ;
  SRes tmp___3 ;
  int __result_____4 ;
  SRes tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  UInt32 tmp___7 ;
  int __result_____5 ;
  SRes tmp___8 ;
  int __result_____6 ;
  SRes tmp___9 ;
  UInt64 totalSize ;
  UInt64 tmp___10 ;
  UInt64 sum ;
  int __result_____7 ;
  SRes tmp___11 ;
  CXzStreamFlags headerFlags ;
  CSecToRead secToRead ;
  int __result_____8 ;
  SRes tmp___12 ;
  int tmp___13 ;

  {
#line 146
  if ((*startOffset & 3LL) != 0LL) {
#line 147
    return (17);
  } else
#line 146
  if (*startOffset < 12LL) {
#line 147
    return (17);
  }
  {
#line 148
  *startOffset = (Int64 )-12;
#line 149
  tmp = SeekFromCur(stream, startOffset);
#line 149
  __result__ = tmp;
  }
#line 149
  if (__result__ != 0) {
#line 149
    return (__result__);
  }
  {
#line 151
  tmp___0 = LookInStream_Read2(stream, (void *)(buf), (size_t )12, 17);
#line 151
  __result_____0 = tmp___0;
  }
#line 151
  if (__result_____0 != 0) {
#line 151
    return (__result_____0);
  }
  {
#line 153
  tmp___6 = memcmp((void const   *)(buf + 10), (void const   *)(XZ_FOOTER_SIG), (size_t )2);
  }
#line 153
  if (tmp___6 != 0) {
#line 155
    i = (Int64 )0;
#line 156
    *startOffset += 12LL;
    {
#line 157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 163
      if (*startOffset < 12LL) {
#line 164
        return (17);
      } else
#line 163
      if (i > (Int64 )(1 << 16)) {
#line 164
        return (17);
      }
#line 165
      if (*startOffset > (Int64 )(1 << 10)) {
#line 165
        processedSize = (size_t )(1 << 10);
      } else {
#line 165
        processedSize = (size_t )*startOffset;
      }
      {
#line 166
      i += (Int64 )processedSize;
#line 167
      *startOffset = - ((Int64 )processedSize);
#line 168
      tmp___1 = SeekFromCur(stream, startOffset);
#line 168
      __result_____1 = tmp___1;
      }
#line 168
      if (__result_____1 != 0) {
#line 168
        return (__result_____1);
      }
      {
#line 169
      tmp___2 = LookInStream_Read2(stream, (void *)(tempBuf), processedSize, 17);
#line 169
      __result_____2 = tmp___2;
      }
#line 169
      if (__result_____2 != 0) {
#line 169
        return (__result_____2);
      }
#line 170
      j = (int )processedSize;
      {
#line 170
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 170
        if (! (j >= 1)) {
#line 170
          goto while_break___0;
        }
#line 171
        if ((int )tempBuf[j - 1] != 0) {
#line 172
          goto while_break___0;
        }
#line 170
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 173
      if (j != 0) {
#line 175
        if ((j & 3) != 0) {
#line 176
          return (17);
        }
#line 177
        *startOffset += (Int64 )j;
#line 178
        if (*startOffset < 12LL) {
#line 179
          return (17);
        }
        {
#line 180
        *startOffset -= 12LL;
#line 181
        tmp___3 = (*(stream->Seek))((void *)stream, startOffset, (ESzSeek )0);
#line 181
        __result_____3 = tmp___3;
        }
#line 181
        if (__result_____3 != 0) {
#line 181
          return (__result_____3);
        }
        {
#line 182
        tmp___4 = LookInStream_Read2(stream, (void *)(buf), (size_t )12, 17);
#line 182
        __result_____4 = tmp___4;
        }
#line 182
        if (__result_____4 != 0) {
#line 182
          return (__result_____4);
        }
        {
#line 183
        tmp___5 = memcmp((void const   *)(buf + 10), (void const   *)(XZ_FOOTER_SIG),
                         (size_t )2);
        }
#line 183
        if (tmp___5 != 0) {
#line 184
          return (17);
        }
#line 185
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 190
  p->flags = (CXzStreamFlags )(((int )((UInt16 )*((Byte const   *)(buf + 8) + 0)) << 8) | (int )*((Byte const   *)(buf + 8) + 1));
#line 192
  if (! ((int )p->flags <= 15)) {
#line 193
    return (4);
  }
  {
#line 195
  tmp___7 = CrcCalc((void const   *)(buf + 4), (size_t )6);
  }
#line 195
  if (*((UInt32 const   *)(buf)) != (UInt32 const   )tmp___7) {
#line 196
    return (16);
  }
  {
#line 198
  indexSize = ((UInt64 )*((UInt32 const   *)(buf + 4)) + 1ULL) << 2;
#line 200
  *startOffset = - ((Int64 )(indexSize + 12ULL));
#line 201
  tmp___8 = SeekFromCur(stream, startOffset);
#line 201
  __result_____5 = tmp___8;
  }
#line 201
  if (__result_____5 != 0) {
#line 201
    return (__result_____5);
  }
  {
#line 203
  tmp___9 = Xz_ReadIndex(p, stream, indexSize, alloc);
#line 203
  __result_____6 = tmp___9;
  }
#line 203
  if (__result_____6 != 0) {
#line 203
    return (__result_____6);
  }
  {
#line 206
  tmp___10 = Xz_GetPackSize((CXzStream const   *)p);
#line 206
  totalSize = tmp___10;
#line 207
  sum = (12ULL + totalSize) + indexSize;
  }
#line 208
  if (totalSize == 0xffffffffffffffffULL) {
#line 211
    return (16);
  } else
#line 208
  if (sum >= 1ULL << 63) {
#line 211
    return (16);
  } else
#line 208
  if (totalSize >= 1ULL << 63) {
#line 211
    return (16);
  }
  {
#line 212
  *startOffset = - ((Int64 )sum);
#line 213
  tmp___11 = SeekFromCur(stream, startOffset);
#line 213
  __result_____7 = tmp___11;
  }
#line 213
  if (__result_____7 != 0) {
#line 213
    return (__result_____7);
  }
  {
#line 218
  SecToRead_CreateVTable(& secToRead);
#line 219
  secToRead.realStream = stream;
#line 221
  tmp___12 = Xz_ReadHeader(& headerFlags, & secToRead.s);
#line 221
  __result_____8 = tmp___12;
  }
#line 221
  if (__result_____8 != 0) {
#line 221
    return (__result_____8);
  }
#line 222
  if ((int )p->flags == (int )headerFlags) {
#line 222
    tmp___13 = 0;
  } else {
#line 222
    tmp___13 = 16;
  }
#line 222
  return (tmp___13);
}
}
#line 229 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
void Xzs_Construct(CXzs *p ) 
{ 
  size_t tmp ;

  {
#line 231
  tmp = (size_t )0;
#line 231
  p->numAllocated = tmp;
#line 231
  p->num = tmp;
#line 232
  p->streams = (CXzStream *)0;
#line 233
  return;
}
}
#line 235 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
void Xzs_Free(CXzs *p , ISzAlloc *alloc ) 
{ 
  size_t i ;
  size_t tmp ;

  {
#line 238
  i = (size_t )0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < p->num)) {
#line 238
      goto while_break;
    }
    {
#line 239
    Xz_Free(p->streams + i, alloc);
#line 238
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  (*(alloc->Free))((void *)alloc, (void *)p->streams);
#line 241
  tmp = (size_t )0;
#line 241
  p->numAllocated = tmp;
#line 241
  p->num = tmp;
#line 242
  p->streams = (CXzStream *)0;
  }
#line 243
  return;
}
}
#line 245 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
UInt64 Xzs_GetNumBlocks(CXzs const   *p ) 
{ 
  UInt64 num ;
  size_t i ;

  {
#line 247
  num = (UInt64 )0;
#line 249
  i = (size_t )0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (! (i < (size_t )p->num)) {
#line 249
      goto while_break;
    }
#line 250
    num += (UInt64 )(p->streams + i)->numBlocks;
#line 249
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return (num);
}
}
#line 254 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
UInt64 Xzs_GetUnpackSize(CXzs const   *p ) 
{ 
  UInt64 size ;
  size_t i ;
  UInt64 newSize ;
  UInt64 tmp ;

  {
#line 256
  size = (UInt64 )0;
#line 258
  i = (size_t )0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (i < (size_t )p->num)) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp = Xz_GetUnpackSize((CXzStream const   *)(p->streams + i));
#line 259
    newSize = size + tmp;
    }
#line 259
    if (newSize < size) {
#line 259
      return ((UInt64 )((Int64 )-1));
    }
#line 259
    size = newSize;
#line 258
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (size);
}
}
#line 274 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzIn.c"
SRes Xzs_ReadBackward(CXzs *p , ILookInStream *stream , Int64 *startOffset , ICompressProgress *progress ,
                      ISzAlloc *alloc ) 
{ 
  Int64 endOffset ;
  int __result__ ;
  SRes tmp ;
  CXzStream st ;
  SRes res ;
  int __result_____0 ;
  size_t newNum ;
  Byte *data ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int __result_____1 ;
  SRes tmp___2 ;
  SRes tmp___3 ;

  {
  {
#line 276
  endOffset = (Int64 )0;
#line 277
  tmp = (*(stream->Seek))((void *)stream, & endOffset, (ESzSeek )2);
#line 277
  __result__ = tmp;
  }
#line 277
  if (__result__ != 0) {
#line 277
    return (__result__);
  }
#line 278
  *startOffset = endOffset;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 283
    Xz_Construct(& st);
#line 284
    res = Xz_ReadBackward(& st, stream, startOffset, alloc);
#line 285
    st.startOffset = (UInt64 )*startOffset;
#line 286
    __result_____0 = res;
    }
#line 286
    if (__result_____0 != 0) {
#line 286
      return (__result_____0);
    }
#line 287
    if (p->num == p->numAllocated) {
      {
#line 289
      newNum = (p->num + p->num / 4UL) + 1UL;
#line 290
      tmp___0 = (*(alloc->Alloc))((void *)alloc, newNum * sizeof(CXzStream ));
#line 290
      data = (Byte *)tmp___0;
      }
#line 291
      if ((unsigned long )data == (unsigned long )((Byte *)0)) {
#line 292
        return (2);
      }
      {
#line 293
      p->numAllocated = newNum;
#line 294
      memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)p->streams,
             p->num * sizeof(CXzStream ));
#line 295
      (*(alloc->Free))((void *)alloc, (void *)p->streams);
#line 296
      p->streams = (CXzStream *)data;
      }
    }
#line 298
    tmp___1 = p->num;
#line 298
    (p->num) ++;
#line 298
    *(p->streams + tmp___1) = st;
#line 299
    if (*startOffset == 0LL) {
#line 300
      goto while_break;
    }
    {
#line 301
    tmp___2 = (*(stream->Seek))((void *)stream, startOffset, (ESzSeek )0);
#line 301
    __result_____1 = tmp___2;
    }
#line 301
    if (__result_____1 != 0) {
#line 301
      return (__result_____1);
    }
#line 302
    if (progress) {
      {
#line 302
      tmp___3 = (*(progress->Progress))((void *)progress, (UInt64 )(endOffset - *startOffset),
                                        (UInt64 )((Int64 )-1));
      }
#line 302
      if (tmp___3 != 0) {
#line 303
        return (10);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (0);
}
}
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/HuffEnc.h"
void Huffman_Generate(UInt32 const   *freqs , UInt32 *p , Byte *lens , UInt32 numSymbols ,
                      UInt32 maxLen ) ;
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/HuffEnc.c"
void Huffman_Generate(UInt32 const   *freqs , UInt32 *p , Byte *lens , UInt32 numSymbols ,
                      UInt32 maxLen ) 
{ 
  UInt32 num ;
  UInt32 i ;
  UInt32 counters[64] ;
  UInt32 freq ;
  UInt32 tmp ;
  UInt32 temp ;
  UInt32 freq___0 ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;
  unsigned int minCode ;
  unsigned int maxCode ;
  Byte tmp___2 ;
  UInt32 b ;
  UInt32 e ;
  UInt32 i___0 ;
  UInt32 n ;
  UInt32 m ;
  UInt32 freq___1 ;
  UInt32 tmp___3 ;
  UInt32 tmp___4 ;
  UInt32 tmp___5 ;
  UInt32 tmp___6 ;
  UInt32 lenCounters[17] ;
  UInt32 len ;
  UInt32 len___0 ;
  UInt32 num___0 ;
  UInt32 tmp___7 ;
  UInt32 nextCodes[17] ;
  UInt32 code ;
  UInt32 len___1 ;
  UInt32 i___1 ;
  UInt32 tmp___8 ;

  {
#line 17
  num = (UInt32 )0;
#line 25
  i = (UInt32 )0;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i < 64U)) {
#line 25
      goto while_break;
    }
#line 26
    counters[i] = (UInt32 )0;
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 27
  i = (UInt32 )0;
  {
#line 27
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 27
    if (! (i < numSymbols)) {
#line 27
      goto while_break___0;
    }
#line 29
    freq = (UInt32 )*(freqs + i);
#line 30
    if (freq < 63U) {
#line 30
      tmp = freq;
    } else {
#line 30
      tmp = (UInt32 )63;
    }
#line 30
    (counters[tmp]) ++;
#line 27
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 33
  i = (UInt32 )1;
  {
#line 33
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 33
    if (! (i < 64U)) {
#line 33
      goto while_break___1;
    }
#line 35
    temp = counters[i];
#line 36
    counters[i] = num;
#line 37
    num += temp;
#line 33
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 40
  i = (UInt32 )0;
  {
#line 40
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 40
    if (! (i < numSymbols)) {
#line 40
      goto while_break___2;
    }
#line 42
    freq___0 = (UInt32 )*(freqs + i);
#line 43
    if (freq___0 == 0U) {
#line 44
      *(lens + i) = (Byte )0;
    } else {
#line 46
      if (freq___0 < 63U) {
#line 46
        tmp___0 = freq___0;
      } else {
#line 46
        tmp___0 = (UInt32 )63;
      }
#line 46
      tmp___1 = counters[tmp___0];
#line 46
      (counters[tmp___0]) ++;
#line 46
      *(p + tmp___1) = i | (freq___0 << 10);
    }
#line 40
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 48
  counters[0] = (UInt32 )0;
#line 49
  HeapSort(p + counters[62], counters[63] - counters[62]);
  }
#line 66
  if (num < 2U) {
#line 68
    minCode = 0U;
#line 69
    maxCode = 1U;
#line 70
    if (num == 1U) {
#line 72
      maxCode = *(p + 0) & (unsigned int )((1 << 10) - 1);
#line 73
      if (maxCode == 0U) {
#line 74
        maxCode ++;
      }
    }
#line 76
    *(p + minCode) = (UInt32 )0;
#line 77
    *(p + maxCode) = (UInt32 )1;
#line 78
    tmp___2 = (Byte )1;
#line 78
    *(lens + maxCode) = tmp___2;
#line 78
    *(lens + minCode) = tmp___2;
#line 79
    return;
  }
#line 85
  e = (UInt32 )0;
#line 85
  b = e;
#line 85
  i___0 = b;
  {
#line 86
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 89
    if (i___0 != num) {
#line 89
      if (b == e) {
#line 89
        tmp___3 = i___0;
#line 89
        i___0 ++;
#line 89
        n = tmp___3;
      } else
#line 89
      if (*(p + i___0) >> 10 <= *(p + b) >> 10) {
#line 89
        tmp___3 = i___0;
#line 89
        i___0 ++;
#line 89
        n = tmp___3;
      } else {
#line 89
        tmp___4 = b;
#line 89
        b ++;
#line 89
        n = tmp___4;
      }
    } else {
#line 89
      tmp___4 = b;
#line 89
      b ++;
#line 89
      n = tmp___4;
    }
#line 90
    freq___1 = *(p + n) & (unsigned int )(~ ((1 << 10) - 1));
#line 91
    *(p + n) = (*(p + n) & (unsigned int )((1 << 10) - 1)) | (e << 10);
#line 92
    if (i___0 != num) {
#line 92
      if (b == e) {
#line 92
        tmp___5 = i___0;
#line 92
        i___0 ++;
#line 92
        m = tmp___5;
      } else
#line 92
      if (*(p + i___0) >> 10 <= *(p + b) >> 10) {
#line 92
        tmp___5 = i___0;
#line 92
        i___0 ++;
#line 92
        m = tmp___5;
      } else {
#line 92
        tmp___6 = b;
#line 92
        b ++;
#line 92
        m = tmp___6;
      }
    } else {
#line 92
      tmp___6 = b;
#line 92
      b ++;
#line 92
      m = tmp___6;
    }
#line 93
    freq___1 += *(p + m) & (unsigned int )(~ ((1 << 10) - 1));
#line 94
    *(p + m) = (*(p + m) & (unsigned int )((1 << 10) - 1)) | (e << 10);
#line 95
    *(p + e) = (*(p + e) & (unsigned int )((1 << 10) - 1)) | freq___1;
#line 96
    e ++;
#line 86
    if (! (num - e > 1U)) {
#line 86
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 102
  i___0 = (UInt32 )0;
  {
#line 102
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 102
    if (! (i___0 <= 16U)) {
#line 102
      goto while_break___4;
    }
#line 103
    lenCounters[i___0] = (UInt32 )0;
#line 102
    i___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 105
  e --;
#line 105
  *(p + e) &= (unsigned int )((1 << 10) - 1);
#line 106
  lenCounters[1] = (UInt32 )2;
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 107
    if (! (e > 0U)) {
#line 107
      goto while_break___5;
    }
#line 109
    e --;
#line 109
    len = (*(p + (*(p + e) >> 10)) >> 10) + 1U;
#line 110
    *(p + e) = (*(p + e) & (unsigned int )((1 << 10) - 1)) | (len << 10);
#line 111
    if (len >= maxLen) {
#line 112
      len = maxLen - 1U;
      {
#line 112
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 112
        if (! (lenCounters[len] == 0U)) {
#line 112
          goto while_break___6;
        }
#line 112
        len --;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 113
    (lenCounters[len]) --;
#line 114
    lenCounters[len + 1U] += 2U;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 119
  i___0 = (UInt32 )0;
#line 120
  len___0 = maxLen;
  {
#line 120
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 120
    if (! (len___0 != 0U)) {
#line 120
      goto while_break___7;
    }
#line 123
    num___0 = lenCounters[len___0];
    {
#line 123
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 123
      if (! (num___0 != 0U)) {
#line 123
        goto while_break___8;
      }
#line 124
      tmp___7 = i___0;
#line 124
      i___0 ++;
#line 124
      *(lens + (*(p + tmp___7) & (unsigned int )((1 << 10) - 1))) = (Byte )len___0;
#line 123
      num___0 --;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 120
    len___0 --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 131
  code = (UInt32 )0;
#line 133
  len___1 = (UInt32 )1;
  {
#line 133
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 133
    if (! (len___1 <= 16U)) {
#line 133
      goto while_break___9;
    }
#line 134
    code = (code + lenCounters[len___1 - 1U]) << 1;
#line 134
    nextCodes[len___1] = code;
#line 133
    len___1 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 140
  i___1 = (UInt32 )0;
  {
#line 140
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 140
    if (! (i___1 < numSymbols)) {
#line 140
      goto while_break___10;
    }
#line 141
    tmp___8 = nextCodes[*(lens + i___1)];
#line 141
    (nextCodes[*(lens + i___1)]) ++;
#line 141
    *(p + i___1) = tmp___8;
#line 140
    i___1 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Types.h"
SRes LookInStream_LookRead(ILookInStream *stream , void *buf , size_t *size ) ;
#line 184
SRes LookInStream_SeekTo(ILookInStream *stream , UInt64 offset ) ;
#line 188
SRes LookInStream_Read(ILookInStream *stream , void *buf , size_t size ) ;
#line 201
void LookToRead_CreateVTable(CLookToRead *p , int lookahead ) ;
#line 202
void LookToRead_Init(CLookToRead *p ) ;
#line 210
void SecToLook_CreateVTable(CSecToLook *p ) ;
#line 8 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
SRes SeqInStream_Read2(ISeqInStream *stream , void *buf , size_t size , SRes errorType ) 
{ 
  size_t processed ;
  int __result__ ;
  SRes tmp ;

  {
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! (size != 0UL)) {
#line 10
      goto while_break;
    }
    {
#line 12
    processed = size;
#line 13
    tmp = (*(stream->Read))((void *)stream, buf, & processed);
#line 13
    __result__ = tmp;
    }
#line 13
    if (__result__ != 0) {
#line 13
      return (__result__);
    }
#line 14
    if (processed == 0UL) {
#line 15
      return (errorType);
    }
#line 16
    buf = (void *)((Byte *)buf + processed);
#line 17
    size -= processed;
  }
  while_break: /* CIL Label */ ;
  }
#line 19
  return (0);
}
}
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
SRes SeqInStream_Read(ISeqInStream *stream , void *buf , size_t size ) 
{ 
  SRes tmp ;

  {
  {
#line 24
  tmp = SeqInStream_Read2(stream, buf, size, 6);
  }
#line 24
  return (tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
SRes SeqInStream_ReadByte(ISeqInStream *stream , Byte *buf ) 
{ 
  size_t processed ;
  int __result__ ;
  SRes tmp ;
  int tmp___0 ;

  {
  {
#line 29
  processed = (size_t )1;
#line 30
  tmp = (*(stream->Read))((void *)stream, (void *)buf, & processed);
#line 30
  __result__ = tmp;
  }
#line 30
  if (__result__ != 0) {
#line 30
    return (__result__);
  }
#line 31
  if (processed == 1UL) {
#line 31
    tmp___0 = 0;
  } else {
#line 31
    tmp___0 = 6;
  }
#line 31
  return (tmp___0);
}
}
#line 34 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
SRes LookInStream_SeekTo(ILookInStream *stream , UInt64 offset ) 
{ 
  Int64 t ;
  SRes tmp ;

  {
  {
#line 36
  t = (Int64 )offset;
#line 37
  tmp = (*(stream->Seek))((void *)stream, & t, (ESzSeek )0);
  }
#line 37
  return (tmp);
}
}
#line 40 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
SRes LookInStream_LookRead(ILookInStream *stream , void *buf , size_t *size ) 
{ 
  void const   *lookBuf ;
  int __result__ ;
  SRes tmp ;
  SRes tmp___0 ;

  {
#line 43
  if (*size == 0UL) {
#line 44
    return (0);
  }
  {
#line 45
  tmp = (*(stream->Look))((void *)stream, & lookBuf, size);
#line 45
  __result__ = tmp;
  }
#line 45
  if (__result__ != 0) {
#line 45
    return (__result__);
  }
  {
#line 46
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)lookBuf, *size);
#line 47
  tmp___0 = (*(stream->Skip))((void *)stream, *size);
  }
#line 47
  return (tmp___0);
}
}
#line 50 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
SRes LookInStream_Read2(ILookInStream *stream , void *buf , size_t size , SRes errorType ) 
{ 
  size_t processed ;
  int __result__ ;
  SRes tmp ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (size != 0UL)) {
#line 52
      goto while_break;
    }
    {
#line 54
    processed = size;
#line 55
    tmp = (*(stream->Read))((void *)stream, buf, & processed);
#line 55
    __result__ = tmp;
    }
#line 55
    if (__result__ != 0) {
#line 55
      return (__result__);
    }
#line 56
    if (processed == 0UL) {
#line 57
      return (errorType);
    }
#line 58
    buf = (void *)((Byte *)buf + processed);
#line 59
    size -= processed;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (0);
}
}
#line 64 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
SRes LookInStream_Read(ILookInStream *stream , void *buf , size_t size ) 
{ 
  SRes tmp ;

  {
  {
#line 66
  tmp = LookInStream_Read2(stream, buf, size, 6);
  }
#line 66
  return (tmp);
}
}
#line 69 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
static SRes LookToRead_Look_Lookahead(void *pp , void const   **buf , size_t *size ) 
{ 
  SRes res ;
  CLookToRead *p ;
  size_t size2 ;

  {
#line 71
  res = 0;
#line 72
  p = (CLookToRead *)pp;
#line 73
  size2 = p->size - p->pos;
#line 74
  if (size2 == 0UL) {
#line 74
    if (*size > 0UL) {
      {
#line 76
      p->pos = (size_t )0;
#line 77
      size2 = (size_t )(1 << 14);
#line 78
      res = (*((p->realStream)->Read))((void *)p->realStream, (void *)(p->buf), & size2);
#line 79
      p->size = size2;
      }
    }
  }
#line 81
  if (size2 < *size) {
#line 82
    *size = size2;
  }
#line 83
  *buf = (void const   *)(p->buf + p->pos);
#line 84
  return (res);
}
}
#line 87 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
static SRes LookToRead_Look_Exact(void *pp , void const   **buf , size_t *size ) 
{ 
  SRes res ;
  CLookToRead *p ;
  size_t size2 ;
  size_t tmp ;

  {
#line 89
  res = 0;
#line 90
  p = (CLookToRead *)pp;
#line 91
  size2 = p->size - p->pos;
#line 92
  if (size2 == 0UL) {
#line 92
    if (*size > 0UL) {
#line 94
      p->pos = (size_t )0;
#line 95
      if (*size > (size_t )(1 << 14)) {
#line 96
        *size = (size_t )(1 << 14);
      }
      {
#line 97
      res = (*((p->realStream)->Read))((void *)p->realStream, (void *)(p->buf), size);
#line 98
      tmp = *size;
#line 98
      p->size = tmp;
#line 98
      size2 = tmp;
      }
    }
  }
#line 100
  if (size2 < *size) {
#line 101
    *size = size2;
  }
#line 102
  *buf = (void const   *)(p->buf + p->pos);
#line 103
  return (res);
}
}
#line 106 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
static SRes LookToRead_Skip(void *pp , size_t offset ) 
{ 
  CLookToRead *p ;

  {
#line 108
  p = (CLookToRead *)pp;
#line 109
  p->pos += offset;
#line 110
  return (0);
}
}
#line 113 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
static SRes LookToRead_Read(void *pp , void *buf , size_t *size ) 
{ 
  CLookToRead *p ;
  size_t rem ;
  SRes tmp ;

  {
#line 115
  p = (CLookToRead *)pp;
#line 116
  rem = p->size - p->pos;
#line 117
  if (rem == 0UL) {
    {
#line 118
    tmp = (*((p->realStream)->Read))((void *)p->realStream, buf, size);
    }
#line 118
    return (tmp);
  }
#line 119
  if (rem > *size) {
#line 120
    rem = *size;
  }
  {
#line 121
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(p->buf + p->pos),
         rem);
#line 122
  p->pos += rem;
#line 123
  *size = rem;
  }
#line 124
  return (0);
}
}
#line 127 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
static SRes LookToRead_Seek(void *pp , Int64 *pos , ESzSeek origin ) 
{ 
  CLookToRead *p ;
  size_t tmp ;
  SRes tmp___0 ;

  {
  {
#line 129
  p = (CLookToRead *)pp;
#line 130
  tmp = (size_t )0;
#line 130
  p->size = tmp;
#line 130
  p->pos = tmp;
#line 131
  tmp___0 = (*((p->realStream)->Seek))((void *)p->realStream, pos, origin);
  }
#line 131
  return (tmp___0);
}
}
#line 134 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
void LookToRead_CreateVTable(CLookToRead *p , int lookahead ) 
{ 


  {
#line 136
  if (lookahead) {
#line 136
    p->s.Look = & LookToRead_Look_Lookahead;
  } else {
#line 136
    p->s.Look = & LookToRead_Look_Exact;
  }
#line 139
  p->s.Skip = & LookToRead_Skip;
#line 140
  p->s.Read = & LookToRead_Read;
#line 141
  p->s.Seek = & LookToRead_Seek;
#line 142
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
void LookToRead_Init(CLookToRead *p ) 
{ 
  size_t tmp ;

  {
#line 146
  tmp = (size_t )0;
#line 146
  p->size = tmp;
#line 146
  p->pos = tmp;
#line 147
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
static SRes SecToLook_Read(void *pp , void *buf , size_t *size ) 
{ 
  CSecToLook *p ;
  SRes tmp ;

  {
  {
#line 151
  p = (CSecToLook *)pp;
#line 152
  tmp = LookInStream_LookRead(p->realStream, buf, size);
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
void SecToLook_CreateVTable(CSecToLook *p ) 
{ 


  {
#line 157
  p->s.Read = & SecToLook_Read;
#line 158
  return;
}
}
#line 160 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
static SRes SecToRead_Read(void *pp , void *buf , size_t *size ) 
{ 
  CSecToRead *p ;
  SRes tmp ;

  {
  {
#line 162
  p = (CSecToRead *)pp;
#line 163
  tmp = (*((p->realStream)->Read))((void *)p->realStream, buf, size);
  }
#line 163
  return (tmp);
}
}
#line 166 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zStream.c"
void SecToRead_CreateVTable(CSecToRead *p ) 
{ 


  {
#line 168
  p->s.Read = & SecToRead_Read;
#line 169
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 11 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.h"
UInt32 g_CrcTable[2048] ;
#line 57 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra.h"
SizeT x86_Convert(Byte *data , SizeT size , UInt32 ip , UInt32 *state , int encoding ) ;
#line 58
SizeT ARM_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) ;
#line 59
SizeT ARMT_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) ;
#line 60
SizeT PPC_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) ;
#line 61
SizeT SPARC_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) ;
#line 62
SizeT IA64_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) ;
#line 138 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
void LzmaDec_Free(CLzmaDec *p , ISzAlloc *alloc ) ;
#line 32 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.h"
SRes Lzma2Dec_Allocate(CLzma2Dec *p , Byte prop , ISzAlloc *alloc ) ;
#line 33
void Lzma2Dec_Init(CLzma2Dec *p ) ;
#line 54
SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                          SizeT *srcLen , ELzmaFinishMode finishMode , ELzmaStatus *status ) ;
#line 174 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Xz.h"
void MixCoder_Construct(CMixCoder *p , ISzAlloc *alloc ) ;
#line 175
void MixCoder_Free(CMixCoder *p ) ;
#line 176
void MixCoder_Init(CMixCoder *p ) ;
#line 177
SRes MixCoder_SetFromMethod(CMixCoder *p , int coderIndex , UInt64 methodId ) ;
#line 178
SRes MixCoder_Code(CMixCoder *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                   SizeT *srcLen , int srcWasFinished , ECoderFinishMode finishMode ,
                   ECoderStatus *status ) ;
#line 223
SRes XzUnpacker_Create(CXzUnpacker *p , ISzAlloc *alloc ) ;
#line 224
void XzUnpacker_Free(CXzUnpacker *p ) ;
#line 244
SRes XzUnpacker_Code(CXzUnpacker *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                     SizeT *srcLen , int finishMode , ECoderStatus *status ) ;
#line 248
Bool XzUnpacker_IsStreamWasFinished(CXzUnpacker *p ) ;
#line 30 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
unsigned int Xz_ReadVarInt(Byte const   *p , size_t maxSize , UInt64 *value ) 
{ 
  int i ;
  int limit ;
  Byte b ;
  int tmp ;
  int tmp___0 ;

  {
#line 33
  *value = (UInt64 )0;
#line 34
  if (maxSize > 9UL) {
#line 34
    limit = 9;
  } else {
#line 34
    limit = (int )maxSize;
  }
#line 36
  i = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i < limit)) {
#line 36
      goto while_break;
    }
#line 38
    b = (Byte )*(p + i);
#line 39
    tmp = i;
#line 39
    i ++;
#line 39
    *value |= (UInt64 )((int )b & 127) << 7 * tmp;
#line 40
    if (((int )b & 128) == 0) {
#line 41
      if ((int )b == 0) {
#line 41
        if (i != 1) {
#line 41
          tmp___0 = 0;
        } else {
#line 41
          tmp___0 = i;
        }
      } else {
#line 41
        tmp___0 = i;
      }
#line 41
      return ((unsigned int )tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (0U);
}
}
#line 66 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
void BraState_Free(void *pp , ISzAlloc *alloc ) 
{ 


  {
  {
#line 68
  (*(alloc->Free))((void *)alloc, pp);
  }
#line 69
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes BraState_SetProps(void *pp , Byte const   *props , size_t propSize , ISzAlloc *alloc ) 
{ 
  CBraState *p ;
  UInt32 v ;

  {
#line 73
  p = (CBraState *)pp;
#line 74
  alloc = alloc;
#line 75
  p->encodeMode = 0;
#line 76
  p->ip = (UInt32 )0;
#line 77
  if (p->methodId == 3U) {
#line 79
    if (propSize != 1UL) {
#line 80
      return (4);
    }
#line 81
    p->delta = (unsigned int )*(props + 0) + 1U;
  } else
#line 85
  if (propSize == 4UL) {
#line 87
    v = (UInt32 )*((UInt32 const   *)props);
    {
#line 92
    if (p->methodId == 9U) {
#line 92
      goto case_9;
    }
#line 92
    if (p->methodId == 7U) {
#line 92
      goto case_9;
    }
#line 92
    if (p->methodId == 5U) {
#line 92
      goto case_9;
    }
#line 96
    if (p->methodId == 8U) {
#line 96
      goto case_8;
    }
#line 100
    if (p->methodId == 6U) {
#line 100
      goto case_6;
    }
#line 88
    goto switch_break;
    case_9: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 93
    if ((v & 3U) != 0U) {
#line 94
      return (4);
    }
#line 95
    goto switch_break;
    case_8: /* CIL Label */ 
#line 97
    if ((v & 1U) != 0U) {
#line 98
      return (4);
    }
#line 99
    goto switch_break;
    case_6: /* CIL Label */ 
#line 101
    if ((v & 15U) != 0U) {
#line 102
      return (4);
    }
#line 103
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 105
    p->ip = v;
  } else
#line 107
  if (propSize != 0UL) {
#line 108
    return (4);
  }
#line 110
  return (0);
}
}
#line 113 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
void BraState_Init(void *pp ) 
{ 
  CBraState *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 115
  p = (CBraState *)pp;
#line 116
  tmp___0 = (size_t )0;
#line 116
  p->bufTotal = tmp___0;
#line 116
  tmp = tmp___0;
#line 116
  p->bufConv = tmp;
#line 116
  p->bufPos = tmp;
#line 117
  p->x86State = (UInt32 )0;
#line 118
  if (p->methodId == 3U) {
    {
#line 119
    Delta_Init(p->deltaState);
    }
  }
#line 120
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
static SRes BraState_Code(void *pp , Byte *dest , SizeT *destLen , Byte const   *src ,
                          SizeT *srcLen , int srcWasFinished , ECoderFinishMode finishMode ,
                          int *wasFinished ) 
{ 
  CBraState *p ;
  SizeT destLenOrig ;
  SizeT srcLenOrig ;
  size_t curSize ;
  size_t curSize___0 ;

  {
#line 127
  p = (CBraState *)pp;
#line 128
  destLenOrig = *destLen;
#line 129
  srcLenOrig = *srcLen;
#line 130
  *destLen = (SizeT )0;
#line 131
  *srcLen = (SizeT )0;
#line 132
  finishMode = finishMode;
#line 133
  *wasFinished = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (destLenOrig > 0UL)) {
#line 134
      goto while_break;
    }
#line 136
    if (p->bufPos != p->bufConv) {
#line 138
      curSize = p->bufConv - p->bufPos;
#line 139
      if (curSize > destLenOrig) {
#line 140
        curSize = destLenOrig;
      }
      {
#line 141
      memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)(p->buf + p->bufPos),
             curSize);
#line 142
      p->bufPos += curSize;
#line 143
      *destLen += curSize;
#line 144
      dest += curSize;
#line 145
      destLenOrig -= curSize;
      }
#line 146
      goto while_continue;
    }
    {
#line 148
    p->bufTotal -= p->bufPos;
#line 149
    memmove((void *)(p->buf), (void const   *)(p->buf + p->bufPos), p->bufTotal);
#line 150
    p->bufPos = (size_t )0;
#line 151
    p->bufConv = (size_t )0;
#line 153
    curSize___0 = (size_t )(1 << 14) - p->bufTotal;
    }
#line 154
    if (curSize___0 > srcLenOrig) {
#line 155
      curSize___0 = srcLenOrig;
    }
    {
#line 156
    memcpy((void */* __restrict  */)(p->buf + p->bufTotal), (void const   */* __restrict  */)src,
           curSize___0);
#line 157
    *srcLen += curSize___0;
#line 158
    src += curSize___0;
#line 159
    srcLenOrig -= curSize___0;
#line 160
    p->bufTotal += curSize___0;
    }
#line 162
    if (p->bufTotal == 0UL) {
#line 163
      goto while_break;
    }
    {
#line 166
    if (p->methodId == 3U) {
#line 166
      goto case_3;
    }
#line 173
    if (p->methodId == 4U) {
#line 173
      goto case_4;
    }
#line 176
    if (p->methodId == 5U) {
#line 176
      goto case_5;
    }
#line 177
    if (p->methodId == 6U) {
#line 177
      goto case_6;
    }
#line 178
    if (p->methodId == 7U) {
#line 178
      goto case_7;
    }
#line 179
    if (p->methodId == 8U) {
#line 179
      goto case_8;
    }
#line 180
    if (p->methodId == 9U) {
#line 180
      goto case_9;
    }
#line 181
    goto switch_default;
    case_3: /* CIL Label */ 
#line 167
    if (p->encodeMode) {
      {
#line 168
      Delta_Encode(p->deltaState, p->delta, p->buf, p->bufTotal);
      }
    } else {
      {
#line 170
      Delta_Decode(p->deltaState, p->delta, p->buf, p->bufTotal);
      }
    }
#line 171
    p->bufConv = p->bufTotal;
#line 172
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 174
    p->bufConv = x86_Convert(p->buf, p->bufTotal, p->ip, & p->x86State, p->encodeMode);
    }
#line 175
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 176
    p->bufConv = PPC_Convert(p->buf, p->bufTotal, p->ip, p->encodeMode);
    }
#line 176
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 177
    p->bufConv = IA64_Convert(p->buf, p->bufTotal, p->ip, p->encodeMode);
    }
#line 177
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 178
    p->bufConv = ARM_Convert(p->buf, p->bufTotal, p->ip, p->encodeMode);
    }
#line 178
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 179
    p->bufConv = ARMT_Convert(p->buf, p->bufTotal, p->ip, p->encodeMode);
    }
#line 179
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 180
    p->bufConv = SPARC_Convert(p->buf, p->bufTotal, p->ip, p->encodeMode);
    }
#line 180
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 182
    return (4);
    switch_break: /* CIL Label */ ;
    }
#line 184
    p->ip += (UInt32 )p->bufConv;
#line 186
    if (p->bufConv == 0UL) {
#line 188
      if (! srcWasFinished) {
#line 189
        goto while_break;
      }
#line 190
      p->bufConv = p->bufTotal;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (p->bufTotal == p->bufPos) {
#line 193
    if (srcLenOrig == 0UL) {
#line 193
      if (srcWasFinished) {
#line 194
        *wasFinished = 1;
      }
    }
  }
#line 195
  return (0);
}
}
#line 198 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes BraState_SetFromMethod(IStateCoder *p , UInt64 id , ISzAlloc *alloc ) 
{ 
  CBraState *decoder ;
  void *tmp ;

  {
#line 201
  if (id != 3ULL) {
#line 201
    if (id != 4ULL) {
#line 201
      if (id != 5ULL) {
#line 201
        if (id != 6ULL) {
#line 201
          if (id != 7ULL) {
#line 201
            if (id != 8ULL) {
#line 201
              if (id != 9ULL) {
#line 208
                return (4);
              }
            }
          }
        }
      }
    }
  }
  {
#line 209
  p->p = (void *)0;
#line 210
  tmp = (*(alloc->Alloc))((void *)alloc, sizeof(CBraState ));
#line 210
  decoder = (CBraState *)tmp;
  }
#line 211
  if ((unsigned long )decoder == (unsigned long )((CBraState *)0)) {
#line 212
    return (2);
  }
#line 213
  decoder->methodId = (UInt32 )id;
#line 214
  p->p = (void *)decoder;
#line 215
  p->Free = & BraState_Free;
#line 216
  p->SetProps = & BraState_SetProps;
#line 217
  p->Init = & BraState_Init;
#line 218
  p->Code = & BraState_Code;
#line 219
  return (0);
}
}
#line 275 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
static void Lzma2State_Free(void *pp , ISzAlloc *alloc ) 
{ 


  {
  {
#line 277
  LzmaDec_Free(& ((CLzma2Dec *)pp)->decoder, alloc);
#line 278
  (*(alloc->Free))((void *)alloc, pp);
  }
#line 279
  return;
}
}
#line 281 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
static SRes Lzma2State_SetProps(void *pp , Byte const   *props , size_t propSize ,
                                ISzAlloc *alloc ) 
{ 
  SRes tmp ;

  {
#line 283
  if (propSize != 1UL) {
#line 284
    return (4);
  }
  {
#line 285
  tmp = Lzma2Dec_Allocate((CLzma2Dec *)pp, (Byte )*(props + 0), alloc);
  }
#line 285
  return (tmp);
}
}
#line 288 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
static void Lzma2State_Init(void *pp ) 
{ 


  {
  {
#line 290
  Lzma2Dec_Init((CLzma2Dec *)pp);
  }
#line 291
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
static SRes Lzma2State_Code(void *pp , Byte *dest , SizeT *destLen , Byte const   *src ,
                            SizeT *srcLen , int srcWasFinished , ECoderFinishMode finishMode ,
                            int *wasFinished ) 
{ 
  ELzmaStatus status ;
  SRes res ;
  SRes tmp ;

  {
  {
#line 298
  tmp = Lzma2Dec_DecodeToBuf((CLzma2Dec *)pp, dest, destLen, src, srcLen, (ELzmaFinishMode )finishMode,
                             & status);
#line 298
  res = tmp;
#line 299
  srcWasFinished = srcWasFinished;
#line 300
  *wasFinished = (unsigned int )status == 1U;
  }
#line 301
  return (res);
}
}
#line 304 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
static SRes Lzma2State_SetFromMethod(IStateCoder *p , ISzAlloc *alloc ) 
{ 
  CLzma2Dec *decoder ;
  void *tmp ;

  {
  {
#line 306
  tmp = (*(alloc->Alloc))((void *)alloc, sizeof(CLzma2Dec ));
#line 306
  decoder = (CLzma2Dec *)tmp;
#line 307
  p->p = (void *)decoder;
  }
#line 308
  if ((unsigned long )decoder == (unsigned long )((CLzma2Dec *)0)) {
#line 309
    return (2);
  }
#line 310
  p->Free = & Lzma2State_Free;
#line 311
  p->SetProps = & Lzma2State_SetProps;
#line 312
  p->Init = & Lzma2State_Init;
#line 313
  p->Code = & Lzma2State_Code;
#line 314
  decoder->decoder.dic = (Byte *)0;
#line 314
  decoder->decoder.probs = (UInt16 *)0;
#line 315
  return (0);
}
}
#line 319 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
void MixCoder_Construct(CMixCoder *p , ISzAlloc *alloc ) 
{ 
  int i ;

  {
#line 322
  p->alloc = alloc;
#line 323
  p->buf = (Byte *)0;
#line 324
  p->numCoders = 0;
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (i < 4)) {
#line 325
      goto while_break;
    }
#line 326
    p->coders[i].p = (void *)0;
#line 325
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  return;
}
}
#line 329 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
void MixCoder_Free(CMixCoder *p ) 
{ 
  int i ;
  IStateCoder *sc ;

  {
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! (i < p->numCoders)) {
#line 332
      goto while_break;
    }
#line 334
    sc = & p->coders[i];
#line 335
    if (p->alloc) {
#line 335
      if (sc->p) {
        {
#line 336
        (*(sc->Free))(sc->p, p->alloc);
        }
      }
    }
#line 332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  p->numCoders = 0;
#line 339
  if (p->buf) {
    {
#line 340
    (*((p->alloc)->Free))((void *)p->alloc, (void *)p->buf);
    }
  }
#line 341
  return;
}
}
#line 343 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
void MixCoder_Init(CMixCoder *p ) 
{ 
  int i ;
  IStateCoder *coder ;

  {
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (i < p->numCoders - 1)) {
#line 346
      goto while_break;
    }
#line 348
    p->size[i] = (size_t )0;
#line 349
    p->pos[i] = (size_t )0;
#line 350
    p->finished[i] = 0;
#line 346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 352
    if (! (i < p->numCoders)) {
#line 352
      goto while_break___0;
    }
    {
#line 354
    coder = & p->coders[i];
#line 355
    (*(coder->Init))(coder->p);
#line 352
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes MixCoder_SetFromMethod(CMixCoder *p , int coderIndex , UInt64 methodId ) 
{ 
  IStateCoder *sc ;
  SRes tmp ;
  SRes tmp___0 ;

  {
#line 361
  sc = & p->coders[coderIndex];
#line 362
  p->ids[coderIndex] = methodId;
  {
#line 365
  if (methodId == 33ULL) {
#line 365
    goto case_33;
  }
#line 363
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 365
  tmp = Lzma2State_SetFromMethod(sc, p->alloc);
  }
#line 365
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
#line 370
  if (coderIndex == 0) {
#line 371
    return (4);
  }
  {
#line 372
  tmp___0 = BraState_SetFromMethod(sc, methodId, p->alloc);
  }
#line 372
  return (tmp___0);
}
}
#line 375 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes MixCoder_Code(CMixCoder *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                   SizeT *srcLen , int srcWasFinished , ECoderFinishMode finishMode ,
                   ECoderStatus *status ) 
{ 
  SizeT destLenOrig ;
  SizeT srcLenOrig ;
  Bool allFinished ;
  void *tmp ;
  Bool processed ;
  int i ;
  SRes res ;
  IStateCoder *coder ;
  Byte *destCur ;
  SizeT destLenCur ;
  SizeT srcLenCur ;
  Byte const   *srcCur ;
  int srcFinishedCur ;
  int encodingWasFinished ;

  {
#line 379
  destLenOrig = *destLen;
#line 380
  srcLenOrig = *srcLen;
#line 381
  allFinished = 1;
#line 382
  *destLen = (SizeT )0;
#line 383
  *srcLen = (SizeT )0;
#line 384
  *status = (ECoderStatus )2;
#line 386
  if ((unsigned long )p->buf == (unsigned long )((Byte *)0)) {
    {
#line 388
    tmp = (*((p->alloc)->Alloc))((void *)p->alloc, (size_t )((1 << 17) * 3));
#line 388
    p->buf = (Byte *)tmp;
    }
#line 389
    if ((unsigned long )p->buf == (unsigned long )((Byte *)0)) {
#line 390
      return (2);
    }
  }
#line 393
  if (p->numCoders != 1) {
#line 394
    finishMode = (ECoderFinishMode )0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    processed = 0;
#line 405
    i = 0;
    {
#line 405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 405
      if (! (i < p->numCoders)) {
#line 405
        goto while_break___0;
      }
#line 408
      coder = & p->coders[i];
#line 415
      if (i == 0) {
#line 417
        srcCur = src;
#line 418
        srcLenCur = srcLenOrig - *srcLen;
#line 419
        srcFinishedCur = srcWasFinished;
      } else {
#line 423
        srcCur = (Byte const   *)((p->buf + (1 << 17) * (i - 1)) + p->pos[i - 1]);
#line 424
        srcLenCur = p->size[i - 1] - p->pos[i - 1];
#line 425
        srcFinishedCur = p->finished[i - 1];
      }
#line 428
      if (i == p->numCoders - 1) {
#line 430
        destCur = dest;
#line 431
        destLenCur = destLenOrig - *destLen;
      } else {
#line 435
        if (p->pos[i] != p->size[i]) {
#line 436
          goto __Cont;
        }
#line 437
        destCur = p->buf + (1 << 17) * i;
#line 438
        destLenCur = (SizeT )(1 << 17);
      }
      {
#line 441
      res = (*(coder->Code))(coder->p, destCur, & destLenCur, srcCur, & srcLenCur,
                             srcFinishedCur, finishMode, & encodingWasFinished);
      }
#line 443
      if (! encodingWasFinished) {
#line 444
        allFinished = 0;
      }
#line 446
      if (i == 0) {
#line 448
        *srcLen += srcLenCur;
#line 449
        src += srcLenCur;
      } else {
#line 453
        p->pos[i - 1] += srcLenCur;
      }
#line 456
      if (i == p->numCoders - 1) {
#line 458
        *destLen += destLenCur;
#line 459
        dest += destLenCur;
      } else {
#line 463
        p->size[i] = destLenCur;
#line 464
        p->pos[i] = (size_t )0;
#line 465
        p->finished[i] = encodingWasFinished;
      }
#line 468
      if (res != 0) {
#line 469
        return (res);
      }
#line 471
      if (destLenCur != 0UL) {
#line 472
        processed = 1;
      } else
#line 471
      if (srcLenCur != 0UL) {
#line 472
        processed = 1;
      }
      __Cont: /* CIL Label */ 
#line 405
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 474
    if (! processed) {
#line 475
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  if (allFinished) {
#line 478
    *status = (ECoderStatus )1;
  }
#line 479
  return (0);
}
}
#line 482 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes Xz_ParseHeader(CXzStreamFlags *p , Byte const   *buf ) 
{ 
  UInt32 tmp ;
  int tmp___0 ;

  {
  {
#line 484
  *p = (CXzStreamFlags )(((int )((UInt16 )*((buf + 6) + 0)) << 8) | (int )*((buf + 6) + 1));
#line 485
  tmp = CrcCalc((void const   *)(buf + 6), (size_t )2);
  }
#line 485
  if (tmp != (UInt32 )*((UInt32 const   *)((buf + 6) + 2))) {
#line 487
    return (17);
  }
#line 488
  if ((int )*p <= 15) {
#line 488
    tmp___0 = 0;
  } else {
#line 488
    tmp___0 = 4;
  }
#line 488
  return (tmp___0);
}
}
#line 491 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
static Bool Xz_CheckFooter(CXzStreamFlags flags , UInt64 indexSize , Byte const   *buf ) 
{ 
  UInt32 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 493
  if (indexSize == ((UInt64 )*((UInt32 const   *)(buf + 4)) + 1ULL) << 2) {
    {
#line 493
    tmp = CrcCalc((void const   *)(buf + 4), (size_t )6);
    }
#line 493
    if (*((UInt32 const   *)buf) == (UInt32 const   )tmp) {
#line 493
      if ((int )flags == (((int )((UInt16 )*((buf + 8) + 0)) << 8) | (int )*((buf + 8) + 1))) {
        {
#line 493
        tmp___0 = memcmp((void const   *)(buf + 10), (void const   *)(XZ_FOOTER_SIG),
                         (size_t )2);
        }
#line 493
        if (tmp___0 == 0) {
#line 493
          tmp___1 = 1;
        } else {
#line 493
          tmp___1 = 0;
        }
      } else {
#line 493
        tmp___1 = 0;
      }
    } else {
#line 493
      tmp___1 = 0;
    }
  } else {
#line 493
    tmp___1 = 0;
  }
#line 493
  return (tmp___1);
}
}
#line 505 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes XzBlock_Parse(CXzBlock *p , Byte const   *header ) 
{ 
  unsigned int pos ;
  int numFilters ;
  int i ;
  UInt32 headerSize ;
  UInt32 tmp ;
  unsigned int tmp___0 ;
  unsigned int s ;
  unsigned int tmp___1 ;
  unsigned int s___0 ;
  unsigned int tmp___2 ;
  CXzFilter *filter ;
  UInt64 size ;
  unsigned int s___1 ;
  unsigned int tmp___3 ;
  unsigned int s___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
#line 509
  headerSize = (UInt32 )*(header + 0) << 2;
#line 511
  tmp = CrcCalc((void const   *)header, (size_t )headerSize);
  }
#line 511
  if (tmp != (UInt32 )*((UInt32 const   *)(header + headerSize))) {
#line 512
    return (16);
  }
#line 514
  pos = 1U;
#line 515
  if (pos == headerSize) {
#line 516
    return (16);
  }
#line 517
  tmp___0 = pos;
#line 517
  pos ++;
#line 517
  p->flags = (Byte )*(header + tmp___0);
#line 519
  if (((int )p->flags & (1 << 6)) != 0) {
    {
#line 521
    tmp___1 = Xz_ReadVarInt(header + pos, (size_t )(headerSize - pos), & p->packSize);
#line 521
    s = tmp___1;
    }
#line 521
    if (s == 0U) {
#line 521
      return (16);
    }
#line 521
    pos += s;
#line 522
    if (p->packSize == 0ULL) {
#line 523
      return (16);
    } else
#line 522
    if (p->packSize + (UInt64 )headerSize >= 1ULL << 63) {
#line 523
      return (16);
    }
  }
#line 526
  if (((int )p->flags & (1 << 7)) != 0) {
    {
#line 527
    tmp___2 = Xz_ReadVarInt(header + pos, (size_t )(headerSize - pos), & p->unpackSize);
#line 527
    s___0 = tmp___2;
    }
#line 527
    if (s___0 == 0U) {
#line 527
      return (16);
    }
#line 527
    pos += s___0;
  }
#line 529
  numFilters = ((int )p->flags & 3) + 1;
#line 530
  i = 0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! (i < numFilters)) {
#line 530
      goto while_break;
    }
    {
#line 532
    filter = p->filters + i;
#line 534
    tmp___3 = Xz_ReadVarInt(header + pos, (size_t )(headerSize - pos), & filter->id);
#line 534
    s___1 = tmp___3;
    }
#line 534
    if (s___1 == 0U) {
#line 534
      return (16);
    }
    {
#line 534
    pos += s___1;
#line 535
    tmp___4 = Xz_ReadVarInt(header + pos, (size_t )(headerSize - pos), & size);
#line 535
    s___2 = tmp___4;
    }
#line 535
    if (s___2 == 0U) {
#line 535
      return (16);
    }
#line 535
    pos += s___2;
#line 536
    if (size > (UInt64 )(headerSize - pos)) {
#line 537
      return (16);
    } else
#line 536
    if (size > 20ULL) {
#line 537
      return (16);
    }
    {
#line 538
    filter->propsSize = (UInt32 )size;
#line 539
    memcpy((void */* __restrict  */)(filter->props), (void const   */* __restrict  */)(header + pos),
           (size_t )size);
#line 540
    pos += (unsigned int )size;
#line 530
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 552
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 552
    if (! (pos < headerSize)) {
#line 552
      goto while_break___0;
    }
#line 553
    tmp___5 = pos;
#line 553
    pos ++;
#line 553
    if ((int const   )*(header + tmp___5) != 0) {
#line 554
      return (16);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 555
  return (0);
}
}
#line 558 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes XzDec_Init(CMixCoder *p , CXzBlock const   *block ) 
{ 
  int i ;
  Bool needReInit ;
  int numFilters ;
  CXzFilter const   *f ;
  int __result__ ;
  SRes tmp ;
  CXzFilter const   *f___0 ;
  IStateCoder *sc ;
  int __result_____0 ;
  SRes tmp___0 ;

  {
#line 561
  needReInit = 1;
#line 562
  numFilters = (int )(((int const   )block->flags & 3) + 1);
#line 563
  if (numFilters == p->numCoders) {
#line 565
    i = 0;
    {
#line 565
    while (1) {
      while_continue: /* CIL Label */ ;
#line 565
      if (! (i < numFilters)) {
#line 565
        goto while_break;
      }
#line 566
      if (p->ids[i] != (UInt64 )block->filters[(numFilters - 1) - i].id) {
#line 567
        goto while_break;
      }
#line 565
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 568
    needReInit = i != numFilters;
  }
#line 570
  if (needReInit) {
    {
#line 572
    MixCoder_Free(p);
#line 573
    p->numCoders = numFilters;
#line 574
    i = 0;
    }
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (i < numFilters)) {
#line 574
        goto while_break___0;
      }
      {
#line 576
      f = (CXzFilter const   *)(& block->filters[(numFilters - 1) - i]);
#line 577
      tmp = MixCoder_SetFromMethod(p, i, (UInt64 )f->id);
#line 577
      __result__ = tmp;
      }
#line 577
      if (__result__ != 0) {
#line 577
        return (__result__);
      }
#line 574
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 580
  i = 0;
  {
#line 580
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 580
    if (! (i < numFilters)) {
#line 580
      goto while_break___1;
    }
    {
#line 582
    f___0 = (CXzFilter const   *)(& block->filters[(numFilters - 1) - i]);
#line 583
    sc = & p->coders[i];
#line 584
    tmp___0 = (*(sc->SetProps))(sc->p, (Byte const   *)(f___0->props), (size_t )f___0->propsSize,
                                p->alloc);
#line 584
    __result_____0 = tmp___0;
    }
#line 584
    if (__result_____0 != 0) {
#line 584
      return (__result_____0);
    }
#line 580
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 586
  MixCoder_Init(p);
  }
#line 587
  return (0);
}
}
#line 590 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes XzUnpacker_Create(CXzUnpacker *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 592
  MixCoder_Construct(& p->decoder, alloc);
#line 593
  p->state = (EXzState )0;
#line 594
  p->pos = (UInt32 )0;
#line 595
  p->numStreams = (UInt64 )0;
  }
#line 596
  return (0);
}
}
#line 599 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
void XzUnpacker_Free(CXzUnpacker *p ) 
{ 


  {
  {
#line 601
  MixCoder_Free(& p->decoder);
  }
#line 602
  return;
}
}
#line 604 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
SRes XzUnpacker_Code(CXzUnpacker *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                     SizeT *srcLen , int finishMode , ECoderStatus *status ) 
{ 
  SizeT destLenOrig ;
  SizeT srcLenOrig ;
  SizeT srcRem ;
  SizeT destLen2 ;
  SizeT srcLen2 ;
  SRes res ;
  int __result__ ;
  Byte temp[32] ;
  unsigned int num ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  UInt32 tmp___2 ;
  Byte const   *tmp___3 ;
  int __result_____0 ;
  SRes tmp___4 ;
  UInt32 tmp___5 ;
  Byte const   *tmp___6 ;
  unsigned int tmp___7 ;
  UInt32 cur ;
  int __result_____1 ;
  SRes tmp___8 ;
  int __result_____2 ;
  SRes tmp___9 ;
  Byte const   *tmp___10 ;
  UInt32 checkSize ;
  unsigned int tmp___11 ;
  UInt32 cur___0 ;
  Byte digest[64] ;
  int tmp___12 ;
  int tmp___13 ;
  Byte const   *tmp___14 ;
  UInt32 tmp___15 ;
  UInt64 cur___1 ;
  Byte b ;
  Byte const   *tmp___16 ;
  Byte digest___0[32] ;
  int tmp___17 ;
  UInt32 tmp___18 ;
  Byte const   *tmp___19 ;
  UInt32 cur___2 ;
  Bool tmp___20 ;

  {
#line 607
  destLenOrig = *destLen;
#line 608
  srcLenOrig = *srcLen;
#line 609
  *destLen = (SizeT )0;
#line 610
  *srcLen = (SizeT )0;
#line 611
  *status = (ECoderStatus )0;
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 614
    srcRem = srcLenOrig - *srcLen;
#line 616
    if ((unsigned int )p->state == 6U) {
#line 618
      destLen2 = destLenOrig - *destLen;
#line 619
      srcLen2 = srcLenOrig - *srcLen;
#line 621
      if (srcLen2 == 0UL) {
#line 621
        if (destLen2 == 0UL) {
#line 623
          *status = (ECoderStatus )2;
#line 624
          return (0);
        }
      }
      {
#line 627
      res = MixCoder_Code(& p->decoder, dest, & destLen2, src, & srcLen2, 0, (ECoderFinishMode )finishMode,
                          status);
#line 628
      XzCheck_Update(& p->check, (void const   *)dest, destLen2);
#line 630
      *srcLen += srcLen2;
#line 631
      src += srcLen2;
#line 632
      p->packSize += (UInt64 )srcLen2;
#line 634
      *destLen += destLen2;
#line 635
      dest += destLen2;
#line 636
      p->unpackSize += (UInt64 )destLen2;
#line 638
      __result__ = res;
      }
#line 638
      if (__result__ != 0) {
#line 638
        return (__result__);
      }
#line 640
      if ((unsigned int )*status == 1U) {
        {
#line 643
        tmp = XzFlags_GetCheckSize(p->streamFlags);
#line 643
        tmp___0 = Xz_WriteVarInt(temp, (p->packSize + (UInt64 )p->blockHeaderSize) + (UInt64 )tmp);
#line 643
        num = tmp___0;
#line 644
        tmp___1 = Xz_WriteVarInt(temp + num, p->unpackSize);
#line 644
        num += tmp___1;
#line 645
        Sha256_Update(& p->sha, (Byte const   *)(temp), (size_t )num);
#line 646
        p->indexSize += (UInt64 )num;
#line 647
        (p->numBlocks) ++;
#line 649
        p->state = (EXzState )7;
#line 650
        p->pos = (UInt32 )0;
#line 651
        p->alignPos = 0U;
        }
      } else
#line 653
      if (srcLen2 == 0UL) {
#line 653
        if (destLen2 == 0UL) {
#line 654
          return (0);
        }
      }
#line 656
      goto __Cont;
    }
#line 659
    if (srcRem == 0UL) {
#line 661
      *status = (ECoderStatus )3;
#line 662
      return (0);
    }
    {
#line 667
    if ((unsigned int )p->state == 0U) {
#line 667
      goto case_0;
    }
#line 688
    if ((unsigned int )p->state == 5U) {
#line 688
      goto case_5;
    }
#line 728
    if ((unsigned int )p->state == 7U) {
#line 728
      goto case_7;
    }
#line 762
    if ((unsigned int )p->state == 1U) {
#line 762
      goto case_1;
    }
#line 807
    if ((unsigned int )p->state == 2U) {
#line 807
      goto case_2;
    }
#line 824
    if ((unsigned int )p->state == 3U) {
#line 824
      goto case_3;
    }
#line 844
    if ((unsigned int )p->state == 4U) {
#line 844
      goto case_4;
    }
#line 862
    if ((unsigned int )p->state == 6U) {
#line 862
      goto case_6;
    }
#line 665
    goto switch_break;
    case_0: /* CIL Label */ 
#line 669
    if (p->pos < 12U) {
#line 671
      if (p->pos < 6U) {
#line 671
        if ((int const   )*src != (int const   )XZ_SIG[p->pos]) {
#line 672
          return (17);
        }
      }
#line 673
      tmp___2 = p->pos;
#line 673
      (p->pos) ++;
#line 673
      tmp___3 = src;
#line 673
      src ++;
#line 673
      p->buf[tmp___2] = (Byte )*tmp___3;
#line 674
      (*srcLen) ++;
    } else {
      {
#line 678
      tmp___4 = Xz_ParseHeader(& p->streamFlags, (Byte const   *)(p->buf));
#line 678
      __result_____0 = tmp___4;
      }
#line 678
      if (__result_____0 != 0) {
#line 678
        return (__result_____0);
      }
      {
#line 679
      p->state = (EXzState )5;
#line 680
      Sha256_Init(& p->sha);
#line 681
      p->indexSize = (UInt64 )0;
#line 682
      p->numBlocks = (UInt64 )0;
#line 683
      p->pos = (UInt32 )0;
      }
    }
#line 685
    goto switch_break;
    case_5: /* CIL Label */ 
#line 690
    if (p->pos == 0U) {
#line 692
      tmp___5 = p->pos;
#line 692
      (p->pos) ++;
#line 692
      tmp___6 = src;
#line 692
      src ++;
#line 692
      p->buf[tmp___5] = (Byte )*tmp___6;
#line 693
      (*srcLen) ++;
#line 694
      if ((int )p->buf[0] == 0) {
        {
#line 696
        tmp___7 = Xz_WriteVarInt(p->buf + 1, p->numBlocks);
#line 696
        p->indexPreSize = 1U + tmp___7;
#line 697
        p->indexPos = (UInt64 )p->indexPreSize;
#line 698
        p->indexSize += (UInt64 )p->indexPreSize;
#line 699
        Sha256_Final(& p->sha, p->shaDigest);
#line 700
        Sha256_Init(& p->sha);
#line 701
        p->crc = CrcUpdate(4294967295U, (void const   *)(p->buf), (size_t )p->indexPreSize);
#line 702
        p->state = (EXzState )1;
        }
      }
#line 704
      p->blockHeaderSize = ((UInt32 )p->buf[0] << 2) + 4U;
    } else
#line 706
    if (p->pos != p->blockHeaderSize) {
#line 708
      cur = p->blockHeaderSize - p->pos;
#line 709
      if ((SizeT )cur > srcRem) {
#line 710
        cur = (UInt32 )srcRem;
      }
      {
#line 711
      memcpy((void */* __restrict  */)(p->buf + p->pos), (void const   */* __restrict  */)src,
             (size_t )cur);
#line 712
      p->pos += cur;
#line 713
      *srcLen += (SizeT )cur;
#line 714
      src += cur;
      }
    } else {
      {
#line 718
      tmp___8 = XzBlock_Parse(& p->block, (Byte const   *)(p->buf));
#line 718
      __result_____1 = tmp___8;
      }
#line 718
      if (__result_____1 != 0) {
#line 718
        return (__result_____1);
      }
      {
#line 719
      p->state = (EXzState )6;
#line 720
      p->packSize = (UInt64 )0;
#line 721
      p->unpackSize = (UInt64 )0;
#line 722
      XzCheck_Init(& p->check, (int )p->streamFlags & 15);
#line 723
      tmp___9 = XzDec_Init(& p->decoder, (CXzBlock const   *)(& p->block));
#line 723
      __result_____2 = tmp___9;
      }
#line 723
      if (__result_____2 != 0) {
#line 723
        return (__result_____2);
      }
    }
#line 725
    goto switch_break;
    case_7: /* CIL Label */ 
#line 730
    if (((p->packSize + (UInt64 )p->alignPos) & 3ULL) != 0ULL) {
#line 732
      (*srcLen) ++;
#line 733
      (p->alignPos) ++;
#line 734
      tmp___10 = src;
#line 734
      src ++;
#line 734
      if ((int const   )*tmp___10 != 0) {
#line 735
        return (3);
      }
    } else {
      {
#line 739
      tmp___11 = XzFlags_GetCheckSize(p->streamFlags);
#line 739
      checkSize = tmp___11;
#line 740
      cur___0 = checkSize - p->pos;
      }
#line 741
      if (cur___0 != 0U) {
#line 743
        if ((SizeT )cur___0 > srcRem) {
#line 744
          cur___0 = (UInt32 )srcRem;
        }
        {
#line 745
        memcpy((void */* __restrict  */)(p->buf + p->pos), (void const   */* __restrict  */)src,
               (size_t )cur___0);
#line 746
        p->pos += cur___0;
#line 747
        *srcLen += (SizeT )cur___0;
#line 748
        src += cur___0;
        }
      } else {
        {
#line 753
        p->state = (EXzState )5;
#line 754
        p->pos = (UInt32 )0;
#line 755
        tmp___12 = XzCheck_Final(& p->check, digest);
        }
#line 755
        if (tmp___12) {
          {
#line 755
          tmp___13 = memcmp((void const   *)(digest), (void const   *)(p->buf), (size_t )checkSize);
          }
#line 755
          if (tmp___13 != 0) {
#line 756
            return (3);
          }
        }
      }
    }
#line 759
    goto switch_break;
    case_1: /* CIL Label */ 
#line 764
    if (p->pos < p->indexPreSize) {
#line 766
      (*srcLen) ++;
#line 767
      tmp___14 = src;
#line 767
      src ++;
#line 767
      tmp___15 = p->pos;
#line 767
      (p->pos) ++;
#line 767
      if ((int const   )*tmp___14 != (int const   )p->buf[tmp___15]) {
#line 768
        return (3);
      }
    } else
#line 772
    if (p->indexPos < p->indexSize) {
#line 774
      cur___1 = p->indexSize - p->indexPos;
#line 775
      if ((UInt64 )srcRem > cur___1) {
#line 776
        srcRem = (SizeT )cur___1;
      }
      {
#line 777
      p->crc = CrcUpdate(p->crc, (void const   *)src, srcRem);
#line 778
      Sha256_Update(& p->sha, src, srcRem);
#line 779
      *srcLen += srcRem;
#line 780
      src += srcRem;
#line 781
      p->indexPos += (UInt64 )srcRem;
      }
    } else
#line 783
    if ((p->indexPos & 3ULL) != 0ULL) {
#line 785
      tmp___16 = src;
#line 785
      src ++;
#line 785
      b = (Byte )*tmp___16;
#line 786
      p->crc = g_CrcTable[(p->crc ^ (unsigned int )b) & 255U] ^ (p->crc >> 8);
#line 787
      (*srcLen) ++;
#line 788
      (p->indexPos) ++;
#line 789
      (p->indexSize) ++;
#line 790
      if ((int )b != 0) {
#line 791
        return (3);
      }
    } else {
      {
#line 796
      p->state = (EXzState )2;
#line 797
      p->indexSize += 4ULL;
#line 798
      p->pos = (UInt32 )0;
#line 799
      Sha256_Final(& p->sha, digest___0);
#line 800
      tmp___17 = memcmp((void const   *)(digest___0), (void const   *)(p->shaDigest),
                        (size_t )32);
      }
#line 800
      if (tmp___17 != 0) {
#line 801
        return (3);
      }
    }
#line 804
    goto switch_break;
    case_2: /* CIL Label */ 
#line 809
    if (p->pos < 4U) {
#line 811
      (*srcLen) ++;
#line 812
      tmp___18 = p->pos;
#line 812
      (p->pos) ++;
#line 812
      tmp___19 = src;
#line 812
      src ++;
#line 812
      p->buf[tmp___18] = (Byte )*tmp___19;
    } else {
#line 816
      p->state = (EXzState )3;
#line 817
      p->pos = (UInt32 )0;
#line 818
      if ((p->crc ^ 4294967295U) != (unsigned int )*((UInt32 const   *)(p->buf))) {
#line 819
        return (3);
      }
    }
#line 821
    goto switch_break;
    case_3: /* CIL Label */ 
#line 826
    cur___2 = 12U - p->pos;
#line 827
    if ((SizeT )cur___2 > srcRem) {
#line 828
      cur___2 = (UInt32 )srcRem;
    }
    {
#line 829
    memcpy((void */* __restrict  */)(p->buf + p->pos), (void const   */* __restrict  */)src,
           (size_t )cur___2);
#line 830
    p->pos += cur___2;
#line 831
    *srcLen += (SizeT )cur___2;
#line 832
    src += cur___2;
    }
#line 833
    if (p->pos == 12U) {
      {
#line 835
      p->state = (EXzState )4;
#line 836
      (p->numStreams) ++;
#line 837
      p->padSize = (UInt64 )0;
#line 838
      tmp___20 = Xz_CheckFooter(p->streamFlags, p->indexSize, (Byte const   *)(p->buf));
      }
#line 838
      if (! tmp___20) {
#line 839
        return (3);
      }
    }
#line 841
    goto switch_break;
    case_4: /* CIL Label */ 
#line 846
    if ((int const   )*src != 0) {
#line 848
      if (((UInt32 )p->padSize & 3U) != 0U) {
#line 849
        return (17);
      }
#line 850
      p->pos = (UInt32 )0;
#line 851
      p->state = (EXzState )0;
    } else {
#line 855
      (*srcLen) ++;
#line 856
      src ++;
#line 857
      (p->padSize) ++;
    }
#line 859
    goto switch_break;
    case_6: /* CIL Label */ 
#line 862
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 872 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzDec.c"
Bool XzUnpacker_IsStreamWasFinished(CXzUnpacker *p ) 
{ 
  int tmp ;

  {
#line 874
  if ((unsigned int )p->state == 4U) {
#line 874
    if (((UInt32 )p->padSize & 3U) == 0U) {
#line 874
      tmp = 1;
    } else {
#line 874
      tmp = 0;
    }
  } else {
#line 874
    tmp = 0;
  }
#line 874
  return (tmp);
}
}
#line 71 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
Byte const   PPMD7_kExpEscape[16] ;
#line 83
void Ppmd7_Update1(CPpmd7 *p ) ;
#line 84
void Ppmd7_Update1_0(CPpmd7 *p ) ;
#line 85
void Ppmd7_Update2(CPpmd7 *p ) ;
#line 86
void Ppmd7_UpdateBin(CPpmd7 *p ) ;
#line 95
CPpmd_See *Ppmd7_MakeEscFreq(CPpmd7 *p , unsigned int numMasked , UInt32 *escFreq ) ;
#line 115
void Ppmd7z_RangeDec_CreateVTable(CPpmd7z_RangeDec *p ) ;
#line 116
Bool Ppmd7z_RangeDec_Init(CPpmd7z_RangeDec *p ) ;
#line 119
int Ppmd7_DecodeSymbol(CPpmd7 *p , IPpmd7_RangeDec *rc ) ;
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Dec.c"
Bool Ppmd7z_RangeDec_Init(CPpmd7z_RangeDec *p ) 
{ 
  unsigned int i ;
  Byte tmp ;
  Byte tmp___0 ;

  {
  {
#line 12
  p->Code = (UInt32 )0;
#line 13
  p->Range = 4294967295U;
#line 14
  tmp = (*((p->Stream)->Read))((void *)p->Stream);
  }
#line 14
  if ((int )tmp != 0) {
#line 15
    return (0);
  }
#line 16
  i = 0U;
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! (i < 4U)) {
#line 16
      goto while_break;
    }
    {
#line 17
    tmp___0 = (*((p->Stream)->Read))((void *)p->Stream);
#line 17
    p->Code = (p->Code << 8) | (unsigned int )tmp___0;
#line 16
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  return (p->Code < 4294967295U);
}
}
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Dec.c"
static UInt32 Range_GetThreshold(void *pp , UInt32 total ) 
{ 
  CPpmd7z_RangeDec *p ;
  UInt32 tmp ;

  {
#line 23
  p = (CPpmd7z_RangeDec *)pp;
#line 24
  tmp = p->Range / total;
#line 24
  p->Range = tmp;
#line 24
  return (p->Code / tmp);
}
}
#line 27 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Dec.c"
static void Range_Normalize(CPpmd7z_RangeDec *p ) 
{ 
  Byte tmp ;
  Byte tmp___0 ;

  {
#line 29
  if (p->Range < (UInt32 )(1 << 24)) {
    {
#line 31
    tmp = (*((p->Stream)->Read))((void *)p->Stream);
#line 31
    p->Code = (p->Code << 8) | (unsigned int )tmp;
#line 32
    p->Range <<= 8;
    }
#line 33
    if (p->Range < (UInt32 )(1 << 24)) {
      {
#line 35
      tmp___0 = (*((p->Stream)->Read))((void *)p->Stream);
#line 35
      p->Code = (p->Code << 8) | (unsigned int )tmp___0;
#line 36
      p->Range <<= 8;
      }
    }
  }
#line 39
  return;
}
}
#line 41 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Dec.c"
static void Range_Decode(void *pp , UInt32 start , UInt32 size ) 
{ 
  CPpmd7z_RangeDec *p ;

  {
  {
#line 43
  p = (CPpmd7z_RangeDec *)pp;
#line 44
  p->Code -= start * p->Range;
#line 45
  p->Range *= size;
#line 46
  Range_Normalize(p);
  }
#line 47
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Dec.c"
static UInt32 Range_DecodeBit(void *pp , UInt32 size0 ) 
{ 
  CPpmd7z_RangeDec *p ;
  UInt32 newBound ;
  UInt32 symbol ;

  {
#line 51
  p = (CPpmd7z_RangeDec *)pp;
#line 52
  newBound = (p->Range >> 14) * size0;
#line 54
  if (p->Code < newBound) {
#line 56
    symbol = (UInt32 )0;
#line 57
    p->Range = newBound;
  } else {
#line 61
    symbol = (UInt32 )1;
#line 62
    p->Code -= newBound;
#line 63
    p->Range -= newBound;
  }
  {
#line 65
  Range_Normalize(p);
  }
#line 66
  return (symbol);
}
}
#line 69 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Dec.c"
void Ppmd7z_RangeDec_CreateVTable(CPpmd7z_RangeDec *p ) 
{ 


  {
#line 71
  p->p.GetThreshold = & Range_GetThreshold;
#line 72
  p->p.Decode = & Range_Decode;
#line 73
  p->p.DecodeBit = & Range_DecodeBit;
#line 74
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Dec.c"
int Ppmd7_DecodeSymbol(CPpmd7 *p , IPpmd7_RangeDec *rc ) 
{ 
  size_t charMask[256UL / sizeof(size_t )] ;
  CPpmd_State *s ;
  unsigned int i ;
  UInt32 count ;
  UInt32 hiCnt ;
  Byte symbol ;
  Byte symbol___0 ;
  unsigned int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  UInt16 *prob ;
  unsigned int tmp___6 ;
  Byte symbol___1 ;
  CPpmd_State *tmp___7 ;
  UInt32 tmp___8 ;
  unsigned int i___1 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  CPpmd_State *ps[256] ;
  CPpmd_State *s___0 ;
  UInt32 freqSum ;
  UInt32 count___0 ;
  UInt32 hiCnt___0 ;
  CPpmd_See *see ;
  unsigned int i___2 ;
  unsigned int num ;
  unsigned int numMasked ;
  int k ;
  CPpmd_State *tmp___16 ;
  Byte symbol___2 ;
  CPpmd_State **pps ;
  Byte tmp___17 ;

  {
#line 82
  if ((int )(p->MinContext)->NumStats != 1) {
    {
#line 84
    s = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 87
    count = (*(rc->GetThreshold))((void *)rc, (UInt32 )(p->MinContext)->SummFreq);
#line 87
    hiCnt = (UInt32 )s->Freq;
    }
#line 87
    if (count < hiCnt) {
      {
#line 90
      (*(rc->Decode))((void *)rc, (UInt32 )0, (UInt32 )s->Freq);
#line 91
      p->FoundState = s;
#line 92
      symbol = s->Symbol;
#line 93
      Ppmd7_Update1_0(p);
      }
#line 94
      return ((int )symbol);
    }
#line 96
    p->PrevSuccess = 0U;
#line 97
    i = (unsigned int )((int )(p->MinContext)->NumStats - 1);
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 100
      s ++;
#line 100
      hiCnt += (UInt32 )s->Freq;
#line 100
      if (hiCnt > count) {
        {
#line 103
        (*(rc->Decode))((void *)rc, hiCnt - (UInt32 )s->Freq, (UInt32 )s->Freq);
#line 104
        p->FoundState = s;
#line 105
        symbol___0 = s->Symbol;
#line 106
        Ppmd7_Update1(p);
        }
#line 107
        return ((int )symbol___0);
      }
#line 98
      i --;
#line 98
      if (! i) {
#line 98
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 111
    if (count >= (UInt32 )(p->MinContext)->SummFreq) {
#line 112
      return (-2);
    }
    {
#line 113
    p->HiBitsFlag = (unsigned int )p->HB2Flag[(p->FoundState)->Symbol];
#line 114
    (*(rc->Decode))((void *)rc, hiCnt, (UInt32 )(p->MinContext)->SummFreq - hiCnt);
#line 115
    i___0 = 0U;
    }
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! ((unsigned long )i___0 < 256UL / sizeof(charMask[0]))) {
#line 115
        goto while_break___0;
      }
#line 115
      tmp___5 = ~ ((size_t )0);
#line 115
      charMask[i___0] = tmp___5;
#line 115
      tmp___4 = tmp___5;
#line 115
      charMask[i___0 + 1U] = tmp___4;
#line 115
      tmp___3 = tmp___4;
#line 115
      charMask[i___0 + 2U] = tmp___3;
#line 115
      tmp___2 = tmp___3;
#line 115
      charMask[i___0 + 3U] = tmp___2;
#line 115
      tmp___1 = tmp___2;
#line 115
      charMask[i___0 + 4U] = tmp___1;
#line 115
      tmp___0 = tmp___1;
#line 115
      charMask[i___0 + 5U] = tmp___0;
#line 115
      tmp = tmp___0;
#line 115
      charMask[i___0 + 6U] = tmp;
#line 115
      charMask[i___0 + 7U] = tmp;
#line 115
      i___0 += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 117
    i = (unsigned int )((int )(p->MinContext)->NumStats - 1);
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      s --;
#line 118
      *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 118
      i --;
#line 118
      if (! i) {
#line 118
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 122
    tmp___6 = (unsigned int )p->HB2Flag[(p->FoundState)->Symbol];
#line 122
    p->HiBitsFlag = tmp___6;
#line 122
    prob = & p->BinSumm[(int )((CPpmd_State *)(& (p->MinContext)->SummFreq))->Freq - 1][(((p->PrevSuccess + (unsigned int )p->NS2BSIndx[(int )((CPpmd7_Context *)((void *)(p->Base + (p->MinContext)->Suffix)))->NumStats - 1]) + tmp___6) + (unsigned int )(2 * (int )p->HB2Flag[((CPpmd_State *)(& (p->MinContext)->SummFreq))->Symbol])) + (unsigned int )((p->RunLength >> 26) & 32)];
#line 123
    tmp___8 = (*(rc->DecodeBit))((void *)rc, (UInt32 )*prob);
    }
#line 123
    if (tmp___8 == 0U) {
      {
#line 126
      *prob = (UInt16 )(((int )*prob + (1 << 7)) - (((int )*prob + (1 << 5)) >> 7));
#line 127
      tmp___7 = (CPpmd_State *)(& (p->MinContext)->SummFreq);
#line 127
      p->FoundState = tmp___7;
#line 127
      symbol___1 = tmp___7->Symbol;
#line 128
      Ppmd7_UpdateBin(p);
      }
#line 129
      return ((int )symbol___1);
    }
#line 131
    *prob = (UInt16 )((int )*prob - (((int )*prob + (1 << 5)) >> 7));
#line 132
    p->InitEsc = (unsigned int )PPMD7_kExpEscape[(int )*prob >> 10];
#line 133
    i___1 = 0U;
    {
#line 133
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 133
      if (! ((unsigned long )i___1 < 256UL / sizeof(charMask[0]))) {
#line 133
        goto while_break___2;
      }
#line 133
      tmp___15 = ~ ((size_t )0);
#line 133
      charMask[i___1] = tmp___15;
#line 133
      tmp___14 = tmp___15;
#line 133
      charMask[i___1 + 1U] = tmp___14;
#line 133
      tmp___13 = tmp___14;
#line 133
      charMask[i___1 + 2U] = tmp___13;
#line 133
      tmp___12 = tmp___13;
#line 133
      charMask[i___1 + 3U] = tmp___12;
#line 133
      tmp___11 = tmp___12;
#line 133
      charMask[i___1 + 4U] = tmp___11;
#line 133
      tmp___10 = tmp___11;
#line 133
      charMask[i___1 + 5U] = tmp___10;
#line 133
      tmp___9 = tmp___10;
#line 133
      charMask[i___1 + 6U] = tmp___9;
#line 133
      charMask[i___1 + 7U] = tmp___9;
#line 133
      i___1 += 8U;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 134
    *((signed char *)(charMask) + ((CPpmd_State *)(& (p->MinContext)->SummFreq))->Symbol) = (signed char)0;
#line 135
    p->PrevSuccess = 0U;
  }
  {
#line 137
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 142
    numMasked = (unsigned int )(p->MinContext)->NumStats;
    {
#line 143
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 145
      (p->OrderFall) ++;
#line 146
      if (! (p->MinContext)->Suffix) {
#line 147
        return (-1);
      }
#line 148
      p->MinContext = (CPpmd7_Context *)((void *)(p->Base + (p->MinContext)->Suffix));
#line 143
      if (! ((unsigned int )(p->MinContext)->NumStats == numMasked)) {
#line 143
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 151
    hiCnt___0 = (UInt32 )0;
#line 152
    s___0 = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 153
    i___2 = 0U;
#line 154
    num = (unsigned int )(p->MinContext)->NumStats - numMasked;
    {
#line 155
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 157
      k = (int )*((signed char *)(charMask) + s___0->Symbol);
#line 158
      hiCnt___0 += (UInt32 )((int )s___0->Freq & k);
#line 159
      tmp___16 = s___0;
#line 159
      s___0 ++;
#line 159
      ps[i___2] = tmp___16;
#line 160
      i___2 -= (unsigned int )k;
#line 155
      if (! (i___2 != num)) {
#line 155
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 164
    see = Ppmd7_MakeEscFreq(p, numMasked, & freqSum);
#line 165
    freqSum += hiCnt___0;
#line 166
    count___0 = (*(rc->GetThreshold))((void *)rc, freqSum);
    }
#line 168
    if (count___0 < hiCnt___0) {
#line 171
      pps = ps;
#line 172
      hiCnt___0 = (UInt32 )0;
      {
#line 172
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 172
        hiCnt___0 += (UInt32 )(*pps)->Freq;
#line 172
        if (! (hiCnt___0 <= count___0)) {
#line 172
          goto while_break___6;
        }
#line 172
        pps ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 173
      s___0 = *pps;
#line 174
      (*(rc->Decode))((void *)rc, hiCnt___0 - (UInt32 )s___0->Freq, (UInt32 )s___0->Freq);
      }
#line 175
      if ((int )see->Shift < 7) {
#line 175
        see->Count = (Byte )((int )see->Count - 1);
#line 175
        if ((int )see->Count == 0) {
#line 175
          see->Summ = (UInt16 )((int )see->Summ << 1);
#line 175
          tmp___17 = see->Shift;
#line 175
          see->Shift = (Byte )((int )see->Shift + 1);
#line 175
          see->Count = (Byte )(3 << (int )tmp___17);
        }
      }
      {
#line 176
      p->FoundState = s___0;
#line 177
      symbol___2 = s___0->Symbol;
#line 178
      Ppmd7_Update2(p);
      }
#line 179
      return ((int )symbol___2);
    }
#line 181
    if (count___0 >= freqSum) {
#line 182
      return (-2);
    }
    {
#line 183
    (*(rc->Decode))((void *)rc, hiCnt___0, freqSum - hiCnt___0);
#line 184
    see->Summ = (UInt16 )((UInt32 )see->Summ + freqSum);
    }
    {
#line 185
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 185
      i___2 --;
#line 185
      *((signed char *)(charMask) + (ps[i___2])->Symbol) = (signed char)0;
#line 185
      if (! (i___2 != 0U)) {
#line 185
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 6 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra.c"
SizeT ARM_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) 
{ 
  SizeT i ;
  UInt32 dest ;
  UInt32 src ;

  {
#line 9
  if (size < 4UL) {
#line 10
    return ((SizeT )0);
  }
#line 11
  size -= 4UL;
#line 12
  ip += 8U;
#line 13
  i = (SizeT )0;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! (i <= size)) {
#line 13
      goto while_break;
    }
#line 15
    if ((int )*(data + (i + 3UL)) == 235) {
#line 18
      src = (((UInt32 )*(data + (i + 2UL)) << 16) | ((UInt32 )*(data + (i + 1UL)) << 8)) | (unsigned int )*(data + i);
#line 19
      src <<= 2;
#line 20
      if (encoding) {
#line 21
        dest = (ip + (UInt32 )i) + src;
      } else {
#line 23
        dest = src - (ip + (UInt32 )i);
      }
#line 24
      dest >>= 2;
#line 25
      *(data + (i + 2UL)) = (Byte )(dest >> 16);
#line 26
      *(data + (i + 1UL)) = (Byte )(dest >> 8);
#line 27
      *(data + i) = (Byte )dest;
    }
#line 13
    i += 4UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return (i);
}
}
#line 33 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra.c"
SizeT ARMT_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) 
{ 
  SizeT i ;
  UInt32 dest ;
  UInt32 src ;

  {
#line 36
  if (size < 4UL) {
#line 37
    return ((SizeT )0);
  }
#line 38
  size -= 4UL;
#line 39
  ip += 4U;
#line 40
  i = (SizeT )0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i <= size)) {
#line 40
      goto while_break;
    }
#line 42
    if (((int )*(data + (i + 1UL)) & 248) == 240) {
#line 42
      if (((int )*(data + (i + 3UL)) & 248) == 248) {
#line 46
        src = (((((UInt32 )*(data + (i + 1UL)) & 7U) << 19) | ((UInt32 )*(data + i) << 11)) | (((UInt32 )*(data + (i + 3UL)) & 7U) << 8)) | (unsigned int )*(data + (i + 2UL));
#line 52
        src <<= 1;
#line 53
        if (encoding) {
#line 54
          dest = (ip + (UInt32 )i) + src;
        } else {
#line 56
          dest = src - (ip + (UInt32 )i);
        }
#line 57
        dest >>= 1;
#line 59
        *(data + (i + 1UL)) = (Byte )(240U | ((dest >> 19) & 7U));
#line 60
        *(data + i) = (Byte )(dest >> 11);
#line 61
        *(data + (i + 3UL)) = (Byte )(248U | ((dest >> 8) & 7U));
#line 62
        *(data + (i + 2UL)) = (Byte )dest;
#line 63
        i += 2UL;
      }
    }
#line 40
    i += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (i);
}
}
#line 69 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra.c"
SizeT PPC_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) 
{ 
  SizeT i ;
  UInt32 src ;
  UInt32 dest ;

  {
#line 72
  if (size < 4UL) {
#line 73
    return ((SizeT )0);
  }
#line 74
  size -= 4UL;
#line 75
  i = (SizeT )0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i <= size)) {
#line 75
      goto while_break;
    }
#line 77
    if ((int )*(data + i) >> 2 == 18) {
#line 77
      if (((int )*(data + (i + 3UL)) & 3) == 1) {
#line 79
        src = ((((UInt32 )((int )*(data + i) & 3) << 24) | ((UInt32 )*(data + (i + 1UL)) << 16)) | ((UInt32 )*(data + (i + 2UL)) << 8)) | ((UInt32 )*(data + (i + 3UL)) & 4294967292U);
#line 85
        if (encoding) {
#line 86
          dest = (ip + (UInt32 )i) + src;
        } else {
#line 88
          dest = src - (ip + (UInt32 )i);
        }
#line 89
        *(data + i) = (Byte )(72U | ((dest >> 24) & 3U));
#line 90
        *(data + (i + 1UL)) = (Byte )(dest >> 16);
#line 91
        *(data + (i + 2UL)) = (Byte )(dest >> 8);
#line 92
        *(data + (i + 3UL)) = (Byte )((int )*(data + (i + 3UL)) & 3);
#line 93
        *(data + (i + 3UL)) = (Byte )((unsigned int )*(data + (i + 3UL)) | dest);
      }
    }
#line 75
    i += 4UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (i);
}
}
#line 99 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra.c"
SizeT SPARC_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) 
{ 
  UInt32 i ;
  UInt32 src ;
  UInt32 dest ;

  {
#line 102
  if (size < 4UL) {
#line 103
    return ((SizeT )0);
  }
#line 104
  size -= 4UL;
#line 105
  i = (UInt32 )0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! ((SizeT )i <= size)) {
#line 105
      goto while_break;
    }
#line 107
    if ((int )*(data + i) == 64) {
#line 107
      if (((int )*(data + (i + 1U)) & 192) == 0) {
#line 107
        goto _L;
      } else {
#line 107
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 107
    if ((int )*(data + i) == 127) {
#line 107
      if (((int )*(data + (i + 1U)) & 192) == 192) {
        _L: /* CIL Label */ 
#line 110
        src = ((((UInt32 )*(data + i) << 24) | ((UInt32 )*(data + (i + 1U)) << 16)) | ((UInt32 )*(data + (i + 2U)) << 8)) | (UInt32 )*(data + (i + 3U));
#line 117
        src <<= 2;
#line 118
        if (encoding) {
#line 119
          dest = (ip + i) + src;
        } else {
#line 121
          dest = src - (ip + i);
        }
#line 122
        dest >>= 2;
#line 124
        dest = ((((0U - ((dest >> 22) & 1U)) << 22) & 1073741823U) | (dest & 4194303U)) | 1073741824U;
#line 126
        *(data + i) = (Byte )(dest >> 24);
#line 127
        *(data + (i + 1U)) = (Byte )(dest >> 16);
#line 128
        *(data + (i + 2U)) = (Byte )(dest >> 8);
#line 129
        *(data + (i + 3U)) = (Byte )dest;
      }
    }
#line 105
    i += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return ((SizeT )i);
}
}
#line 58 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.h"
int MatchFinder_NeedMove(CMatchFinder *p ) ;
#line 59
Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p ) ;
#line 60
void MatchFinder_MoveBlock(CMatchFinder *p ) ;
#line 61
void MatchFinder_ReadIfRequired(CMatchFinder *p ) ;
#line 73
void MatchFinder_Normalize3(UInt32 subValue , CLzRef *items , UInt32 numItems ) ;
#line 74
void MatchFinder_ReduceOffsets(CMatchFinder *p , UInt32 subValue ) ;
#line 76
UInt32 *GetMatchesSpec1(UInt32 lenLimit , UInt32 curMatch , UInt32 pos , Byte const   *cur ,
                        CLzRef *son , UInt32 _cyclicBufferPos , UInt32 _cyclicBufferSize ,
                        UInt32 cutValue , UInt32 *distances , UInt32 maxLen ) ;
#line 105
void MatchFinder_Init(CMatchFinder *p ) ;
#line 106
UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) ;
#line 107
UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) ;
#line 108
void Bt3Zip_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) ;
#line 109
void Hc3Zip_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) ;
#line 17 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void LzInWindow_Free(CMatchFinder *p , ISzAlloc *alloc ) 
{ 


  {
#line 19
  if (! p->directInput) {
    {
#line 21
    (*(alloc->Free))((void *)alloc, (void *)p->bufferBase);
#line 22
    p->bufferBase = (Byte *)0;
    }
  }
#line 24
  return;
}
}
#line 28 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static int LzInWindow_Create(CMatchFinder *p , UInt32 keepSizeReserv , ISzAlloc *alloc ) 
{ 
  UInt32 blockSize ;
  void *tmp ;

  {
#line 30
  blockSize = (p->keepSizeBefore + p->keepSizeAfter) + keepSizeReserv;
#line 31
  if (p->directInput) {
#line 33
    p->blockSize = blockSize;
#line 34
    return (1);
  }
#line 36
  if ((unsigned long )p->bufferBase == (unsigned long )((Byte *)0)) {
    {
#line 38
    LzInWindow_Free(p, alloc);
#line 39
    p->blockSize = blockSize;
#line 40
    tmp = (*(alloc->Alloc))((void *)alloc, (size_t )blockSize);
#line 40
    p->bufferBase = (Byte *)tmp;
    }
  } else
#line 36
  if (p->blockSize != blockSize) {
    {
#line 38
    LzInWindow_Free(p, alloc);
#line 39
    p->blockSize = blockSize;
#line 40
    tmp = (*(alloc->Alloc))((void *)alloc, (size_t )blockSize);
#line 40
    p->bufferBase = (Byte *)tmp;
    }
  }
#line 42
  return ((unsigned long )p->bufferBase != (unsigned long )((Byte *)0));
}
}
#line 45 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p ) 
{ 


  {
#line 45
  return (p->buffer);
}
}
#line 46 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
Byte MatchFinder_GetIndexByte(CMatchFinder *p , Int32 index___0 ) 
{ 


  {
#line 46
  return (*(p->buffer + index___0));
}
}
#line 48 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p ) 
{ 


  {
#line 48
  return (p->streamPos - p->pos);
}
}
#line 50 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_ReduceOffsets(CMatchFinder *p , UInt32 subValue ) 
{ 


  {
#line 52
  p->posLimit -= subValue;
#line 53
  p->pos -= subValue;
#line 54
  p->streamPos -= subValue;
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_ReadBlock(CMatchFinder *p ) 
{ 
  UInt32 curSize ;
  Byte *dest ;
  size_t size ;

  {
#line 59
  if (p->streamEndWasReached) {
#line 60
    return;
  } else
#line 59
  if (p->result != 0) {
#line 60
    return;
  }
#line 61
  if (p->directInput) {
#line 63
    curSize = 4294967295U - p->streamPos;
#line 64
    if ((size_t )curSize > p->directInputRem) {
#line 65
      curSize = (UInt32 )p->directInputRem;
    }
#line 66
    p->directInputRem -= (size_t )curSize;
#line 67
    p->streamPos += curSize;
#line 68
    if (p->directInputRem == 0UL) {
#line 69
      p->streamEndWasReached = 1;
    }
#line 70
    return;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    dest = p->buffer + (p->streamPos - p->pos);
#line 75
    size = (size_t )((p->bufferBase + p->blockSize) - dest);
#line 76
    if (size == 0UL) {
#line 77
      return;
    }
    {
#line 78
    p->result = (*((p->stream)->Read))((void *)p->stream, (void *)dest, & size);
    }
#line 79
    if (p->result != 0) {
#line 80
      return;
    }
#line 81
    if (size == 0UL) {
#line 83
      p->streamEndWasReached = 1;
#line 84
      return;
    }
#line 86
    p->streamPos += (UInt32 )size;
#line 87
    if (p->streamPos - p->pos > p->keepSizeAfter) {
#line 88
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 92 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_MoveBlock(CMatchFinder *p ) 
{ 


  {
  {
#line 94
  memmove((void *)p->bufferBase, (void const   *)(p->buffer - p->keepSizeBefore),
          (size_t )((p->streamPos - p->pos) + p->keepSizeBefore));
#line 97
  p->buffer = p->bufferBase + p->keepSizeBefore;
  }
#line 98
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
int MatchFinder_NeedMove(CMatchFinder *p ) 
{ 


  {
#line 102
  if (p->directInput) {
#line 103
    return (0);
  }
#line 105
  return ((size_t )((p->bufferBase + p->blockSize) - p->buffer) <= (size_t )p->keepSizeAfter);
}
}
#line 108 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_ReadIfRequired(CMatchFinder *p ) 
{ 


  {
#line 110
  if (p->streamEndWasReached) {
#line 111
    return;
  }
#line 112
  if (p->keepSizeAfter >= p->streamPos - p->pos) {
    {
#line 113
    MatchFinder_ReadBlock(p);
    }
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p ) 
{ 
  int tmp ;

  {
  {
#line 118
  tmp = MatchFinder_NeedMove(p);
  }
#line 118
  if (tmp) {
    {
#line 119
    MatchFinder_MoveBlock(p);
    }
  }
  {
#line 120
  MatchFinder_ReadBlock(p);
  }
#line 121
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_SetDefaultSettings(CMatchFinder *p ) 
{ 


  {
#line 125
  p->cutValue = (UInt32 )32;
#line 126
  p->btMode = 1;
#line 127
  p->numHashBytes = (UInt32 )4;
#line 128
  p->bigHash = 0;
#line 129
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_Construct(CMatchFinder *p ) 
{ 
  UInt32 i ;
  UInt32 r ;
  int j ;

  {
  {
#line 136
  p->bufferBase = (Byte *)0;
#line 137
  p->directInput = 0;
#line 138
  p->hash = (CLzRef *)0;
#line 139
  MatchFinder_SetDefaultSettings(p);
#line 141
  i = (UInt32 )0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < 256U)) {
#line 141
      goto while_break;
    }
#line 143
    r = i;
#line 145
    j = 0;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 145
      if (! (j < 8)) {
#line 145
        goto while_break___0;
      }
#line 146
      r = (r >> 1) ^ (3988292384U & ~ ((r & 1U) - 1U));
#line 145
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    p->crc[i] = r;
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_FreeThisClassMemory(CMatchFinder *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 153
  (*(alloc->Free))((void *)alloc, (void *)p->hash);
#line 154
  p->hash = (CLzRef *)0;
  }
#line 155
  return;
}
}
#line 157 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_Free(CMatchFinder *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 159
  MatchFinder_FreeThisClassMemory(p, alloc);
#line 160
  LzInWindow_Free(p, alloc);
  }
#line 161
  return;
}
}
#line 163 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static CLzRef *AllocRefs(UInt32 num , ISzAlloc *alloc ) 
{ 
  size_t sizeInBytes ;
  void *tmp ;

  {
#line 165
  sizeInBytes = (size_t )num * sizeof(CLzRef );
#line 166
  if (sizeInBytes / sizeof(CLzRef ) != (size_t )num) {
#line 167
    return ((CLzRef *)0);
  }
  {
#line 168
  tmp = (*(alloc->Alloc))((void *)alloc, sizeInBytes);
  }
#line 168
  return ((CLzRef *)tmp);
}
}
#line 171 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
int MatchFinder_Create(CMatchFinder *p , UInt32 historySize , UInt32 keepAddBufferBefore ,
                       UInt32 matchMaxLen , UInt32 keepAddBufferAfter , ISzAlloc *alloc ) 
{ 
  UInt32 sizeReserv ;
  UInt32 newCyclicBufferSize ;
  UInt32 hs ;
  UInt32 prevSize ;
  UInt32 newSize ;
  int tmp ;

  {
#line 176
  if (historySize > 3U << 30) {
    {
#line 178
    MatchFinder_Free(p, alloc);
    }
#line 179
    return (0);
  }
#line 181
  sizeReserv = historySize >> 1;
#line 182
  if (historySize > 2U << 30) {
#line 183
    sizeReserv = historySize >> 2;
  }
  {
#line 184
  sizeReserv += ((keepAddBufferBefore + matchMaxLen) + keepAddBufferAfter) / 2U + (UInt32 )(1 << 19);
#line 186
  p->keepSizeBefore = (historySize + keepAddBufferBefore) + 1U;
#line 187
  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
#line 189
  tmp = LzInWindow_Create(p, sizeReserv, alloc);
  }
#line 189
  if (tmp) {
#line 191
    newCyclicBufferSize = historySize + 1U;
#line 193
    p->matchMaxLen = matchMaxLen;
#line 195
    p->fixedHashSize = (UInt32 )0;
#line 196
    if (p->numHashBytes == 2U) {
#line 197
      hs = (UInt32 )((1 << 16) - 1);
    } else {
#line 200
      hs = historySize - 1U;
#line 201
      hs |= hs >> 1;
#line 202
      hs |= hs >> 2;
#line 203
      hs |= hs >> 4;
#line 204
      hs |= hs >> 8;
#line 205
      hs >>= 1;
#line 206
      hs |= 65535U;
#line 207
      if (hs > (UInt32 )(1 << 24)) {
#line 209
        if (p->numHashBytes == 3U) {
#line 210
          hs = (UInt32 )((1 << 24) - 1);
        } else {
#line 212
          hs >>= 1;
        }
      }
    }
#line 215
    p->hashMask = hs;
#line 216
    hs ++;
#line 217
    if (p->numHashBytes > 2U) {
#line 217
      p->fixedHashSize += (UInt32 )(1 << 10);
    }
#line 218
    if (p->numHashBytes > 3U) {
#line 218
      p->fixedHashSize += (UInt32 )(1 << 16);
    }
#line 219
    if (p->numHashBytes > 4U) {
#line 219
      p->fixedHashSize += (UInt32 )(1 << 20);
    }
#line 220
    hs += p->fixedHashSize;
#line 224
    prevSize = p->hashSizeSum + p->numSons;
#line 226
    p->historySize = historySize;
#line 227
    p->hashSizeSum = hs;
#line 228
    p->cyclicBufferSize = newCyclicBufferSize;
#line 229
    if (p->btMode) {
#line 229
      p->numSons = newCyclicBufferSize * 2U;
    } else {
#line 229
      p->numSons = newCyclicBufferSize;
    }
#line 230
    newSize = p->hashSizeSum + p->numSons;
#line 231
    if ((unsigned long )p->hash != (unsigned long )((CLzRef *)0)) {
#line 231
      if (prevSize == newSize) {
#line 232
        return (1);
      }
    }
    {
#line 233
    MatchFinder_FreeThisClassMemory(p, alloc);
#line 234
    p->hash = AllocRefs(newSize, alloc);
    }
#line 235
    if ((unsigned long )p->hash != (unsigned long )((CLzRef *)0)) {
#line 237
      p->son = p->hash + p->hashSizeSum;
#line 238
      return (1);
    }
  }
  {
#line 242
  MatchFinder_Free(p, alloc);
  }
#line 243
  return (0);
}
}
#line 246 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_SetLimits(CMatchFinder *p ) 
{ 
  UInt32 limit ;
  UInt32 limit2 ;
  UInt32 lenLimit ;

  {
#line 248
  limit = 4294967295U - p->pos;
#line 249
  limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
#line 250
  if (limit2 < limit) {
#line 251
    limit = limit2;
  }
#line 252
  limit2 = p->streamPos - p->pos;
#line 253
  if (limit2 <= p->keepSizeAfter) {
#line 255
    if (limit2 > 0U) {
#line 256
      limit2 = (UInt32 )1;
    }
  } else {
#line 259
    limit2 -= p->keepSizeAfter;
  }
#line 260
  if (limit2 < limit) {
#line 261
    limit = limit2;
  }
#line 263
  lenLimit = p->streamPos - p->pos;
#line 264
  if (lenLimit > p->matchMaxLen) {
#line 265
    lenLimit = p->matchMaxLen;
  }
#line 266
  p->lenLimit = lenLimit;
#line 268
  p->posLimit = p->pos + limit;
#line 269
  return;
}
}
#line 271 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_Init(CMatchFinder *p ) 
{ 
  UInt32 i ;
  UInt32 tmp ;

  {
#line 274
  i = (UInt32 )0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < p->hashSizeSum)) {
#line 274
      goto while_break;
    }
#line 275
    *(p->hash + i) = (CLzRef )0;
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  p->cyclicBufferPos = (UInt32 )0;
#line 277
  p->buffer = p->bufferBase;
#line 278
  tmp = p->cyclicBufferSize;
#line 278
  p->streamPos = tmp;
#line 278
  p->pos = tmp;
#line 279
  p->result = 0;
#line 280
  p->streamEndWasReached = 0;
#line 281
  MatchFinder_ReadBlock(p);
#line 282
  MatchFinder_SetLimits(p);
  }
#line 283
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static UInt32 MatchFinder_GetSubValue(CMatchFinder *p ) 
{ 


  {
#line 287
  return (((p->pos - p->historySize) - 1U) & (unsigned int )(~ ((1 << 10) - 1)));
}
}
#line 290 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_Normalize3(UInt32 subValue , CLzRef *items , UInt32 numItems ) 
{ 
  UInt32 i ;
  UInt32 value ;

  {
#line 293
  i = (UInt32 )0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < numItems)) {
#line 293
      goto while_break;
    }
#line 295
    value = *(items + i);
#line 296
    if (value <= subValue) {
#line 297
      value = (UInt32 )0;
    } else {
#line 299
      value -= subValue;
    }
#line 300
    *(items + i) = value;
#line 293
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_Normalize(CMatchFinder *p ) 
{ 
  UInt32 subValue ;
  UInt32 tmp ;

  {
  {
#line 306
  tmp = MatchFinder_GetSubValue(p);
#line 306
  subValue = tmp;
#line 307
  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
#line 308
  MatchFinder_ReduceOffsets(p, subValue);
  }
#line 309
  return;
}
}
#line 311 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_CheckLimits(CMatchFinder *p ) 
{ 


  {
#line 313
  if (p->pos == 4294967295U) {
    {
#line 314
    MatchFinder_Normalize(p);
    }
  }
#line 315
  if (! p->streamEndWasReached) {
#line 315
    if (p->keepSizeAfter == p->streamPos - p->pos) {
      {
#line 316
      MatchFinder_CheckAndMoveAndRead(p);
      }
    }
  }
#line 317
  if (p->cyclicBufferPos == p->cyclicBufferSize) {
#line 318
    p->cyclicBufferPos = (UInt32 )0;
  }
  {
#line 319
  MatchFinder_SetLimits(p);
  }
#line 320
  return;
}
}
#line 322 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static UInt32 *Hc_GetMatchesSpec(UInt32 lenLimit , UInt32 curMatch , UInt32 pos ,
                                 Byte const   *cur , CLzRef *son , UInt32 _cyclicBufferPos ,
                                 UInt32 _cyclicBufferSize , UInt32 cutValue , UInt32 *distances ,
                                 UInt32 maxLen ) 
{ 
  UInt32 delta ;
  UInt32 tmp ;
  Byte const   *pb ;
  UInt32 tmp___0 ;
  UInt32 len ;
  UInt32 *tmp___1 ;
  UInt32 *tmp___2 ;

  {
#line 326
  *(son + _cyclicBufferPos) = curMatch;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    delta = pos - curMatch;
#line 330
    tmp = cutValue;
#line 330
    cutValue --;
#line 330
    if (tmp == 0U) {
#line 331
      return (distances);
    } else
#line 330
    if (delta >= _cyclicBufferSize) {
#line 331
      return (distances);
    }
#line 333
    pb = cur - delta;
#line 334
    if (delta > _cyclicBufferPos) {
#line 334
      tmp___0 = _cyclicBufferSize;
    } else {
#line 334
      tmp___0 = (UInt32 )0;
    }
#line 334
    curMatch = *(son + ((_cyclicBufferPos - delta) + tmp___0));
#line 335
    if ((int const   )*(pb + maxLen) == (int const   )*(cur + maxLen)) {
#line 335
      if ((int const   )*pb == (int const   )*cur) {
#line 337
        len = (UInt32 )0;
        {
#line 338
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 338
          len ++;
#line 338
          if (! (len != lenLimit)) {
#line 338
            goto while_break___0;
          }
#line 339
          if ((int const   )*(pb + len) != (int const   )*(cur + len)) {
#line 340
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 341
        if (maxLen < len) {
#line 343
          tmp___1 = distances;
#line 343
          distances ++;
#line 343
          maxLen = len;
#line 343
          *tmp___1 = maxLen;
#line 344
          tmp___2 = distances;
#line 344
          distances ++;
#line 344
          *tmp___2 = delta - 1U;
#line 345
          if (len == lenLimit) {
#line 346
            return (distances);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 353 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
UInt32 *GetMatchesSpec1(UInt32 lenLimit , UInt32 curMatch , UInt32 pos , Byte const   *cur ,
                        CLzRef *son , UInt32 _cyclicBufferPos , UInt32 _cyclicBufferSize ,
                        UInt32 cutValue , UInt32 *distances , UInt32 maxLen ) 
{ 
  CLzRef *ptr0 ;
  CLzRef *ptr1 ;
  UInt32 len0 ;
  UInt32 len1 ;
  UInt32 delta ;
  CLzRef tmp ;
  UInt32 tmp___0 ;
  CLzRef *pair ;
  UInt32 tmp___1 ;
  Byte const   *pb ;
  UInt32 len ;
  UInt32 tmp___2 ;
  UInt32 *tmp___3 ;
  UInt32 *tmp___4 ;

  {
#line 357
  ptr0 = (son + (_cyclicBufferPos << 1)) + 1;
#line 358
  ptr1 = son + (_cyclicBufferPos << 1);
#line 359
  len0 = (UInt32 )0;
#line 359
  len1 = (UInt32 )0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    delta = pos - curMatch;
#line 363
    tmp___0 = cutValue;
#line 363
    cutValue --;
#line 363
    if (tmp___0 == 0U) {
#line 365
      tmp = (CLzRef )0;
#line 365
      *ptr1 = tmp;
#line 365
      *ptr0 = tmp;
#line 366
      return (distances);
    } else
#line 363
    if (delta >= _cyclicBufferSize) {
#line 365
      tmp = (CLzRef )0;
#line 365
      *ptr1 = tmp;
#line 365
      *ptr0 = tmp;
#line 366
      return (distances);
    }
#line 369
    if (delta > _cyclicBufferPos) {
#line 369
      tmp___1 = _cyclicBufferSize;
    } else {
#line 369
      tmp___1 = (UInt32 )0;
    }
#line 369
    pair = son + (((_cyclicBufferPos - delta) + tmp___1) << 1);
#line 370
    pb = cur - delta;
#line 371
    if (len0 < len1) {
#line 371
      tmp___2 = len0;
    } else {
#line 371
      tmp___2 = len1;
    }
#line 371
    len = tmp___2;
#line 372
    if ((int const   )*(pb + len) == (int const   )*(cur + len)) {
#line 374
      len ++;
#line 374
      if (len != lenLimit) {
#line 374
        if ((int const   )*(pb + len) == (int const   )*(cur + len)) {
          {
#line 375
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 375
            len ++;
#line 375
            if (! (len != lenLimit)) {
#line 375
              goto while_break___0;
            }
#line 376
            if ((int const   )*(pb + len) != (int const   )*(cur + len)) {
#line 377
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 378
      if (maxLen < len) {
#line 380
        tmp___3 = distances;
#line 380
        distances ++;
#line 380
        maxLen = len;
#line 380
        *tmp___3 = maxLen;
#line 381
        tmp___4 = distances;
#line 381
        distances ++;
#line 381
        *tmp___4 = delta - 1U;
#line 382
        if (len == lenLimit) {
#line 384
          *ptr1 = *(pair + 0);
#line 385
          *ptr0 = *(pair + 1);
#line 386
          return (distances);
        }
      }
    }
#line 390
    if ((int const   )*(pb + len) < (int const   )*(cur + len)) {
#line 392
      *ptr1 = curMatch;
#line 393
      ptr1 = pair + 1;
#line 394
      curMatch = *ptr1;
#line 395
      len1 = len;
    } else {
#line 399
      *ptr0 = curMatch;
#line 400
      ptr0 = pair;
#line 401
      curMatch = *ptr0;
#line 402
      len0 = len;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 408 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void SkipMatchesSpec(UInt32 lenLimit , UInt32 curMatch , UInt32 pos , Byte const   *cur ,
                            CLzRef *son , UInt32 _cyclicBufferPos , UInt32 _cyclicBufferSize ,
                            UInt32 cutValue ) 
{ 
  CLzRef *ptr0 ;
  CLzRef *ptr1 ;
  UInt32 len0 ;
  UInt32 len1 ;
  UInt32 delta ;
  CLzRef tmp ;
  UInt32 tmp___0 ;
  CLzRef *pair ;
  UInt32 tmp___1 ;
  Byte const   *pb ;
  UInt32 len ;
  UInt32 tmp___2 ;

  {
#line 411
  ptr0 = (son + (_cyclicBufferPos << 1)) + 1;
#line 412
  ptr1 = son + (_cyclicBufferPos << 1);
#line 413
  len0 = (UInt32 )0;
#line 413
  len1 = (UInt32 )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    delta = pos - curMatch;
#line 417
    tmp___0 = cutValue;
#line 417
    cutValue --;
#line 417
    if (tmp___0 == 0U) {
#line 419
      tmp = (CLzRef )0;
#line 419
      *ptr1 = tmp;
#line 419
      *ptr0 = tmp;
#line 420
      return;
    } else
#line 417
    if (delta >= _cyclicBufferSize) {
#line 419
      tmp = (CLzRef )0;
#line 419
      *ptr1 = tmp;
#line 419
      *ptr0 = tmp;
#line 420
      return;
    }
#line 423
    if (delta > _cyclicBufferPos) {
#line 423
      tmp___1 = _cyclicBufferSize;
    } else {
#line 423
      tmp___1 = (UInt32 )0;
    }
#line 423
    pair = son + (((_cyclicBufferPos - delta) + tmp___1) << 1);
#line 424
    pb = cur - delta;
#line 425
    if (len0 < len1) {
#line 425
      tmp___2 = len0;
    } else {
#line 425
      tmp___2 = len1;
    }
#line 425
    len = tmp___2;
#line 426
    if ((int const   )*(pb + len) == (int const   )*(cur + len)) {
      {
#line 428
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 428
        len ++;
#line 428
        if (! (len != lenLimit)) {
#line 428
          goto while_break___0;
        }
#line 429
        if ((int const   )*(pb + len) != (int const   )*(cur + len)) {
#line 430
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 432
      if (len == lenLimit) {
#line 434
        *ptr1 = *(pair + 0);
#line 435
        *ptr0 = *(pair + 1);
#line 436
        return;
      }
    }
#line 440
    if ((int const   )*(pb + len) < (int const   )*(cur + len)) {
#line 442
      *ptr1 = curMatch;
#line 443
      ptr1 = pair + 1;
#line 444
      curMatch = *ptr1;
#line 445
      len1 = len;
    } else {
#line 449
      *ptr0 = curMatch;
#line 450
      ptr0 = pair;
#line 451
      curMatch = *ptr0;
#line 452
      len0 = len;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 465 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void MatchFinder_MovePos(CMatchFinder *p ) 
{ 


  {
#line 465
  (p->cyclicBufferPos) ++;
#line 465
  (p->buffer) ++;
#line 465
  (p->pos) ++;
#line 465
  if (p->pos == p->posLimit) {
    {
#line 465
    MatchFinder_CheckLimits(p);
    }
  }
#line 465
  return;
}
}
#line 484 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) 
{ 
  UInt32 offset ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 *tmp ;

  {
#line 487
  lenLimit = p->lenLimit;
#line 487
  if (lenLimit < 2U) {
    {
#line 487
    MatchFinder_MovePos(p);
    }
#line 487
    return ((UInt32 )0);
  }
  {
#line 487
  cur = (Byte const   *)p->buffer;
#line 488
  hashValue = (unsigned int )*(cur + 0) | ((UInt32 )*(cur + 1) << 8);
#line 489
  curMatch = *(p->hash + hashValue);
#line 490
  *(p->hash + hashValue) = p->pos;
#line 491
  offset = (UInt32 )0;
#line 492
  tmp = GetMatchesSpec1(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                        p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue, distances + offset,
                        (UInt32 )1);
#line 492
  offset = (UInt32 )(tmp - distances);
#line 492
  (p->cyclicBufferPos) ++;
#line 492
  (p->buffer) ++;
#line 492
  (p->pos) ++;
  }
#line 492
  if (p->pos == p->posLimit) {
    {
#line 492
    MatchFinder_CheckLimits(p);
    }
  }
#line 492
  return (offset);
}
}
#line 495 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) 
{ 
  UInt32 offset ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 *tmp ;

  {
#line 498
  lenLimit = p->lenLimit;
#line 498
  if (lenLimit < 3U) {
    {
#line 498
    MatchFinder_MovePos(p);
    }
#line 498
    return ((UInt32 )0);
  }
  {
#line 498
  cur = (Byte const   *)p->buffer;
#line 499
  hashValue = (((unsigned int )*(cur + 2) | ((UInt32 )*(cur + 0) << 8)) ^ p->crc[*(cur + 1)]) & 65535U;
#line 500
  curMatch = *(p->hash + hashValue);
#line 501
  *(p->hash + hashValue) = p->pos;
#line 502
  offset = (UInt32 )0;
#line 503
  tmp = GetMatchesSpec1(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                        p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue, distances + offset,
                        (UInt32 )2);
#line 503
  offset = (UInt32 )(tmp - distances);
#line 503
  (p->cyclicBufferPos) ++;
#line 503
  (p->buffer) ++;
#line 503
  (p->pos) ++;
  }
#line 503
  if (p->pos == p->posLimit) {
    {
#line 503
    MatchFinder_CheckLimits(p);
    }
  }
#line 503
  return (offset);
}
}
#line 506 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) 
{ 
  UInt32 hash2Value ;
  UInt32 delta2 ;
  UInt32 maxLen ;
  UInt32 offset ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 temp ;
  CLzRef tmp ;
  UInt32 *tmp___0 ;

  {
#line 509
  lenLimit = p->lenLimit;
#line 509
  if (lenLimit < 3U) {
    {
#line 509
    MatchFinder_MovePos(p);
    }
#line 509
    return ((UInt32 )0);
  }
#line 509
  cur = (Byte const   *)p->buffer;
#line 511
  temp = p->crc[*(cur + 0)] ^ (unsigned int )*(cur + 1);
#line 511
  hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 511
  hashValue = (temp ^ ((UInt32 )*(cur + 2) << 8)) & p->hashMask;
#line 513
  delta2 = p->pos - *(p->hash + hash2Value);
#line 514
  curMatch = *(p->hash + ((UInt32 )(1 << 10) + hashValue));
#line 516
  tmp = p->pos;
#line 516
  *(p->hash + ((UInt32 )(1 << 10) + hashValue)) = tmp;
#line 516
  *(p->hash + hash2Value) = tmp;
#line 520
  maxLen = (UInt32 )2;
#line 521
  offset = (UInt32 )0;
#line 522
  if (delta2 < p->cyclicBufferSize) {
#line 522
    if ((int const   )*(cur - delta2) == (int const   )*cur) {
      {
#line 524
      while (1) {
        while_continue: /* CIL Label */ ;
#line 524
        if (! (maxLen != lenLimit)) {
#line 524
          goto while_break;
        }
#line 525
        if ((int const   )*(cur + ((ptrdiff_t )maxLen - (ptrdiff_t )delta2)) != (int const   )*(cur + maxLen)) {
#line 526
          goto while_break;
        }
#line 524
        maxLen ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 527
      *(distances + 0) = maxLen;
#line 528
      *(distances + 1) = delta2 - 1U;
#line 529
      offset = (UInt32 )2;
#line 530
      if (maxLen == lenLimit) {
        {
#line 532
        SkipMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                        p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue);
#line 533
        (p->cyclicBufferPos) ++;
#line 533
        (p->buffer) ++;
#line 533
        (p->pos) ++;
        }
#line 533
        if (p->pos == p->posLimit) {
          {
#line 533
          MatchFinder_CheckLimits(p);
          }
        }
#line 533
        return (offset);
      }
    }
  }
  {
#line 536
  tmp___0 = GetMatchesSpec1(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer,
                            p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
                            distances + offset, maxLen);
#line 536
  offset = (UInt32 )(tmp___0 - distances);
#line 536
  (p->cyclicBufferPos) ++;
#line 536
  (p->buffer) ++;
#line 536
  (p->pos) ++;
  }
#line 536
  if (p->pos == p->posLimit) {
    {
#line 536
    MatchFinder_CheckLimits(p);
    }
  }
#line 536
  return (offset);
}
}
#line 539 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) 
{ 
  UInt32 hash2Value ;
  UInt32 hash3Value ;
  UInt32 delta2 ;
  UInt32 delta3 ;
  UInt32 maxLen ;
  UInt32 offset ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 temp ;
  CLzRef tmp ;
  CLzRef tmp___0 ;
  UInt32 *tmp___1 ;

  {
#line 542
  lenLimit = p->lenLimit;
#line 542
  if (lenLimit < 4U) {
    {
#line 542
    MatchFinder_MovePos(p);
    }
#line 542
    return ((UInt32 )0);
  }
#line 542
  cur = (Byte const   *)p->buffer;
#line 544
  temp = p->crc[*(cur + 0)] ^ (unsigned int )*(cur + 1);
#line 544
  hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 544
  hash3Value = (temp ^ ((UInt32 )*(cur + 2) << 8)) & (unsigned int )((1 << 16) - 1);
#line 544
  hashValue = ((temp ^ ((UInt32 )*(cur + 2) << 8)) ^ (p->crc[*(cur + 3)] << 5)) & p->hashMask;
#line 546
  delta2 = p->pos - *(p->hash + hash2Value);
#line 547
  delta3 = p->pos - *(p->hash + ((UInt32 )(1 << 10) + hash3Value));
#line 548
  curMatch = *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue));
#line 550
  tmp___0 = p->pos;
#line 550
  *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue)) = tmp___0;
#line 550
  tmp = tmp___0;
#line 550
  *(p->hash + ((UInt32 )(1 << 10) + hash3Value)) = tmp;
#line 550
  *(p->hash + hash2Value) = tmp;
#line 554
  maxLen = (UInt32 )1;
#line 555
  offset = (UInt32 )0;
#line 556
  if (delta2 < p->cyclicBufferSize) {
#line 556
    if ((int const   )*(cur - delta2) == (int const   )*cur) {
#line 558
      maxLen = (UInt32 )2;
#line 558
      *(distances + 0) = maxLen;
#line 559
      *(distances + 1) = delta2 - 1U;
#line 560
      offset = (UInt32 )2;
    }
  }
#line 562
  if (delta2 != delta3) {
#line 562
    if (delta3 < p->cyclicBufferSize) {
#line 562
      if ((int const   )*(cur - delta3) == (int const   )*cur) {
#line 564
        maxLen = (UInt32 )3;
#line 565
        *(distances + (offset + 1U)) = delta3 - 1U;
#line 566
        offset += 2U;
#line 567
        delta2 = delta3;
      }
    }
  }
#line 569
  if (offset != 0U) {
    {
#line 571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 571
      if (! (maxLen != lenLimit)) {
#line 571
        goto while_break;
      }
#line 572
      if ((int const   )*(cur + ((ptrdiff_t )maxLen - (ptrdiff_t )delta2)) != (int const   )*(cur + maxLen)) {
#line 573
        goto while_break;
      }
#line 571
      maxLen ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 574
    *(distances + (offset - 2U)) = maxLen;
#line 575
    if (maxLen == lenLimit) {
      {
#line 577
      SkipMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                      p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue);
#line 578
      (p->cyclicBufferPos) ++;
#line 578
      (p->buffer) ++;
#line 578
      (p->pos) ++;
      }
#line 578
      if (p->pos == p->posLimit) {
        {
#line 578
        MatchFinder_CheckLimits(p);
        }
      }
#line 578
      return (offset);
    }
  }
#line 581
  if (maxLen < 3U) {
#line 582
    maxLen = (UInt32 )3;
  }
  {
#line 583
  tmp___1 = GetMatchesSpec1(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer,
                            p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
                            distances + offset, maxLen);
#line 583
  offset = (UInt32 )(tmp___1 - distances);
#line 583
  (p->cyclicBufferPos) ++;
#line 583
  (p->buffer) ++;
#line 583
  (p->pos) ++;
  }
#line 583
  if (p->pos == p->posLimit) {
    {
#line 583
    MatchFinder_CheckLimits(p);
    }
  }
#line 583
  return (offset);
}
}
#line 586 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) 
{ 
  UInt32 hash2Value ;
  UInt32 hash3Value ;
  UInt32 delta2 ;
  UInt32 delta3 ;
  UInt32 maxLen ;
  UInt32 offset ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 temp ;
  CLzRef tmp ;
  CLzRef tmp___0 ;
  UInt32 *tmp___1 ;

  {
#line 589
  lenLimit = p->lenLimit;
#line 589
  if (lenLimit < 4U) {
    {
#line 589
    MatchFinder_MovePos(p);
    }
#line 589
    return ((UInt32 )0);
  }
#line 589
  cur = (Byte const   *)p->buffer;
#line 591
  temp = p->crc[*(cur + 0)] ^ (unsigned int )*(cur + 1);
#line 591
  hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 591
  hash3Value = (temp ^ ((UInt32 )*(cur + 2) << 8)) & (unsigned int )((1 << 16) - 1);
#line 591
  hashValue = ((temp ^ ((UInt32 )*(cur + 2) << 8)) ^ (p->crc[*(cur + 3)] << 5)) & p->hashMask;
#line 593
  delta2 = p->pos - *(p->hash + hash2Value);
#line 594
  delta3 = p->pos - *(p->hash + ((UInt32 )(1 << 10) + hash3Value));
#line 595
  curMatch = *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue));
#line 597
  tmp___0 = p->pos;
#line 597
  *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue)) = tmp___0;
#line 597
  tmp = tmp___0;
#line 597
  *(p->hash + ((UInt32 )(1 << 10) + hash3Value)) = tmp;
#line 597
  *(p->hash + hash2Value) = tmp;
#line 601
  maxLen = (UInt32 )1;
#line 602
  offset = (UInt32 )0;
#line 603
  if (delta2 < p->cyclicBufferSize) {
#line 603
    if ((int const   )*(cur - delta2) == (int const   )*cur) {
#line 605
      maxLen = (UInt32 )2;
#line 605
      *(distances + 0) = maxLen;
#line 606
      *(distances + 1) = delta2 - 1U;
#line 607
      offset = (UInt32 )2;
    }
  }
#line 609
  if (delta2 != delta3) {
#line 609
    if (delta3 < p->cyclicBufferSize) {
#line 609
      if ((int const   )*(cur - delta3) == (int const   )*cur) {
#line 611
        maxLen = (UInt32 )3;
#line 612
        *(distances + (offset + 1U)) = delta3 - 1U;
#line 613
        offset += 2U;
#line 614
        delta2 = delta3;
      }
    }
  }
#line 616
  if (offset != 0U) {
    {
#line 618
    while (1) {
      while_continue: /* CIL Label */ ;
#line 618
      if (! (maxLen != lenLimit)) {
#line 618
        goto while_break;
      }
#line 619
      if ((int const   )*(cur + ((ptrdiff_t )maxLen - (ptrdiff_t )delta2)) != (int const   )*(cur + maxLen)) {
#line 620
        goto while_break;
      }
#line 618
      maxLen ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 621
    *(distances + (offset - 2U)) = maxLen;
#line 622
    if (maxLen == lenLimit) {
#line 624
      *(p->son + p->cyclicBufferPos) = curMatch;
#line 625
      (p->cyclicBufferPos) ++;
#line 625
      (p->buffer) ++;
#line 625
      (p->pos) ++;
#line 625
      if (p->pos == p->posLimit) {
        {
#line 625
        MatchFinder_CheckLimits(p);
        }
      }
#line 625
      return (offset);
    }
  }
#line 628
  if (maxLen < 3U) {
#line 629
    maxLen = (UInt32 )3;
  }
  {
#line 630
  tmp___1 = Hc_GetMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer,
                              p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
                              distances + offset, maxLen);
#line 630
  offset = (UInt32 )(tmp___1 - distances);
#line 632
  (p->cyclicBufferPos) ++;
#line 632
  (p->buffer) ++;
#line 632
  (p->pos) ++;
  }
#line 632
  if (p->pos == p->posLimit) {
    {
#line 632
    MatchFinder_CheckLimits(p);
    }
  }
#line 632
  return (offset);
}
}
#line 635 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p , UInt32 *distances ) 
{ 
  UInt32 offset ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 *tmp ;

  {
#line 638
  lenLimit = p->lenLimit;
#line 638
  if (lenLimit < 3U) {
    {
#line 638
    MatchFinder_MovePos(p);
    }
#line 638
    return ((UInt32 )0);
  }
  {
#line 638
  cur = (Byte const   *)p->buffer;
#line 639
  hashValue = (((unsigned int )*(cur + 2) | ((UInt32 )*(cur + 0) << 8)) ^ p->crc[*(cur + 1)]) & 65535U;
#line 640
  curMatch = *(p->hash + hashValue);
#line 641
  *(p->hash + hashValue) = p->pos;
#line 642
  tmp = Hc_GetMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                          p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue, distances,
                          (UInt32 )2);
#line 642
  offset = (UInt32 )(tmp - distances);
#line 644
  (p->cyclicBufferPos) ++;
#line 644
  (p->buffer) ++;
#line 644
  (p->pos) ++;
  }
#line 644
  if (p->pos == p->posLimit) {
    {
#line 644
    MatchFinder_CheckLimits(p);
    }
  }
#line 644
  return (offset);
}
}
#line 647 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void Bt2_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) 
{ 
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;

  {
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    lenLimit = p->lenLimit;
#line 651
    if (lenLimit < 2U) {
      {
#line 651
      MatchFinder_MovePos(p);
      }
#line 651
      goto __Cont;
    }
    {
#line 651
    cur = (Byte const   *)p->buffer;
#line 652
    hashValue = (unsigned int )*(cur + 0) | ((UInt32 )*(cur + 1) << 8);
#line 653
    curMatch = *(p->hash + hashValue);
#line 654
    *(p->hash + hashValue) = p->pos;
#line 655
    SkipMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                    p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue);
#line 655
    (p->cyclicBufferPos) ++;
#line 655
    (p->buffer) ++;
#line 655
    (p->pos) ++;
    }
#line 655
    if (p->pos == p->posLimit) {
      {
#line 655
      MatchFinder_CheckLimits(p);
      }
    }
    __Cont: /* CIL Label */ 
#line 649
    num --;
#line 649
    if (! (num != 0U)) {
#line 649
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 658
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void Bt3Zip_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) 
{ 
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;

  {
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    lenLimit = p->lenLimit;
#line 664
    if (lenLimit < 3U) {
      {
#line 664
      MatchFinder_MovePos(p);
      }
#line 664
      goto __Cont;
    }
    {
#line 664
    cur = (Byte const   *)p->buffer;
#line 665
    hashValue = (((unsigned int )*(cur + 2) | ((UInt32 )*(cur + 0) << 8)) ^ p->crc[*(cur + 1)]) & 65535U;
#line 666
    curMatch = *(p->hash + hashValue);
#line 667
    *(p->hash + hashValue) = p->pos;
#line 668
    SkipMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                    p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue);
#line 668
    (p->cyclicBufferPos) ++;
#line 668
    (p->buffer) ++;
#line 668
    (p->pos) ++;
    }
#line 668
    if (p->pos == p->posLimit) {
      {
#line 668
      MatchFinder_CheckLimits(p);
      }
    }
    __Cont: /* CIL Label */ 
#line 662
    num --;
#line 662
    if (! (num != 0U)) {
#line 662
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  return;
}
}
#line 673 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void Bt3_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) 
{ 
  UInt32 hash2Value ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 temp ;
  CLzRef tmp ;

  {
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 678
    lenLimit = p->lenLimit;
#line 678
    if (lenLimit < 3U) {
      {
#line 678
      MatchFinder_MovePos(p);
      }
#line 678
      goto __Cont;
    }
    {
#line 678
    cur = (Byte const   *)p->buffer;
#line 679
    temp = p->crc[*(cur + 0)] ^ (unsigned int )*(cur + 1);
#line 679
    hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 679
    hashValue = (temp ^ ((UInt32 )*(cur + 2) << 8)) & p->hashMask;
#line 680
    curMatch = *(p->hash + ((UInt32 )(1 << 10) + hashValue));
#line 681
    tmp = p->pos;
#line 681
    *(p->hash + ((UInt32 )(1 << 10) + hashValue)) = tmp;
#line 681
    *(p->hash + hash2Value) = tmp;
#line 683
    SkipMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                    p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue);
#line 683
    (p->cyclicBufferPos) ++;
#line 683
    (p->buffer) ++;
#line 683
    (p->pos) ++;
    }
#line 683
    if (p->pos == p->posLimit) {
      {
#line 683
      MatchFinder_CheckLimits(p);
      }
    }
    __Cont: /* CIL Label */ 
#line 675
    num --;
#line 675
    if (! (num != 0U)) {
#line 675
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  return;
}
}
#line 688 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void Bt4_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) 
{ 
  UInt32 hash2Value ;
  UInt32 hash3Value ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 temp ;
  CLzRef tmp ;

  {
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    lenLimit = p->lenLimit;
#line 693
    if (lenLimit < 4U) {
      {
#line 693
      MatchFinder_MovePos(p);
      }
#line 693
      goto __Cont;
    }
    {
#line 693
    cur = (Byte const   *)p->buffer;
#line 694
    temp = p->crc[*(cur + 0)] ^ (unsigned int )*(cur + 1);
#line 694
    hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 694
    hash3Value = (temp ^ ((UInt32 )*(cur + 2) << 8)) & (unsigned int )((1 << 16) - 1);
#line 694
    hashValue = ((temp ^ ((UInt32 )*(cur + 2) << 8)) ^ (p->crc[*(cur + 3)] << 5)) & p->hashMask;
#line 695
    curMatch = *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue));
#line 696
    tmp = p->pos;
#line 696
    *(p->hash + ((UInt32 )(1 << 10) + hash3Value)) = tmp;
#line 696
    *(p->hash + hash2Value) = tmp;
#line 698
    *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue)) = p->pos;
#line 699
    SkipMatchesSpec(lenLimit, curMatch, p->pos, (Byte const   *)p->buffer, p->son,
                    p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue);
#line 699
    (p->cyclicBufferPos) ++;
#line 699
    (p->buffer) ++;
#line 699
    (p->pos) ++;
    }
#line 699
    if (p->pos == p->posLimit) {
      {
#line 699
      MatchFinder_CheckLimits(p);
      }
    }
    __Cont: /* CIL Label */ 
#line 690
    num --;
#line 690
    if (! (num != 0U)) {
#line 690
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  return;
}
}
#line 704 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
static void Hc4_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) 
{ 
  UInt32 hash2Value ;
  UInt32 hash3Value ;
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;
  UInt32 temp ;
  CLzRef tmp ;
  CLzRef tmp___0 ;

  {
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    lenLimit = p->lenLimit;
#line 709
    if (lenLimit < 4U) {
      {
#line 709
      MatchFinder_MovePos(p);
      }
#line 709
      goto __Cont;
    }
#line 709
    cur = (Byte const   *)p->buffer;
#line 710
    temp = p->crc[*(cur + 0)] ^ (unsigned int )*(cur + 1);
#line 710
    hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 710
    hash3Value = (temp ^ ((UInt32 )*(cur + 2) << 8)) & (unsigned int )((1 << 16) - 1);
#line 710
    hashValue = ((temp ^ ((UInt32 )*(cur + 2) << 8)) ^ (p->crc[*(cur + 3)] << 5)) & p->hashMask;
#line 711
    curMatch = *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue));
#line 712
    tmp___0 = p->pos;
#line 712
    *(p->hash + ((UInt32 )((1 << 10) + (1 << 16)) + hashValue)) = tmp___0;
#line 712
    tmp = tmp___0;
#line 712
    *(p->hash + ((UInt32 )(1 << 10) + hash3Value)) = tmp;
#line 712
    *(p->hash + hash2Value) = tmp;
#line 715
    *(p->son + p->cyclicBufferPos) = curMatch;
#line 716
    (p->cyclicBufferPos) ++;
#line 716
    (p->buffer) ++;
#line 716
    (p->pos) ++;
#line 716
    if (p->pos == p->posLimit) {
      {
#line 716
      MatchFinder_CheckLimits(p);
      }
    }
    __Cont: /* CIL Label */ 
#line 706
    num --;
#line 706
    if (! (num != 0U)) {
#line 706
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  return;
}
}
#line 721 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void Hc3Zip_MatchFinder_Skip(CMatchFinder *p , UInt32 num ) 
{ 
  UInt32 lenLimit ;
  UInt32 hashValue ;
  Byte const   *cur ;
  UInt32 curMatch ;

  {
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    lenLimit = p->lenLimit;
#line 725
    if (lenLimit < 3U) {
      {
#line 725
      MatchFinder_MovePos(p);
      }
#line 725
      goto __Cont;
    }
#line 725
    cur = (Byte const   *)p->buffer;
#line 726
    hashValue = (((unsigned int )*(cur + 2) | ((UInt32 )*(cur + 0) << 8)) ^ p->crc[*(cur + 1)]) & 65535U;
#line 727
    curMatch = *(p->hash + hashValue);
#line 728
    *(p->hash + hashValue) = p->pos;
#line 729
    *(p->son + p->cyclicBufferPos) = curMatch;
#line 730
    (p->cyclicBufferPos) ++;
#line 730
    (p->buffer) ++;
#line 730
    (p->pos) ++;
#line 730
    if (p->pos == p->posLimit) {
      {
#line 730
      MatchFinder_CheckLimits(p);
      }
    }
    __Cont: /* CIL Label */ 
#line 723
    num --;
#line 723
    if (! (num != 0U)) {
#line 723
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 733
  return;
}
}
#line 735 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFind.c"
void MatchFinder_CreateVTable(CMatchFinder *p , IMatchFinder *vTable ) 
{ 


  {
#line 737
  vTable->Init = (void (*)(void *object ))(& MatchFinder_Init);
#line 738
  vTable->GetIndexByte = (Byte (*)(void *object , Int32 index ))(& MatchFinder_GetIndexByte);
#line 739
  vTable->GetNumAvailableBytes = (UInt32 (*)(void *object ))(& MatchFinder_GetNumAvailableBytes);
#line 740
  vTable->GetPointerToCurrentPos = (Byte const   *(*)(void *object ))(& MatchFinder_GetPointerToCurrentPos);
#line 741
  if (! p->btMode) {
#line 743
    vTable->GetMatches = (UInt32 (*)(void *object , UInt32 *distances ))(& Hc4_MatchFinder_GetMatches);
#line 744
    vTable->Skip = (void (*)(void *object , UInt32  ))(& Hc4_MatchFinder_Skip);
  } else
#line 746
  if (p->numHashBytes == 2U) {
#line 748
    vTable->GetMatches = (UInt32 (*)(void *object , UInt32 *distances ))(& Bt2_MatchFinder_GetMatches);
#line 749
    vTable->Skip = (void (*)(void *object , UInt32  ))(& Bt2_MatchFinder_Skip);
  } else
#line 751
  if (p->numHashBytes == 3U) {
#line 753
    vTable->GetMatches = (UInt32 (*)(void *object , UInt32 *distances ))(& Bt3_MatchFinder_GetMatches);
#line 754
    vTable->Skip = (void (*)(void *object , UInt32  ))(& Bt3_MatchFinder_Skip);
  } else {
#line 758
    vTable->GetMatches = (UInt32 (*)(void *object , UInt32 *distances ))(& Bt4_MatchFinder_GetMatches);
#line 759
    vTable->Skip = (void (*)(void *object , UInt32  ))(& Bt4_MatchFinder_Skip);
  }
#line 761
  return;
}
}
#line 23 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.h"
void LoopThread_Construct(CLoopThread *p ) ;
#line 24
void LoopThread_Close(CLoopThread *p ) ;
#line 25
WRes LoopThread_Create(CLoopThread *p ) ;
#line 26
WRes LoopThread_StopAndWait(CLoopThread *p ) ;
#line 27
WRes LoopThread_StartSubThread(CLoopThread *p ) ;
#line 28
WRes LoopThread_WaitSubThread(CLoopThread *p ) ;
#line 8 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
void LoopThread_Construct(CLoopThread *p ) 
{ 


  {
#line 10
  p->thread._created = 0;
#line 11
  p->startEvent._created = 0;
#line 12
  p->finishedEvent._created = 0;
#line 13
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
void LoopThread_Close(CLoopThread *p ) 
{ 


  {
  {
#line 17
  Thread_Close(& p->thread);
#line 18
  Event_Close(& p->startEvent);
#line 19
  Event_Close(& p->finishedEvent);
  }
#line 20
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static THREAD_FUNC_RET_TYPE LoopThreadFunc(void *pp ) 
{ 
  CLoopThread *p ;
  WRes tmp ;
  WRes tmp___0 ;

  {
#line 24
  p = (CLoopThread *)pp;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 27
    tmp = Event_Wait(& p->startEvent);
    }
#line 27
    if (tmp != 0) {
#line 28
      return ((THREAD_FUNC_RET_TYPE )12);
    }
#line 29
    if (p->stop) {
#line 30
      return ((THREAD_FUNC_RET_TYPE )0);
    }
    {
#line 31
    p->res = (*(p->func))(p->param);
#line 32
    tmp___0 = Event_Set(& p->finishedEvent);
    }
#line 32
    if (tmp___0 != 0) {
#line 33
      return ((THREAD_FUNC_RET_TYPE )12);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 37 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
WRes LoopThread_Create(CLoopThread *p ) 
{ 
  int __result__ ;
  WRes tmp ;
  int __result_____0 ;
  WRes tmp___0 ;
  WRes tmp___1 ;

  {
  {
#line 39
  p->stop = 0;
#line 40
  tmp = AutoResetEvent_CreateNotSignaled(& p->startEvent);
#line 40
  __result__ = tmp;
  }
#line 40
  if (__result__ != 0) {
#line 40
    return (__result__);
  }
  {
#line 41
  tmp___0 = AutoResetEvent_CreateNotSignaled(& p->finishedEvent);
#line 41
  __result_____0 = tmp___0;
  }
#line 41
  if (__result_____0 != 0) {
#line 41
    return (__result_____0);
  }
  {
#line 42
  tmp___1 = Thread_Create(& p->thread, & LoopThreadFunc, (LPVOID )p);
  }
#line 42
  return (tmp___1);
}
}
#line 45 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
WRes LoopThread_StopAndWait(CLoopThread *p ) 
{ 
  WRes tmp ;
  WRes tmp___0 ;

  {
  {
#line 47
  p->stop = 1;
#line 48
  tmp = Event_Set(& p->startEvent);
  }
#line 48
  if (tmp != 0) {
#line 49
    return (12);
  }
  {
#line 50
  tmp___0 = Thread_Wait(& p->thread);
  }
#line 50
  return (tmp___0);
}
}
#line 53 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
WRes LoopThread_StartSubThread(CLoopThread *p ) 
{ 
  WRes tmp ;

  {
  {
#line 53
  tmp = Event_Set(& p->startEvent);
  }
#line 53
  return (tmp);
}
}
#line 54 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
WRes LoopThread_WaitSubThread(CLoopThread *p ) 
{ 
  WRes tmp ;

  {
  {
#line 54
  tmp = Event_Wait(& p->finishedEvent);
  }
#line 54
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static SRes Progress___0(ICompressProgress *p , UInt64 inSize , UInt64 outSize ) 
{ 
  int tmp___0 ;
  SRes tmp___1 ;

  {
#line 58
  if (p) {
    {
#line 58
    tmp___1 = (*(p->Progress))((void *)p, inSize, outSize);
    }
#line 58
    if (tmp___1 != 0) {
#line 58
      tmp___0 = 10;
    } else {
#line 58
      tmp___0 = 0;
    }
  } else {
#line 58
    tmp___0 = 0;
  }
#line 58
  return (tmp___0);
}
}
#line 61 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static void MtProgress_Init(CMtProgress *p , ICompressProgress *progress ) 
{ 
  unsigned int i ;
  UInt64 tmp ;
  UInt64 tmp___0 ;

  {
#line 64
  i = 0U;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 32U)) {
#line 64
      goto while_break;
    }
#line 65
    tmp = (UInt64 )0;
#line 65
    p->outSizes[i] = tmp;
#line 65
    p->inSizes[i] = tmp;
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  tmp___0 = (UInt64 )0;
#line 66
  p->totalOutSize = tmp___0;
#line 66
  p->totalInSize = tmp___0;
#line 67
  p->progress = progress;
#line 68
  p->res = 0;
#line 69
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static void MtProgress_Reinit(CMtProgress *p , unsigned int index___0 ) 
{ 


  {
#line 73
  p->inSizes[index___0] = (UInt64 )0;
#line 74
  p->outSizes[index___0] = (UInt64 )0;
#line 75
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
SRes MtProgress_Set(CMtProgress *p , unsigned int index___0 , UInt64 inSize , UInt64 outSize ) 
{ 
  SRes res ;

  {
  {
#line 83
  pthread_mutex_lock(& p->cs._mutex);
  }
#line 84
  if (inSize != 0xffffffffffffffffULL) {
#line 84
    p->totalInSize += inSize - p->inSizes[index___0];
#line 84
    p->inSizes[index___0] = inSize;
  }
#line 85
  if (outSize != 0xffffffffffffffffULL) {
#line 85
    p->totalOutSize += outSize - p->outSizes[index___0];
#line 85
    p->outSizes[index___0] = outSize;
  }
#line 86
  if (p->res == 0) {
    {
#line 87
    p->res = Progress___0(p->progress, p->totalInSize, p->totalOutSize);
    }
  }
  {
#line 88
  res = p->res;
#line 89
  pthread_mutex_unlock(& p->cs._mutex);
  }
#line 90
  return (res);
}
}
#line 93 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static void MtProgress_SetError(CMtProgress *p , SRes res ) 
{ 


  {
  {
#line 95
  pthread_mutex_lock(& p->cs._mutex);
  }
#line 96
  if (p->res == 0) {
#line 97
    p->res = res;
  }
  {
#line 98
  pthread_mutex_unlock(& p->cs._mutex);
  }
#line 99
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static void MtCoder_SetError(CMtCoder *p , SRes res ) 
{ 


  {
  {
#line 103
  pthread_mutex_lock(& p->cs._mutex);
  }
#line 104
  if (p->res == 0) {
#line 105
    p->res = res;
  }
  {
#line 106
  pthread_mutex_unlock(& p->cs._mutex);
  }
#line 107
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
void CMtThread_Construct(CMtThread *p , CMtCoder *mtCoder ) 
{ 


  {
  {
#line 113
  p->mtCoder = mtCoder;
#line 114
  p->outBuf = (Byte *)0;
#line 115
  p->inBuf = (Byte *)0;
#line 116
  p->canRead._created = 0;
#line 117
  p->canWrite._created = 0;
#line 118
  LoopThread_Construct(& p->thread);
  }
#line 119
  return;
}
}
#line 123 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static void CMtThread_CloseEvents(CMtThread *p ) 
{ 


  {
  {
#line 125
  Event_Close(& p->canRead);
#line 126
  Event_Close(& p->canWrite);
  }
#line 127
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static void CMtThread_Destruct(CMtThread *p ) 
{ 


  {
  {
#line 131
  CMtThread_CloseEvents(p);
  }
#line 133
  if (p->thread.thread._created != 0) {
    {
#line 135
    LoopThread_StopAndWait(& p->thread);
#line 136
    LoopThread_Close(& p->thread);
    }
  }
#line 139
  if ((p->mtCoder)->alloc) {
    {
#line 140
    (*(((p->mtCoder)->alloc)->Free))((void *)(p->mtCoder)->alloc, (void *)p->outBuf);
    }
  }
#line 141
  p->outBuf = (Byte *)0;
#line 143
  if ((p->mtCoder)->alloc) {
    {
#line 144
    (*(((p->mtCoder)->alloc)->Free))((void *)(p->mtCoder)->alloc, (void *)p->inBuf);
    }
  }
#line 145
  p->inBuf = (Byte *)0;
#line 146
  return;
}
}
#line 154 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static SRes CMtThread_Prepare(CMtThread *p ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  WRes tmp___1 ;
  WRes tmp___2 ;

  {
#line 156
  if ((unsigned long )p->inBuf == (unsigned long )((Byte *)0)) {
#line 156
    goto _L;
  } else
#line 156
  if (p->inBufSize != (p->mtCoder)->blockSize) {
    _L: /* CIL Label */ 
    {
#line 156
    (*(((p->mtCoder)->alloc)->Free))((void *)(p->mtCoder)->alloc, (void *)p->inBuf);
#line 156
    p->inBufSize = (p->mtCoder)->blockSize;
#line 156
    tmp = (*(((p->mtCoder)->alloc)->Alloc))((void *)(p->mtCoder)->alloc, p->inBufSize);
#line 156
    p->inBuf = (Byte *)tmp;
    }
#line 156
    if ((unsigned long )p->inBuf == (unsigned long )((Byte *)0)) {
#line 156
      return (2);
    }
  }
#line 157
  if ((unsigned long )p->outBuf == (unsigned long )((Byte *)0)) {
#line 157
    goto _L___0;
  } else
#line 157
  if (p->outBufSize != (p->mtCoder)->destBlockSize) {
    _L___0: /* CIL Label */ 
    {
#line 157
    (*(((p->mtCoder)->alloc)->Free))((void *)(p->mtCoder)->alloc, (void *)p->outBuf);
#line 157
    p->outBufSize = (p->mtCoder)->destBlockSize;
#line 157
    tmp___0 = (*(((p->mtCoder)->alloc)->Alloc))((void *)(p->mtCoder)->alloc, p->outBufSize);
#line 157
    p->outBuf = (Byte *)tmp___0;
    }
#line 157
    if ((unsigned long )p->outBuf == (unsigned long )((Byte *)0)) {
#line 157
      return (2);
    }
  }
  {
#line 159
  p->stopReading = 0;
#line 160
  p->stopWriting = 0;
#line 161
  tmp___1 = AutoResetEvent_CreateNotSignaled(& p->canRead);
  }
#line 161
  if (tmp___1 != 0) {
#line 161
    return (12);
  }
  {
#line 162
  tmp___2 = AutoResetEvent_CreateNotSignaled(& p->canWrite);
  }
#line 162
  if (tmp___2 != 0) {
#line 162
    return (12);
  }
#line 164
  return (0);
}
}
#line 167 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static SRes FullRead(ISeqInStream *stream , Byte *data , size_t *processedSize ) 
{ 
  size_t size ;
  size_t curSize ;
  SRes res ;
  SRes tmp ;
  int __result__ ;

  {
#line 169
  size = *processedSize;
#line 170
  *processedSize = (size_t )0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (size != 0UL)) {
#line 171
      goto while_break;
    }
    {
#line 173
    curSize = size;
#line 174
    tmp = (*(stream->Read))((void *)stream, (void *)data, & curSize);
#line 174
    res = tmp;
#line 175
    *processedSize += curSize;
#line 176
    data += curSize;
#line 177
    size -= curSize;
#line 178
    __result__ = res;
    }
#line 178
    if (__result__ != 0) {
#line 178
      return (__result__);
    }
#line 179
    if (curSize == 0UL) {
#line 180
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (0);
}
}
#line 187 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static SRes MtThread_Process(CMtThread *p , Bool *stop ) 
{ 
  CMtThread *next ;
  WRes tmp ;
  unsigned int tmp___0 ;
  int tmp___2 ;
  WRes tmp___3 ;
  size_t size ;
  size_t destSize ;
  int __result__ ;
  SRes tmp___4 ;
  Bool tmp___5 ;
  WRes tmp___6 ;
  int __result_____0 ;
  SRes tmp___7 ;
  WRes tmp___8 ;
  size_t tmp___9 ;
  int tmp___11 ;
  WRes tmp___12 ;

  {
  {
#line 190
  *stop = 1;
#line 191
  tmp = Event_Wait(& p->canRead);
  }
#line 191
  if (tmp != 0) {
#line 192
    return (12);
  }
#line 194
  if (p->index == (p->mtCoder)->numThreads - 1U) {
#line 194
    tmp___0 = 0U;
  } else {
#line 194
    tmp___0 = p->index + 1U;
  }
#line 194
  next = & (p->mtCoder)->threads[tmp___0];
#line 196
  if (p->stopReading) {
    {
#line 198
    next->stopReading = 1;
#line 199
    tmp___3 = Event_Set(& next->canRead);
    }
#line 199
    if (tmp___3 == 0) {
#line 199
      tmp___2 = 0;
    } else {
#line 199
      tmp___2 = 12;
    }
#line 199
    return (tmp___2);
  }
  {
#line 203
  size = (p->mtCoder)->blockSize;
#line 204
  destSize = p->outBufSize;
#line 206
  tmp___4 = FullRead((p->mtCoder)->inStream, p->inBuf, & size);
#line 206
  __result__ = tmp___4;
  }
#line 206
  if (__result__ != 0) {
#line 206
    return (__result__);
  }
  {
#line 207
  tmp___5 = size != (p->mtCoder)->blockSize;
#line 207
  *stop = tmp___5;
#line 207
  next->stopReading = tmp___5;
#line 208
  tmp___6 = Event_Set(& next->canRead);
  }
#line 208
  if (tmp___6 != 0) {
#line 209
    return (12);
  }
  {
#line 211
  tmp___7 = (*(((p->mtCoder)->mtCallback)->Code))((void *)(p->mtCoder)->mtCallback,
                                                  p->index, p->outBuf, & destSize,
                                                  (Byte const   *)p->inBuf, size,
                                                  *stop);
#line 211
  __result_____0 = tmp___7;
  }
#line 211
  if (__result_____0 != 0) {
#line 211
    return (__result_____0);
  }
  {
#line 214
  MtProgress_Reinit(& (p->mtCoder)->mtProgress, p->index);
#line 216
  tmp___8 = Event_Wait(& p->canWrite);
  }
#line 216
  if (tmp___8 != 0) {
#line 217
    return (12);
  }
#line 218
  if (p->stopWriting) {
#line 219
    return (11);
  }
  {
#line 220
  tmp___9 = (*(((p->mtCoder)->outStream)->Write))((void *)(p->mtCoder)->outStream,
                                                  (void const   *)p->outBuf, destSize);
  }
#line 220
  if (tmp___9 != destSize) {
#line 221
    return (9);
  }
  {
#line 222
  tmp___12 = Event_Set(& next->canWrite);
  }
#line 222
  if (tmp___12 == 0) {
#line 222
    tmp___11 = 0;
  } else {
#line 222
    tmp___11 = 12;
  }
#line 222
  return (tmp___11);
}
}
#line 226 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
static THREAD_FUNC_RET_TYPE ThreadFunc(void *pp ) 
{ 
  CMtThread *p ;
  Bool stop ;
  CMtThread *next ;
  unsigned int tmp ;
  SRes res ;
  SRes tmp___0 ;

  {
#line 228
  p = (CMtThread *)pp;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (p->index == (p->mtCoder)->numThreads - 1U) {
#line 232
      tmp = 0U;
    } else {
#line 232
      tmp = p->index + 1U;
    }
    {
#line 232
    next = & (p->mtCoder)->threads[tmp];
#line 233
    tmp___0 = MtThread_Process(p, & stop);
#line 233
    res = tmp___0;
    }
#line 234
    if (res != 0) {
      {
#line 236
      MtCoder_SetError(p->mtCoder, res);
#line 237
      MtProgress_SetError(& (p->mtCoder)->mtProgress, res);
#line 238
      next->stopReading = 1;
#line 239
      next->stopWriting = 1;
#line 240
      Event_Set(& next->canRead);
#line 241
      Event_Set(& next->canWrite);
      }
#line 242
      return ((THREAD_FUNC_RET_TYPE )res);
    }
#line 244
    if (stop) {
#line 245
      return ((THREAD_FUNC_RET_TYPE )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 249 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
void MtCoder_Construct(CMtCoder *p ) 
{ 
  unsigned int i ;
  CMtThread *t ;

  {
#line 252
  p->alloc = (ISzAlloc *)0;
#line 253
  i = 0U;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < 32U)) {
#line 253
      goto while_break;
    }
    {
#line 255
    t = & p->threads[i];
#line 256
    t->index = i;
#line 257
    CMtThread_Construct(t, p);
#line 253
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  CriticalSection_Init(& p->cs);
#line 260
  CriticalSection_Init(& p->mtProgress.cs);
  }
#line 261
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
void MtCoder_Destruct(CMtCoder *p ) 
{ 
  unsigned int i ;

  {
#line 266
  i = 0U;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i < 32U)) {
#line 266
      goto while_break;
    }
    {
#line 267
    CMtThread_Destruct(& p->threads[i]);
#line 266
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  pthread_mutex_destroy(& p->cs._mutex);
#line 269
  pthread_mutex_destroy(& p->mtProgress.cs._mutex);
  }
#line 270
  return;
}
}
#line 272 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/MtCoder.c"
SRes MtCoder_Code(CMtCoder *p ) 
{ 
  unsigned int i ;
  unsigned int numThreads ;
  SRes res ;
  int __result__ ;
  SRes tmp ;
  CMtThread *t ;
  CLoopThread *lt ;
  WRes tmp___0 ;
  unsigned int j ;
  CMtThread *t___0 ;
  WRes tmp___1 ;
  SRes tmp___2 ;

  {
  {
#line 274
  numThreads = p->numThreads;
#line 275
  res = 0;
#line 276
  p->res = 0;
#line 278
  MtProgress_Init(& p->mtProgress, p->progress);
#line 280
  i = 0U;
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < numThreads)) {
#line 280
      goto while_break;
    }
    {
#line 282
    tmp = CMtThread_Prepare(& p->threads[i]);
#line 282
    __result__ = tmp;
    }
#line 282
    if (__result__ != 0) {
#line 282
      return (__result__);
    }
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  i = 0U;
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! (i < numThreads)) {
#line 285
      goto while_break___0;
    }
#line 287
    t = & p->threads[i];
#line 288
    lt = & t->thread;
#line 290
    if (! (lt->thread._created != 0)) {
      {
#line 292
      lt->func = & ThreadFunc;
#line 293
      lt->param = (LPVOID )t;
#line 295
      tmp___0 = LoopThread_Create(lt);
      }
#line 295
      if (tmp___0 != 0) {
#line 297
        res = 12;
#line 298
        goto while_break___0;
      }
    }
#line 285
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 303
  if (res == 0) {
#line 306
    i = 0U;
    {
#line 306
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 306
      if (! (i < numThreads)) {
#line 306
        goto while_break___1;
      }
      {
#line 308
      t___0 = & p->threads[i];
#line 309
      tmp___1 = LoopThread_StartSubThread(& t___0->thread);
      }
#line 309
      if (tmp___1 != 0) {
#line 311
        res = 12;
#line 312
        p->threads[0].stopReading = 1;
#line 313
        goto while_break___1;
      }
#line 306
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 317
    Event_Set(& p->threads[0].canWrite);
#line 318
    Event_Set(& p->threads[0].canRead);
#line 320
    j = 0U;
    }
    {
#line 320
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 320
      if (! (j < i)) {
#line 320
        goto while_break___2;
      }
      {
#line 321
      LoopThread_WaitSubThread(& p->threads[j].thread);
#line 320
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 324
  i = 0U;
  {
#line 324
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 324
    if (! (i < numThreads)) {
#line 324
      goto while_break___3;
    }
    {
#line 325
    CMtThread_CloseEvents(& p->threads[i]);
#line 324
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 326
  if (res == 0) {
#line 326
    tmp___2 = p->res;
  } else {
#line 326
    tmp___2 = res;
  }
#line 326
  return (tmp___2);
}
}
#line 133 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
void Ppmd7z_RangeEnc_Init(CPpmd7z_RangeEnc *p ) ;
#line 134
void Ppmd7z_RangeEnc_FlushData(CPpmd7z_RangeEnc *p ) ;
#line 136
void Ppmd7_EncodeSymbol(CPpmd7 *p , CPpmd7z_RangeEnc *rc , int symbol ) ;
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Enc.c"
void Ppmd7z_RangeEnc_Init(CPpmd7z_RangeEnc *p ) 
{ 


  {
#line 11
  p->Low = (UInt64 )0;
#line 12
  p->Range = 4294967295U;
#line 13
  p->Cache = (Byte )0;
#line 14
  p->CacheSize = (UInt64 )1;
#line 15
  return;
}
}
#line 17 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Enc.c"
static void RangeEnc_ShiftLow___0(CPpmd7z_RangeEnc *p ) 
{ 
  Byte temp ;

  {
#line 19
  if ((UInt32 )p->Low < 4278190080U) {
#line 19
    goto _L;
  } else
#line 19
  if ((unsigned int )(p->Low >> 32) != 0U) {
    _L: /* CIL Label */ 
#line 21
    temp = p->Cache;
    {
#line 22
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 24
      (*((p->Stream)->Write))((void *)p->Stream, (Byte )((int )temp + (int )((Byte )(p->Low >> 32))));
#line 25
      temp = (Byte )255;
#line 22
      (p->CacheSize) --;
      }
#line 22
      if (! (p->CacheSize != 0ULL)) {
#line 22
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 28
    p->Cache = (Byte )((UInt32 )p->Low >> 24);
  }
#line 30
  (p->CacheSize) ++;
#line 31
  p->Low = (UInt64 )((UInt32 )p->Low << 8);
#line 32
  return;
}
}
#line 34 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Enc.c"
static void RangeEnc_Encode(CPpmd7z_RangeEnc *p , UInt32 start , UInt32 size , UInt32 total ) 
{ 
  UInt32 tmp ;

  {
#line 36
  tmp = p->Range / total;
#line 36
  p->Range = tmp;
#line 36
  p->Low += (UInt64 )(start * tmp);
#line 37
  p->Range *= size;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! (p->Range < (UInt32 )(1 << 24))) {
#line 38
      goto while_break;
    }
    {
#line 40
    p->Range <<= 8;
#line 41
    RangeEnc_ShiftLow___0(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return;
}
}
#line 45 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Enc.c"
static void RangeEnc_EncodeBit_0(CPpmd7z_RangeEnc *p , UInt32 size0 ) 
{ 


  {
#line 47
  p->Range = (p->Range >> 14) * size0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (p->Range < (UInt32 )(1 << 24))) {
#line 48
      goto while_break;
    }
    {
#line 50
    p->Range <<= 8;
#line 51
    RangeEnc_ShiftLow___0(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Enc.c"
static void RangeEnc_EncodeBit_1(CPpmd7z_RangeEnc *p , UInt32 size0 ) 
{ 
  UInt32 newBound ;

  {
#line 57
  newBound = (p->Range >> 14) * size0;
#line 58
  p->Low += (UInt64 )newBound;
#line 59
  p->Range -= newBound;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (p->Range < (UInt32 )(1 << 24))) {
#line 60
      goto while_break;
    }
    {
#line 62
    p->Range <<= 8;
#line 63
    RangeEnc_ShiftLow___0(p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Enc.c"
void Ppmd7z_RangeEnc_FlushData(CPpmd7z_RangeEnc *p ) 
{ 
  unsigned int i ;

  {
#line 70
  i = 0U;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < 5U)) {
#line 70
      goto while_break;
    }
    {
#line 71
    RangeEnc_ShiftLow___0(p);
#line 70
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7Enc.c"
void Ppmd7_EncodeSymbol(CPpmd7 *p , CPpmd7z_RangeEnc *rc , int symbol ) 
{ 
  size_t charMask[256UL / sizeof(size_t )] ;
  CPpmd_State *s ;
  UInt32 sum ;
  unsigned int i ;
  unsigned int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  UInt16 *prob ;
  unsigned int tmp___6 ;
  CPpmd_State *s___0 ;
  unsigned int i___1 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  UInt32 escFreq ;
  CPpmd_See *see ;
  CPpmd_State *s___1 ;
  UInt32 sum___0 ;
  unsigned int i___2 ;
  unsigned int numMasked ;
  int cur ;
  UInt32 low ;
  CPpmd_State *s1 ;
  Byte tmp___14 ;

  {
#line 80
  if ((int )(p->MinContext)->NumStats != 1) {
#line 82
    s = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 85
    if ((int )s->Symbol == symbol) {
      {
#line 87
      RangeEnc_Encode(rc, (UInt32 )0, (UInt32 )s->Freq, (UInt32 )(p->MinContext)->SummFreq);
#line 88
      p->FoundState = s;
#line 89
      Ppmd7_Update1_0(p);
      }
#line 90
      return;
    }
#line 92
    p->PrevSuccess = 0U;
#line 93
    sum = (UInt32 )s->Freq;
#line 94
    i = (unsigned int )((int )(p->MinContext)->NumStats - 1);
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 97
      s ++;
#line 97
      if ((int )s->Symbol == symbol) {
        {
#line 99
        RangeEnc_Encode(rc, sum, (UInt32 )s->Freq, (UInt32 )(p->MinContext)->SummFreq);
#line 100
        p->FoundState = s;
#line 101
        Ppmd7_Update1(p);
        }
#line 102
        return;
      }
#line 104
      sum += (UInt32 )s->Freq;
#line 95
      i --;
#line 95
      if (! i) {
#line 95
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 108
    p->HiBitsFlag = (unsigned int )p->HB2Flag[(p->FoundState)->Symbol];
#line 109
    i___0 = 0U;
    {
#line 109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 109
      if (! ((unsigned long )i___0 < 256UL / sizeof(charMask[0]))) {
#line 109
        goto while_break___0;
      }
#line 109
      tmp___5 = ~ ((size_t )0);
#line 109
      charMask[i___0] = tmp___5;
#line 109
      tmp___4 = tmp___5;
#line 109
      charMask[i___0 + 1U] = tmp___4;
#line 109
      tmp___3 = tmp___4;
#line 109
      charMask[i___0 + 2U] = tmp___3;
#line 109
      tmp___2 = tmp___3;
#line 109
      charMask[i___0 + 3U] = tmp___2;
#line 109
      tmp___1 = tmp___2;
#line 109
      charMask[i___0 + 4U] = tmp___1;
#line 109
      tmp___0 = tmp___1;
#line 109
      charMask[i___0 + 5U] = tmp___0;
#line 109
      tmp = tmp___0;
#line 109
      charMask[i___0 + 6U] = tmp;
#line 109
      charMask[i___0 + 7U] = tmp;
#line 109
      i___0 += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 111
    i = (unsigned int )((int )(p->MinContext)->NumStats - 1);
    {
#line 112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 112
      s --;
#line 112
      *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 112
      i --;
#line 112
      if (! i) {
#line 112
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 113
    RangeEnc_Encode(rc, sum, (UInt32 )(p->MinContext)->SummFreq - sum, (UInt32 )(p->MinContext)->SummFreq);
    }
  } else {
#line 117
    tmp___6 = (unsigned int )p->HB2Flag[(p->FoundState)->Symbol];
#line 117
    p->HiBitsFlag = tmp___6;
#line 117
    prob = & p->BinSumm[(int )((CPpmd_State *)(& (p->MinContext)->SummFreq))->Freq - 1][(((p->PrevSuccess + (unsigned int )p->NS2BSIndx[(int )((CPpmd7_Context *)((void *)(p->Base + (p->MinContext)->Suffix)))->NumStats - 1]) + tmp___6) + (unsigned int )(2 * (int )p->HB2Flag[((CPpmd_State *)(& (p->MinContext)->SummFreq))->Symbol])) + (unsigned int )((p->RunLength >> 26) & 32)];
#line 118
    s___0 = (CPpmd_State *)(& (p->MinContext)->SummFreq);
#line 119
    if ((int )s___0->Symbol == symbol) {
      {
#line 121
      RangeEnc_EncodeBit_0(rc, (UInt32 )*prob);
#line 122
      *prob = (UInt16 )(((int )*prob + (1 << 7)) - (((int )*prob + (1 << 5)) >> 7));
#line 123
      p->FoundState = s___0;
#line 124
      Ppmd7_UpdateBin(p);
      }
#line 125
      return;
    } else {
      {
#line 129
      RangeEnc_EncodeBit_1(rc, (UInt32 )*prob);
#line 130
      *prob = (UInt16 )((int )*prob - (((int )*prob + (1 << 5)) >> 7));
#line 131
      p->InitEsc = (unsigned int )PPMD7_kExpEscape[(int )*prob >> 10];
#line 132
      i___1 = 0U;
      }
      {
#line 132
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 132
        if (! ((unsigned long )i___1 < 256UL / sizeof(charMask[0]))) {
#line 132
          goto while_break___2;
        }
#line 132
        tmp___13 = ~ ((size_t )0);
#line 132
        charMask[i___1] = tmp___13;
#line 132
        tmp___12 = tmp___13;
#line 132
        charMask[i___1 + 1U] = tmp___12;
#line 132
        tmp___11 = tmp___12;
#line 132
        charMask[i___1 + 2U] = tmp___11;
#line 132
        tmp___10 = tmp___11;
#line 132
        charMask[i___1 + 3U] = tmp___10;
#line 132
        tmp___9 = tmp___10;
#line 132
        charMask[i___1 + 4U] = tmp___9;
#line 132
        tmp___8 = tmp___9;
#line 132
        charMask[i___1 + 5U] = tmp___8;
#line 132
        tmp___7 = tmp___8;
#line 132
        charMask[i___1 + 6U] = tmp___7;
#line 132
        charMask[i___1 + 7U] = tmp___7;
#line 132
        i___1 += 8U;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 133
      *((signed char *)(charMask) + s___0->Symbol) = (signed char)0;
#line 134
      p->PrevSuccess = 0U;
    }
  }
  {
#line 137
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 143
    numMasked = (unsigned int )(p->MinContext)->NumStats;
    {
#line 144
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 146
      (p->OrderFall) ++;
#line 147
      if (! (p->MinContext)->Suffix) {
#line 148
        return;
      }
#line 149
      p->MinContext = (CPpmd7_Context *)((void *)(p->Base + (p->MinContext)->Suffix));
#line 144
      if (! ((unsigned int )(p->MinContext)->NumStats == numMasked)) {
#line 144
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 153
    see = Ppmd7_MakeEscFreq(p, numMasked, & escFreq);
#line 154
    s___1 = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 155
    sum___0 = (UInt32 )0;
#line 156
    i___2 = (unsigned int )(p->MinContext)->NumStats;
    }
    {
#line 157
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 159
      cur = (int )s___1->Symbol;
#line 160
      if (cur == symbol) {
#line 162
        low = sum___0;
#line 163
        s1 = s___1;
        {
#line 164
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 166
          sum___0 += (UInt32 )((int )s___1->Freq & (int )*((signed char *)(charMask) + s___1->Symbol));
#line 167
          s___1 ++;
#line 164
          i___2 --;
#line 164
          if (! i___2) {
#line 164
            goto while_break___6;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 170
        RangeEnc_Encode(rc, low, (UInt32 )s1->Freq, sum___0 + escFreq);
        }
#line 171
        if ((int )see->Shift < 7) {
#line 171
          see->Count = (Byte )((int )see->Count - 1);
#line 171
          if ((int )see->Count == 0) {
#line 171
            see->Summ = (UInt16 )((int )see->Summ << 1);
#line 171
            tmp___14 = see->Shift;
#line 171
            see->Shift = (Byte )((int )see->Shift + 1);
#line 171
            see->Count = (Byte )(3 << (int )tmp___14);
          }
        }
        {
#line 172
        p->FoundState = s1;
#line 173
        Ppmd7_Update2(p);
        }
#line 174
        return;
      }
#line 176
      sum___0 += (UInt32 )((int )s___1->Freq & (int )*((signed char *)(charMask) + cur));
#line 177
      *((signed char *)(charMask) + cur) = (signed char)0;
#line 178
      s___1 ++;
#line 157
      i___2 --;
#line 157
      if (! i___2) {
#line 157
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 182
    RangeEnc_Encode(rc, sum___0, escFreq, sum___0 + escFreq);
#line 183
    see->Summ = (UInt16 )(((UInt32 )see->Summ + sum___0) + escFreq);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 6 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/BraIA64.c"
static Byte const   kBranchTable[32]  = 
#line 6 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/BraIA64.c"
  {      (Byte const   )0,      (Byte const   )0,      (Byte const   )0,      (Byte const   )0, 
        (Byte const   )0,      (Byte const   )0,      (Byte const   )0,      (Byte const   )0, 
        (Byte const   )0,      (Byte const   )0,      (Byte const   )0,      (Byte const   )0, 
        (Byte const   )0,      (Byte const   )0,      (Byte const   )0,      (Byte const   )0, 
        (Byte const   )4,      (Byte const   )4,      (Byte const   )6,      (Byte const   )6, 
        (Byte const   )0,      (Byte const   )0,      (Byte const   )7,      (Byte const   )7, 
        (Byte const   )4,      (Byte const   )4,      (Byte const   )0,      (Byte const   )0, 
        (Byte const   )4,      (Byte const   )4,      (Byte const   )0,      (Byte const   )0};
#line 14 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/BraIA64.c"
SizeT IA64_Convert(Byte *data , SizeT size , UInt32 ip , int encoding ) 
{ 
  SizeT i ;
  UInt32 instrTemplate ;
  UInt32 mask ;
  UInt32 bitPos ;
  int slot ;
  UInt32 bytePos ;
  UInt32 bitRes ;
  UInt64 instruction ;
  UInt64 instNorm ;
  int j ;
  UInt32 src ;
  UInt32 dest ;

  {
#line 17
  if (size < 16UL) {
#line 18
    return ((SizeT )0);
  }
#line 19
  size -= 16UL;
#line 20
  i = (SizeT )0;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! (i <= size)) {
#line 20
      goto while_break;
    }
#line 22
    instrTemplate = (UInt32 )((int )*(data + i) & 31);
#line 23
    mask = (UInt32 )kBranchTable[instrTemplate];
#line 24
    bitPos = (UInt32 )5;
#line 26
    slot = 0;
    {
#line 26
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 26
      if (! (slot < 3)) {
#line 26
        goto while_break___0;
      }
#line 31
      if (((mask >> slot) & 1U) == 0U) {
#line 32
        goto __Cont;
      }
#line 33
      bytePos = bitPos >> 3;
#line 34
      bitRes = bitPos & 7U;
#line 35
      instruction = (UInt64 )0;
#line 36
      j = 0;
      {
#line 36
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 36
        if (! (j < 6)) {
#line 36
          goto while_break___1;
        }
#line 37
        instruction += (UInt64 )*(data + ((i + (SizeT )j) + (SizeT )bytePos)) << 8 * j;
#line 36
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 39
      instNorm = instruction >> bitRes;
#line 40
      if (((instNorm >> 37) & 15ULL) == 5ULL) {
#line 40
        if (((instNorm >> 9) & 7ULL) == 0ULL) {
#line 42
          src = (UInt32 )((instNorm >> 13) & 1048575ULL);
#line 44
          src |= ((UInt32 )(instNorm >> 36) & 1U) << 20;
#line 46
          src <<= 4;
#line 48
          if (encoding) {
#line 49
            dest = (ip + (UInt32 )i) + src;
          } else {
#line 51
            dest = src - (ip + (UInt32 )i);
          }
#line 53
          dest >>= 4;
#line 55
          instNorm &= ~ (9437183ULL << 13);
#line 56
          instNorm |= (UInt64 )(dest & 1048575U) << 13;
#line 57
          instNorm |= (UInt64 )(dest & 1048576U) << 16;
#line 59
          instruction &= (unsigned long long )((1 << bitRes) - 1);
#line 60
          instruction |= instNorm << bitRes;
#line 61
          j = 0;
          {
#line 61
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 61
            if (! (j < 6)) {
#line 61
              goto while_break___2;
            }
#line 62
            *(data + ((i + (SizeT )j) + (SizeT )bytePos)) = (Byte )(instruction >> 8 * j);
#line 61
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 26
      slot ++;
#line 26
      bitPos += 41U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 20
    i += 16UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (i);
}
}
#line 73 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
void LzmaDec_Init(CLzmaDec *p ) ;
#line 134
SRes LzmaDec_AllocateProbs(CLzmaDec *p , Byte const   *props , unsigned int propsSize ,
                           ISzAlloc *alloc ) ;
#line 135
void LzmaDec_FreeProbs(CLzmaDec *p , ISzAlloc *alloc ) ;
#line 137
SRes LzmaDec_Allocate(CLzmaDec *p , Byte const   *props , unsigned int propsSize ,
                      ISzAlloc *alloc ) ;
#line 181
SRes LzmaDec_DecodeToDic(CLzmaDec *p , SizeT dicLimit , Byte const   *src , SizeT *srcLen ,
                         ELzmaFinishMode finishMode , ELzmaStatus *status ) ;
#line 31 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.h"
SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p , Byte prop , ISzAlloc *alloc ) ;
#line 51
SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p , SizeT dicLimit , Byte const   *src , SizeT *srcLen ,
                          ELzmaFinishMode finishMode , ELzmaStatus *status ) ;
#line 77
SRes Lzma2Decode(Byte *dest , SizeT *destLen , Byte const   *src , SizeT *srcLen ,
                 Byte prop , ELzmaFinishMode finishMode , ELzmaStatus *status , ISzAlloc *alloc ) ;
#line 61 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
static SRes Lzma2Dec_GetOldProps(Byte prop , Byte *props ) 
{ 
  UInt32 dicSize ;

  {
#line 64
  if ((int )prop > 40) {
#line 65
    return (4);
  }
#line 66
  if ((int )prop == 40) {
#line 66
    dicSize = 4294967295U;
  } else {
#line 66
    dicSize = (2U | (unsigned int )((int )prop & 1)) << ((int )prop / 2 + 11);
  }
#line 67
  *(props + 0) = (Byte )4;
#line 68
  *(props + 1) = (Byte )dicSize;
#line 69
  *(props + 2) = (Byte )(dicSize >> 8);
#line 70
  *(props + 3) = (Byte )(dicSize >> 16);
#line 71
  *(props + 4) = (Byte )(dicSize >> 24);
#line 72
  return (0);
}
}
#line 75 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p , Byte prop , ISzAlloc *alloc ) 
{ 
  Byte props[5] ;
  int __result__ ;
  SRes tmp ;
  SRes tmp___0 ;

  {
  {
#line 78
  tmp = Lzma2Dec_GetOldProps(prop, props);
#line 78
  __result__ = tmp;
  }
#line 78
  if (__result__ != 0) {
#line 78
    return (__result__);
  }
  {
#line 79
  tmp___0 = LzmaDec_AllocateProbs(& p->decoder, (Byte const   *)(props), 5U, alloc);
  }
#line 79
  return (tmp___0);
}
}
#line 82 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
SRes Lzma2Dec_Allocate(CLzma2Dec *p , Byte prop , ISzAlloc *alloc ) 
{ 
  Byte props[5] ;
  int __result__ ;
  SRes tmp ;
  SRes tmp___0 ;

  {
  {
#line 85
  tmp = Lzma2Dec_GetOldProps(prop, props);
#line 85
  __result__ = tmp;
  }
#line 85
  if (__result__ != 0) {
#line 85
    return (__result__);
  }
  {
#line 86
  tmp___0 = LzmaDec_Allocate(& p->decoder, (Byte const   *)(props), 5U, alloc);
  }
#line 86
  return (tmp___0);
}
}
#line 89 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
void Lzma2Dec_Init(CLzma2Dec *p ) 
{ 


  {
  {
#line 91
  p->state = 0;
#line 92
  p->needInitDic = 1;
#line 93
  p->needInitState = 1;
#line 94
  p->needInitProp = 1;
#line 95
  LzmaDec_Init(& p->decoder);
  }
#line 96
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
static ELzma2State Lzma2Dec_UpdateState(CLzma2Dec *p , Byte b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int lc ;
  int lp ;

  {
  {
#line 102
  if (p->state == 0) {
#line 102
    goto case_0;
  }
#line 118
  if (p->state == 1) {
#line 118
    goto case_1;
  }
#line 122
  if (p->state == 2) {
#line 122
    goto case_2;
  }
#line 128
  if (p->state == 3) {
#line 128
    goto case_3;
  }
#line 132
  if (p->state == 4) {
#line 132
    goto case_4;
  }
#line 139
  if (p->state == 5) {
#line 139
    goto case_5;
  }
#line 100
  goto switch_break;
  case_0: /* CIL Label */ 
#line 103
  p->control = b;
#line 106
  if ((int )p->control == 0) {
#line 107
    return ((ELzma2State )8);
  }
#line 108
  if (((int )p->control & (1 << 7)) == 0) {
#line 110
    if (((int )p->control & 127) > 2) {
#line 111
      return ((ELzma2State )9);
    }
#line 112
    p->unpackSize = (UInt32 )0;
  } else {
#line 115
    p->unpackSize = (UInt32 )((int )p->control & 31) << 16;
  }
#line 116
  return ((ELzma2State )1);
  case_1: /* CIL Label */ 
#line 119
  p->unpackSize |= (UInt32 )b << 8;
#line 120
  return ((ELzma2State )2);
  case_2: /* CIL Label */ 
#line 123
  p->unpackSize |= (UInt32 )b;
#line 124
  (p->unpackSize) ++;
#line 126
  if (((int )p->control & (1 << 7)) == 0) {
#line 126
    tmp = 6;
  } else {
#line 126
    tmp = 3;
  }
#line 126
  return ((ELzma2State )tmp);
  case_3: /* CIL Label */ 
#line 129
  p->packSize = (UInt32 )b << 8;
#line 130
  return ((ELzma2State )4);
  case_4: /* CIL Label */ 
#line 133
  p->packSize |= (UInt32 )b;
#line 134
  (p->packSize) ++;
#line 136
  if ((((int )p->control >> 5) & 3) >= 2) {
#line 136
    tmp___1 = 5;
  } else {
#line 136
    if (p->needInitProp) {
#line 136
      tmp___0 = 9;
    } else {
#line 136
      tmp___0 = 6;
    }
#line 136
    tmp___1 = tmp___0;
  }
#line 136
  return ((ELzma2State )tmp___1);
  case_5: /* CIL Label */ 
#line 142
  if ((int )b >= 225) {
#line 143
    return ((ELzma2State )9);
  }
#line 144
  lc = (int )b % 9;
#line 145
  b = (Byte )((int )b / 9);
#line 146
  p->decoder.prop.pb = (unsigned int )((int )b / 5);
#line 147
  lp = (int )b % 5;
#line 148
  if (lc + lp > 4) {
#line 149
    return ((ELzma2State )9);
  }
#line 150
  p->decoder.prop.lc = (unsigned int )lc;
#line 151
  p->decoder.prop.lp = (unsigned int )lp;
#line 152
  p->needInitProp = 0;
#line 153
  return ((ELzma2State )6);
  switch_break: /* CIL Label */ ;
  }
#line 156
  return ((ELzma2State )9);
}
}
#line 159 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
static void LzmaDec_UpdateWithUncompressed(CLzmaDec *p , Byte const   *src , SizeT size ) 
{ 


  {
  {
#line 161
  memcpy((void */* __restrict  */)(p->dic + p->dicPos), (void const   */* __restrict  */)src,
         size);
#line 162
  p->dicPos += size;
  }
#line 163
  if (p->checkDicSize == 0U) {
#line 163
    if ((SizeT )(p->prop.dicSize - p->processedPos) <= size) {
#line 164
      p->checkDicSize = p->prop.dicSize;
    }
  }
#line 165
  p->processedPos += (UInt32 )size;
#line 166
  return;
}
}
#line 168
void LzmaDec_InitDicAndState(CLzmaDec *p , Bool initDic , Bool initState ) ;
#line 170 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p , SizeT dicLimit , Byte const   *src , SizeT *srcLen ,
                          ELzmaFinishMode finishMode , ELzmaStatus *status ) 
{ 
  SizeT inSize ;
  SizeT dicPos ;
  Byte const   *tmp ;
  ELzma2State tmp___0 ;
  SizeT destSizeCur ;
  SizeT srcSizeCur ;
  ELzmaFinishMode curFinishMode ;
  Bool initDic ;
  Bool tmp___1 ;
  SizeT outSizeProcessed ;
  SRes res ;
  int mode ;
  Bool initDic___0 ;
  Bool initState ;
  int __result__ ;

  {
#line 173
  inSize = *srcLen;
#line 174
  *srcLen = (SizeT )0;
#line 175
  *status = (ELzmaStatus )0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (p->state != 8)) {
#line 177
      goto while_break;
    }
#line 179
    dicPos = p->decoder.dicPos;
#line 180
    if (p->state == 9) {
#line 181
      return (1);
    }
#line 182
    if (dicPos == dicLimit) {
#line 182
      if ((unsigned int )finishMode == 0U) {
#line 184
        *status = (ELzmaStatus )2;
#line 185
        return (0);
      }
    }
#line 187
    if (p->state != 6) {
#line 187
      if (p->state != 7) {
#line 189
        if (*srcLen == inSize) {
#line 191
          *status = (ELzmaStatus )3;
#line 192
          return (0);
        }
        {
#line 194
        (*srcLen) ++;
#line 195
        tmp = src;
#line 195
        src ++;
#line 195
        tmp___0 = Lzma2Dec_UpdateState(p, (Byte )*tmp);
#line 195
        p->state = (int )tmp___0;
        }
#line 196
        goto while_continue;
      }
    }
#line 199
    destSizeCur = dicLimit - dicPos;
#line 200
    srcSizeCur = inSize - *srcLen;
#line 201
    curFinishMode = (ELzmaFinishMode )0;
#line 203
    if ((SizeT )p->unpackSize <= destSizeCur) {
#line 205
      destSizeCur = (SizeT )p->unpackSize;
#line 206
      curFinishMode = (ELzmaFinishMode )1;
    }
#line 209
    if (((int )p->control & (1 << 7)) == 0) {
#line 211
      if (*srcLen == inSize) {
#line 213
        *status = (ELzmaStatus )3;
#line 214
        return (0);
      }
#line 217
      if (p->state == 6) {
#line 219
        initDic = (int )p->control == 1;
#line 220
        if (initDic) {
#line 221
          tmp___1 = 1;
#line 221
          p->needInitState = tmp___1;
#line 221
          p->needInitProp = tmp___1;
        } else
#line 222
        if (p->needInitDic) {
#line 223
          return (1);
        }
        {
#line 224
        p->needInitDic = 0;
#line 225
        LzmaDec_InitDicAndState(& p->decoder, initDic, 0);
        }
      }
#line 228
      if (srcSizeCur > destSizeCur) {
#line 229
        srcSizeCur = destSizeCur;
      }
#line 231
      if (srcSizeCur == 0UL) {
#line 232
        return (1);
      }
      {
#line 234
      LzmaDec_UpdateWithUncompressed(& p->decoder, src, srcSizeCur);
#line 236
      src += srcSizeCur;
#line 237
      *srcLen += srcSizeCur;
#line 238
      p->unpackSize -= (UInt32 )srcSizeCur;
      }
#line 239
      if (p->unpackSize == 0U) {
#line 239
        p->state = 0;
      } else {
#line 239
        p->state = 7;
      }
    } else {
#line 246
      if (p->state == 6) {
#line 248
        mode = ((int )p->control >> 5) & 3;
#line 249
        initDic___0 = mode == 3;
#line 250
        initState = mode > 0;
#line 251
        if (! initDic___0) {
#line 251
          if (p->needInitDic) {
#line 252
            return (1);
          } else {
#line 251
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 251
        if (! initState) {
#line 251
          if (p->needInitState) {
#line 252
            return (1);
          }
        }
        {
#line 254
        LzmaDec_InitDicAndState(& p->decoder, initDic___0, initState);
#line 255
        p->needInitDic = 0;
#line 256
        p->needInitState = 0;
#line 257
        p->state = 7;
        }
      }
#line 259
      if (srcSizeCur > (SizeT )p->packSize) {
#line 260
        srcSizeCur = (SizeT )p->packSize;
      }
      {
#line 262
      res = LzmaDec_DecodeToDic(& p->decoder, dicPos + destSizeCur, src, & srcSizeCur,
                                curFinishMode, status);
#line 264
      src += srcSizeCur;
#line 265
      *srcLen += srcSizeCur;
#line 266
      p->packSize -= (UInt32 )srcSizeCur;
#line 268
      outSizeProcessed = p->decoder.dicPos - dicPos;
#line 269
      p->unpackSize -= (UInt32 )outSizeProcessed;
#line 271
      __result__ = res;
      }
#line 271
      if (__result__ != 0) {
#line 271
        return (__result__);
      }
#line 272
      if ((unsigned int )*status == 3U) {
#line 273
        return (res);
      }
#line 275
      if (srcSizeCur == 0UL) {
#line 275
        if (outSizeProcessed == 0UL) {
#line 277
          if ((unsigned int )*status != 4U) {
#line 279
            return (1);
          } else
#line 277
          if (p->unpackSize != 0U) {
#line 279
            return (1);
          } else
#line 277
          if (p->packSize != 0U) {
#line 279
            return (1);
          }
#line 280
          p->state = 0;
        }
      }
#line 282
      if ((unsigned int )*status == 4U) {
#line 283
        *status = (ELzmaStatus )2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  *status = (ELzmaStatus )1;
#line 288
  return (0);
}
}
#line 291 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                          SizeT *srcLen , ELzmaFinishMode finishMode , ELzmaStatus *status ) 
{ 
  SizeT outSize ;
  SizeT inSize ;
  SizeT tmp ;
  SizeT srcSizeCur ;
  SizeT outSizeCur ;
  SizeT dicPos ;
  ELzmaFinishMode curFinishMode ;
  SRes res ;

  {
#line 293
  outSize = *destLen;
#line 293
  inSize = *srcLen;
#line 294
  tmp = (SizeT )0;
#line 294
  *destLen = tmp;
#line 294
  *srcLen = tmp;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    srcSizeCur = inSize;
#line 300
    if (p->decoder.dicPos == p->decoder.dicBufSize) {
#line 301
      p->decoder.dicPos = (SizeT )0;
    }
#line 302
    dicPos = p->decoder.dicPos;
#line 303
    if (outSize > p->decoder.dicBufSize - dicPos) {
#line 305
      outSizeCur = p->decoder.dicBufSize;
#line 306
      curFinishMode = (ELzmaFinishMode )0;
    } else {
#line 310
      outSizeCur = dicPos + outSize;
#line 311
      curFinishMode = finishMode;
    }
    {
#line 314
    res = Lzma2Dec_DecodeToDic(p, outSizeCur, src, & srcSizeCur, curFinishMode, status);
#line 315
    src += srcSizeCur;
#line 316
    inSize -= srcSizeCur;
#line 317
    *srcLen += srcSizeCur;
#line 318
    outSizeCur = p->decoder.dicPos - dicPos;
#line 319
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)(p->decoder.dic + dicPos),
           outSizeCur);
#line 320
    dest += outSizeCur;
#line 321
    outSize -= outSizeCur;
#line 322
    *destLen += outSizeCur;
    }
#line 323
    if (res != 0) {
#line 324
      return (res);
    }
#line 325
    if (outSizeCur == 0UL) {
#line 326
      return (0);
    } else
#line 325
    if (outSize == 0UL) {
#line 326
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 330 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Lzma2Dec.c"
SRes Lzma2Decode(Byte *dest , SizeT *destLen , Byte const   *src , SizeT *srcLen ,
                 Byte prop , ELzmaFinishMode finishMode , ELzmaStatus *status , ISzAlloc *alloc ) 
{ 
  CLzma2Dec decoder ;
  SRes res ;
  SizeT outSize ;
  SizeT inSize ;
  Byte props[5] ;
  SizeT tmp ;
  int __result__ ;
  SRes tmp___0 ;
  int __result_____0 ;
  SRes tmp___1 ;

  {
  {
#line 335
  outSize = *destLen;
#line 335
  inSize = *srcLen;
#line 338
  decoder.decoder.dic = (Byte *)0;
#line 338
  decoder.decoder.probs = (UInt16 *)0;
#line 340
  tmp = (SizeT )0;
#line 340
  *srcLen = tmp;
#line 340
  *destLen = tmp;
#line 341
  *status = (ELzmaStatus )0;
#line 342
  decoder.decoder.dic = dest;
#line 343
  decoder.decoder.dicBufSize = outSize;
#line 345
  tmp___0 = Lzma2Dec_GetOldProps(prop, props);
#line 345
  __result__ = tmp___0;
  }
#line 345
  if (__result__ != 0) {
#line 345
    return (__result__);
  }
  {
#line 346
  tmp___1 = LzmaDec_AllocateProbs(& decoder.decoder, (Byte const   *)(props), 5U,
                                  alloc);
#line 346
  __result_____0 = tmp___1;
  }
#line 346
  if (__result_____0 != 0) {
#line 346
    return (__result_____0);
  }
  {
#line 348
  *srcLen = inSize;
#line 349
  res = Lzma2Dec_DecodeToDic(& decoder, outSize, src, srcLen, finishMode, status);
#line 350
  *destLen = decoder.decoder.dicPos;
  }
#line 351
  if (res == 0) {
#line 351
    if ((unsigned int )*status == 3U) {
#line 352
      res = 6;
    }
  }
  {
#line 354
  LzmaDec_FreeProbs(& decoder.decoder, alloc);
  }
#line 355
  return (res);
}
}
#line 24 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/BwtSort.h"
UInt32 BlockSort(UInt32 *Indices , Byte const   *data , UInt32 blockSize ) ;
#line 43 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/BwtSort.c"
static void SetGroupSize(UInt32 *p , UInt32 size ) 
{ 


  {
#line 45
  size --;
#line 45
  if (size == 0U) {
#line 46
    return;
  }
#line 47
  *p |= 2147483648U | ((size & (unsigned int )((1 << 10) - 1)) << 20);
#line 48
  if (size >= (UInt32 )(1 << 10)) {
#line 50
    *p |= 1073741824U;
#line 51
    *(p + 1) |= (size >> 10) << 20;
  }
#line 53
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/BwtSort.c"
UInt32 SortGroup(UInt32 BlockSize , UInt32 NumSortedBytes , UInt32 groupOffset , UInt32 groupSize ,
                 int NumRefBits , UInt32 *Indices , UInt32 left , UInt32 range ) 
{ 
  UInt32 *ind2 ;
  UInt32 *Groups ;
  UInt32 *temp ;
  UInt32 j ;
  UInt32 mask ;
  UInt32 thereAreGroups ;
  UInt32 group ;
  UInt32 cg ;
  UInt32 gPrev ;
  UInt32 gRes ;
  UInt32 sp ;
  UInt32 sp___0 ;
  UInt32 g ;
  UInt32 prevGroupStart ;
  UInt32 val ;
  UInt32 cgCur ;
  UInt32 ind ;
  UInt32 group___0 ;
  UInt32 j___0 ;
  UInt32 sp___1 ;
  UInt32 i ;
  UInt32 mid ;
  UInt32 j___1 ;
  UInt32 sp___2 ;
  UInt32 temp___0 ;
  UInt32 j___2 ;
  UInt32 res ;
  UInt32 tmp ;
  UInt32 tmp___0 ;

  {
#line 69
  ind2 = Indices + groupOffset;
#line 71
  if (groupSize <= 1U) {
#line 78
    return ((UInt32 )0);
  }
#line 80
  Groups = (Indices + BlockSize) + (1 << 16);
#line 81
  if (groupSize <= 1U << NumRefBits) {
#line 81
    if (groupSize <= range) {
#line 87
      temp = Indices + BlockSize;
#line 92
      gRes = (UInt32 )0;
#line 94
      sp = *(ind2 + 0) + NumSortedBytes;
#line 95
      if (sp >= BlockSize) {
#line 95
        sp -= BlockSize;
      }
#line 96
      gPrev = *(Groups + sp);
#line 97
      *(temp + 0) = gPrev << NumRefBits;
#line 100
      j = (UInt32 )1;
      {
#line 100
      while (1) {
        while_continue: /* CIL Label */ ;
#line 100
        if (! (j < groupSize)) {
#line 100
          goto while_break;
        }
#line 102
        sp___0 = *(ind2 + j) + NumSortedBytes;
#line 104
        if (sp___0 >= BlockSize) {
#line 104
          sp___0 -= BlockSize;
        }
#line 105
        g = *(Groups + sp___0);
#line 106
        *(temp + j) = (g << NumRefBits) | j;
#line 107
        gRes |= gPrev ^ g;
#line 100
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 109
      if (gRes == 0U) {
        {
#line 112
        SetGroupSize(ind2, groupSize);
        }
#line 114
        return ((UInt32 )1);
      }
      {
#line 118
      HeapSort(temp, groupSize);
#line 119
      mask = (UInt32 )((1 << NumRefBits) - 1);
#line 120
      thereAreGroups = (UInt32 )0;
#line 122
      group = groupOffset;
#line 123
      cg = *(temp + 0) >> NumRefBits;
#line 124
      *(temp + 0) = *(ind2 + (*(temp + 0) & mask));
#line 130
      prevGroupStart = (UInt32 )0;
#line 133
      j = (UInt32 )1;
      }
      {
#line 133
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 133
        if (! (j < groupSize)) {
#line 133
          goto while_break___0;
        }
#line 135
        val = *(temp + j);
#line 136
        cgCur = val >> NumRefBits;
#line 138
        if (cgCur != cg) {
          {
#line 140
          cg = cgCur;
#line 141
          group = groupOffset + j;
#line 149
          SetGroupSize(temp + prevGroupStart, j - prevGroupStart);
#line 150
          prevGroupStart = j;
          }
        } else {
#line 154
          thereAreGroups = (UInt32 )1;
        }
#line 156
        ind = *(ind2 + (val & mask));
#line 157
        *(temp + j) = ind;
#line 158
        *(Groups + ind) = group;
#line 133
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 163
      SetGroupSize(temp + prevGroupStart, j - prevGroupStart);
#line 167
      j = (UInt32 )0;
      }
      {
#line 167
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 167
        if (! (j < groupSize)) {
#line 167
          goto while_break___1;
        }
#line 168
        *(ind2 + j) = *(temp + j);
#line 167
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 169
      return (thereAreGroups);
    }
  }
#line 175
  sp___1 = *(ind2 + 0) + NumSortedBytes;
#line 175
  if (sp___1 >= BlockSize) {
#line 175
    sp___1 -= BlockSize;
  }
#line 176
  group___0 = *(Groups + sp___1);
#line 177
  j___0 = (UInt32 )1;
  {
#line 177
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 177
    if (! (j___0 < groupSize)) {
#line 177
      goto while_break___2;
    }
#line 179
    sp___1 = *(ind2 + j___0) + NumSortedBytes;
#line 179
    if (sp___1 >= BlockSize) {
#line 179
      sp___1 -= BlockSize;
    }
#line 180
    if (*(Groups + sp___1) != group___0) {
#line 181
      goto while_break___2;
    }
#line 177
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 183
  if (j___0 == groupSize) {
    {
#line 186
    SetGroupSize(ind2, groupSize);
    }
#line 188
    return ((UInt32 )1);
  }
  {
#line 197
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 200
    if (range <= 1U) {
      {
#line 203
      SetGroupSize(ind2, groupSize);
      }
#line 205
      return ((UInt32 )1);
    }
#line 207
    mid = left + ((range + 1U) >> 1);
#line 208
    j___1 = groupSize;
#line 209
    i = (UInt32 )0;
    {
#line 210
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 212
      sp___2 = *(ind2 + i) + NumSortedBytes;
#line 212
      if (sp___2 >= BlockSize) {
#line 212
        sp___2 -= BlockSize;
      }
#line 213
      if (*(Groups + sp___2) >= mid) {
#line 215
        j___1 --;
        {
#line 215
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 215
          if (! (j___1 > i)) {
#line 215
            goto while_break___5;
          }
#line 217
          sp___2 = *(ind2 + j___1) + NumSortedBytes;
#line 217
          if (sp___2 >= BlockSize) {
#line 217
            sp___2 -= BlockSize;
          }
#line 218
          if (*(Groups + sp___2) < mid) {
#line 220
            temp___0 = *(ind2 + i);
#line 220
            *(ind2 + i) = *(ind2 + j___1);
#line 220
            *(ind2 + j___1) = temp___0;
#line 221
            goto while_break___5;
          }
#line 215
          j___1 --;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 224
        if (i >= j___1) {
#line 225
          goto while_break___4;
        }
      }
#line 210
      i ++;
#line 210
      if (! (i < j___1)) {
#line 210
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 229
    if (i == 0U) {
#line 231
      range -= mid - left;
#line 232
      left = mid;
    } else
#line 234
    if (i == groupSize) {
#line 235
      range = mid - left;
    } else {
#line 237
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 250
  j___2 = i;
  {
#line 250
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 250
    if (! (j___2 < groupSize)) {
#line 250
      goto while_break___6;
    }
#line 251
    *(Groups + *(ind2 + j___2)) = groupOffset + i;
#line 250
    j___2 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 255
  tmp = SortGroup(BlockSize, NumSortedBytes, groupOffset, i, NumRefBits, Indices,
                  left, mid - left);
#line 255
  res = tmp;
#line 256
  tmp___0 = SortGroup(BlockSize, NumSortedBytes, groupOffset + i, groupSize - i, NumRefBits,
                      Indices, mid, range - (mid - left));
  }
#line 256
  return (res | tmp___0);
}
}
#line 352 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/BwtSort.c"
UInt32 BlockSort(UInt32 *Indices , Byte const   *data , UInt32 blockSize ) 
{ 
  UInt32 *counters ;
  UInt32 i ;
  UInt32 *Groups ;
  UInt32 sum ;
  UInt32 groupSize ;
  UInt32 tmp ;
  UInt32 tmp___0 ;
  UInt32 prev ;
  UInt32 prevGroupSize ;
  int NumRefBits ;
  UInt32 NumSortedBytes ;
  UInt32 finishedGroupSize ;
  UInt32 newLimit ;
  UInt32 groupSize___0 ;
  Bool finishedGroup ;
  UInt32 newGroupSize ;
  UInt32 j ;
  UInt32 t ;
  UInt32 tmp___1 ;
  UInt32 groupSize___1 ;

  {
#line 354
  counters = Indices + blockSize;
#line 362
  i = (UInt32 )0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i < (UInt32 )(1 << 16))) {
#line 362
      goto while_break;
    }
#line 363
    *(counters + i) = (UInt32 )0;
#line 362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  i = (UInt32 )0;
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 364
    if (! (i < blockSize - 1U)) {
#line 364
      goto while_break___0;
    }
#line 365
    (*(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + (i + 1U))))) ++;
#line 364
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 366
  (*(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + 0)))) ++;
#line 368
  Groups = counters + (1 << 16);
#line 379
  sum = (UInt32 )0;
#line 380
  i = (UInt32 )0;
  {
#line 380
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 380
    if (! (i < (UInt32 )(1 << 16))) {
#line 380
      goto while_break___1;
    }
#line 382
    groupSize = *(counters + i);
#line 383
    if (groupSize > 0U) {
#line 389
      sum += groupSize;
    }
#line 391
    *(counters + i) = sum - groupSize;
#line 380
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 394
  i = (UInt32 )0;
  {
#line 394
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 394
    if (! (i < blockSize - 1U)) {
#line 394
      goto while_break___2;
    }
#line 395
    *(Groups + i) = *(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + (i + 1U))));
#line 394
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 396
  *(Groups + i) = *(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + 0)));
#line 398
  i = (UInt32 )0;
  {
#line 398
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 398
    if (! (i < blockSize - 1U)) {
#line 398
      goto while_break___3;
    }
#line 399
    tmp = *(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + (i + 1U))));
#line 399
    (*(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + (i + 1U))))) ++;
#line 399
    *(Indices + tmp) = i;
#line 398
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 400
  tmp___0 = *(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + 0)));
#line 400
  (*(counters + (((UInt32 )*(data + i) << 8) | (unsigned int )*(data + 0)))) ++;
#line 400
  *(Indices + tmp___0) = i;
#line 404
  prev = (UInt32 )0;
#line 405
  i = (UInt32 )0;
  {
#line 405
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 405
    if (! (i < (UInt32 )(1 << 16))) {
#line 405
      goto while_break___4;
    }
#line 407
    prevGroupSize = *(counters + i) - prev;
#line 408
    if (prevGroupSize == 0U) {
#line 409
      goto __Cont;
    }
    {
#line 410
    SetGroupSize(Indices + prev, prevGroupSize);
#line 411
    prev = *(counters + i);
    }
    __Cont: /* CIL Label */ 
#line 405
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 420
  NumRefBits = 0;
  {
#line 420
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 420
    if (! ((blockSize - 1U) >> NumRefBits != 0U)) {
#line 420
      goto while_break___5;
    }
#line 420
    NumRefBits ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 421
  NumRefBits = 32 - NumRefBits;
#line 422
  if (NumRefBits > 12) {
#line 423
    NumRefBits = 12;
  }
#line 425
  NumSortedBytes = (UInt32 )2;
  {
#line 425
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 428
    finishedGroupSize = (UInt32 )0;
#line 430
    newLimit = (UInt32 )0;
#line 431
    i = (UInt32 )0;
    {
#line 431
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 431
      if (! (i < blockSize)) {
#line 431
        goto while_break___7;
      }
#line 449
      groupSize___0 = (*(Indices + i) & 1073741823U) >> 20;
#line 451
      finishedGroup = (*(Indices + i) & 2147483648U) == 0U;
#line 452
      if ((*(Indices + i) & 1073741824U) != 0U) {
#line 454
        groupSize___0 += (*(Indices + (i + 1U)) >> 20) << 10;
#line 455
        *(Indices + (i + 1U)) &= (unsigned int )((1 << 20) - 1);
      }
#line 457
      *(Indices + i) &= (unsigned int )((1 << 20) - 1);
#line 458
      groupSize___0 ++;
#line 459
      if (finishedGroup) {
#line 459
        goto _L;
      } else
#line 459
      if (groupSize___0 == 1U) {
        _L: /* CIL Label */ 
#line 461
        *(Indices + (i - finishedGroupSize)) &= (unsigned int )((1 << 20) - 1);
#line 462
        if (finishedGroupSize > 1U) {
#line 463
          *(Indices + ((i - finishedGroupSize) + 1U)) &= (unsigned int )((1 << 20) - 1);
        }
#line 465
        newGroupSize = groupSize___0 + finishedGroupSize;
#line 466
        *((Indices + i) - finishedGroupSize) |= ((newGroupSize - 1U) & (unsigned int )((1 << 10) - 1)) << 20;
#line 466
        if (newGroupSize > (UInt32 )(1 << 10)) {
#line 466
          *((Indices + i) - finishedGroupSize) |= 1073741824U;
#line 466
          *(((Indices + i) - finishedGroupSize) + 1) |= ((newGroupSize - 1U) >> 10) << 20;
        }
#line 467
        finishedGroupSize = newGroupSize;
#line 469
        i += groupSize___0;
#line 470
        goto __Cont___0;
      }
#line 472
      finishedGroupSize = (UInt32 )0;
#line 477
      if (NumSortedBytes >= blockSize) {
#line 480
        j = (UInt32 )0;
        {
#line 480
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 480
          if (! (j < groupSize___0)) {
#line 480
            goto while_break___8;
          }
#line 482
          t = i + j;
#line 484
          *(Groups + *(Indices + t)) = t;
#line 480
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      } else {
        {
#line 488
        tmp___1 = SortGroup(blockSize, NumSortedBytes, i, groupSize___0, NumRefBits,
                            Indices, (UInt32 )0, blockSize);
        }
#line 488
        if (tmp___1 != 0U) {
#line 493
          newLimit = i + groupSize___0;
        }
      }
#line 494
      i += groupSize___0;
      __Cont___0: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 496
    if (newLimit == 0U) {
#line 497
      goto while_break___6;
    }
#line 425
    NumSortedBytes <<= 1;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 501
  i = (UInt32 )0;
  {
#line 501
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 501
    if (! (i < blockSize)) {
#line 501
      goto while_break___9;
    }
#line 503
    groupSize___1 = (*(Indices + i) & 1073741823U) >> 20;
#line 504
    if ((*(Indices + i) & 1073741824U) != 0U) {
#line 506
      groupSize___1 += (*(Indices + (i + 1U)) >> 20) << 10;
#line 507
      *(Indices + (i + 1U)) &= (unsigned int )((1 << 20) - 1);
    }
#line 509
    *(Indices + i) &= (unsigned int )((1 << 20) - 1);
#line 510
    groupSize___1 ++;
#line 511
    i += groupSize___1;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 514
  return (*(Groups + 0));
}
}
#line 10 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrcOpt.c"
UInt32 CrcUpdateT4(UInt32 v , void const   *data , size_t size , UInt32 const   *table ) 
{ 
  Byte const   *p ;

  {
#line 12
  p = (Byte const   *)data;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (size > 0UL) {
#line 13
      if (! (((unsigned int )((ptrdiff_t )p) & 3U) != 0U)) {
#line 13
        goto while_break;
      }
    } else {
#line 13
      goto while_break;
    }
#line 14
    v = (UInt32 )(*(table + ((v ^ (unsigned int )*p) & 255U)) ^ (unsigned int const   )(v >> 8));
#line 13
    size --;
#line 13
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 15
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 15
    if (! (size >= 4UL)) {
#line 15
      goto while_break___0;
    }
#line 17
    v ^= (unsigned int )*((UInt32 const   *)p);
#line 18
    v = (UInt32 )(((*(table + (768U + (v & 255U))) ^ *(table + (512U + ((v >> 8) & 255U)))) ^ *(table + (256U + ((v >> 16) & 255U)))) ^ *(table + (v >> 24)));
#line 15
    size -= 4UL;
#line 15
    p += 4;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 24
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 24
    if (! (size > 0UL)) {
#line 24
      goto while_break___1;
    }
#line 25
    v = (UInt32 )(*(table + ((v ^ (unsigned int )*p) & 255U)) ^ (unsigned int const   )(v >> 8));
#line 24
    size --;
#line 24
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 26
  return (v);
}
}
#line 29 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrcOpt.c"
UInt32 CrcUpdateT8(UInt32 v , void const   *data , size_t size , UInt32 const   *table ) 
{ 
  UInt32 tmp ;

  {
  {
#line 31
  tmp = CrcUpdateT4(v, data, size, table);
  }
#line 31
  return (tmp);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 84 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
void Ppmd8_Construct(CPpmd8 *p ) ;
#line 85
Bool Ppmd8_Alloc(CPpmd8 *p , UInt32 size , ISzAlloc *alloc ) ;
#line 86
void Ppmd8_Free(CPpmd8 *p , ISzAlloc *alloc ) ;
#line 87
void Ppmd8_Init(CPpmd8 *p , unsigned int maxOrder , unsigned int restoreMethod ) ;
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
Byte const   PPMD8_kExpEscape[16]  = 
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
  {      (Byte const   )25,      (Byte const   )14,      (Byte const   )9,      (Byte const   )7, 
        (Byte const   )5,      (Byte const   )5,      (Byte const   )4,      (Byte const   )4, 
        (Byte const   )4,      (Byte const   )3,      (Byte const   )3,      (Byte const   )3, 
        (Byte const   )2,      (Byte const   )2,      (Byte const   )2,      (Byte const   )2};
#line 10 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static UInt16 const   kInitBinEsc[8]  = 
#line 10
  {      (UInt16 const   )15581,      (UInt16 const   )7999,      (UInt16 const   )22975,      (UInt16 const   )18675, 
        (UInt16 const   )25761,      (UInt16 const   )23228,      (UInt16 const   )26162,      (UInt16 const   )24657};
#line 59 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
void Ppmd8_Construct(CPpmd8 *p ) 
{ 
  unsigned int i ;
  unsigned int k ;
  unsigned int m ;
  unsigned int step ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 63
  p->Base = (Byte *)0;
#line 65
  i = 0U;
#line 65
  k = 0U;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < 38U)) {
#line 65
      goto while_break;
    }
#line 67
    if (i >= 12U) {
#line 67
      tmp = 4U;
    } else {
#line 67
      tmp = (i >> 2) + 1U;
    }
#line 67
    step = tmp;
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 68
      tmp___0 = k;
#line 68
      k ++;
#line 68
      p->Units2Indx[tmp___0] = (Byte )i;
#line 68
      step --;
#line 68
      if (! step) {
#line 68
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 69
    p->Indx2Units[i] = (Byte )k;
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  p->NS2BSIndx[0] = (Byte )0;
#line 73
  p->NS2BSIndx[1] = (Byte )(1 << 1);
#line 74
  memset((void *)(p->NS2BSIndx + 2), 2 << 1, (size_t )9);
#line 75
  memset((void *)(p->NS2BSIndx + 11), 3 << 1, (size_t )245);
#line 77
  i = 0U;
  }
  {
#line 77
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 77
    if (! (i < 5U)) {
#line 77
      goto while_break___1;
    }
#line 78
    p->NS2Indx[i] = (Byte )i;
#line 77
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 79
  m = i;
#line 79
  k = 1U;
  {
#line 79
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 79
    if (! (i < 260U)) {
#line 79
      goto while_break___2;
    }
#line 81
    p->NS2Indx[i] = (Byte )m;
#line 82
    k --;
#line 82
    if (k == 0U) {
#line 83
      m ++;
#line 83
      k = m - 4U;
    }
#line 79
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
void Ppmd8_Free(CPpmd8 *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 89
  (*(alloc->Free))((void *)alloc, (void *)p->Base);
#line 90
  p->Size = (UInt32 )0;
#line 91
  p->Base = (Byte *)0;
  }
#line 92
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
Bool Ppmd8_Alloc(CPpmd8 *p , UInt32 size , ISzAlloc *alloc ) 
{ 
  Byte *tmp ;
  void *tmp___0 ;

  {
#line 96
  if ((unsigned long )p->Base == (unsigned long )((Byte *)0)) {
#line 96
    goto _L;
  } else
#line 96
  if (p->Size != size) {
    _L: /* CIL Label */ 
    {
#line 98
    Ppmd8_Free(p, alloc);
#line 99
    p->AlignOffset = 4U - (size & 3U);
#line 105
    tmp___0 = (*(alloc->Alloc))((void *)alloc, (size_t )(p->AlignOffset + size));
#line 105
    tmp = (Byte *)tmp___0;
#line 105
    p->Base = tmp;
    }
#line 105
    if ((unsigned long )tmp == (unsigned long )((Byte *)0)) {
#line 106
      return (0);
    }
#line 107
    p->Size = size;
  }
#line 109
  return (1);
}
}
#line 112 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void InsertNode(CPpmd8 *p , void *node , unsigned int indx ) 
{ 


  {
#line 114
  ((CPpmd8_Node *)node)->Stamp = 4294967295U;
#line 115
  ((CPpmd8_Node *)node)->Next = p->FreeList[indx];
#line 116
  ((CPpmd8_Node *)node)->NU = (UInt32 )p->Indx2Units[indx];
#line 117
  p->FreeList[indx] = (UInt32 )((Byte *)node - p->Base);
#line 118
  (p->Stamps[indx]) ++;
#line 119
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void *RemoveNode(CPpmd8 *p , unsigned int indx ) 
{ 
  CPpmd8_Node *node ;

  {
#line 123
  node = (CPpmd8_Node *)(p->Base + p->FreeList[indx]);
#line 124
  p->FreeList[indx] = node->Next;
#line 125
  (p->Stamps[indx]) --;
#line 126
  return ((void *)node);
}
}
#line 129 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void SplitBlock(CPpmd8 *p , void *ptr , unsigned int oldIndx , unsigned int newIndx ) 
{ 
  unsigned int i ;
  unsigned int nu ;
  unsigned int k ;

  {
#line 131
  nu = (unsigned int )((int )p->Indx2Units[oldIndx] - (int )p->Indx2Units[newIndx]);
#line 132
  ptr = (void *)((Byte *)ptr + (UInt32 )p->Indx2Units[newIndx] * 12U);
#line 133
  i = (unsigned int )p->Units2Indx[nu - 1U];
#line 133
  if ((unsigned int )p->Indx2Units[i] != nu) {
    {
#line 135
    i --;
#line 135
    k = (unsigned int )p->Indx2Units[i];
#line 136
    InsertNode(p, (void *)((Byte *)ptr + k * 12U), (nu - k) - 1U);
    }
  }
  {
#line 138
  InsertNode(p, ptr, i);
  }
#line 139
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void GlueFreeBlocks(CPpmd8 *p ) 
{ 
  CPpmd8_Node_Ref head ;
  CPpmd8_Node_Ref *prev ;
  unsigned int i ;
  CPpmd8_Node_Ref next ;
  CPpmd8_Node *node ;
  CPpmd8_Node *node2 ;
  CPpmd8_Node *node___0 ;
  unsigned int nu ;
  unsigned int k ;

  {
  {
#line 143
  head = (CPpmd8_Node_Ref )0;
#line 144
  prev = & head;
#line 147
  p->GlueCount = (UInt32 )(1 << 13);
#line 148
  memset((void *)(p->Stamps), 0, sizeof(p->Stamps));
  }
#line 152
  if ((unsigned long )p->LoUnit != (unsigned long )p->HiUnit) {
#line 153
    ((CPpmd8_Node *)p->LoUnit)->Stamp = (UInt32 )0;
  }
#line 156
  i = 0U;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < 38U)) {
#line 156
      goto while_break;
    }
#line 158
    next = p->FreeList[i];
#line 159
    p->FreeList[i] = (CPpmd_Void_Ref )0;
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (! (next != 0U)) {
#line 160
        goto while_break___0;
      }
#line 162
      node = (CPpmd8_Node *)(p->Base + next);
#line 163
      if (node->NU != 0U) {
#line 166
        *prev = next;
#line 167
        prev = & node->Next;
        {
#line 168
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 168
          node2 = node + node->NU;
#line 168
          if (! (node2->Stamp == 4294967295U)) {
#line 168
            goto while_break___1;
          }
#line 170
          node->NU += node2->NU;
#line 171
          node2->NU = (UInt32 )0;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 174
      next = node->Next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  *prev = (CPpmd8_Node_Ref )0;
  {
#line 180
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 180
    if (! (head != 0U)) {
#line 180
      goto while_break___2;
    }
#line 182
    node___0 = (CPpmd8_Node *)(p->Base + head);
#line 184
    head = node___0->Next;
#line 185
    nu = node___0->NU;
#line 186
    if (nu == 0U) {
#line 187
      goto while_continue___2;
    }
    {
#line 188
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 188
      if (! (nu > 128U)) {
#line 188
        goto while_break___3;
      }
      {
#line 189
      InsertNode(p, (void *)node___0, 37U);
#line 188
      nu -= 128U;
#line 188
      node___0 += 128;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 190
    i = (unsigned int )p->Units2Indx[nu - 1U];
#line 190
    if ((unsigned int )p->Indx2Units[i] != nu) {
      {
#line 192
      i --;
#line 192
      k = (unsigned int )p->Indx2Units[i];
#line 193
      InsertNode(p, (void *)(node___0 + k), (nu - k) - 1U);
      }
    }
    {
#line 195
    InsertNode(p, (void *)node___0, i);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void *AllocUnitsRare(CPpmd8 *p , unsigned int indx ) 
{ 
  unsigned int i ;
  void *retVal ;
  void *tmp ;
  UInt32 numBytes ;
  Byte *tmp___0 ;
  Byte *tmp___1 ;

  {
#line 203
  if (p->GlueCount == 0U) {
    {
#line 205
    GlueFreeBlocks(p);
    }
#line 206
    if (p->FreeList[indx] != 0U) {
      {
#line 207
      tmp = RemoveNode(p, indx);
      }
#line 207
      return (tmp);
    }
  }
#line 209
  i = indx;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    i ++;
#line 212
    if (i == 38U) {
#line 214
      numBytes = (UInt32 )p->Indx2Units[indx] * 12U;
#line 215
      (p->GlueCount) --;
#line 216
      if ((UInt32 )(p->UnitsStart - p->Text) > numBytes) {
#line 216
        tmp___0 = p->UnitsStart - numBytes;
#line 216
        p->UnitsStart = tmp___0;
#line 216
        tmp___1 = tmp___0;
      } else {
#line 216
        tmp___1 = (Byte *)((void *)0);
      }
#line 216
      return ((void *)tmp___1);
    }
#line 210
    if (! (p->FreeList[i] == 0U)) {
#line 210
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  retVal = RemoveNode(p, i);
#line 221
  SplitBlock(p, retVal, i, indx);
  }
#line 222
  return (retVal);
}
}
#line 225 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void *AllocUnits(CPpmd8 *p , unsigned int indx ) 
{ 
  UInt32 numBytes ;
  void *tmp ;
  void *retVal ;
  void *tmp___0 ;

  {
#line 228
  if (p->FreeList[indx] != 0U) {
    {
#line 229
    tmp = RemoveNode(p, indx);
    }
#line 229
    return (tmp);
  }
#line 230
  numBytes = (UInt32 )p->Indx2Units[indx] * 12U;
#line 231
  if (numBytes <= (UInt32 )(p->HiUnit - p->LoUnit)) {
#line 233
    retVal = (void *)p->LoUnit;
#line 234
    p->LoUnit += numBytes;
#line 235
    return (retVal);
  }
  {
#line 237
  tmp___0 = AllocUnitsRare(p, indx);
  }
#line 237
  return (tmp___0);
}
}
#line 244 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void *ShrinkUnits(CPpmd8 *p , void *oldPtr , unsigned int oldNU , unsigned int newNU ) 
{ 
  unsigned int i0 ;
  unsigned int i1 ;
  void *ptr ;
  void *tmp ;
  UInt32 *d ;
  UInt32 const   *s ;
  UInt32 n ;

  {
#line 246
  i0 = (unsigned int )p->Units2Indx[oldNU - 1U];
#line 247
  i1 = (unsigned int )p->Units2Indx[newNU - 1U];
#line 248
  if (i0 == i1) {
#line 249
    return (oldPtr);
  }
#line 250
  if (p->FreeList[i1] != 0U) {
    {
#line 252
    tmp = RemoveNode(p, i1);
#line 252
    ptr = tmp;
#line 253
    d = (UInt32 *)ptr;
#line 253
    s = (UInt32 const   *)oldPtr;
#line 253
    n = newNU;
    }
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      *(d + 0) = (UInt32 )*(s + 0);
#line 253
      *(d + 1) = (UInt32 )*(s + 1);
#line 253
      *(d + 2) = (UInt32 )*(s + 2);
#line 253
      s += 3;
#line 253
      d += 3;
#line 253
      n --;
#line 253
      if (! n) {
#line 253
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 254
    InsertNode(p, oldPtr, i0);
    }
#line 255
    return (ptr);
  }
  {
#line 257
  SplitBlock(p, oldPtr, i0, i1);
  }
#line 258
  return (oldPtr);
}
}
#line 261 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void FreeUnits(CPpmd8 *p , void *ptr , unsigned int nu ) 
{ 


  {
  {
#line 263
  InsertNode(p, ptr, (unsigned int )p->Units2Indx[nu - 1U]);
  }
#line 264
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void SpecialFreeUnit(CPpmd8 *p , void *ptr ) 
{ 


  {
#line 268
  if ((unsigned long )((Byte *)ptr) != (unsigned long )p->UnitsStart) {
    {
#line 269
    InsertNode(p, ptr, 0U);
    }
  } else {
#line 275
    p->UnitsStart += 12;
  }
#line 277
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void *MoveUnitsUp(CPpmd8 *p , void *oldPtr , unsigned int nu ) 
{ 
  unsigned int indx ;
  void *ptr ;
  UInt32 *d ;
  UInt32 const   *s ;
  UInt32 n ;

  {
#line 281
  indx = (unsigned int )p->Units2Indx[nu - 1U];
#line 283
  if ((unsigned long )((Byte *)oldPtr) > (unsigned long )(p->UnitsStart + 16384)) {
#line 284
    return (oldPtr);
  } else
#line 283
  if ((UInt32 )((Byte *)oldPtr - p->Base) > p->FreeList[indx]) {
#line 284
    return (oldPtr);
  }
  {
#line 285
  ptr = RemoveNode(p, indx);
#line 286
  d = (UInt32 *)ptr;
#line 286
  s = (UInt32 const   *)oldPtr;
#line 286
  n = nu;
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    *(d + 0) = (UInt32 )*(s + 0);
#line 286
    *(d + 1) = (UInt32 )*(s + 1);
#line 286
    *(d + 2) = (UInt32 )*(s + 2);
#line 286
    s += 3;
#line 286
    d += 3;
#line 286
    n --;
#line 286
    if (! n) {
#line 286
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  if ((unsigned long )((Byte *)oldPtr) != (unsigned long )p->UnitsStart) {
    {
#line 288
    InsertNode(p, oldPtr, indx);
    }
  } else {
#line 290
    p->UnitsStart += (UInt32 )p->Indx2Units[indx] * 12U;
  }
#line 291
  return (ptr);
}
}
#line 294 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void ExpandTextArea(CPpmd8 *p ) 
{ 
  UInt32 count[38] ;
  unsigned int i ;
  CPpmd8_Node *node ;
  CPpmd8_Node_Ref *next ;
  CPpmd8_Node *node___0 ;

  {
  {
#line 298
  memset((void *)(count), 0, sizeof(count));
  }
#line 299
  if ((unsigned long )p->LoUnit != (unsigned long )p->HiUnit) {
#line 300
    ((CPpmd8_Node *)p->LoUnit)->Stamp = (UInt32 )0;
  }
#line 303
  node = (CPpmd8_Node *)p->UnitsStart;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (node->Stamp == 4294967295U)) {
#line 304
      goto while_break;
    }
#line 306
    node->Stamp = (UInt32 )0;
#line 307
    (count[p->Units2Indx[node->NU - 1U]]) ++;
#line 304
    node += node->NU;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  p->UnitsStart = (Byte *)node;
#line 312
  i = 0U;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! (i < 38U)) {
#line 312
      goto while_break___0;
    }
#line 314
    next = & p->FreeList[i];
    {
#line 315
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 315
      if (! (count[i] != 0U)) {
#line 315
        goto while_break___1;
      }
#line 317
      node___0 = (CPpmd8_Node *)(p->Base + *next);
      {
#line 318
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 318
        if (! (node___0->Stamp == 0U)) {
#line 318
          goto while_break___2;
        }
#line 320
        *next = node___0->Next;
#line 321
        node___0 = (CPpmd8_Node *)(p->Base + *next);
#line 322
        (p->Stamps[i]) --;
#line 323
        (count[i]) --;
#line 323
        if (count[i] == 0U) {
#line 324
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 326
      next = & node___0->Next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 312
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 329
  return;
}
}
#line 333 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void SetSuccessor(CPpmd_State *p , CPpmd_Void_Ref v ) 
{ 


  {
#line 335
  p->SuccessorLow = (UInt16 )(v & 65535U);
#line 336
  p->SuccessorHigh = (UInt16 )((v >> 16) & 65535U);
#line 337
  return;
}
}
#line 341 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void RestartModel(CPpmd8 *p ) 
{ 
  unsigned int i ;
  unsigned int k ;
  unsigned int m ;
  unsigned int r ;
  Byte *tmp ;
  Int32 tmp___0 ;
  unsigned int tmp___1 ;
  CPpmd8_Context *tmp___2 ;
  Byte *tmp___3 ;
  CPpmd_State *s ;
  UInt16 val ;
  UInt16 *dest ;
  CPpmd_See *s___0 ;
  Byte tmp___4 ;

  {
  {
#line 345
  memset((void *)(p->FreeList), 0, sizeof(p->FreeList));
#line 346
  memset((void *)(p->Stamps), 0, sizeof(p->Stamps));
#line 347
  p->Text = (p->Base + p->AlignOffset) + 0;
#line 348
  p->HiUnit = p->Text + p->Size;
#line 349
  tmp = p->HiUnit - (((p->Size / 8U) / 12U) * 7U) * 12U;
#line 349
  p->UnitsStart = tmp;
#line 349
  p->LoUnit = tmp;
#line 350
  p->GlueCount = (UInt32 )0;
#line 352
  p->OrderFall = p->MaxOrder;
  }
#line 353
  if (p->MaxOrder < 12U) {
#line 353
    tmp___1 = p->MaxOrder;
  } else {
#line 353
    tmp___1 = 12U;
  }
#line 353
  tmp___0 = - ((Int32 )tmp___1) - 1;
#line 353
  p->InitRL = tmp___0;
#line 353
  p->RunLength = tmp___0;
#line 354
  p->PrevSuccess = 0U;
#line 356
  tmp___3 = p->HiUnit - 12;
#line 356
  p->HiUnit = tmp___3;
#line 356
  tmp___2 = (CTX_PTR )tmp___3;
#line 356
  p->MaxContext = tmp___2;
#line 356
  p->MinContext = tmp___2;
#line 357
  (p->MinContext)->Suffix = (CPpmd8_Context_Ref )0;
#line 358
  (p->MinContext)->NumStats = (Byte )255;
#line 359
  (p->MinContext)->Flags = (Byte )0;
#line 360
  (p->MinContext)->SummFreq = (UInt16 )257;
#line 361
  p->FoundState = (CPpmd_State *)p->LoUnit;
#line 362
  p->LoUnit += 1536U;
#line 363
  (p->MinContext)->Stats = (UInt32 )((Byte *)p->FoundState - p->Base);
#line 364
  i = 0U;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (i < 256U)) {
#line 364
      goto while_break;
    }
    {
#line 366
    s = p->FoundState + i;
#line 367
    s->Symbol = (Byte )i;
#line 368
    s->Freq = (Byte )1;
#line 369
    SetSuccessor(s, (CPpmd_Void_Ref )0);
#line 364
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  m = 0U;
#line 372
  i = m;
  {
#line 372
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 372
    if (! (m < 25U)) {
#line 372
      goto while_break___0;
    }
    {
#line 374
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 374
      if (! ((unsigned int )p->NS2Indx[i] == m)) {
#line 374
        goto while_break___1;
      }
#line 375
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 376
    k = 0U;
    {
#line 376
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 376
      if (! (k < 8U)) {
#line 376
        goto while_break___2;
      }
#line 378
      val = (UInt16 )((unsigned int )(1 << 14) - (unsigned int )kInitBinEsc[k] / (i + 1U));
#line 379
      dest = p->BinSumm[m] + k;
#line 380
      r = 0U;
      {
#line 380
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 380
        if (! (r < 64U)) {
#line 380
          goto while_break___3;
        }
#line 381
        *(dest + r) = val;
#line 380
        r += 8U;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 376
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 372
    m ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 385
  m = 0U;
#line 385
  i = m;
  {
#line 385
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 385
    if (! (m < 24U)) {
#line 385
      goto while_break___4;
    }
    {
#line 387
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 387
      if (! ((unsigned int )p->NS2Indx[i + 3U] == m + 3U)) {
#line 387
        goto while_break___5;
      }
#line 388
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 389
    k = 0U;
    {
#line 389
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 389
      if (! (k < 32U)) {
#line 389
        goto while_break___6;
      }
#line 391
      s___0 = & p->See[m][k];
#line 392
      tmp___4 = (Byte )3;
#line 392
      s___0->Shift = tmp___4;
#line 392
      s___0->Summ = (UInt16 )((2U * i + 5U) << (int )tmp___4);
#line 393
      s___0->Count = (Byte )7;
#line 389
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 385
    m ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 396
  return;
}
}
#line 398 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
void Ppmd8_Init(CPpmd8 *p , unsigned int maxOrder , unsigned int restoreMethod ) 
{ 


  {
  {
#line 400
  p->MaxOrder = maxOrder;
#line 401
  p->RestoreMethod = restoreMethod;
#line 402
  RestartModel(p);
#line 403
  p->DummySee.Shift = (Byte )7;
#line 404
  p->DummySee.Summ = (UInt16 )0;
#line 405
  p->DummySee.Count = (Byte )64;
  }
#line 406
  return;
}
}
#line 408 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void Refresh(CPpmd8 *p , CTX_PTR ctx , unsigned int oldNU , unsigned int scale ) 
{ 
  unsigned int i ;
  unsigned int escFreq ;
  unsigned int sumFreq ;
  unsigned int flags ;
  CPpmd_State *s ;
  void *tmp ;
  Byte tmp___0 ;
  Byte tmp___1 ;

  {
  {
#line 410
  i = (unsigned int )ctx->NumStats;
#line 411
  tmp = ShrinkUnits(p, (void *)((CPpmd_State *)((void *)(p->Base + ctx->Stats))),
                    oldNU, (i + 2U) >> 1);
#line 411
  s = (CPpmd_State *)tmp;
#line 412
  ctx->Stats = (UInt32 )((Byte *)s - p->Base);
#line 417
  flags = ((unsigned int )ctx->Flags & (16U + 4U * scale)) + (unsigned int )(8 * ((int )s->Symbol >= 64));
#line 418
  escFreq = (unsigned int )((int )ctx->SummFreq - (int )s->Freq);
#line 419
  tmp___0 = (Byte )(((unsigned int )s->Freq + scale) >> scale);
#line 419
  s->Freq = tmp___0;
#line 419
  sumFreq = (unsigned int )tmp___0;
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    s ++;
#line 422
    escFreq -= (unsigned int )s->Freq;
#line 423
    tmp___1 = (Byte )(((unsigned int )s->Freq + scale) >> scale);
#line 423
    s->Freq = tmp___1;
#line 423
    sumFreq += (unsigned int )tmp___1;
#line 424
    flags |= (unsigned int )(8 * ((int )s->Symbol >= 64));
#line 420
    i --;
#line 420
    if (! i) {
#line 420
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  ctx->SummFreq = (UInt16 )(sumFreq + ((escFreq + scale) >> scale));
#line 428
  ctx->Flags = (Byte )flags;
#line 429
  return;
}
}
#line 431 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void SwapStates(CPpmd_State *t1 , CPpmd_State *t2 ) 
{ 
  CPpmd_State tmp ;

  {
#line 433
  tmp = *t1;
#line 434
  *t1 = *t2;
#line 435
  *t2 = tmp;
#line 436
  return;
}
}
#line 438 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static CPpmd_Void_Ref CutOff(CPpmd8 *p , CTX_PTR ctx , unsigned int order ) 
{ 
  int i ;
  unsigned int tmp ;
  CPpmd_State *s ;
  CPpmd_Void_Ref tmp___0 ;
  void *tmp___1 ;
  CPpmd_State *s2 ;
  int tmp___2 ;
  CPpmd_Void_Ref tmp___3 ;

  {
#line 444
  if (! ctx->NumStats) {
#line 446
    s = (CPpmd_State *)(& ctx->SummFreq);
#line 447
    if ((unsigned long )((Byte *)((void *)(p->Base + ((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16))))) >= (unsigned long )p->UnitsStart) {
#line 449
      if (order < p->MaxOrder) {
        {
#line 450
        tmp___0 = CutOff(p, (CPpmd8_Context *)((void *)(p->Base + ((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16)))),
                         order + 1U);
#line 450
        SetSuccessor(s, tmp___0);
        }
      } else {
        {
#line 452
        SetSuccessor(s, (CPpmd_Void_Ref )0);
        }
      }
#line 453
      if ((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16)) {
#line 454
        return ((UInt32 )((Byte *)ctx - p->Base));
      } else
#line 453
      if (order <= 9U) {
#line 454
        return ((UInt32 )((Byte *)ctx - p->Base));
      }
    }
    {
#line 456
    SpecialFreeUnit(p, (void *)ctx);
    }
#line 457
    return ((CPpmd_Void_Ref )0);
  }
  {
#line 460
  tmp = ((unsigned int )ctx->NumStats + 2U) >> 1;
#line 460
  tmp___1 = MoveUnitsUp(p, (void *)((CPpmd_State *)((void *)(p->Base + ctx->Stats))),
                        tmp);
#line 460
  ctx->Stats = (UInt32 )((Byte *)tmp___1 - p->Base);
#line 462
  i = (int )ctx->NumStats;
#line 462
  s = (CPpmd_State *)((void *)(p->Base + ctx->Stats)) + i;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! ((unsigned long )s >= (unsigned long )((CPpmd_State *)((void *)(p->Base + ctx->Stats))))) {
#line 462
      goto while_break;
    }
#line 463
    if ((unsigned long )((Byte *)((void *)(p->Base + ((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16))))) < (unsigned long )p->UnitsStart) {
      {
#line 465
      tmp___2 = i;
#line 465
      i --;
#line 465
      s2 = (CPpmd_State *)((void *)(p->Base + ctx->Stats)) + tmp___2;
#line 466
      SetSuccessor(s, (CPpmd_Void_Ref )0);
#line 467
      SwapStates(s, s2);
      }
    } else
#line 469
    if (order < p->MaxOrder) {
      {
#line 470
      tmp___3 = CutOff(p, (CPpmd8_Context *)((void *)(p->Base + ((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16)))),
                       order + 1U);
#line 470
      SetSuccessor(s, tmp___3);
      }
    } else {
      {
#line 472
      SetSuccessor(s, (CPpmd_Void_Ref )0);
      }
    }
#line 462
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  if (i != (int )ctx->NumStats) {
#line 474
    if (order) {
#line 476
      ctx->NumStats = (Byte )i;
#line 477
      s = (CPpmd_State *)((void *)(p->Base + ctx->Stats));
#line 478
      if (i < 0) {
        {
#line 480
        FreeUnits(p, (void *)s, tmp);
#line 481
        SpecialFreeUnit(p, (void *)ctx);
        }
#line 482
        return ((CPpmd_Void_Ref )0);
      }
#line 484
      if (i == 0) {
        {
#line 486
        ctx->Flags = (Byte )(((int )ctx->Flags & 16) + 8 * ((int )s->Symbol >= 64));
#line 487
        *((CPpmd_State *)(& ctx->SummFreq)) = *s;
#line 488
        FreeUnits(p, (void *)s, tmp);
#line 489
        ((CPpmd_State *)(& ctx->SummFreq))->Freq = (Byte )((int )((Byte )((unsigned int )((CPpmd_State *)(& ctx->SummFreq))->Freq + 11U)) >> 3);
        }
      } else {
        {
#line 492
        Refresh(p, ctx, tmp, (unsigned int )((int )ctx->SummFreq > 16 * i));
        }
      }
    }
  }
#line 494
  return ((UInt32 )((Byte *)ctx - p->Base));
}
}
#line 529 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static UInt32 GetUsedMemory(CPpmd8 const   *p ) 
{ 
  UInt32 v ;
  unsigned int i ;

  {
#line 531
  v = (UInt32 )0;
#line 533
  i = 0U;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (i < 38U)) {
#line 533
      goto while_break;
    }
#line 534
    v += p->Stamps[i] * (UInt32 )p->Indx2Units[i];
#line 533
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  return ((UInt32 )(((p->Size - (UInt32 const   )((UInt32 )(p->HiUnit - p->LoUnit))) - (UInt32 const   )((UInt32 )(p->UnitsStart - p->Text))) - (UInt32 const   )(v * 12U)));
}
}
#line 544 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void RestoreModel(CPpmd8 *p , CTX_PTR c1 ) 
{ 
  CTX_PTR c ;
  CPpmd_State *s ;
  UInt16 tmp ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;

  {
#line 552
  p->Text = (p->Base + p->AlignOffset) + 0;
#line 553
  c = p->MaxContext;
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! ((unsigned long )c != (unsigned long )c1)) {
#line 553
      goto while_break;
    }
#line 554
    c->NumStats = (Byte )((int )c->NumStats - 1);
#line 554
    if ((int )c->NumStats == 0) {
      {
#line 556
      s = (CPpmd_State *)((void *)(p->Base + c->Stats));
#line 557
      c->Flags = (Byte )(((int )c->Flags & 16) + 8 * ((int )s->Symbol >= 64));
#line 558
      *((CPpmd_State *)(& c->SummFreq)) = *s;
#line 559
      SpecialFreeUnit(p, (void *)s);
#line 560
      ((CPpmd_State *)(& c->SummFreq))->Freq = (Byte )(((int )((CPpmd_State *)(& c->SummFreq))->Freq + 11) >> 3);
      }
    } else {
      {
#line 563
      Refresh(p, c, (unsigned int )(((int )c->NumStats + 3) >> 1), 0U);
      }
    }
#line 553
    c = (CPpmd8_Context *)((void *)(p->Base + c->Suffix));
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 565
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 565
    if (! ((unsigned long )c != (unsigned long )p->MinContext)) {
#line 565
      goto while_break___0;
    }
#line 566
    if (! c->NumStats) {
#line 567
      ((CPpmd_State *)(& c->SummFreq))->Freq = (Byte )((int )((CPpmd_State *)(& c->SummFreq))->Freq - ((int )((CPpmd_State *)(& c->SummFreq))->Freq >> 1));
    } else {
#line 568
      tmp = (UInt16 )((int )c->SummFreq + 4);
#line 568
      c->SummFreq = tmp;
#line 568
      if ((int )tmp > 128 + 4 * (int )c->NumStats) {
        {
#line 569
        Refresh(p, c, (unsigned int )(((int )c->NumStats + 2) >> 1), 1U);
        }
      }
    }
#line 565
    c = (CPpmd8_Context *)((void *)(p->Base + c->Suffix));
  }
  while_break___0: /* CIL Label */ ;
  }
#line 588
  if (p->RestoreMethod == 0U) {
    {
#line 589
    RestartModel(p);
    }
  } else {
    {
#line 588
    tmp___1 = GetUsedMemory((CPpmd8 const   *)p);
    }
#line 588
    if (tmp___1 < p->Size >> 1) {
      {
#line 589
      RestartModel(p);
      }
    } else {
      {
#line 592
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 592
        if (! (p->MaxContext)->Suffix) {
#line 592
          goto while_break___1;
        }
#line 593
        p->MaxContext = (CPpmd8_Context *)((void *)(p->Base + (p->MaxContext)->Suffix));
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 594
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 596
        CutOff(p, p->MaxContext, 0U);
#line 597
        ExpandTextArea(p);
#line 594
        tmp___0 = GetUsedMemory((CPpmd8 const   *)p);
        }
#line 594
        if (! (tmp___0 > 3U * (p->Size >> 2))) {
#line 594
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 600
      p->GlueCount = (UInt32 )0;
#line 601
      p->OrderFall = p->MaxOrder;
    }
  }
#line 603
  return;
}
}
#line 605 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static CTX_PTR CreateSuccessors(CPpmd8 *p , Bool skip , CPpmd_State *s1 , CTX_PTR c ) 
{ 
  CPpmd_State upState ;
  Byte flags ;
  CPpmd_Byte_Ref upBranch ;
  CPpmd_State *ps[17] ;
  unsigned int numPs ;
  unsigned int tmp ;
  CPpmd_Void_Ref successor ;
  CPpmd_State *s ;
  unsigned int tmp___0 ;
  UInt32 cf ;
  UInt32 s0 ;
  CPpmd_State *s___0 ;
  UInt32 tmp___1 ;
  CTX_PTR c1 ;
  Byte *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 609
  upBranch = (unsigned int )(p->FoundState)->SuccessorLow | ((UInt32 )(p->FoundState)->SuccessorHigh << 16);
#line 612
  numPs = 0U;
#line 614
  if (! skip) {
#line 615
    tmp = numPs;
#line 615
    numPs ++;
#line 615
    ps[tmp] = p->FoundState;
  }
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! c->Suffix) {
#line 617
      goto while_break;
    }
#line 621
    c = (CPpmd8_Context *)((void *)(p->Base + c->Suffix));
#line 622
    if (s1) {
#line 624
      s = s1;
#line 625
      s1 = (CPpmd_State *)((void *)0);
    } else
#line 627
    if ((int )c->NumStats != 0) {
#line 629
      s = (CPpmd_State *)((void *)(p->Base + c->Stats));
      {
#line 629
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 629
        if (! ((int )s->Symbol != (int )(p->FoundState)->Symbol)) {
#line 629
          goto while_break___0;
        }
#line 629
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 630
      if ((int )s->Freq < 115) {
#line 632
        s->Freq = (Byte )((int )s->Freq + 1);
#line 633
        c->SummFreq = (UInt16 )((int )c->SummFreq + 1);
      }
    } else {
#line 638
      s = (CPpmd_State *)(& c->SummFreq);
#line 639
      s->Freq = (Byte )((int )s->Freq + (! ((CPpmd8_Context *)((void *)(p->Base + c->Suffix)))->NumStats & ((int )s->Freq < 24)));
    }
#line 641
    successor = (unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16);
#line 642
    if (successor != upBranch) {
#line 644
      c = (CPpmd8_Context *)((void *)(p->Base + successor));
#line 645
      if (numPs == 0U) {
#line 646
        return (c);
      }
#line 647
      goto while_break;
    }
#line 649
    tmp___0 = numPs;
#line 649
    numPs ++;
#line 649
    ps[tmp___0] = s;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 652
  upState.Symbol = (Byte )*((Byte const   *)((void *)(p->Base + upBranch)));
#line 653
  SetSuccessor(& upState, upBranch + 1U);
#line 654
  flags = (Byte )(16 * ((int )(p->FoundState)->Symbol >= 64) + 8 * ((int )upState.Symbol >= 64));
  }
#line 656
  if ((int )c->NumStats == 0) {
#line 657
    upState.Freq = ((CPpmd_State *)(& c->SummFreq))->Freq;
  } else {
#line 662
    s___0 = (CPpmd_State *)((void *)(p->Base + c->Stats));
    {
#line 662
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 662
      if (! ((int )s___0->Symbol != (int )upState.Symbol)) {
#line 662
        goto while_break___1;
      }
#line 662
      s___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 663
    cf = (UInt32 )((int )s___0->Freq - 1);
#line 664
    s0 = (UInt32 )((int )c->SummFreq - (int )c->NumStats) - cf;
#line 665
    if (2U * cf <= s0) {
#line 665
      tmp___1 = (UInt32 )(5U * cf > s0);
    } else {
#line 665
      tmp___1 = ((cf + 2U * s0) - 3U) / s0;
    }
#line 665
    upState.Freq = (Byte )(1U + tmp___1);
  }
  {
#line 668
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 672
    if ((unsigned long )p->HiUnit != (unsigned long )p->LoUnit) {
#line 673
      tmp___2 = p->HiUnit - 12;
#line 673
      p->HiUnit = tmp___2;
#line 673
      c1 = (CTX_PTR )tmp___2;
    } else
#line 674
    if (p->FreeList[0] != 0U) {
      {
#line 675
      tmp___3 = RemoveNode(p, 0U);
#line 675
      c1 = (CTX_PTR )tmp___3;
      }
    } else {
      {
#line 678
      tmp___4 = AllocUnitsRare(p, 0U);
#line 678
      c1 = (CTX_PTR )tmp___4;
      }
#line 679
      if (! c1) {
#line 680
        return ((CTX_PTR )((void *)0));
      }
    }
    {
#line 682
    c1->NumStats = (Byte )0;
#line 683
    c1->Flags = flags;
#line 684
    *((CPpmd_State *)(& c1->SummFreq)) = upState;
#line 685
    c1->Suffix = (UInt32 )((Byte *)c - p->Base);
#line 686
    numPs --;
#line 686
    SetSuccessor(ps[numPs], (UInt32 )((Byte *)c1 - p->Base));
#line 687
    c = c1;
    }
#line 668
    if (! (numPs != 0U)) {
#line 668
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 691
  return (c);
}
}
#line 694 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static CTX_PTR ReduceOrder(CPpmd8 *p , CPpmd_State *s1 , CTX_PTR c ) 
{ 
  CPpmd_State *s ;
  CTX_PTR c1 ;
  CPpmd_Void_Ref upBranch ;
  CTX_PTR successor ;
  CPpmd_State *s1___0 ;

  {
  {
#line 696
  s = (CPpmd_State *)((void *)0);
#line 697
  c1 = c;
#line 698
  upBranch = (UInt32 )(p->Text - p->Base);
#line 707
  SetSuccessor(p->FoundState, upBranch);
#line 708
  (p->OrderFall) ++;
  }
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (s1) {
#line 714
      c = (CPpmd8_Context *)((void *)(p->Base + c->Suffix));
#line 715
      s = s1;
#line 716
      s1 = (CPpmd_State *)((void *)0);
    } else {
#line 720
      if (! c->Suffix) {
#line 730
        return (c);
      }
#line 732
      c = (CPpmd8_Context *)((void *)(p->Base + c->Suffix));
#line 733
      if (c->NumStats) {
#line 735
        s = (CPpmd_State *)((void *)(p->Base + c->Stats));
#line 735
        if ((int )s->Symbol != (int )(p->FoundState)->Symbol) {
          {
#line 736
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 736
            s ++;
#line 736
            if (! ((int )s->Symbol != (int )(p->FoundState)->Symbol)) {
#line 736
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 737
        if ((int )s->Freq < 115) {
#line 739
          s->Freq = (Byte )((int )s->Freq + 2);
#line 740
          c->SummFreq = (UInt16 )((int )c->SummFreq + 2);
        }
      } else {
#line 745
        s = (CPpmd_State *)(& c->SummFreq);
#line 746
        s->Freq = (Byte )((int )s->Freq + ((int )s->Freq < 32));
      }
    }
#line 749
    if ((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16)) {
#line 750
      goto while_break;
    }
    {
#line 754
    SetSuccessor(s, upBranch);
#line 755
    (p->OrderFall) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  if (((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16)) <= upBranch) {
    {
#line 772
    s1___0 = p->FoundState;
#line 773
    p->FoundState = s;
#line 775
    successor = CreateSuccessors(p, 0, (CPpmd_State *)((void *)0), c);
    }
#line 776
    if ((unsigned long )successor == (unsigned long )((void *)0)) {
      {
#line 777
      SetSuccessor(s, (CPpmd_Void_Ref )0);
      }
    } else {
      {
#line 779
      SetSuccessor(s, (UInt32 )((Byte *)successor - p->Base));
      }
    }
#line 780
    p->FoundState = s1___0;
  }
#line 783
  if (p->OrderFall == 1U) {
#line 783
    if ((unsigned long )c1 == (unsigned long )p->MaxContext) {
      {
#line 785
      SetSuccessor(p->FoundState, (unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16));
#line 786
      (p->Text) --;
      }
    }
  }
#line 788
  if (((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16)) == 0U) {
#line 789
    return ((CTX_PTR )((void *)0));
  }
#line 790
  return ((CPpmd8_Context *)((void *)(p->Base + ((unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16)))));
}
}
#line 793 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void UpdateModel(CPpmd8 *p ) 
{ 
  CPpmd_Void_Ref successor ;
  CPpmd_Void_Ref fSuccessor ;
  CTX_PTR c ;
  unsigned int s0 ;
  unsigned int ns ;
  unsigned int fFreq ;
  Byte flag ;
  Byte fSymbol ;
  CPpmd_State *s ;
  CTX_PTR cs ;
  CTX_PTR tmp ;
  Byte *tmp___0 ;
  CTX_PTR cs___0 ;
  CTX_PTR tmp___1 ;
  CTX_PTR cs___1 ;
  CTX_PTR tmp___2 ;
  unsigned int ns1 ;
  UInt32 cf ;
  UInt32 sf ;
  unsigned int oldNU ;
  unsigned int i ;
  void *ptr ;
  void *tmp___3 ;
  void *oldPtr ;
  UInt32 *d ;
  UInt32 const   *s___0 ;
  UInt32 n ;
  CPpmd_State *s___1 ;
  void *tmp___4 ;
  CPpmd_State *s___2 ;
  CPpmd8_Context *tmp___5 ;

  {
#line 795
  fSuccessor = (unsigned int )(p->FoundState)->SuccessorLow | ((UInt32 )(p->FoundState)->SuccessorHigh << 16);
#line 797
  fFreq = (unsigned int )(p->FoundState)->Freq;
#line 798
  fSymbol = (p->FoundState)->Symbol;
#line 799
  s = (CPpmd_State *)((void *)0);
#line 801
  if ((int )(p->FoundState)->Freq < 31) {
#line 801
    if ((p->MinContext)->Suffix != 0U) {
#line 803
      c = (CPpmd8_Context *)((void *)(p->Base + (p->MinContext)->Suffix));
#line 805
      if ((int )c->NumStats == 0) {
#line 807
        s = (CPpmd_State *)(& c->SummFreq);
#line 808
        if ((int )s->Freq < 32) {
#line 809
          s->Freq = (Byte )((int )s->Freq + 1);
        }
      } else {
#line 813
        s = (CPpmd_State *)((void *)(p->Base + c->Stats));
#line 814
        if ((int )s->Symbol != (int )(p->FoundState)->Symbol) {
          {
#line 816
          while (1) {
            while_continue: /* CIL Label */ ;
#line 816
            s ++;
#line 816
            if (! ((int )s->Symbol != (int )(p->FoundState)->Symbol)) {
#line 816
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 817
          if ((int )(s + 0)->Freq >= (int )(s + -1)->Freq) {
            {
#line 819
            SwapStates(s + 0, s + -1);
#line 820
            s --;
            }
          }
        }
#line 823
        if ((int )s->Freq < 115) {
#line 825
          s->Freq = (Byte )((int )s->Freq + 2);
#line 826
          c->SummFreq = (UInt16 )((int )c->SummFreq + 2);
        }
      }
    }
  }
#line 831
  c = p->MaxContext;
#line 832
  if (p->OrderFall == 0U) {
#line 832
    if (fSuccessor) {
      {
#line 834
      tmp = CreateSuccessors(p, 1, s, p->MinContext);
#line 834
      cs = tmp;
      }
#line 835
      if ((unsigned long )cs == (unsigned long )((CTX_PTR )0)) {
        {
#line 837
        SetSuccessor(p->FoundState, (CPpmd_Void_Ref )0);
#line 838
        RestoreModel(p, c);
        }
      } else {
        {
#line 842
        SetSuccessor(p->FoundState, (UInt32 )((Byte *)cs - p->Base));
#line 843
        p->MaxContext = cs;
        }
      }
#line 845
      return;
    }
  }
#line 848
  tmp___0 = p->Text;
#line 848
  (p->Text) ++;
#line 848
  *tmp___0 = (p->FoundState)->Symbol;
#line 849
  successor = (UInt32 )(p->Text - p->Base);
#line 850
  if ((unsigned long )p->Text >= (unsigned long )p->UnitsStart) {
    {
#line 852
    RestoreModel(p, c);
    }
#line 853
    return;
  }
#line 856
  if (! fSuccessor) {
    {
#line 858
    tmp___1 = ReduceOrder(p, s, p->MinContext);
#line 858
    cs___0 = tmp___1;
    }
#line 859
    if ((unsigned long )cs___0 == (unsigned long )((void *)0)) {
      {
#line 861
      RestoreModel(p, c);
      }
#line 862
      return;
    }
#line 864
    fSuccessor = (UInt32 )((Byte *)cs___0 - p->Base);
  } else
#line 866
  if ((unsigned long )((Byte *)((void *)(p->Base + fSuccessor))) < (unsigned long )p->UnitsStart) {
    {
#line 868
    tmp___2 = CreateSuccessors(p, 0, s, p->MinContext);
#line 868
    cs___1 = tmp___2;
    }
#line 869
    if ((unsigned long )cs___1 == (unsigned long )((void *)0)) {
      {
#line 871
      RestoreModel(p, c);
      }
#line 872
      return;
    }
#line 874
    fSuccessor = (UInt32 )((Byte *)cs___1 - p->Base);
  }
#line 877
  (p->OrderFall) --;
#line 877
  if (p->OrderFall == 0U) {
#line 879
    successor = fSuccessor;
#line 880
    p->Text -= (unsigned long )p->MaxContext != (unsigned long )p->MinContext;
  }
#line 891
  ns = (unsigned int )(p->MinContext)->NumStats;
#line 891
  s0 = ((unsigned int )(p->MinContext)->SummFreq - ns) - fFreq;
#line 892
  flag = (Byte )(8 * ((int )fSymbol >= 64));
  {
#line 894
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 894
    if (! ((unsigned long )c != (unsigned long )p->MinContext)) {
#line 894
      goto while_break___0;
    }
#line 898
    ns1 = (unsigned int )c->NumStats;
#line 898
    if (ns1 != 0U) {
#line 900
      if ((ns1 & 1U) != 0U) {
#line 903
        oldNU = (ns1 + 1U) >> 1;
#line 904
        i = (unsigned int )p->Units2Indx[oldNU - 1U];
#line 905
        if (i != (unsigned int )p->Units2Indx[(oldNU + 1U) - 1U]) {
          {
#line 907
          tmp___3 = AllocUnits(p, i + 1U);
#line 907
          ptr = tmp___3;
          }
#line 909
          if (! ptr) {
            {
#line 911
            RestoreModel(p, c);
            }
#line 912
            return;
          }
#line 914
          oldPtr = (void *)((CPpmd_State *)((void *)(p->Base + c->Stats)));
#line 915
          d = (UInt32 *)ptr;
#line 915
          s___0 = (UInt32 const   *)oldPtr;
#line 915
          n = oldNU;
          {
#line 915
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 915
            *(d + 0) = (UInt32 )*(s___0 + 0);
#line 915
            *(d + 1) = (UInt32 )*(s___0 + 1);
#line 915
            *(d + 2) = (UInt32 )*(s___0 + 2);
#line 915
            s___0 += 3;
#line 915
            d += 3;
#line 915
            n --;
#line 915
            if (! n) {
#line 915
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 916
          InsertNode(p, oldPtr, i);
#line 917
          c->Stats = (UInt32 )((Byte *)ptr - p->Base);
          }
        }
      }
#line 920
      c->SummFreq = (UInt16 )((int )c->SummFreq + (3U * ns1 + 1U < ns));
    } else {
      {
#line 924
      tmp___4 = AllocUnits(p, 0U);
#line 924
      s___1 = (CPpmd_State *)tmp___4;
      }
#line 925
      if (! s___1) {
        {
#line 927
        RestoreModel(p, c);
        }
#line 928
        return;
      }
#line 930
      *s___1 = *((CPpmd_State *)(& c->SummFreq));
#line 931
      c->Stats = (UInt32 )((Byte *)s___1 - p->Base);
#line 932
      if ((int )s___1->Freq < 30) {
#line 933
        s___1->Freq = (Byte )((int )s___1->Freq << 1);
      } else {
#line 935
        s___1->Freq = (Byte )120;
      }
#line 936
      c->SummFreq = (UInt16 )(((unsigned int )s___1->Freq + p->InitEsc) + (unsigned int )(ns > 2U));
    }
#line 938
    cf = (2U * fFreq) * (unsigned int )((int )c->SummFreq + 6);
#line 939
    sf = s0 + (UInt32 )c->SummFreq;
#line 940
    if (cf < 6U * sf) {
#line 942
      cf = (UInt32 )((1 + (cf > sf)) + (cf >= 4U * sf));
#line 943
      c->SummFreq = (UInt16 )((int )c->SummFreq + 4);
    } else {
#line 947
      cf = (UInt32 )(((4 + (cf > 9U * sf)) + (cf > 12U * sf)) + (cf > 15U * sf));
#line 948
      c->SummFreq = (UInt16 )((UInt32 )c->SummFreq + cf);
    }
    {
#line 951
    s___2 = ((CPpmd_State *)((void *)(p->Base + c->Stats)) + ns1) + 1;
#line 952
    SetSuccessor(s___2, successor);
#line 953
    s___2->Symbol = fSymbol;
#line 954
    s___2->Freq = (Byte )cf;
#line 955
    c->Flags = (Byte )((int )c->Flags | (int )flag);
#line 956
    c->NumStats = (Byte )(ns1 + 1U);
#line 894
    c = (CPpmd8_Context *)((void *)(p->Base + c->Suffix));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 959
  tmp___5 = (CPpmd8_Context *)((void *)(p->Base + fSuccessor));
#line 959
  p->MinContext = tmp___5;
#line 959
  p->MaxContext = tmp___5;
#line 960
  return;
}
}
#line 962 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void Rescale(CPpmd8 *p ) 
{ 
  unsigned int i ;
  unsigned int adder ;
  unsigned int sumFreq ;
  unsigned int escFreq ;
  CPpmd_State *stats ;
  CPpmd_State *s ;
  CPpmd_State tmp ;
  CPpmd_State *s1 ;
  CPpmd_State tmp___0 ;
  unsigned int numStats ;
  unsigned int n0 ;
  unsigned int n1 ;
  CPpmd_State tmp___1 ;
  CPpmd_State *tmp___2 ;
  void *tmp___3 ;

  {
#line 965
  stats = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 966
  s = p->FoundState;
#line 968
  tmp = *s;
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if (! ((unsigned long )s != (unsigned long )stats)) {
#line 969
      goto while_break;
    }
#line 970
    *(s + 0) = *(s + -1);
#line 969
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  *s = tmp;
#line 973
  escFreq = (unsigned int )((int )(p->MinContext)->SummFreq - (int )s->Freq);
#line 974
  s->Freq = (Byte )((int )s->Freq + 4);
#line 975
  adder = (unsigned int )(p->OrderFall != 0U);
#line 980
  s->Freq = (Byte )(((unsigned int )s->Freq + adder) >> 1);
#line 981
  sumFreq = (unsigned int )s->Freq;
#line 983
  i = (unsigned int )(p->MinContext)->NumStats;
  {
#line 984
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 986
    s ++;
#line 986
    escFreq -= (unsigned int )s->Freq;
#line 987
    s->Freq = (Byte )(((unsigned int )s->Freq + adder) >> 1);
#line 988
    sumFreq += (unsigned int )s->Freq;
#line 989
    if ((int )(s + 0)->Freq > (int )(s + -1)->Freq) {
#line 991
      s1 = s;
#line 992
      tmp___0 = *s1;
      {
#line 993
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 994
        *(s1 + 0) = *(s1 + -1);
#line 993
        s1 --;
#line 993
        if ((unsigned long )s1 != (unsigned long )stats) {
#line 993
          if (! ((int )tmp___0.Freq > (int )(s1 + -1)->Freq)) {
#line 993
            goto while_break___1;
          }
        } else {
#line 993
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 996
      *s1 = tmp___0;
    }
#line 984
    i --;
#line 984
    if (! i) {
#line 984
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1001
  if ((int )s->Freq == 0) {
#line 1003
    numStats = (unsigned int )(p->MinContext)->NumStats;
    {
#line 1005
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1005
      i ++;
#line 1005
      s --;
#line 1005
      if (! ((int )s->Freq == 0)) {
#line 1005
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1006
    escFreq += i;
#line 1007
    (p->MinContext)->NumStats = (Byte )((unsigned int )(p->MinContext)->NumStats - i);
#line 1008
    if ((int )(p->MinContext)->NumStats == 0) {
#line 1010
      tmp___1 = *stats;
#line 1011
      tmp___1.Freq = (Byte )((((unsigned int )(2 * (int )tmp___1.Freq) + escFreq) - 1U) / escFreq);
#line 1012
      if ((int )tmp___1.Freq > 41) {
#line 1013
        tmp___1.Freq = (Byte )41;
      }
      {
#line 1014
      InsertNode(p, (void *)stats, (unsigned int )p->Units2Indx[((numStats + 2U) >> 1) - 1U]);
#line 1015
      (p->MinContext)->Flags = (Byte )(((int )(p->MinContext)->Flags & 16) + 8 * ((int )tmp___1.Symbol >= 64));
#line 1016
      tmp___2 = (CPpmd_State *)(& (p->MinContext)->SummFreq);
#line 1016
      p->FoundState = tmp___2;
#line 1016
      *tmp___2 = tmp___1;
      }
#line 1017
      return;
    }
#line 1019
    n0 = (numStats + 2U) >> 1;
#line 1020
    n1 = (unsigned int )(((int )(p->MinContext)->NumStats + 2) >> 1);
#line 1021
    if (n0 != n1) {
      {
#line 1022
      tmp___3 = ShrinkUnits(p, (void *)stats, n0, n1);
#line 1022
      (p->MinContext)->Stats = (UInt32 )((Byte *)tmp___3 - p->Base);
      }
    }
#line 1023
    (p->MinContext)->Flags = (Byte )((int )(p->MinContext)->Flags & -9);
#line 1024
    s = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 1024
    (p->MinContext)->Flags = (Byte )((int )(p->MinContext)->Flags | 8 * ((int )s->Symbol >= 64));
#line 1025
    i = (unsigned int )(p->MinContext)->NumStats;
    {
#line 1026
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1026
      s ++;
#line 1026
      (p->MinContext)->Flags = (Byte )((int )(p->MinContext)->Flags | 8 * ((int )s->Symbol >= 64));
#line 1026
      i --;
#line 1026
      if (! i) {
#line 1026
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1028
  (p->MinContext)->SummFreq = (UInt16 )((sumFreq + escFreq) - (escFreq >> 1));
#line 1029
  (p->MinContext)->Flags = (Byte )((int )(p->MinContext)->Flags | 4);
#line 1030
  p->FoundState = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 1031
  return;
}
}
#line 1033 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
CPpmd_See *Ppmd8_MakeEscFreq(CPpmd8 *p , unsigned int numMasked1 , UInt32 *escFreq ) 
{ 
  CPpmd_See *see ;
  unsigned int r ;

  {
#line 1036
  if ((int )(p->MinContext)->NumStats != 255) {
#line 1038
    see = ((p->See[(int )p->NS2Indx[(int )(p->MinContext)->NumStats + 2] - 3] + ((unsigned int )(p->MinContext)->SummFreq > 11U * ((unsigned int )(p->MinContext)->NumStats + 1U))) + 2 * (2U * (unsigned int )(p->MinContext)->NumStats < (unsigned int )((CPpmd8_Context *)((void *)(p->Base + (p->MinContext)->Suffix)))->NumStats + numMasked1)) + (int )(p->MinContext)->Flags;
#line 1044
    r = (unsigned int )((int )see->Summ >> (int )see->Shift);
#line 1045
    see->Summ = (UInt16 )((unsigned int )see->Summ - r);
#line 1046
    *escFreq = r + (unsigned int )(r == 0U);
  } else {
#line 1051
    see = & p->DummySee;
#line 1052
    *escFreq = (UInt32 )1;
  }
#line 1054
  return (see);
}
}
#line 1057 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
static void NextContext(CPpmd8 *p ) 
{ 
  CTX_PTR c ;
  CPpmd8_Context *tmp ;

  {
#line 1059
  c = (CPpmd8_Context *)((void *)(p->Base + ((unsigned int )(p->FoundState)->SuccessorLow | ((UInt32 )(p->FoundState)->SuccessorHigh << 16))));
#line 1060
  if (p->OrderFall == 0U) {
#line 1060
    if ((unsigned long )((Byte *)c) >= (unsigned long )p->UnitsStart) {
#line 1061
      tmp = c;
#line 1061
      p->MaxContext = tmp;
#line 1061
      p->MinContext = tmp;
    } else {
      {
#line 1064
      UpdateModel(p);
#line 1065
      p->MinContext = p->MaxContext;
      }
    }
  } else {
    {
#line 1064
    UpdateModel(p);
#line 1065
    p->MinContext = p->MaxContext;
    }
  }
#line 1067
  return;
}
}
#line 1069 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
void Ppmd8_Update1(CPpmd8 *p ) 
{ 
  CPpmd_State *s ;

  {
#line 1071
  s = p->FoundState;
#line 1072
  s->Freq = (Byte )((int )s->Freq + 4);
#line 1073
  (p->MinContext)->SummFreq = (UInt16 )((int )(p->MinContext)->SummFreq + 4);
#line 1074
  if ((int )(s + 0)->Freq > (int )(s + -1)->Freq) {
    {
#line 1076
    SwapStates(s + 0, s + -1);
#line 1077
    s --;
#line 1077
    p->FoundState = s;
    }
#line 1078
    if ((int )s->Freq > 124) {
      {
#line 1079
      Rescale(p);
      }
    }
  }
  {
#line 1081
  NextContext(p);
  }
#line 1082
  return;
}
}
#line 1084 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
void Ppmd8_Update1_0(CPpmd8 *p ) 
{ 
  Byte tmp ;

  {
#line 1086
  p->PrevSuccess = (unsigned int )(2 * (int )(p->FoundState)->Freq >= (int )(p->MinContext)->SummFreq);
#line 1087
  p->RunLength = (Int32 )((unsigned int )p->RunLength + p->PrevSuccess);
#line 1088
  (p->MinContext)->SummFreq = (UInt16 )((int )(p->MinContext)->SummFreq + 4);
#line 1089
  tmp = (Byte )((int )(p->FoundState)->Freq + 4);
#line 1089
  (p->FoundState)->Freq = tmp;
#line 1089
  if ((int )tmp > 124) {
    {
#line 1090
    Rescale(p);
    }
  }
  {
#line 1091
  NextContext(p);
  }
#line 1092
  return;
}
}
#line 1094 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
void Ppmd8_UpdateBin(CPpmd8 *p ) 
{ 


  {
  {
#line 1096
  (p->FoundState)->Freq = (Byte )((int )(p->FoundState)->Freq + ((int )(p->FoundState)->Freq < 196));
#line 1097
  p->PrevSuccess = 1U;
#line 1098
  (p->RunLength) ++;
#line 1099
  NextContext(p);
  }
#line 1100
  return;
}
}
#line 1102 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.c"
void Ppmd8_Update2(CPpmd8 *p ) 
{ 
  Byte tmp ;

  {
#line 1104
  (p->MinContext)->SummFreq = (UInt16 )((int )(p->MinContext)->SummFreq + 4);
#line 1105
  tmp = (Byte )((int )(p->FoundState)->Freq + 4);
#line 1105
  (p->FoundState)->Freq = tmp;
#line 1105
  if ((int )tmp > 124) {
    {
#line 1106
    Rescale(p);
    }
  }
  {
#line 1107
  p->RunLength = p->InitRL;
#line 1108
  UpdateModel(p);
#line 1109
  p->MinContext = p->MaxContext;
  }
#line 1110
  return;
}
}
#line 8 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MtSync_Construct(CMtSync *p ) 
{ 


  {
#line 10
  p->wasCreated = 0;
#line 11
  p->csWasInitialized = 0;
#line 12
  p->csWasEntered = 0;
#line 13
  p->thread._created = 0;
#line 14
  p->canStart._created = 0;
#line 15
  p->wasStarted._created = 0;
#line 16
  p->wasStopped._created = 0;
#line 17
  p->freeSemaphore._created = 0;
#line 18
  p->filledSemaphore._created = 0;
#line 19
  return;
}
}
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MtSync_GetNextBlock(CMtSync *p ) 
{ 


  {
#line 23
  if (p->needStart) {
    {
#line 25
    p->numProcessedBlocks = (UInt32 )1;
#line 26
    p->needStart = 0;
#line 27
    p->stopWriting = 0;
#line 28
    p->exit = 0;
#line 29
    Event_Reset(& p->wasStarted);
#line 30
    Event_Reset(& p->wasStopped);
#line 32
    Event_Set(& p->canStart);
#line 33
    Event_Wait(& p->wasStarted);
    }
  } else {
    {
#line 37
    pthread_mutex_unlock(& p->cs._mutex);
#line 38
    p->csWasEntered = 0;
#line 39
    (p->numProcessedBlocks) ++;
#line 40
    Semaphore_ReleaseN(& p->freeSemaphore, (UInt32 )1);
    }
  }
  {
#line 42
  Semaphore_Wait(& p->filledSemaphore);
#line 43
  pthread_mutex_lock(& p->cs._mutex);
#line 44
  p->csWasEntered = 1;
  }
#line 45
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MtSync_StopWriting(CMtSync *p ) 
{ 
  UInt32 myNumBlocks ;
  UInt32 tmp ;

  {
#line 51
  myNumBlocks = p->numProcessedBlocks;
#line 52
  if (! (p->thread._created != 0)) {
#line 53
    return;
  } else
#line 52
  if (p->needStart) {
#line 53
    return;
  }
#line 54
  p->stopWriting = 1;
#line 55
  if (p->csWasEntered) {
    {
#line 57
    pthread_mutex_unlock(& p->cs._mutex);
#line 58
    p->csWasEntered = 0;
    }
  }
  {
#line 60
  Semaphore_ReleaseN(& p->freeSemaphore, (UInt32 )1);
#line 62
  Event_Wait(& p->wasStopped);
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    tmp = myNumBlocks;
#line 64
    myNumBlocks ++;
#line 64
    if (! (tmp != p->numProcessedBlocks)) {
#line 64
      goto while_break;
    }
    {
#line 66
    Semaphore_Wait(& p->filledSemaphore);
#line 67
    Semaphore_ReleaseN(& p->freeSemaphore, (UInt32 )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  p->needStart = 1;
#line 70
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MtSync_Destruct(CMtSync *p ) 
{ 


  {
#line 74
  if (p->thread._created != 0) {
    {
#line 76
    MtSync_StopWriting(p);
#line 77
    p->exit = 1;
    }
#line 78
    if (p->needStart) {
      {
#line 79
      Event_Set(& p->canStart);
      }
    }
    {
#line 80
    Thread_Wait(& p->thread);
#line 81
    Thread_Close(& p->thread);
    }
  }
#line 83
  if (p->csWasInitialized) {
    {
#line 85
    pthread_mutex_destroy(& p->cs._mutex);
#line 86
    p->csWasInitialized = 0;
    }
  }
  {
#line 89
  Event_Close(& p->canStart);
#line 90
  Event_Close(& p->wasStarted);
#line 91
  Event_Close(& p->wasStopped);
#line 92
  Semaphore_Close(& p->freeSemaphore);
#line 93
  Semaphore_Close(& p->filledSemaphore);
#line 95
  p->wasCreated = 0;
  }
#line 96
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static SRes MtSync_Create2(CMtSync *p , unsigned int (*startAddress)(void * ) , void *obj ,
                           UInt32 numBlocks ) 
{ 
  WRes tmp ;
  WRes tmp___0 ;
  WRes tmp___1 ;
  WRes tmp___2 ;
  WRes tmp___3 ;
  WRes tmp___4 ;
  WRes tmp___5 ;

  {
#line 102
  if (p->wasCreated) {
#line 103
    return (0);
  }
  {
#line 105
  tmp = CriticalSection_Init(& p->cs);
  }
#line 105
  if (tmp != 0) {
#line 105
    return (12);
  }
  {
#line 106
  p->csWasInitialized = 1;
#line 108
  tmp___0 = AutoResetEvent_CreateNotSignaled(& p->canStart);
  }
#line 108
  if (tmp___0 != 0) {
#line 108
    return (12);
  }
  {
#line 109
  tmp___1 = AutoResetEvent_CreateNotSignaled(& p->wasStarted);
  }
#line 109
  if (tmp___1 != 0) {
#line 109
    return (12);
  }
  {
#line 110
  tmp___2 = AutoResetEvent_CreateNotSignaled(& p->wasStopped);
  }
#line 110
  if (tmp___2 != 0) {
#line 110
    return (12);
  }
  {
#line 112
  tmp___3 = Semaphore_Create(& p->freeSemaphore, numBlocks, numBlocks);
  }
#line 112
  if (tmp___3 != 0) {
#line 112
    return (12);
  }
  {
#line 113
  tmp___4 = Semaphore_Create(& p->filledSemaphore, (UInt32 )0, numBlocks);
  }
#line 113
  if (tmp___4 != 0) {
#line 113
    return (12);
  }
  {
#line 115
  p->needStart = 1;
#line 117
  tmp___5 = Thread_Create(& p->thread, startAddress, obj);
  }
#line 117
  if (tmp___5 != 0) {
#line 117
    return (12);
  }
#line 118
  p->wasCreated = 1;
#line 119
  return (0);
}
}
#line 122 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static SRes MtSync_Create(CMtSync *p , unsigned int (*startAddress)(void * ) , void *obj ,
                          UInt32 numBlocks ) 
{ 
  SRes res ;
  SRes tmp ;

  {
  {
#line 124
  tmp = MtSync_Create2(p, startAddress, obj, numBlocks);
#line 124
  res = tmp;
  }
#line 125
  if (res != 0) {
    {
#line 126
    MtSync_Destruct(p);
    }
  }
#line 127
  return (res);
}
}
#line 130 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MtSync_Init(CMtSync *p ) 
{ 


  {
#line 130
  p->needStart = 1;
#line 130
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static void GetHeads2(Byte const   *p , UInt32 pos , UInt32 *hash , UInt32 hashMask ,
                      UInt32 *heads , UInt32 numHeads , UInt32 const   *crc ) 
{ 
  UInt32 value ;
  UInt32 *tmp ;
  UInt32 tmp___0 ;

  {
#line 142
  hashMask = hashMask;
#line 142
  crc = crc;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (numHeads != 0U)) {
#line 142
      goto while_break;
    }
#line 142
    value = (unsigned int )*(p + 0) | ((UInt32 )*(p + 1) << 8);
#line 142
    p ++;
#line 142
    tmp = heads;
#line 142
    heads ++;
#line 142
    *tmp = pos - *(hash + value);
#line 142
    tmp___0 = pos;
#line 142
    pos ++;
#line 142
    *(hash + value) = tmp___0;
#line 142
    numHeads --;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static void GetHeads3(Byte const   *p , UInt32 pos , UInt32 *hash , UInt32 hashMask ,
                      UInt32 *heads , UInt32 numHeads , UInt32 const   *crc ) 
{ 
  UInt32 value ;
  UInt32 *tmp ;
  UInt32 tmp___0 ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (numHeads != 0U)) {
#line 143
      goto while_break;
    }
#line 143
    value = (UInt32 )(((*(crc + *(p + 0)) ^ (unsigned int const   )*(p + 1)) ^ (unsigned int const   )((UInt32 )*(p + 2) << 8)) & (unsigned int const   )hashMask);
#line 143
    p ++;
#line 143
    tmp = heads;
#line 143
    heads ++;
#line 143
    *tmp = pos - *(hash + value);
#line 143
    tmp___0 = pos;
#line 143
    pos ++;
#line 143
    *(hash + value) = tmp___0;
#line 143
    numHeads --;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static void GetHeads4(Byte const   *p , UInt32 pos , UInt32 *hash , UInt32 hashMask ,
                      UInt32 *heads , UInt32 numHeads , UInt32 const   *crc ) 
{ 
  UInt32 value ;
  UInt32 *tmp ;
  UInt32 tmp___0 ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (numHeads != 0U)) {
#line 144
      goto while_break;
    }
#line 144
    value = (UInt32 )((((*(crc + *(p + 0)) ^ (unsigned int const   )*(p + 1)) ^ (unsigned int const   )((UInt32 )*(p + 2) << 8)) ^ (*(crc + *(p + 3)) << 5)) & (unsigned int const   )hashMask);
#line 144
    p ++;
#line 144
    tmp = heads;
#line 144
    heads ++;
#line 144
    *tmp = pos - *(hash + value);
#line 144
    tmp___0 = pos;
#line 144
    pos ++;
#line 144
    *(hash + value) = tmp___0;
#line 144
    numHeads --;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 145 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static void GetHeads4b(Byte const   *p , UInt32 pos , UInt32 *hash , UInt32 hashMask ,
                       UInt32 *heads , UInt32 numHeads , UInt32 const   *crc ) 
{ 
  UInt32 value ;
  UInt32 *tmp ;
  UInt32 tmp___0 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (numHeads != 0U)) {
#line 145
      goto while_break;
    }
#line 145
    value = (UInt32 )((((*(crc + *(p + 0)) ^ (unsigned int const   )*(p + 1)) ^ (unsigned int const   )((UInt32 )*(p + 2) << 8)) ^ (unsigned int const   )((UInt32 )*(p + 3) << 16)) & (unsigned int const   )hashMask);
#line 145
    p ++;
#line 145
    tmp = heads;
#line 145
    heads ++;
#line 145
    *tmp = pos - *(hash + value);
#line 145
    tmp___0 = pos;
#line 145
    pos ++;
#line 145
    *(hash + value) = tmp___0;
#line 145
    numHeads --;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 148 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void HashThreadFunc(CMatchFinderMt *mt ) 
{ 
  CMtSync *p ;
  UInt32 numProcessedBlocks ;
  CMatchFinder *mf ;
  Byte const   *beforePtr ;
  Byte *tmp ;
  Byte const   *afterPtr ;
  Byte *tmp___0 ;
  int tmp___1 ;
  UInt32 subValue ;
  UInt32 *heads ;
  UInt32 tmp___2 ;
  UInt32 num ;

  {
#line 150
  p = & mt->hashSync;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    numProcessedBlocks = (UInt32 )0;
#line 154
    Event_Wait(& p->canStart);
#line 155
    Event_Set(& p->wasStarted);
    }
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (p->exit) {
#line 159
        return;
      }
#line 160
      if (p->stopWriting) {
        {
#line 162
        p->numProcessedBlocks = numProcessedBlocks;
#line 163
        Event_Set(& p->wasStopped);
        }
#line 164
        goto while_break___0;
      }
      {
#line 168
      mf = mt->MatchFinder;
#line 169
      tmp___1 = MatchFinder_NeedMove(mf);
      }
#line 169
      if (tmp___1) {
        {
#line 171
        pthread_mutex_lock(& mt->btSync.cs._mutex);
#line 172
        pthread_mutex_lock(& mt->hashSync.cs._mutex);
#line 174
        tmp = MatchFinder_GetPointerToCurrentPos(mf);
#line 174
        beforePtr = (Byte const   *)tmp;
#line 176
        MatchFinder_MoveBlock(mf);
#line 177
        tmp___0 = MatchFinder_GetPointerToCurrentPos(mf);
#line 177
        afterPtr = (Byte const   *)tmp___0;
#line 178
        mt->pointerToCurPos -= beforePtr - afterPtr;
#line 179
        mt->buffer -= beforePtr - afterPtr;
#line 181
        pthread_mutex_unlock(& mt->btSync.cs._mutex);
#line 182
        pthread_mutex_unlock(& mt->hashSync.cs._mutex);
        }
#line 183
        goto __Cont;
      }
      {
#line 186
      Semaphore_Wait(& p->freeSemaphore);
#line 188
      MatchFinder_ReadIfRequired(mf);
      }
#line 189
      if (mf->pos > 4294967295U - (unsigned int )(1 << 13)) {
        {
#line 191
        subValue = (mf->pos - mf->historySize) - 1U;
#line 192
        MatchFinder_ReduceOffsets(mf, subValue);
#line 193
        MatchFinder_Normalize3(subValue, mf->hash + mf->fixedHashSize, mf->hashMask + 1U);
        }
      }
#line 196
      tmp___2 = numProcessedBlocks;
#line 196
      numProcessedBlocks ++;
#line 196
      heads = mt->hashBuf + (tmp___2 & (unsigned int )((1 << 3) - 1)) * (unsigned int )(1 << 13);
#line 197
      num = mf->streamPos - mf->pos;
#line 198
      *(heads + 0) = (UInt32 )2;
#line 199
      *(heads + 1) = num;
#line 200
      if (num >= mf->numHashBytes) {
#line 202
        num = (num - mf->numHashBytes) + 1U;
#line 203
        if (num > (UInt32 )((1 << 13) - 2)) {
#line 204
          num = (UInt32 )((1 << 13) - 2);
        }
        {
#line 205
        (*(mt->GetHeadsFunc))((Byte const   *)mf->buffer, mf->pos, mf->hash + mf->fixedHashSize,
                              mf->hashMask, heads + 2, num, (UInt32 const   *)(mf->crc));
#line 206
        *(heads + 0) += num;
        }
      }
      {
#line 208
      mf->pos += num;
#line 209
      mf->buffer += num;
#line 213
      Semaphore_ReleaseN(& p->filledSemaphore, (UInt32 )1);
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 218 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p ) 
{ 
  UInt32 tmp ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;

  {
  {
#line 220
  MtSync_GetNextBlock(& p->hashSync);
#line 221
  tmp = ((p->hashSync.numProcessedBlocks - 1U) & (unsigned int )((1 << 3) - 1)) * (unsigned int )(1 << 13);
#line 221
  p->hashBufPos = tmp;
#line 221
  p->hashBufPosLimit = tmp;
#line 222
  tmp___0 = p->hashBufPos;
#line 222
  (p->hashBufPos) ++;
#line 222
  p->hashBufPosLimit += *(p->hashBuf + tmp___0);
#line 223
  tmp___1 = p->hashBufPos;
#line 223
  (p->hashBufPos) ++;
#line 223
  p->hashNumAvail = *(p->hashBuf + tmp___1);
  }
#line 224
  return;
}
}
#line 311 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void BtGetMatches(CMatchFinderMt *p , UInt32 *distances ) 
{ 
  UInt32 numProcessed ;
  UInt32 curPos ;
  UInt32 limit ;
  UInt32 tmp ;
  UInt32 size ;
  UInt32 lenLimit ;
  UInt32 pos ;
  UInt32 cyclicBufferPos ;
  UInt32 size2 ;
  UInt32 *startDistances ;
  UInt32 num ;
  UInt32 tmp___0 ;
  UInt32 *tmp___1 ;
  UInt32 tmp___2 ;

  {
#line 313
  numProcessed = (UInt32 )0;
#line 314
  curPos = (UInt32 )2;
#line 315
  limit = (UInt32 )(1 << 14) - p->matchMaxLen * 2U;
#line 316
  *(distances + 1) = p->hashNumAvail;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! (curPos < limit)) {
#line 317
      goto while_break;
    }
#line 319
    if (p->hashBufPos == p->hashBufPosLimit) {
      {
#line 321
      MatchFinderMt_GetNextBlock_Hash(p);
#line 322
      *(distances + 1) = numProcessed + p->hashNumAvail;
      }
#line 323
      if (p->hashNumAvail >= p->numHashBytes) {
#line 324
        goto while_continue;
      }
      {
#line 325
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 325
        if (! (p->hashNumAvail != 0U)) {
#line 325
          goto while_break___0;
        }
#line 326
        tmp = curPos;
#line 326
        curPos ++;
#line 326
        *(distances + tmp) = (UInt32 )0;
#line 325
        (p->hashNumAvail) --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 327
      goto while_break;
    }
#line 330
    size = p->hashBufPosLimit - p->hashBufPos;
#line 331
    lenLimit = p->matchMaxLen;
#line 332
    pos = p->pos;
#line 333
    cyclicBufferPos = p->cyclicBufferPos;
#line 334
    if (lenLimit >= p->hashNumAvail) {
#line 335
      lenLimit = p->hashNumAvail;
    }
#line 337
    size2 = (p->hashNumAvail - lenLimit) + 1U;
#line 338
    if (size2 < size) {
#line 339
      size = size2;
    }
#line 340
    size2 = p->cyclicBufferSize - cyclicBufferPos;
#line 341
    if (size2 < size) {
#line 342
      size = size2;
    }
    {
#line 345
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 345
      if (curPos < limit) {
#line 345
        tmp___2 = size;
#line 345
        size --;
#line 345
        if (! (tmp___2 != 0U)) {
#line 345
          goto while_break___1;
        }
      } else {
#line 345
        goto while_break___1;
      }
      {
#line 347
      startDistances = distances + curPos;
#line 348
      tmp___0 = p->hashBufPos;
#line 348
      (p->hashBufPos) ++;
#line 348
      tmp___1 = GetMatchesSpec1(lenLimit, pos - *(p->hashBuf + tmp___0), pos, (Byte const   *)p->buffer,
                                p->son, cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
                                startDistances + 1, p->numHashBytes - 1U);
#line 348
      num = (UInt32 )(tmp___1 - startDistances);
#line 351
      *startDistances = num - 1U;
#line 352
      curPos += num;
#line 353
      cyclicBufferPos ++;
#line 354
      pos ++;
#line 355
      (p->buffer) ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 369
    numProcessed += pos - p->pos;
#line 370
    p->hashNumAvail -= pos - p->pos;
#line 371
    p->pos = pos;
#line 372
    if (cyclicBufferPos == p->cyclicBufferSize) {
#line 373
      cyclicBufferPos = (UInt32 )0;
    }
#line 374
    p->cyclicBufferPos = cyclicBufferPos;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  *(distances + 0) = curPos;
#line 378
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void BtFillBlock(CMatchFinderMt *p , UInt32 globalBlockIndex ) 
{ 
  CMtSync *sync ;
  UInt32 subValue ;

  {
#line 382
  sync = & p->hashSync;
#line 383
  if (! sync->needStart) {
    {
#line 385
    pthread_mutex_lock(& sync->cs._mutex);
#line 386
    sync->csWasEntered = 1;
    }
  }
  {
#line 389
  BtGetMatches(p, p->btBuf + (globalBlockIndex & (unsigned int )((1 << 6) - 1)) * (unsigned int )(1 << 14));
  }
#line 391
  if (p->pos > 4294967295U - (unsigned int )(1 << 14)) {
    {
#line 393
    subValue = p->pos - p->cyclicBufferSize;
#line 394
    MatchFinder_Normalize3(subValue, p->son, p->cyclicBufferSize * 2U);
#line 395
    p->pos -= subValue;
    }
  }
#line 398
  if (! sync->needStart) {
    {
#line 400
    pthread_mutex_unlock(& sync->cs._mutex);
#line 401
    sync->csWasEntered = 0;
    }
  }
#line 403
  return;
}
}
#line 405 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void BtThreadFunc(CMatchFinderMt *mt ) 
{ 
  CMtSync *p ;
  UInt32 blockIndex ;
  UInt32 tmp ;

  {
#line 407
  p = & mt->btSync;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 410
    blockIndex = (UInt32 )0;
#line 411
    Event_Wait(& p->canStart);
#line 412
    Event_Set(& p->wasStarted);
    }
    {
#line 413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 415
      if (p->exit) {
#line 416
        return;
      }
#line 417
      if (p->stopWriting) {
        {
#line 419
        p->numProcessedBlocks = blockIndex;
#line 420
        MtSync_StopWriting(& mt->hashSync);
#line 421
        Event_Set(& p->wasStopped);
        }
#line 422
        goto while_break___0;
      }
      {
#line 424
      Semaphore_Wait(& p->freeSemaphore);
#line 425
      tmp = blockIndex;
#line 425
      blockIndex ++;
#line 425
      BtFillBlock(mt, tmp);
#line 426
      Semaphore_ReleaseN(& p->filledSemaphore, (UInt32 )1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 431 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_Construct(CMatchFinderMt *p ) 
{ 


  {
  {
#line 433
  p->hashBuf = (UInt32 *)0;
#line 434
  MtSync_Construct(& p->hashSync);
#line 435
  MtSync_Construct(& p->btSync);
  }
#line 436
  return;
}
}
#line 438 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_FreeMem(CMatchFinderMt *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 440
  (*(alloc->Free))((void *)alloc, (void *)p->hashBuf);
#line 441
  p->hashBuf = (UInt32 *)0;
  }
#line 442
  return;
}
}
#line 444 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_Destruct(CMatchFinderMt *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 446
  MtSync_Destruct(& p->hashSync);
#line 447
  MtSync_Destruct(& p->btSync);
#line 448
  MatchFinderMt_FreeMem(p, alloc);
  }
#line 449
  return;
}
}
#line 454 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static unsigned int HashThreadFunc2(void *p ) 
{ 


  {
  {
#line 454
  HashThreadFunc((CMatchFinderMt *)p);
  }
#line 454
  return (0U);
}
}
#line 455 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
static unsigned int BtThreadFunc2(void *p ) 
{ 
  Byte allocaDummy[384] ;
  int i ;

  {
#line 458
  i = 0;
#line 459
  i = 0;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! (i < 16)) {
#line 459
      goto while_break;
    }
#line 460
    allocaDummy[i] = (Byte )i;
#line 459
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  BtThreadFunc((CMatchFinderMt *)p);
  }
#line 462
  return (0U);
}
}
#line 465 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
SRes MatchFinderMt_Create(CMatchFinderMt *p , UInt32 historySize , UInt32 keepAddBufferBefore ,
                          UInt32 matchMaxLen , UInt32 keepAddBufferAfter , ISzAlloc *alloc ) 
{ 
  CMatchFinder *mf ;
  void *tmp ;
  int tmp___0 ;
  int __result__ ;
  SRes tmp___1 ;
  int __result_____0 ;
  SRes tmp___2 ;

  {
#line 468
  mf = p->MatchFinder;
#line 469
  p->historySize = historySize;
#line 470
  if ((UInt32 )(1 << 14) <= matchMaxLen * 4U) {
#line 471
    return (5);
  }
#line 472
  if ((unsigned long )p->hashBuf == (unsigned long )((UInt32 *)0)) {
    {
#line 474
    tmp = (*(alloc->Alloc))((void *)alloc, (unsigned long )((1 << 13) * (1 << 3) + (1 << 14) * (1 << 6)) * sizeof(UInt32 ));
#line 474
    p->hashBuf = (UInt32 *)tmp;
    }
#line 475
    if ((unsigned long )p->hashBuf == (unsigned long )((UInt32 *)0)) {
#line 476
      return (2);
    }
#line 477
    p->btBuf = p->hashBuf + (1 << 13) * (1 << 3);
  }
  {
#line 479
  keepAddBufferBefore += (UInt32 )((1 << 13) * (1 << 3) + (1 << 14) * (1 << 6));
#line 480
  keepAddBufferAfter += (UInt32 )(1 << 13);
#line 481
  tmp___0 = MatchFinder_Create(mf, historySize, keepAddBufferBefore, matchMaxLen,
                               keepAddBufferAfter, alloc);
  }
#line 481
  if (! tmp___0) {
#line 482
    return (2);
  }
  {
#line 484
  tmp___1 = MtSync_Create(& p->hashSync, & HashThreadFunc2, (void *)p, (UInt32 )(1 << 3));
#line 484
  __result__ = tmp___1;
  }
#line 484
  if (__result__ != 0) {
#line 484
    return (__result__);
  }
  {
#line 485
  tmp___2 = MtSync_Create(& p->btSync, & BtThreadFunc2, (void *)p, (UInt32 )(1 << 6));
#line 485
  __result_____0 = tmp___2;
  }
#line 485
  if (__result_____0 != 0) {
#line 485
    return (__result_____0);
  }
#line 486
  return (0);
}
}
#line 490 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_Init(CMatchFinderMt *p ) 
{ 
  CMatchFinder *mf ;
  UInt32 tmp ;
  UInt32 tmp___0 ;
  Byte *tmp___1 ;

  {
  {
#line 492
  mf = p->MatchFinder;
#line 493
  tmp = (UInt32 )0;
#line 493
  p->btBufPosLimit = tmp;
#line 493
  p->btBufPos = tmp;
#line 494
  tmp___0 = (UInt32 )0;
#line 494
  p->hashBufPosLimit = tmp___0;
#line 494
  p->hashBufPos = tmp___0;
#line 495
  MatchFinder_Init(mf);
#line 496
  tmp___1 = MatchFinder_GetPointerToCurrentPos(mf);
#line 496
  p->pointerToCurPos = (Byte const   *)tmp___1;
#line 497
  p->btNumAvailBytes = (UInt32 )0;
#line 498
  p->lzPos = p->historySize + 1U;
#line 500
  p->hash = mf->hash;
#line 501
  p->fixedHashSize = mf->fixedHashSize;
#line 502
  p->crc = (UInt32 const   *)(mf->crc);
#line 504
  p->son = mf->son;
#line 505
  p->matchMaxLen = mf->matchMaxLen;
#line 506
  p->numHashBytes = mf->numHashBytes;
#line 507
  p->pos = mf->pos;
#line 508
  p->buffer = mf->buffer;
#line 509
  p->cyclicBufferPos = mf->cyclicBufferPos;
#line 510
  p->cyclicBufferSize = mf->cyclicBufferSize;
#line 511
  p->cutValue = mf->cutValue;
  }
#line 512
  return;
}
}
#line 515 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_ReleaseStream(CMatchFinderMt *p ) 
{ 


  {
  {
#line 517
  MtSync_StopWriting(& p->btSync);
  }
#line 519
  return;
}
}
#line 521 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_Normalize(CMatchFinderMt *p ) 
{ 


  {
  {
#line 523
  MatchFinder_Normalize3((p->lzPos - p->historySize) - 1U, p->hash, p->fixedHashSize);
#line 524
  p->lzPos = p->historySize + 1U;
  }
#line 525
  return;
}
}
#line 527 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_GetNextBlock_Bt(CMatchFinderMt *p ) 
{ 
  UInt32 blockIndex ;
  UInt32 tmp ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;

  {
  {
#line 530
  MtSync_GetNextBlock(& p->btSync);
#line 531
  blockIndex = (p->btSync.numProcessedBlocks - 1U) & (unsigned int )((1 << 6) - 1);
#line 532
  tmp = blockIndex * (UInt32 )(1 << 14);
#line 532
  p->btBufPos = tmp;
#line 532
  p->btBufPosLimit = tmp;
#line 533
  tmp___0 = p->btBufPos;
#line 533
  (p->btBufPos) ++;
#line 533
  p->btBufPosLimit += *(p->btBuf + tmp___0);
#line 534
  tmp___1 = p->btBufPos;
#line 534
  (p->btBufPos) ++;
#line 534
  p->btNumAvailBytes = *(p->btBuf + tmp___1);
  }
#line 535
  if (p->lzPos >= 4294967295U - (unsigned int )(1 << 14)) {
    {
#line 536
    MatchFinderMt_Normalize(p);
    }
  }
#line 537
  return;
}
}
#line 539 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
Byte const   *MatchFinderMt_GetPointerToCurrentPos(CMatchFinderMt *p ) 
{ 


  {
#line 541
  return (p->pointerToCurPos);
}
}
#line 546 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
UInt32 MatchFinderMt_GetNumAvailableBytes(CMatchFinderMt *p ) 
{ 


  {
#line 548
  if (p->btBufPos == p->btBufPosLimit) {
    {
#line 548
    MatchFinderMt_GetNextBlock_Bt(p);
    }
  }
#line 549
  return (p->btNumAvailBytes);
}
}
#line 552 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
Byte MatchFinderMt_GetIndexByte(CMatchFinderMt *p , Int32 index___0 ) 
{ 


  {
#line 554
  return ((Byte )*(p->pointerToCurPos + index___0));
}
}
#line 557 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
UInt32 *MixMatches2(CMatchFinderMt *p , UInt32 matchMinPos , UInt32 *distances ) 
{ 
  UInt32 hash2Value ;
  UInt32 curMatch2 ;
  UInt32 *hash ;
  Byte const   *cur ;
  UInt32 lzPos ;
  UInt32 *tmp ;
  UInt32 *tmp___0 ;

  {
#line 560
  hash = p->hash;
#line 561
  cur = p->pointerToCurPos;
#line 562
  lzPos = p->lzPos;
#line 563
  hash2Value = (UInt32 )((*(p->crc + *(cur + 0)) ^ (unsigned int const   )*(cur + 1)) & (unsigned int const   )((1 << 10) - 1));
#line 565
  curMatch2 = *(hash + hash2Value);
#line 566
  *(hash + hash2Value) = lzPos;
#line 568
  if (curMatch2 >= matchMinPos) {
#line 569
    if ((int const   )*(cur + ((ptrdiff_t )curMatch2 - (ptrdiff_t )lzPos)) == (int const   )*(cur + 0)) {
#line 571
      tmp = distances;
#line 571
      distances ++;
#line 571
      *tmp = (UInt32 )2;
#line 572
      tmp___0 = distances;
#line 572
      distances ++;
#line 572
      *tmp___0 = (lzPos - curMatch2) - 1U;
    }
  }
#line 574
  return (distances);
}
}
#line 577 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
UInt32 *MixMatches3(CMatchFinderMt *p , UInt32 matchMinPos , UInt32 *distances ) 
{ 
  UInt32 hash2Value ;
  UInt32 hash3Value ;
  UInt32 curMatch2 ;
  UInt32 curMatch3 ;
  UInt32 *hash ;
  Byte const   *cur ;
  UInt32 lzPos ;
  UInt32 temp ;
  UInt32 tmp ;
  UInt32 *tmp___0 ;
  UInt32 *tmp___1 ;

  {
#line 580
  hash = p->hash;
#line 581
  cur = p->pointerToCurPos;
#line 582
  lzPos = p->lzPos;
#line 583
  temp = (UInt32 )(*(p->crc + *(cur + 0)) ^ (unsigned int const   )*(cur + 1));
#line 583
  hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 583
  hash3Value = (temp ^ ((UInt32 )*(cur + 2) << 8)) & (unsigned int )((1 << 16) - 1);
#line 585
  curMatch2 = *(hash + hash2Value);
#line 586
  curMatch3 = *(hash + ((UInt32 )(1 << 10) + hash3Value));
#line 588
  tmp = lzPos;
#line 588
  *(hash + ((UInt32 )(1 << 10) + hash3Value)) = tmp;
#line 588
  *(hash + hash2Value) = tmp;
#line 592
  if (curMatch2 >= matchMinPos) {
#line 592
    if ((int const   )*(cur + ((ptrdiff_t )curMatch2 - (ptrdiff_t )lzPos)) == (int const   )*(cur + 0)) {
#line 594
      *(distances + 1) = (lzPos - curMatch2) - 1U;
#line 595
      if ((int const   )*(cur + (((ptrdiff_t )curMatch2 - (ptrdiff_t )lzPos) + 2L)) == (int const   )*(cur + 2)) {
#line 597
        *(distances + 0) = (UInt32 )3;
#line 598
        return (distances + 2);
      }
#line 600
      *(distances + 0) = (UInt32 )2;
#line 601
      distances += 2;
    }
  }
#line 603
  if (curMatch3 >= matchMinPos) {
#line 603
    if ((int const   )*(cur + ((ptrdiff_t )curMatch3 - (ptrdiff_t )lzPos)) == (int const   )*(cur + 0)) {
#line 605
      tmp___0 = distances;
#line 605
      distances ++;
#line 605
      *tmp___0 = (UInt32 )3;
#line 606
      tmp___1 = distances;
#line 606
      distances ++;
#line 606
      *tmp___1 = (lzPos - curMatch3) - 1U;
    }
  }
#line 608
  return (distances);
}
}
#line 667 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
UInt32 MatchFinderMt2_GetMatches(CMatchFinderMt *p , UInt32 *distances ) 
{ 
  UInt32 const   *btBuf ;
  UInt32 len ;
  UInt32 const   *tmp ;
  UInt32 i ;
  UInt32 *tmp___0 ;
  UInt32 const   *tmp___1 ;
  UInt32 *tmp___2 ;
  UInt32 const   *tmp___3 ;

  {
#line 669
  btBuf = (UInt32 const   *)(p->btBuf + p->btBufPos);
#line 670
  tmp = btBuf;
#line 670
  btBuf ++;
#line 670
  len = (UInt32 )*tmp;
#line 671
  p->btBufPos += 1U + len;
#line 672
  (p->btNumAvailBytes) --;
#line 675
  i = (UInt32 )0;
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (i < len)) {
#line 675
      goto while_break;
    }
#line 677
    tmp___0 = distances;
#line 677
    distances ++;
#line 677
    tmp___1 = btBuf;
#line 677
    btBuf ++;
#line 677
    *tmp___0 = (UInt32 )*tmp___1;
#line 678
    tmp___2 = distances;
#line 678
    distances ++;
#line 678
    tmp___3 = btBuf;
#line 678
    btBuf ++;
#line 678
    *tmp___2 = (UInt32 )*tmp___3;
#line 675
    i += 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 681
  (p->lzPos) ++;
#line 681
  (p->pointerToCurPos) ++;
#line 682
  return (len);
}
}
#line 685 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
UInt32 MatchFinderMt_GetMatches(CMatchFinderMt *p , UInt32 *distances ) 
{ 
  UInt32 const   *btBuf ;
  UInt32 len ;
  UInt32 const   *tmp ;
  UInt32 *tmp___0 ;
  UInt32 tmp___1 ;
  UInt32 *distances2 ;
  UInt32 *tmp___2 ;
  UInt32 const   *tmp___3 ;
  UInt32 *tmp___4 ;
  UInt32 const   *tmp___5 ;

  {
#line 687
  btBuf = (UInt32 const   *)(p->btBuf + p->btBufPos);
#line 688
  tmp = btBuf;
#line 688
  btBuf ++;
#line 688
  len = (UInt32 )*tmp;
#line 689
  p->btBufPos += 1U + len;
#line 691
  if (len == 0U) {
#line 693
    tmp___1 = p->btNumAvailBytes;
#line 693
    (p->btNumAvailBytes) --;
#line 693
    if (tmp___1 >= 4U) {
      {
#line 694
      tmp___0 = (*(p->MixMatchesFunc))((void *)p, p->lzPos - p->historySize, distances);
#line 694
      len = (UInt32 )(tmp___0 - distances);
      }
    }
  } else {
    {
#line 700
    (p->btNumAvailBytes) --;
#line 701
    distances2 = (*(p->MixMatchesFunc))((void *)p, p->lzPos - (UInt32 )*(btBuf + 1),
                                        distances);
    }
    {
#line 702
    while (1) {
      while_continue: /* CIL Label */ ;
#line 704
      tmp___2 = distances2;
#line 704
      distances2 ++;
#line 704
      tmp___3 = btBuf;
#line 704
      btBuf ++;
#line 704
      *tmp___2 = (UInt32 )*tmp___3;
#line 705
      tmp___4 = distances2;
#line 705
      distances2 ++;
#line 705
      tmp___5 = btBuf;
#line 705
      btBuf ++;
#line 705
      *tmp___4 = (UInt32 )*tmp___5;
#line 702
      len -= 2U;
#line 702
      if (! (len != 0U)) {
#line 702
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 708
    len = (UInt32 )(distances2 - distances);
  }
#line 710
  (p->lzPos) ++;
#line 710
  (p->pointerToCurPos) ++;
#line 711
  return (len);
}
}
#line 718 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt0_Skip(CMatchFinderMt *p , UInt32 num ) 
{ 


  {
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (p->btBufPos == p->btBufPosLimit) {
      {
#line 720
      MatchFinderMt_GetNextBlock_Bt(p);
      }
    }
#line 720
    (p->btNumAvailBytes) --;
#line 721
    (p->lzPos) ++;
#line 721
    (p->pointerToCurPos) ++;
#line 721
    p->btBufPos += *(p->btBuf + p->btBufPos) + 1U;
#line 720
    num --;
#line 720
    if (! (num != 0U)) {
#line 720
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  return;
}
}
#line 724 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt2_Skip(CMatchFinderMt *p , UInt32 num ) 
{ 
  Byte const   *cur ;
  UInt32 *hash ;
  UInt32 hash2Value ;
  UInt32 tmp ;

  {
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (p->btBufPos == p->btBufPosLimit) {
      {
#line 726
      MatchFinderMt_GetNextBlock_Bt(p);
      }
    }
#line 726
    tmp = p->btNumAvailBytes;
#line 726
    (p->btNumAvailBytes) --;
#line 726
    if (tmp >= 2U) {
#line 726
      cur = p->pointerToCurPos;
#line 726
      hash = p->hash;
#line 728
      hash2Value = (UInt32 )((*(p->crc + *(cur + 0)) ^ (unsigned int const   )*(cur + 1)) & (unsigned int const   )((1 << 10) - 1));
#line 729
      *(hash + hash2Value) = p->lzPos;
    }
#line 730
    (p->lzPos) ++;
#line 730
    (p->pointerToCurPos) ++;
#line 730
    p->btBufPos += *(p->btBuf + p->btBufPos) + 1U;
#line 726
    num --;
#line 726
    if (! (num != 0U)) {
#line 726
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  return;
}
}
#line 733 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt3_Skip(CMatchFinderMt *p , UInt32 num ) 
{ 
  Byte const   *cur ;
  UInt32 *hash ;
  UInt32 hash2Value ;
  UInt32 hash3Value ;
  UInt32 temp ;
  UInt32 tmp ;
  UInt32 tmp___0 ;

  {
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (p->btBufPos == p->btBufPosLimit) {
      {
#line 735
      MatchFinderMt_GetNextBlock_Bt(p);
      }
    }
#line 735
    tmp___0 = p->btNumAvailBytes;
#line 735
    (p->btNumAvailBytes) --;
#line 735
    if (tmp___0 >= 3U) {
#line 735
      cur = p->pointerToCurPos;
#line 735
      hash = p->hash;
#line 737
      temp = (UInt32 )(*(p->crc + *(cur + 0)) ^ (unsigned int const   )*(cur + 1));
#line 737
      hash2Value = temp & (unsigned int )((1 << 10) - 1);
#line 737
      hash3Value = (temp ^ ((UInt32 )*(cur + 2) << 8)) & (unsigned int )((1 << 16) - 1);
#line 738
      tmp = p->lzPos;
#line 738
      *(hash + hash2Value) = tmp;
#line 738
      *(hash + ((UInt32 )(1 << 10) + hash3Value)) = tmp;
    }
#line 741
    (p->lzPos) ++;
#line 741
    (p->pointerToCurPos) ++;
#line 741
    p->btBufPos += *(p->btBuf + p->btBufPos) + 1U;
#line 735
    num --;
#line 735
    if (! (num != 0U)) {
#line 735
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  return;
}
}
#line 758 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzFindMt.c"
void MatchFinderMt_CreateVTable(CMatchFinderMt *p , IMatchFinder *vTable ) 
{ 


  {
#line 760
  vTable->Init = (void (*)(void *object ))(& MatchFinderMt_Init);
#line 761
  vTable->GetIndexByte = (Byte (*)(void *object , Int32 index ))(& MatchFinderMt_GetIndexByte);
#line 762
  vTable->GetNumAvailableBytes = (UInt32 (*)(void *object ))(& MatchFinderMt_GetNumAvailableBytes);
#line 763
  vTable->GetPointerToCurrentPos = (Byte const   *(*)(void *object ))(& MatchFinderMt_GetPointerToCurrentPos);
#line 764
  vTable->GetMatches = (UInt32 (*)(void *object , UInt32 *distances ))(& MatchFinderMt_GetMatches);
  {
#line 767
  if ((p->MatchFinder)->numHashBytes == 2U) {
#line 767
    goto case_2;
  }
#line 773
  if ((p->MatchFinder)->numHashBytes == 3U) {
#line 773
    goto case_3;
  }
#line 778
  goto switch_default;
  case_2: /* CIL Label */ 
#line 768
  p->GetHeadsFunc = & GetHeads2;
#line 769
  p->MixMatchesFunc = (UInt32 *(*)(void *p , UInt32 matchMinPos , UInt32 *distances ))0;
#line 770
  vTable->Skip = (void (*)(void *object , UInt32  ))(& MatchFinderMt0_Skip);
#line 771
  vTable->GetMatches = (UInt32 (*)(void *object , UInt32 *distances ))(& MatchFinderMt2_GetMatches);
#line 772
  goto switch_break;
  case_3: /* CIL Label */ 
#line 774
  p->GetHeadsFunc = & GetHeads3;
#line 775
  p->MixMatchesFunc = (UInt32 *(*)(void *p , UInt32 matchMinPos , UInt32 *distances ))(& MixMatches2);
#line 776
  vTable->Skip = (void (*)(void *object , UInt32  ))(& MatchFinderMt2_Skip);
#line 777
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 780
  if ((p->MatchFinder)->bigHash) {
#line 780
    p->GetHeadsFunc = & GetHeads4b;
  } else {
#line 780
    p->GetHeadsFunc = & GetHeads4;
  }
#line 782
  p->MixMatchesFunc = (UInt32 *(*)(void *p , UInt32 matchMinPos , UInt32 *distances ))(& MixMatches3);
#line 783
  vTable->Skip = (void (*)(void *object , UInt32  ))(& MatchFinderMt3_Skip);
#line 784
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 793
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzCrc64.h"
UInt64 g_Crc64Table[256]  ;
#line 15
void Crc64GenerateTable(void) ;
#line 22
UInt64 Crc64Calc(void const   *data , size_t size ) ;
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzCrc64.c"
void Crc64GenerateTable(void) 
{ 
  UInt32 i ;
  UInt64 r ;
  int j ;

  {
#line 12
  i = (UInt32 )0;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (! (i < 256U)) {
#line 12
      goto while_break;
    }
#line 14
    r = (UInt64 )i;
#line 16
    j = 0;
    {
#line 16
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 16
      if (! (j < 8)) {
#line 16
        goto while_break___0;
      }
#line 17
      r = (r >> 1) ^ (0xc96c5795d7870f42ULL & ~ ((r & 1ULL) - 1ULL));
#line 16
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 18
    g_Crc64Table[i] = r;
#line 12
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzCrc64.c"
UInt64 Crc64Update(UInt64 v , void const   *data , size_t size ) 
{ 
  Byte const   *p ;

  {
#line 24
  p = (Byte const   *)data;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (size > 0UL)) {
#line 25
      goto while_break;
    }
#line 26
    v = g_Crc64Table[(v ^ (unsigned long long )*p) & 255ULL] ^ (v >> 8);
#line 25
    size --;
#line 25
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 27
  return (v);
}
}
#line 30 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzCrc64.c"
UInt64 Crc64Calc(void const   *data , size_t size ) 
{ 
  UInt64 tmp ;

  {
  {
#line 32
  tmp = Crc64Update(0xffffffffffffffffULL, data, size);
  }
#line 32
  return (tmp ^ 0xffffffffffffffffULL);
}
}
#line 11 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.h"
UInt32 g_CrcTable[2048]  ;
#line 14
void CrcGenerateTable(void) ;
#line 17 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.c"
static UInt32 (*g_CrcUpdate)(UInt32 v , void const   *data , size_t size , UInt32 const   *table )  ;
#line 39 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.c"
UInt32 CrcUpdate(UInt32 v , void const   *data , size_t size ) 
{ 
  UInt32 tmp ;

  {
  {
#line 41
  tmp = (*g_CrcUpdate)(v, data, size, (UInt32 const   *)(g_CrcTable));
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.c"
UInt32 CrcCalc(void const   *data , size_t size ) 
{ 
  UInt32 tmp ;

  {
  {
#line 46
  tmp = (*g_CrcUpdate)(4294967295U, data, size, (UInt32 const   *)(g_CrcTable));
  }
#line 46
  return (tmp ^ 4294967295U);
}
}
#line 49 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/7zCrc.c"
void CrcGenerateTable(void) 
{ 
  UInt32 i ;
  UInt32 r ;
  unsigned int j ;
  UInt32 r___0 ;

  {
#line 52
  i = (UInt32 )0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < 256U)) {
#line 52
      goto while_break;
    }
#line 54
    r = i;
#line 56
    j = 0U;
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 56
      if (! (j < 8U)) {
#line 56
        goto while_break___0;
      }
#line 57
      r = (r >> 1) ^ (3988292384U & ~ ((r & 1U) - 1U));
#line 56
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 58
    g_CrcTable[i] = r;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 63
    if (! (i < 2048U)) {
#line 63
      goto while_break___1;
    }
#line 65
    r___0 = g_CrcTable[i - 256U];
#line 66
    g_CrcTable[i] = g_CrcTable[r___0 & 255U] ^ (r___0 >> 8);
#line 63
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 68
  g_CrcUpdate = & CrcUpdateT4;
#line 76
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.h"
SRes LzmaProps_Decode(CLzmaProps *p , Byte const   *data , unsigned int size ) ;
#line 198
SRes LzmaDec_DecodeToBuf(CLzmaDec *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                         SizeT *srcLen , ELzmaFinishMode finishMode , ELzmaStatus *status ) ;
#line 223
SRes LzmaDecode(Byte *dest , SizeT *destLen , Byte const   *src , SizeT *srcLen ,
                Byte const   *propData , unsigned int propSize , ELzmaFinishMode finishMode ,
                ELzmaStatus *status , ISzAlloc *alloc ) ;
#line 131 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static int LzmaDec_DecodeReal(CLzmaDec *p , SizeT limit , Byte const   *bufLimit ) 
{ 
  UInt16 *probs ;
  unsigned int state ;
  UInt32 rep0 ;
  UInt32 rep1 ;
  UInt32 rep2 ;
  UInt32 rep3 ;
  unsigned int pbMask ;
  unsigned int lpMask ;
  unsigned int lc ;
  Byte *dic ;
  SizeT dicBufSize ;
  SizeT dicPos ;
  UInt32 processedPos ;
  UInt32 checkDicSize ;
  unsigned int len ;
  Byte const   *buf ;
  UInt32 range ;
  UInt32 code ;
  UInt16 *prob ;
  UInt32 bound ;
  unsigned int ttt ;
  unsigned int posState ;
  Byte const   *tmp ;
  unsigned int symbol ;
  SizeT tmp___0 ;
  unsigned int tmp___1 ;
  Byte const   *tmp___2 ;
  unsigned int matchByte ;
  SizeT tmp___3 ;
  unsigned int offs ;
  int tmp___4 ;
  unsigned int bit ;
  UInt16 *probLit ;
  Byte const   *tmp___5 ;
  SizeT tmp___6 ;
  Byte const   *tmp___7 ;
  Byte const   *tmp___8 ;
  Byte const   *tmp___9 ;
  SizeT tmp___10 ;
  UInt32 distance ;
  Byte const   *tmp___11 ;
  Byte const   *tmp___12 ;
  unsigned int limit___0 ;
  unsigned int offset ;
  UInt16 *probLen ;
  Byte const   *tmp___13 ;
  Byte const   *tmp___14 ;
  Byte const   *tmp___15 ;
  UInt32 distance___0 ;
  unsigned int tmp___16 ;
  Byte const   *tmp___17 ;
  Byte const   *tmp___18 ;
  Byte const   *tmp___19 ;
  Byte const   *tmp___20 ;
  Byte const   *tmp___21 ;
  Byte const   *tmp___22 ;
  unsigned int posSlot ;
  int numDirectBits ;
  UInt32 mask ;
  unsigned int i ;
  Byte const   *tmp___23 ;
  Byte const   *tmp___24 ;
  UInt32 t ;
  unsigned int i___0 ;
  Byte const   *tmp___25 ;
  Byte const   *tmp___26 ;
  Byte const   *tmp___27 ;
  Byte const   *tmp___28 ;
  SizeT rem ;
  unsigned int curLen ;
  unsigned int tmp___29 ;
  SizeT pos ;
  SizeT tmp___30 ;
  Byte *dest ;
  ptrdiff_t src ;
  Byte const   *lim ;
  SizeT tmp___31 ;
  Byte const   *tmp___32 ;

  {
#line 133
  probs = p->probs;
#line 135
  state = p->state;
#line 136
  rep0 = p->reps[0];
#line 136
  rep1 = p->reps[1];
#line 136
  rep2 = p->reps[2];
#line 136
  rep3 = p->reps[3];
#line 137
  pbMask = (1U << p->prop.pb) - 1U;
#line 138
  lpMask = (1U << p->prop.lp) - 1U;
#line 139
  lc = p->prop.lc;
#line 141
  dic = p->dic;
#line 142
  dicBufSize = p->dicBufSize;
#line 143
  dicPos = p->dicPos;
#line 145
  processedPos = p->processedPos;
#line 146
  checkDicSize = p->checkDicSize;
#line 147
  len = 0U;
#line 149
  buf = p->buf;
#line 150
  range = p->range;
#line 151
  code = p->code;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    posState = processedPos & pbMask;
#line 160
    prob = ((probs + 0) + (state << 4)) + posState;
#line 161
    ttt = (unsigned int )*prob;
#line 161
    if (range < 1U << 24) {
#line 161
      range <<= 8;
#line 161
      tmp = buf;
#line 161
      buf ++;
#line 161
      code = (code << 8) | (unsigned int )*tmp;
    }
#line 161
    bound = (range >> 11) * ttt;
#line 161
    if (code < bound) {
#line 164
      range = bound;
#line 164
      *prob = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 165
      prob = probs + ((((((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14) + (1 << 4)) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8))) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8)));
#line 166
      if (checkDicSize != 0U) {
#line 166
        goto _L;
      } else
#line 166
      if (processedPos != 0U) {
        _L: /* CIL Label */ 
#line 167
        if (dicPos == 0UL) {
#line 167
          tmp___0 = dicBufSize;
        } else {
#line 167
          tmp___0 = dicPos;
        }
#line 167
        prob += 768U * (((processedPos & lpMask) << lc) + (unsigned int )((int )*(dic + (tmp___0 - 1UL)) >> (8U - lc)));
      }
#line 170
      if (state < 7U) {
#line 172
        if (state < 4U) {
#line 172
          tmp___1 = state;
        } else {
#line 172
          tmp___1 = 3U;
        }
#line 172
        state -= tmp___1;
#line 173
        symbol = 1U;
        {
#line 174
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 174
          ttt = (unsigned int )*(prob + symbol);
#line 174
          if (range < 1U << 24) {
#line 174
            range <<= 8;
#line 174
            tmp___2 = buf;
#line 174
            buf ++;
#line 174
            code = (code << 8) | (unsigned int )*tmp___2;
          }
#line 174
          bound = (range >> 11) * ttt;
#line 174
          if (code < bound) {
#line 174
            range = bound;
#line 174
            *(prob + symbol) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 174
            symbol += symbol;
          } else {
#line 174
            range -= bound;
#line 174
            code -= bound;
#line 174
            *(prob + symbol) = (UInt16 )(ttt - (ttt >> 5));
#line 174
            symbol = (symbol + symbol) + 1U;
          }
#line 174
          if (! (symbol < 256U)) {
#line 174
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 178
        if (dicPos < (SizeT )rep0) {
#line 178
          tmp___3 = dicBufSize;
        } else {
#line 178
          tmp___3 = (SizeT )0;
        }
#line 178
        matchByte = (unsigned int )*(p->dic + ((dicPos - (SizeT )rep0) + tmp___3));
#line 179
        offs = 256U;
#line 180
        if (state < 10U) {
#line 180
          tmp___4 = 3;
        } else {
#line 180
          tmp___4 = 6;
        }
#line 180
        state -= (unsigned int )tmp___4;
#line 181
        symbol = 1U;
        {
#line 182
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 186
          matchByte <<= 1;
#line 187
          bit = matchByte & offs;
#line 188
          probLit = ((prob + offs) + bit) + symbol;
#line 189
          ttt = (unsigned int )*probLit;
#line 189
          if (range < 1U << 24) {
#line 189
            range <<= 8;
#line 189
            tmp___5 = buf;
#line 189
            buf ++;
#line 189
            code = (code << 8) | (unsigned int )*tmp___5;
          }
#line 189
          bound = (range >> 11) * ttt;
#line 189
          if (code < bound) {
#line 189
            range = bound;
#line 189
            *probLit = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 189
            symbol += symbol;
#line 189
            offs &= ~ bit;
          } else {
#line 189
            range -= bound;
#line 189
            code -= bound;
#line 189
            *probLit = (UInt16 )(ttt - (ttt >> 5));
#line 189
            symbol = (symbol + symbol) + 1U;
#line 189
            offs &= bit;
          }
#line 182
          if (! (symbol < 256U)) {
#line 182
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 193
      tmp___6 = dicPos;
#line 193
      dicPos ++;
#line 193
      *(dic + tmp___6) = (Byte )symbol;
#line 194
      processedPos ++;
#line 195
      goto __Cont;
    } else {
#line 199
      range -= bound;
#line 199
      code -= bound;
#line 199
      *prob = (UInt16 )(ttt - (ttt >> 5));
#line 200
      prob = (probs + (12 << 4)) + state;
#line 201
      ttt = (unsigned int )*prob;
#line 201
      if (range < 1U << 24) {
#line 201
        range <<= 8;
#line 201
        tmp___7 = buf;
#line 201
        buf ++;
#line 201
        code = (code << 8) | (unsigned int )*tmp___7;
      }
#line 201
      bound = (range >> 11) * ttt;
#line 201
      if (code < bound) {
#line 203
        range = bound;
#line 203
        *prob = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 204
        state += 12U;
#line 205
        prob = probs + ((((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14) + (1 << 4));
      } else {
#line 209
        range -= bound;
#line 209
        code -= bound;
#line 209
        *prob = (UInt16 )(ttt - (ttt >> 5));
#line 210
        if (checkDicSize == 0U) {
#line 210
          if (processedPos == 0U) {
#line 211
            return (1);
          }
        }
#line 212
        prob = (probs + ((12 << 4) + 12)) + state;
#line 213
        ttt = (unsigned int )*prob;
#line 213
        if (range < 1U << 24) {
#line 213
          range <<= 8;
#line 213
          tmp___8 = buf;
#line 213
          buf ++;
#line 213
          code = (code << 8) | (unsigned int )*tmp___8;
        }
#line 213
        bound = (range >> 11) * ttt;
#line 213
        if (code < bound) {
#line 215
          range = bound;
#line 215
          *prob = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 216
          prob = ((probs + (((((12 << 4) + 12) + 12) + 12) + 12)) + (state << 4)) + posState;
#line 217
          ttt = (unsigned int )*prob;
#line 217
          if (range < 1U << 24) {
#line 217
            range <<= 8;
#line 217
            tmp___9 = buf;
#line 217
            buf ++;
#line 217
            code = (code << 8) | (unsigned int )*tmp___9;
          }
#line 217
          bound = (range >> 11) * ttt;
#line 217
          if (code < bound) {
#line 219
            range = bound;
#line 219
            *prob = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 220
            if (dicPos < (SizeT )rep0) {
#line 220
              tmp___10 = dicBufSize;
            } else {
#line 220
              tmp___10 = (SizeT )0;
            }
#line 220
            *(dic + dicPos) = *(dic + ((dicPos - (SizeT )rep0) + tmp___10));
#line 221
            dicPos ++;
#line 222
            processedPos ++;
#line 223
            if (state < 7U) {
#line 223
              state = 9U;
            } else {
#line 223
              state = 11U;
            }
#line 224
            goto __Cont;
          }
#line 226
          range -= bound;
#line 226
          code -= bound;
#line 226
          *prob = (UInt16 )(ttt - (ttt >> 5));
        } else {
#line 231
          range -= bound;
#line 231
          code -= bound;
#line 231
          *prob = (UInt16 )(ttt - (ttt >> 5));
#line 232
          prob = (probs + (((12 << 4) + 12) + 12)) + state;
#line 233
          ttt = (unsigned int )*prob;
#line 233
          if (range < 1U << 24) {
#line 233
            range <<= 8;
#line 233
            tmp___11 = buf;
#line 233
            buf ++;
#line 233
            code = (code << 8) | (unsigned int )*tmp___11;
          }
#line 233
          bound = (range >> 11) * ttt;
#line 233
          if (code < bound) {
#line 235
            range = bound;
#line 235
            *prob = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 236
            distance = rep1;
          } else {
#line 240
            range -= bound;
#line 240
            code -= bound;
#line 240
            *prob = (UInt16 )(ttt - (ttt >> 5));
#line 241
            prob = (probs + ((((12 << 4) + 12) + 12) + 12)) + state;
#line 242
            ttt = (unsigned int )*prob;
#line 242
            if (range < 1U << 24) {
#line 242
              range <<= 8;
#line 242
              tmp___12 = buf;
#line 242
              buf ++;
#line 242
              code = (code << 8) | (unsigned int )*tmp___12;
            }
#line 242
            bound = (range >> 11) * ttt;
#line 242
            if (code < bound) {
#line 244
              range = bound;
#line 244
              *prob = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 245
              distance = rep2;
            } else {
#line 249
              range -= bound;
#line 249
              code -= bound;
#line 249
              *prob = (UInt16 )(ttt - (ttt >> 5));
#line 250
              distance = rep3;
#line 251
              rep3 = rep2;
            }
#line 253
            rep2 = rep1;
          }
#line 255
          rep1 = rep0;
#line 256
          rep0 = distance;
        }
#line 258
        if (state < 7U) {
#line 258
          state = 8U;
        } else {
#line 258
          state = 11U;
        }
#line 259
        prob = probs + (((((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14) + (1 << 4)) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8)));
      }
#line 263
      probLen = prob + 0;
#line 264
      ttt = (unsigned int )*probLen;
#line 264
      if (range < 1U << 24) {
#line 264
        range <<= 8;
#line 264
        tmp___13 = buf;
#line 264
        buf ++;
#line 264
        code = (code << 8) | (unsigned int )*tmp___13;
      }
#line 264
      bound = (range >> 11) * ttt;
#line 264
      if (code < bound) {
#line 266
        range = bound;
#line 266
        *probLen = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 267
        probLen = (prob + 2) + (posState << 3);
#line 268
        offset = 0U;
#line 269
        limit___0 = (unsigned int )(1 << 3);
      } else {
#line 273
        range -= bound;
#line 273
        code -= bound;
#line 273
        *probLen = (UInt16 )(ttt - (ttt >> 5));
#line 274
        probLen = prob + 1;
#line 275
        ttt = (unsigned int )*probLen;
#line 275
        if (range < 1U << 24) {
#line 275
          range <<= 8;
#line 275
          tmp___14 = buf;
#line 275
          buf ++;
#line 275
          code = (code << 8) | (unsigned int )*tmp___14;
        }
#line 275
        bound = (range >> 11) * ttt;
#line 275
        if (code < bound) {
#line 277
          range = bound;
#line 277
          *probLen = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 278
          probLen = (prob + (2 + ((1 << 4) << 3))) + (posState << 3);
#line 279
          offset = (unsigned int )(1 << 3);
#line 280
          limit___0 = (unsigned int )(1 << 3);
        } else {
#line 284
          range -= bound;
#line 284
          code -= bound;
#line 284
          *probLen = (UInt16 )(ttt - (ttt >> 5));
#line 285
          probLen = prob + ((2 + ((1 << 4) << 3)) + ((1 << 4) << 3));
#line 286
          offset = (unsigned int )((1 << 3) + (1 << 3));
#line 287
          limit___0 = (unsigned int )(1 << 8);
        }
      }
#line 290
      len = 1U;
      {
#line 290
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 290
        ttt = (unsigned int )*(probLen + len);
#line 290
        if (range < 1U << 24) {
#line 290
          range <<= 8;
#line 290
          tmp___15 = buf;
#line 290
          buf ++;
#line 290
          code = (code << 8) | (unsigned int )*tmp___15;
        }
#line 290
        bound = (range >> 11) * ttt;
#line 290
        if (code < bound) {
#line 290
          range = bound;
#line 290
          *(probLen + len) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 290
          len += len;
        } else {
#line 290
          range -= bound;
#line 290
          code -= bound;
#line 290
          *(probLen + len) = (UInt16 )(ttt - (ttt >> 5));
#line 290
          len = (len + len) + 1U;
        }
#line 290
        if (! (len < limit___0)) {
#line 290
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 290
      len -= limit___0;
#line 291
      len += offset;
#line 294
      if (state >= 12U) {
#line 297
        if (len < 4U) {
#line 297
          tmp___16 = len;
        } else {
#line 297
          tmp___16 = 3U;
        }
#line 297
        prob = (probs + ((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4))) + (tmp___16 << 6);
#line 299
        distance___0 = (UInt32 )1;
#line 299
        ttt = (unsigned int )*(prob + distance___0);
#line 299
        if (range < 1U << 24) {
#line 299
          range <<= 8;
#line 299
          tmp___17 = buf;
#line 299
          buf ++;
#line 299
          code = (code << 8) | (unsigned int )*tmp___17;
        }
#line 299
        bound = (range >> 11) * ttt;
#line 299
        if (code < bound) {
#line 299
          range = bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 299
          distance___0 += distance___0;
        } else {
#line 299
          range -= bound;
#line 299
          code -= bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt - (ttt >> 5));
#line 299
          distance___0 = (distance___0 + distance___0) + 1U;
        }
#line 299
        ttt = (unsigned int )*(prob + distance___0);
#line 299
        if (range < 1U << 24) {
#line 299
          range <<= 8;
#line 299
          tmp___18 = buf;
#line 299
          buf ++;
#line 299
          code = (code << 8) | (unsigned int )*tmp___18;
        }
#line 299
        bound = (range >> 11) * ttt;
#line 299
        if (code < bound) {
#line 299
          range = bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 299
          distance___0 += distance___0;
        } else {
#line 299
          range -= bound;
#line 299
          code -= bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt - (ttt >> 5));
#line 299
          distance___0 = (distance___0 + distance___0) + 1U;
        }
#line 299
        ttt = (unsigned int )*(prob + distance___0);
#line 299
        if (range < 1U << 24) {
#line 299
          range <<= 8;
#line 299
          tmp___19 = buf;
#line 299
          buf ++;
#line 299
          code = (code << 8) | (unsigned int )*tmp___19;
        }
#line 299
        bound = (range >> 11) * ttt;
#line 299
        if (code < bound) {
#line 299
          range = bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 299
          distance___0 += distance___0;
        } else {
#line 299
          range -= bound;
#line 299
          code -= bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt - (ttt >> 5));
#line 299
          distance___0 = (distance___0 + distance___0) + 1U;
        }
#line 299
        ttt = (unsigned int )*(prob + distance___0);
#line 299
        if (range < 1U << 24) {
#line 299
          range <<= 8;
#line 299
          tmp___20 = buf;
#line 299
          buf ++;
#line 299
          code = (code << 8) | (unsigned int )*tmp___20;
        }
#line 299
        bound = (range >> 11) * ttt;
#line 299
        if (code < bound) {
#line 299
          range = bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 299
          distance___0 += distance___0;
        } else {
#line 299
          range -= bound;
#line 299
          code -= bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt - (ttt >> 5));
#line 299
          distance___0 = (distance___0 + distance___0) + 1U;
        }
#line 299
        ttt = (unsigned int )*(prob + distance___0);
#line 299
        if (range < 1U << 24) {
#line 299
          range <<= 8;
#line 299
          tmp___21 = buf;
#line 299
          buf ++;
#line 299
          code = (code << 8) | (unsigned int )*tmp___21;
        }
#line 299
        bound = (range >> 11) * ttt;
#line 299
        if (code < bound) {
#line 299
          range = bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 299
          distance___0 += distance___0;
        } else {
#line 299
          range -= bound;
#line 299
          code -= bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt - (ttt >> 5));
#line 299
          distance___0 = (distance___0 + distance___0) + 1U;
        }
#line 299
        ttt = (unsigned int )*(prob + distance___0);
#line 299
        if (range < 1U << 24) {
#line 299
          range <<= 8;
#line 299
          tmp___22 = buf;
#line 299
          buf ++;
#line 299
          code = (code << 8) | (unsigned int )*tmp___22;
        }
#line 299
        bound = (range >> 11) * ttt;
#line 299
        if (code < bound) {
#line 299
          range = bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 299
          distance___0 += distance___0;
        } else {
#line 299
          range -= bound;
#line 299
          code -= bound;
#line 299
          *(prob + distance___0) = (UInt16 )(ttt - (ttt >> 5));
#line 299
          distance___0 = (distance___0 + distance___0) + 1U;
        }
#line 299
        distance___0 -= 64U;
#line 300
        if (distance___0 >= 4U) {
#line 302
          posSlot = distance___0;
#line 303
          numDirectBits = (int )((distance___0 >> 1) - 1U);
#line 304
          distance___0 = 2U | (distance___0 & 1U);
#line 305
          if (posSlot < 14U) {
#line 307
            distance___0 <<= numDirectBits;
#line 308
            prob = (((probs + (((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6))) + distance___0) - posSlot) - 1;
#line 310
            mask = (UInt32 )1;
#line 311
            i = 1U;
            {
#line 312
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 314
              ttt = (unsigned int )*(prob + i);
#line 314
              if (range < 1U << 24) {
#line 314
                range <<= 8;
#line 314
                tmp___23 = buf;
#line 314
                buf ++;
#line 314
                code = (code << 8) | (unsigned int )*tmp___23;
              }
#line 314
              bound = (range >> 11) * ttt;
#line 314
              if (code < bound) {
#line 314
                range = bound;
#line 314
                *(prob + i) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 314
                i += i;
              } else {
#line 314
                range -= bound;
#line 314
                code -= bound;
#line 314
                *(prob + i) = (UInt16 )(ttt - (ttt >> 5));
#line 314
                i = (i + i) + 1U;
#line 314
                distance___0 |= mask;
              }
#line 315
              mask <<= 1;
#line 312
              numDirectBits --;
#line 312
              if (! (numDirectBits != 0)) {
#line 312
                goto while_break___3;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          } else {
#line 322
            numDirectBits -= 4;
            {
#line 323
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 325
              if (range < 1U << 24) {
#line 325
                range <<= 8;
#line 325
                tmp___24 = buf;
#line 325
                buf ++;
#line 325
                code = (code << 8) | (unsigned int )*tmp___24;
              }
#line 326
              range >>= 1;
#line 330
              code -= range;
#line 331
              t = 0U - (code >> 31);
#line 332
              distance___0 = (distance___0 << 1) + (t + 1U);
#line 333
              code += range & t;
#line 323
              numDirectBits --;
#line 323
              if (! (numDirectBits != 0)) {
#line 323
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 345
            prob = probs + (((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14);
#line 346
            distance___0 <<= 4;
#line 348
            i___0 = 1U;
#line 349
            ttt = (unsigned int )*(prob + i___0);
#line 349
            if (range < 1U << 24) {
#line 349
              range <<= 8;
#line 349
              tmp___25 = buf;
#line 349
              buf ++;
#line 349
              code = (code << 8) | (unsigned int )*tmp___25;
            }
#line 349
            bound = (range >> 11) * ttt;
#line 349
            if (code < bound) {
#line 349
              range = bound;
#line 349
              *(prob + i___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 349
              i___0 += i___0;
            } else {
#line 349
              range -= bound;
#line 349
              code -= bound;
#line 349
              *(prob + i___0) = (UInt16 )(ttt - (ttt >> 5));
#line 349
              i___0 = (i___0 + i___0) + 1U;
#line 349
              distance___0 |= 1U;
            }
#line 350
            ttt = (unsigned int )*(prob + i___0);
#line 350
            if (range < 1U << 24) {
#line 350
              range <<= 8;
#line 350
              tmp___26 = buf;
#line 350
              buf ++;
#line 350
              code = (code << 8) | (unsigned int )*tmp___26;
            }
#line 350
            bound = (range >> 11) * ttt;
#line 350
            if (code < bound) {
#line 350
              range = bound;
#line 350
              *(prob + i___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 350
              i___0 += i___0;
            } else {
#line 350
              range -= bound;
#line 350
              code -= bound;
#line 350
              *(prob + i___0) = (UInt16 )(ttt - (ttt >> 5));
#line 350
              i___0 = (i___0 + i___0) + 1U;
#line 350
              distance___0 |= 2U;
            }
#line 351
            ttt = (unsigned int )*(prob + i___0);
#line 351
            if (range < 1U << 24) {
#line 351
              range <<= 8;
#line 351
              tmp___27 = buf;
#line 351
              buf ++;
#line 351
              code = (code << 8) | (unsigned int )*tmp___27;
            }
#line 351
            bound = (range >> 11) * ttt;
#line 351
            if (code < bound) {
#line 351
              range = bound;
#line 351
              *(prob + i___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 351
              i___0 += i___0;
            } else {
#line 351
              range -= bound;
#line 351
              code -= bound;
#line 351
              *(prob + i___0) = (UInt16 )(ttt - (ttt >> 5));
#line 351
              i___0 = (i___0 + i___0) + 1U;
#line 351
              distance___0 |= 4U;
            }
#line 352
            ttt = (unsigned int )*(prob + i___0);
#line 352
            if (range < 1U << 24) {
#line 352
              range <<= 8;
#line 352
              tmp___28 = buf;
#line 352
              buf ++;
#line 352
              code = (code << 8) | (unsigned int )*tmp___28;
            }
#line 352
            bound = (range >> 11) * ttt;
#line 352
            if (code < bound) {
#line 352
              range = bound;
#line 352
              *(prob + i___0) = (UInt16 )(ttt + (((unsigned int )(1 << 11) - ttt) >> 5));
#line 352
              i___0 += i___0;
            } else {
#line 352
              range -= bound;
#line 352
              code -= bound;
#line 352
              *(prob + i___0) = (UInt16 )(ttt - (ttt >> 5));
#line 352
              i___0 = (i___0 + i___0) + 1U;
#line 352
              distance___0 |= 8U;
            }
#line 354
            if (distance___0 == 4294967295U) {
#line 356
              len += (unsigned int )(((2 + (1 << 3)) + (1 << 3)) + (1 << 8));
#line 357
              state -= 12U;
#line 358
              goto while_break;
            }
          }
        }
#line 362
        rep3 = rep2;
#line 363
        rep2 = rep1;
#line 364
        rep1 = rep0;
#line 365
        rep0 = distance___0 + 1U;
#line 366
        if (checkDicSize == 0U) {
#line 368
          if (distance___0 >= processedPos) {
#line 369
            return (1);
          }
        } else
#line 371
        if (distance___0 >= checkDicSize) {
#line 372
          return (1);
        }
#line 373
        if (state < 19U) {
#line 373
          state = 7U;
        } else {
#line 373
          state = 10U;
        }
      }
#line 376
      len += 2U;
#line 378
      if (limit == dicPos) {
#line 379
        return (1);
      }
#line 381
      rem = limit - dicPos;
#line 382
      if (rem < (SizeT )len) {
#line 382
        tmp___29 = (unsigned int )rem;
      } else {
#line 382
        tmp___29 = len;
      }
#line 382
      curLen = tmp___29;
#line 383
      if (dicPos < (SizeT )rep0) {
#line 383
        tmp___30 = dicBufSize;
      } else {
#line 383
        tmp___30 = (SizeT )0;
      }
#line 383
      pos = (dicPos - (SizeT )rep0) + tmp___30;
#line 385
      processedPos += curLen;
#line 387
      len -= curLen;
#line 388
      if (pos + (SizeT )curLen <= dicBufSize) {
#line 390
        dest = dic + dicPos;
#line 391
        src = (ptrdiff_t )pos - (ptrdiff_t )dicPos;
#line 392
        lim = (Byte const   *)(dest + curLen);
#line 393
        dicPos += (SizeT )curLen;
        {
#line 394
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 395
          *dest = *(dest + src);
#line 394
          dest ++;
#line 394
          if (! ((unsigned long )dest != (unsigned long )lim)) {
#line 394
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 400
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 402
          tmp___31 = dicPos;
#line 402
          dicPos ++;
#line 402
          *(dic + tmp___31) = *(dic + pos);
#line 403
          pos ++;
#line 403
          if (pos == dicBufSize) {
#line 404
            pos = (SizeT )0;
          }
#line 400
          curLen --;
#line 400
          if (! (curLen != 0U)) {
#line 400
            goto while_break___6;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 153
    if (dicPos < limit) {
#line 153
      if (! ((unsigned long )buf < (unsigned long )bufLimit)) {
#line 153
        goto while_break;
      }
    } else {
#line 153
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  if (range < 1U << 24) {
#line 412
    range <<= 8;
#line 412
    tmp___32 = buf;
#line 412
    buf ++;
#line 412
    code = (code << 8) | (unsigned int )*tmp___32;
  }
#line 413
  p->buf = buf;
#line 414
  p->range = range;
#line 415
  p->code = code;
#line 416
  p->remainLen = len;
#line 417
  p->dicPos = dicPos;
#line 418
  p->processedPos = processedPos;
#line 419
  p->reps[0] = rep0;
#line 420
  p->reps[1] = rep1;
#line 421
  p->reps[2] = rep2;
#line 422
  p->reps[3] = rep3;
#line 423
  p->state = state;
#line 425
  return (0);
}
}
#line 428 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static void LzmaDec_WriteRem(CLzmaDec *p , SizeT limit ) 
{ 
  Byte *dic ;
  SizeT dicPos ;
  SizeT dicBufSize ;
  unsigned int len ;
  UInt32 rep0 ;
  SizeT tmp ;
  unsigned int tmp___0 ;

  {
#line 430
  if (p->remainLen != 0U) {
#line 430
    if (p->remainLen < (unsigned int )(((2 + (1 << 3)) + (1 << 3)) + (1 << 8))) {
#line 432
      dic = p->dic;
#line 433
      dicPos = p->dicPos;
#line 434
      dicBufSize = p->dicBufSize;
#line 435
      len = p->remainLen;
#line 436
      rep0 = p->reps[0];
#line 437
      if (limit - dicPos < (SizeT )len) {
#line 438
        len = (unsigned int )(limit - dicPos);
      }
#line 440
      if (p->checkDicSize == 0U) {
#line 440
        if (p->prop.dicSize - p->processedPos <= len) {
#line 441
          p->checkDicSize = p->prop.dicSize;
        }
      }
#line 443
      p->processedPos += len;
#line 444
      p->remainLen -= len;
      {
#line 445
      while (1) {
        while_continue: /* CIL Label */ ;
#line 445
        tmp___0 = len;
#line 445
        len --;
#line 445
        if (! (tmp___0 != 0U)) {
#line 445
          goto while_break;
        }
#line 447
        if (dicPos < (SizeT )rep0) {
#line 447
          tmp = dicBufSize;
        } else {
#line 447
          tmp = (SizeT )0;
        }
#line 447
        *(dic + dicPos) = *(dic + ((dicPos - (SizeT )rep0) + tmp));
#line 448
        dicPos ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 450
      p->dicPos = dicPos;
    }
  }
#line 452
  return;
}
}
#line 454 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static int LzmaDec_DecodeReal2(CLzmaDec *p , SizeT limit , Byte const   *bufLimit ) 
{ 
  SizeT limit2 ;
  UInt32 rem ;
  int __result__ ;
  int tmp ;

  {
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    limit2 = limit;
#line 459
    if (p->checkDicSize == 0U) {
#line 461
      rem = p->prop.dicSize - p->processedPos;
#line 462
      if (limit - p->dicPos > (SizeT )rem) {
#line 463
        limit2 = p->dicPos + (SizeT )rem;
      }
    }
    {
#line 465
    tmp = LzmaDec_DecodeReal(p, limit2, bufLimit);
#line 465
    __result__ = tmp;
    }
#line 465
    if (__result__ != 0) {
#line 465
      return (__result__);
    }
#line 466
    if (p->processedPos >= p->prop.dicSize) {
#line 467
      p->checkDicSize = p->prop.dicSize;
    }
    {
#line 468
    LzmaDec_WriteRem(p, limit);
    }
#line 456
    if (p->dicPos < limit) {
#line 456
      if ((unsigned long )p->buf < (unsigned long )bufLimit) {
#line 456
        if (! (p->remainLen < (unsigned int )(((2 + (1 << 3)) + (1 << 3)) + (1 << 8)))) {
#line 456
          goto while_break;
        }
      } else {
#line 456
        goto while_break;
      }
    } else {
#line 456
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  if (p->remainLen > (unsigned int )(((2 + (1 << 3)) + (1 << 3)) + (1 << 8))) {
#line 474
    p->remainLen = (unsigned int )(((2 + (1 << 3)) + (1 << 3)) + (1 << 8));
  }
#line 476
  return (0);
}
}
#line 487 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static ELzmaDummy LzmaDec_TryDummy(CLzmaDec const   *p , Byte const   *buf , SizeT inSize ) 
{ 
  UInt32 range ;
  UInt32 code ;
  Byte const   *bufLimit ;
  UInt16 *probs ;
  unsigned int state ;
  ELzmaDummy res ;
  UInt16 *prob ;
  UInt32 bound ;
  unsigned int ttt ;
  unsigned int posState ;
  Byte const   *tmp ;
  SizeT tmp___0 ;
  unsigned int symbol ;
  Byte const   *tmp___1 ;
  unsigned int matchByte ;
  SizeT tmp___2 ;
  unsigned int offs ;
  unsigned int symbol___0 ;
  unsigned int bit ;
  UInt16 *probLit ;
  Byte const   *tmp___3 ;
  unsigned int len ;
  Byte const   *tmp___4 ;
  Byte const   *tmp___5 ;
  Byte const   *tmp___6 ;
  Byte const   *tmp___7 ;
  Byte const   *tmp___8 ;
  Byte const   *tmp___9 ;
  unsigned int limit ;
  unsigned int offset ;
  UInt16 *probLen ;
  Byte const   *tmp___10 ;
  Byte const   *tmp___11 ;
  Byte const   *tmp___12 ;
  unsigned int posSlot ;
  unsigned int tmp___13 ;
  Byte const   *tmp___14 ;
  int numDirectBits ;
  Byte const   *tmp___15 ;
  unsigned int i ;
  Byte const   *tmp___16 ;
  Byte const   *tmp___17 ;

  {
#line 489
  range = (UInt32 )p->range;
#line 490
  code = (UInt32 )p->code;
#line 491
  bufLimit = buf + inSize;
#line 492
  probs = (UInt16 *)p->probs;
#line 493
  state = (unsigned int )p->state;
#line 500
  posState = (unsigned int )(p->processedPos & (unsigned int const   )((1 << p->prop.pb) - 1));
#line 502
  prob = ((probs + 0) + (state << 4)) + posState;
#line 503
  ttt = (unsigned int )*prob;
#line 503
  if (range < 1U << 24) {
#line 503
    if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 503
      return ((ELzmaDummy )0);
    }
#line 503
    range <<= 8;
#line 503
    tmp = buf;
#line 503
    buf ++;
#line 503
    code = (code << 8) | (unsigned int )*tmp;
  }
#line 503
  bound = (range >> 11) * ttt;
#line 503
  if (code < bound) {
#line 505
    range = bound;
#line 509
    prob = probs + ((((((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14) + (1 << 4)) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8))) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8)));
#line 510
    if (p->checkDicSize != 0U) {
#line 510
      goto _L;
    } else
#line 510
    if (p->processedPos != 0U) {
      _L: /* CIL Label */ 
#line 511
      if (p->dicPos == 0UL) {
#line 511
        tmp___0 = p->dicBufSize;
      } else {
#line 511
        tmp___0 = p->dicPos;
      }
#line 511
      prob += 768U * (((p->processedPos & (unsigned int const   )((1 << p->prop.lp) - 1)) << p->prop.lc) + (unsigned int const   )((int )*(p->dic + (tmp___0 - 1UL)) >> (8U - p->prop.lc)));
    }
#line 515
    if (state < 7U) {
#line 517
      symbol = 1U;
      {
#line 518
      while (1) {
        while_continue: /* CIL Label */ ;
#line 518
        ttt = (unsigned int )*(prob + symbol);
#line 518
        if (range < 1U << 24) {
#line 518
          if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 518
            return ((ELzmaDummy )0);
          }
#line 518
          range <<= 8;
#line 518
          tmp___1 = buf;
#line 518
          buf ++;
#line 518
          code = (code << 8) | (unsigned int )*tmp___1;
        }
#line 518
        bound = (range >> 11) * ttt;
#line 518
        if (code < bound) {
#line 518
          range = bound;
#line 518
          symbol += symbol;
        } else {
#line 518
          range -= bound;
#line 518
          code -= bound;
#line 518
          symbol = (symbol + symbol) + 1U;
        }
#line 518
        if (! (symbol < 256U)) {
#line 518
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 522
      if (p->dicPos < (SizeT const   )p->reps[0]) {
#line 522
        tmp___2 = p->dicBufSize;
      } else {
#line 522
        tmp___2 = (SizeT const   )0;
      }
#line 522
      matchByte = (unsigned int )*(p->dic + ((p->dicPos - (SizeT const   )p->reps[0]) + tmp___2));
#line 524
      offs = 256U;
#line 525
      symbol___0 = 1U;
      {
#line 526
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 530
        matchByte <<= 1;
#line 531
        bit = matchByte & offs;
#line 532
        probLit = ((prob + offs) + bit) + symbol___0;
#line 533
        ttt = (unsigned int )*probLit;
#line 533
        if (range < 1U << 24) {
#line 533
          if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 533
            return ((ELzmaDummy )0);
          }
#line 533
          range <<= 8;
#line 533
          tmp___3 = buf;
#line 533
          buf ++;
#line 533
          code = (code << 8) | (unsigned int )*tmp___3;
        }
#line 533
        bound = (range >> 11) * ttt;
#line 533
        if (code < bound) {
#line 533
          range = bound;
#line 533
          symbol___0 += symbol___0;
#line 533
          offs &= ~ bit;
        } else {
#line 533
          range -= bound;
#line 533
          code -= bound;
#line 533
          symbol___0 = (symbol___0 + symbol___0) + 1U;
#line 533
          offs &= bit;
        }
#line 526
        if (! (symbol___0 < 256U)) {
#line 526
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 537
    res = (ELzmaDummy )1;
  } else {
#line 542
    range -= bound;
#line 542
    code -= bound;
#line 544
    prob = (probs + (12 << 4)) + state;
#line 545
    ttt = (unsigned int )*prob;
#line 545
    if (range < 1U << 24) {
#line 545
      if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 545
        return ((ELzmaDummy )0);
      }
#line 545
      range <<= 8;
#line 545
      tmp___4 = buf;
#line 545
      buf ++;
#line 545
      code = (code << 8) | (unsigned int )*tmp___4;
    }
#line 545
    bound = (range >> 11) * ttt;
#line 545
    if (code < bound) {
#line 547
      range = bound;
#line 548
      state = 0U;
#line 549
      prob = probs + ((((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14) + (1 << 4));
#line 550
      res = (ELzmaDummy )2;
    } else {
#line 554
      range -= bound;
#line 554
      code -= bound;
#line 555
      res = (ELzmaDummy )3;
#line 556
      prob = (probs + ((12 << 4) + 12)) + state;
#line 557
      ttt = (unsigned int )*prob;
#line 557
      if (range < 1U << 24) {
#line 557
        if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 557
          return ((ELzmaDummy )0);
        }
#line 557
        range <<= 8;
#line 557
        tmp___5 = buf;
#line 557
        buf ++;
#line 557
        code = (code << 8) | (unsigned int )*tmp___5;
      }
#line 557
      bound = (range >> 11) * ttt;
#line 557
      if (code < bound) {
#line 559
        range = bound;
#line 560
        prob = ((probs + (((((12 << 4) + 12) + 12) + 12) + 12)) + (state << 4)) + posState;
#line 561
        ttt = (unsigned int )*prob;
#line 561
        if (range < 1U << 24) {
#line 561
          if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 561
            return ((ELzmaDummy )0);
          }
#line 561
          range <<= 8;
#line 561
          tmp___6 = buf;
#line 561
          buf ++;
#line 561
          code = (code << 8) | (unsigned int )*tmp___6;
        }
#line 561
        bound = (range >> 11) * ttt;
#line 561
        if (code < bound) {
#line 563
          range = bound;
#line 564
          if (range < 1U << 24) {
#line 564
            if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 564
              return ((ELzmaDummy )0);
            }
#line 564
            range <<= 8;
#line 564
            tmp___7 = buf;
#line 564
            buf ++;
#line 564
            code = (code << 8) | (unsigned int )*tmp___7;
          }
#line 565
          return ((ELzmaDummy )3);
        } else {
#line 569
          range -= bound;
#line 569
          code -= bound;
        }
      } else {
#line 574
        range -= bound;
#line 574
        code -= bound;
#line 575
        prob = (probs + (((12 << 4) + 12) + 12)) + state;
#line 576
        ttt = (unsigned int )*prob;
#line 576
        if (range < 1U << 24) {
#line 576
          if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 576
            return ((ELzmaDummy )0);
          }
#line 576
          range <<= 8;
#line 576
          tmp___8 = buf;
#line 576
          buf ++;
#line 576
          code = (code << 8) | (unsigned int )*tmp___8;
        }
#line 576
        bound = (range >> 11) * ttt;
#line 576
        if (code < bound) {
#line 578
          range = bound;
        } else {
#line 582
          range -= bound;
#line 582
          code -= bound;
#line 583
          prob = (probs + ((((12 << 4) + 12) + 12) + 12)) + state;
#line 584
          ttt = (unsigned int )*prob;
#line 584
          if (range < 1U << 24) {
#line 584
            if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 584
              return ((ELzmaDummy )0);
            }
#line 584
            range <<= 8;
#line 584
            tmp___9 = buf;
#line 584
            buf ++;
#line 584
            code = (code << 8) | (unsigned int )*tmp___9;
          }
#line 584
          bound = (range >> 11) * ttt;
#line 584
          if (code < bound) {
#line 586
            range = bound;
          } else {
#line 590
            range -= bound;
#line 590
            code -= bound;
          }
        }
      }
#line 594
      state = 12U;
#line 595
      prob = probs + (((((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14) + (1 << 4)) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8)));
    }
#line 599
    probLen = prob + 0;
#line 600
    ttt = (unsigned int )*probLen;
#line 600
    if (range < 1U << 24) {
#line 600
      if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 600
        return ((ELzmaDummy )0);
      }
#line 600
      range <<= 8;
#line 600
      tmp___10 = buf;
#line 600
      buf ++;
#line 600
      code = (code << 8) | (unsigned int )*tmp___10;
    }
#line 600
    bound = (range >> 11) * ttt;
#line 600
    if (code < bound) {
#line 602
      range = bound;
#line 603
      probLen = (prob + 2) + (posState << 3);
#line 604
      offset = 0U;
#line 605
      limit = (unsigned int )(1 << 3);
    } else {
#line 609
      range -= bound;
#line 609
      code -= bound;
#line 610
      probLen = prob + 1;
#line 611
      ttt = (unsigned int )*probLen;
#line 611
      if (range < 1U << 24) {
#line 611
        if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 611
          return ((ELzmaDummy )0);
        }
#line 611
        range <<= 8;
#line 611
        tmp___11 = buf;
#line 611
        buf ++;
#line 611
        code = (code << 8) | (unsigned int )*tmp___11;
      }
#line 611
      bound = (range >> 11) * ttt;
#line 611
      if (code < bound) {
#line 613
        range = bound;
#line 614
        probLen = (prob + (2 + ((1 << 4) << 3))) + (posState << 3);
#line 615
        offset = (unsigned int )(1 << 3);
#line 616
        limit = (unsigned int )(1 << 3);
      } else {
#line 620
        range -= bound;
#line 620
        code -= bound;
#line 621
        probLen = prob + ((2 + ((1 << 4) << 3)) + ((1 << 4) << 3));
#line 622
        offset = (unsigned int )((1 << 3) + (1 << 3));
#line 623
        limit = (unsigned int )(1 << 8);
      }
    }
#line 626
    len = 1U;
    {
#line 626
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 626
      ttt = (unsigned int )*(probLen + len);
#line 626
      if (range < 1U << 24) {
#line 626
        if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 626
          return ((ELzmaDummy )0);
        }
#line 626
        range <<= 8;
#line 626
        tmp___12 = buf;
#line 626
        buf ++;
#line 626
        code = (code << 8) | (unsigned int )*tmp___12;
      }
#line 626
      bound = (range >> 11) * ttt;
#line 626
      if (code < bound) {
#line 626
        range = bound;
#line 626
        len += len;
      } else {
#line 626
        range -= bound;
#line 626
        code -= bound;
#line 626
        len = (len + len) + 1U;
      }
#line 626
      if (! (len < limit)) {
#line 626
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 626
    len -= limit;
#line 627
    len += offset;
#line 630
    if (state < 4U) {
#line 633
      if (len < 4U) {
#line 633
        tmp___13 = len;
      } else {
#line 633
        tmp___13 = 3U;
      }
#line 633
      prob = (probs + ((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4))) + (tmp___13 << 6);
#line 636
      posSlot = 1U;
      {
#line 636
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 636
        ttt = (unsigned int )*(prob + posSlot);
#line 636
        if (range < 1U << 24) {
#line 636
          if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 636
            return ((ELzmaDummy )0);
          }
#line 636
          range <<= 8;
#line 636
          tmp___14 = buf;
#line 636
          buf ++;
#line 636
          code = (code << 8) | (unsigned int )*tmp___14;
        }
#line 636
        bound = (range >> 11) * ttt;
#line 636
        if (code < bound) {
#line 636
          range = bound;
#line 636
          posSlot += posSlot;
        } else {
#line 636
          range -= bound;
#line 636
          code -= bound;
#line 636
          posSlot = (posSlot + posSlot) + 1U;
        }
#line 636
        if (! (posSlot < (unsigned int )(1 << 6))) {
#line 636
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 636
      posSlot -= (unsigned int )(1 << 6);
#line 637
      if (posSlot >= 4U) {
#line 639
        numDirectBits = (int )((posSlot >> 1) - 1U);
#line 643
        if (posSlot < 14U) {
#line 645
          prob = (((probs + (((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6))) + ((2U | (posSlot & 1U)) << numDirectBits)) - posSlot) - 1;
        } else {
#line 649
          numDirectBits -= 4;
          {
#line 650
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 652
            if (range < 1U << 24) {
#line 652
              if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 652
                return ((ELzmaDummy )0);
              }
#line 652
              range <<= 8;
#line 652
              tmp___15 = buf;
#line 652
              buf ++;
#line 652
              code = (code << 8) | (unsigned int )*tmp___15;
            }
#line 653
            range >>= 1;
#line 654
            code -= range & (((code - range) >> 31) - 1U);
#line 650
            numDirectBits --;
#line 650
            if (! (numDirectBits != 0)) {
#line 650
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 658
          prob = probs + (((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14);
#line 659
          numDirectBits = 4;
        }
#line 662
        i = 1U;
        {
#line 663
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 665
          ttt = (unsigned int )*(prob + i);
#line 665
          if (range < 1U << 24) {
#line 665
            if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 665
              return ((ELzmaDummy )0);
            }
#line 665
            range <<= 8;
#line 665
            tmp___16 = buf;
#line 665
            buf ++;
#line 665
            code = (code << 8) | (unsigned int )*tmp___16;
          }
#line 665
          bound = (range >> 11) * ttt;
#line 665
          if (code < bound) {
#line 665
            range = bound;
#line 665
            i += i;
          } else {
#line 665
            range -= bound;
#line 665
            code -= bound;
#line 665
            i = (i + i) + 1U;
          }
#line 663
          numDirectBits --;
#line 663
          if (! (numDirectBits != 0)) {
#line 663
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
  }
#line 673
  if (range < 1U << 24) {
#line 673
    if ((unsigned long )buf >= (unsigned long )bufLimit) {
#line 673
      return ((ELzmaDummy )0);
    }
#line 673
    range <<= 8;
#line 673
    tmp___17 = buf;
#line 673
    buf ++;
#line 673
    code = (code << 8) | (unsigned int )*tmp___17;
  }
#line 674
  return (res);
}
}
#line 678 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static void LzmaDec_InitRc(CLzmaDec *p , Byte const   *data ) 
{ 


  {
#line 680
  p->code = ((((UInt32 )*(data + 1) << 24) | ((UInt32 )*(data + 2) << 16)) | ((UInt32 )*(data + 3) << 8)) | (UInt32 )*(data + 4);
#line 681
  p->range = 4294967295U;
#line 682
  p->needFlush = 0;
#line 683
  return;
}
}
#line 685 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
void LzmaDec_InitDicAndState(CLzmaDec *p , Bool initDic , Bool initState ) 
{ 


  {
#line 687
  p->needFlush = 1;
#line 688
  p->remainLen = 0U;
#line 689
  p->tempBufSize = 0U;
#line 691
  if (initDic) {
#line 693
    p->processedPos = (UInt32 )0;
#line 694
    p->checkDicSize = (UInt32 )0;
#line 695
    p->needInitState = 1;
  }
#line 697
  if (initState) {
#line 698
    p->needInitState = 1;
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
void LzmaDec_Init(CLzmaDec *p ) 
{ 


  {
  {
#line 703
  p->dicPos = (SizeT )0;
#line 704
  LzmaDec_InitDicAndState(p, 1, 1);
  }
#line 705
  return;
}
}
#line 707 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static void LzmaDec_InitStateReal(CLzmaDec *p ) 
{ 
  UInt32 numProbs ;
  UInt32 i ;
  UInt16 *probs ;
  UInt32 tmp ;
  UInt32 tmp___0 ;
  UInt32 tmp___1 ;

  {
#line 709
  numProbs = (UInt32 )((((((((((((12 << 4) + 12) + 12) + 12) + 12) + (12 << 4)) + (4 << 6)) + (1 << (14 >> 1))) - 14) + (1 << 4)) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8))) + (((2 + ((1 << 4) << 3)) + ((1 << 4) << 3)) + (1 << 8))) + (768U << (p->prop.lc + p->prop.lp));
#line 711
  probs = p->probs;
#line 712
  i = (UInt32 )0;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! (i < numProbs)) {
#line 712
      goto while_break;
    }
#line 713
    *(probs + i) = (UInt16 )((1 << 11) >> 1);
#line 712
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  tmp___1 = (UInt32 )1;
#line 714
  p->reps[3] = tmp___1;
#line 714
  tmp___0 = tmp___1;
#line 714
  p->reps[2] = tmp___0;
#line 714
  tmp = tmp___0;
#line 714
  p->reps[1] = tmp;
#line 714
  p->reps[0] = tmp;
#line 715
  p->state = 0U;
#line 716
  p->needInitState = 0;
#line 717
  return;
}
}
#line 719 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
SRes LzmaDec_DecodeToDic(CLzmaDec *p , SizeT dicLimit , Byte const   *src , SizeT *srcLen ,
                         ELzmaFinishMode finishMode , ELzmaStatus *status ) 
{ 
  SizeT inSize ;
  int checkEndMarkNow ;
  unsigned int tmp ;
  Byte const   *tmp___0 ;
  SizeT processed ;
  Byte const   *bufLimit ;
  int dummyRes ;
  ELzmaDummy tmp___1 ;
  int tmp___2 ;
  unsigned int rem ;
  unsigned int lookAhead ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int dummyRes___0 ;
  ELzmaDummy tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 722
  inSize = *srcLen;
#line 723
  *srcLen = (SizeT )0;
#line 724
  LzmaDec_WriteRem(p, dicLimit);
#line 726
  *status = (ELzmaStatus )0;
  }
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (! (p->remainLen != (unsigned int )(((2 + (1 << 3)) + (1 << 3)) + (1 << 8)))) {
#line 728
      goto while_break;
    }
#line 732
    if (p->needFlush != 0) {
      {
#line 734
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 734
        if (inSize > 0UL) {
#line 734
          if (! (p->tempBufSize < 5U)) {
#line 734
            goto while_break___0;
          }
        } else {
#line 734
          goto while_break___0;
        }
#line 735
        tmp = p->tempBufSize;
#line 735
        (p->tempBufSize) ++;
#line 735
        tmp___0 = src;
#line 735
        src ++;
#line 735
        p->tempBuf[tmp] = (Byte )*tmp___0;
#line 734
        (*srcLen) ++;
#line 734
        inSize --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 736
      if (p->tempBufSize < 5U) {
#line 738
        *status = (ELzmaStatus )3;
#line 739
        return (0);
      }
#line 741
      if ((int )p->tempBuf[0] != 0) {
#line 742
        return (1);
      }
      {
#line 744
      LzmaDec_InitRc(p, (Byte const   *)(p->tempBuf));
#line 745
      p->tempBufSize = 0U;
      }
    }
#line 748
    checkEndMarkNow = 0;
#line 749
    if (p->dicPos >= dicLimit) {
#line 751
      if (p->remainLen == 0U) {
#line 751
        if (p->code == 0U) {
#line 753
          *status = (ELzmaStatus )4;
#line 754
          return (0);
        }
      }
#line 756
      if ((unsigned int )finishMode == 0U) {
#line 758
        *status = (ELzmaStatus )2;
#line 759
        return (0);
      }
#line 761
      if (p->remainLen != 0U) {
#line 763
        *status = (ELzmaStatus )2;
#line 764
        return (1);
      }
#line 766
      checkEndMarkNow = 1;
    }
#line 769
    if (p->needInitState) {
      {
#line 770
      LzmaDec_InitStateReal(p);
      }
    }
#line 772
    if (p->tempBufSize == 0U) {
#line 776
      if (inSize < 20UL) {
#line 776
        goto _L;
      } else
#line 776
      if (checkEndMarkNow) {
        _L: /* CIL Label */ 
        {
#line 778
        tmp___1 = LzmaDec_TryDummy((CLzmaDec const   *)p, src, inSize);
#line 778
        dummyRes = (int )tmp___1;
        }
#line 779
        if (dummyRes == 0) {
          {
#line 781
          memcpy((void */* __restrict  */)(p->tempBuf), (void const   */* __restrict  */)src,
                 inSize);
#line 782
          p->tempBufSize = (unsigned int )inSize;
#line 783
          *srcLen += inSize;
#line 784
          *status = (ELzmaStatus )3;
          }
#line 785
          return (0);
        }
#line 787
        if (checkEndMarkNow) {
#line 787
          if (dummyRes != 2) {
#line 789
            *status = (ELzmaStatus )2;
#line 790
            return (1);
          }
        }
#line 792
        bufLimit = src;
      } else {
#line 795
        bufLimit = (src + inSize) - 20;
      }
      {
#line 796
      p->buf = src;
#line 797
      tmp___2 = LzmaDec_DecodeReal2(p, dicLimit, bufLimit);
      }
#line 797
      if (tmp___2 != 0) {
#line 798
        return (1);
      }
#line 799
      processed = (SizeT )(p->buf - src);
#line 800
      *srcLen += processed;
#line 801
      src += processed;
#line 802
      inSize -= processed;
    } else {
#line 806
      rem = p->tempBufSize;
#line 806
      lookAhead = 0U;
      {
#line 807
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 807
        if (rem < 20U) {
#line 807
          if (! ((SizeT )lookAhead < inSize)) {
#line 807
            goto while_break___1;
          }
        } else {
#line 807
          goto while_break___1;
        }
#line 808
        tmp___3 = rem;
#line 808
        rem ++;
#line 808
        tmp___4 = lookAhead;
#line 808
        lookAhead ++;
#line 808
        p->tempBuf[tmp___3] = (Byte )*(src + tmp___4);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 809
      p->tempBufSize = rem;
#line 810
      if (rem < 20U) {
#line 810
        goto _L___0;
      } else
#line 810
      if (checkEndMarkNow) {
        _L___0: /* CIL Label */ 
        {
#line 812
        tmp___5 = LzmaDec_TryDummy((CLzmaDec const   *)p, (Byte const   *)(p->tempBuf),
                                   (SizeT )rem);
#line 812
        dummyRes___0 = (int )tmp___5;
        }
#line 813
        if (dummyRes___0 == 0) {
#line 815
          *srcLen += (SizeT )lookAhead;
#line 816
          *status = (ELzmaStatus )3;
#line 817
          return (0);
        }
#line 819
        if (checkEndMarkNow) {
#line 819
          if (dummyRes___0 != 2) {
#line 821
            *status = (ELzmaStatus )2;
#line 822
            return (1);
          }
        }
      }
      {
#line 825
      p->buf = (Byte const   *)(p->tempBuf);
#line 826
      tmp___6 = LzmaDec_DecodeReal2(p, dicLimit, p->buf);
      }
#line 826
      if (tmp___6 != 0) {
#line 827
        return (1);
      }
#line 828
      lookAhead -= rem - (unsigned int )(p->buf - (Byte const   *)(p->tempBuf));
#line 829
      *srcLen += (SizeT )lookAhead;
#line 830
      src += lookAhead;
#line 831
      inSize -= (SizeT )lookAhead;
#line 832
      p->tempBufSize = 0U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 835
  if (p->code == 0U) {
#line 836
    *status = (ELzmaStatus )1;
  }
#line 837
  if (p->code == 0U) {
#line 837
    tmp___7 = 0;
  } else {
#line 837
    tmp___7 = 1;
  }
#line 837
  return (tmp___7);
}
}
#line 840 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
SRes LzmaDec_DecodeToBuf(CLzmaDec *p , Byte *dest , SizeT *destLen , Byte const   *src ,
                         SizeT *srcLen , ELzmaFinishMode finishMode , ELzmaStatus *status ) 
{ 
  SizeT outSize ;
  SizeT inSize ;
  SizeT tmp ;
  SizeT inSizeCur ;
  SizeT outSizeCur ;
  SizeT dicPos ;
  ELzmaFinishMode curFinishMode ;
  SRes res ;

  {
#line 842
  outSize = *destLen;
#line 843
  inSize = *srcLen;
#line 844
  tmp = (SizeT )0;
#line 844
  *destLen = tmp;
#line 844
  *srcLen = tmp;
  {
#line 845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    inSizeCur = inSize;
#line 850
    if (p->dicPos == p->dicBufSize) {
#line 851
      p->dicPos = (SizeT )0;
    }
#line 852
    dicPos = p->dicPos;
#line 853
    if (outSize > p->dicBufSize - dicPos) {
#line 855
      outSizeCur = p->dicBufSize;
#line 856
      curFinishMode = (ELzmaFinishMode )0;
    } else {
#line 860
      outSizeCur = dicPos + outSize;
#line 861
      curFinishMode = finishMode;
    }
    {
#line 864
    res = LzmaDec_DecodeToDic(p, outSizeCur, src, & inSizeCur, curFinishMode, status);
#line 865
    src += inSizeCur;
#line 866
    inSize -= inSizeCur;
#line 867
    *srcLen += inSizeCur;
#line 868
    outSizeCur = p->dicPos - dicPos;
#line 869
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)(p->dic + dicPos),
           outSizeCur);
#line 870
    dest += outSizeCur;
#line 871
    outSize -= outSizeCur;
#line 872
    *destLen += outSizeCur;
    }
#line 873
    if (res != 0) {
#line 874
      return (res);
    }
#line 875
    if (outSizeCur == 0UL) {
#line 876
      return (0);
    } else
#line 875
    if (outSize == 0UL) {
#line 876
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 880 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
void LzmaDec_FreeProbs(CLzmaDec *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 882
  (*(alloc->Free))((void *)alloc, (void *)p->probs);
#line 883
  p->probs = (UInt16 *)0;
  }
#line 884
  return;
}
}
#line 886 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static void LzmaDec_FreeDict(CLzmaDec *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 888
  (*(alloc->Free))((void *)alloc, (void *)p->dic);
#line 889
  p->dic = (Byte *)0;
  }
#line 890
  return;
}
}
#line 892 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
void LzmaDec_Free(CLzmaDec *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 894
  LzmaDec_FreeProbs(p, alloc);
#line 895
  LzmaDec_FreeDict(p, alloc);
  }
#line 896
  return;
}
}
#line 898 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
SRes LzmaProps_Decode(CLzmaProps *p , Byte const   *data , unsigned int size ) 
{ 
  UInt32 dicSize ;
  Byte d ;

  {
#line 903
  if (size < 5U) {
#line 904
    return (4);
  } else {
#line 906
    dicSize = (((unsigned int )*(data + 1) | ((UInt32 )*(data + 2) << 8)) | ((UInt32 )*(data + 3) << 16)) | ((UInt32 )*(data + 4) << 24);
  }
#line 908
  if (dicSize < (UInt32 )(1 << 12)) {
#line 909
    dicSize = (UInt32 )(1 << 12);
  }
#line 910
  p->dicSize = dicSize;
#line 912
  d = (Byte )*(data + 0);
#line 913
  if ((int )d >= 225) {
#line 914
    return (4);
  }
#line 916
  p->lc = (unsigned int )((int )d % 9);
#line 917
  d = (Byte )((int )d / 9);
#line 918
  p->pb = (unsigned int )((int )d / 5);
#line 919
  p->lp = (unsigned int )((int )d % 5);
#line 921
  return (0);
}
}
#line 924 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
static SRes LzmaDec_AllocateProbs2(CLzmaDec *p , CLzmaProps const   *propNew , ISzAlloc *alloc ) 
{ 
  UInt32 numProbs ;
  void *tmp ;

  {
#line 926
  numProbs = 1846U + (UInt32 )(768 << (propNew->lc + propNew->lp));
#line 927
  if ((unsigned long )p->probs == (unsigned long )((UInt16 *)0)) {
#line 927
    goto _L;
  } else
#line 927
  if (numProbs != p->numProbs) {
    _L: /* CIL Label */ 
    {
#line 929
    LzmaDec_FreeProbs(p, alloc);
#line 930
    tmp = (*(alloc->Alloc))((void *)alloc, (unsigned long )numProbs * sizeof(UInt16 ));
#line 930
    p->probs = (UInt16 *)tmp;
#line 931
    p->numProbs = numProbs;
    }
#line 932
    if ((unsigned long )p->probs == (unsigned long )((UInt16 *)0)) {
#line 933
      return (2);
    }
  }
#line 935
  return (0);
}
}
#line 938 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
SRes LzmaDec_AllocateProbs(CLzmaDec *p , Byte const   *props , unsigned int propsSize ,
                           ISzAlloc *alloc ) 
{ 
  CLzmaProps propNew ;
  int __result__ ;
  SRes tmp ;
  int __result_____0 ;
  SRes tmp___0 ;

  {
  {
#line 941
  tmp = LzmaProps_Decode(& propNew, props, propsSize);
#line 941
  __result__ = tmp;
  }
#line 941
  if (__result__ != 0) {
#line 941
    return (__result__);
  }
  {
#line 942
  tmp___0 = LzmaDec_AllocateProbs2(p, (CLzmaProps const   *)(& propNew), alloc);
#line 942
  __result_____0 = tmp___0;
  }
#line 942
  if (__result_____0 != 0) {
#line 942
    return (__result_____0);
  }
#line 943
  p->prop = propNew;
#line 944
  return (0);
}
}
#line 947 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
SRes LzmaDec_Allocate(CLzmaDec *p , Byte const   *props , unsigned int propsSize ,
                      ISzAlloc *alloc ) 
{ 
  CLzmaProps propNew ;
  SizeT dicBufSize ;
  int __result__ ;
  SRes tmp ;
  int __result_____0 ;
  SRes tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 951
  tmp = LzmaProps_Decode(& propNew, props, propsSize);
#line 951
  __result__ = tmp;
  }
#line 951
  if (__result__ != 0) {
#line 951
    return (__result__);
  }
  {
#line 952
  tmp___0 = LzmaDec_AllocateProbs2(p, (CLzmaProps const   *)(& propNew), alloc);
#line 952
  __result_____0 = tmp___0;
  }
#line 952
  if (__result_____0 != 0) {
#line 952
    return (__result_____0);
  }
#line 953
  dicBufSize = (SizeT )propNew.dicSize;
#line 954
  if ((unsigned long )p->dic == (unsigned long )((Byte *)0)) {
#line 954
    goto _L;
  } else
#line 954
  if (dicBufSize != p->dicBufSize) {
    _L: /* CIL Label */ 
    {
#line 956
    LzmaDec_FreeDict(p, alloc);
#line 957
    tmp___1 = (*(alloc->Alloc))((void *)alloc, dicBufSize);
#line 957
    p->dic = (Byte *)tmp___1;
    }
#line 958
    if ((unsigned long )p->dic == (unsigned long )((Byte *)0)) {
      {
#line 960
      LzmaDec_FreeProbs(p, alloc);
      }
#line 961
      return (2);
    }
  }
#line 964
  p->dicBufSize = dicBufSize;
#line 965
  p->prop = propNew;
#line 966
  return (0);
}
}
#line 969 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/LzmaDec.c"
SRes LzmaDecode(Byte *dest , SizeT *destLen , Byte const   *src , SizeT *srcLen ,
                Byte const   *propData , unsigned int propSize , ELzmaFinishMode finishMode ,
                ELzmaStatus *status , ISzAlloc *alloc ) 
{ 
  CLzmaDec p ;
  SRes res ;
  SizeT inSize ;
  SizeT outSize ;
  SizeT tmp ;

  {
#line 975
  inSize = *srcLen;
#line 976
  outSize = *destLen;
#line 977
  tmp = (SizeT )0;
#line 977
  *destLen = tmp;
#line 977
  *srcLen = tmp;
#line 978
  if (inSize < 5UL) {
#line 979
    return (6);
  }
  {
#line 981
  p.dic = (Byte *)0;
#line 981
  p.probs = (UInt16 *)0;
#line 982
  res = LzmaDec_AllocateProbs(& p, propData, propSize, alloc);
  }
#line 983
  if (res != 0) {
#line 984
    return (res);
  }
  {
#line 985
  p.dic = dest;
#line 986
  p.dicBufSize = outSize;
#line 988
  LzmaDec_Init(& p);
#line 990
  *srcLen = inSize;
#line 991
  res = LzmaDec_DecodeToDic(& p, outSize, src, srcLen, finishMode, status);
  }
#line 993
  if (res == 0) {
#line 993
    if ((unsigned int )*status == 3U) {
#line 994
      res = 6;
    }
  }
  {
#line 996
  *destLen = p.dicPos;
#line 997
  LzmaDec_FreeProbs(& p, alloc);
  }
#line 998
  return (res);
}
}
#line 128 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8.h"
void Ppmd8_RangeEnc_FlushData(CPpmd8 *p ) ;
#line 129
void Ppmd8_EncodeSymbol(CPpmd8 *p , int symbol ) ;
#line 12 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Enc.c"
void Ppmd8_RangeEnc_FlushData(CPpmd8 *p ) 
{ 
  unsigned int i ;

  {
#line 15
  i = 0U;
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! (i < 4U)) {
#line 15
      goto while_break;
    }
    {
#line 16
    (*((p->Stream.Out)->Write))((void *)p->Stream.Out, (Byte )(p->Low >> 24));
#line 15
    i ++;
#line 15
    p->Low <<= 8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 17
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Enc.c"
static void RangeEnc_Normalize(CPpmd8 *p ) 
{ 


  {
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21
    if (! ((p->Low ^ (p->Low + p->Range)) < (unsigned int )(1 << 24))) {
#line 21
      if (p->Range < (UInt32 )(1 << 15)) {
#line 21
        p->Range = (0U - p->Low) & (unsigned int )((1 << 15) - 1);
      } else {
#line 21
        goto while_break;
      }
    }
    {
#line 24
    (*((p->Stream.Out)->Write))((void *)p->Stream.Out, (Byte )(p->Low >> 24));
#line 25
    p->Range <<= 8;
#line 26
    p->Low <<= 8;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  return;
}
}
#line 30 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Enc.c"
static void RangeEnc_Encode___0(CPpmd8 *p , UInt32 start , UInt32 size , UInt32 total ) 
{ 
  UInt32 tmp ;

  {
  {
#line 32
  tmp = p->Range / total;
#line 32
  p->Range = tmp;
#line 32
  p->Low += start * tmp;
#line 33
  p->Range *= size;
#line 34
  RangeEnc_Normalize(p);
  }
#line 35
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Enc.c"
static void RangeEnc_EncodeBit_0___0(CPpmd8 *p , UInt32 size0 ) 
{ 


  {
  {
#line 39
  p->Range >>= 14;
#line 40
  p->Range *= size0;
#line 41
  RangeEnc_Normalize(p);
  }
#line 42
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Enc.c"
static void RangeEnc_EncodeBit_1___0(CPpmd8 *p , UInt32 size0 ) 
{ 
  UInt32 tmp ;

  {
  {
#line 46
  tmp = p->Range >> 14;
#line 46
  p->Range = tmp;
#line 46
  p->Low += size0 * tmp;
#line 47
  p->Range *= (UInt32 )(1 << 14) - size0;
#line 48
  RangeEnc_Normalize(p);
  }
#line 49
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd8Enc.c"
void Ppmd8_EncodeSymbol(CPpmd8 *p , int symbol ) 
{ 
  size_t charMask[256UL / sizeof(size_t )] ;
  CPpmd_State *s ;
  UInt32 sum ;
  unsigned int i ;
  unsigned int i___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  UInt16 *prob ;
  CPpmd_State *s___0 ;
  unsigned int i___1 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  UInt32 escFreq ;
  CPpmd_See *see ;
  CPpmd_State *s___1 ;
  UInt32 sum___0 ;
  unsigned int i___2 ;
  unsigned int numMasked ;
  int cur ;
  UInt32 low ;
  CPpmd_State *s1 ;
  Byte tmp___13 ;

  {
#line 57
  if ((int )(p->MinContext)->NumStats != 0) {
#line 59
    s = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 62
    if ((int )s->Symbol == symbol) {
      {
#line 64
      RangeEnc_Encode___0(p, (UInt32 )0, (UInt32 )s->Freq, (UInt32 )(p->MinContext)->SummFreq);
#line 65
      p->FoundState = s;
#line 66
      Ppmd8_Update1_0(p);
      }
#line 67
      return;
    }
#line 69
    p->PrevSuccess = 0U;
#line 70
    sum = (UInt32 )s->Freq;
#line 71
    i = (unsigned int )(p->MinContext)->NumStats;
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      s ++;
#line 74
      if ((int )s->Symbol == symbol) {
        {
#line 76
        RangeEnc_Encode___0(p, sum, (UInt32 )s->Freq, (UInt32 )(p->MinContext)->SummFreq);
#line 77
        p->FoundState = s;
#line 78
        Ppmd8_Update1(p);
        }
#line 79
        return;
      }
#line 81
      sum += (UInt32 )s->Freq;
#line 72
      i --;
#line 72
      if (! i) {
#line 72
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 85
    i___0 = 0U;
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 85
      if (! ((unsigned long )i___0 < 256UL / sizeof(charMask[0]))) {
#line 85
        goto while_break___0;
      }
#line 85
      tmp___5 = ~ ((size_t )0);
#line 85
      charMask[i___0] = tmp___5;
#line 85
      tmp___4 = tmp___5;
#line 85
      charMask[i___0 + 1U] = tmp___4;
#line 85
      tmp___3 = tmp___4;
#line 85
      charMask[i___0 + 2U] = tmp___3;
#line 85
      tmp___2 = tmp___3;
#line 85
      charMask[i___0 + 3U] = tmp___2;
#line 85
      tmp___1 = tmp___2;
#line 85
      charMask[i___0 + 4U] = tmp___1;
#line 85
      tmp___0 = tmp___1;
#line 85
      charMask[i___0 + 5U] = tmp___0;
#line 85
      tmp = tmp___0;
#line 85
      charMask[i___0 + 6U] = tmp;
#line 85
      charMask[i___0 + 7U] = tmp;
#line 85
      i___0 += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 87
    i = (unsigned int )(p->MinContext)->NumStats;
    {
#line 88
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 88
      s --;
#line 88
      *((signed char *)(charMask) + s->Symbol) = (signed char)0;
#line 88
      i --;
#line 88
      if (! i) {
#line 88
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 89
    RangeEnc_Encode___0(p, sum, (UInt32 )(p->MinContext)->SummFreq - sum, (UInt32 )(p->MinContext)->SummFreq);
    }
  } else {
#line 93
    prob = & p->BinSumm[p->NS2Indx[(int )((CPpmd_State *)(& (p->MinContext)->SummFreq))->Freq - 1]][(((unsigned int )p->NS2BSIndx[((CPpmd8_Context *)((void *)(p->Base + (p->MinContext)->Suffix)))->NumStats] + p->PrevSuccess) + (unsigned int )(p->MinContext)->Flags) + (unsigned int )((p->RunLength >> 26) & 32)];
#line 94
    s___0 = (CPpmd_State *)(& (p->MinContext)->SummFreq);
#line 95
    if ((int )s___0->Symbol == symbol) {
      {
#line 97
      RangeEnc_EncodeBit_0___0(p, (UInt32 )*prob);
#line 98
      *prob = (UInt16 )(((int )*prob + (1 << 7)) - (((int )*prob + (1 << 5)) >> 7));
#line 99
      p->FoundState = s___0;
#line 100
      Ppmd8_UpdateBin(p);
      }
#line 101
      return;
    } else {
      {
#line 105
      RangeEnc_EncodeBit_1___0(p, (UInt32 )*prob);
#line 106
      *prob = (UInt16 )((int )*prob - (((int )*prob + (1 << 5)) >> 7));
#line 107
      p->InitEsc = (unsigned int )PPMD8_kExpEscape[(int )*prob >> 10];
#line 108
      i___1 = 0U;
      }
      {
#line 108
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 108
        if (! ((unsigned long )i___1 < 256UL / sizeof(charMask[0]))) {
#line 108
          goto while_break___2;
        }
#line 108
        tmp___12 = ~ ((size_t )0);
#line 108
        charMask[i___1] = tmp___12;
#line 108
        tmp___11 = tmp___12;
#line 108
        charMask[i___1 + 1U] = tmp___11;
#line 108
        tmp___10 = tmp___11;
#line 108
        charMask[i___1 + 2U] = tmp___10;
#line 108
        tmp___9 = tmp___10;
#line 108
        charMask[i___1 + 3U] = tmp___9;
#line 108
        tmp___8 = tmp___9;
#line 108
        charMask[i___1 + 4U] = tmp___8;
#line 108
        tmp___7 = tmp___8;
#line 108
        charMask[i___1 + 5U] = tmp___7;
#line 108
        tmp___6 = tmp___7;
#line 108
        charMask[i___1 + 6U] = tmp___6;
#line 108
        charMask[i___1 + 7U] = tmp___6;
#line 108
        i___1 += 8U;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 109
      *((signed char *)(charMask) + s___0->Symbol) = (signed char)0;
#line 110
      p->PrevSuccess = 0U;
    }
  }
  {
#line 113
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 119
    numMasked = (unsigned int )(p->MinContext)->NumStats;
    {
#line 120
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 122
      (p->OrderFall) ++;
#line 123
      if (! (p->MinContext)->Suffix) {
#line 124
        return;
      }
#line 125
      p->MinContext = (CPpmd8_Context *)((void *)(p->Base + (p->MinContext)->Suffix));
#line 120
      if (! ((unsigned int )(p->MinContext)->NumStats == numMasked)) {
#line 120
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 129
    see = Ppmd8_MakeEscFreq(p, numMasked, & escFreq);
#line 130
    s___1 = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 131
    sum___0 = (UInt32 )0;
#line 132
    i___2 = (unsigned int )((int )(p->MinContext)->NumStats + 1);
    }
    {
#line 133
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 135
      cur = (int )s___1->Symbol;
#line 136
      if (cur == symbol) {
#line 138
        low = sum___0;
#line 139
        s1 = s___1;
        {
#line 140
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 142
          sum___0 += (UInt32 )((int )s___1->Freq & (int )*((signed char *)(charMask) + s___1->Symbol));
#line 143
          s___1 ++;
#line 140
          i___2 --;
#line 140
          if (! i___2) {
#line 140
            goto while_break___6;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 146
        RangeEnc_Encode___0(p, low, (UInt32 )s1->Freq, sum___0 + escFreq);
        }
#line 147
        if ((int )see->Shift < 7) {
#line 147
          see->Count = (Byte )((int )see->Count - 1);
#line 147
          if ((int )see->Count == 0) {
#line 147
            see->Summ = (UInt16 )((int )see->Summ << 1);
#line 147
            tmp___13 = see->Shift;
#line 147
            see->Shift = (Byte )((int )see->Shift + 1);
#line 147
            see->Count = (Byte )(3 << (int )tmp___13);
          }
        }
        {
#line 148
        p->FoundState = s1;
#line 149
        Ppmd8_Update2(p);
        }
#line 150
        return;
      }
#line 152
      sum___0 += (UInt32 )((int )s___1->Freq & (int )*((signed char *)(charMask) + cur));
#line 153
      *((signed char *)(charMask) + cur) = (signed char)0;
#line 154
      s___1 ++;
#line 133
      i___2 --;
#line 133
      if (! i___2) {
#line 133
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 158
    RangeEnc_Encode___0(p, sum___0, escFreq, sum___0 + escFreq);
#line 159
    see->Summ = (UInt16 )(((UInt32 )see->Summ + sum___0) + escFreq);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 8 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra86.c"
Byte const   kMaskToAllowedStatus[8]  = 
#line 8 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra86.c"
  {      (Byte const   )1,      (Byte const   )1,      (Byte const   )1,      (Byte const   )0, 
        (Byte const   )1,      (Byte const   )0,      (Byte const   )0,      (Byte const   )0};
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra86.c"
Byte const   kMaskToBitNumber[8]  = 
#line 9
  {      (Byte const   )0,      (Byte const   )1,      (Byte const   )2,      (Byte const   )2, 
        (Byte const   )3,      (Byte const   )3,      (Byte const   )3,      (Byte const   )3};
#line 11 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Bra86.c"
SizeT x86_Convert(Byte *data , SizeT size , UInt32 ip , UInt32 *state , int encoding ) 
{ 
  SizeT bufferPos ;
  SizeT prevPosT ;
  UInt32 prevMask ;
  Byte *p ;
  Byte *limit ;
  Byte b ;
  UInt32 src ;
  UInt32 dest ;
  Byte b___0 ;
  int index ;

  {
#line 13
  bufferPos = (SizeT )0;
#line 14
  prevMask = *state & 7U;
#line 15
  if (size < 5UL) {
#line 16
    return ((SizeT )0);
  }
#line 17
  ip += 5U;
#line 18
  prevPosT = 0xffffffffffffffffUL;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    p = data + bufferPos;
#line 23
    limit = (data + size) - 4;
    {
#line 24
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 24
      if (! ((unsigned long )p < (unsigned long )limit)) {
#line 24
        goto while_break___0;
      }
#line 25
      if (((int )*p & 254) == 232) {
#line 26
        goto while_break___0;
      }
#line 24
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 27
    bufferPos = (SizeT )(p - data);
#line 28
    if ((unsigned long )p >= (unsigned long )limit) {
#line 29
      goto while_break;
    }
#line 30
    prevPosT = bufferPos - prevPosT;
#line 31
    if (prevPosT > 3UL) {
#line 32
      prevMask = (UInt32 )0;
    } else {
#line 35
      prevMask = (prevMask << ((int )prevPosT - 1)) & 7U;
#line 36
      if (prevMask != 0U) {
#line 38
        b = *(p + (4 - (int )kMaskToBitNumber[prevMask]));
#line 39
        if (! kMaskToAllowedStatus[prevMask]) {
#line 41
          prevPosT = bufferPos;
#line 42
          prevMask = ((prevMask << 1) & 7U) | 1U;
#line 43
          bufferPos ++;
#line 44
          goto __Cont;
        } else
#line 39
        if ((int )b == 0) {
#line 41
          prevPosT = bufferPos;
#line 42
          prevMask = ((prevMask << 1) & 7U) | 1U;
#line 43
          bufferPos ++;
#line 44
          goto __Cont;
        } else
#line 39
        if ((int )b == 255) {
#line 41
          prevPosT = bufferPos;
#line 42
          prevMask = ((prevMask << 1) & 7U) | 1U;
#line 43
          bufferPos ++;
#line 44
          goto __Cont;
        }
      }
    }
#line 48
    prevPosT = bufferPos;
#line 50
    if ((int )*(p + 4) == 0) {
#line 50
      goto _L;
    } else
#line 50
    if ((int )*(p + 4) == 255) {
      _L: /* CIL Label */ 
#line 52
      src = ((((UInt32 )*(p + 4) << 24) | ((UInt32 )*(p + 3) << 16)) | ((UInt32 )*(p + 2) << 8)) | (UInt32 )*(p + 1);
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 58
        if (encoding) {
#line 59
          dest = (ip + (UInt32 )bufferPos) + src;
        } else {
#line 61
          dest = src - (ip + (UInt32 )bufferPos);
        }
#line 62
        if (prevMask == 0U) {
#line 63
          goto while_break___1;
        }
#line 64
        index = (int )((int const   )kMaskToBitNumber[prevMask] * 8);
#line 65
        b___0 = (Byte )(dest >> (24 - index));
#line 66
        if (! ((int )b___0 == 0)) {
#line 66
          if (! ((int )b___0 == 255)) {
#line 67
            goto while_break___1;
          }
        }
#line 68
        src = dest ^ (unsigned int )((1 << (32 - index)) - 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 70
      *(p + 4) = (Byte )(~ (((dest >> 24) & 1U) - 1U));
#line 71
      *(p + 3) = (Byte )(dest >> 16);
#line 72
      *(p + 2) = (Byte )(dest >> 8);
#line 73
      *(p + 1) = (Byte )dest;
#line 74
      bufferPos += 5UL;
    } else {
#line 78
      prevMask = ((prevMask << 1) & 7U) | 1U;
#line 79
      bufferPos ++;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  prevPosT = bufferPos - prevPosT;
#line 83
  if (prevPosT > 3UL) {
#line 83
    *state = (UInt32 )0;
  } else {
#line 83
    *state = (prevMask << ((int )prevPosT - 1)) & 7U;
  }
#line 84
  return (bufferPos);
}
}
#line 62 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.h"
void Ppmd7_Construct(CPpmd7 *p ) ;
#line 63
Bool Ppmd7_Alloc(CPpmd7 *p , UInt32 size , ISzAlloc *alloc ) ;
#line 64
void Ppmd7_Free(CPpmd7 *p , ISzAlloc *alloc ) ;
#line 65
void Ppmd7_Init(CPpmd7 *p , unsigned int maxOrder ) ;
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
Byte const   PPMD7_kExpEscape[16]  = 
#line 9 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
  {      (Byte const   )25,      (Byte const   )14,      (Byte const   )9,      (Byte const   )7, 
        (Byte const   )5,      (Byte const   )5,      (Byte const   )4,      (Byte const   )4, 
        (Byte const   )4,      (Byte const   )3,      (Byte const   )3,      (Byte const   )3, 
        (Byte const   )2,      (Byte const   )2,      (Byte const   )2,      (Byte const   )2};
#line 10 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static UInt16 const   kInitBinEsc___0[8]  = 
#line 10
  {      (UInt16 const   )15581,      (UInt16 const   )7999,      (UInt16 const   )22975,      (UInt16 const   )18675, 
        (UInt16 const   )25761,      (UInt16 const   )23228,      (UInt16 const   )26162,      (UInt16 const   )24657};
#line 58 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
void Ppmd7_Construct(CPpmd7 *p ) 
{ 
  unsigned int i ;
  unsigned int k ;
  unsigned int m ;
  unsigned int step ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 62
  p->Base = (Byte *)0;
#line 64
  i = 0U;
#line 64
  k = 0U;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 38U)) {
#line 64
      goto while_break;
    }
#line 66
    if (i >= 12U) {
#line 66
      tmp = 4U;
    } else {
#line 66
      tmp = (i >> 2) + 1U;
    }
#line 66
    step = tmp;
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 67
      tmp___0 = k;
#line 67
      k ++;
#line 67
      p->Units2Indx[tmp___0] = (Byte )i;
#line 67
      step --;
#line 67
      if (! step) {
#line 67
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 68
    p->Indx2Units[i] = (Byte )k;
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  p->NS2BSIndx[0] = (Byte )0;
#line 72
  p->NS2BSIndx[1] = (Byte )(1 << 1);
#line 73
  memset((void *)(p->NS2BSIndx + 2), 2 << 1, (size_t )9);
#line 74
  memset((void *)(p->NS2BSIndx + 11), 3 << 1, (size_t )245);
#line 76
  i = 0U;
  }
  {
#line 76
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 76
    if (! (i < 3U)) {
#line 76
      goto while_break___1;
    }
#line 77
    p->NS2Indx[i] = (Byte )i;
#line 76
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 78
  m = i;
#line 78
  k = 1U;
  {
#line 78
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 78
    if (! (i < 256U)) {
#line 78
      goto while_break___2;
    }
#line 80
    p->NS2Indx[i] = (Byte )m;
#line 81
    k --;
#line 81
    if (k == 0U) {
#line 82
      m ++;
#line 82
      k = m - 2U;
    }
#line 78
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 85
  memset((void *)(p->HB2Flag), 0, (size_t )64);
#line 86
  memset((void *)(p->HB2Flag + 64), 8, (size_t )192);
  }
#line 87
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
void Ppmd7_Free(CPpmd7 *p , ISzAlloc *alloc ) 
{ 


  {
  {
#line 91
  (*(alloc->Free))((void *)alloc, (void *)p->Base);
#line 92
  p->Size = (UInt32 )0;
#line 93
  p->Base = (Byte *)0;
  }
#line 94
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
Bool Ppmd7_Alloc(CPpmd7 *p , UInt32 size , ISzAlloc *alloc ) 
{ 
  Byte *tmp ;
  void *tmp___0 ;

  {
#line 98
  if ((unsigned long )p->Base == (unsigned long )((Byte *)0)) {
#line 98
    goto _L;
  } else
#line 98
  if (p->Size != size) {
    _L: /* CIL Label */ 
    {
#line 100
    Ppmd7_Free(p, alloc);
#line 101
    p->AlignOffset = 4U - (size & 3U);
#line 107
    tmp___0 = (*(alloc->Alloc))((void *)alloc, (size_t )((p->AlignOffset + size) + 12U));
#line 107
    tmp = (Byte *)tmp___0;
#line 107
    p->Base = tmp;
    }
#line 107
    if ((unsigned long )tmp == (unsigned long )((Byte *)0)) {
#line 112
      return (0);
    }
#line 113
    p->Size = size;
  }
#line 115
  return (1);
}
}
#line 118 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void InsertNode___0(CPpmd7 *p , void *node , unsigned int indx ) 
{ 


  {
#line 120
  *((CPpmd_Void_Ref *)node) = p->FreeList[indx];
#line 121
  p->FreeList[indx] = (UInt32 )((Byte *)node - p->Base);
#line 122
  return;
}
}
#line 124 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void *RemoveNode___0(CPpmd7 *p , unsigned int indx ) 
{ 
  CPpmd_Void_Ref *node ;

  {
#line 126
  node = (CPpmd_Void_Ref *)((void *)(p->Base + p->FreeList[indx]));
#line 127
  p->FreeList[indx] = *node;
#line 128
  return ((void *)node);
}
}
#line 131 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void SplitBlock___0(CPpmd7 *p , void *ptr , unsigned int oldIndx , unsigned int newIndx ) 
{ 
  unsigned int i ;
  unsigned int nu ;
  unsigned int k ;

  {
#line 133
  nu = (unsigned int )((int )p->Indx2Units[oldIndx] - (int )p->Indx2Units[newIndx]);
#line 134
  ptr = (void *)((Byte *)ptr + (UInt32 )p->Indx2Units[newIndx] * 12U);
#line 135
  i = (unsigned int )p->Units2Indx[nu - 1U];
#line 135
  if ((unsigned int )p->Indx2Units[i] != nu) {
    {
#line 137
    i --;
#line 137
    k = (unsigned int )p->Indx2Units[i];
#line 138
    InsertNode___0(p, (void *)((Byte *)ptr + k * 12U), (nu - k) - 1U);
    }
  }
  {
#line 140
  InsertNode___0(p, ptr, i);
  }
#line 141
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void GlueFreeBlocks___0(CPpmd7 *p ) 
{ 
  CPpmd7_Node_Ref head ;
  CPpmd7_Node_Ref n ;
  unsigned int i ;
  UInt16 nu ;
  CPpmd7_Node_Ref next ;
  CPpmd7_Node *node ;
  CPpmd7_Node_Ref tmp ;
  CPpmd7_Node *node___0 ;
  UInt32 nu___0 ;
  CPpmd7_Node *node2 ;
  CPpmd7_Node *node___1 ;
  unsigned int nu___1 ;
  CPpmd7_Node_Ref next___0 ;
  unsigned int k ;

  {
#line 149
  head = p->AlignOffset + p->Size;
#line 152
  n = head;
#line 155
  p->GlueCount = (UInt32 )255;
#line 158
  i = 0U;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < 38U)) {
#line 158
      goto while_break;
    }
#line 160
    nu = (UInt16 )p->Indx2Units[i];
#line 161
    next = p->FreeList[i];
#line 162
    p->FreeList[i] = (CPpmd_Void_Ref )0;
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (! (next != 0U)) {
#line 163
        goto while_break___0;
      }
#line 165
      node = (CPpmd7_Node *)(p->Base + next);
#line 166
      node->Next = n;
#line 167
      tmp = next;
#line 167
      ((CPpmd7_Node *)(p->Base + n))->Prev = tmp;
#line 167
      n = tmp;
#line 168
      next = (CPpmd7_Node_Ref )*((CPpmd7_Node_Ref const   *)node);
#line 169
      node->Stamp = (UInt16 )0;
#line 170
      node->NU = nu;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  ((CPpmd7_Node *)(p->Base + head))->Stamp = (UInt16 )1;
#line 174
  ((CPpmd7_Node *)(p->Base + head))->Next = n;
#line 175
  ((CPpmd7_Node *)(p->Base + n))->Prev = head;
#line 176
  if ((unsigned long )p->LoUnit != (unsigned long )p->HiUnit) {
#line 177
    ((CPpmd7_Node *)p->LoUnit)->Stamp = (UInt16 )1;
  }
  {
#line 180
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 180
    if (! (n != head)) {
#line 180
      goto while_break___1;
    }
#line 182
    node___0 = (CPpmd7_Node *)(p->Base + n);
#line 183
    nu___0 = (UInt32 )node___0->NU;
    {
#line 184
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 186
      node2 = (CPpmd7_Node *)(p->Base + n) + nu___0;
#line 187
      nu___0 += (UInt32 )node2->NU;
#line 188
      if ((int )node2->Stamp != 0) {
#line 189
        goto while_break___2;
      } else
#line 188
      if (nu___0 >= 65536U) {
#line 189
        goto while_break___2;
      }
#line 190
      ((CPpmd7_Node *)(p->Base + node2->Prev))->Next = node2->Next;
#line 191
      ((CPpmd7_Node *)(p->Base + node2->Next))->Prev = node2->Prev;
#line 192
      node___0->NU = (UInt16 )nu___0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 194
    n = node___0->Next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 198
  n = ((CPpmd7_Node *)(p->Base + head))->Next;
  {
#line 198
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 198
    if (! (n != head)) {
#line 198
      goto while_break___3;
    }
#line 200
    node___1 = (CPpmd7_Node *)(p->Base + n);
#line 202
    next___0 = node___1->Next;
#line 203
    nu___1 = (unsigned int )node___1->NU;
    {
#line 203
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 203
      if (! (nu___1 > 128U)) {
#line 203
        goto while_break___4;
      }
      {
#line 204
      InsertNode___0(p, (void *)node___1, 37U);
#line 203
      nu___1 -= 128U;
#line 203
      node___1 += 128;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 205
    i = (unsigned int )p->Units2Indx[nu___1 - 1U];
#line 205
    if ((unsigned int )p->Indx2Units[i] != nu___1) {
      {
#line 207
      i --;
#line 207
      k = (unsigned int )p->Indx2Units[i];
#line 208
      InsertNode___0(p, (void *)(node___1 + k), (nu___1 - k) - 1U);
      }
    }
    {
#line 210
    InsertNode___0(p, (void *)node___1, i);
#line 211
    n = next___0;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 215 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void *AllocUnitsRare___0(CPpmd7 *p , unsigned int indx ) 
{ 
  unsigned int i ;
  void *retVal ;
  void *tmp ;
  UInt32 numBytes ;
  Byte *tmp___0 ;
  Byte *tmp___1 ;

  {
#line 219
  if (p->GlueCount == 0U) {
    {
#line 221
    GlueFreeBlocks___0(p);
    }
#line 222
    if (p->FreeList[indx] != 0U) {
      {
#line 223
      tmp = RemoveNode___0(p, indx);
      }
#line 223
      return (tmp);
    }
  }
#line 225
  i = indx;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    i ++;
#line 228
    if (i == 38U) {
#line 230
      numBytes = (UInt32 )p->Indx2Units[indx] * 12U;
#line 231
      (p->GlueCount) --;
#line 232
      if ((UInt32 )(p->UnitsStart - p->Text) > numBytes) {
#line 232
        tmp___0 = p->UnitsStart - numBytes;
#line 232
        p->UnitsStart = tmp___0;
#line 232
        tmp___1 = tmp___0;
      } else {
#line 232
        tmp___1 = (Byte *)((void *)0);
      }
#line 232
      return ((void *)tmp___1);
    }
#line 226
    if (! (p->FreeList[i] == 0U)) {
#line 226
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  retVal = RemoveNode___0(p, i);
#line 237
  SplitBlock___0(p, retVal, i, indx);
  }
#line 238
  return (retVal);
}
}
#line 241 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void *AllocUnits___0(CPpmd7 *p , unsigned int indx ) 
{ 
  UInt32 numBytes ;
  void *tmp ;
  void *retVal ;
  void *tmp___0 ;

  {
#line 244
  if (p->FreeList[indx] != 0U) {
    {
#line 245
    tmp = RemoveNode___0(p, indx);
    }
#line 245
    return (tmp);
  }
#line 246
  numBytes = (UInt32 )p->Indx2Units[indx] * 12U;
#line 247
  if (numBytes <= (UInt32 )(p->HiUnit - p->LoUnit)) {
#line 249
    retVal = (void *)p->LoUnit;
#line 250
    p->LoUnit += numBytes;
#line 251
    return (retVal);
  }
  {
#line 253
  tmp___0 = AllocUnitsRare___0(p, indx);
  }
#line 253
  return (tmp___0);
}
}
#line 260 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void *ShrinkUnits___0(CPpmd7 *p , void *oldPtr , unsigned int oldNU , unsigned int newNU ) 
{ 
  unsigned int i0 ;
  unsigned int i1 ;
  void *ptr ;
  void *tmp ;
  UInt32 *d ;
  UInt32 const   *s ;
  UInt32 n ;

  {
#line 262
  i0 = (unsigned int )p->Units2Indx[oldNU - 1U];
#line 263
  i1 = (unsigned int )p->Units2Indx[newNU - 1U];
#line 264
  if (i0 == i1) {
#line 265
    return (oldPtr);
  }
#line 266
  if (p->FreeList[i1] != 0U) {
    {
#line 268
    tmp = RemoveNode___0(p, i1);
#line 268
    ptr = tmp;
#line 269
    d = (UInt32 *)ptr;
#line 269
    s = (UInt32 const   *)oldPtr;
#line 269
    n = newNU;
    }
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      *(d + 0) = (UInt32 )*(s + 0);
#line 269
      *(d + 1) = (UInt32 )*(s + 1);
#line 269
      *(d + 2) = (UInt32 )*(s + 2);
#line 269
      s += 3;
#line 269
      d += 3;
#line 269
      n --;
#line 269
      if (! n) {
#line 269
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 270
    InsertNode___0(p, oldPtr, i0);
    }
#line 271
    return (ptr);
  }
  {
#line 273
  SplitBlock___0(p, oldPtr, i0, i1);
  }
#line 274
  return (oldPtr);
}
}
#line 279 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void SetSuccessor___0(CPpmd_State *p , CPpmd_Void_Ref v ) 
{ 


  {
#line 281
  p->SuccessorLow = (UInt16 )(v & 65535U);
#line 282
  p->SuccessorHigh = (UInt16 )((v >> 16) & 65535U);
#line 283
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void RestartModel___0(CPpmd7 *p ) 
{ 
  unsigned int i ;
  unsigned int k ;
  unsigned int m ;
  Byte *tmp ;
  Int32 tmp___0 ;
  unsigned int tmp___1 ;
  CPpmd7_Context *tmp___2 ;
  Byte *tmp___3 ;
  CPpmd_State *s ;
  UInt16 *dest ;
  UInt16 val ;
  CPpmd_See *s___0 ;
  Byte tmp___4 ;

  {
  {
#line 289
  memset((void *)(p->FreeList), 0, sizeof(p->FreeList));
#line 290
  p->Text = p->Base + p->AlignOffset;
#line 291
  p->HiUnit = p->Text + p->Size;
#line 292
  tmp = p->HiUnit - (((p->Size / 8U) / 12U) * 7U) * 12U;
#line 292
  p->UnitsStart = tmp;
#line 292
  p->LoUnit = tmp;
#line 293
  p->GlueCount = (UInt32 )0;
#line 295
  p->OrderFall = p->MaxOrder;
  }
#line 296
  if (p->MaxOrder < 12U) {
#line 296
    tmp___1 = p->MaxOrder;
  } else {
#line 296
    tmp___1 = 12U;
  }
#line 296
  tmp___0 = - ((Int32 )tmp___1) - 1;
#line 296
  p->InitRL = tmp___0;
#line 296
  p->RunLength = tmp___0;
#line 297
  p->PrevSuccess = 0U;
#line 299
  tmp___3 = p->HiUnit - 12;
#line 299
  p->HiUnit = tmp___3;
#line 299
  tmp___2 = (CTX_PTR___0 )tmp___3;
#line 299
  p->MaxContext = tmp___2;
#line 299
  p->MinContext = tmp___2;
#line 300
  (p->MinContext)->Suffix = (CPpmd7_Context_Ref )0;
#line 301
  (p->MinContext)->NumStats = (UInt16 )256;
#line 302
  (p->MinContext)->SummFreq = (UInt16 )257;
#line 303
  p->FoundState = (CPpmd_State *)p->LoUnit;
#line 304
  p->LoUnit += 1536U;
#line 305
  (p->MinContext)->Stats = (UInt32 )((Byte *)p->FoundState - p->Base);
#line 306
  i = 0U;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < 256U)) {
#line 306
      goto while_break;
    }
    {
#line 308
    s = p->FoundState + i;
#line 309
    s->Symbol = (Byte )i;
#line 310
    s->Freq = (Byte )1;
#line 311
    SetSuccessor___0(s, (CPpmd_Void_Ref )0);
#line 306
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  i = 0U;
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if (! (i < 128U)) {
#line 314
      goto while_break___0;
    }
#line 315
    k = 0U;
    {
#line 315
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 315
      if (! (k < 8U)) {
#line 315
        goto while_break___1;
      }
#line 317
      dest = p->BinSumm[i] + k;
#line 318
      val = (UInt16 )((unsigned int )(1 << 14) - (unsigned int )kInitBinEsc___0[k] / (i + 2U));
#line 319
      m = 0U;
      {
#line 319
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 319
        if (! (m < 64U)) {
#line 319
          goto while_break___2;
        }
#line 320
        *(dest + m) = val;
#line 319
        m += 8U;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 315
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 314
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  i = 0U;
  {
#line 323
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 323
    if (! (i < 25U)) {
#line 323
      goto while_break___3;
    }
#line 324
    k = 0U;
    {
#line 324
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 324
      if (! (k < 16U)) {
#line 324
        goto while_break___4;
      }
#line 326
      s___0 = & p->See[i][k];
#line 327
      tmp___4 = (Byte )3;
#line 327
      s___0->Shift = tmp___4;
#line 327
      s___0->Summ = (UInt16 )((5U * i + 10U) << (int )tmp___4);
#line 328
      s___0->Count = (Byte )4;
#line 324
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 323
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 330
  return;
}
}
#line 332 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
void Ppmd7_Init(CPpmd7 *p , unsigned int maxOrder ) 
{ 


  {
  {
#line 334
  p->MaxOrder = maxOrder;
#line 335
  RestartModel___0(p);
#line 336
  p->DummySee.Shift = (Byte )7;
#line 337
  p->DummySee.Summ = (UInt16 )0;
#line 338
  p->DummySee.Count = (Byte )64;
  }
#line 339
  return;
}
}
#line 341 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static CTX_PTR___0 CreateSuccessors___0(CPpmd7 *p , Bool skip ) 
{ 
  CPpmd_State upState ;
  CTX_PTR___0 c ;
  CPpmd_Byte_Ref upBranch ;
  CPpmd_State *ps[64] ;
  unsigned int numPs ;
  unsigned int tmp ;
  CPpmd_Void_Ref successor ;
  CPpmd_State *s ;
  unsigned int tmp___0 ;
  UInt32 cf ;
  UInt32 s0 ;
  CPpmd_State *s___0 ;
  UInt32 tmp___1 ;
  CTX_PTR___0 c1 ;
  Byte *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 344
  c = p->MinContext;
#line 345
  upBranch = (unsigned int )(p->FoundState)->SuccessorLow | ((UInt32 )(p->FoundState)->SuccessorHigh << 16);
#line 347
  numPs = 0U;
#line 349
  if (! skip) {
#line 350
    tmp = numPs;
#line 350
    numPs ++;
#line 350
    ps[tmp] = p->FoundState;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! c->Suffix) {
#line 352
      goto while_break;
    }
#line 356
    c = (CPpmd7_Context *)((void *)(p->Base + c->Suffix));
#line 357
    if ((int )c->NumStats != 1) {
#line 359
      s = (CPpmd_State *)((void *)(p->Base + c->Stats));
      {
#line 359
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 359
        if (! ((int )s->Symbol != (int )(p->FoundState)->Symbol)) {
#line 359
          goto while_break___0;
        }
#line 359
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 362
      s = (CPpmd_State *)(& c->SummFreq);
    }
#line 363
    successor = (unsigned int )s->SuccessorLow | ((UInt32 )s->SuccessorHigh << 16);
#line 364
    if (successor != upBranch) {
#line 366
      c = (CPpmd7_Context *)((void *)(p->Base + successor));
#line 367
      if (numPs == 0U) {
#line 368
        return (c);
      }
#line 369
      goto while_break;
    }
#line 371
    tmp___0 = numPs;
#line 371
    numPs ++;
#line 371
    ps[tmp___0] = s;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  upState.Symbol = (Byte )*((Byte const   *)((void *)(p->Base + upBranch)));
#line 375
  SetSuccessor___0(& upState, upBranch + 1U);
  }
#line 377
  if ((int )c->NumStats == 1) {
#line 378
    upState.Freq = ((CPpmd_State *)(& c->SummFreq))->Freq;
  } else {
#line 383
    s___0 = (CPpmd_State *)((void *)(p->Base + c->Stats));
    {
#line 383
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 383
      if (! ((int )s___0->Symbol != (int )upState.Symbol)) {
#line 383
        goto while_break___1;
      }
#line 383
      s___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 384
    cf = (UInt32 )((int )s___0->Freq - 1);
#line 385
    s0 = (UInt32 )((int )c->SummFreq - (int )c->NumStats) - cf;
#line 386
    if (2U * cf <= s0) {
#line 386
      tmp___1 = (UInt32 )(5U * cf > s0);
    } else {
#line 386
      tmp___1 = ((2U * cf + 3U * s0) - 1U) / (2U * s0);
    }
#line 386
    upState.Freq = (Byte )(1U + tmp___1);
  }
  {
#line 389
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 393
    if ((unsigned long )p->HiUnit != (unsigned long )p->LoUnit) {
#line 394
      tmp___2 = p->HiUnit - 12;
#line 394
      p->HiUnit = tmp___2;
#line 394
      c1 = (CTX_PTR___0 )tmp___2;
    } else
#line 395
    if (p->FreeList[0] != 0U) {
      {
#line 396
      tmp___3 = RemoveNode___0(p, 0U);
#line 396
      c1 = (CTX_PTR___0 )tmp___3;
      }
    } else {
      {
#line 399
      tmp___4 = AllocUnitsRare___0(p, 0U);
#line 399
      c1 = (CTX_PTR___0 )tmp___4;
      }
#line 400
      if (! c1) {
#line 401
        return ((CTX_PTR___0 )((void *)0));
      }
    }
    {
#line 403
    c1->NumStats = (UInt16 )1;
#line 404
    *((CPpmd_State *)(& c1->SummFreq)) = upState;
#line 405
    c1->Suffix = (UInt32 )((Byte *)c - p->Base);
#line 406
    numPs --;
#line 406
    SetSuccessor___0(ps[numPs], (UInt32 )((Byte *)c1 - p->Base));
#line 407
    c = c1;
    }
#line 389
    if (! (numPs != 0U)) {
#line 389
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 411
  return (c);
}
}
#line 414 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void SwapStates___0(CPpmd_State *t1 , CPpmd_State *t2 ) 
{ 
  CPpmd_State tmp ;

  {
#line 416
  tmp = *t1;
#line 417
  *t1 = *t2;
#line 418
  *t2 = tmp;
#line 419
  return;
}
}
#line 421 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void UpdateModel___0(CPpmd7 *p ) 
{ 
  CPpmd_Void_Ref successor ;
  CPpmd_Void_Ref fSuccessor ;
  CTX_PTR___0 c ;
  unsigned int s0 ;
  unsigned int ns ;
  CPpmd_State *s ;
  CPpmd_State *s___0 ;
  CPpmd7_Context *tmp ;
  Byte *tmp___0 ;
  CTX_PTR___0 cs ;
  CTX_PTR___0 tmp___1 ;
  unsigned int ns1 ;
  UInt32 cf ;
  UInt32 sf ;
  unsigned int oldNU ;
  unsigned int i ;
  void *ptr ;
  void *tmp___2 ;
  void *oldPtr ;
  UInt32 *d ;
  UInt32 const   *s___1 ;
  UInt32 n ;
  CPpmd_State *s___2 ;
  void *tmp___3 ;
  CPpmd_State *s___3 ;
  CPpmd7_Context *tmp___4 ;

  {
#line 423
  fSuccessor = (unsigned int )(p->FoundState)->SuccessorLow | ((UInt32 )(p->FoundState)->SuccessorHigh << 16);
#line 427
  if ((int )(p->FoundState)->Freq < 31) {
#line 427
    if ((p->MinContext)->Suffix != 0U) {
#line 429
      c = (CPpmd7_Context *)((void *)(p->Base + (p->MinContext)->Suffix));
#line 431
      if ((int )c->NumStats == 1) {
#line 433
        s = (CPpmd_State *)(& c->SummFreq);
#line 434
        if ((int )s->Freq < 32) {
#line 435
          s->Freq = (Byte )((int )s->Freq + 1);
        }
      } else {
#line 439
        s___0 = (CPpmd_State *)((void *)(p->Base + c->Stats));
#line 440
        if ((int )s___0->Symbol != (int )(p->FoundState)->Symbol) {
          {
#line 442
          while (1) {
            while_continue: /* CIL Label */ ;
#line 442
            s___0 ++;
#line 442
            if (! ((int )s___0->Symbol != (int )(p->FoundState)->Symbol)) {
#line 442
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 443
          if ((int )(s___0 + 0)->Freq >= (int )(s___0 + -1)->Freq) {
            {
#line 445
            SwapStates___0(s___0 + 0, s___0 + -1);
#line 446
            s___0 --;
            }
          }
        }
#line 449
        if ((int )s___0->Freq < 115) {
#line 451
          s___0->Freq = (Byte )((int )s___0->Freq + 2);
#line 452
          c->SummFreq = (UInt16 )((int )c->SummFreq + 2);
        }
      }
    }
  }
#line 457
  if (p->OrderFall == 0U) {
    {
#line 459
    tmp = CreateSuccessors___0(p, 1);
#line 459
    p->MaxContext = tmp;
#line 459
    p->MinContext = tmp;
    }
#line 460
    if ((unsigned long )p->MinContext == (unsigned long )((CPpmd7_Context *)0)) {
      {
#line 462
      RestartModel___0(p);
      }
#line 463
      return;
    }
    {
#line 465
    SetSuccessor___0(p->FoundState, (UInt32 )((Byte *)p->MinContext - p->Base));
    }
#line 466
    return;
  }
#line 469
  tmp___0 = p->Text;
#line 469
  (p->Text) ++;
#line 469
  *tmp___0 = (p->FoundState)->Symbol;
#line 470
  successor = (UInt32 )(p->Text - p->Base);
#line 471
  if ((unsigned long )p->Text >= (unsigned long )p->UnitsStart) {
    {
#line 473
    RestartModel___0(p);
    }
#line 474
    return;
  }
#line 477
  if (fSuccessor) {
#line 479
    if (fSuccessor <= successor) {
      {
#line 481
      tmp___1 = CreateSuccessors___0(p, 0);
#line 481
      cs = tmp___1;
      }
#line 482
      if ((unsigned long )cs == (unsigned long )((void *)0)) {
        {
#line 484
        RestartModel___0(p);
        }
#line 485
        return;
      }
#line 487
      fSuccessor = (UInt32 )((Byte *)cs - p->Base);
    }
#line 489
    (p->OrderFall) --;
#line 489
    if (p->OrderFall == 0U) {
#line 491
      successor = fSuccessor;
#line 492
      p->Text -= (unsigned long )p->MaxContext != (unsigned long )p->MinContext;
    }
  } else {
    {
#line 497
    SetSuccessor___0(p->FoundState, successor);
#line 498
    fSuccessor = (UInt32 )((Byte *)p->MinContext - p->Base);
    }
  }
#line 501
  ns = (unsigned int )(p->MinContext)->NumStats;
#line 501
  s0 = ((unsigned int )(p->MinContext)->SummFreq - ns) - (unsigned int )((int )(p->FoundState)->Freq - 1);
#line 503
  c = p->MaxContext;
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! ((unsigned long )c != (unsigned long )p->MinContext)) {
#line 503
      goto while_break___0;
    }
#line 507
    ns1 = (unsigned int )c->NumStats;
#line 507
    if (ns1 != 1U) {
#line 509
      if ((ns1 & 1U) == 0U) {
#line 512
        oldNU = ns1 >> 1;
#line 513
        i = (unsigned int )p->Units2Indx[oldNU - 1U];
#line 514
        if (i != (unsigned int )p->Units2Indx[(oldNU + 1U) - 1U]) {
          {
#line 516
          tmp___2 = AllocUnits___0(p, i + 1U);
#line 516
          ptr = tmp___2;
          }
#line 518
          if (! ptr) {
            {
#line 520
            RestartModel___0(p);
            }
#line 521
            return;
          }
#line 523
          oldPtr = (void *)((CPpmd_State *)((void *)(p->Base + c->Stats)));
#line 524
          d = (UInt32 *)ptr;
#line 524
          s___1 = (UInt32 const   *)oldPtr;
#line 524
          n = oldNU;
          {
#line 524
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 524
            *(d + 0) = (UInt32 )*(s___1 + 0);
#line 524
            *(d + 1) = (UInt32 )*(s___1 + 1);
#line 524
            *(d + 2) = (UInt32 )*(s___1 + 2);
#line 524
            s___1 += 3;
#line 524
            d += 3;
#line 524
            n --;
#line 524
            if (! n) {
#line 524
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 525
          InsertNode___0(p, oldPtr, i);
#line 526
          c->Stats = (UInt32 )((Byte *)ptr - p->Base);
          }
        }
      }
#line 529
      c->SummFreq = (UInt16 )(((int )c->SummFreq + (2U * ns1 < ns)) + 2 * ((4U * ns1 <= ns) & ((unsigned int )c->SummFreq <= 8U * ns1)));
    } else {
      {
#line 533
      tmp___3 = AllocUnits___0(p, 0U);
#line 533
      s___2 = (CPpmd_State *)tmp___3;
      }
#line 534
      if (! s___2) {
        {
#line 536
        RestartModel___0(p);
        }
#line 537
        return;
      }
#line 539
      *s___2 = *((CPpmd_State *)(& c->SummFreq));
#line 540
      c->Stats = (UInt32 )((Byte *)s___2 - p->Base);
#line 541
      if ((int )s___2->Freq < 30) {
#line 542
        s___2->Freq = (Byte )((int )s___2->Freq << 1);
      } else {
#line 544
        s___2->Freq = (Byte )120;
      }
#line 545
      c->SummFreq = (UInt16 )(((unsigned int )s___2->Freq + p->InitEsc) + (unsigned int )(ns > 3U));
    }
#line 547
    cf = (2U * (UInt32 )(p->FoundState)->Freq) * (UInt32 )((int )c->SummFreq + 6);
#line 548
    sf = s0 + (UInt32 )c->SummFreq;
#line 549
    if (cf < 6U * sf) {
#line 551
      cf = (UInt32 )((1 + (cf > sf)) + (cf >= 4U * sf));
#line 552
      c->SummFreq = (UInt16 )((int )c->SummFreq + 3);
    } else {
#line 556
      cf = (UInt32 )(((4 + (cf >= 9U * sf)) + (cf >= 12U * sf)) + (cf >= 15U * sf));
#line 557
      c->SummFreq = (UInt16 )((UInt32 )c->SummFreq + cf);
    }
    {
#line 560
    s___3 = (CPpmd_State *)((void *)(p->Base + c->Stats)) + ns1;
#line 561
    SetSuccessor___0(s___3, successor);
#line 562
    s___3->Symbol = (p->FoundState)->Symbol;
#line 563
    s___3->Freq = (Byte )cf;
#line 564
    c->NumStats = (UInt16 )(ns1 + 1U);
#line 503
    c = (CPpmd7_Context *)((void *)(p->Base + c->Suffix));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 567
  tmp___4 = (CPpmd7_Context *)((void *)(p->Base + fSuccessor));
#line 567
  p->MinContext = tmp___4;
#line 567
  p->MaxContext = tmp___4;
#line 568
  return;
}
}
#line 570 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void Rescale___0(CPpmd7 *p ) 
{ 
  unsigned int i ;
  unsigned int adder ;
  unsigned int sumFreq ;
  unsigned int escFreq ;
  CPpmd_State *stats ;
  CPpmd_State *s ;
  CPpmd_State tmp ;
  CPpmd_State *s1 ;
  CPpmd_State tmp___0 ;
  unsigned int numStats ;
  unsigned int n0 ;
  unsigned int n1 ;
  CPpmd_State tmp___1 ;
  CPpmd_State *tmp___2 ;
  void *tmp___3 ;

  {
#line 573
  stats = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 574
  s = p->FoundState;
#line 576
  tmp = *s;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! ((unsigned long )s != (unsigned long )stats)) {
#line 577
      goto while_break;
    }
#line 578
    *(s + 0) = *(s + -1);
#line 577
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  *s = tmp;
#line 581
  escFreq = (unsigned int )((int )(p->MinContext)->SummFreq - (int )s->Freq);
#line 582
  s->Freq = (Byte )((int )s->Freq + 4);
#line 583
  adder = (unsigned int )(p->OrderFall != 0U);
#line 584
  s->Freq = (Byte )(((unsigned int )s->Freq + adder) >> 1);
#line 585
  sumFreq = (unsigned int )s->Freq;
#line 587
  i = (unsigned int )((int )(p->MinContext)->NumStats - 1);
  {
#line 588
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 590
    s ++;
#line 590
    escFreq -= (unsigned int )s->Freq;
#line 591
    s->Freq = (Byte )(((unsigned int )s->Freq + adder) >> 1);
#line 592
    sumFreq += (unsigned int )s->Freq;
#line 593
    if ((int )(s + 0)->Freq > (int )(s + -1)->Freq) {
#line 595
      s1 = s;
#line 596
      tmp___0 = *s1;
      {
#line 597
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 598
        *(s1 + 0) = *(s1 + -1);
#line 597
        s1 --;
#line 597
        if ((unsigned long )s1 != (unsigned long )stats) {
#line 597
          if (! ((int )tmp___0.Freq > (int )(s1 + -1)->Freq)) {
#line 597
            goto while_break___1;
          }
        } else {
#line 597
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 600
      *s1 = tmp___0;
    }
#line 588
    i --;
#line 588
    if (! i) {
#line 588
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 605
  if ((int )s->Freq == 0) {
#line 607
    numStats = (unsigned int )(p->MinContext)->NumStats;
    {
#line 609
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 609
      i ++;
#line 609
      s --;
#line 609
      if (! ((int )s->Freq == 0)) {
#line 609
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 610
    escFreq += i;
#line 611
    (p->MinContext)->NumStats = (UInt16 )((unsigned int )(p->MinContext)->NumStats - i);
#line 612
    if ((int )(p->MinContext)->NumStats == 1) {
#line 614
      tmp___1 = *stats;
      {
#line 615
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 617
        tmp___1.Freq = (Byte )((int )tmp___1.Freq - ((int )tmp___1.Freq >> 1));
#line 618
        escFreq >>= 1;
#line 615
        if (! (escFreq > 1U)) {
#line 615
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 621
      InsertNode___0(p, (void *)stats, (unsigned int )p->Units2Indx[((numStats + 1U) >> 1) - 1U]);
#line 622
      tmp___2 = (CPpmd_State *)(& (p->MinContext)->SummFreq);
#line 622
      p->FoundState = tmp___2;
#line 622
      *tmp___2 = tmp___1;
      }
#line 623
      return;
    }
#line 625
    n0 = (numStats + 1U) >> 1;
#line 626
    n1 = (unsigned int )(((int )(p->MinContext)->NumStats + 1) >> 1);
#line 627
    if (n0 != n1) {
      {
#line 628
      tmp___3 = ShrinkUnits___0(p, (void *)stats, n0, n1);
#line 628
      (p->MinContext)->Stats = (UInt32 )((Byte *)tmp___3 - p->Base);
      }
    }
  }
#line 630
  (p->MinContext)->SummFreq = (UInt16 )((sumFreq + escFreq) - (escFreq >> 1));
#line 631
  p->FoundState = (CPpmd_State *)((void *)(p->Base + (p->MinContext)->Stats));
#line 632
  return;
}
}
#line 634 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
CPpmd_See *Ppmd7_MakeEscFreq(CPpmd7 *p , unsigned int numMasked , UInt32 *escFreq ) 
{ 
  CPpmd_See *see ;
  unsigned int nonMasked ;
  unsigned int r ;

  {
#line 637
  nonMasked = (unsigned int )(p->MinContext)->NumStats - numMasked;
#line 638
  if ((int )(p->MinContext)->NumStats != 256) {
#line 640
    see = (((p->See[p->NS2Indx[nonMasked - 1U]] + (nonMasked < (unsigned int )((CPpmd7_Context *)((void *)(p->Base + (p->MinContext)->Suffix)))->NumStats - (unsigned int )(p->MinContext)->NumStats)) + 2 * ((int )(p->MinContext)->SummFreq < 11 * (int )(p->MinContext)->NumStats)) + 4 * (numMasked > nonMasked)) + p->HiBitsFlag;
#line 646
    r = (unsigned int )((int )see->Summ >> (int )see->Shift);
#line 647
    see->Summ = (UInt16 )((unsigned int )see->Summ - r);
#line 648
    *escFreq = r + (unsigned int )(r == 0U);
  } else {
#line 653
    see = & p->DummySee;
#line 654
    *escFreq = (UInt32 )1;
  }
#line 656
  return (see);
}
}
#line 659 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
static void NextContext___0(CPpmd7 *p ) 
{ 
  CTX_PTR___0 c ;
  CPpmd7_Context *tmp ;

  {
#line 661
  c = (CPpmd7_Context *)((void *)(p->Base + ((unsigned int )(p->FoundState)->SuccessorLow | ((UInt32 )(p->FoundState)->SuccessorHigh << 16))));
#line 662
  if (p->OrderFall == 0U) {
#line 662
    if ((unsigned long )((Byte *)c) > (unsigned long )p->Text) {
#line 663
      tmp = c;
#line 663
      p->MaxContext = tmp;
#line 663
      p->MinContext = tmp;
    } else {
      {
#line 665
      UpdateModel___0(p);
      }
    }
  } else {
    {
#line 665
    UpdateModel___0(p);
    }
  }
#line 666
  return;
}
}
#line 668 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
void Ppmd7_Update1(CPpmd7 *p ) 
{ 
  CPpmd_State *s ;

  {
#line 670
  s = p->FoundState;
#line 671
  s->Freq = (Byte )((int )s->Freq + 4);
#line 672
  (p->MinContext)->SummFreq = (UInt16 )((int )(p->MinContext)->SummFreq + 4);
#line 673
  if ((int )(s + 0)->Freq > (int )(s + -1)->Freq) {
    {
#line 675
    SwapStates___0(s + 0, s + -1);
#line 676
    s --;
#line 676
    p->FoundState = s;
    }
#line 677
    if ((int )s->Freq > 124) {
      {
#line 678
      Rescale___0(p);
      }
    }
  }
  {
#line 680
  NextContext___0(p);
  }
#line 681
  return;
}
}
#line 683 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
void Ppmd7_Update1_0(CPpmd7 *p ) 
{ 
  Byte tmp ;

  {
#line 685
  p->PrevSuccess = (unsigned int )(2 * (int )(p->FoundState)->Freq > (int )(p->MinContext)->SummFreq);
#line 686
  p->RunLength = (Int32 )((unsigned int )p->RunLength + p->PrevSuccess);
#line 687
  (p->MinContext)->SummFreq = (UInt16 )((int )(p->MinContext)->SummFreq + 4);
#line 688
  tmp = (Byte )((int )(p->FoundState)->Freq + 4);
#line 688
  (p->FoundState)->Freq = tmp;
#line 688
  if ((int )tmp > 124) {
    {
#line 689
    Rescale___0(p);
    }
  }
  {
#line 690
  NextContext___0(p);
  }
#line 691
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
void Ppmd7_UpdateBin(CPpmd7 *p ) 
{ 
  int tmp ;

  {
#line 695
  if ((int )(p->FoundState)->Freq < 128) {
#line 695
    tmp = 1;
  } else {
#line 695
    tmp = 0;
  }
  {
#line 695
  (p->FoundState)->Freq = (Byte )((int )(p->FoundState)->Freq + tmp);
#line 696
  p->PrevSuccess = 1U;
#line 697
  (p->RunLength) ++;
#line 698
  NextContext___0(p);
  }
#line 699
  return;
}
}
#line 701 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/Ppmd7.c"
void Ppmd7_Update2(CPpmd7 *p ) 
{ 
  Byte tmp ;

  {
#line 703
  (p->MinContext)->SummFreq = (UInt16 )((int )(p->MinContext)->SummFreq + 4);
#line 704
  tmp = (Byte )((int )(p->FoundState)->Freq + 4);
#line 704
  (p->FoundState)->Freq = tmp;
#line 704
  if ((int )tmp > 124) {
    {
#line 705
    Rescale___0(p);
    }
  }
  {
#line 706
  p->RunLength = p->InitRL;
#line 707
  UpdateModel___0(p);
  }
#line 708
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.h"
SRes Xz_Encode(ISeqOutStream *outStream , ISeqInStream *inStream , CLzma2EncProps const   *lzma2Props ,
               Bool useSubblock , ICompressProgress *progress ) ;
#line 19
SRes Xz_EncodeEmpty(ISeqOutStream *outStream ) ;
#line 17 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static void *SzBigAlloc(void *p , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 17
  p = p;
#line 17
  tmp = BigAlloc(size);
  }
#line 17
  return (tmp);
}
}
#line 18 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static void SzBigFree(void *p , void *address ) 
{ 


  {
  {
#line 18
  p = p;
#line 18
  BigFree(address);
  }
#line 18
  return;
}
}
#line 19 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static ISzAlloc g_BigAlloc  =    {& SzBigAlloc, & SzBigFree};
#line 21 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static void *SzAlloc(void *p , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 21
  p = p;
#line 21
  tmp = MyAlloc(size);
  }
#line 21
  return (tmp);
}
}
#line 22 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static void SzFree(void *p , void *address ) 
{ 


  {
  {
#line 22
  p = p;
#line 22
  MyFree(address);
  }
#line 22
  return;
}
}
#line 23 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static ISzAlloc g_Alloc  =    {& SzAlloc, & SzFree};
#line 30 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static SRes WriteBytes(ISeqOutStream *s , void const   *buf , UInt32 size ) 
{ 
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 32
  tmp___1 = (*(s->Write))((void *)s, buf, (size_t )size);
  }
#line 32
  if (tmp___1 == (size_t )size) {
#line 32
    tmp___0 = 0;
  } else {
#line 32
    tmp___0 = 9;
  }
#line 32
  return (tmp___0);
}
}
#line 35 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static SRes WriteBytesAndCrc(ISeqOutStream *s , void const   *buf , UInt32 size ,
                             UInt32 *crc ) 
{ 
  SRes tmp ;

  {
  {
#line 37
  *crc = CrcUpdate(*crc, buf, (size_t )size);
#line 38
  tmp = WriteBytes(s, buf, size);
  }
#line 38
  return (tmp);
}
}
#line 41 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
SRes Xz_WriteHeader(CXzStreamFlags f , ISeqOutStream *s ) 
{ 
  UInt32 crc ;
  Byte header[12] ;
  SRes tmp ;

  {
  {
#line 45
  memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)(XZ_SIG),
         (size_t )6);
#line 46
  header[6] = (Byte )((int )f >> 8);
#line 47
  header[7] = (Byte )((int )f & 255);
#line 48
  crc = CrcCalc((void const   *)(header + 6), (size_t )2);
#line 49
  *((UInt32 *)((header + 6) + 2)) = crc;
#line 50
  tmp = WriteBytes(s, (void const   *)(header), (UInt32 )12);
  }
#line 50
  return (tmp);
}
}
#line 53 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
SRes XzBlock_WriteHeader(CXzBlock const   *p , ISeqOutStream *s ) 
{ 
  Byte header[1024] ;
  unsigned int pos ;
  int numFilters ;
  int i ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  CXzFilter const   *f ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  SRes tmp___5 ;

  {
#line 57
  pos = 1U;
#line 59
  tmp = pos;
#line 59
  pos ++;
#line 59
  header[tmp] = (Byte )p->flags;
#line 61
  if (((int const   )p->flags & (int const   )(1 << 6)) != 0) {
    {
#line 61
    tmp___0 = Xz_WriteVarInt(header + pos, (UInt64 )p->packSize);
#line 61
    pos += tmp___0;
    }
  }
#line 62
  if (((int const   )p->flags & (int const   )(1 << 7)) != 0) {
    {
#line 62
    tmp___1 = Xz_WriteVarInt(header + pos, (UInt64 )p->unpackSize);
#line 62
    pos += tmp___1;
    }
  }
#line 63
  numFilters = (int )(((int const   )p->flags & 3) + 1);
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < numFilters)) {
#line 64
      goto while_break;
    }
    {
#line 66
    f = (CXzFilter const   *)(& p->filters[i]);
#line 67
    tmp___2 = Xz_WriteVarInt(header + pos, (UInt64 )f->id);
#line 67
    pos += tmp___2;
#line 68
    tmp___3 = Xz_WriteVarInt(header + pos, (UInt64 )f->propsSize);
#line 68
    pos += tmp___3;
#line 69
    memcpy((void */* __restrict  */)(header + pos), (void const   */* __restrict  */)(f->props),
           (size_t )f->propsSize);
#line 70
    pos += (unsigned int )f->propsSize;
#line 64
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! ((pos & 3U) != 0U)) {
#line 72
      goto while_break___0;
    }
#line 73
    tmp___4 = pos;
#line 73
    pos ++;
#line 73
    header[tmp___4] = (Byte )0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 74
  header[0] = (Byte )(pos >> 2);
#line 75
  *((UInt32 *)(header + pos)) = CrcCalc((void const   *)(header), (size_t )pos);
#line 76
  tmp___5 = WriteBytes(s, (void const   *)(header), pos + 4U);
  }
#line 76
  return (tmp___5);
}
}
#line 79 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
SRes Xz_WriteFooter(CXzStream *p , ISeqOutStream *s ) 
{ 
  Byte buf[32] ;
  UInt64 globalPos ;
  UInt32 crc ;
  unsigned int pos ;
  unsigned int tmp ;
  size_t i ;
  int __result__ ;
  SRes tmp___0 ;
  CXzBlockSizes const   *block ;
  unsigned int tmp___1 ;
  int __result_____0 ;
  SRes tmp___2 ;
  int __result_____1 ;
  SRes tmp___3 ;
  int __result_____2 ;
  SRes tmp___4 ;
  UInt32 indexSize ;
  SRes tmp___5 ;

  {
  {
#line 84
  crc = 4294967295U;
#line 85
  tmp = Xz_WriteVarInt(buf + 1, (UInt64 )p->numBlocks);
#line 85
  pos = 1U + tmp;
#line 88
  globalPos = (UInt64 )pos;
#line 89
  buf[0] = (Byte )0;
#line 90
  tmp___0 = WriteBytesAndCrc(s, (void const   *)(buf), pos, & crc);
#line 90
  __result__ = tmp___0;
  }
#line 90
  if (__result__ != 0) {
#line 90
    return (__result__);
  }
#line 91
  i = (size_t )0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < p->numBlocks)) {
#line 91
      goto while_break;
    }
    {
#line 93
    block = (CXzBlockSizes const   *)(p->blocks + i);
#line 94
    pos = Xz_WriteVarInt(buf, (UInt64 )block->totalSize);
#line 95
    tmp___1 = Xz_WriteVarInt(buf + pos, (UInt64 )block->unpackSize);
#line 95
    pos += tmp___1;
#line 96
    globalPos += (UInt64 )pos;
#line 97
    tmp___2 = WriteBytesAndCrc(s, (void const   *)(buf), pos, & crc);
#line 97
    __result_____0 = tmp___2;
    }
#line 97
    if (__result_____0 != 0) {
#line 97
      return (__result_____0);
    }
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  pos = (unsigned int )globalPos & 3U;
#line 100
  if (pos != 0U) {
    {
#line 102
    buf[2] = (Byte )0;
#line 102
    buf[1] = buf[2];
#line 102
    buf[0] = buf[1];
#line 103
    tmp___3 = WriteBytesAndCrc(s, (void const   *)(buf), 4U - pos, & crc);
#line 103
    __result_____1 = tmp___3;
    }
#line 103
    if (__result_____1 != 0) {
#line 103
      return (__result_____1);
    }
#line 104
    globalPos += (UInt64 )(4U - pos);
  }
  {
#line 107
  *((UInt32 *)(buf)) = crc ^ 4294967295U;
#line 108
  tmp___4 = WriteBytes(s, (void const   *)(buf), (UInt32 )4);
#line 108
  __result_____2 = tmp___4;
  }
#line 108
  if (__result_____2 != 0) {
#line 108
    return (__result_____2);
  }
  {
#line 109
  globalPos += 4ULL;
#line 114
  indexSize = (UInt32 )((globalPos >> 2) - 1ULL);
#line 115
  *((UInt32 *)(buf + 4)) = indexSize;
#line 116
  buf[8] = (Byte )((int )p->flags >> 8);
#line 117
  buf[9] = (Byte )((int )p->flags & 255);
#line 118
  *((UInt32 *)(buf)) = CrcCalc((void const   *)(buf + 4), (size_t )6);
#line 119
  memcpy((void */* __restrict  */)(buf + 10), (void const   */* __restrict  */)(XZ_FOOTER_SIG),
         (size_t )2);
#line 120
  tmp___5 = WriteBytes(s, (void const   *)(buf), (UInt32 )12);
  }
#line 120
  return (tmp___5);
}
}
#line 124 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
SRes Xz_AddIndexRecord(CXzStream *p , UInt64 unpackSize , UInt64 totalSize , ISzAlloc *alloc ) 
{ 
  size_t num ;
  size_t newSize ;
  CXzBlockSizes *blocks ;
  void *tmp ;
  CXzBlockSizes *block ;
  size_t tmp___0 ;

  {
#line 126
  if ((unsigned long )p->blocks == (unsigned long )((CXzBlockSizes *)0)) {
#line 126
    goto _L;
  } else
#line 126
  if (p->numBlocksAllocated == p->numBlocks) {
    _L: /* CIL Label */ 
#line 128
    num = (p->numBlocks + 1UL) * 2UL;
#line 129
    newSize = sizeof(CXzBlockSizes ) * num;
#line 131
    if (newSize / sizeof(CXzBlockSizes ) != num) {
#line 132
      return (2);
    }
    {
#line 133
    tmp = (*(alloc->Alloc))((void *)alloc, newSize);
#line 133
    blocks = (CXzBlockSizes *)tmp;
    }
#line 134
    if ((unsigned long )blocks == (unsigned long )((CXzBlockSizes *)0)) {
#line 135
      return (2);
    }
#line 136
    if (p->numBlocks != 0UL) {
      {
#line 138
      memcpy((void */* __restrict  */)blocks, (void const   */* __restrict  */)p->blocks,
             p->numBlocks * sizeof(CXzBlockSizes ));
#line 139
      Xz_Free(p, alloc);
      }
    }
#line 141
    p->blocks = blocks;
#line 142
    p->numBlocksAllocated = num;
  }
#line 145
  tmp___0 = p->numBlocks;
#line 145
  (p->numBlocks) ++;
#line 145
  block = p->blocks + tmp___0;
#line 146
  block->totalSize = totalSize;
#line 147
  block->unpackSize = unpackSize;
#line 149
  return (0);
}
}
#line 162 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
void SeqCheckInStream_Init(CSeqCheckInStream *p , int mode ) 
{ 


  {
  {
#line 164
  p->processed = (UInt64 )0;
#line 165
  XzCheck_Init(& p->check, mode);
  }
#line 166
  return;
}
}
#line 168 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
void SeqCheckInStream_GetDigest(CSeqCheckInStream *p , Byte *digest ) 
{ 


  {
  {
#line 170
  XzCheck_Final(& p->check, digest);
  }
#line 171
  return;
}
}
#line 173 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static SRes SeqCheckInStream_Read(void *pp , void *data , size_t *size ) 
{ 
  CSeqCheckInStream *p ;
  SRes res ;
  SRes tmp ;

  {
  {
#line 175
  p = (CSeqCheckInStream *)pp;
#line 176
  tmp = (*((p->realStream)->Read))((void *)p->realStream, data, size);
#line 176
  res = tmp;
#line 177
  XzCheck_Update(& p->check, (void const   *)data, *size);
#line 178
  p->processed += (UInt64 )*size;
  }
#line 179
  return (res);
}
}
#line 191 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static size_t MyWrite___0(void *pp , void const   *data , size_t size ) 
{ 
  CSeqSizeOutStream *p ;

  {
  {
#line 193
  p = (CSeqSizeOutStream *)pp;
#line 194
  size = (*((p->realStream)->Write))((void *)p->realStream, data, size);
#line 195
  p->processed += (UInt64 )size;
  }
#line 196
  return (size);
}
}
#line 358 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static void Lzma2WithFilters_Construct(CLzma2WithFilters *p , ISzAlloc *alloc , ISzAlloc *bigAlloc ) 
{ 


  {
#line 360
  p->alloc = alloc;
#line 361
  p->bigAlloc = bigAlloc;
#line 362
  p->lzma2 = (void *)0;
#line 367
  return;
}
}
#line 369 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static SRes Lzma2WithFilters_Create(CLzma2WithFilters *p ) 
{ 


  {
  {
#line 371
  p->lzma2 = Lzma2Enc_Create(p->alloc, p->bigAlloc);
  }
#line 372
  if ((unsigned long )p->lzma2 == (unsigned long )((CLzma2EncHandle )0)) {
#line 373
    return (2);
  }
#line 374
  return (0);
}
}
#line 377 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static void Lzma2WithFilters_Free(CLzma2WithFilters *p ) 
{ 


  {
#line 382
  if (p->lzma2) {
    {
#line 384
    Lzma2Enc_Destroy(p->lzma2);
#line 385
    p->lzma2 = (void *)0;
    }
  }
#line 387
  return;
}
}
#line 389 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
static SRes Xz_Compress(CXzStream *xz , CLzma2WithFilters *lzmaf , ISeqOutStream *outStream ,
                        ISeqInStream *inStream , CLzma2EncProps const   *lzma2Props ,
                        Bool useSubblock , ICompressProgress *progress ) 
{ 
  int __result__ ;
  SRes tmp ;
  int __result_____0 ;
  SRes tmp___0 ;
  CSeqCheckInStream checkInStream ;
  CSeqSizeOutStream seqSizeOutStream ;
  CXzBlock block ;
  int filterIndex ;
  int tmp___1 ;
  CXzFilter *f ;
  int tmp___2 ;
  CXzFilter *f___0 ;
  int tmp___3 ;
  int __result_____1 ;
  SRes tmp___4 ;
  UInt64 packPos ;
  SRes res ;
  SRes tmp___5 ;
  int __result_____2 ;
  unsigned int padSize ;
  Byte buf[128] ;
  unsigned int tmp___6 ;
  int __result_____3 ;
  unsigned int tmp___7 ;
  SRes tmp___8 ;
  int __result_____4 ;
  SRes tmp___9 ;
  SRes tmp___10 ;

  {
  {
#line 397
  xz->flags = (CXzStreamFlags )1;
#line 399
  tmp = Lzma2Enc_SetProps(lzmaf->lzma2, lzma2Props);
#line 399
  __result__ = tmp;
  }
#line 399
  if (__result__ != 0) {
#line 399
    return (__result__);
  }
  {
#line 400
  tmp___0 = Xz_WriteHeader(xz->flags, outStream);
#line 400
  __result_____0 = tmp___0;
  }
#line 400
  if (__result_____0 != 0) {
#line 400
    return (__result_____0);
  }
#line 406
  filterIndex = 0;
#line 408
  block.flags = (Byte )0;
#line 409
  if (useSubblock) {
#line 409
    tmp___1 = 1;
  } else {
#line 409
    tmp___1 = 0;
  }
#line 409
  block.flags = (Byte )((int )block.flags | ((1 + tmp___1) - 1));
#line 411
  if (useSubblock) {
#line 413
    tmp___2 = filterIndex;
#line 413
    filterIndex ++;
#line 413
    f = & block.filters[tmp___2];
#line 414
    f->id = (UInt64 )1;
#line 415
    f->propsSize = (UInt32 )0;
  }
  {
#line 419
  tmp___3 = filterIndex;
#line 419
  filterIndex ++;
#line 419
  f___0 = & block.filters[tmp___3];
#line 420
  f___0->id = (UInt64 )33;
#line 421
  f___0->propsSize = (UInt32 )1;
#line 422
  f___0->props[0] = Lzma2Enc_WriteProperties(lzmaf->lzma2);
#line 425
  seqSizeOutStream.p.Write = & MyWrite___0;
#line 426
  seqSizeOutStream.realStream = outStream;
#line 427
  seqSizeOutStream.processed = (UInt64 )0;
#line 429
  tmp___4 = XzBlock_WriteHeader((CXzBlock const   *)(& block), & seqSizeOutStream.p);
#line 429
  __result_____1 = tmp___4;
  }
#line 429
  if (__result_____1 != 0) {
#line 429
    return (__result_____1);
  }
  {
#line 431
  checkInStream.p.Read = & SeqCheckInStream_Read;
#line 432
  checkInStream.realStream = inStream;
#line 433
  SeqCheckInStream_Init(& checkInStream, (int )xz->flags & 15);
#line 444
  packPos = seqSizeOutStream.processed;
#line 445
  tmp___5 = Lzma2Enc_Encode(lzmaf->lzma2, & seqSizeOutStream.p, & checkInStream.p,
                            progress);
#line 445
  res = tmp___5;
#line 451
  __result_____2 = res;
  }
#line 451
  if (__result_____2 != 0) {
#line 451
    return (__result_____2);
  }
#line 452
  block.unpackSize = checkInStream.processed;
#line 453
  block.packSize = seqSizeOutStream.processed - packPos;
#line 457
  padSize = 0U;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! ((((unsigned int )block.packSize + padSize) & 3U) != 0U)) {
#line 459
      goto while_break;
    }
#line 460
    tmp___6 = padSize;
#line 460
    padSize ++;
#line 460
    buf[tmp___6] = (Byte )0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 461
  SeqCheckInStream_GetDigest(& checkInStream, buf + padSize);
#line 462
  tmp___7 = XzFlags_GetCheckSize(xz->flags);
#line 462
  tmp___8 = WriteBytes(& seqSizeOutStream.p, (void const   *)(buf), padSize + tmp___7);
#line 462
  __result_____3 = tmp___8;
  }
#line 462
  if (__result_____3 != 0) {
#line 462
    return (__result_____3);
  }
  {
#line 463
  tmp___9 = Xz_AddIndexRecord(xz, block.unpackSize, seqSizeOutStream.processed - (UInt64 )padSize,
                              & g_Alloc);
#line 463
  __result_____4 = tmp___9;
  }
#line 463
  if (__result_____4 != 0) {
#line 463
    return (__result_____4);
  }
  {
#line 466
  tmp___10 = Xz_WriteFooter(xz, outStream);
  }
#line 466
  return (tmp___10);
}
}
#line 469 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
SRes Xz_Encode(ISeqOutStream *outStream , ISeqInStream *inStream , CLzma2EncProps const   *lzma2Props ,
               Bool useSubblock , ICompressProgress *progress ) 
{ 
  SRes res ;
  CXzStream xz ;
  CLzma2WithFilters lzmaf ;

  {
  {
#line 476
  Xz_Construct(& xz);
#line 477
  Lzma2WithFilters_Construct(& lzmaf, & g_Alloc, & g_BigAlloc);
#line 478
  res = Lzma2WithFilters_Create(& lzmaf);
  }
#line 479
  if (res == 0) {
    {
#line 480
    res = Xz_Compress(& xz, & lzmaf, outStream, inStream, lzma2Props, useSubblock,
                      progress);
    }
  }
  {
#line 482
  Lzma2WithFilters_Free(& lzmaf);
#line 483
  Xz_Free(& xz, & g_Alloc);
  }
#line 484
  return (res);
}
}
#line 487 "/home/wheatley/newnew/temp/p7zip-9.20.1~dfsg.1/CPP/7zip/Bundles/Alone/../../../../C/XzEnc.c"
SRes Xz_EncodeEmpty(ISeqOutStream *outStream ) 
{ 
  SRes res ;
  CXzStream xz ;

  {
  {
#line 491
  Xz_Construct(& xz);
#line 492
  res = Xz_WriteHeader(xz.flags, outStream);
  }
#line 493
  if (res == 0) {
    {
#line 494
    res = Xz_WriteFooter(& xz, outStream);
    }
  }
  {
#line 495
  Xz_Free(& xz, & g_Alloc);
  }
#line 496
  return (res);
}
}
