/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 31 "/usr/include/linux/dvb/frontend.h"
enum fe_type {
    FE_QPSK = 0,
    FE_QAM = 1,
    FE_OFDM = 2,
    FE_ATSC = 3
} ;
#line 31 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_type fe_type_t;
#line 39
enum fe_caps {
    FE_IS_STUPID = 0,
    FE_CAN_INVERSION_AUTO = 1,
    FE_CAN_FEC_1_2 = 2,
    FE_CAN_FEC_2_3 = 4,
    FE_CAN_FEC_3_4 = 8,
    FE_CAN_FEC_4_5 = 16,
    FE_CAN_FEC_5_6 = 32,
    FE_CAN_FEC_6_7 = 64,
    FE_CAN_FEC_7_8 = 128,
    FE_CAN_FEC_8_9 = 256,
    FE_CAN_FEC_AUTO = 512,
    FE_CAN_QPSK = 1024,
    FE_CAN_QAM_16 = 2048,
    FE_CAN_QAM_32 = 4096,
    FE_CAN_QAM_64 = 8192,
    FE_CAN_QAM_128 = 16384,
    FE_CAN_QAM_256 = 32768,
    FE_CAN_QAM_AUTO = 65536,
    FE_CAN_TRANSMISSION_MODE_AUTO = 131072,
    FE_CAN_BANDWIDTH_AUTO = 262144,
    FE_CAN_GUARD_INTERVAL_AUTO = 524288,
    FE_CAN_HIERARCHY_AUTO = 1048576,
    FE_CAN_8VSB = 2097152,
    FE_CAN_16VSB = 4194304,
    FE_HAS_EXTENDED_CAPS = 8388608,
    FE_CAN_MULTISTREAM = 67108864,
    FE_CAN_TURBO_FEC = 134217728,
    FE_CAN_2G_MODULATION = 268435456,
    FE_NEEDS_BENDING = 536870912,
    FE_CAN_RECOVER = 1073741824,
    FE_CAN_MUTE_TS = 2147483648U
} ;
#line 39 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_caps fe_caps_t;
#line 74 "/usr/include/linux/dvb/frontend.h"
struct dvb_frontend_info {
   char name[128] ;
   fe_type_t type ;
   __u32 frequency_min ;
   __u32 frequency_max ;
   __u32 frequency_stepsize ;
   __u32 frequency_tolerance ;
   __u32 symbol_rate_min ;
   __u32 symbol_rate_max ;
   __u32 symbol_rate_tolerance ;
   __u32 notifier_delay ;
   fe_caps_t caps ;
};
#line 93 "/usr/include/linux/dvb/frontend.h"
struct dvb_diseqc_master_cmd {
   __u8 msg[6] ;
   __u8 msg_len ;
};
#line 106
enum fe_sec_voltage {
    SEC_VOLTAGE_13 = 0,
    SEC_VOLTAGE_18 = 1,
    SEC_VOLTAGE_OFF = 2
} ;
#line 106 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_sec_voltage fe_sec_voltage_t;
#line 113
enum fe_sec_tone_mode {
    SEC_TONE_ON = 0,
    SEC_TONE_OFF = 1
} ;
#line 113 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_sec_tone_mode fe_sec_tone_mode_t;
#line 119
enum fe_sec_mini_cmd {
    SEC_MINI_A = 0,
    SEC_MINI_B = 1
} ;
#line 119 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_sec_mini_cmd fe_sec_mini_cmd_t;
#line 137
enum fe_status {
    FE_HAS_SIGNAL = 1,
    FE_HAS_CARRIER = 2,
    FE_HAS_VITERBI = 4,
    FE_HAS_SYNC = 8,
    FE_HAS_LOCK = 16,
    FE_TIMEDOUT = 32,
    FE_REINIT = 64
} ;
#line 137 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_status fe_status_t;
#line 147
enum fe_spectral_inversion {
    INVERSION_OFF = 0,
    INVERSION_ON = 1,
    INVERSION_AUTO = 2
} ;
#line 147 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_spectral_inversion fe_spectral_inversion_t;
#line 154
enum fe_code_rate {
    FEC_NONE = 0,
    FEC_1_2 = 1,
    FEC_2_3 = 2,
    FEC_3_4 = 3,
    FEC_4_5 = 4,
    FEC_5_6 = 5,
    FEC_6_7 = 6,
    FEC_7_8 = 7,
    FEC_8_9 = 8,
    FEC_AUTO = 9,
    FEC_3_5 = 10,
    FEC_9_10 = 11,
    FEC_2_5 = 12
} ;
#line 154 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_code_rate fe_code_rate_t;
#line 171
enum fe_modulation {
    QPSK = 0,
    QAM_16 = 1,
    QAM_32 = 2,
    QAM_64 = 3,
    QAM_128 = 4,
    QAM_256 = 5,
    QAM_AUTO = 6,
    VSB_8 = 7,
    VSB_16 = 8,
    PSK_8 = 9,
    APSK_16 = 10,
    APSK_32 = 11,
    DQPSK = 12,
    QAM_4_NR = 13
} ;
#line 171 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_modulation fe_modulation_t;
#line 188
enum fe_transmit_mode {
    TRANSMISSION_MODE_2K = 0,
    TRANSMISSION_MODE_8K = 1,
    TRANSMISSION_MODE_AUTO = 2,
    TRANSMISSION_MODE_4K = 3,
    TRANSMISSION_MODE_1K = 4,
    TRANSMISSION_MODE_16K = 5,
    TRANSMISSION_MODE_32K = 6,
    TRANSMISSION_MODE_C1 = 7,
    TRANSMISSION_MODE_C3780 = 8
} ;
#line 188 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_transmit_mode fe_transmit_mode_t;
#line 200
enum fe_bandwidth {
    BANDWIDTH_8_MHZ = 0,
    BANDWIDTH_7_MHZ = 1,
    BANDWIDTH_6_MHZ = 2,
    BANDWIDTH_AUTO = 3,
    BANDWIDTH_5_MHZ = 4,
    BANDWIDTH_10_MHZ = 5,
    BANDWIDTH_1_712_MHZ = 6
} ;
#line 200 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_bandwidth fe_bandwidth_t;
#line 210
enum fe_guard_interval {
    GUARD_INTERVAL_1_32 = 0,
    GUARD_INTERVAL_1_16 = 1,
    GUARD_INTERVAL_1_8 = 2,
    GUARD_INTERVAL_1_4 = 3,
    GUARD_INTERVAL_AUTO = 4,
    GUARD_INTERVAL_1_128 = 5,
    GUARD_INTERVAL_19_128 = 6,
    GUARD_INTERVAL_19_256 = 7,
    GUARD_INTERVAL_PN420 = 8,
    GUARD_INTERVAL_PN595 = 9,
    GUARD_INTERVAL_PN945 = 10
} ;
#line 210 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_guard_interval fe_guard_interval_t;
#line 225
enum fe_hierarchy {
    HIERARCHY_NONE = 0,
    HIERARCHY_1 = 1,
    HIERARCHY_2 = 2,
    HIERARCHY_4 = 3,
    HIERARCHY_AUTO = 4
} ;
#line 225 "/usr/include/linux/dvb/frontend.h"
typedef enum fe_hierarchy fe_hierarchy_t;
#line 240 "/usr/include/linux/dvb/frontend.h"
struct dvb_qpsk_parameters {
   __u32 symbol_rate ;
   fe_code_rate_t fec_inner ;
};
#line 245 "/usr/include/linux/dvb/frontend.h"
struct dvb_qam_parameters {
   __u32 symbol_rate ;
   fe_code_rate_t fec_inner ;
   fe_modulation_t modulation ;
};
#line 251 "/usr/include/linux/dvb/frontend.h"
struct dvb_vsb_parameters {
   fe_modulation_t modulation ;
};
#line 255 "/usr/include/linux/dvb/frontend.h"
struct dvb_ofdm_parameters {
   fe_bandwidth_t bandwidth ;
   fe_code_rate_t code_rate_HP ;
   fe_code_rate_t code_rate_LP ;
   fe_modulation_t constellation ;
   fe_transmit_mode_t transmission_mode ;
   fe_guard_interval_t guard_interval ;
   fe_hierarchy_t hierarchy_information ;
};
#line 266 "/usr/include/linux/dvb/frontend.h"
union __anonunion_u_34 {
   struct dvb_qpsk_parameters qpsk ;
   struct dvb_qam_parameters qam ;
   struct dvb_ofdm_parameters ofdm ;
   struct dvb_vsb_parameters vsb ;
};
#line 266 "/usr/include/linux/dvb/frontend.h"
struct dvb_frontend_parameters {
   __u32 frequency ;
   fe_spectral_inversion_t inversion ;
   union __anonunion_u_34 u ;
};
#line 278 "/usr/include/linux/dvb/frontend.h"
struct dvb_frontend_event {
   fe_status_t status ;
   struct dvb_frontend_parameters parameters ;
};
#line 172 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/tune.c"
struct diseqc_cmd {
   struct dvb_diseqc_master_cmd cmd ;
   uint32_t wait ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 151 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 33 "/usr/include/linux/dvb/dmx.h"
enum __anonenum_dmx_output_t_33 {
    DMX_OUT_DECODER = 0,
    DMX_OUT_TAP = 1,
    DMX_OUT_TS_TAP = 2,
    DMX_OUT_TSDEMUX_TAP = 3
} ;
#line 33 "/usr/include/linux/dvb/dmx.h"
typedef enum __anonenum_dmx_output_t_33 dmx_output_t;
#line 45
enum __anonenum_dmx_input_t_34 {
    DMX_IN_FRONTEND = 0,
    DMX_IN_DVR = 1
} ;
#line 45 "/usr/include/linux/dvb/dmx.h"
typedef enum __anonenum_dmx_input_t_34 dmx_input_t;
#line 52
enum dmx_ts_pes {
    DMX_PES_AUDIO0 = 0,
    DMX_PES_VIDEO0 = 1,
    DMX_PES_TELETEXT0 = 2,
    DMX_PES_SUBTITLE0 = 3,
    DMX_PES_PCR0 = 4,
    DMX_PES_AUDIO1 = 5,
    DMX_PES_VIDEO1 = 6,
    DMX_PES_TELETEXT1 = 7,
    DMX_PES_SUBTITLE1 = 8,
    DMX_PES_PCR1 = 9,
    DMX_PES_AUDIO2 = 10,
    DMX_PES_VIDEO2 = 11,
    DMX_PES_TELETEXT2 = 12,
    DMX_PES_SUBTITLE2 = 13,
    DMX_PES_PCR2 = 14,
    DMX_PES_AUDIO3 = 15,
    DMX_PES_VIDEO3 = 16,
    DMX_PES_TELETEXT3 = 17,
    DMX_PES_SUBTITLE3 = 18,
    DMX_PES_PCR3 = 19,
    DMX_PES_OTHER = 20
} ;
#line 52 "/usr/include/linux/dvb/dmx.h"
typedef enum dmx_ts_pes dmx_pes_type_t;
#line 88 "/usr/include/linux/dvb/dmx.h"
struct dmx_filter {
   __u8 filter[16] ;
   __u8 mask[16] ;
   __u8 mode[16] ;
};
#line 88 "/usr/include/linux/dvb/dmx.h"
typedef struct dmx_filter dmx_filter_t;
#line 96 "/usr/include/linux/dvb/dmx.h"
struct dmx_sct_filter_params {
   __u16 pid ;
   dmx_filter_t filter ;
   __u32 timeout ;
   __u32 flags ;
};
#line 109 "/usr/include/linux/dvb/dmx.h"
struct dmx_pes_filter_params {
   __u16 pid ;
   dmx_input_t input ;
   dmx_output_t output ;
   dmx_pes_type_t pes_type ;
   __u32 flags ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 29 "/usr/include/linux/dvb/net.h"
struct dvb_net_if {
   __u16 pid ;
   __u16 if_num ;
   __u8 feedtype ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
struct _transponder_t {
   int id ;
   int onid ;
   unsigned int freq ;
   int srate ;
   int pos ;
   int we_flag ;
   char pol ;
   int mod ;
   int scanned ;
   struct _transponder_t *next ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
typedef struct _transponder_t transponder_t;
#line 129 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
struct _pat_t {
   int service_id ;
   int pmt_pid ;
   int scanned ;
   struct _pat_t *next ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
typedef struct _pat_t pat_t;
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 31 "/usr/include/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) ;
#line 34
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/error.h"
extern void ( /* format attribute */  __error_alias)(int __status , int __errnum ,
                                                     char const   *__format  , ...)  __asm__("error")  ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) 
{ 


  {
  {
#line 42
  __error_alias(__status, __errnum, __format, __builtin_va_arg_pack());
  }
#line 43
  return;
}
}
#line 46
extern void ( /* format attribute */  __error_at_line_alias)(int __status , int __errnum ,
                                                             char const   *__fname ,
                                                             unsigned int __line ,
                                                             char const   *__format 
                                                             , ...)  __asm__("error_at_line")  ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) 
{ 


  {
  {
#line 71
  __error_at_line_alias(__status, __errnum, __fname, __line, __format, __builtin_va_arg_pack());
  }
#line 73
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/tune.h"
int tune_it(int fd_frontend , int fd_sec , unsigned int freq , unsigned int srate ,
            char pol , int tone___0 , fe_spectral_inversion_t specInv___0 , unsigned int diseqc ,
            fe_modulation_t modulation , fe_code_rate_t HP_CodeRate , fe_transmit_mode_t TransmissionMode ,
            fe_guard_interval_t guardInterval , fe_bandwidth_t bandwidth ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/tune.c"
void print_status(FILE *fd , fe_status_t festatus ) 
{ 


  {
  {
#line 155
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"FE_STATUS:");
  }
#line 156
  if ((unsigned int )festatus & 1U) {
    {
#line 156
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" FE_HAS_SIGNAL");
    }
  }
#line 158
  if ((unsigned int )festatus & 32U) {
    {
#line 158
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" FE_TIMEDOUT");
    }
  }
#line 164
  if ((unsigned int )festatus & 16U) {
    {
#line 164
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" FE_HAS_LOCK");
    }
  }
#line 165
  if ((unsigned int )festatus & 2U) {
    {
#line 165
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" FE_HAS_CARRIER");
    }
  }
#line 166
  if ((unsigned int )festatus & 4U) {
    {
#line 166
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" FE_HAS_VITERBI");
    }
  }
#line 167
  if ((unsigned int )festatus & 8U) {
    {
#line 167
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)" FE_HAS_SYNC");
    }
  }
  {
#line 168
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
  }
#line 169
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/tune.c"
void diseqc_send_msg(int fd , fe_sec_voltage_t v , struct diseqc_cmd *cmd , fe_sec_tone_mode_t t ,
                     fe_sec_mini_cmd_t b ) 
{ 


  {
  {
#line 180
  ioctl(fd, (unsigned long )((unsigned int )(111 << 8) | 66U), 1);
#line 181
  ioctl(fd, (unsigned long )((unsigned int )(111 << 8) | 67U), (unsigned int )v);
#line 182
  usleep((__useconds_t )15000);
#line 183
  ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 63U) | (sizeof(struct dvb_diseqc_master_cmd ) << 16),
        & cmd->cmd);
#line 184
  usleep(cmd->wait * 1000U);
#line 185
  usleep((__useconds_t )15000);
#line 186
  ioctl(fd, (unsigned long )((unsigned int )(111 << 8) | 65U), (unsigned int )b);
#line 187
  usleep((__useconds_t )15000);
#line 188
  ioctl(fd, (unsigned long )((unsigned int )(111 << 8) | 66U), (unsigned int )t);
  }
#line 189
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/tune.c"
static int do_diseqc(int secfd , int sat_no , int pol , int hi_lo ) 
{ 
  struct diseqc_cmd cmd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 199
  cmd.cmd.msg[0] = (__u8 )224;
#line 199
  cmd.cmd.msg[1] = (__u8 )16;
#line 199
  cmd.cmd.msg[2] = (__u8 )56;
#line 199
  cmd.cmd.msg[3] = (__u8 )240;
#line 199
  cmd.cmd.msg[4] = (__u8 )0;
#line 199
  cmd.cmd.msg[5] = (__u8 )0;
#line 199
  cmd.cmd.msg_len = (__u8 )4;
#line 199
  cmd.wait = (uint32_t )0;
#line 205
  if (hi_lo) {
#line 205
    tmp = 1;
  } else {
#line 205
    tmp = 0;
  }
#line 205
  if (pol) {
#line 205
    tmp___0 = 0;
  } else {
#line 205
    tmp___0 = 2;
  }
#line 205
  cmd.cmd.msg[3] = (__u8 )(240 | (((sat_no * 4 & 15) | tmp) | tmp___0));
#line 208
  if ((sat_no / 4) % 2) {
#line 208
    tmp___1 = 1;
  } else {
#line 208
    tmp___1 = 0;
  }
  {
#line 208
  diseqc_send_msg(secfd, (fe_sec_voltage_t )pol, & cmd, (fe_sec_tone_mode_t )hi_lo,
                  (fe_sec_mini_cmd_t )tmp___1);
  }
#line 212
  return (1);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/tune.c"
int check_status(int fd_frontend , struct dvb_frontend_parameters *feparams , int tone___0 ) 
{ 
  int32_t strength ;
  fe_status_t festatus ;
  struct dvb_frontend_event event ;
  struct dvb_frontend_info fe_info ;
  struct pollfd pfd[1] ;
  int status ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;

  {
  {
#line 223
  tmp = ioctl(fd_frontend, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 76U) | (sizeof(struct dvb_frontend_parameters ) << 16),
              feparams);
  }
#line 223
  if (tmp < 0) {
    {
#line 224
    perror("ERROR tuning channel\n");
    }
#line 225
    return (-1);
  }
#line 228
  pfd[0].fd = fd_frontend;
#line 229
  pfd[0].events = (short)1;
#line 231
  event.status = (fe_status_t )0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (((unsigned int )event.status & 32U) == 0U) {
#line 232
      if (! (((unsigned int )event.status & 16U) == 0U)) {
#line 232
        goto while_break;
      }
    } else {
#line 232
      goto while_break;
    }
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"polling....\n");
#line 234
    tmp___3 = poll(pfd, (nfds_t )1, 10000);
    }
#line 234
    if (tmp___3) {
#line 235
      if ((int )pfd[0].revents & 1) {
        {
#line 236
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getting frontend event\n");
#line 237
        status = ioctl(fd_frontend, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 78U) | (sizeof(struct dvb_frontend_event ) << 16),
                       & event);
        }
#line 237
        if (status < 0) {
          {
#line 238
          tmp___2 = __errno_location();
          }
#line 238
          if (*tmp___2 != 75) {
            {
#line 239
            perror("FE_GET_EVENT");
#line 240
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"status = %d\n",
                    status);
#line 241
            tmp___0 = __errno_location();
#line 241
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"errno = %d\n",
                    *tmp___0);
            }
#line 242
            return (-1);
          } else {
            {
#line 244
            tmp___1 = __errno_location();
#line 244
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Overflow error, trying again (status = %d, errno = %d)",
                    status, *tmp___1);
            }
          }
        }
      }
      {
#line 247
      print_status(stderr, event.status);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if ((unsigned int )event.status & 16U) {
    {
#line 253
    if ((unsigned int )fe_info.type == 2U) {
#line 253
      goto case_2;
    }
#line 256
    if ((unsigned int )fe_info.type == 0U) {
#line 256
      goto case_0;
    }
#line 262
    if ((unsigned int )fe_info.type == 1U) {
#line 262
      goto case_1;
    }
#line 267
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Event:  Frequency: %d\n",
            event.parameters.frequency);
    }
#line 255
    goto switch_break;
    case_0: /* CIL Label */ 
#line 257
    if (tone___0 == 1) {
#line 257
      tmp___4 = 9750000UL;
    } else {
#line 257
      tmp___4 = 10600000UL;
    }
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Event:  Frequency: %d\n",
            (unsigned int )((unsigned long )event.parameters.frequency + tmp___4));
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        SymbolRate: %d\n",
            event.parameters.u.qpsk.symbol_rate);
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        FEC_inner:  %d\n",
            (unsigned int )event.parameters.u.qpsk.fec_inner);
#line 260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 261
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Event:  Frequency: %d\n",
            event.parameters.frequency);
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        SymbolRate: %d\n",
            event.parameters.u.qpsk.symbol_rate);
#line 265
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        FEC_inner:  %d\n",
            (unsigned int )event.parameters.u.qpsk.fec_inner);
    }
#line 266
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 268
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 271
    strength = 0;
#line 272
    ioctl(fd_frontend, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 70U) | (sizeof(__u32 ) << 16),
          & strength);
#line 273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bit error rate: %d\n",
            strength);
#line 275
    strength = 0;
#line 276
    ioctl(fd_frontend, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 71U) | (sizeof(__u16 ) << 16),
          & strength);
#line 277
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Signal strength: %d\n",
            strength);
#line 279
    strength = 0;
#line 280
    ioctl(fd_frontend, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 72U) | (sizeof(__u16 ) << 16),
          & strength);
#line 281
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SNR: %d\n",
            strength);
#line 283
    festatus = (fe_status_t )0;
#line 284
    ioctl(fd_frontend, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 69U) | (sizeof(fe_status_t ) << 16),
          & festatus);
#line 285
    print_status(stderr, festatus);
    }
  } else {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not able to lock to the signal on the given frequency\n");
    }
#line 288
    return (-1);
  }
#line 290
  return (0);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/tune.c"
int tune_it(int fd_frontend , int fd_sec , unsigned int freq , unsigned int srate ,
            char pol , int tone___0 , fe_spectral_inversion_t specInv___0 , unsigned int diseqc ,
            fe_modulation_t modulation , fe_code_rate_t HP_CodeRate , fe_transmit_mode_t TransmissionMode ,
            fe_guard_interval_t guardInterval , fe_bandwidth_t bandwidth ) 
{ 
  int res ;
  struct dvb_frontend_parameters feparams ;
  struct dvb_frontend_info fe_info ;
  fe_sec_voltage_t voltage ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 427
  tmp = ioctl(fd_frontend, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 61U) | (sizeof(struct dvb_frontend_info ) << 16),
              & fe_info);
#line 427
  res = tmp < 0;
  }
#line 427
  if (res) {
    {
#line 428
    perror("FE_GET_INFO: ");
    }
#line 429
    return (-1);
  }
  {
#line 437
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using DVB card \"%s\"\n",
          fe_info.name);
  }
  {
#line 441
  if ((unsigned int )fe_info.type == 2U) {
#line 441
    goto case_2;
  }
#line 467
  if ((unsigned int )fe_info.type == 0U) {
#line 467
    goto case_0;
  }
#line 570
  if ((unsigned int )fe_info.type == 1U) {
#line 570
    goto case_1;
  }
#line 586
  goto switch_default;
  case_2: /* CIL Label */ 
#line 443
  if (freq < 1000000U) {
#line 443
    freq = (unsigned int )((unsigned long )freq * 1000UL);
  }
  {
#line 444
  feparams.frequency = freq;
#line 445
  feparams.inversion = specInv___0;
#line 446
  feparams.u.ofdm.bandwidth = bandwidth;
#line 447
  feparams.u.ofdm.code_rate_HP = HP_CodeRate;
#line 448
  feparams.u.ofdm.code_rate_LP = (fe_code_rate_t )0;
#line 449
  feparams.u.ofdm.constellation = modulation;
#line 450
  feparams.u.ofdm.transmission_mode = TransmissionMode;
#line 451
  feparams.u.ofdm.guard_interval = guardInterval;
#line 452
  feparams.u.ofdm.hierarchy_information = (fe_hierarchy_t )0;
#line 465
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tuning DVB-T (%s) to %d Hz\n",
          "in United Kingdom", freq);
  }
#line 466
  goto switch_break;
  case_0: /* CIL Label */ 
#line 469
  if (tone___0 == 0) {
#line 469
    tmp___0 = "on";
  } else {
#line 469
    tmp___0 = "off";
  }
  {
#line 469
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tuning DVB-S to L-Band:%d, Pol:%c Srate=%d, 22kHz=%s\n",
          feparams.frequency, (int )pol, srate, tmp___0);
  }
#line 473
  if ((int )pol == 104) {
#line 474
    voltage = (fe_sec_voltage_t )1;
  } else
#line 473
  if ((int )pol == 72) {
#line 474
    voltage = (fe_sec_voltage_t )1;
  } else {
#line 476
    voltage = (fe_sec_voltage_t )0;
  }
#line 479
  if (diseqc == 0U) {
    {
#line 479
    tmp___1 = ioctl(fd_frontend, (unsigned long )((unsigned int )(111 << 8) | 67U),
                    (unsigned int )voltage);
    }
#line 479
    if (tmp___1 < 0) {
      {
#line 483
      perror("ERROR setting voltage\n");
      }
    }
  }
#line 486
  if (freq > 2200000U) {
#line 488
    if ((unsigned long )freq < 11700000UL) {
#line 490
      feparams.frequency = (__u32 )((unsigned long )freq - 9750000UL);
#line 494
      if (tone___0 < 0) {
#line 494
        tone___0 = 1;
      }
    } else {
#line 497
      feparams.frequency = (__u32 )((unsigned long )freq - 10600000UL);
#line 501
      if (tone___0 < 0) {
#line 501
        tone___0 = 0;
      }
    }
  } else {
#line 506
    feparams.frequency = freq;
  }
#line 513
  feparams.inversion = specInv___0;
#line 514
  feparams.u.qpsk.symbol_rate = srate;
#line 515
  feparams.u.qpsk.fec_inner = (fe_code_rate_t )9;
#line 523
  if (diseqc == 0U) {
    {
#line 524
    tmp___2 = ioctl(fd_frontend, (unsigned long )((unsigned int )(111 << 8) | 66U),
                    tone___0);
    }
#line 524
    if (tmp___2 < 0) {
      {
#line 525
      perror("ERROR setting tone\n");
      }
    }
  }
#line 535
  if (diseqc > 0U) {
    {
#line 536
    do_diseqc(fd_frontend, (int )(diseqc - 1U), (int )voltage, tone___0);
#line 537
    sleep(1U);
    }
  }
#line 569
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 571
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tuning DVB-C to %d, srate=%d\n",
          freq, srate);
#line 573
  feparams.frequency = freq;
#line 574
  feparams.inversion = specInv___0;
#line 575
  feparams.u.qam.symbol_rate = srate;
#line 576
  feparams.u.qam.fec_inner = (fe_code_rate_t )9;
#line 577
  feparams.u.qam.modulation = modulation;
  }
#line 585
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 587
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown FE type. Aborting\n");
#line 588
  exit(-1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 590
  usleep((__useconds_t )100000);
#line 596
  tmp___3 = check_status(fd_frontend, & feparams, tone___0);
  }
#line 596
  return (tmp___3);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int fd_demuxv  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int fd_demuxa  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int fd_demuxtt  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int fd_demuxsi  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int fd_demuxrec  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int fd_demuxd  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int pnr  =    -1;
#line 93 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int apid  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int vpid  =    0;
#line 95 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int card  =    0;
#line 96 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
fe_spectral_inversion_t specInv  =    (fe_spectral_inversion_t )2;
#line 97 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int tone  =    -1;
#line 100 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
char *frontenddev[4]  = {      (char *)"/dev/dvb/adapter0/frontend0",      (char *)"/dev/dvb/adapter1/frontend0",      (char *)"/dev/dvb/adapter2/frontend0",      (char *)"/dev/dvb/adapter3/frontend0"};
#line 101 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
char *dvrdev[4]  = {      (char *)"/dev/dvb/adapter0/dvr0",      (char *)"/dev/dvb/adapter1/dvr0",      (char *)"/dev/dvb/adapter2/dvr0",      (char *)"/dev/dvb/adapter3/dvr0"};
#line 102 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
char *demuxdev[4]  = {      (char *)"/dev/dvb/adapter0/demux0",      (char *)"/dev/dvb/adapter1/demux0",      (char *)"/dev/dvb/adapter2/demux0",      (char *)"/dev/dvb/adapter3/demux0"};
#line 124 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
transponder_t *transponders  =    (transponder_t *)((void *)0);
#line 125 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int num_trans  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
transponder_t transponder  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
pat_t *pats  =    (pat_t *)((void *)0);
#line 139 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
transponder_t *get_unscanned(void) 
{ 
  transponder_t *t ;

  {
#line 142
  t = transponders;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 144
      goto while_break;
    }
#line 145
    if (t->scanned == 0) {
#line 145
      return (t);
    }
#line 146
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return ((transponder_t *)((void *)0));
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
char xmlify_result[10]  ;
#line 152 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
char *xmlify(char c ) 
{ 


  {
  {
#line 154
  if ((int )c == 38) {
#line 154
    goto case_38;
  }
#line 156
  if ((int )c == 60) {
#line 156
    goto case_60;
  }
#line 158
  if ((int )c == 62) {
#line 158
    goto case_62;
  }
#line 160
  if ((int )c == 34) {
#line 160
    goto case_34;
  }
#line 162
  if ((int )c == 0) {
#line 162
    goto case_0;
  }
#line 164
  goto switch_default;
  case_38: /* CIL Label */ 
  {
#line 154
  strcpy((char */* __restrict  */)(xmlify_result), (char const   */* __restrict  */)"&amp;");
  }
#line 155
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 156
  strcpy((char */* __restrict  */)(xmlify_result), (char const   */* __restrict  */)"&lt;");
  }
#line 157
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 158
  strcpy((char */* __restrict  */)(xmlify_result), (char const   */* __restrict  */)"&gt;");
  }
#line 159
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 160
  strcpy((char */* __restrict  */)(xmlify_result), (char const   */* __restrict  */)"&quot;");
  }
#line 161
  goto switch_break;
  case_0: /* CIL Label */ 
#line 162
  xmlify_result[0] = (char)0;
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 164
  xmlify_result[0] = c;
#line 165
  xmlify_result[1] = (char)0;
#line 166
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 168
  return (xmlify_result);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void add_transponder(transponder_t transponder___0 ) 
{ 
  transponder_t *t ;
  int found ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 175
  if ((unsigned long )transponders == (unsigned long )((void *)0)) {
    {
#line 176
    tmp = malloc(sizeof(transponder___0));
#line 176
    transponders = (transponder_t *)tmp;
#line 178
    transponders->freq = transponder___0.freq;
#line 179
    transponders->srate = transponder___0.srate;
#line 180
    transponders->pol = transponder___0.pol;
#line 181
    transponders->pos = transponder___0.pos;
#line 182
    transponders->we_flag = transponder___0.we_flag;
#line 183
    transponders->mod = transponder___0.mod;
#line 184
    transponders->scanned = 0;
#line 185
    transponders->next = (struct _transponder_t *)((void *)0);
    }
  } else {
#line 187
    t = transponders;
#line 188
    found = 0;
    {
#line 189
    while (1) {
      while_continue: /* CIL Label */ ;
#line 189
      if (! found) {
#line 189
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 189
          goto while_break;
        }
      } else {
#line 189
        goto while_break;
      }
      {
#line 192
      tmp___0 = abs((int )(t->freq - transponder___0.freq));
      }
#line 192
      if (tmp___0 <= 3000) {
#line 192
        if ((int )t->pol == (int )transponder___0.pol) {
#line 193
          found = 1;
        } else {
#line 195
          t = t->next;
        }
      } else {
#line 195
        t = t->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 199
    if (! found) {
      {
#line 200
      tmp___1 = malloc(sizeof(transponder___0));
#line 200
      t = (transponder_t *)tmp___1;
#line 202
      t->freq = transponder___0.freq;
#line 203
      t->srate = transponder___0.srate;
#line 204
      t->pol = transponder___0.pol;
#line 205
      t->pos = transponder___0.pos;
#line 206
      t->we_flag = transponder___0.we_flag;
#line 207
      t->mod = transponder___0.mod;
#line 208
      t->scanned = 0;
#line 209
      t->next = transponders;
#line 211
      transponders = t;
      }
    }
  }
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void free_pat_list(void) 
{ 
  pat_t *t ;

  {
#line 217
  t = pats;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((unsigned long )pats != (unsigned long )((void *)0))) {
#line 219
      goto while_break;
    }
    {
#line 220
    t = pats->next;
#line 221
    free((void *)pats);
#line 222
    pats = t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int get_pmt_pid(int service_id ) 
{ 
  pat_t *t ;
  int found ;

  {
#line 227
  t = pats;
#line 228
  found = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! found) {
#line 230
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 230
        goto while_break;
      }
    } else {
#line 230
      goto while_break;
    }
#line 231
    if (t->service_id == service_id) {
#line 232
      found = 1;
    } else {
#line 234
      t = t->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  if (found) {
#line 239
    return (t->pmt_pid);
  } else {
#line 241
    return (0);
  }
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void add_pat(pat_t pat ) 
{ 
  pat_t *t ;
  int found ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 249
  if ((unsigned long )pats == (unsigned long )((void *)0)) {
    {
#line 250
    tmp = malloc(sizeof(pat));
#line 250
    pats = (pat_t *)tmp;
#line 252
    pats->service_id = pat.service_id;
#line 253
    pats->pmt_pid = pat.pmt_pid;
#line 254
    pats->scanned = 0;
#line 255
    pats->next = (struct _pat_t *)((void *)0);
    }
  } else {
#line 257
    t = pats;
#line 258
    found = 0;
    {
#line 259
    while (1) {
      while_continue: /* CIL Label */ ;
#line 259
      if (! found) {
#line 259
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 259
          goto while_break;
        }
      } else {
#line 259
        goto while_break;
      }
#line 260
      if (t->service_id == pat.service_id) {
#line 261
        found = 1;
      } else {
#line 263
        t = t->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 267
    if (! found) {
      {
#line 268
      tmp___0 = malloc(sizeof(pat));
#line 268
      t = (pat_t *)tmp___0;
#line 270
      t->service_id = pat.service_id;
#line 271
      t->pmt_pid = pat.pmt_pid;
#line 272
      t->scanned = 0;
#line 273
      t->next = pats;
#line 275
      pats = t;
      }
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void set_recpid(int fd , ushort ttpid ) 
{ 
  struct dmx_pes_filter_params pesFilterParamsREC ;
  int tmp ;

  {
#line 284
  if ((int )ttpid == 0) {
    {
#line 285
    ioctl(fd, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 286
    return;
  } else
#line 284
  if ((int )ttpid == 65535) {
    {
#line 285
    ioctl(fd, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 286
    return;
  }
  {
#line 289
  pesFilterParamsREC.pid = ttpid;
#line 290
  pesFilterParamsREC.input = (dmx_input_t )0;
#line 291
  pesFilterParamsREC.output = (dmx_output_t )1;
#line 293
  pesFilterParamsREC.pes_type = (dmx_pes_type_t )20;
#line 297
  pesFilterParamsREC.flags = (__u32 )4;
#line 298
  tmp = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 44U) | (sizeof(struct dmx_pes_filter_params ) << 16),
              & pesFilterParamsREC);
  }
#line 298
  if (tmp < 0) {
    {
#line 300
    perror("set_recpid");
    }
  }
#line 301
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void set_sipid(ushort ttpid ) 
{ 
  struct dmx_pes_filter_params pesFilterParamsSI ;
  int tmp ;

  {
#line 307
  if ((int )ttpid == 0) {
    {
#line 308
    ioctl(fd_demuxsi, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 309
    return;
  } else
#line 307
  if ((int )ttpid == 65535) {
    {
#line 308
    ioctl(fd_demuxsi, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 309
    return;
  }
  {
#line 312
  pesFilterParamsSI.pid = ttpid;
#line 313
  pesFilterParamsSI.input = (dmx_input_t )0;
#line 314
  pesFilterParamsSI.output = (dmx_output_t )2;
#line 316
  pesFilterParamsSI.pes_type = (dmx_pes_type_t )20;
#line 320
  pesFilterParamsSI.flags = (__u32 )4;
#line 321
  tmp = ioctl(fd_demuxsi, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 44U) | (sizeof(struct dmx_pes_filter_params ) << 16),
              & pesFilterParamsSI);
  }
#line 321
  if (tmp < 0) {
    {
#line 323
    perror("set_sipid");
    }
  }
#line 324
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void set_ttpid(ushort ttpid ) 
{ 
  struct dmx_pes_filter_params pesFilterParamsTT ;
  int tmp ;

  {
#line 330
  if ((int )ttpid == 0) {
    {
#line 331
    ioctl(fd_demuxtt, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 332
    return;
  } else
#line 330
  if ((int )ttpid == 65535) {
    {
#line 331
    ioctl(fd_demuxtt, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 332
    return;
  }
  {
#line 335
  pesFilterParamsTT.pid = ttpid;
#line 336
  pesFilterParamsTT.input = (dmx_input_t )0;
#line 337
  pesFilterParamsTT.output = (dmx_output_t )0;
#line 339
  pesFilterParamsTT.pes_type = (dmx_pes_type_t )2;
#line 343
  pesFilterParamsTT.flags = (__u32 )4;
#line 344
  tmp = ioctl(fd_demuxtt, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 44U) | (sizeof(struct dmx_pes_filter_params ) << 16),
              & pesFilterParamsTT);
  }
#line 344
  if (tmp < 0) {
    {
#line 346
    perror("set_ttpid");
    }
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void set_vpid(ushort vpid___0 ) 
{ 
  struct dmx_pes_filter_params pesFilterParamsV ;
  int tmp ;

  {
#line 352
  if ((int )vpid___0 == 0) {
    {
#line 353
    ioctl(fd_demuxv, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 354
    return;
  } else
#line 352
  if ((int )vpid___0 == 65535) {
    {
#line 353
    ioctl(fd_demuxv, (unsigned long )((unsigned int )(111 << 8) | 42U), 0);
    }
#line 354
    return;
  }
  {
#line 357
  pesFilterParamsV.pid = vpid___0;
#line 358
  pesFilterParamsV.input = (dmx_input_t )0;
#line 359
  pesFilterParamsV.output = (dmx_output_t )0;
#line 361
  pesFilterParamsV.pes_type = (dmx_pes_type_t )1;
#line 365
  pesFilterParamsV.flags = (__u32 )4;
#line 366
  tmp = ioctl(fd_demuxv, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 44U) | (sizeof(struct dmx_pes_filter_params ) << 16),
              & pesFilterParamsV);
  }
#line 366
  if (tmp < 0) {
    {
#line 368
    perror("set_vpid");
    }
  }
#line 369
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void set_apid(ushort apid___0 ) 
{ 
  struct dmx_pes_filter_params pesFilterParamsA ;
  int tmp ;

  {
#line 374
  if ((int )apid___0 == 0) {
    {
#line 375
    ioctl(fd_demuxa, (unsigned long )((unsigned int )(111 << 8) | 42U), (int )apid___0);
    }
#line 376
    return;
  } else
#line 374
  if ((int )apid___0 == 65535) {
    {
#line 375
    ioctl(fd_demuxa, (unsigned long )((unsigned int )(111 << 8) | 42U), (int )apid___0);
    }
#line 376
    return;
  }
  {
#line 378
  pesFilterParamsA.pid = apid___0;
#line 379
  pesFilterParamsA.input = (dmx_input_t )0;
#line 380
  pesFilterParamsA.output = (dmx_output_t )0;
#line 382
  pesFilterParamsA.pes_type = (dmx_pes_type_t )0;
#line 386
  pesFilterParamsA.flags = (__u32 )4;
#line 387
  tmp = ioctl(fd_demuxa, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 44U) | (sizeof(struct dmx_pes_filter_params ) << 16),
              & pesFilterParamsA);
  }
#line 387
  if (tmp < 0) {
    {
#line 389
    perror("set_apid");
    }
  }
#line 390
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void set_dpid(ushort dpid ) 
{ 
  struct dmx_sct_filter_params sctFilterParams ;
  int tmp ;

  {
#line 396
  if ((int )dpid == 0) {
    {
#line 397
    ioctl(fd_demuxd, (unsigned long )((unsigned int )(111 << 8) | 42U), (int )dpid);
    }
#line 398
    return;
  } else
#line 396
  if ((int )dpid == 65535) {
    {
#line 397
    ioctl(fd_demuxd, (unsigned long )((unsigned int )(111 << 8) | 42U), (int )dpid);
    }
#line 398
    return;
  }
  {
#line 400
  memset((void *)(& sctFilterParams.filter), 0, sizeof(sctFilterParams.filter));
#line 401
  sctFilterParams.pid = dpid;
#line 404
  sctFilterParams.timeout = (__u32 )0;
#line 405
  sctFilterParams.flags = (__u32 )4;
#line 406
  tmp = ioctl(fd_demuxd, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 43U) | (sizeof(struct dmx_sct_filter_params ) << 16),
              & sctFilterParams);
  }
#line 406
  if (tmp < 0) {
    {
#line 407
    perror("set_dpid");
    }
  }
#line 408
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void set_ts_filter(int fd , uint16_t pid ) 
{ 
  struct dmx_pes_filter_params pesFilterParams ;
  int tmp ;

  {
  {
#line 415
  pesFilterParams.pid = pid;
#line 416
  pesFilterParams.input = (dmx_input_t )0;
#line 417
  pesFilterParams.output = (dmx_output_t )2;
#line 419
  pesFilterParams.pes_type = (dmx_pes_type_t )20;
#line 426
  pesFilterParams.flags = (__u32 )4;
#line 428
  tmp = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 44U) | (sizeof(struct dmx_pes_filter_params ) << 16),
              & pesFilterParams);
  }
#line 428
  if (tmp < 0) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FILTER %i: ",
            (int )pid);
#line 430
    perror("DMX SET PES FILTER");
    }
  }
#line 432
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void parse_descriptors(int info_len , unsigned char *buf ) 
{ 
  int i ;
  int descriptor_tag ;
  int descriptor_length ;
  int j ;
  int k ;
  int pid ;
  int id ;
  int service_type ;
  char tmp[128] ;
  unsigned int freq ;
  unsigned int pol ;
  unsigned int sr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___19 ;
  unsigned short const   **tmp___20 ;

  {
#line 436
  i = 0;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! (i < info_len)) {
#line 442
      goto while_break;
    }
#line 443
    tmp___0 = i;
#line 443
    i ++;
#line 443
    descriptor_tag = (int )*(buf + tmp___0);
#line 444
    tmp___1 = i;
#line 444
    i ++;
#line 444
    descriptor_length = (int )*(buf + tmp___1);
    {
#line 446
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 446
      if (! (descriptor_length > 0)) {
#line 446
        goto while_break___0;
      }
      {
#line 448
      if (descriptor_tag == 3) {
#line 448
        goto case_3;
      }
#line 454
      if (descriptor_tag == 6) {
#line 454
        goto case_6;
      }
#line 460
      if (descriptor_tag == 10) {
#line 460
        goto case_10;
      }
#line 472
      if (descriptor_tag == 11) {
#line 472
        goto case_11;
      }
#line 478
      if (descriptor_tag == 9) {
#line 478
        goto case_9;
      }
#line 528
      if (descriptor_tag == 64) {
#line 528
        goto case_64;
      }
#line 539
      if (descriptor_tag == 65) {
#line 539
        goto case_65;
      }
#line 549
      if (descriptor_tag == 67) {
#line 549
        goto case_67;
      }
#line 576
      if (descriptor_tag == 72) {
#line 576
        goto case_72;
      }
#line 598
      if (descriptor_tag == 73) {
#line 598
        goto case_73;
      }
#line 610
      if (descriptor_tag == 76) {
#line 610
        goto case_76;
      }
#line 616
      if (descriptor_tag == 82) {
#line 616
        goto case_82;
      }
#line 622
      if (descriptor_tag == 83) {
#line 622
        goto case_83;
      }
#line 633
      if (descriptor_tag == 86) {
#line 633
        goto case_86;
      }
#line 650
      if (descriptor_tag == 89) {
#line 650
        goto case_89;
      }
#line 666
      if (descriptor_tag == 106) {
#line 666
        goto case_106;
      }
#line 674
      if (descriptor_tag == 197) {
#line 674
        goto case_197;
      }
#line 685
      goto switch_default___0;
      case_3: /* CIL Label */ 
      {
#line 449
      printf((char const   */* __restrict  */)"<audio_info tag=\"0x03\" info=\"%02x\" />\n",
             (int )*(buf + i));
#line 450
      i += descriptor_length;
#line 451
      descriptor_length = 0;
      }
#line 452
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 455
      printf((char const   */* __restrict  */)"<data_stream_alignment tag=\"0x06\" data=\"%02x\" />\n",
             (int )*(buf + i));
#line 456
      i += descriptor_length;
#line 457
      descriptor_length = 0;
      }
#line 458
      goto switch_break;
      case_10: /* CIL Label */ 
#line 461
      j = 0;
      {
#line 461
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 461
        if (! (j < descriptor_length / 4)) {
#line 461
          goto while_break___1;
        }
        {
#line 462
        printf((char const   */* __restrict  */)"<iso_639 language=\"");
        }
#line 463
        if ((int )*(buf + i) != 0) {
          {
#line 463
          printf((char const   */* __restrict  */)"%c", (int )*(buf + i));
          }
        }
#line 464
        if ((int )*(buf + (i + 1)) != 0) {
          {
#line 464
          printf((char const   */* __restrict  */)"%c", (int )*(buf + (i + 1)));
          }
        }
#line 465
        if ((int )*(buf + (i + 2)) != 0) {
          {
#line 465
          printf((char const   */* __restrict  */)"%c", (int )*(buf + (i + 2)));
          }
        }
        {
#line 466
        printf((char const   */* __restrict  */)"\" type=\"%d\" />\n", (int )*(buf + (i + 3)));
#line 467
        i += 4;
#line 468
        descriptor_length -= 4;
#line 461
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 470
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 473
      printf((char const   */* __restrict  */)"<system_clock tag=\"0x0b\" data=\"%02x%02x\" />\n",
             (int )*(buf + i), (int )*(buf + (i + 1)));
#line 474
      i += descriptor_length;
#line 475
      descriptor_length = 0;
      }
#line 476
      goto switch_break;
      case_9: /* CIL Label */ 
#line 479
      k = ((int )*(buf + i) << 8) | (int )*(buf + (i + 1));
      {
#line 481
      if ((k & 65280) == 256) {
#line 481
        goto case_256;
      }
#line 489
      if ((k & 65280) == 1280) {
#line 489
        goto case_1280;
      }
#line 503
      if ((k & 65280) == 5888) {
#line 503
        goto case_5888;
      }
#line 503
      if ((k & 65280) == 1536) {
#line 503
        goto case_5888;
      }
#line 507
      if ((k & 65280) == 6144) {
#line 507
        goto case_6144;
      }
#line 511
      if ((k & 65280) == 2816) {
#line 511
        goto case_2816;
      }
#line 515
      if ((k & 65280) == 2304) {
#line 515
        goto case_2304;
      }
#line 519
      goto switch_default;
      case_256: /* CIL Label */ 
#line 482
      j = 2;
      {
#line 482
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 482
        if (! (j < descriptor_length)) {
#line 482
          goto while_break___2;
        }
        {
#line 484
        pid = (((int )*(buf + (i + j)) & 31) << 8) | (int )*(buf + ((i + j) + 1));
#line 485
        id = ((int )*(buf + ((i + j) + 2)) << 8) | (int )*(buf + ((i + j) + 3));
#line 486
        printf((char const   */* __restrict  */)"<ca_system_descriptor type=\"seca\" system_id=\"0x%04x\" ecm_pid=\"%d\" ecm_id=\"%06x\">\n",
               k, pid, id);
#line 482
        j += 15;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 488
      goto switch_break___0;
      case_1280: /* CIL Label */ 
#line 490
      j = 4;
      {
#line 491
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 491
        if (! (j < descriptor_length)) {
#line 491
          goto while_break___3;
        }
#line 493
        if ((int )*(buf + (i + j)) == 20) {
          {
#line 495
          pid = (((int )*(buf + (i + 2)) & 31) << 8) | (int )*(buf + (i + 3));
#line 496
          id = (((int )*(buf + ((i + j) + 2)) << 16) | ((int )*(buf + ((i + j) + 3)) << 8)) | ((int )*(buf + ((i + j) + 4)) & 240);
#line 497
          printf((char const   */* __restrict  */)"<ca_system_descriptor type=\"viaccess\" system_id=\"0x%04x\" ecm_pid=\"%d\" ecm_id=\"%06x\">\n",
                 k, pid, id);
          }
        }
#line 499
        j += 2 + (int )*(buf + ((i + j) + 1));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 501
      goto switch_break___0;
      case_5888: /* CIL Label */ 
      case_1536: /* CIL Label */ 
      {
#line 504
      pid = (((int )*(buf + (i + 2)) & 31) << 8) | (int )*(buf + (i + 3));
#line 505
      printf((char const   */* __restrict  */)"<ca_system_descriptor type=\"irdeto\" system_id=\"0x%04x\" ecm_pid=\"%d\">\n",
             k, pid);
      }
#line 506
      goto switch_break___0;
      case_6144: /* CIL Label */ 
      {
#line 508
      pid = (((int )*(buf + (i + 2)) & 31) << 8) | (int )*(buf + (i + 3));
#line 509
      printf((char const   */* __restrict  */)"<ca_system_descriptor type=\"nagra\" system_id=\"0x%04x\" ecm_pid=\"%d\">\n",
             k, pid);
      }
#line 510
      goto switch_break___0;
      case_2816: /* CIL Label */ 
      {
#line 512
      pid = (((int )*(buf + (i + 2)) & 31) << 8) | (int )*(buf + (i + 3));
#line 513
      printf((char const   */* __restrict  */)"<ca_system_descriptor type=\"conax\" system_id=\"0x%04x\" ecm_pid=\"%d\">\n",
             k, pid);
      }
#line 514
      goto switch_break___0;
      case_2304: /* CIL Label */ 
      {
#line 516
      pid = (((int )*(buf + (i + 2)) & 31) << 8) | (int )*(buf + (i + 3));
#line 517
      printf((char const   */* __restrict  */)"<ca_system_descriptor type=\"videoguard\" system_id=\"0x%04x\" ecm_pid=\"%d\">\n",
             k, pid);
      }
#line 518
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 520
      pid = (((int )*(buf + (i + 2)) & 31) << 8) | (int )*(buf + (i + 3));
#line 521
      printf((char const   */* __restrict  */)"<ca_system_descriptor type=\"unknown\" system_id=\"0x%04x\">\n",
             k);
      }
#line 522
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 524
      i += descriptor_length;
#line 525
      descriptor_length = 0;
#line 526
      goto switch_break;
      case_64: /* CIL Label */ 
#line 530
      j = descriptor_length;
      {
#line 531
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 531
        if (! (j > 0)) {
#line 531
          goto while_break___4;
        }
#line 533
        j --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 535
      descriptor_length = 0;
#line 537
      goto switch_break;
      case_65: /* CIL Label */ 
      {
#line 541
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 541
        if (! (descriptor_length > 0)) {
#line 541
          goto while_break___5;
        }
#line 543
        i += 3;
#line 544
        descriptor_length -= 3;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 547
      goto switch_break;
      case_67: /* CIL Label */ 
      {
#line 550
      freq = (((unsigned int )((int )*(buf + i) << 24) | (unsigned int )((int )*(buf + (i + 1)) << 16)) | (unsigned int )((int )*(buf + (i + 2)) << 8)) | (unsigned int )*(buf + (i + 3));
#line 551
      sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"%x",
              freq);
#line 552
      tmp___2 = atoi((char const   *)(tmp));
#line 552
      transponder.freq = (unsigned int )(tmp___2 * 10);
#line 553
      i += 4;
#line 554
      transponder.pos = ((int )*(buf + i) << 8) | (int )*(buf + (i + 1));
#line 555
      i += 2;
#line 556
      transponder.we_flag = ((int )*(buf + i) & 128) >> 7;
#line 557
      pol = (unsigned int )(((int )*(buf + i) & 96) >> 5);
      }
      {
#line 559
      if (pol == 0U) {
#line 559
        goto case_0;
      }
#line 560
      if (pol == 1U) {
#line 560
        goto case_1;
      }
#line 561
      if (pol == 2U) {
#line 561
        goto case_2;
      }
#line 562
      if (pol == 3U) {
#line 562
        goto case_3___0;
      }
#line 558
      goto switch_break___1;
      case_0: /* CIL Label */ 
#line 559
      transponder.pol = (char )'H';
#line 559
      goto switch_break___1;
      case_1: /* CIL Label */ 
#line 560
      transponder.pol = (char )'V';
#line 560
      goto switch_break___1;
      case_2: /* CIL Label */ 
#line 561
      transponder.pol = (char )'L';
#line 561
      goto switch_break___1;
      case_3___0: /* CIL Label */ 
#line 562
      transponder.pol = (char )'R';
#line 562
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 564
      transponder.mod = (int )*(buf + i) & 31;
#line 565
      i ++;
#line 566
      sr = (((unsigned int )((int )*(buf + i) << 24) | (unsigned int )((int )*(buf + (i + 1)) << 16)) | (unsigned int )((int )*(buf + (i + 2)) << 8)) | (unsigned int )((int )*(buf + (i + 3)) & 240);
#line 567
      sr >>= 4;
#line 568
      sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"%x",
              sr);
#line 569
      tmp___3 = atoi((char const   *)(tmp));
#line 569
      transponder.srate = tmp___3 * 100;
#line 570
      i += 4;
#line 571
      descriptor_length = 0;
#line 572
      add_transponder(transponder);
      }
#line 574
      goto switch_break;
      case_72: /* CIL Label */ 
      {
#line 577
      tmp___4 = i;
#line 577
      i ++;
#line 577
      service_type = (int )*(buf + tmp___4);
#line 578
      printf((char const   */* __restrict  */)"<description tag=\"0x48\" type=\"%d\"",
             service_type);
#line 579
      descriptor_length --;
#line 580
      tmp___5 = i;
#line 580
      i ++;
#line 580
      j = (int )*(buf + tmp___5);
#line 581
      descriptor_length -= j + 1;
#line 582
      printf((char const   */* __restrict  */)" provider_name=\"");
      }
      {
#line 583
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 583
        if (! (j > 0)) {
#line 583
          goto while_break___6;
        }
        {
#line 584
        tmp___6 = i;
#line 584
        i ++;
#line 584
        tmp___7 = xmlify((char )*(buf + tmp___6));
#line 584
        printf((char const   */* __restrict  */)"%s", tmp___7);
#line 585
        j --;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 587
      printf((char const   */* __restrict  */)"\" service_name=\"");
#line 588
      tmp___8 = i;
#line 588
      i ++;
#line 588
      j = (int )*(buf + tmp___8);
#line 589
      descriptor_length -= j + 1;
      }
      {
#line 590
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 590
        if (! (j > 0)) {
#line 590
          goto while_break___7;
        }
        {
#line 591
        tmp___9 = xmlify((char )*(buf + i));
#line 591
        printf((char const   */* __restrict  */)"%s", tmp___9);
#line 592
        i ++;
#line 593
        j --;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 595
      printf((char const   */* __restrict  */)"\" />\n");
      }
#line 596
      goto switch_break;
      case_73: /* CIL Label */ 
      {
#line 599
      printf((char const   */* __restrict  */)"<country_availability tag=\"0x49\" type=\"%d\" countries=\" ",
             ((int )*(buf + i) & 128) >> 7);
#line 600
      i ++;
#line 601
      j = descriptor_length - 1;
      }
      {
#line 602
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 602
        if (! (j > 0)) {
#line 602
          goto while_break___8;
        }
        {
#line 603
        tmp___10 = i;
#line 603
        i ++;
#line 603
        printf((char const   */* __restrict  */)"%c", (int )*(buf + tmp___10));
#line 604
        j --;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 606
      printf((char const   */* __restrict  */)"\" />\n");
#line 607
      descriptor_length = 0;
      }
#line 608
      goto switch_break;
      case_76: /* CIL Label */ 
      {
#line 611
      printf((char const   */* __restrict  */)"<time_shifted_copy_of tag=\"0x4c\" service_id=\"%d\" />\n",
             ((int )*(buf + i) << 8) | (int )*(buf + (i + 1)));
#line 612
      i += descriptor_length;
#line 613
      descriptor_length = 0;
      }
#line 614
      goto switch_break;
      case_82: /* CIL Label */ 
      {
#line 617
      printf((char const   */* __restrict  */)"<stream_id id=\"%d\" />\n", (int )*(buf + i));
#line 618
      i += descriptor_length;
#line 619
      descriptor_length = 0;
      }
#line 620
      goto switch_break;
      case_83: /* CIL Label */ 
      {
#line 623
      printf((char const   */* __restrict  */)"<ca_identifier tag=\"0x53\" length=\"%02x\">\n",
             descriptor_length);
#line 624
      j = 0;
      }
      {
#line 624
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 624
        if (! (j < descriptor_length)) {
#line 624
          goto while_break___9;
        }
        {
#line 625
        k = ((int )*(buf + (i + j)) << 8) | (int )*(buf + ((i + j) + 1));
#line 626
        printf((char const   */* __restrict  */)"<ca_system_id>%04x</ca_system_id>\n",
               k);
#line 624
        j += 2;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 628
      i += descriptor_length;
#line 629
      descriptor_length = 0;
#line 630
      printf((char const   */* __restrict  */)"</ca_identifier>\n");
      }
#line 631
      goto switch_break;
      case_86: /* CIL Label */ 
      {
#line 634
      j = 0;
#line 635
      printf((char const   */* __restrict  */)"<teletext tag=\"0x56\">\n");
      }
      {
#line 636
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 636
        if (! (j < descriptor_length)) {
#line 636
          goto while_break___10;
        }
        {
#line 637
        printf((char const   */* __restrict  */)"<teletext_info lang=\"");
#line 638
        tmp___11 = xmlify((char )*(buf + i));
#line 638
        printf((char const   */* __restrict  */)"%s", tmp___11);
#line 639
        tmp___12 = xmlify((char )*(buf + (i + 1)));
#line 639
        printf((char const   */* __restrict  */)"%s", tmp___12);
#line 640
        tmp___13 = xmlify((char )*(buf + (i + 2)));
#line 640
        printf((char const   */* __restrict  */)"%s", tmp___13);
#line 641
        k = (int )*(buf + (i + 3)) & 7;
        }
#line 642
        if (k == 0) {
#line 642
          tmp___14 = 8;
        } else {
#line 642
          tmp___14 = k;
        }
        {
#line 642
        printf((char const   */* __restrict  */)"\" type=\"%d\" page=\"%d%02x\" />\n",
               ((int )*(buf + (i + 3)) & 248) >> 3, tmp___14, (int )*(buf + (i + 4)));
#line 643
        i += 5;
#line 644
        j += 5;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 646
      printf((char const   */* __restrict  */)"</teletext>\n");
#line 647
      descriptor_length = 0;
      }
#line 648
      goto switch_break;
      case_89: /* CIL Label */ 
      {
#line 651
      j = 0;
#line 652
      printf((char const   */* __restrict  */)"<subtitling_descriptor tag=\"0x59\">\n");
      }
      {
#line 653
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 653
        if (! (j < descriptor_length)) {
#line 653
          goto while_break___11;
        }
        {
#line 654
        printf((char const   */* __restrict  */)"<subtitle_stream lang=\"");
#line 655
        tmp___15 = xmlify((char )*(buf + i));
#line 655
        printf((char const   */* __restrict  */)"%s", tmp___15);
#line 656
        tmp___16 = xmlify((char )*(buf + (i + 1)));
#line 656
        printf((char const   */* __restrict  */)"%s", tmp___16);
#line 657
        tmp___17 = xmlify((char )*(buf + (i + 2)));
#line 657
        printf((char const   */* __restrict  */)"%s", tmp___17);
#line 658
        printf((char const   */* __restrict  */)"\" type=\"%d\" composition_page_id=\"%04x\" ancillary_page_id=\"%04x\" />\n",
               (int )*(buf + (i + 3)), ((int )*(buf + (i + 4)) << 8) | (int )*(buf + (i + 5)),
               ((int )*(buf + (i + 6)) << 8) | (int )*(buf + (i + 7)));
#line 659
        i += 8;
#line 660
        j += 8;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 662
      printf((char const   */* __restrict  */)"</subtitling_descriptor>\n");
#line 663
      descriptor_length = 0;
      }
#line 664
      goto switch_break;
      case_106: /* CIL Label */ 
      {
#line 667
      printf((char const   */* __restrict  */)"<ac3_descriptor tag=\"0x6a\" data=\"");
#line 668
      j = 0;
      }
      {
#line 668
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 668
        if (! (j < descriptor_length)) {
#line 668
          goto while_break___12;
        }
        {
#line 668
        printf((char const   */* __restrict  */)"%02x", (int )*(buf + (i + j)));
#line 668
        j ++;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 669
      printf((char const   */* __restrict  */)"\" />\n");
#line 670
      i += descriptor_length;
#line 671
      descriptor_length = 0;
      }
#line 672
      goto switch_break;
      case_197: /* CIL Label */ 
      {
#line 676
      printf((char const   */* __restrict  */)"<canal_radio tag=\"0x%02x\" id=\"%d\" name=\"",
             descriptor_tag, (int )*(buf + i));
#line 677
      i ++;
#line 678
      j = 0;
      }
      {
#line 678
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 678
        if (! (j < descriptor_length)) {
#line 678
          goto while_break___13;
        }
#line 679
        if ((int )*(buf + (i + j)) != 0) {
          {
#line 679
          printf((char const   */* __restrict  */)"%c", (int )*(buf + (i + j)));
          }
        }
#line 678
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 680
      printf((char const   */* __restrict  */)"\" />\n");
#line 681
      i += descriptor_length;
#line 682
      descriptor_length = 0;
      }
#line 683
      goto switch_break;
      switch_default___0: /* CIL Label */ 
      {
#line 686
      printf((char const   */* __restrict  */)"<descriptor tag=\"0x%02x\" data=\"",
             descriptor_tag);
#line 687
      j = 0;
      }
      {
#line 687
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 687
        if (! (j < descriptor_length)) {
#line 687
          goto while_break___14;
        }
        {
#line 687
        printf((char const   */* __restrict  */)"%02x", (int )*(buf + (i + j)));
#line 687
        j ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 688
      printf((char const   */* __restrict  */)"\" text=\"");
#line 689
      j = 0;
      }
      {
#line 689
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 689
        if (! (j < descriptor_length)) {
#line 689
          goto while_break___15;
        }
        {
#line 689
        tmp___20 = __ctype_b_loc();
        }
#line 689
        if ((int const   )*(*tmp___20 + (int )*(buf + (i + j))) & 8) {
#line 689
          tmp___19 = (int )*(buf + (i + j));
        } else {
#line 689
          tmp___19 = '.';
        }
        {
#line 689
        printf((char const   */* __restrict  */)"%c", tmp___19);
#line 689
        j ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 690
      printf((char const   */* __restrict  */)"\" />\n");
#line 691
      i += descriptor_length;
#line 692
      descriptor_length = 0;
      }
#line 693
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return;
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void dump(char *fname , int len , char *buf ) 
{ 
  FILE *f ;

  {
  {
#line 702
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 703
  if (f) {
    {
#line 704
    fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )len, (FILE */* __restrict  */)f);
#line 705
    fclose(f);
    }
  }
#line 707
  return;
}
}
#line 709 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int scan_nit(int x ) 
{ 
  int fd_nit ;
  int n ;
  int seclen ;
  int i ;
  struct pollfd ufd ;
  unsigned char buf[4096] ;
  struct dmx_sct_filter_params sctFilterParams ;
  int info_len ;
  int network_id ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 718
  fd_nit = open((char const   *)demuxdev[card], 2050);
  }
#line 718
  if (fd_nit < 0) {
    {
#line 719
    perror("fd_nit DEVICE: ");
    }
#line 720
    return (-1);
  }
  {
#line 723
  sctFilterParams.pid = (__u16 )16;
#line 724
  memset((void *)(& sctFilterParams.filter), 0, sizeof(sctFilterParams.filter));
#line 725
  sctFilterParams.timeout = (__u32 )0;
#line 726
  sctFilterParams.flags = (__u32 )4;
#line 727
  sctFilterParams.filter.filter[0] = (__u8 )x;
#line 728
  sctFilterParams.filter.mask[0] = (__u8 )255;
#line 730
  tmp = ioctl(fd_nit, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 43U) | (sizeof(struct dmx_sct_filter_params ) << 16),
              & sctFilterParams);
  }
#line 730
  if (tmp < 0) {
    {
#line 731
    perror("NIT - DMX_SET_FILTER:");
#line 732
    close(fd_nit);
    }
#line 733
    return (-1);
  }
  {
#line 736
  ufd.fd = fd_nit;
#line 737
  ufd.events = (short)2;
#line 738
  tmp___0 = poll(& ufd, (nfds_t )1, 10000);
  }
#line 738
  if (tmp___0 < 0) {
    {
#line 739
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TIMEOUT on read from fd_nit\n");
#line 740
    close(fd_nit);
    }
#line 741
    return (-1);
  }
  {
#line 743
  tmp___2 = read(fd_nit, (void *)(buf), (size_t )3);
  }
#line 743
  if (tmp___2 == 3L) {
    {
#line 744
    seclen = (((int )buf[1] & 15) << 8) | ((int )buf[2] & 255);
#line 745
    tmp___1 = read(fd_nit, (void *)(buf + 3), (size_t )seclen);
#line 745
    n = (int )tmp___1;
    }
#line 746
    if (n == seclen) {
      {
#line 747
      seclen += 3;
#line 750
      network_id = ((int )buf[3] << 8) | (int )buf[4];
#line 753
      info_len = (((int )buf[8] & 15) << 8) | (int )buf[9];
#line 754
      i = 10;
#line 755
      parse_descriptors(info_len, & buf[i]);
#line 756
      i += info_len;
#line 757
      i += 2;
      }
      {
#line 758
      while (1) {
        while_continue: /* CIL Label */ ;
#line 758
        if (! (i < seclen - 4)) {
#line 758
          goto while_break;
        }
        {
#line 759
        transponder.id = ((int )buf[i] << 8) | (int )buf[i + 1];
#line 760
        i += 2;
#line 761
        transponder.onid = ((int )buf[i] << 8) | (int )buf[i + 1];
#line 762
        i += 2;
#line 764
        info_len = (((int )buf[i] & 15) << 8) | (int )buf[i + 1];
#line 765
        i += 2;
#line 766
        parse_descriptors(info_len, & buf[i]);
#line 768
        i += info_len;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 773
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Under-read bytes for NIT - wanted %d, got %d\n",
              seclen, n);
      }
    }
  } else {
    {
#line 776
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Nothing to read from fd_nit\n");
    }
  }
  {
#line 778
  close(fd_nit);
  }
#line 779
  return (0);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void scan_pmt(int pid , int sid , int change ) 
{ 
  int fd_pmt ;
  int n ;
  int seclen ;
  int i ;
  unsigned char buf[4096] ;
  struct dmx_sct_filter_params sctFilterParams ;
  int service_id ;
  int info_len ;
  int es_pid ;
  int stream_type ;
  struct pollfd ufd ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 794
  if (pid == 0) {
#line 794
    return;
  }
  {
#line 796
  fd_pmt = open((char const   *)demuxdev[card], 2050);
  }
#line 796
  if (fd_pmt < 0) {
    {
#line 797
    perror("fd_pmt DEVICE: ");
    }
#line 798
    return;
  }
  {
#line 801
  sctFilterParams.pid = (__u16 )pid;
#line 802
  memset((void *)(& sctFilterParams.filter), 0, sizeof(sctFilterParams.filter));
#line 803
  sctFilterParams.timeout = (__u32 )0;
#line 804
  sctFilterParams.flags = (__u32 )4;
#line 805
  sctFilterParams.filter.filter[0] = (__u8 )2;
#line 806
  sctFilterParams.filter.mask[0] = (__u8 )255;
#line 808
  tmp = ioctl(fd_pmt, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 43U) | (sizeof(struct dmx_sct_filter_params ) << 16),
              & sctFilterParams);
  }
#line 808
  if (tmp < 0) {
    {
#line 809
    perror("PMT - DMX_SET_FILTER:");
#line 810
    close(fd_pmt);
    }
#line 811
    return;
  }
  {
#line 814
  ufd.fd = fd_pmt;
#line 815
  ufd.events = (short)2;
#line 816
  tmp___0 = poll(& ufd, (nfds_t )1, 10000);
  }
#line 816
  if (tmp___0 < 0) {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TIMEOUT reading from fd_pmt\n");
#line 818
    close(fd_pmt);
    }
#line 819
    return;
  }
  {
#line 822
  tmp___3 = read(fd_pmt, (void *)(buf), (size_t )3);
  }
#line 822
  if (tmp___3 == 3L) {
    {
#line 823
    seclen = (((int )buf[1] & 15) << 8) | ((int )buf[2] & 255);
#line 824
    tmp___1 = read(fd_pmt, (void *)(buf + 3), (size_t )seclen);
#line 824
    n = (int )tmp___1;
    }
#line 825
    if (n == seclen) {
#line 826
      seclen += 3;
#line 828
      service_id = ((int )buf[3] << 8) | (int )buf[4];
#line 831
      if (sid != service_id) {
        {
#line 832
        close(fd_pmt);
#line 833
        scan_pmt(pid, sid, change);
        }
#line 834
        return;
      }
      {
#line 837
      info_len = (((int )buf[10] & 15) << 8) | (int )buf[11];
#line 838
      i = 12;
#line 839
      parse_descriptors(info_len, & buf[i]);
#line 840
      i += info_len;
      }
      {
#line 841
      while (1) {
        while_continue: /* CIL Label */ ;
#line 841
        if (! (i < seclen - 4)) {
#line 841
          goto while_break;
        }
        {
#line 842
        tmp___2 = i;
#line 842
        i ++;
#line 842
        stream_type = (int )buf[tmp___2];
#line 843
        es_pid = (((int )buf[i] & 31) << 8) | (int )buf[i + 1];
#line 844
        printf((char const   */* __restrict  */)"<stream type=\"%d\" pid=\"%d\">\n",
               stream_type, es_pid);
        }
#line 845
        if (change) {
#line 846
          if (vpid == 0) {
#line 846
            if (stream_type == 1) {
#line 847
              vpid = es_pid;
            } else
#line 846
            if (stream_type == 2) {
#line 847
              vpid = es_pid;
            }
          }
#line 849
          if (apid == 0) {
#line 849
            if (stream_type == 3) {
#line 850
              apid = es_pid;
            } else
#line 849
            if (stream_type == 4) {
#line 850
              apid = es_pid;
            }
          }
        }
        {
#line 854
        i += 2;
#line 855
        info_len = (((int )buf[i] & 15) << 8) | (int )buf[i + 1];
#line 856
        i += 2;
#line 857
        parse_descriptors(info_len, & buf[i]);
#line 858
        i += info_len;
#line 859
        printf((char const   */* __restrict  */)"</stream>\n");
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 864
      printf((char const   */* __restrict  */)"Under-read bytes for PMT - wanted %d, got %d\n",
             seclen, n);
      }
    }
  } else {
    {
#line 867
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Nothing to read from fd_pmt\n");
    }
  }
  {
#line 870
  close(fd_pmt);
  }
#line 871
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void scan_pat(void) 
{ 
  int fd_pat ;
  int n ;
  int seclen ;
  int i ;
  unsigned char buf[4096] ;
  struct dmx_sct_filter_params sctFilterParams ;
  struct pollfd ufd ;
  pat_t pat ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 883
  fd_pat = open((char const   *)demuxdev[card], 2050);
  }
#line 883
  if (fd_pat < 0) {
    {
#line 884
    perror("fd_pat DEVICE: ");
    }
#line 885
    return;
  }
  {
#line 888
  sctFilterParams.pid = (__u16 )0;
#line 889
  memset((void *)(& sctFilterParams.filter), 0, sizeof(sctFilterParams.filter));
#line 890
  sctFilterParams.timeout = (__u32 )0;
#line 891
  sctFilterParams.flags = (__u32 )4;
#line 892
  sctFilterParams.filter.filter[0] = (__u8 )0;
#line 893
  sctFilterParams.filter.mask[0] = (__u8 )255;
#line 895
  tmp = ioctl(fd_pat, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 43U) | (sizeof(struct dmx_sct_filter_params ) << 16),
              & sctFilterParams);
  }
#line 895
  if (tmp < 0) {
    {
#line 896
    perror("PAT - DMX_SET_FILTER:");
#line 897
    close(fd_pat);
    }
#line 898
    return;
  }
  {
#line 901
  ufd.fd = fd_pat;
#line 902
  ufd.events = (short)2;
#line 903
  tmp___0 = poll(& ufd, (nfds_t )1, 10000);
  }
#line 903
  if (tmp___0 < 0) {
    {
#line 904
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TIMEOUT reading from fd_pat\n");
#line 905
    close(fd_pat);
    }
#line 906
    return;
  }
  {
#line 908
  tmp___2 = read(fd_pat, (void *)(buf), (size_t )3);
  }
#line 908
  if (tmp___2 == 3L) {
    {
#line 909
    seclen = (((int )buf[1] & 15) << 8) | ((int )buf[2] & 255);
#line 910
    tmp___1 = read(fd_pat, (void *)(buf + 3), (size_t )seclen);
#line 910
    n = (int )tmp___1;
    }
#line 911
    if (n == seclen) {
#line 912
      seclen += 3;
#line 916
      i = 8;
      {
#line 917
      while (1) {
        while_continue: /* CIL Label */ ;
#line 917
        if (! (i < seclen - 4)) {
#line 917
          goto while_break;
        }
        {
#line 918
        pat.service_id = ((int )buf[i] << 8) | (int )buf[i + 1];
#line 919
        pat.pmt_pid = (((int )buf[i + 2] & 31) << 8) | (int )buf[i + 3];
#line 920
        add_pat(pat);
#line 926
        i += 4;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 930
      printf((char const   */* __restrict  */)"Under-read bytes for PAT - wanted %d, got %d\n",
             seclen, n);
      }
    }
  } else {
    {
#line 933
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Nothing to read from fd_pat\n");
    }
  }
  {
#line 935
  close(fd_pat);
  }
#line 936
  return;
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void scan_sdt(void) 
{ 
  int fd_sdt ;
  int n ;
  int seclen ;
  int i ;
  int k ;
  int max_k ;
  unsigned char buf[4096] ;
  struct dmx_sct_filter_params sctFilterParams ;
  int ca ;
  int service_id ;
  int loop_length ;
  struct pollfd ufd ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 948
  fd_sdt = open((char const   *)demuxdev[card], 2050);
  }
#line 948
  if (fd_sdt < 0) {
    {
#line 949
    perror("fd_sdt DEVICE: ");
    }
#line 950
    return;
  }
  {
#line 953
  sctFilterParams.pid = (__u16 )17;
#line 954
  memset((void *)(& sctFilterParams.filter), 0, sizeof(sctFilterParams.filter));
#line 955
  sctFilterParams.timeout = (__u32 )0;
#line 956
  sctFilterParams.flags = (__u32 )4;
#line 957
  sctFilterParams.filter.filter[0] = (__u8 )66;
#line 958
  sctFilterParams.filter.mask[0] = (__u8 )255;
#line 960
  tmp = ioctl(fd_sdt, (unsigned long )(((1U << 30) | (unsigned int )(111 << 8)) | 43U) | (sizeof(struct dmx_sct_filter_params ) << 16),
              & sctFilterParams);
  }
#line 960
  if (tmp < 0) {
    {
#line 961
    perror("SDT - DMX_SET_FILTER:");
#line 962
    close(fd_sdt);
    }
#line 963
    return;
  }
#line 966
  max_k = 1;
#line 969
  k = 0;
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if (! (k < max_k)) {
#line 969
      goto while_break;
    }
    {
#line 970
    ufd.fd = fd_sdt;
#line 971
    ufd.events = (short)2;
#line 972
    tmp___0 = poll(& ufd, (nfds_t )1, 2000);
    }
#line 972
    if (tmp___0 < 0) {
      {
#line 973
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TIMEOUT on read from fd_sdt\n");
#line 974
      close(fd_sdt);
      }
#line 975
      return;
    }
    {
#line 977
    tmp___3 = read(fd_sdt, (void *)(buf), (size_t )3);
    }
#line 977
    if (tmp___3 == 3L) {
      {
#line 978
      seclen = (((int )buf[1] & 15) << 8) | ((int )buf[2] & 255);
#line 979
      tmp___1 = read(fd_sdt, (void *)(buf + 3), (size_t )seclen);
#line 979
      n = (int )tmp___1;
      }
#line 980
      if (n == seclen) {
#line 981
        seclen += 3;
#line 996
        max_k = (int )buf[7] + 1;
#line 998
        i = 11;
        {
#line 999
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 999
          if (! (i < seclen - 4)) {
#line 999
            goto while_break___0;
          }
          {
#line 1000
          service_id = ((int )buf[i] << 8) | (int )buf[i + 1];
#line 1001
          i += 2;
#line 1002
          i ++;
#line 1003
          ca = ((int )buf[i] & 16) >> 4;
#line 1004
          loop_length = (((int )buf[i] & 15) << 8) | (int )buf[i + 1];
#line 1005
          printf((char const   */* __restrict  */)"<service id=\"%d\" ca=\"%d\">\n",
                 service_id, ca);
#line 1006
          i += 2;
#line 1007
          parse_descriptors(loop_length, & buf[i]);
#line 1008
          i += loop_length;
#line 1009
          tmp___2 = get_pmt_pid(service_id);
#line 1009
          scan_pmt(tmp___2, service_id, service_id == pnr);
#line 1010
          printf((char const   */* __restrict  */)"</service>\n");
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 1013
        printf((char const   */* __restrict  */)"Under-read bytes for SDT - wanted %d, got %d\n",
               seclen, n);
        }
      }
    } else {
      {
#line 1016
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Nothing to read from fd_sdt\n");
      }
    }
#line 969
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1020
  close(fd_sdt);
  }
#line 1022
  return;
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int FEReadBER(int fd , uint32_t *ber ) 
{ 
  int ans ;
  int tmp ;

  {
  {
#line 1028
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 70U) | (sizeof(__u32 ) << 16),
              ber);
#line 1028
  ans = tmp < 0;
  }
#line 1028
  if (ans) {
    {
#line 1029
    perror("FE READ_BER: ");
    }
#line 1030
    return (-1);
  }
#line 1032
  return (0);
}
}
#line 1036 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int FEReadSignalStrength(int fd , int32_t *strength ) 
{ 
  int ans ;
  int tmp ;

  {
  {
#line 1040
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 71U) | (sizeof(__u16 ) << 16),
              strength);
#line 1040
  ans = tmp < 0;
  }
#line 1040
  if (ans) {
    {
#line 1041
    perror("FE READ SIGNAL STRENGTH: ");
    }
#line 1042
    return (-1);
  }
#line 1044
  return (0);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int FEReadSNR(int fd , int32_t *snr ) 
{ 
  int ans ;
  int tmp ;

  {
  {
#line 1051
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 72U) | (sizeof(__u16 ) << 16),
              snr);
#line 1051
  ans = tmp < 0;
  }
#line 1051
  if (ans) {
    {
#line 1052
    perror("FE READ_SNR: ");
    }
#line 1053
    return (-1);
  }
#line 1055
  return (0);
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int FEReadUncorrectedBlocks(int fd , uint32_t *ucb ) 
{ 
  int ans ;
  int tmp ;

  {
  {
#line 1076
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 73U) | (sizeof(__u32 ) << 16),
              ucb);
#line 1076
  ans = tmp < 0;
  }
#line 1076
  if (ans) {
    {
#line 1077
    perror("FE READ UNCORRECTED BLOCKS: ");
    }
#line 1078
    return (-1);
  }
#line 1080
  return (0);
}
}
#line 1083 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void usage(int was_error ) 
{ 
  FILE *fp ;
  struct _IO_FILE *tmp ;

  {
#line 1085
  if (was_error) {
#line 1085
    tmp = stderr;
  } else {
#line 1085
    tmp = stdout;
  }
  {
#line 1085
  fp = tmp;
#line 1086
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Usage: dvbtune [OPTIONS]\n\n");
#line 1087
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Standard options:\n\n");
#line 1088
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-f freq     absolute Frequency (DVB-S in Hz or DVB-T in Hz)\n");
#line 1089
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"            or L-band Frequency (DVB-S in Hz or DVB-T in Hz)\n");
#line 1090
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-p [H,V]    Polarity (DVB-S only)\n");
#line 1091
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-s N        Symbol rate (DVB-S or DVB-C)\n");
#line 1092
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-v vpid     Decode video PID (full cards only)\n");
#line 1093
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-a apid     Decode audio PID (full cards only)\n");
#line 1094
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-t ttpid    Decode teletext PID (full cards only)\n");
#line 1095
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-pnr N      Tune to Program Number (aka service) N\n\n");
#line 1096
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-i          Dump SI information as XML\n");
#line 1098
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nAdvanced tuning options:\n\n");
#line 1099
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-c [0-3]    Use DVB card #[0-3]\n");
#line 1100
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-tone [0|1] 0=22kHz off, 1=22kHz on\n");
#line 1101
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-I [0|1|2]  0=Spectrum Inversion off, 1=Spectrum Inversion on, 2=auto\n");
#line 1102
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-D [0-4]    DiSEqC command (0=none)\n\n");
#line 1103
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-qam X      DVB-T modulation - 16%s, 32%s, 64%s, 128%s or 256%s\n",
          "", "", " (default)", "", "");
#line 1109
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-gi N       DVB-T guard interval 1_N (N=32%s, 16%s, 8%s or 4%s)\n",
          " (default)", "", "", "");
#line 1114
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-cr N       DVB-T code rate. N=AUTO%s, 1_2%s, 2_3%s, 3_4%s, 5_6%s, 7_8%s\n",
          "", "", " (default)", "", "", "");
#line 1121
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-bw N       DVB-T bandwidth (Mhz) - N=6%s, 7%s or 8%s\n",
          "", "", " (default)");
#line 1125
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-tm N       DVB-T transmission mode - N=2%s or 8%s\n",
          " (default)", "");
#line 1129
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-x          Attempt to auto-find other transponders (experimental - DVB-S only)\n");
#line 1130
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-m          Monitor the reception quality\n");
#line 1131
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-n dpid     Add network interface and receive MPE on PID dpid\n");
#line 1132
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 1134
  exit(was_error);
  }
}
}
#line 1137 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
void version(void) 
{ 


  {
  {
#line 1139
  printf((char const   */* __restrict  */)"dvbtune %s\n", "");
#line 1140
  exit(0);
  }
}
}
#line 1143 "/home/june/repo/benchmarks/collector/temp/dvbtune-0.5.ds/dvbtune.c"
int main(int argc , char **argv ) 
{ 
  int fd_frontend ;
  int fd_sec ;
  int fd_dvr ;
  int do_info ;
  int do_scan ;
  int do_monitor ;
  unsigned int freq ;
  char pol ;
  unsigned int srate ;
  unsigned int diseqc ;
  int ttpid ;
  int dpid ;
  fe_modulation_t modulation ;
  fe_transmit_mode_t TransmissionMode ;
  fe_bandwidth_t bandWidth ;
  fe_guard_interval_t guardInterval ;
  fe_code_rate_t HP_CodeRate ;
  int count ;
  transponder_t *t ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char devnamen[80] ;
  int dev ;
  int fdn ;
  struct dvb_net_if netif ;
  int32_t strength ;
  int32_t ber ;
  int32_t snr ;
  int32_t uncorr ;
  fe_status_t festatus ;

  {
#line 1145
  fd_frontend = 0;
#line 1146
  fd_sec = 0;
#line 1147
  fd_dvr = 0;
#line 1148
  do_info = 0;
#line 1149
  do_scan = 0;
#line 1150
  do_monitor = 0;
#line 1152
  freq = 0U;
#line 1153
  pol = (char)0;
#line 1154
  srate = 0U;
#line 1155
  diseqc = 0U;
#line 1156
  ttpid = 0;
#line 1157
  dpid = 0;
#line 1159
  modulation = (fe_modulation_t )3;
#line 1160
  TransmissionMode = (fe_transmit_mode_t )0;
#line 1161
  bandWidth = (fe_bandwidth_t )0;
#line 1162
  guardInterval = (fe_guard_interval_t )0;
#line 1163
  HP_CodeRate = (fe_code_rate_t )2;
#line 1169
  if (argc == 1) {
    {
#line 1170
    usage(1);
    }
  } else {
#line 1172
    count = 0;
#line 1173
    i = 1;
    {
#line 1173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1173
      if (! (i < argc)) {
#line 1173
        goto while_break;
      }
      {
#line 1174
      tmp___41 = strcmp((char const   *)*(argv + i), "-f");
      }
#line 1174
      if (tmp___41 == 0) {
        {
#line 1175
        i ++;
#line 1176
        tmp = atoi((char const   *)*(argv + i));
#line 1176
        freq = (unsigned int )tmp;
        }
      } else {
        {
#line 1177
        tmp___40 = strcmp((char const   *)*(argv + i), "-i");
        }
#line 1177
        if (tmp___40 == 0) {
#line 1178
          do_info = 1;
        } else {
          {
#line 1179
          tmp___39 = strcmp((char const   *)*(argv + i), "-m");
          }
#line 1179
          if (tmp___39 == 0) {
#line 1180
            do_monitor = 1;
          } else {
            {
#line 1181
            tmp___38 = strcmp((char const   *)*(argv + i), "-n");
            }
#line 1181
            if (tmp___38 == 0) {
              {
#line 1182
              i ++;
#line 1183
              dpid = atoi((char const   *)*(argv + i));
              }
            } else {
              {
#line 1184
              tmp___37 = strcmp((char const   *)*(argv + i), "-c");
              }
#line 1184
              if (tmp___37 == 0) {
                {
#line 1185
                i ++;
#line 1186
                card = atoi((char const   *)*(argv + i));
                }
#line 1187
                if (card < 0) {
                  {
#line 1188
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"card must be between 0 and 3\n");
#line 1189
                  exit(-1);
                  }
                } else
#line 1187
                if (card > 3) {
                  {
#line 1188
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"card must be between 0 and 3\n");
#line 1189
                  exit(-1);
                  }
                }
              } else {
                {
#line 1191
                tmp___36 = strcmp((char const   *)*(argv + i), "-x");
                }
#line 1191
                if (tmp___36 == 0) {
#line 1192
                  do_scan = 1;
                } else {
                  {
#line 1193
                  tmp___35 = strcmp((char const   *)*(argv + i), "-v");
                  }
#line 1193
                  if (tmp___35 == 0) {
                    {
#line 1194
                    i ++;
#line 1195
                    vpid = atoi((char const   *)*(argv + i));
                    }
                  } else {
                    {
#line 1196
                    tmp___34 = strcmp((char const   *)*(argv + i), "-pnr");
                    }
#line 1196
                    if (tmp___34 == 0) {
                      {
#line 1197
                      i ++;
#line 1198
                      pnr = atoi((char const   *)*(argv + i));
#line 1199
                      do_info = 1;
                      }
                    } else {
                      {
#line 1200
                      tmp___33 = strcmp((char const   *)*(argv + i), "-a");
                      }
#line 1200
                      if (tmp___33 == 0) {
                        {
#line 1201
                        i ++;
#line 1202
                        apid = atoi((char const   *)*(argv + i));
                        }
                      } else {
                        {
#line 1203
                        tmp___32 = strcmp((char const   *)*(argv + i), "-t");
                        }
#line 1203
                        if (tmp___32 == 0) {
                          {
#line 1204
                          i ++;
#line 1205
                          ttpid = atoi((char const   *)*(argv + i));
                          }
                        } else {
                          {
#line 1206
                          tmp___31 = strcmp((char const   *)*(argv + i), "-p");
                          }
#line 1206
                          if (tmp___31 == 0) {
#line 1207
                            i ++;
#line 1208
                            if ((int )*(*(argv + i) + 1) == 0) {
                              {
#line 1209
                              tmp___3 = tolower((int )*(*(argv + i) + 0));
                              }
#line 1209
                              if (tmp___3 == 118) {
#line 1210
                                pol = (char )'V';
                              } else {
                                {
#line 1211
                                tmp___2 = tolower((int )*(*(argv + i) + 0));
                                }
#line 1211
                                if (tmp___2 == 104) {
#line 1212
                                  pol = (char )'H';
                                } else {
                                  {
#line 1213
                                  tmp___1 = tolower((int )*(*(argv + i) + 0));
                                  }
#line 1213
                                  if (tmp___1 == 108) {
#line 1214
                                    pol = (char )'L';
                                  } else {
                                    {
#line 1215
                                    tmp___0 = tolower((int )*(*(argv + i) + 0));
                                    }
#line 1215
                                    if (tmp___0 == 114) {
#line 1216
                                      pol = (char )'R';
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            {
#line 1219
                            tmp___30 = strcmp((char const   *)*(argv + i), "-s");
                            }
#line 1219
                            if (tmp___30 == 0) {
                              {
#line 1220
                              i ++;
#line 1221
                              tmp___4 = atoi((char const   *)*(argv + i));
#line 1221
                              srate = (unsigned int )((unsigned long )tmp___4 * 1000UL);
                              }
                            } else {
                              {
#line 1222
                              tmp___29 = strcmp((char const   *)*(argv + i), "-qam");
                              }
#line 1222
                              if (tmp___29 == 0) {
                                {
#line 1223
                                i ++;
#line 1224
                                tmp___5 = atoi((char const   *)*(argv + i));
                                }
                                {
#line 1225
                                if (tmp___5 == 16) {
#line 1225
                                  goto case_16;
                                }
#line 1226
                                if (tmp___5 == 32) {
#line 1226
                                  goto case_32;
                                }
#line 1227
                                if (tmp___5 == 64) {
#line 1227
                                  goto case_64;
                                }
#line 1228
                                if (tmp___5 == 128) {
#line 1228
                                  goto case_128;
                                }
#line 1229
                                if (tmp___5 == 256) {
#line 1229
                                  goto case_256;
                                }
#line 1230
                                goto switch_default;
                                case_16: /* CIL Label */ 
#line 1225
                                modulation = (fe_modulation_t )1;
#line 1225
                                goto switch_break;
                                case_32: /* CIL Label */ 
#line 1226
                                modulation = (fe_modulation_t )2;
#line 1226
                                goto switch_break;
                                case_64: /* CIL Label */ 
#line 1227
                                modulation = (fe_modulation_t )3;
#line 1227
                                goto switch_break;
                                case_128: /* CIL Label */ 
#line 1228
                                modulation = (fe_modulation_t )4;
#line 1228
                                goto switch_break;
                                case_256: /* CIL Label */ 
#line 1229
                                modulation = (fe_modulation_t )5;
#line 1229
                                goto switch_break;
                                switch_default: /* CIL Label */ 
                                {
#line 1231
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid QAM rate: %s\n",
                                        *(argv + i));
#line 1232
                                exit(0);
                                }
                                switch_break: /* CIL Label */ ;
                                }
                              } else {
                                {
#line 1234
                                tmp___28 = strcmp((char const   *)*(argv + i), "-gi");
                                }
#line 1234
                                if (tmp___28 == 0) {
                                  {
#line 1235
                                  i ++;
#line 1236
                                  tmp___6 = atoi((char const   *)*(argv + i));
                                  }
                                  {
#line 1237
                                  if (tmp___6 == 32) {
#line 1237
                                    goto case_32___0;
                                  }
#line 1238
                                  if (tmp___6 == 16) {
#line 1238
                                    goto case_16___0;
                                  }
#line 1239
                                  if (tmp___6 == 8) {
#line 1239
                                    goto case_8;
                                  }
#line 1240
                                  if (tmp___6 == 4) {
#line 1240
                                    goto case_4;
                                  }
#line 1241
                                  goto switch_default___0;
                                  case_32___0: /* CIL Label */ 
#line 1237
                                  guardInterval = (fe_guard_interval_t )0;
#line 1237
                                  goto switch_break___0;
                                  case_16___0: /* CIL Label */ 
#line 1238
                                  guardInterval = (fe_guard_interval_t )1;
#line 1238
                                  goto switch_break___0;
                                  case_8: /* CIL Label */ 
#line 1239
                                  guardInterval = (fe_guard_interval_t )2;
#line 1239
                                  goto switch_break___0;
                                  case_4: /* CIL Label */ 
#line 1240
                                  guardInterval = (fe_guard_interval_t )3;
#line 1240
                                  goto switch_break___0;
                                  switch_default___0: /* CIL Label */ 
                                  {
#line 1242
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid Guard Interval: %s\n",
                                          *(argv + i));
#line 1243
                                  exit(1);
                                  }
                                  switch_break___0: /* CIL Label */ ;
                                  }
                                } else {
                                  {
#line 1245
                                  tmp___27 = strcmp((char const   *)*(argv + i), "-tm");
                                  }
#line 1245
                                  if (tmp___27 == 0) {
                                    {
#line 1246
                                    i ++;
#line 1247
                                    tmp___7 = atoi((char const   *)*(argv + i));
                                    }
                                    {
#line 1248
                                    if (tmp___7 == 8) {
#line 1248
                                      goto case_8___0;
                                    }
#line 1249
                                    if (tmp___7 == 2) {
#line 1249
                                      goto case_2;
                                    }
#line 1250
                                    goto switch_default___1;
                                    case_8___0: /* CIL Label */ 
#line 1248
                                    TransmissionMode = (fe_transmit_mode_t )1;
#line 1248
                                    goto switch_break___1;
                                    case_2: /* CIL Label */ 
#line 1249
                                    TransmissionMode = (fe_transmit_mode_t )0;
#line 1249
                                    goto switch_break___1;
                                    switch_default___1: /* CIL Label */ 
                                    {
#line 1251
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid Transmission Mode: %s\n",
                                            *(argv + i));
#line 1252
                                    exit(1);
                                    }
                                    switch_break___1: /* CIL Label */ ;
                                    }
                                  } else {
                                    {
#line 1254
                                    tmp___26 = strcmp((char const   *)*(argv + i),
                                                      "-bw");
                                    }
#line 1254
                                    if (tmp___26 == 0) {
                                      {
#line 1255
                                      i ++;
#line 1256
                                      tmp___8 = atoi((char const   *)*(argv + i));
                                      }
                                      {
#line 1257
                                      if (tmp___8 == 8) {
#line 1257
                                        goto case_8___1;
                                      }
#line 1258
                                      if (tmp___8 == 7) {
#line 1258
                                        goto case_7;
                                      }
#line 1259
                                      if (tmp___8 == 6) {
#line 1259
                                        goto case_6;
                                      }
#line 1260
                                      goto switch_default___2;
                                      case_8___1: /* CIL Label */ 
#line 1257
                                      bandWidth = (fe_bandwidth_t )0;
#line 1257
                                      goto switch_break___2;
                                      case_7: /* CIL Label */ 
#line 1258
                                      bandWidth = (fe_bandwidth_t )1;
#line 1258
                                      goto switch_break___2;
                                      case_6: /* CIL Label */ 
#line 1259
                                      bandWidth = (fe_bandwidth_t )2;
#line 1259
                                      goto switch_break___2;
                                      switch_default___2: /* CIL Label */ 
                                      {
#line 1261
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid DVB-T bandwidth: %s\n",
                                              *(argv + i));
#line 1262
                                      exit(1);
                                      }
                                      switch_break___2: /* CIL Label */ ;
                                      }
                                    } else {
                                      {
#line 1264
                                      tmp___25 = strcmp((char const   *)*(argv + i),
                                                        "-cr");
                                      }
#line 1264
                                      if (tmp___25 == 0) {
                                        {
#line 1265
                                        i ++;
#line 1266
                                        tmp___14 = strcmp((char const   *)*(argv + i),
                                                          "AUTO");
                                        }
#line 1266
                                        if (tmp___14) {
                                          {
#line 1268
                                          tmp___13 = strcmp((char const   *)*(argv + i),
                                                            "1_2");
                                          }
#line 1268
                                          if (tmp___13) {
                                            {
#line 1270
                                            tmp___12 = strcmp((char const   *)*(argv + i),
                                                              "2_3");
                                            }
#line 1270
                                            if (tmp___12) {
                                              {
#line 1272
                                              tmp___11 = strcmp((char const   *)*(argv + i),
                                                                "3_4");
                                              }
#line 1272
                                              if (tmp___11) {
                                                {
#line 1274
                                                tmp___10 = strcmp((char const   *)*(argv + i),
                                                                  "5_6");
                                                }
#line 1274
                                                if (tmp___10) {
                                                  {
#line 1276
                                                  tmp___9 = strcmp((char const   *)*(argv + i),
                                                                   "7_8");
                                                  }
#line 1276
                                                  if (tmp___9) {
                                                    {
#line 1279
                                                    fprintf((FILE */* __restrict  */)stderr,
                                                            (char const   */* __restrict  */)"Invalid Code Rate: %s\n",
                                                            *(argv + i));
#line 1280
                                                    exit(1);
                                                    }
                                                  } else {
#line 1277
                                                    HP_CodeRate = (fe_code_rate_t )7;
                                                  }
                                                } else {
#line 1275
                                                  HP_CodeRate = (fe_code_rate_t )5;
                                                }
                                              } else {
#line 1273
                                                HP_CodeRate = (fe_code_rate_t )3;
                                              }
                                            } else {
#line 1271
                                              HP_CodeRate = (fe_code_rate_t )2;
                                            }
                                          } else {
#line 1269
                                            HP_CodeRate = (fe_code_rate_t )1;
                                          }
                                        } else {
#line 1267
                                          HP_CodeRate = (fe_code_rate_t )9;
                                        }
                                      } else {
                                        {
#line 1282
                                        tmp___24 = strcmp((char const   *)*(argv + i),
                                                          "-D");
                                        }
#line 1282
                                        if (tmp___24 == 0) {
                                          {
#line 1283
                                          i ++;
#line 1284
                                          tmp___15 = atoi((char const   *)*(argv + i));
#line 1284
                                          diseqc = (unsigned int )tmp___15;
                                          }
#line 1285
                                          if (diseqc > 4U) {
                                            {
#line 1286
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"DiSEqC must be between 0 and 4\n");
#line 1287
                                            exit(-1);
                                            }
                                          }
                                        } else {
                                          {
#line 1289
                                          tmp___23 = strcmp((char const   *)*(argv + i),
                                                            "-tone");
                                          }
#line 1289
                                          if (tmp___23 == 0) {
                                            {
#line 1290
                                            i ++;
#line 1291
                                            tmp___16 = atoi((char const   *)*(argv + i));
                                            }
#line 1291
                                            if (tmp___16 == 0) {
#line 1292
                                              tone = 1;
                                            } else {
#line 1294
                                              tone = 0;
                                            }
                                          } else {
                                            {
#line 1295
                                            tmp___22 = strcmp((char const   *)*(argv + i),
                                                              "-I");
                                            }
#line 1295
                                            if (tmp___22 == 0) {
                                              {
#line 1296
                                              i ++;
#line 1297
                                              tmp___18 = atoi((char const   *)*(argv + i));
                                              }
#line 1297
                                              if (tmp___18 == 0) {
#line 1298
                                                specInv = (fe_spectral_inversion_t )0;
                                              } else {
                                                {
#line 1299
                                                tmp___17 = atoi((char const   *)*(argv + i));
                                                }
#line 1299
                                                if (tmp___17 == 1) {
#line 1300
                                                  specInv = (fe_spectral_inversion_t )1;
                                                } else {
#line 1302
                                                  specInv = (fe_spectral_inversion_t )2;
                                                }
                                              }
                                            } else {
                                              {
#line 1303
                                              tmp___20 = strcmp((char const   *)*(argv + i),
                                                                "--help");
                                              }
#line 1303
                                              if (tmp___20 == 0) {
                                                {
#line 1305
                                                usage(0);
                                                }
                                              } else {
                                                {
#line 1303
                                                tmp___21 = strcmp((char const   *)*(argv + i),
                                                                  "-h");
                                                }
#line 1303
                                                if (tmp___21 == 0) {
                                                  {
#line 1305
                                                  usage(0);
                                                  }
                                                } else {
                                                  {
#line 1306
                                                  tmp___19 = strcmp((char const   *)*(argv + i),
                                                                    "--version");
                                                  }
#line 1306
                                                  if (tmp___19 == 0) {
                                                    {
#line 1307
                                                    version();
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 1173
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1319
  fd_dvr = open((char const   *)dvrdev[card], 2048);
  }
#line 1319
  if (fd_dvr < 0) {
    {
#line 1320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD %d: ",
            i);
#line 1321
    perror("fd_dvr DEMUX DEVICE: ");
    }
#line 1322
    return (-1);
  }
  {
#line 1325
  fd_frontend = open((char const   *)frontenddev[card], 2);
  }
#line 1325
  if (fd_frontend < 0) {
    {
#line 1326
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"frontend: %d",
            i);
#line 1327
    perror("FRONTEND DEVICE: ");
    }
#line 1328
    return (-1);
  }
  {
#line 1341
  fd_demuxrec = open((char const   *)demuxdev[card], 2050);
  }
#line 1341
  if (fd_demuxrec < 0) {
    {
#line 1342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD %i: ",
            i);
#line 1343
    perror("DEMUX DEVICE: ");
    }
#line 1344
    return (-1);
  }
  {
#line 1347
  fd_demuxv = open((char const   *)demuxdev[card], 2);
  }
#line 1347
  if (fd_demuxv < 0) {
    {
#line 1348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD %i: ",
            i);
#line 1349
    perror("DEMUX DEVICE: ");
    }
#line 1350
    return (-1);
  }
  {
#line 1353
  fd_demuxa = open((char const   *)demuxdev[card], 2);
  }
#line 1353
  if (fd_demuxa < 0) {
    {
#line 1354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD %i: ",
            i);
#line 1355
    perror("DEMUX DEVICE: ");
    }
#line 1356
    return (-1);
  }
  {
#line 1359
  fd_demuxtt = open((char const   *)demuxdev[card], 2);
  }
#line 1359
  if (fd_demuxtt < 0) {
    {
#line 1360
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD %i: ",
            i);
#line 1361
    perror("DEMUX DEVICE: ");
    }
#line 1362
    return (-1);
  }
  {
#line 1365
  fd_demuxd = open((char const   *)demuxdev[card], 2);
  }
#line 1365
  if (fd_demuxd < 0) {
    {
#line 1366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD %i: ",
            i);
#line 1367
    perror("DEMUX DEVICE: ");
    }
#line 1368
    return (-1);
  }
  {
#line 1371
  fd_demuxsi = open((char const   *)demuxdev[card], 2050);
  }
#line 1371
  if (fd_demuxsi < 0) {
    {
#line 1372
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FD %i: ",
            i);
#line 1373
    perror("DEMUX DEVICE: ");
    }
#line 1374
    return (-1);
  }
#line 1377
  if (freq > 0U) {
    {
#line 1379
    set_apid((ushort )0);
#line 1380
    set_vpid((ushort )0);
#line 1381
    set_ttpid((ushort )0);
#line 1383
    tmp___42 = tune_it(fd_frontend, fd_sec, freq, srate, pol, tone, specInv, diseqc,
                       modulation, HP_CodeRate, TransmissionMode, guardInterval, bandWidth);
    }
#line 1383
    if (tmp___42 < 0) {
#line 1384
      return (-1);
    }
  }
#line 1388
  if (do_scan) {
    {
#line 1389
    printf((char const   */* __restrict  */)"<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<satellite>\n");
#line 1390
    scan_nit(64);
#line 1391
    scan_nit(65);
    }
    {
#line 1392
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1392
      t = get_unscanned(transponders);
      }
#line 1392
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 1392
        goto while_break___0;
      }
      {
#line 1393
      free_pat_list();
#line 1394
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scanning %d%c %d\n",
              t->freq, (int )t->pol, t->srate);
#line 1395
      tune_it(fd_frontend, fd_sec, t->freq, (unsigned int )t->srate, t->pol, tone,
              specInv, 0U, modulation, HP_CodeRate, TransmissionMode, guardInterval,
              bandWidth);
#line 1396
      printf((char const   */* __restrict  */)"<transponder id=\"%d\" onid=\"%d\" freq=\"%05d\" srate=\"%d\" pos=\"%04x\" we_flag=\"%d\" polarity=\"%c\" modulation=\"%d\">\n",
             t->id, t->onid, t->freq, t->srate, t->pos, t->we_flag, (int )t->pol,
             t->mod);
#line 1397
      t->scanned = 1;
#line 1398
      scan_pat();
#line 1399
      scan_sdt();
#line 1400
      printf((char const   */* __restrict  */)"</transponder>\n");
#line 1401
      scan_nit(64);
#line 1402
      scan_nit(65);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1404
    printf((char const   */* __restrict  */)"</satellite>\n");
    }
  }
#line 1407
  if (do_info) {
#line 1408
    if ((int )pol != 0) {
      {
#line 1409
      printf((char const   */* __restrict  */)"<transponder type=\"S\" freq=\"%d\" srate=\"%d\" polarity=\"%c\" >\n",
             freq, srate, (int )pol);
      }
    } else
#line 1411
    if (srate != 0U) {
      {
#line 1412
      printf((char const   */* __restrict  */)"<transponder type=\"C\" freq=\"%d\" srate=\"%d\">\n",
             freq, srate);
      }
    } else {
#line 1414
      if (freq < 1000000U) {
#line 1414
        freq = (unsigned int )((unsigned long )freq * 1000UL);
      }
      {
#line 1415
      printf((char const   */* __restrict  */)"<transponder type=\"T\" freq=\"%d\">\n",
             freq);
      }
    }
    {
#line 1418
    scan_pat();
#line 1419
    scan_sdt();
#line 1421
    printf((char const   */* __restrict  */)"</transponder>\n");
    }
  }
#line 1424
  if (vpid != 0) {
    {
#line 1425
    set_vpid((ushort )vpid);
#line 1426
    set_apid((ushort )apid);
#line 1427
    set_ttpid((ushort )ttpid);
#line 1428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A/V/TT Filters set\n");
    }
  } else
#line 1424
  if (apid != 0) {
    {
#line 1425
    set_vpid((ushort )vpid);
#line 1426
    set_apid((ushort )apid);
#line 1427
    set_ttpid((ushort )ttpid);
#line 1428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A/V/TT Filters set\n");
    }
  } else
#line 1424
  if (ttpid != 0) {
    {
#line 1425
    set_vpid((ushort )vpid);
#line 1426
    set_apid((ushort )apid);
#line 1427
    set_ttpid((ushort )ttpid);
#line 1428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A/V/TT Filters set\n");
    }
  }
#line 1431
  if (dpid > 0) {
    {
#line 1436
    dev = card;
#line 1437
    netif.pid = (__u16 )dpid;
#line 1438
    netif.if_num = (__u16 )0;
#line 1441
    sprintf((char */* __restrict  */)(devnamen), (char const   */* __restrict  */)"/dev/dvb/adapter%d/net0",
            dev);
#line 1446
    fdn = open((char const   *)(devnamen), 2050);
    }
#line 1446
    if (fdn < 0) {
      {
#line 1447
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open DVB NET DEVICE");
#line 1448
      close(fd_frontend);
      }
#line 1449
      if (fd_sec) {
        {
#line 1449
        close(fd_sec);
        }
      }
    } else {
      {
#line 1452
      ioctl(fdn, (unsigned long )(((3U << 30) | (unsigned int )(111 << 8)) | 52U) | (sizeof(struct dvb_net_if ) << 16),
            & netif);
#line 1454
      close(fdn);
#line 1455
      printf((char const   */* __restrict  */)"Successfully opened network device, please configure the dvb interface\n");
      }
    }
  }
#line 1459
  if (do_monitor) {
    {
#line 1463
    fd_frontend = open((char const   *)frontenddev[card], 0);
    }
#line 1463
    if (fd_frontend < 0) {
      {
#line 1464
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"frontend: %d",
              i);
#line 1465
      perror("FRONTEND DEVICE: ");
      }
#line 1466
      return (-1);
    }
    {
#line 1470
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1471
      festatus = (fe_status_t )0;
#line 1471
      strength = 0;
#line 1471
      ber = 0;
#line 1471
      snr = 0;
#line 1471
      uncorr = 0;
#line 1472
      FEReadBER(fd_frontend, (uint32_t *)(& ber));
#line 1473
      FEReadSignalStrength(fd_frontend, & strength);
#line 1474
      FEReadSNR(fd_frontend, & snr);
#line 1475
      FEReadUncorrectedBlocks(fd_frontend, (uint32_t *)(& uncorr));
#line 1476
      ioctl(fd_frontend, (unsigned long )(((2U << 30) | (unsigned int )(111 << 8)) | 69U) | (sizeof(fe_status_t ) << 16),
            & festatus);
#line 1477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Signal=%d, Verror=%d, SNR=%ddB, BlockErrors=%d, (",
              strength, ber, snr, uncorr);
      }
#line 1482
      if ((unsigned int )festatus & 1U) {
        {
#line 1482
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"S|");
        }
      }
#line 1483
      if ((unsigned int )festatus & 16U) {
        {
#line 1483
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"L|");
        }
      }
#line 1484
      if ((unsigned int )festatus & 2U) {
        {
#line 1484
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"C|");
        }
      }
#line 1485
      if ((unsigned int )festatus & 4U) {
        {
#line 1485
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"V|");
        }
      }
#line 1486
      if ((unsigned int )festatus & 8U) {
        {
#line 1486
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SY|");
        }
      }
      {
#line 1487
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
#line 1488
      sleep(1U);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1493
  close(fd_frontend);
  }
#line 1494
  if (fd_sec) {
    {
#line 1494
    close(fd_sec);
    }
  }
#line 1495
  return (0);
}
}
