/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
union __anonunion_sem_t_61 {
   char __size[32] ;
   long __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
typedef union __anonunion_sem_t_61 sem_t;
#line 64 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
enum _Mode {
    NOT_IN_USE = 0,
    FREE = 1,
    ALLOCATED = 2,
    PROTECTED = 3,
    INTERNAL_USE = 4
} ;
#line 71 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
typedef enum _Mode Mode;
#line 77 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
struct _Slot {
   void *userAddress ;
   void *internalAddress ;
   size_t userSize ;
   size_t internalSize ;
   Mode mode ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
typedef struct _Slot Slot;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 12 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.h"
typedef unsigned long ef_number;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 21 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
struct diagnostic {
   int (*test)(void) ;
   int expectedStatus ;
   char const   *explanation ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.h"
void Page_AllowAccess(void *address , size_t size ) ;
#line 34
void *Page_Create(size_t size ) ;
#line 35
void Page_Delete(void *address , size_t size ) ;
#line 36
void Page_DenyAccess(void *address , size_t size ) ;
#line 37
size_t Page_Size(void) ;
#line 41
void EF_Exit(char const   *pattern  , ...) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 81
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mprotect)(void *__addr ,
                                                                               size_t __len ,
                                                                               int __prot ) ;
#line 94
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) madvise)(void *__addr ,
                                                                              size_t __len ,
                                                                              int __advice ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 427 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen )  __asm__("__xpg_strerror_r")  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static caddr_t startAddr  =    (caddr_t )0;
#line 37 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static char const   *stringErrorReport(void) 
{ 
  char err_message[128] ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 46
  tmp = __errno_location();
#line 46
  tmp___0 = strerror_r(*tmp, err_message, (size_t )128);
  }
#line 46
  return ((char const   *)tmp___0);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
void *Page_Create(size_t size ) 
{ 
  caddr_t allocation___0 ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 69
  tmp = mmap((void *)startAddr, (size_t )((int )size), 3, 34, -1, (__off_t )0);
#line 69
  allocation___0 = (caddr_t )tmp;
#line 88
  startAddr = allocation___0 + size;
  }
#line 91
  if ((unsigned long )allocation___0 == (unsigned long )((caddr_t )-1)) {
    {
#line 92
    tmp___0 = stringErrorReport();
#line 92
    EF_Exit("mmap() failed: %s", tmp___0);
    }
  }
#line 94
  return ((void *)allocation___0);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static void mprotectFailed(void) 
{ 
  char const   *tmp ;

  {
  {
#line 141
  tmp = stringErrorReport();
#line 141
  EF_Exit("mprotect() failed: %s", tmp);
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
void Page_AllowAccess(void *address , size_t size ) 
{ 
  int tmp ;

  {
  {
#line 147
  tmp = mprotect((void *)((caddr_t )address), size, 3);
  }
#line 147
  if (tmp < 0) {
    {
#line 148
    mprotectFailed();
    }
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
void Page_DenyAccess(void *address , size_t size ) 
{ 
  int tmp ;

  {
  {
#line 154
  tmp = mprotect((void *)((caddr_t )address), size, 0);
  }
#line 154
  if (tmp < 0) {
    {
#line 155
    mprotectFailed();
    }
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
void Page_Delete(void *address , size_t size ) 
{ 


  {
  {
#line 161
  Page_DenyAccess(address, size);
#line 163
  madvise(address, size, 4);
  }
#line 164
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
size_t Page_Size(void) 
{ 
  long tmp ;

  {
  {
#line 170
  tmp = sysconf(30);
  }
#line 170
  return ((size_t )tmp);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.h"
void EF_Abort(char const   *pattern  , ...) ;
#line 43
void EF_Print(char const   *pattern  , ...) ;
#line 45
void EF_InternalError(char const   *pattern  , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t nelem ,
                                                                               size_t elsize )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *oldBuffer , size_t newSize ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *address ) ;
#line 498
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) valloc)(size_t size )  __attribute__((__malloc__)) ;
#line 503
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **memptr ,
                                                                                                     size_t alignment ,
                                                                                                     size_t size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 36 "/usr/include/semaphore.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sem_init)(sem_t *__sem ,
                                                                               int __pshared ,
                                                                               unsigned int __value ) ;
#line 54
extern int sem_wait(sem_t *__sem ) ;
#line 69
extern  __attribute__((__nothrow__)) int sem_post(sem_t *__sem ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static char const   version[79]  = 
#line 51 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
  {      (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'E', 
        (char const   )'l',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'F',      (char const   )'e',      (char const   )'n',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'2',      (char const   )'.', 
        (char const   )'2',      (char const   )' ',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'C',      (char const   )')',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'8',      (char const   )'7', 
        (char const   )'-',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'9',      (char const   )' ',      (char const   )'B',      (char const   )'r', 
        (char const   )'u',      (char const   )'c',      (char const   )'e',      (char const   )' ', 
        (char const   )'P',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'<', 
        (char const   )'b',      (char const   )'r',      (char const   )'u',      (char const   )'c', 
        (char const   )'e',      (char const   )'@',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'.',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'>',      (char const   )'\n',      (char const   )'\000'};
#line 86
static void *memalign_locked(size_t alignment , size_t userSize ) ;
#line 87
static void free_locked(void *address ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
int EF_DISABLE_BANNER  =    -1;
#line 105 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
int EF_ALIGNMENT  =    -1;
#line 118 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
int EF_PROTECT_FREE  =    -1;
#line 130 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
int EF_PROTECT_BELOW  =    -1;
#line 136 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
int EF_ALLOW_MALLOC_0  =    -1;
#line 142 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
int EF_FILL  =    -1;
#line 148 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *allocationList  =    (Slot *)0;
#line 154 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t allocationListSize  =    (size_t )0;
#line 159 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t slotCount  =    (size_t )0;
#line 166 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t unUsedSlots  =    (size_t )0;
#line 172 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t slotsPerPage  =    (size_t )0;
#line 178 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int internalUse  =    0;
#line 186 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int noAllocationListProtection  =    0;
#line 192
#pragma weak sem_init
#line 193
#pragma weak sem_post
#line 194
#pragma weak sem_wait
#line 196 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int pthread_initialization  =    0;
#line 204 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static sem_t EF_sem  =    {{(char)0}};
#line 205 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int semEnabled  =    0;
#line 212 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t bytesPerPage  =    (size_t )0;
#line 214 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void lock(void) 
{ 
  int tmp ;

  {
#line 219
  if (! semEnabled) {
#line 220
    return;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    tmp = sem_wait(& EF_sem);
    }
#line 223
    if (! (tmp < 0)) {
#line 223
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void release(void) 
{ 
  int tmp ;

  {
#line 233
  if (! semEnabled) {
#line 234
    return;
  }
  {
#line 235
  tmp = sem_post(& EF_sem);
  }
#line 235
  if (tmp < 0) {
    {
#line 236
    EF_InternalError("Failed to post the semaphore.");
    }
  }
#line 238
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void initialize(void) 
{ 
  size_t size ;
  size_t slack ;
  char *string ;
  Slot *slot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;

  {
#line 247
  size = (size_t )1048576;
#line 252
  if (EF_DISABLE_BANNER == -1) {
    {
#line 253
    string = getenv("EF_DISABLE_BANNER");
    }
#line 253
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 254
      EF_DISABLE_BANNER = atoi((char const   *)string);
      }
    } else {
#line 256
      EF_DISABLE_BANNER = 0;
    }
  }
#line 259
  if (EF_DISABLE_BANNER == 0) {
    {
#line 260
    EF_Print(version);
    }
  }
#line 264
  if ((unsigned long )(& sem_init) != (unsigned long )((void *)0)) {
#line 264
    if (! pthread_initialization) {
      {
#line 264
      tmp = sem_init(& EF_sem, 0, 1U);
      }
#line 264
      if (tmp >= 0) {
#line 265
        semEnabled = 1;
      }
    }
  }
  {
#line 268
  lock();
  }
#line 289
  if (EF_ALIGNMENT == -1) {
    {
#line 290
    string = getenv("EF_ALIGNMENT");
    }
#line 290
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 291
      tmp___0 = atoi((char const   *)string);
#line 291
      EF_ALIGNMENT = (int )((size_t )tmp___0);
      }
    } else {
#line 293
      EF_ALIGNMENT = (int )sizeof(int );
    }
  }
#line 300
  if (EF_PROTECT_BELOW == -1) {
    {
#line 301
    string = getenv("EF_PROTECT_BELOW");
    }
#line 301
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 302
      tmp___1 = atoi((char const   *)string);
#line 302
      EF_PROTECT_BELOW = tmp___1 != 0;
      }
    } else {
#line 304
      EF_PROTECT_BELOW = 0;
    }
  }
#line 311
  if (EF_PROTECT_FREE == -1) {
    {
#line 312
    string = getenv("EF_PROTECT_FREE");
    }
#line 312
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 313
      tmp___2 = atoi((char const   *)string);
#line 313
      EF_PROTECT_FREE = tmp___2 != 0;
      }
    } else {
#line 315
      EF_PROTECT_FREE = 0;
    }
  }
#line 321
  if (EF_ALLOW_MALLOC_0 == -1) {
    {
#line 322
    string = getenv("EF_ALLOW_MALLOC_0");
    }
#line 322
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 323
      tmp___3 = atoi((char const   *)string);
#line 323
      EF_ALLOW_MALLOC_0 = tmp___3 != 0;
      }
    } else {
#line 325
      EF_ALLOW_MALLOC_0 = 0;
    }
  }
#line 331
  if (EF_FILL == -1) {
    {
#line 332
    string = getenv("EF_FILL");
    }
#line 332
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 333
      tmp___4 = atoi((char const   *)string);
#line 333
      EF_FILL = (int )((unsigned char )tmp___4);
      }
    }
  }
  {
#line 339
  bytesPerPage = Page_Size();
#line 344
  slotsPerPage = bytesPerPage / sizeof(Slot );
#line 344
  slotCount = slotsPerPage;
#line 345
  allocationListSize = bytesPerPage;
  }
#line 347
  if (allocationListSize > size) {
#line 348
    size = allocationListSize;
  }
#line 350
  slack = size % bytesPerPage;
#line 350
  if (slack != 0UL) {
#line 351
    size += bytesPerPage - slack;
  }
  {
#line 358
  tmp___5 = Page_Create(size);
#line 358
  allocationList = (Slot *)tmp___5;
#line 358
  slot = allocationList;
#line 359
  memset((void *)((char *)allocationList), 0, allocationListSize);
#line 361
  tmp___6 = allocationListSize;
#line 361
  (slot + 0)->userSize = tmp___6;
#line 361
  (slot + 0)->internalSize = tmp___6;
#line 362
  tmp___7 = (void *)allocationList;
#line 362
  (slot + 0)->userAddress = tmp___7;
#line 362
  (slot + 0)->internalAddress = tmp___7;
#line 363
  (slot + 0)->mode = (Mode )4;
  }
#line 364
  if (size > allocationListSize) {
#line 365
    tmp___8 = (void *)((char *)(slot + 0)->internalAddress + (slot + 0)->internalSize);
#line 365
    (slot + 1)->userAddress = tmp___8;
#line 365
    (slot + 1)->internalAddress = tmp___8;
#line 367
    tmp___9 = size - (slot + 0)->internalSize;
#line 367
    (slot + 1)->userSize = tmp___9;
#line 367
    (slot + 1)->internalSize = tmp___9;
#line 369
    (slot + 1)->mode = (Mode )1;
  }
  {
#line 376
  Page_DenyAccess((slot + 1)->internalAddress, (slot + 1)->internalSize);
#line 381
  unUsedSlots = slotCount - 2UL;
#line 383
  release();
  }
#line 384
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
void __libc_malloc_pthread_startup(_Bool first_time ) 
{ 
  int tmp ;

  {
#line 390
  if (first_time) {
    {
#line 391
    pthread_initialization = 1;
#line 392
    initialize();
    }
  } else {
#line 394
    pthread_initialization = 0;
#line 395
    if (! semEnabled) {
#line 395
      if ((unsigned long )(& sem_init) != (unsigned long )((void *)0)) {
        {
#line 395
        tmp = sem_init(& EF_sem, 0, 1U);
        }
#line 395
        if (tmp >= 0) {
#line 396
          semEnabled = 1;
        }
      }
    }
  }
#line 398
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void allocateMoreSlots(void) 
{ 
  size_t newSize ;
  void *newAllocation ;
  void *oldAllocation ;

  {
  {
#line 408
  newSize = allocationListSize + bytesPerPage;
#line 410
  oldAllocation = (void *)allocationList;
#line 412
  Page_AllowAccess((void *)allocationList, allocationListSize);
#line 413
  noAllocationListProtection = 1;
#line 414
  internalUse = 1;
#line 416
  newAllocation = memalign_locked((size_t )EF_ALIGNMENT, newSize);
#line 417
  memcpy((void */* __restrict  */)newAllocation, (void const   */* __restrict  */)allocationList,
         allocationListSize);
#line 418
  memset((void *)((char *)newAllocation + allocationListSize), 0, bytesPerPage);
#line 420
  allocationList = (Slot *)newAllocation;
#line 421
  allocationListSize = newSize;
#line 422
  slotCount += slotsPerPage;
#line 423
  unUsedSlots += slotsPerPage;
#line 425
  free_locked(oldAllocation);
#line 431
  noAllocationListProtection = 0;
#line 432
  internalUse = 0;
  }
#line 433
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void *memalign_locked(size_t alignment , size_t userSize ) 
{ 
  register Slot *slot ;
  register size_t count ;
  Slot *fullSlot ;
  Slot *emptySlots[2] ;
  size_t internalSize ;
  size_t slack ;
  char *address ;
  size_t chunkSize ;

  {
#line 462
  fullSlot = (Slot *)0;
#line 468
  if (userSize == 0UL) {
#line 468
    if (! EF_ALLOW_MALLOC_0) {
      {
#line 469
      EF_Abort("Allocating 0 bytes, probably a bug.");
      }
    }
  }
#line 475
  if (! EF_PROTECT_BELOW) {
#line 475
    if (alignment > 1UL) {
#line 476
      slack = userSize % alignment;
#line 476
      if (slack != 0UL) {
#line 477
        userSize += alignment - slack;
      }
    }
  }
#line 485
  internalSize = userSize + bytesPerPage;
#line 486
  slack = internalSize % bytesPerPage;
#line 486
  if (slack != 0UL) {
#line 487
    internalSize += bytesPerPage - slack;
  }
#line 494
  emptySlots[0] = (Slot *)0;
#line 495
  emptySlots[1] = (Slot *)0;
#line 503
  if (! noAllocationListProtection) {
    {
#line 504
    Page_AllowAccess((void *)allocationList, allocationListSize);
    }
  }
#line 510
  if (! internalUse) {
#line 510
    if (unUsedSlots < 7UL) {
      {
#line 511
      allocateMoreSlots();
      }
    }
  }
#line 524
  slot = allocationList;
#line 524
  count = slotCount;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (count > 0UL)) {
#line 524
      goto while_break;
    }
#line 525
    if ((unsigned int )slot->mode == 1U) {
#line 525
      if (slot->internalSize >= internalSize) {
#line 527
        if (! fullSlot) {
#line 527
          goto _L;
        } else
#line 527
        if (slot->internalSize < fullSlot->internalSize) {
          _L: /* CIL Label */ 
#line 529
          fullSlot = slot;
#line 530
          if (slot->internalSize == internalSize) {
#line 530
            if (emptySlots[0]) {
#line 532
              goto while_break;
            }
          }
        }
      } else {
#line 525
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 535
    if ((unsigned int )slot->mode == 0U) {
#line 536
      if (! emptySlots[0]) {
#line 537
        emptySlots[0] = slot;
      } else
#line 538
      if (! emptySlots[1]) {
#line 539
        emptySlots[1] = slot;
      } else
#line 540
      if (fullSlot) {
#line 540
        if (fullSlot->internalSize == internalSize) {
#line 542
          goto while_break;
        }
      }
    }
#line 544
    slot ++;
#line 524
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  if (! emptySlots[0]) {
    {
#line 547
    EF_InternalError("No empty slot 0.");
    }
  }
#line 549
  if (! fullSlot) {
#line 556
    chunkSize = (size_t )1048576;
#line 558
    if (! emptySlots[1]) {
      {
#line 559
      EF_InternalError("No empty slot 1.");
      }
    }
#line 561
    if (chunkSize < internalSize) {
#line 562
      chunkSize = internalSize;
    }
#line 564
    slack = chunkSize % bytesPerPage;
#line 564
    if (slack != 0UL) {
#line 565
      chunkSize += bytesPerPage - slack;
    }
    {
#line 568
    fullSlot = emptySlots[0];
#line 569
    emptySlots[0] = emptySlots[1];
#line 570
    fullSlot->internalAddress = Page_Create(chunkSize);
#line 571
    fullSlot->internalSize = chunkSize;
#line 572
    fullSlot->mode = (Mode )1;
#line 573
    unUsedSlots --;
    }
#line 576
    if (EF_FILL != -1) {
      {
#line 577
      memset((void *)((char *)fullSlot->internalAddress), EF_FILL, chunkSize);
      }
    }
  }
#line 588
  if (internalUse) {
#line 589
    fullSlot->mode = (Mode )4;
  } else {
#line 591
    fullSlot->mode = (Mode )2;
  }
#line 598
  if (fullSlot->internalSize > internalSize) {
#line 599
    (emptySlots[0])->internalSize = fullSlot->internalSize - internalSize;
#line 601
    (emptySlots[0])->internalAddress = (void *)((char *)fullSlot->internalAddress + internalSize);
#line 603
    (emptySlots[0])->mode = (Mode )1;
#line 604
    fullSlot->internalSize = internalSize;
#line 605
    unUsedSlots --;
  }
#line 608
  if (! EF_PROTECT_BELOW) {
#line 614
    address = (char *)fullSlot->internalAddress;
#line 617
    if (internalSize - bytesPerPage > 0UL) {
      {
#line 618
      Page_AllowAccess(fullSlot->internalAddress, internalSize - bytesPerPage);
      }
    }
    {
#line 622
    address += internalSize - bytesPerPage;
#line 625
    Page_Delete((void *)address, bytesPerPage);
#line 628
    address -= userSize;
    }
  } else {
    {
#line 636
    address = (char *)fullSlot->internalAddress;
#line 639
    Page_Delete((void *)address, bytesPerPage);
#line 641
    address += bytesPerPage;
    }
#line 644
    if (internalSize - bytesPerPage > 0UL) {
      {
#line 645
      Page_AllowAccess((void *)address, internalSize - bytesPerPage);
      }
    }
  }
#line 648
  fullSlot->userAddress = (void *)address;
#line 649
  fullSlot->userSize = userSize;
#line 655
  if (! internalUse) {
    {
#line 656
    Page_DenyAccess((void *)allocationList, allocationListSize);
    }
  }
#line 658
  return ((void *)address);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
extern void *memalign(size_t alignment , size_t userSize ) 
{ 
  void *address ;

  {
#line 665
  if ((unsigned long )allocationList == (unsigned long )((Slot *)0)) {
    {
#line 666
    initialize();
    }
  }
  {
#line 667
  lock();
#line 668
  address = memalign_locked(alignment, userSize);
#line 669
  release();
  }
#line 670
  return (address);
}
}
#line 673
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **memptr ,
                                                                                                     size_t alignment ,
                                                                                                     size_t size ) ;
#line 673 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
extern int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **memptr ,
                                                                       size_t alignment ,
                                                                       size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
#line 683
  if (alignment & (alignment - 1UL)) {
#line 685
    return (22);
  } else
#line 683
  if (alignment % sizeof(void *)) {
#line 685
    return (22);
  }
  {
#line 687
  tmp = memalign(alignment, size);
#line 687
  ptr = tmp;
  }
#line 688
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 689
    return (12);
  }
#line 690
  *memptr = ptr;
#line 691
  return (0);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForUserAddress(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 700
  slot = allocationList;
#line 701
  count = slotCount;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! (count > 0UL)) {
#line 703
      goto while_break;
    }
#line 704
    if ((unsigned long )slot->userAddress == (unsigned long )address) {
#line 705
      return (slot);
    }
#line 706
    slot ++;
#line 703
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return ((Slot *)0);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForInternalAddress(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 718
  slot = allocationList;
#line 719
  count = slotCount;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (count > 0UL)) {
#line 721
      goto while_break;
    }
#line 722
    if ((unsigned long )slot->internalAddress == (unsigned long )address) {
#line 723
      return (slot);
    }
#line 724
    slot ++;
#line 721
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  return ((Slot *)0);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForInternalAddressPreviousTo(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 737
  slot = allocationList;
#line 738
  count = slotCount;
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! (count > 0UL)) {
#line 740
      goto while_break;
    }
#line 741
    if ((unsigned long )((char *)slot->internalAddress + slot->internalSize) == (unsigned long )address) {
#line 743
      return (slot);
    }
#line 744
    slot ++;
#line 740
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  return ((Slot *)0);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void free_locked(void *address ) 
{ 
  Slot *slot ;
  Slot *previousSlot ;
  Slot *nextSlot ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 753
  previousSlot = (Slot *)0;
#line 754
  nextSlot = (Slot *)0;
#line 756
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 757
    return;
  }
#line 759
  if (! noAllocationListProtection) {
    {
#line 760
    Page_AllowAccess((void *)allocationList, allocationListSize);
    }
  }
  {
#line 762
  slot = slotForUserAddress(address);
  }
#line 764
  if (! slot) {
    {
#line 765
    EF_Abort("free(%a): address not from malloc().", address);
    }
  }
#line 767
  if ((unsigned int )slot->mode != 2U) {
#line 768
    if (internalUse) {
#line 768
      if (! ((unsigned int )slot->mode == 4U)) {
        {
#line 771
        EF_Abort("free(%a): freeing free memory.", address);
        }
      }
    } else {
      {
#line 771
      EF_Abort("free(%a): freeing free memory.", address);
      }
    }
  }
#line 777
  if (EF_PROTECT_FREE) {
#line 778
    slot->mode = (Mode )3;
  } else {
#line 780
    slot->mode = (Mode )1;
  }
  {
#line 796
  Page_Delete(slot->internalAddress, slot->internalSize);
#line 798
  previousSlot = slotForInternalAddressPreviousTo(slot->internalAddress);
#line 799
  nextSlot = slotForInternalAddress((void *)((char *)slot->internalAddress + slot->internalSize));
  }
#line 802
  if (previousSlot) {
#line 802
    if ((unsigned int )previousSlot->mode == (unsigned int )slot->mode) {
#line 804
      previousSlot->internalSize += slot->internalSize;
#line 805
      tmp = (void *)0;
#line 805
      slot->userAddress = tmp;
#line 805
      slot->internalAddress = tmp;
#line 806
      tmp___0 = (size_t )0;
#line 806
      slot->userSize = tmp___0;
#line 806
      slot->internalSize = tmp___0;
#line 807
      slot->mode = (Mode )0;
#line 808
      slot = previousSlot;
#line 809
      unUsedSlots ++;
    }
  }
#line 811
  if (nextSlot) {
#line 811
    if ((unsigned int )nextSlot->mode == (unsigned int )slot->mode) {
#line 813
      slot->internalSize += nextSlot->internalSize;
#line 814
      tmp___1 = (void *)0;
#line 814
      nextSlot->userAddress = tmp___1;
#line 814
      nextSlot->internalAddress = tmp___1;
#line 815
      tmp___2 = (size_t )0;
#line 815
      nextSlot->userSize = tmp___2;
#line 815
      nextSlot->internalSize = tmp___2;
#line 816
      nextSlot->mode = (Mode )0;
#line 817
      unUsedSlots ++;
    }
  }
#line 820
  slot->userAddress = slot->internalAddress;
#line 821
  slot->userSize = slot->internalSize;
#line 823
  if (! noAllocationListProtection) {
    {
#line 824
    Page_DenyAccess((void *)allocationList, allocationListSize);
    }
  }
#line 825
  return;
}
}
#line 827
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *address ) ;
#line 827 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
extern void ( __attribute__((__leaf__)) free)(void *address ) 
{ 


  {
#line 831
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 832
    return;
  }
#line 834
  if ((unsigned long )allocationList == (unsigned long )((Slot *)0)) {
    {
#line 835
    EF_Abort("free() called before first malloc().");
    }
  }
  {
#line 837
  lock();
#line 838
  free_locked(address);
#line 839
  release();
  }
#line 840
  return;
}
}
#line 842
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *oldBuffer , size_t newSize ) ;
#line 842 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
extern void *( __attribute__((__warn_unused_result__, __leaf__)) realloc)(void *oldBuffer ,
                                                                          size_t newSize ) 
{ 
  void *newBuffer ;
  size_t size ;
  Slot *slot ;

  {
#line 845
  newBuffer = (void *)0;
#line 847
  if ((unsigned long )allocationList == (unsigned long )((Slot *)0)) {
    {
#line 848
    initialize();
    }
  }
  {
#line 850
  lock();
#line 852
  newBuffer = memalign_locked((size_t )EF_ALIGNMENT, newSize);
  }
#line 854
  if (oldBuffer) {
    {
#line 858
    Page_AllowAccess((void *)allocationList, allocationListSize);
#line 859
    noAllocationListProtection = 1;
#line 861
    slot = slotForUserAddress(oldBuffer);
    }
#line 863
    if ((unsigned long )slot == (unsigned long )((Slot *)0)) {
      {
#line 864
      EF_Abort("realloc(%a, %d): address not from malloc().", oldBuffer, newSize);
      }
    }
#line 869
    size = slot->userSize;
#line 869
    if (newSize < size) {
#line 870
      size = newSize;
    }
#line 872
    if (size > 0UL) {
      {
#line 873
      memcpy((void */* __restrict  */)newBuffer, (void const   */* __restrict  */)oldBuffer,
             size);
      }
    }
    {
#line 875
    free_locked(oldBuffer);
#line 876
    noAllocationListProtection = 0;
#line 877
    Page_DenyAccess((void *)allocationList, allocationListSize);
    }
#line 879
    if (size < newSize) {
      {
#line 880
      memset((void *)((char *)newBuffer + size), 0, newSize - size);
      }
    }
  }
  {
#line 884
  release();
  }
#line 886
  return (newBuffer);
}
}
#line 889
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t size )  __attribute__((__malloc__)) ;
#line 889 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
extern void *( __attribute__((__leaf__)) malloc)(size_t size ) 
{ 
  void *tmp ;

  {
#line 892
  if ((unsigned long )allocationList == (unsigned long )((Slot *)0)) {
    {
#line 893
    initialize();
    }
  }
  {
#line 895
  tmp = memalign((size_t )EF_ALIGNMENT, size);
  }
#line 895
  return (tmp);
}
}
#line 898
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t nelem ,
                                                                               size_t elsize )  __attribute__((__malloc__)) ;
#line 898 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
extern void *( __attribute__((__leaf__)) calloc)(size_t nelem , size_t elsize ) 
{ 
  size_t size ;
  void *allocation___0 ;
  void *tmp ;

  {
  {
#line 901
  size = nelem * elsize;
#line 902
  tmp = malloc(size);
#line 902
  allocation___0 = tmp;
#line 904
  memset(allocation___0, 0, size);
  }
#line 905
  return (allocation___0);
}
}
#line 912
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) valloc)(size_t size )  __attribute__((__malloc__)) ;
#line 912 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
extern void *( __attribute__((__leaf__)) valloc)(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 915
  tmp = memalign(bytesPerPage, size);
  }
#line 915
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.h"
void EF_Abortv(char const   *pattern , va_list args ) ;
#line 42
void EF_Exitv(char const   *pattern , va_list args ) ;
#line 44
void EF_Printv(char const   *pattern , va_list args ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static void do_abort(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 28
  tmp = getpid();
#line 28
  kill(tmp, 4);
#line 30
  _exit(-1);
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static void printNumber(ef_number number , ef_number base ) 
{ 
  char buffer[sizeof(ef_number ) * 8UL] ;
  char *s ;
  int size ;
  ef_number digit ;

  {
#line 37
  s = & buffer[sizeof(ef_number ) * 8UL];
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    s --;
#line 43
    if ((unsigned long )s == (unsigned long )(buffer)) {
      {
#line 44
      EF_Abort("Internal error printing number.");
      }
    }
#line 46
    digit = number % base;
#line 48
    if (digit < 10UL) {
#line 49
      *s = (char )(48UL + digit);
    } else {
#line 51
      *s = (char )((97UL + digit) - 10UL);
    }
#line 40
    number /= base;
#line 40
    if (! (number > 0UL)) {
#line 40
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  size = (int )(& buffer[sizeof(ef_number ) * 8UL] - s);
#line 57
  if (size > 0) {
    {
#line 58
    write(2, (void const   *)s, (size_t )size);
    }
  }
#line 59
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static char const   bad_pattern[44]  = 
#line 64
  {      (char const   )'\n',      (char const   )'B',      (char const   )'a',      (char const   )'d', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'t', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'n', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'%', 
        (char const   )'%',      (char const   )'%',      (char const   )'c',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'E', 
        (char const   )'F',      (char const   )'_',      (char const   )'P',      (char const   )'r', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'(', 
        (char const   )')',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
void EF_Printv(char const   *pattern , va_list args ) 
{ 
  char const   *s ;
  char c___0 ;
  char const   *tmp ;
  void *tmp___1 ;
  char const   *string ;
  size_t length ;
  char const   *tmp___2 ;
  int n ;
  int tmp___4 ;
  char c___1 ;
  u_int tmp___6 ;
  char c___2 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 66
  s = pattern;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    tmp___9 = s;
#line 69
    s ++;
#line 69
    c___0 = (char )*tmp___9;
#line 69
    if (! ((int )c___0 != 0)) {
#line 69
      goto while_break;
    }
#line 70
    if ((int )c___0 == 37) {
#line 71
      tmp = s;
#line 71
      s ++;
#line 71
      c___0 = (char )*tmp;
      {
#line 73
      if ((int )c___0 == 37) {
#line 73
        goto case_37;
      }
#line 76
      if ((int )c___0 == 97) {
#line 76
        goto case_97;
      }
#line 87
      if ((int )c___0 == 115) {
#line 87
        goto case_115;
      }
#line 98
      if ((int )c___0 == 100) {
#line 98
        goto case_100;
      }
#line 110
      if ((int )c___0 == 120) {
#line 110
        goto case_120;
      }
#line 113
      if ((int )c___0 == 99) {
#line 113
        goto case_99;
      }
#line 120
      goto switch_default;
      case_37: /* CIL Label */ 
      {
#line 74
      write(2, (void const   *)(& c___0), (size_t )1);
      }
#line 75
      goto switch_break;
      case_97: /* CIL Label */ 
      {
#line 83
      tmp___1 = __builtin_va_arg(args, void *);
#line 83
      printNumber((ef_number )tmp___1, (ef_number )16);
      }
#line 86
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 92
      tmp___2 = __builtin_va_arg(args, char *);
#line 92
      string = tmp___2;
#line 93
      length = strlen(string);
#line 95
      write(2, (void const   *)string, length);
      }
#line 97
      goto switch_break;
      case_100: /* CIL Label */ 
      {
#line 100
      tmp___4 = __builtin_va_arg(args, int );
#line 100
      n = tmp___4;
      }
#line 102
      if (n < 0) {
        {
#line 103
        c___1 = (char )'-';
#line 104
        write(2, (void const   *)(& c___1), (size_t )1);
#line 105
        n = - n;
        }
      }
      {
#line 107
      printNumber((ef_number )n, (ef_number )10);
      }
#line 109
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 111
      tmp___6 = __builtin_va_arg(args, u_int );
#line 111
      printNumber((ef_number )tmp___6, (ef_number )16);
      }
#line 112
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 115
      tmp___8 = __builtin_va_arg(args, int );
#line 115
      c___2 = (char )tmp___8;
#line 117
      write(2, (void const   *)(& c___2), (size_t )1);
      }
#line 119
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 122
      EF_Print(bad_pattern, (int )c___0);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 128
      write(2, (void const   *)(& c___0), (size_t )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
void EF_Abortv(char const   *pattern , va_list args ) 
{ 


  {
  {
#line 135
  EF_Print("\nElectricFence Aborting: ");
#line 136
  EF_Printv(pattern, args);
#line 137
  EF_Print("\n");
#line 138
  do_abort();
  }
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
void EF_Abort(char const   *pattern  , ...) 
{ 
  va_list args ;

  {
  {
#line 146
  __builtin_va_start(args, pattern);
#line 147
  EF_Abortv(pattern, args);
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
void EF_Exitv(char const   *pattern , va_list args ) 
{ 


  {
  {
#line 154
  EF_Print("\nElectricFence Exiting: ");
#line 155
  EF_Printv(pattern, args);
#line 156
  EF_Print("\n");
#line 162
  _exit(-1);
  }
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
void EF_Exit(char const   *pattern  , ...) 
{ 
  va_list args ;

  {
  {
#line 170
  __builtin_va_start(args, pattern);
#line 172
  EF_Exitv(pattern, args);
  }
#line 174
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
void EF_Print(char const   *pattern  , ...) 
{ 
  va_list args ;

  {
  {
#line 181
  __builtin_va_start(args, pattern);
#line 182
  EF_Printv(pattern, args);
#line 183
  __builtin_va_end(args);
  }
#line 184
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
void EF_InternalError(char const   *pattern  , ...) 
{ 
  va_list args ;

  {
  {
#line 191
  EF_Print("\nInternal error in allocator: ");
#line 192
  __builtin_va_start(args, pattern);
#line 193
  EF_Printv(pattern, args);
#line 194
  EF_Print("\n");
#line 196
  __builtin_va_end(args);
#line 197
  do_abort();
  }
#line 198
  return;
}
}
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static sigjmp_buf env  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static void segmentationFaultHandler(int signalNumber ) 
{ 


  {
  {
#line 45
  signal(11, (void (*)(int  ))0);
#line 49
  siglongjmp((struct __jmp_buf_tag *)(env), 1);
  }
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int gotSegmentationFault(int (*test)(void) ) 
{ 
  int status ;
  int tmp ;

  {
  {
#line 55
  tmp = __sigsetjmp((struct __jmp_buf_tag *)(env), 1);
  }
#line 55
  if (tmp == 0) {
    {
#line 58
    signal(11, & segmentationFaultHandler);
#line 65
    status = (*test)();
#line 66
    signal(11, (void (*)(int  ))0);
    }
#line 70
    return (status);
  } else {
#line 73
    return (1);
  }
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static char *allocation  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
char c  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int testSizes(void) 
{ 


  {
#line 88
  return (sizeof(ef_number ) < sizeof(void *));
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int allocateMemory(void) 
{ 
  void *tmp ;

  {
  {
#line 94
  tmp = malloc((size_t )1);
#line 94
  allocation = (char *)tmp;
  }
#line 96
  if ((unsigned long )allocation != (unsigned long )((char *)0)) {
#line 97
    return (0);
  } else {
#line 99
    return (1);
  }
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int freeMemory(void) 
{ 


  {
  {
#line 105
  free((void *)allocation);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int protectBelow(void) 
{ 


  {
#line 112
  EF_PROTECT_BELOW = 1;
#line 113
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int read0(void) 
{ 


  {
#line 119
  c = *allocation;
#line 121
  return (0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int write0(void) 
{ 


  {
#line 127
  *allocation = (char)1;
#line 129
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int read1(void) 
{ 


  {
#line 135
  c = *(allocation + 1);
#line 137
  return (0);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static int readMinus1(void) 
{ 


  {
#line 143
  c = *(allocation + -1);
#line 144
  return (0);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static struct diagnostic diagnostics[12]  = 
#line 147
  {      {& testSizes, 0, "Please add -DLONG_LONG to the compiler flags and recompile."}, 
        {& allocateMemory,
      0, "Allocation 1: This test allocates a single byte of memory."}, 
        {& read0, 0, "Read valid memory 1: This test reads the allocated memory."}, 
        {& write0, 0, "Write valid memory 1: This test writes the allocated memory."}, 
        {& read1,
      1, "Read overrun: This test reads beyond the end of the buffer."}, 
        {& freeMemory, 0, "Free memory: This test frees the allocated memory."}, 
        {& protectBelow, 0, "Protect below: This sets Electric Fence to protect\nthe lower boundary of a malloc buffer, rather than the\nupper boundary."}, 
        {& allocateMemory,
      0, "Allocation 2: This allocates memory with the lower boundary protected."}, 
        {& read0,
      0, "Read valid memory 2: This test reads the allocated memory."}, 
        {& write0, 0, "Write valid memory 2: This test writes the allocated memory."}, 
        {& readMinus1,
      1, "Read underrun: This test reads before the beginning of the buffer."}, 
        {(int (*)(void))0, 0, (char const   *)0}};
#line 201 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static char const   failedTest[40]  = 
#line 201
  {      (char const   )'E',      (char const   )'l',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'c', 
        (char const   )' ',      (char const   )'F',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'f',      (char const   )'i', 
        (char const   )'d',      (char const   )'e',      (char const   )'n',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )'t',      (char const   )' ',      (char const   )'f', 
        (char const   )'a',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'d',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 204 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static char const   newline  =    (char const   )'\n';
#line 209
int main(int argc , char **argv ) ;
#line 209 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
static struct diagnostic  const  *diag  =    (struct diagnostic  const  *)(diagnostics);
#line 206 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/eftest.c"
int main(int argc , char **argv ) 
{ 
  int status ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 212
  EF_PROTECT_BELOW = 0;
#line 213
  EF_ALIGNMENT = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((unsigned long )diag->explanation != (unsigned long )((char const   */* const  */)0))) {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp = gotSegmentationFault((int (*)(void))diag->test);
#line 216
    status = tmp;
    }
#line 218
    if (status != (int )diag->expectedStatus) {
      {
#line 225
      write(2, (void const   *)(failedTest), sizeof(failedTest) - 1UL);
#line 226
      tmp___0 = strlen((char const   *)diag->explanation);
#line 226
      write(2, (void const   *)diag->explanation, tmp___0);
#line 227
      write(2, (void const   *)(& newline), (size_t )1);
#line 228
      _exit(-1);
      }
    }
#line 230
    diag ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static char const   version___0[79]  = 
#line 51 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
  {      (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'E', 
        (char const   )'l',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'F',      (char const   )'e',      (char const   )'n',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'2',      (char const   )'.', 
        (char const   )'2',      (char const   )' ',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'C',      (char const   )')',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'8',      (char const   )'7', 
        (char const   )'-',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'9',      (char const   )' ',      (char const   )'B',      (char const   )'r', 
        (char const   )'u',      (char const   )'c',      (char const   )'e',      (char const   )' ', 
        (char const   )'P',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'<', 
        (char const   )'b',      (char const   )'r',      (char const   )'u',      (char const   )'c', 
        (char const   )'e',      (char const   )'@',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'.',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'>',      (char const   )'\n',      (char const   )'\000'};
#line 86
static void *memalign_locked___0(size_t alignment , size_t userSize ) ;
#line 87
static void free_locked___0(void *address ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *allocationList___0  =    (Slot *)0;
#line 154 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t allocationListSize___0  =    (size_t )0;
#line 159 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t slotCount___0  =    (size_t )0;
#line 166 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t unUsedSlots___0  =    (size_t )0;
#line 172 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t slotsPerPage___0  =    (size_t )0;
#line 178 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int internalUse___0  =    0;
#line 186 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int noAllocationListProtection___0  =    0;
#line 192
#pragma weak sem_init
#line 193
#pragma weak sem_post
#line 194
#pragma weak sem_wait
#line 196 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int pthread_initialization___0  =    0;
#line 204 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static sem_t EF_sem___0  =    {{(char)0}};
#line 205 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int semEnabled___0  =    0;
#line 212 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t bytesPerPage___0  =    (size_t )0;
#line 214 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void lock___0(void) 
{ 
  int tmp ;

  {
#line 219
  if (! semEnabled___0) {
#line 220
    return;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    tmp = sem_wait(& EF_sem___0);
    }
#line 223
    if (! (tmp < 0)) {
#line 223
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void release___0(void) 
{ 
  int tmp ;

  {
#line 233
  if (! semEnabled___0) {
#line 234
    return;
  }
  {
#line 235
  tmp = sem_post(& EF_sem___0);
  }
#line 235
  if (tmp < 0) {
    {
#line 236
    EF_InternalError("Failed to post the semaphore.");
    }
  }
#line 238
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void initialize___0(void) 
{ 
  size_t size ;
  size_t slack ;
  char *string ;
  Slot *slot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;

  {
#line 247
  size = (size_t )1048576;
#line 252
  if (EF_DISABLE_BANNER == -1) {
    {
#line 253
    string = getenv("EF_DISABLE_BANNER");
    }
#line 253
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 254
      EF_DISABLE_BANNER = atoi((char const   *)string);
      }
    } else {
#line 256
      EF_DISABLE_BANNER = 0;
    }
  }
#line 259
  if (EF_DISABLE_BANNER == 0) {
    {
#line 260
    EF_Print(version___0);
    }
  }
#line 264
  if ((unsigned long )(& sem_init) != (unsigned long )((void *)0)) {
#line 264
    if (! pthread_initialization___0) {
      {
#line 264
      tmp = sem_init(& EF_sem___0, 0, 1U);
      }
#line 264
      if (tmp >= 0) {
#line 265
        semEnabled___0 = 1;
      }
    }
  }
  {
#line 268
  lock___0();
  }
#line 289
  if (EF_ALIGNMENT == -1) {
    {
#line 290
    string = getenv("EF_ALIGNMENT");
    }
#line 290
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 291
      tmp___0 = atoi((char const   *)string);
#line 291
      EF_ALIGNMENT = (int )((size_t )tmp___0);
      }
    } else {
#line 293
      EF_ALIGNMENT = (int )sizeof(int );
    }
  }
#line 300
  if (EF_PROTECT_BELOW == -1) {
    {
#line 301
    string = getenv("EF_PROTECT_BELOW");
    }
#line 301
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 302
      tmp___1 = atoi((char const   *)string);
#line 302
      EF_PROTECT_BELOW = tmp___1 != 0;
      }
    } else {
#line 304
      EF_PROTECT_BELOW = 0;
    }
  }
#line 311
  if (EF_PROTECT_FREE == -1) {
    {
#line 312
    string = getenv("EF_PROTECT_FREE");
    }
#line 312
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 313
      tmp___2 = atoi((char const   *)string);
#line 313
      EF_PROTECT_FREE = tmp___2 != 0;
      }
    } else {
#line 315
      EF_PROTECT_FREE = 0;
    }
  }
#line 321
  if (EF_ALLOW_MALLOC_0 == -1) {
    {
#line 322
    string = getenv("EF_ALLOW_MALLOC_0");
    }
#line 322
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 323
      tmp___3 = atoi((char const   *)string);
#line 323
      EF_ALLOW_MALLOC_0 = tmp___3 != 0;
      }
    } else {
#line 325
      EF_ALLOW_MALLOC_0 = 0;
    }
  }
#line 331
  if (EF_FILL == -1) {
    {
#line 332
    string = getenv("EF_FILL");
    }
#line 332
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 333
      tmp___4 = atoi((char const   *)string);
#line 333
      EF_FILL = (int )((unsigned char )tmp___4);
      }
    }
  }
  {
#line 339
  bytesPerPage___0 = Page_Size();
#line 344
  slotsPerPage___0 = bytesPerPage___0 / sizeof(Slot );
#line 344
  slotCount___0 = slotsPerPage___0;
#line 345
  allocationListSize___0 = bytesPerPage___0;
  }
#line 347
  if (allocationListSize___0 > size) {
#line 348
    size = allocationListSize___0;
  }
#line 350
  slack = size % bytesPerPage___0;
#line 350
  if (slack != 0UL) {
#line 351
    size += bytesPerPage___0 - slack;
  }
  {
#line 358
  tmp___5 = Page_Create(size);
#line 358
  allocationList___0 = (Slot *)tmp___5;
#line 358
  slot = allocationList___0;
#line 359
  memset((void *)((char *)allocationList___0), 0, allocationListSize___0);
#line 361
  tmp___6 = allocationListSize___0;
#line 361
  (slot + 0)->userSize = tmp___6;
#line 361
  (slot + 0)->internalSize = tmp___6;
#line 362
  tmp___7 = (void *)allocationList___0;
#line 362
  (slot + 0)->userAddress = tmp___7;
#line 362
  (slot + 0)->internalAddress = tmp___7;
#line 363
  (slot + 0)->mode = (Mode )4;
  }
#line 364
  if (size > allocationListSize___0) {
#line 365
    tmp___8 = (void *)((char *)(slot + 0)->internalAddress + (slot + 0)->internalSize);
#line 365
    (slot + 1)->userAddress = tmp___8;
#line 365
    (slot + 1)->internalAddress = tmp___8;
#line 367
    tmp___9 = size - (slot + 0)->internalSize;
#line 367
    (slot + 1)->userSize = tmp___9;
#line 367
    (slot + 1)->internalSize = tmp___9;
#line 369
    (slot + 1)->mode = (Mode )1;
  }
  {
#line 376
  Page_DenyAccess((slot + 1)->internalAddress, (slot + 1)->internalSize);
#line 381
  unUsedSlots___0 = slotCount___0 - 2UL;
#line 383
  release___0();
  }
#line 384
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void allocateMoreSlots___0(void) 
{ 
  size_t newSize ;
  void *newAllocation ;
  void *oldAllocation ;

  {
  {
#line 408
  newSize = allocationListSize___0 + bytesPerPage___0;
#line 410
  oldAllocation = (void *)allocationList___0;
#line 412
  Page_AllowAccess((void *)allocationList___0, allocationListSize___0);
#line 413
  noAllocationListProtection___0 = 1;
#line 414
  internalUse___0 = 1;
#line 416
  newAllocation = memalign_locked___0((size_t )EF_ALIGNMENT, newSize);
#line 417
  memcpy((void */* __restrict  */)newAllocation, (void const   */* __restrict  */)allocationList___0,
         allocationListSize___0);
#line 418
  memset((void *)((char *)newAllocation + allocationListSize___0), 0, bytesPerPage___0);
#line 420
  allocationList___0 = (Slot *)newAllocation;
#line 421
  allocationListSize___0 = newSize;
#line 422
  slotCount___0 += slotsPerPage___0;
#line 423
  unUsedSlots___0 += slotsPerPage___0;
#line 425
  free_locked___0(oldAllocation);
#line 431
  noAllocationListProtection___0 = 0;
#line 432
  internalUse___0 = 0;
  }
#line 433
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void *memalign_locked___0(size_t alignment , size_t userSize ) 
{ 
  register Slot *slot ;
  register size_t count ;
  Slot *fullSlot ;
  Slot *emptySlots[2] ;
  size_t internalSize ;
  size_t slack ;
  char *address ;
  size_t chunkSize ;

  {
#line 462
  fullSlot = (Slot *)0;
#line 468
  if (userSize == 0UL) {
#line 468
    if (! EF_ALLOW_MALLOC_0) {
      {
#line 469
      EF_Abort("Allocating 0 bytes, probably a bug.");
      }
    }
  }
#line 475
  if (! EF_PROTECT_BELOW) {
#line 475
    if (alignment > 1UL) {
#line 476
      slack = userSize % alignment;
#line 476
      if (slack != 0UL) {
#line 477
        userSize += alignment - slack;
      }
    }
  }
#line 485
  internalSize = userSize + bytesPerPage___0;
#line 486
  slack = internalSize % bytesPerPage___0;
#line 486
  if (slack != 0UL) {
#line 487
    internalSize += bytesPerPage___0 - slack;
  }
#line 494
  emptySlots[0] = (Slot *)0;
#line 495
  emptySlots[1] = (Slot *)0;
#line 503
  if (! noAllocationListProtection___0) {
    {
#line 504
    Page_AllowAccess((void *)allocationList___0, allocationListSize___0);
    }
  }
#line 510
  if (! internalUse___0) {
#line 510
    if (unUsedSlots___0 < 7UL) {
      {
#line 511
      allocateMoreSlots___0();
      }
    }
  }
#line 524
  slot = allocationList___0;
#line 524
  count = slotCount___0;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (count > 0UL)) {
#line 524
      goto while_break;
    }
#line 525
    if ((unsigned int )slot->mode == 1U) {
#line 525
      if (slot->internalSize >= internalSize) {
#line 527
        if (! fullSlot) {
#line 527
          goto _L;
        } else
#line 527
        if (slot->internalSize < fullSlot->internalSize) {
          _L: /* CIL Label */ 
#line 529
          fullSlot = slot;
#line 530
          if (slot->internalSize == internalSize) {
#line 530
            if (emptySlots[0]) {
#line 532
              goto while_break;
            }
          }
        }
      } else {
#line 525
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 535
    if ((unsigned int )slot->mode == 0U) {
#line 536
      if (! emptySlots[0]) {
#line 537
        emptySlots[0] = slot;
      } else
#line 538
      if (! emptySlots[1]) {
#line 539
        emptySlots[1] = slot;
      } else
#line 540
      if (fullSlot) {
#line 540
        if (fullSlot->internalSize == internalSize) {
#line 542
          goto while_break;
        }
      }
    }
#line 544
    slot ++;
#line 524
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  if (! emptySlots[0]) {
    {
#line 547
    EF_InternalError("No empty slot 0.");
    }
  }
#line 549
  if (! fullSlot) {
#line 556
    chunkSize = (size_t )1048576;
#line 558
    if (! emptySlots[1]) {
      {
#line 559
      EF_InternalError("No empty slot 1.");
      }
    }
#line 561
    if (chunkSize < internalSize) {
#line 562
      chunkSize = internalSize;
    }
#line 564
    slack = chunkSize % bytesPerPage___0;
#line 564
    if (slack != 0UL) {
#line 565
      chunkSize += bytesPerPage___0 - slack;
    }
    {
#line 568
    fullSlot = emptySlots[0];
#line 569
    emptySlots[0] = emptySlots[1];
#line 570
    fullSlot->internalAddress = Page_Create(chunkSize);
#line 571
    fullSlot->internalSize = chunkSize;
#line 572
    fullSlot->mode = (Mode )1;
#line 573
    unUsedSlots___0 --;
    }
#line 576
    if (EF_FILL != -1) {
      {
#line 577
      memset((void *)((char *)fullSlot->internalAddress), EF_FILL, chunkSize);
      }
    }
  }
#line 588
  if (internalUse___0) {
#line 589
    fullSlot->mode = (Mode )4;
  } else {
#line 591
    fullSlot->mode = (Mode )2;
  }
#line 598
  if (fullSlot->internalSize > internalSize) {
#line 599
    (emptySlots[0])->internalSize = fullSlot->internalSize - internalSize;
#line 601
    (emptySlots[0])->internalAddress = (void *)((char *)fullSlot->internalAddress + internalSize);
#line 603
    (emptySlots[0])->mode = (Mode )1;
#line 604
    fullSlot->internalSize = internalSize;
#line 605
    unUsedSlots___0 --;
  }
#line 608
  if (! EF_PROTECT_BELOW) {
#line 614
    address = (char *)fullSlot->internalAddress;
#line 617
    if (internalSize - bytesPerPage___0 > 0UL) {
      {
#line 618
      Page_AllowAccess(fullSlot->internalAddress, internalSize - bytesPerPage___0);
      }
    }
    {
#line 622
    address += internalSize - bytesPerPage___0;
#line 625
    Page_Delete((void *)address, bytesPerPage___0);
#line 628
    address -= userSize;
    }
  } else {
    {
#line 636
    address = (char *)fullSlot->internalAddress;
#line 639
    Page_Delete((void *)address, bytesPerPage___0);
#line 641
    address += bytesPerPage___0;
    }
#line 644
    if (internalSize - bytesPerPage___0 > 0UL) {
      {
#line 645
      Page_AllowAccess((void *)address, internalSize - bytesPerPage___0);
      }
    }
  }
#line 648
  fullSlot->userAddress = (void *)address;
#line 649
  fullSlot->userSize = userSize;
#line 655
  if (! internalUse___0) {
    {
#line 656
    Page_DenyAccess((void *)allocationList___0, allocationListSize___0);
    }
  }
#line 658
  return ((void *)address);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForUserAddress___0(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 700
  slot = allocationList___0;
#line 701
  count = slotCount___0;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! (count > 0UL)) {
#line 703
      goto while_break;
    }
#line 704
    if ((unsigned long )slot->userAddress == (unsigned long )address) {
#line 705
      return (slot);
    }
#line 706
    slot ++;
#line 703
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return ((Slot *)0);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForInternalAddress___0(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 718
  slot = allocationList___0;
#line 719
  count = slotCount___0;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (count > 0UL)) {
#line 721
      goto while_break;
    }
#line 722
    if ((unsigned long )slot->internalAddress == (unsigned long )address) {
#line 723
      return (slot);
    }
#line 724
    slot ++;
#line 721
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  return ((Slot *)0);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForInternalAddressPreviousTo___0(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 737
  slot = allocationList___0;
#line 738
  count = slotCount___0;
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! (count > 0UL)) {
#line 740
      goto while_break;
    }
#line 741
    if ((unsigned long )((char *)slot->internalAddress + slot->internalSize) == (unsigned long )address) {
#line 743
      return (slot);
    }
#line 744
    slot ++;
#line 740
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  return ((Slot *)0);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void free_locked___0(void *address ) 
{ 
  Slot *slot ;
  Slot *previousSlot ;
  Slot *nextSlot ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 753
  previousSlot = (Slot *)0;
#line 754
  nextSlot = (Slot *)0;
#line 756
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 757
    return;
  }
#line 759
  if (! noAllocationListProtection___0) {
    {
#line 760
    Page_AllowAccess((void *)allocationList___0, allocationListSize___0);
    }
  }
  {
#line 762
  slot = slotForUserAddress___0(address);
  }
#line 764
  if (! slot) {
    {
#line 765
    EF_Abort("free(%a): address not from malloc().", address);
    }
  }
#line 767
  if ((unsigned int )slot->mode != 2U) {
#line 768
    if (internalUse___0) {
#line 768
      if (! ((unsigned int )slot->mode == 4U)) {
        {
#line 771
        EF_Abort("free(%a): freeing free memory.", address);
        }
      }
    } else {
      {
#line 771
      EF_Abort("free(%a): freeing free memory.", address);
      }
    }
  }
#line 777
  if (EF_PROTECT_FREE) {
#line 778
    slot->mode = (Mode )3;
  } else {
#line 780
    slot->mode = (Mode )1;
  }
  {
#line 796
  Page_Delete(slot->internalAddress, slot->internalSize);
#line 798
  previousSlot = slotForInternalAddressPreviousTo___0(slot->internalAddress);
#line 799
  nextSlot = slotForInternalAddress___0((void *)((char *)slot->internalAddress + slot->internalSize));
  }
#line 802
  if (previousSlot) {
#line 802
    if ((unsigned int )previousSlot->mode == (unsigned int )slot->mode) {
#line 804
      previousSlot->internalSize += slot->internalSize;
#line 805
      tmp = (void *)0;
#line 805
      slot->userAddress = tmp;
#line 805
      slot->internalAddress = tmp;
#line 806
      tmp___0 = (size_t )0;
#line 806
      slot->userSize = tmp___0;
#line 806
      slot->internalSize = tmp___0;
#line 807
      slot->mode = (Mode )0;
#line 808
      slot = previousSlot;
#line 809
      unUsedSlots___0 ++;
    }
  }
#line 811
  if (nextSlot) {
#line 811
    if ((unsigned int )nextSlot->mode == (unsigned int )slot->mode) {
#line 813
      slot->internalSize += nextSlot->internalSize;
#line 814
      tmp___1 = (void *)0;
#line 814
      nextSlot->userAddress = tmp___1;
#line 814
      nextSlot->internalAddress = tmp___1;
#line 815
      tmp___2 = (size_t )0;
#line 815
      nextSlot->userSize = tmp___2;
#line 815
      nextSlot->internalSize = tmp___2;
#line 816
      nextSlot->mode = (Mode )0;
#line 817
      unUsedSlots___0 ++;
    }
  }
#line 820
  slot->userAddress = slot->internalAddress;
#line 821
  slot->userSize = slot->internalSize;
#line 823
  if (! noAllocationListProtection___0) {
    {
#line 824
    Page_DenyAccess((void *)allocationList___0, allocationListSize___0);
    }
  }
#line 825
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static void do_abort___0(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 28
  tmp = getpid();
#line 28
  kill(tmp, 4);
#line 30
  _exit(-1);
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static void printNumber___0(ef_number number , ef_number base ) 
{ 
  char buffer[sizeof(ef_number ) * 8UL] ;
  char *s ;
  int size ;
  ef_number digit ;

  {
#line 37
  s = & buffer[sizeof(ef_number ) * 8UL];
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    s --;
#line 43
    if ((unsigned long )s == (unsigned long )(buffer)) {
      {
#line 44
      EF_Abort("Internal error printing number.");
      }
    }
#line 46
    digit = number % base;
#line 48
    if (digit < 10UL) {
#line 49
      *s = (char )(48UL + digit);
    } else {
#line 51
      *s = (char )((97UL + digit) - 10UL);
    }
#line 40
    number /= base;
#line 40
    if (! (number > 0UL)) {
#line 40
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  size = (int )(& buffer[sizeof(ef_number ) * 8UL] - s);
#line 57
  if (size > 0) {
    {
#line 58
    write(2, (void const   *)s, (size_t )size);
    }
  }
#line 59
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static char const   bad_pattern___0[44]  = 
#line 64
  {      (char const   )'\n',      (char const   )'B',      (char const   )'a',      (char const   )'d', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'t', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'n', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'%', 
        (char const   )'%',      (char const   )'%',      (char const   )'c',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'E', 
        (char const   )'F',      (char const   )'_',      (char const   )'P',      (char const   )'r', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'(', 
        (char const   )')',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static caddr_t startAddr___0  =    (caddr_t )0;
#line 37 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static char const   *stringErrorReport___0(void) 
{ 
  char err_message[128] ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 46
  tmp = __errno_location();
#line 46
  tmp___0 = strerror_r(*tmp, err_message, (size_t )128);
  }
#line 46
  return ((char const   *)tmp___0);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static void mprotectFailed___0(void) 
{ 
  char const   *tmp ;

  {
  {
#line 141
  tmp = stringErrorReport___0();
#line 141
  EF_Exit("mprotect() failed: %s", tmp);
  }
#line 142
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static caddr_t startAddr___1  =    (caddr_t )0;
#line 37 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static char const   *stringErrorReport___1(void) 
{ 
  char err_message[128] ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 46
  tmp = __errno_location();
#line 46
  tmp___0 = strerror_r(*tmp, err_message, (size_t )128);
  }
#line 46
  return ((char const   *)tmp___0);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/page.c"
static void mprotectFailed___1(void) 
{ 
  char const   *tmp ;

  {
  {
#line 141
  tmp = stringErrorReport___1();
#line 141
  EF_Exit("mprotect() failed: %s", tmp);
  }
#line 142
  return;
}
}
#line 389 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) drand48)(void) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/tstheap.c"
void *pool[1024]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static char const   version___1[79]  = 
#line 51 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
  {      (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'E', 
        (char const   )'l',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'F',      (char const   )'e',      (char const   )'n',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'2',      (char const   )'.', 
        (char const   )'2',      (char const   )' ',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'C',      (char const   )')',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'8',      (char const   )'7', 
        (char const   )'-',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'9',      (char const   )' ',      (char const   )'B',      (char const   )'r', 
        (char const   )'u',      (char const   )'c',      (char const   )'e',      (char const   )' ', 
        (char const   )'P',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'<', 
        (char const   )'b',      (char const   )'r',      (char const   )'u',      (char const   )'c', 
        (char const   )'e',      (char const   )'@',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'.',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'>',      (char const   )'\n',      (char const   )'\000'};
#line 86
static void *memalign_locked___1(size_t alignment , size_t userSize ) ;
#line 87
static void free_locked___1(void *address ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *allocationList___1  =    (Slot *)0;
#line 154 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t allocationListSize___1  =    (size_t )0;
#line 159 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t slotCount___1  =    (size_t )0;
#line 166 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t unUsedSlots___1  =    (size_t )0;
#line 172 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t slotsPerPage___1  =    (size_t )0;
#line 178 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int internalUse___1  =    0;
#line 186 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int noAllocationListProtection___1  =    0;
#line 192
#pragma weak sem_init
#line 193
#pragma weak sem_post
#line 194
#pragma weak sem_wait
#line 196 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int pthread_initialization___1  =    0;
#line 204 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static sem_t EF_sem___1  =    {{(char)0}};
#line 205 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static int semEnabled___1  =    0;
#line 212 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static size_t bytesPerPage___1  =    (size_t )0;
#line 214 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void lock___1(void) 
{ 
  int tmp ;

  {
#line 219
  if (! semEnabled___1) {
#line 220
    return;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    tmp = sem_wait(& EF_sem___1);
    }
#line 223
    if (! (tmp < 0)) {
#line 223
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void release___1(void) 
{ 
  int tmp ;

  {
#line 233
  if (! semEnabled___1) {
#line 234
    return;
  }
  {
#line 235
  tmp = sem_post(& EF_sem___1);
  }
#line 235
  if (tmp < 0) {
    {
#line 236
    EF_InternalError("Failed to post the semaphore.");
    }
  }
#line 238
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void initialize___1(void) 
{ 
  size_t size ;
  size_t slack ;
  char *string ;
  Slot *slot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;

  {
#line 247
  size = (size_t )1048576;
#line 252
  if (EF_DISABLE_BANNER == -1) {
    {
#line 253
    string = getenv("EF_DISABLE_BANNER");
    }
#line 253
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 254
      EF_DISABLE_BANNER = atoi((char const   *)string);
      }
    } else {
#line 256
      EF_DISABLE_BANNER = 0;
    }
  }
#line 259
  if (EF_DISABLE_BANNER == 0) {
    {
#line 260
    EF_Print(version___1);
    }
  }
#line 264
  if ((unsigned long )(& sem_init) != (unsigned long )((void *)0)) {
#line 264
    if (! pthread_initialization___1) {
      {
#line 264
      tmp = sem_init(& EF_sem___1, 0, 1U);
      }
#line 264
      if (tmp >= 0) {
#line 265
        semEnabled___1 = 1;
      }
    }
  }
  {
#line 268
  lock___1();
  }
#line 289
  if (EF_ALIGNMENT == -1) {
    {
#line 290
    string = getenv("EF_ALIGNMENT");
    }
#line 290
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 291
      tmp___0 = atoi((char const   *)string);
#line 291
      EF_ALIGNMENT = (int )((size_t )tmp___0);
      }
    } else {
#line 293
      EF_ALIGNMENT = (int )sizeof(int );
    }
  }
#line 300
  if (EF_PROTECT_BELOW == -1) {
    {
#line 301
    string = getenv("EF_PROTECT_BELOW");
    }
#line 301
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 302
      tmp___1 = atoi((char const   *)string);
#line 302
      EF_PROTECT_BELOW = tmp___1 != 0;
      }
    } else {
#line 304
      EF_PROTECT_BELOW = 0;
    }
  }
#line 311
  if (EF_PROTECT_FREE == -1) {
    {
#line 312
    string = getenv("EF_PROTECT_FREE");
    }
#line 312
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 313
      tmp___2 = atoi((char const   *)string);
#line 313
      EF_PROTECT_FREE = tmp___2 != 0;
      }
    } else {
#line 315
      EF_PROTECT_FREE = 0;
    }
  }
#line 321
  if (EF_ALLOW_MALLOC_0 == -1) {
    {
#line 322
    string = getenv("EF_ALLOW_MALLOC_0");
    }
#line 322
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 323
      tmp___3 = atoi((char const   *)string);
#line 323
      EF_ALLOW_MALLOC_0 = tmp___3 != 0;
      }
    } else {
#line 325
      EF_ALLOW_MALLOC_0 = 0;
    }
  }
#line 331
  if (EF_FILL == -1) {
    {
#line 332
    string = getenv("EF_FILL");
    }
#line 332
    if ((unsigned long )string != (unsigned long )((char *)0)) {
      {
#line 333
      tmp___4 = atoi((char const   *)string);
#line 333
      EF_FILL = (int )((unsigned char )tmp___4);
      }
    }
  }
  {
#line 339
  bytesPerPage___1 = Page_Size();
#line 344
  slotsPerPage___1 = bytesPerPage___1 / sizeof(Slot );
#line 344
  slotCount___1 = slotsPerPage___1;
#line 345
  allocationListSize___1 = bytesPerPage___1;
  }
#line 347
  if (allocationListSize___1 > size) {
#line 348
    size = allocationListSize___1;
  }
#line 350
  slack = size % bytesPerPage___1;
#line 350
  if (slack != 0UL) {
#line 351
    size += bytesPerPage___1 - slack;
  }
  {
#line 358
  tmp___5 = Page_Create(size);
#line 358
  allocationList___1 = (Slot *)tmp___5;
#line 358
  slot = allocationList___1;
#line 359
  memset((void *)((char *)allocationList___1), 0, allocationListSize___1);
#line 361
  tmp___6 = allocationListSize___1;
#line 361
  (slot + 0)->userSize = tmp___6;
#line 361
  (slot + 0)->internalSize = tmp___6;
#line 362
  tmp___7 = (void *)allocationList___1;
#line 362
  (slot + 0)->userAddress = tmp___7;
#line 362
  (slot + 0)->internalAddress = tmp___7;
#line 363
  (slot + 0)->mode = (Mode )4;
  }
#line 364
  if (size > allocationListSize___1) {
#line 365
    tmp___8 = (void *)((char *)(slot + 0)->internalAddress + (slot + 0)->internalSize);
#line 365
    (slot + 1)->userAddress = tmp___8;
#line 365
    (slot + 1)->internalAddress = tmp___8;
#line 367
    tmp___9 = size - (slot + 0)->internalSize;
#line 367
    (slot + 1)->userSize = tmp___9;
#line 367
    (slot + 1)->internalSize = tmp___9;
#line 369
    (slot + 1)->mode = (Mode )1;
  }
  {
#line 376
  Page_DenyAccess((slot + 1)->internalAddress, (slot + 1)->internalSize);
#line 381
  unUsedSlots___1 = slotCount___1 - 2UL;
#line 383
  release___1();
  }
#line 384
  return;
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void allocateMoreSlots___1(void) 
{ 
  size_t newSize ;
  void *newAllocation ;
  void *oldAllocation ;

  {
  {
#line 408
  newSize = allocationListSize___1 + bytesPerPage___1;
#line 410
  oldAllocation = (void *)allocationList___1;
#line 412
  Page_AllowAccess((void *)allocationList___1, allocationListSize___1);
#line 413
  noAllocationListProtection___1 = 1;
#line 414
  internalUse___1 = 1;
#line 416
  newAllocation = memalign_locked___1((size_t )EF_ALIGNMENT, newSize);
#line 417
  memcpy((void */* __restrict  */)newAllocation, (void const   */* __restrict  */)allocationList___1,
         allocationListSize___1);
#line 418
  memset((void *)((char *)newAllocation + allocationListSize___1), 0, bytesPerPage___1);
#line 420
  allocationList___1 = (Slot *)newAllocation;
#line 421
  allocationListSize___1 = newSize;
#line 422
  slotCount___1 += slotsPerPage___1;
#line 423
  unUsedSlots___1 += slotsPerPage___1;
#line 425
  free_locked___1(oldAllocation);
#line 431
  noAllocationListProtection___1 = 0;
#line 432
  internalUse___1 = 0;
  }
#line 433
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void *memalign_locked___1(size_t alignment , size_t userSize ) 
{ 
  register Slot *slot ;
  register size_t count ;
  Slot *fullSlot ;
  Slot *emptySlots[2] ;
  size_t internalSize ;
  size_t slack ;
  char *address ;
  size_t chunkSize ;

  {
#line 462
  fullSlot = (Slot *)0;
#line 468
  if (userSize == 0UL) {
#line 468
    if (! EF_ALLOW_MALLOC_0) {
      {
#line 469
      EF_Abort("Allocating 0 bytes, probably a bug.");
      }
    }
  }
#line 475
  if (! EF_PROTECT_BELOW) {
#line 475
    if (alignment > 1UL) {
#line 476
      slack = userSize % alignment;
#line 476
      if (slack != 0UL) {
#line 477
        userSize += alignment - slack;
      }
    }
  }
#line 485
  internalSize = userSize + bytesPerPage___1;
#line 486
  slack = internalSize % bytesPerPage___1;
#line 486
  if (slack != 0UL) {
#line 487
    internalSize += bytesPerPage___1 - slack;
  }
#line 494
  emptySlots[0] = (Slot *)0;
#line 495
  emptySlots[1] = (Slot *)0;
#line 503
  if (! noAllocationListProtection___1) {
    {
#line 504
    Page_AllowAccess((void *)allocationList___1, allocationListSize___1);
    }
  }
#line 510
  if (! internalUse___1) {
#line 510
    if (unUsedSlots___1 < 7UL) {
      {
#line 511
      allocateMoreSlots___1();
      }
    }
  }
#line 524
  slot = allocationList___1;
#line 524
  count = slotCount___1;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (count > 0UL)) {
#line 524
      goto while_break;
    }
#line 525
    if ((unsigned int )slot->mode == 1U) {
#line 525
      if (slot->internalSize >= internalSize) {
#line 527
        if (! fullSlot) {
#line 527
          goto _L;
        } else
#line 527
        if (slot->internalSize < fullSlot->internalSize) {
          _L: /* CIL Label */ 
#line 529
          fullSlot = slot;
#line 530
          if (slot->internalSize == internalSize) {
#line 530
            if (emptySlots[0]) {
#line 532
              goto while_break;
            }
          }
        }
      } else {
#line 525
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 535
    if ((unsigned int )slot->mode == 0U) {
#line 536
      if (! emptySlots[0]) {
#line 537
        emptySlots[0] = slot;
      } else
#line 538
      if (! emptySlots[1]) {
#line 539
        emptySlots[1] = slot;
      } else
#line 540
      if (fullSlot) {
#line 540
        if (fullSlot->internalSize == internalSize) {
#line 542
          goto while_break;
        }
      }
    }
#line 544
    slot ++;
#line 524
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  if (! emptySlots[0]) {
    {
#line 547
    EF_InternalError("No empty slot 0.");
    }
  }
#line 549
  if (! fullSlot) {
#line 556
    chunkSize = (size_t )1048576;
#line 558
    if (! emptySlots[1]) {
      {
#line 559
      EF_InternalError("No empty slot 1.");
      }
    }
#line 561
    if (chunkSize < internalSize) {
#line 562
      chunkSize = internalSize;
    }
#line 564
    slack = chunkSize % bytesPerPage___1;
#line 564
    if (slack != 0UL) {
#line 565
      chunkSize += bytesPerPage___1 - slack;
    }
    {
#line 568
    fullSlot = emptySlots[0];
#line 569
    emptySlots[0] = emptySlots[1];
#line 570
    fullSlot->internalAddress = Page_Create(chunkSize);
#line 571
    fullSlot->internalSize = chunkSize;
#line 572
    fullSlot->mode = (Mode )1;
#line 573
    unUsedSlots___1 --;
    }
#line 576
    if (EF_FILL != -1) {
      {
#line 577
      memset((void *)((char *)fullSlot->internalAddress), EF_FILL, chunkSize);
      }
    }
  }
#line 588
  if (internalUse___1) {
#line 589
    fullSlot->mode = (Mode )4;
  } else {
#line 591
    fullSlot->mode = (Mode )2;
  }
#line 598
  if (fullSlot->internalSize > internalSize) {
#line 599
    (emptySlots[0])->internalSize = fullSlot->internalSize - internalSize;
#line 601
    (emptySlots[0])->internalAddress = (void *)((char *)fullSlot->internalAddress + internalSize);
#line 603
    (emptySlots[0])->mode = (Mode )1;
#line 604
    fullSlot->internalSize = internalSize;
#line 605
    unUsedSlots___1 --;
  }
#line 608
  if (! EF_PROTECT_BELOW) {
#line 614
    address = (char *)fullSlot->internalAddress;
#line 617
    if (internalSize - bytesPerPage___1 > 0UL) {
      {
#line 618
      Page_AllowAccess(fullSlot->internalAddress, internalSize - bytesPerPage___1);
      }
    }
    {
#line 622
    address += internalSize - bytesPerPage___1;
#line 625
    Page_Delete((void *)address, bytesPerPage___1);
#line 628
    address -= userSize;
    }
  } else {
    {
#line 636
    address = (char *)fullSlot->internalAddress;
#line 639
    Page_Delete((void *)address, bytesPerPage___1);
#line 641
    address += bytesPerPage___1;
    }
#line 644
    if (internalSize - bytesPerPage___1 > 0UL) {
      {
#line 645
      Page_AllowAccess((void *)address, internalSize - bytesPerPage___1);
      }
    }
  }
#line 648
  fullSlot->userAddress = (void *)address;
#line 649
  fullSlot->userSize = userSize;
#line 655
  if (! internalUse___1) {
    {
#line 656
    Page_DenyAccess((void *)allocationList___1, allocationListSize___1);
    }
  }
#line 658
  return ((void *)address);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForUserAddress___1(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 700
  slot = allocationList___1;
#line 701
  count = slotCount___1;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! (count > 0UL)) {
#line 703
      goto while_break;
    }
#line 704
    if ((unsigned long )slot->userAddress == (unsigned long )address) {
#line 705
      return (slot);
    }
#line 706
    slot ++;
#line 703
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return ((Slot *)0);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForInternalAddress___1(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 718
  slot = allocationList___1;
#line 719
  count = slotCount___1;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (count > 0UL)) {
#line 721
      goto while_break;
    }
#line 722
    if ((unsigned long )slot->internalAddress == (unsigned long )address) {
#line 723
      return (slot);
    }
#line 724
    slot ++;
#line 721
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  return ((Slot *)0);
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static Slot *slotForInternalAddressPreviousTo___1(void *address ) 
{ 
  register Slot *slot ;
  register size_t count ;

  {
#line 737
  slot = allocationList___1;
#line 738
  count = slotCount___1;
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! (count > 0UL)) {
#line 740
      goto while_break;
    }
#line 741
    if ((unsigned long )((char *)slot->internalAddress + slot->internalSize) == (unsigned long )address) {
#line 743
      return (slot);
    }
#line 744
    slot ++;
#line 740
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  return ((Slot *)0);
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/efence.c"
static void free_locked___1(void *address ) 
{ 
  Slot *slot ;
  Slot *previousSlot ;
  Slot *nextSlot ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 753
  previousSlot = (Slot *)0;
#line 754
  nextSlot = (Slot *)0;
#line 756
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 757
    return;
  }
#line 759
  if (! noAllocationListProtection___1) {
    {
#line 760
    Page_AllowAccess((void *)allocationList___1, allocationListSize___1);
    }
  }
  {
#line 762
  slot = slotForUserAddress___1(address);
  }
#line 764
  if (! slot) {
    {
#line 765
    EF_Abort("free(%a): address not from malloc().", address);
    }
  }
#line 767
  if ((unsigned int )slot->mode != 2U) {
#line 768
    if (internalUse___1) {
#line 768
      if (! ((unsigned int )slot->mode == 4U)) {
        {
#line 771
        EF_Abort("free(%a): freeing free memory.", address);
        }
      }
    } else {
      {
#line 771
      EF_Abort("free(%a): freeing free memory.", address);
      }
    }
  }
#line 777
  if (EF_PROTECT_FREE) {
#line 778
    slot->mode = (Mode )3;
  } else {
#line 780
    slot->mode = (Mode )1;
  }
  {
#line 796
  Page_Delete(slot->internalAddress, slot->internalSize);
#line 798
  previousSlot = slotForInternalAddressPreviousTo___1(slot->internalAddress);
#line 799
  nextSlot = slotForInternalAddress___1((void *)((char *)slot->internalAddress + slot->internalSize));
  }
#line 802
  if (previousSlot) {
#line 802
    if ((unsigned int )previousSlot->mode == (unsigned int )slot->mode) {
#line 804
      previousSlot->internalSize += slot->internalSize;
#line 805
      tmp = (void *)0;
#line 805
      slot->userAddress = tmp;
#line 805
      slot->internalAddress = tmp;
#line 806
      tmp___0 = (size_t )0;
#line 806
      slot->userSize = tmp___0;
#line 806
      slot->internalSize = tmp___0;
#line 807
      slot->mode = (Mode )0;
#line 808
      slot = previousSlot;
#line 809
      unUsedSlots___1 ++;
    }
  }
#line 811
  if (nextSlot) {
#line 811
    if ((unsigned int )nextSlot->mode == (unsigned int )slot->mode) {
#line 813
      slot->internalSize += nextSlot->internalSize;
#line 814
      tmp___1 = (void *)0;
#line 814
      nextSlot->userAddress = tmp___1;
#line 814
      nextSlot->internalAddress = tmp___1;
#line 815
      tmp___2 = (size_t )0;
#line 815
      nextSlot->userSize = tmp___2;
#line 815
      nextSlot->internalSize = tmp___2;
#line 816
      nextSlot->mode = (Mode )0;
#line 817
      unUsedSlots___1 ++;
    }
  }
#line 820
  slot->userAddress = slot->internalAddress;
#line 821
  slot->userSize = slot->internalSize;
#line 823
  if (! noAllocationListProtection___1) {
    {
#line 824
    Page_DenyAccess((void *)allocationList___1, allocationListSize___1);
    }
  }
#line 825
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static void do_abort___1(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 28
  tmp = getpid();
#line 28
  kill(tmp, 4);
#line 30
  _exit(-1);
  }
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static void printNumber___1(ef_number number , ef_number base ) 
{ 
  char buffer[sizeof(ef_number ) * 8UL] ;
  char *s ;
  int size ;
  ef_number digit ;

  {
#line 37
  s = & buffer[sizeof(ef_number ) * 8UL];
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    s --;
#line 43
    if ((unsigned long )s == (unsigned long )(buffer)) {
      {
#line 44
      EF_Abort("Internal error printing number.");
      }
    }
#line 46
    digit = number % base;
#line 48
    if (digit < 10UL) {
#line 49
      *s = (char )(48UL + digit);
    } else {
#line 51
      *s = (char )((97UL + digit) - 10UL);
    }
#line 40
    number /= base;
#line 40
    if (! (number > 0UL)) {
#line 40
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  size = (int )(& buffer[sizeof(ef_number ) * 8UL] - s);
#line 57
  if (size > 0) {
    {
#line 58
    write(2, (void const   *)s, (size_t )size);
    }
  }
#line 59
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/electric-fence-2.2.4/print.c"
static char const   bad_pattern___1[44]  = 
#line 64
  {      (char const   )'\n',      (char const   )'B',      (char const   )'a',      (char const   )'d', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'t', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'n', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'%', 
        (char const   )'%',      (char const   )'%',      (char const   )'c',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'E', 
        (char const   )'F',      (char const   )'_',      (char const   )'P',      (char const   )'r', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'(', 
        (char const   )')',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
